pragma solidity ^0.4.21;

/// @author Luis Freitas, Miguel Amaral (https://repop.world)
contract REPOPAccessControl {
    address public ceoAddress;
    address public cfoAddress;
    address public cooAddress;

    bool public paused = false;

    modifier onlyCEO() {
        require(msg.sender == ceoAddress);
        _;
    }

    modifier onlyCFO() {
        require(msg.sender == cfoAddress);
        _;
    }

    modifier onlyCOO() {
        require(msg.sender == cooAddress);
        _;
    }

    modifier onlyCLevel() {
        require(
            msg.sender == cooAddress ||
            msg.sender == ceoAddress ||
            msg.sender == cfoAddress
        );
        _;
    }

    function setCEO(address _newCEO) external onlyCEO {
        require(_newCEO != address(0));

        ceoAddress = _newCEO;
    }

    function setCFO(address _newCFO) external onlyCEO {
        require(_newCFO != address(0));

        cfoAddress = _newCFO;
    }

    function setCOO(address _newCOO) external onlyCEO {
        require(_newCOO != address(0));

        cooAddress = _newCOO;
    }

    modifier whenNotPaused() {
        require(!paused);
        _;
    }

    modifier whenPaused {
        require(paused);
        _;
    }

    function pause() external onlyCLevel whenNotPaused {
        paused = true;
    }

    function unpause() public onlyCEO whenPaused {

        paused = false;
    }
}

contract PullPayment {
  mapping(address => uint) public payments;

  function asyncSend(address dest, uint amount) internal {
    payments[dest] += amount;
  }

  function withdrawPayments() external {
    uint payment = payments[msg.sender];
    payments[msg.sender] = 0;
    if (!msg.sender.send(payment)) {
      payments[msg.sender] = payment;
    }
  }
}


/// @author Dieter Shirley <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="d0b4b5a4b590b1a8b9bfbdaab5befeb3bf">[emailÂ protected]</a>&gt; (https://github.com/dete)&#13;
contract ERC721 {&#13;
&#13;
  function approve(address _to, uint256 _tokenId) public;&#13;
  function balanceOf(address _owner) public view returns (uint256 balance);&#13;
  function implementsERC721() public pure returns (bool);&#13;
  function ownerOf(uint256 _tokenId) public view returns (address addr);&#13;
  function takeOwnership(uint256 _tokenId) public;&#13;
  function totalSupply() public view returns (uint256 total);&#13;
  function transferFrom(address _from, address _to, uint256 _tokenId) public;&#13;
  function transfer(address _to, uint256 _tokenId) public;&#13;
  function tokenMetadata(uint256 _tokenId) public view returns (string infoUrl);&#13;
&#13;
  event Transfer(address indexed from, address indexed to, uint256 tokenId);&#13;
  event Approval(address indexed owner, address indexed approved, uint256 tokenId);&#13;
  function supportsInterface(bytes4 _interfaceID) external view returns (bool);&#13;
}&#13;
&#13;
library SafeMath {&#13;
&#13;
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
    if (a == 0) {&#13;
      return 0;&#13;
    }&#13;
    uint256 c = a * b;&#13;
    assert(c / a == b);&#13;
    return c;&#13;
  }&#13;
&#13;
  function div(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
    // assert(b &gt; 0); // Solidity automatically throws when dividing by 0&#13;
    uint256 c = a / b;&#13;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold&#13;
    return c;&#13;
  }&#13;
&#13;
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
    assert(b &lt;= a);&#13;
    return a - b;&#13;
  }&#13;
&#13;
  function add(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
    uint256 c = a + b;&#13;
    assert(c &gt;= a);&#13;
    return c;&#13;
  }&#13;
}&#13;
&#13;
contract MetadataContract{&#13;
&#13;
    function getMetadata(uint256 _tokenId) public view returns (bytes32[4] buffer, uint256 count) {&#13;
        buffer[0] = "https://meta.repop.world/";&#13;
        buffer[1] = uintToBytes(_tokenId);&#13;
        count = 64;&#13;
    }&#13;
&#13;
      function _memcpy(uint _dest, uint _src, uint _len) private view {&#13;
&#13;
        for(; _len &gt;= 32; _len -= 32) {&#13;
            assembly {&#13;
                mstore(_dest, mload(_src))&#13;
            }&#13;
            _dest += 32;&#13;
            _src += 32;&#13;
        }&#13;
&#13;
        uint256 mask = 256 ** (32 - _len) - 1;&#13;
        assembly {&#13;
            let srcpart := and(mload(_src), not(mask))&#13;
            let destpart := and(mload(_dest), mask)&#13;
            mstore(_dest, or(destpart, srcpart))&#13;
        }&#13;
    }&#13;
&#13;
    function _toString(bytes32[4] _rawBytes, uint256 _stringLength) private view returns (string) {&#13;
        var outputString = new string(_stringLength);&#13;
        uint256 outputPtr;&#13;
        uint256 bytesPtr;&#13;
&#13;
        assembly {&#13;
            outputPtr := add(outputString, 32)&#13;
            bytesPtr := _rawBytes&#13;
        }&#13;
&#13;
        _memcpy(outputPtr, bytesPtr, _stringLength);&#13;
&#13;
        return outputString;&#13;
    }&#13;
&#13;
    function getMetadataUrl(uint256 _tokenId) external view returns (string infoUrl) {&#13;
        bytes32[4] memory buffer;&#13;
        uint256 count;&#13;
        (buffer, count) = getMetadata(_tokenId);&#13;
&#13;
        return _toString(buffer, count);&#13;
    }&#13;
&#13;
    function uintToBytes(uint v) public view returns (bytes32 ret) {&#13;
        if (v == 0) {&#13;
            ret = '0';&#13;
        }&#13;
        else {&#13;
            while (v &gt; 0) {&#13;
                ret = bytes32(uint(ret) / (2 ** 8));&#13;
                ret |= bytes32(((v % 10) + 48) * 2 ** (8 * 31));&#13;
                v /= 10;&#13;
            }&#13;
        }&#13;
        return ret;&#13;
    }&#13;
}&#13;
&#13;
&#13;
/// @author Luis Freitas, Miguel Amaral (https://repop.world)&#13;
contract REPOPERC721 is ERC721, REPOPAccessControl{&#13;
&#13;
  MetadataContract public metadataContract;&#13;
&#13;
  bytes4 constant InterfaceSignature_ERC165 =&#13;
      bytes4(keccak256('supportsInterface(bytes4)'));&#13;
&#13;
  bytes4 constant InterfaceSignature_ERC721 =&#13;
      bytes4(keccak256('name()')) ^&#13;
      bytes4(keccak256('symbol()')) ^&#13;
      bytes4(keccak256('totalSupply()')) ^&#13;
      bytes4(keccak256('balanceOf(address)')) ^&#13;
      bytes4(keccak256('ownerOf(uint256)')) ^&#13;
      bytes4(keccak256('approve(address,uint256)')) ^&#13;
      bytes4(keccak256('transfer(address,uint256)')) ^&#13;
      bytes4(keccak256('transferFrom(address,address,uint256)')) ^&#13;
      bytes4(keccak256('tokensOfOwner(address)')) ^&#13;
      bytes4(keccak256('tokenMetadata(uint256)'));&#13;
&#13;
    function tokenMetadata(uint256 _tokenId) public view returns (string infoUrl) {&#13;
      require(metadataContract != address(0));&#13;
      require(_tokenId &gt;= 0 &amp;&amp; _tokenId &lt;= pops.length);&#13;
&#13;
      return metadataContract.getMetadataUrl(_tokenId);&#13;
    }&#13;
&#13;
    function setMetadataContractAddress(address contractAddress) public onlyCEO{&#13;
      require(contractAddress != address(0));&#13;
      metadataContract = MetadataContract(contractAddress);&#13;
    }&#13;
&#13;
    string public constant name = "REPOP WORLD";&#13;
    string public constant symbol = "POP";&#13;
&#13;
    function supportsInterface(bytes4 _interfaceID) external view returns (bool)&#13;
    {&#13;
        return ((_interfaceID == InterfaceSignature_ERC165) || (_interfaceID == InterfaceSignature_ERC721));&#13;
    }&#13;
&#13;
    function approve(address _to, uint256 _tokenId) public whenNotPaused{&#13;
&#13;
        require(_owns(msg.sender, _tokenId));&#13;
&#13;
        popIndexToApproved[_tokenId] = _to;&#13;
&#13;
        emit Approval(msg.sender, _to, _tokenId);&#13;
    }&#13;
&#13;
    function balanceOf(address _owner) public view returns (uint256 balance){&#13;
        return ownershipTokenCount[_owner];&#13;
    }&#13;
&#13;
    function implementsERC721() public pure returns (bool){&#13;
        return true;&#13;
    }&#13;
&#13;
    function ownerOf(uint256 _tokenId) public view returns (address owner) {&#13;
        owner = popIndexToOwner[_tokenId];&#13;
        require(owner != address(0));&#13;
    }&#13;
&#13;
    function takeOwnership(uint256 _tokenId) public {&#13;
        address currentOwner = ownerOf(_tokenId);&#13;
        address newOwner = msg.sender;&#13;
&#13;
        require(_addressNotNull(newOwner));&#13;
        require(_approved(newOwner, _tokenId));&#13;
&#13;
        _transfer(newOwner, _tokenId);&#13;
        emit Transfer(currentOwner, newOwner, _tokenId);&#13;
    }&#13;
&#13;
    function tokensOfOwner(address _owner) external view returns(uint256[] ownerTokens) {&#13;
        uint256 tokenCount = balanceOf(_owner);&#13;
        if (tokenCount == 0) {&#13;
&#13;
            return new uint256[](0);&#13;
        } else {&#13;
            uint256[] memory result = new uint256[](tokenCount);&#13;
            uint256 totalPops = totalSupply();&#13;
            uint256 resultIndex = 0;&#13;
            uint256 popId;&#13;
&#13;
            for (popId = 1; popId &lt;= totalPops; popId++) {&#13;
                if (popIndexToOwner[popId] == _owner) {&#13;
                    result[resultIndex] = popId;&#13;
                    resultIndex++;&#13;
                }&#13;
            }&#13;
            return result;&#13;
        }&#13;
    }&#13;
&#13;
    function totalSupply() public view returns (uint256 total) {&#13;
        return pops.length;&#13;
    }&#13;
&#13;
    function transfer(address _to, uint256 _tokenId ) public whenNotPaused{&#13;
      require(_owns(msg.sender, _tokenId));&#13;
      require(_addressNotNull(_to));&#13;
&#13;
      _transfer(_to, _tokenId);&#13;
&#13;
      emit Transfer(msg.sender, _to, _tokenId);&#13;
    }&#13;
&#13;
    function transferFrom(address _from, address _to, uint256 _tokenId) public whenNotPaused{&#13;
        require(_owns(_from, _tokenId));&#13;
        require(_approved(msg.sender, _tokenId));&#13;
        require(_addressNotNull(_to));&#13;
&#13;
        _transfer(_to, _tokenId);&#13;
&#13;
        emit Transfer(_from, _to, _tokenId);&#13;
    }&#13;
&#13;
&#13;
    function _addressNotNull(address _to) private pure returns (bool){&#13;
        return _to != address(0);&#13;
    }&#13;
&#13;
    function _approved(address _to, uint256 _tokenId) private view returns (bool) {&#13;
        return popIndexToApproved[_tokenId] == _to;&#13;
    }&#13;
&#13;
    function _owns(address claimant, uint256 _tokenId) private view returns (bool) {&#13;
        return claimant == popIndexToOwner[_tokenId];&#13;
    }&#13;
&#13;
    function _transfer(address _to, uint256 _tokenID) internal {&#13;
        address owner = popIndexToOwner[_tokenID];&#13;
        ownershipTokenCount[owner] = ownershipTokenCount[owner] - 1 ;&#13;
        popIndexToApproved[_tokenID] = 0;&#13;
        popIndexToOwner[_tokenID] = _to;&#13;
        ownershipTokenCount[_to] = ownershipTokenCount[_to] + 1;&#13;
    }&#13;
&#13;
    event Birth(address owner, uint256 popId, uint256 aParentId, uint256 bParentId, uint256 genes);&#13;
    event Transfer(address from, address to, uint256 tokenId);&#13;
&#13;
    struct Pop {&#13;
      uint256 genes;&#13;
      uint64 birthTime;&#13;
      uint64 cooldownEndTimestamp;&#13;
      uint32 aParentId;&#13;
      uint32 bParentId;&#13;
      bytes32 popName;&#13;
      uint16 cooldownIndex;&#13;
      uint16 generation;&#13;
    }&#13;
&#13;
    uint32[14] public cooldowns = [&#13;
        uint32(10 minutes),&#13;
        uint32(20 minutes),&#13;
        uint32(40 minutes),&#13;
        uint32(1 hours),&#13;
        uint32(2 hours),&#13;
        uint32(3 hours),&#13;
        uint32(4 hours),&#13;
        uint32(5 hours),&#13;
        uint32(6 hours),&#13;
        uint32(12 hours),&#13;
        uint32(1 days),&#13;
        uint32(3 days),&#13;
        uint32(5 days),&#13;
        uint32(7 days)&#13;
    ];&#13;
&#13;
    Pop[] public pops;&#13;
&#13;
    mapping (uint256 =&gt; address) public popIndexToOwner;&#13;
    mapping (address =&gt; uint256) public ownershipTokenCount;&#13;
    mapping (uint256 =&gt; address) public popIndexToApproved;&#13;
    mapping (uint256 =&gt; uint256) public genesToTokenId;&#13;
&#13;
    function getPop(uint256 _popId) public view&#13;
                    returns (&#13;
                                bool isReady,&#13;
                                uint256 genes,&#13;
                                uint64 birthTime,&#13;
                                uint64 cooldownEndTimestamp,&#13;
                                uint32 aParentId,&#13;
                                uint32 bParentId,&#13;
                                bytes32 popName,&#13;
                                uint16 cooldownIndex,&#13;
                                uint16 generation){&#13;
        Pop memory pop = pops[_popId];&#13;
        return(&#13;
                isReady = (pop.cooldownEndTimestamp &lt;= now),&#13;
                pop.genes,&#13;
                pop.birthTime,&#13;
                pop.cooldownEndTimestamp,&#13;
                pop.aParentId,&#13;
                pop.bParentId,&#13;
                pop.popName,&#13;
                pop.cooldownIndex,&#13;
                pop.generation);&#13;
    }&#13;
&#13;
&#13;
    function createNewPop(uint256 genes, string popName) public onlyCLevel whenNotPaused{&#13;
        bytes32 name32 = stringToBytes32(popName);&#13;
        uint256 index = pops.push(Pop(genes,uint64(now),1,0,0,name32,0,0)) -1;&#13;
&#13;
        emit Birth(msg.sender,index,0,0,genes);&#13;
&#13;
        genesToTokenId[genes] = index;&#13;
&#13;
        popIndexToOwner[index] = msg.sender;&#13;
        ownershipTokenCount[msg.sender] = ownershipTokenCount[msg.sender]+1;&#13;
    }&#13;
&#13;
    function _triggerCooldown(Pop storage _pop) internal {&#13;
        _pop.cooldownEndTimestamp = uint64(now + cooldowns[_pop.cooldownIndex]);&#13;
    }&#13;
&#13;
    function stringToBytes32(string memory source) internal pure returns (bytes32 result) {&#13;
        bytes memory tempEmptyStringTest = bytes(source);&#13;
        if (tempEmptyStringTest.length == 0) {&#13;
            return 0x0;&#13;
        }&#13;
        assembly {&#13;
            result := mload(add(source, 32))&#13;
        }&#13;
    }&#13;
&#13;
    function setPopNameOriginal(uint256 popId, string newName) external onlyCLevel{&#13;
      Pop storage pop = pops[popId];&#13;
      require(pop.generation == 0);&#13;
      bytes32 name32 = stringToBytes32(newName);&#13;
      pop.popName = name32;&#13;
    }&#13;
&#13;
    function setDNA(uint256 popId, uint256 newDna) external onlyCLevel{&#13;
      require(_owns(msg.sender, popId));&#13;
      Pop storage pop = pops[popId];&#13;
      pop.genes = newDna;&#13;
    }&#13;
&#13;
}&#13;
&#13;
contract CarefulTransfer {&#13;
    uint constant suggestedExtraGasToIncludeWithSends = 23000;&#13;
&#13;
    function carefulSendWithFixedGas(&#13;
        address _toAddress,&#13;
        uint _valueWei,&#13;
        uint _extraGasIncluded&#13;
    ) internal returns (bool success) {&#13;
        return _toAddress.call.value(_valueWei).gas(_extraGasIncluded)();&#13;
    }&#13;
}&#13;
&#13;
contract MoneyManager is PullPayment, CarefulTransfer, REPOPAccessControl {&#13;
&#13;
    function _repopTransaction(address _receiver, uint256 _amountWei, uint256 _marginPerThousandForDevelopers) internal {&#13;
        uint256 commissionWei = (_amountWei * _marginPerThousandForDevelopers) / 1000;&#13;
        uint256 compensationWei = _amountWei - commissionWei;&#13;
&#13;
        if( ! carefulSendWithFixedGas(_receiver,compensationWei,23000)) {&#13;
            asyncSend(_receiver, compensationWei);&#13;
        }&#13;
    }&#13;
&#13;
    function withdraw(uint amount) external onlyCFO {&#13;
        require(amount &lt; address(this).balance);&#13;
        cfoAddress.transfer(amount);&#13;
    }&#13;
&#13;
    function getBalance() public view returns (uint256 balance) {&#13;
        return address(this).balance;&#13;
    }&#13;
}&#13;
&#13;
library RoundMoneyNicely {&#13;
    function roundMoneyDownNicely(uint _rawValueWei) internal pure&#13;
    returns (uint nicerValueWei) {&#13;
        if (_rawValueWei &lt; 1 finney) {&#13;
            return _rawValueWei;&#13;
        } else if (_rawValueWei &lt; 10 finney) {&#13;
            return 10 szabo * (_rawValueWei / 10 szabo);&#13;
        } else if (_rawValueWei &lt; 100 finney) {&#13;
            return 100 szabo * (_rawValueWei / 100 szabo);&#13;
        } else if (_rawValueWei &lt; 1 ether) {&#13;
            return 1 finney * (_rawValueWei / 1 finney);&#13;
        } else if (_rawValueWei &lt; 10 ether) {&#13;
            return 10 finney * (_rawValueWei / 10 finney);&#13;
        } else if (_rawValueWei &lt; 100 ether) {&#13;
            return 100 finney * (_rawValueWei / 100 finney);&#13;
        } else if (_rawValueWei &lt; 1000 ether) {&#13;
            return 1 ether * (_rawValueWei / 1 ether);&#13;
        } else if (_rawValueWei &lt; 10000 ether) {&#13;
            return 10 ether * (_rawValueWei / 10 ether);&#13;
        } else {&#13;
            return _rawValueWei;&#13;
        }&#13;
    }&#13;
&#13;
    function roundMoneyUpToWholeFinney(uint _valueWei) pure internal&#13;
    returns (uint valueFinney) {&#13;
        return (1 finney + _valueWei - 1 wei) / 1 finney;&#13;
    }&#13;
}&#13;
&#13;
contract AuctionManager is MoneyManager {&#13;
    event Bid(address bidder, uint256 bid, uint256 auctionId);&#13;
    event NewAuction( uint256 itemForAuctionID, uint256 durationSeconds, address seller);&#13;
    event NewAuctionWinner(address highestBidder, uint256 auctionId);&#13;
&#13;
    struct Auction{&#13;
        uint auctionStart;&#13;
        uint auctionEnd;&#13;
        uint highestBid;&#13;
        address highestBidder;&#13;
        bool ended;&#13;
    }&#13;
&#13;
    bool public isAuctionManager = true;&#13;
    uint256 private marginPerThousandForDevelopers = 50;&#13;
    uint256 private percentageBidIncrease = 33;&#13;
    uint256 private auctionsStartBid = 0.1 ether;&#13;
    address private auctionsStartAddress;&#13;
&#13;
    mapping (uint256 =&gt; uint256) public _itemID2auctionID;&#13;
    mapping (uint256 =&gt; uint256) public _auctionID2itemID;&#13;
    Auction[] public _auctionsArray;&#13;
&#13;
    ERC721 public nonFungibleContract;&#13;
&#13;
    function AuctionManager() public {&#13;
        ceoAddress = msg.sender;&#13;
        cooAddress = msg.sender;&#13;
        cfoAddress = msg.sender;&#13;
&#13;
        auctionsStartAddress = msg.sender;&#13;
        _auctionsArray.push(Auction(0,0,0,0,false));&#13;
    }&#13;
&#13;
    function setERCContract(address candidateAddress) public onlyCEO {&#13;
        ERC721 candidateContract = ERC721(candidateAddress);&#13;
&#13;
        nonFungibleContract = candidateContract;&#13;
    }&#13;
&#13;
    function getERCContractAddress() public view returns (address) {&#13;
        return address(nonFungibleContract);&#13;
    }&#13;
&#13;
    function getAllActiveAuctions()  external view returns (uint256[] popsIDs,uint256[] auctionsIDs,uint256[] sellingPrices, address[] highestBidders, bool[] canBeEnded){&#13;
&#13;
        uint256[] memory toReturnPopsIDs = new uint256[](_auctionsArray.length);&#13;
        uint256[] memory toReturnAuctionsIDs = new uint256[](_auctionsArray.length);&#13;
        uint256[] memory toReturnSellingPrices = new uint256[](_auctionsArray.length);&#13;
        address[] memory toReturnSellerAddress = new address[](_auctionsArray.length);&#13;
        bool[] memory toReturnCanBeEnded = new bool[](_auctionsArray.length);&#13;
        uint256 index = 0;&#13;
&#13;
        for(uint256 i = 1; i &lt; _auctionsArray.length; i++){&#13;
            uint256 popId = _auctionID2itemID[i];&#13;
            uint256 price = requiredBid(i);&#13;
&#13;
            if(_auctionsArray[i].ended == false){&#13;
                toReturnPopsIDs[index] = popId;&#13;
                toReturnAuctionsIDs[index] = i;&#13;
                toReturnSellingPrices[index] = price;&#13;
                toReturnSellerAddress[index] = _auctionsArray[i].highestBidder;&#13;
                toReturnCanBeEnded[index] = _auctionsArray[i].auctionEnd &lt; now;&#13;
                index++;&#13;
            }&#13;
        }&#13;
        return (toReturnPopsIDs,toReturnAuctionsIDs,toReturnSellingPrices,toReturnSellerAddress,toReturnCanBeEnded);&#13;
    }&#13;
&#13;
    function getAllAuctions()  external view returns (uint256[] popsIDs,uint256[] auctionsIDs,uint256[] sellingPrices){&#13;
&#13;
        uint256[] memory toReturnPopsIDs = new uint256[](_auctionsArray.length);&#13;
        uint256[] memory toReturnAuctionsIDs = new uint256[](_auctionsArray.length);&#13;
        uint256[] memory toReturnSellingPrices = new uint256[](_auctionsArray.length);&#13;
&#13;
        uint256 index = 0;&#13;
&#13;
        for(uint256 i = 1; i &lt; _auctionsArray.length; i++){&#13;
            uint256 popId = _auctionID2itemID[i];&#13;
            uint256 price = requiredBid(i);&#13;
            toReturnPopsIDs[index] = popId;&#13;
            toReturnAuctionsIDs[index] = i;&#13;
            toReturnSellingPrices[index] = price;&#13;
            index++;&#13;
        }&#13;
        return (toReturnPopsIDs,toReturnAuctionsIDs,toReturnSellingPrices);&#13;
    }&#13;
&#13;
&#13;
    function createAuction(uint256 _itemForAuctionID, uint256 _auctionDurationSeconds, address _seller) public {&#13;
        require(msg.sender == getERCContractAddress());&#13;
        require(_auctionDurationSeconds &gt;= 20 seconds);&#13;
        require(_auctionDurationSeconds &lt; 45 days);&#13;
        require(_itemForAuctionID != 0);&#13;
        require(_seller != 0);&#13;
&#13;
        _takeOwnershipOfTokenFrom(_itemForAuctionID,_seller);&#13;
&#13;
        uint256 auctionEnd = SafeMath.add(now,_auctionDurationSeconds);&#13;
        uint256 auctionID = _itemID2auctionID[_itemForAuctionID];&#13;
        if(auctionID == 0){&#13;
            uint256 index = _auctionsArray.push(Auction(now, auctionEnd, 0, _seller, false)) - 1;&#13;
            _itemID2auctionID[_itemForAuctionID] = index;&#13;
            _auctionID2itemID[index] = _itemForAuctionID;&#13;
        } else {&#13;
            Auction storage previousAuction = _auctionsArray[auctionID];&#13;
            require(previousAuction.ended == true);&#13;
            previousAuction.auctionStart = now;&#13;
            previousAuction.auctionEnd = auctionEnd;&#13;
            previousAuction.highestBidder = _seller;&#13;
            previousAuction.highestBid = 0;&#13;
            previousAuction.ended = false;&#13;
        }&#13;
        emit NewAuction(_itemForAuctionID, _auctionDurationSeconds, _seller);&#13;
    }&#13;
&#13;
    function bid(uint auctionID) public payable whenNotPaused{&#13;
        require(auctionID != 0);&#13;
        Auction storage auction = _auctionsArray[auctionID];&#13;
        require(auction.ended == false);&#13;
        require(auction.auctionEnd &gt;= now);&#13;
        uint claimBidPrice = requiredBid(auctionID);&#13;
        uint256 bidValue = msg.value;&#13;
        require(bidValue &gt;= claimBidPrice);&#13;
        address previousHighestBidder = auction.highestBidder;&#13;
        auction.highestBid = msg.value;&#13;
        auction.highestBidder = msg.sender;&#13;
        _repopTransaction(previousHighestBidder, msg.value, marginPerThousandForDevelopers);&#13;
        emit Bid(msg.sender, msg.value, auctionID);&#13;
    }&#13;
&#13;
    function endAuction(uint auctionID) public{&#13;
        require(auctionID != 0);&#13;
        Auction storage auction = _auctionsArray[auctionID];&#13;
        require(auction.ended == false);&#13;
        require(auction.auctionEnd &lt; now);&#13;
        auction.ended = true;&#13;
        nonFungibleContract.transfer(auction.highestBidder, _auctionID2itemID[auctionID]);&#13;
        emit NewAuctionWinner(auction.highestBidder, auctionID);&#13;
    }&#13;
&#13;
    function requiredBid(uint _auctionID) constant public returns (uint256 amountToOutBid) {&#13;
        require(_auctionID != 0);&#13;
        Auction memory auction = _auctionsArray[_auctionID];&#13;
        if(auction.highestBid == 0){&#13;
            return auctionsStartBid;&#13;
        } else {&#13;
            uint256 amountRequiredToOutBid = (auction.highestBid * (100 + percentageBidIncrease)) / 100;&#13;
            amountRequiredToOutBid = RoundMoneyNicely.roundMoneyDownNicely(amountRequiredToOutBid);&#13;
            return amountRequiredToOutBid;&#13;
        }&#13;
    }&#13;
&#13;
    function getAuction(uint _itemForAuctionID) external constant returns (uint256 itemID, uint256 auctionStart, uint256 auctionEnd, address highestBidder, uint256 highestBid, bool ended){&#13;
        require(_itemForAuctionID != 0);&#13;
        Auction memory auction = _auctionsArray[_itemID2auctionID[_itemForAuctionID]];&#13;
        if(auction.highestBidder != 0) {&#13;
            itemID = _itemForAuctionID;&#13;
            auctionStart =  auction.auctionStart;&#13;
            auctionEnd =    auction.auctionEnd;&#13;
            highestBidder = auction.highestBidder;&#13;
            highestBid =    auction.highestBid;&#13;
            ended =         auction.ended;&#13;
            return(itemID,auctionStart,auctionEnd,highestBidder,highestBid,ended);&#13;
        } else {&#13;
            revert();&#13;
        }&#13;
    }&#13;
&#13;
    function getAuctionStartBid() public view returns(uint256){&#13;
      return auctionsStartBid;&#13;
    }&#13;
&#13;
    function setAuctionStartBid(uint256 _auctionStartBid) public onlyCLevel{&#13;
      auctionsStartBid = _auctionStartBid;&#13;
    }&#13;
&#13;
    function _addressNotNull(address _to) private pure returns (bool){&#13;
        return _to != address(0);&#13;
    }&#13;
&#13;
&#13;
    function _takeOwnershipOfToken(uint256 _itemForAuctionID) internal {&#13;
&#13;
        nonFungibleContract.takeOwnership(_itemForAuctionID);&#13;
    }&#13;
&#13;
    function _takeOwnershipOfTokenFrom(uint256 _itemForAuctionID, address previousOwner) internal {&#13;
        nonFungibleContract.transferFrom(previousOwner,this,_itemForAuctionID);&#13;
    }&#13;
}&#13;
&#13;
contract MarketManager is MoneyManager {&#13;
    event PopPurchased(address seller, address buyer, uint256 popId, uint256 sellingPrice);&#13;
    event PopCancelSale(address popOwner, uint256 popId);&#13;
    event PopChangedPrice(address popOwner, uint256 popId, uint256 newPrice);&#13;
&#13;
    struct Sale {&#13;
        uint256 sellingPrice;&#13;
&#13;
        address seller;&#13;
    }&#13;
&#13;
    bool public isMarketManager = true;&#13;
    uint256 private marginPerThousandForDevelopers = 50;&#13;
    uint256 private MAX_SELLING_PRICE = 100000 ether;&#13;
    mapping (uint256 =&gt; uint256) public _itemID2saleID;&#13;
    mapping (uint256 =&gt; uint256) public _saleID2itemID;&#13;
    Sale[] public _salesArray;&#13;
    ERC721 public nonFungibleContract;&#13;
&#13;
    function MarketManager() public {&#13;
        ceoAddress = msg.sender;&#13;
        cooAddress = msg.sender;&#13;
        cfoAddress = msg.sender;&#13;
        _salesArray.push(Sale(0,0));&#13;
        _itemID2saleID[0] = 0;&#13;
        _saleID2itemID[0] = 0;&#13;
    }&#13;
&#13;
    function setERCContract(address candidateAddress) public onlyCEO {&#13;
        require(candidateAddress != address(0));&#13;
        ERC721 candidateContract = ERC721(candidateAddress);&#13;
        nonFungibleContract = candidateContract;&#13;
    }&#13;
&#13;
    function getERCContractAddress() public view returns (address) {&#13;
        return address(nonFungibleContract);&#13;
    }&#13;
&#13;
    function getAllActiveSales()  external view returns (uint256[] popsIDs,uint256[] sellingPrices,address[] sellerAddresses){&#13;
&#13;
        uint256[] memory toReturnPopsIDs = new uint256[](_salesArray.length);&#13;
        uint256[] memory toReturnSellingPrices = new uint256[](_salesArray.length);&#13;
        address[] memory toReturnSellerAddress = new address[](_salesArray.length);&#13;
        uint256 index = 0;&#13;
&#13;
        for(uint256 i = 1; i &lt; _salesArray.length; i++){&#13;
            uint256 popId = _saleID2itemID[i];&#13;
            uint256 price = _salesArray[i].sellingPrice;&#13;
            address seller = _salesArray[i].seller;&#13;
&#13;
            if(seller != 0){&#13;
                toReturnSellerAddress[index] = seller;&#13;
                toReturnPopsIDs[index] = popId;&#13;
                toReturnSellingPrices[index] = price;&#13;
                index++;&#13;
            }&#13;
        }&#13;
        return (toReturnPopsIDs,toReturnSellingPrices,toReturnSellerAddress);&#13;
    }&#13;
&#13;
    function getAllSalesByAddress(address addr)  external view returns (uint256[] popsIDs,uint256[] sellingPrices,address[] sellerAddresses){&#13;
&#13;
        uint256[] memory toReturnPopsIDs = new uint256[](_salesArray.length);&#13;
        uint256[] memory toReturnSellingPrices = new uint256[](_salesArray.length);&#13;
        address[] memory toReturnSellerAddress = new address[](_salesArray.length);&#13;
        uint256 index = 0;&#13;
&#13;
        for(uint256 i = 1; i &lt; _salesArray.length; i++){&#13;
            uint256 popId = _saleID2itemID[i];&#13;
            uint256 price = _salesArray[i].sellingPrice;&#13;
            address seller = _salesArray[i].seller;&#13;
&#13;
            if(seller == addr){&#13;
                toReturnSellerAddress[index] = seller;&#13;
                toReturnPopsIDs[index] = popId;&#13;
                toReturnSellingPrices[index] = price;&#13;
                index++;&#13;
            }&#13;
        }&#13;
        return (toReturnPopsIDs,toReturnSellingPrices,toReturnSellerAddress);&#13;
    }&#13;
&#13;
    function purchasePop(uint256 _popId) public payable whenNotPaused{&#13;
        uint256 saleID = _itemID2saleID[_popId];&#13;
        require(saleID != 0);&#13;
        Sale storage sale = _salesArray[saleID];&#13;
        address popOwner = sale.seller;&#13;
        require(popOwner != 0);&#13;
        address newOwner = msg.sender;&#13;
        uint256 sellingPrice = sale.sellingPrice;&#13;
        require(popOwner != newOwner);&#13;
        require(_addressNotNull(newOwner));&#13;
        require(msg.value == sellingPrice);&#13;
        sale.seller = 0;&#13;
        nonFungibleContract.transfer(newOwner,_popId);&#13;
        _repopTransaction(popOwner, msg.value, marginPerThousandForDevelopers);&#13;
        emit PopPurchased(popOwner, msg.sender, _popId, msg.value);&#13;
    }&#13;
&#13;
    function sellerOf(uint _popId) public view returns (address) {&#13;
        uint256 saleID = _itemID2saleID[_popId];&#13;
        Sale memory sale = _salesArray[saleID];&#13;
        return sale.seller;&#13;
    }&#13;
&#13;
    function sellPop(address seller, uint256 _popId, uint256 _sellingPrice) public whenNotPaused{&#13;
        require(_sellingPrice &lt; MAX_SELLING_PRICE);&#13;
        require(msg.sender == getERCContractAddress());&#13;
        require(_sellingPrice &gt; 0);&#13;
        _takeOwnershipOfTokenFrom(_popId,seller);&#13;
        uint256 saleID = _itemID2saleID[_popId];&#13;
        if(saleID == 0) {&#13;
            uint256  index = _salesArray.push(Sale(_sellingPrice,seller)) - 1;&#13;
            _itemID2saleID[_popId] = index;&#13;
            _saleID2itemID[index] = _popId;&#13;
        } else {&#13;
            Sale storage sale = _salesArray[saleID];&#13;
            require(sale.seller == 0);&#13;
            sale.seller = seller;&#13;
            sale.sellingPrice = _sellingPrice;&#13;
        }&#13;
    }&#13;
&#13;
    function cancelSellPop(uint256 _popId) public {&#13;
        Sale storage sale = _salesArray[_itemID2saleID[_popId]];&#13;
        require(sale.seller == msg.sender);&#13;
        sale.seller = 0;&#13;
        nonFungibleContract.transfer(msg.sender,_popId);&#13;
&#13;
        emit PopCancelSale(msg.sender, _popId);&#13;
    }&#13;
&#13;
    function changeSellPOPPrice(uint256 _popId, uint256 _newSellingValue) public whenNotPaused{&#13;
      require(_newSellingValue &lt; MAX_SELLING_PRICE);&#13;
      require(_newSellingValue &gt; 0);&#13;
      Sale storage sale = _salesArray[_itemID2saleID[_popId]];&#13;
      require(sale.seller == msg.sender);&#13;
      sale.sellingPrice = _newSellingValue;&#13;
      emit PopChangedPrice(msg.sender, _popId, _newSellingValue);&#13;
    }&#13;
&#13;
    function _addressNotNull(address _to) private pure returns (bool){&#13;
        return _to != address(0);&#13;
    }&#13;
&#13;
    function _takeOwnershipOfToken(uint256 _itemForAuctionID) internal {&#13;
        nonFungibleContract.takeOwnership(_itemForAuctionID);&#13;
    }&#13;
&#13;
    function _takeOwnershipOfTokenFrom(uint256 _itemForAuctionID, address previousOwner) internal {&#13;
        nonFungibleContract.transferFrom(previousOwner,this,_itemForAuctionID);&#13;
    }&#13;
}&#13;
&#13;
contract CloningInterface{&#13;
  function isGeneScience() public pure returns (bool);&#13;
  function mixGenes(uint256 genes1, uint256 genes2) public returns (uint256);&#13;
}&#13;
&#13;
contract GenesMarket is MoneyManager {&#13;
    event GenesCancelSale(address popOwner, uint256 popId);&#13;
    event GenesPurchased(address buyer, address popOwner, uint256 popId, uint256 amount, uint256 price);&#13;
    event GenesChangedPrice(address popOwner, uint256 popId, uint256 newPrice);&#13;
&#13;
    struct GeneForSale {&#13;
            uint256 sellingPrice;&#13;
            address currentOwner;&#13;
    }&#13;
&#13;
    mapping (uint256 =&gt; uint256) public _itemID2geneSaleID;&#13;
    mapping (uint256 =&gt; uint256) public _geneSaleID2itemID;&#13;
    GeneForSale[] public _genesForSaleArray;&#13;
    uint256 marginPerThousandForDevelopers = 50;&#13;
    uint256 MAX_SELLING_PRICE = 10000 ether;&#13;
&#13;
    mapping(address =&gt; mapping (uint256 =&gt; uint256)) _genesOwned;&#13;
    mapping(address =&gt; uint256[]) _ownedGenesPopsId;&#13;
    bool public isGenesMarket = true;&#13;
&#13;
    function GenesMarket() public {&#13;
        ceoAddress = msg.sender;&#13;
        cooAddress = msg.sender;&#13;
        cfoAddress = msg.sender;&#13;
        _genesForSaleArray.push(GeneForSale(0,0));&#13;
    }&#13;
&#13;
    ERC721 public nonFungibleContract;&#13;
    function setERCContract(address candidateAddress) public onlyCEO() {&#13;
        ERC721 candidateContract = ERC721(candidateAddress);&#13;
        nonFungibleContract = candidateContract;&#13;
    }&#13;
&#13;
    function getERCContractAddress() public view returns (address) {&#13;
        return address(nonFungibleContract);&#13;
    }&#13;
&#13;
    function startSellingGenes(uint256 _popId, uint256 _sellingPrice, address _seller) public {&#13;
        require(_sellingPrice &lt; MAX_SELLING_PRICE);&#13;
        require(msg.sender == getERCContractAddress());&#13;
        require(_sellingPrice &gt; 0);&#13;
        _takeOwnershipOfTokenFrom(_popId,_seller);&#13;
        uint256 geneSaleID = _itemID2geneSaleID[_popId];&#13;
        if(geneSaleID == 0){&#13;
&#13;
            uint256 index = _genesForSaleArray.push(GeneForSale(_sellingPrice,_seller)) - 1;&#13;
            _itemID2geneSaleID[_popId] = index;&#13;
            _geneSaleID2itemID[index] = _popId;&#13;
&#13;
        }else {&#13;
            GeneForSale storage previousSale = _genesForSaleArray[geneSaleID];&#13;
            previousSale.sellingPrice = _sellingPrice;&#13;
            previousSale.currentOwner = _seller;&#13;
        }&#13;
    }&#13;
&#13;
    function stopSellingGenes(uint _popId) public {&#13;
        uint256 geneSaleID = _itemID2geneSaleID[_popId];&#13;
        require(geneSaleID != 0);&#13;
        GeneForSale storage gene = _genesForSaleArray[geneSaleID];&#13;
        require(msg.sender == gene.currentOwner);&#13;
        require(gene.sellingPrice != 0);&#13;
        gene.sellingPrice = 0;&#13;
        nonFungibleContract.transfer(gene.currentOwner, _popId);&#13;
&#13;
        emit GenesCancelSale(msg.sender, _popId);&#13;
    }&#13;
&#13;
&#13;
    function sellerOf(uint _popId) public view returns (address) {&#13;
        uint256 geneSaleID = _itemID2geneSaleID[_popId];&#13;
        GeneForSale memory gene = _genesForSaleArray[geneSaleID];&#13;
        if(gene.sellingPrice != 0) {&#13;
            return gene.currentOwner;&#13;
        } else {&#13;
            return 0;&#13;
        }&#13;
    }&#13;
&#13;
    function useBottle(address _user, uint _popId) external whenNotPaused {&#13;
        require(msg.sender == getERCContractAddress());&#13;
        require(_genesOwned[_user][_popId] &gt; 0);&#13;
        _genesOwned[_user][_popId] = _genesOwned[_user][_popId] - 1;&#13;
    }&#13;
&#13;
&#13;
    function purchaseGenes(uint256 _popId, uint256 _amountGenes, bool update) public payable whenNotPaused{&#13;
        require(_amountGenes &gt; 0);&#13;
        uint256 geneSaleID = _itemID2geneSaleID[_popId];&#13;
        GeneForSale memory gene = _genesForSaleArray[geneSaleID];&#13;
        require(gene.sellingPrice != 0);&#13;
        address popOwner = gene.currentOwner;&#13;
        address genesReceiver = msg.sender;&#13;
        uint256 sellingPrice = gene.sellingPrice;&#13;
        require(popOwner != genesReceiver);&#13;
        require(msg.value == SafeMath.mul(sellingPrice, _amountGenes));&#13;
        if( update &amp;&amp; _genesOwned[msg.sender][_popId] == 0) {&#13;
            _ownedGenesPopsId[msg.sender].push(_popId);&#13;
        }&#13;
        _genesOwned[msg.sender][_popId] = _genesOwned[msg.sender][_popId] + _amountGenes;&#13;
        _repopTransaction(popOwner, msg.value, marginPerThousandForDevelopers);&#13;
        emit GenesPurchased(msg.sender, popOwner, _popId, _amountGenes, msg.value);&#13;
    }&#13;
&#13;
    function getGenesForSale() public view returns (uint[] popIDs, uint[] sellingPrices, uint[] geneSaleIDs, address[] sellers){&#13;
        uint256[] memory toReturnPopsIDs = new uint256[](_genesForSaleArray.length);&#13;
        uint256[] memory toReturnSellingPrices = new uint256[](_genesForSaleArray.length);&#13;
        uint256[] memory toReturnGeneSaleID = new uint256[](_genesForSaleArray.length);&#13;
        address[] memory toReturnSellers = new address[](_genesForSaleArray.length);&#13;
        uint256 index = 0;&#13;
&#13;
        for(uint256 i = 1; i &lt; _genesForSaleArray.length; i++){&#13;
            uint256 popId = _geneSaleID2itemID[i];&#13;
            uint256 price = _genesForSaleArray[i].sellingPrice;&#13;
&#13;
            if(price != 0){&#13;
                toReturnGeneSaleID[index] = i;&#13;
                toReturnPopsIDs[index] = popId;&#13;
                toReturnSellingPrices[index] = price;&#13;
                toReturnSellers[index] = _genesForSaleArray[i].currentOwner;&#13;
                index++;&#13;
            }&#13;
        }&#13;
        return (toReturnPopsIDs,toReturnSellingPrices,toReturnGeneSaleID, toReturnSellers);&#13;
    }&#13;
&#13;
    function getGenesForSaleBySeller(address seller) public view returns (uint[] popIDs, uint[] sellingPrices, uint[] geneSaleIDs, address[] sellers){&#13;
        uint256[] memory toReturnPopsIDs = new uint256[](_genesForSaleArray.length);&#13;
        uint256[] memory toReturnSellingPrices = new uint256[](_genesForSaleArray.length);&#13;
        uint256[] memory toReturnGeneSaleID = new uint256[](_genesForSaleArray.length);&#13;
        address[] memory toReturnSellers = new address[](_genesForSaleArray.length);&#13;
        uint256 index = 0;&#13;
&#13;
        for(uint256 i = 1; i &lt; _genesForSaleArray.length; i++){&#13;
            uint256 popId = _geneSaleID2itemID[i];&#13;
            uint256 price = _genesForSaleArray[i].sellingPrice;&#13;
&#13;
            if(price != 0){&#13;
              if(_genesForSaleArray[i].currentOwner == seller){&#13;
                toReturnGeneSaleID[index] = i;&#13;
                toReturnPopsIDs[index] = popId;&#13;
                toReturnSellingPrices[index] = price;&#13;
                toReturnSellers[index] = _genesForSaleArray[i].currentOwner;&#13;
                index++;&#13;
              }&#13;
            }&#13;
        }&#13;
        return (toReturnPopsIDs,toReturnSellingPrices,toReturnGeneSaleID, toReturnSellers);&#13;
    }&#13;
&#13;
    function getAmountOfGene(uint _popId) public view returns (uint amount){&#13;
        return _genesOwned[msg.sender][_popId];&#13;
    }&#13;
&#13;
    function getMyGenes() public view returns (uint[] popIDs, uint[] amount) {&#13;
        uint256[] memory toReturnPopsIDs = new uint256[](_ownedGenesPopsId[msg.sender].length);&#13;
        uint256[] memory toReturnAmount = new uint256[](_ownedGenesPopsId[msg.sender].length);&#13;
&#13;
        for(uint256 i = 0; i &lt; _ownedGenesPopsId[msg.sender].length; i++) {&#13;
            toReturnPopsIDs[i] = _ownedGenesPopsId[msg.sender][i];&#13;
            toReturnAmount[i] = _genesOwned[msg.sender][_ownedGenesPopsId[msg.sender][i]];&#13;
        }&#13;
        return (toReturnPopsIDs,toReturnAmount);&#13;
    }&#13;
&#13;
    function changeSellGenesPrice(uint256 _popId, uint256 _newSellingValue) public whenNotPaused{&#13;
      require(_newSellingValue &lt; MAX_SELLING_PRICE);&#13;
      require(_newSellingValue &gt; 0);&#13;
      uint256 geneSaleID = _itemID2geneSaleID[_popId];&#13;
      require(geneSaleID != 0);&#13;
&#13;
      GeneForSale storage gene = _genesForSaleArray[geneSaleID];&#13;
&#13;
      require(msg.sender == gene.currentOwner);&#13;
      require(gene.sellingPrice != 0);&#13;
&#13;
      gene.sellingPrice = _newSellingValue;&#13;
&#13;
      emit GenesChangedPrice(msg.sender, _popId, _newSellingValue);&#13;
    }&#13;
&#13;
    function _takeOwnershipOfTokenFrom(uint256 _popId, address previousOwner) internal {&#13;
        nonFungibleContract.transferFrom(previousOwner,this,_popId);&#13;
    }&#13;
}&#13;
&#13;
contract REPOPCore is REPOPERC721, MoneyManager{&#13;
    uint256 public refresherFee = 0.01 ether;&#13;
    AuctionManager public auctionManager;&#13;
    MarketManager public marketManager;&#13;
    GenesMarket public genesMarket;&#13;
    CloningInterface public geneScience;&#13;
&#13;
    event CloneWithTwoPops(address creator, uint256 cloneId, uint256 aParentId, uint256 bParentId);&#13;
    event CloneWithPopAndBottle(address creator, uint256 cloneId, uint256 popId, uint256 bottleId);&#13;
    event SellingPop(address seller, uint256 popId, uint256 price);&#13;
    event SellingGenes(address seller, uint256 popId, uint256 price);&#13;
    event ChangedPopName(address owner, uint256 popId, bytes32 newName);&#13;
    event CooldownRemoval(uint256 popId, address owner, uint256 paidFee);&#13;
&#13;
    function REPOPCore() public{&#13;
&#13;
      ceoAddress = msg.sender;&#13;
      cooAddress = msg.sender;&#13;
      cfoAddress = msg.sender;&#13;
&#13;
      createNewPop(0x0, "Satoshi Nakamoto");&#13;
    }&#13;
&#13;
    function createNewAuction(uint256 _itemForAuctionID, uint256 _auctionDurationSeconds) public onlyCLevel{&#13;
        approve(address(auctionManager),_itemForAuctionID);&#13;
        auctionManager.createAuction(_itemForAuctionID,_auctionDurationSeconds,msg.sender);&#13;
    }&#13;
&#13;
    function setAuctionManagerAddress(address _address) external onlyCEO {&#13;
        AuctionManager candidateContract = AuctionManager(_address);&#13;
&#13;
&#13;
        require(candidateContract.isAuctionManager());&#13;
&#13;
&#13;
        auctionManager = candidateContract;&#13;
    }&#13;
&#13;
    function getAuctionManagerAddress() public view returns (address) {&#13;
        return address(auctionManager);&#13;
    }&#13;
&#13;
    function setMarketManagerAddress(address _address) external onlyCEO {&#13;
        MarketManager candidateContract = MarketManager(_address);&#13;
        require(candidateContract.isMarketManager());&#13;
        marketManager = candidateContract;&#13;
    }&#13;
&#13;
    function getMarketManagerAddress() public view returns (address) {&#13;
        return address(marketManager);&#13;
    }&#13;
&#13;
    function setGeneScienceAddress(address _address) external onlyCEO {&#13;
      CloningInterface candidateContract = CloningInterface(_address);&#13;
      require(candidateContract.isGeneScience());&#13;
      geneScience = candidateContract;&#13;
    }&#13;
&#13;
    function getGeneScienceAddress() public view returns (address) {&#13;
        return address(geneScience);&#13;
    }&#13;
&#13;
    function setGenesMarketAddress(address _address) external onlyCEO {&#13;
      GenesMarket candidateContract = GenesMarket(_address);&#13;
      require(candidateContract.isGenesMarket());&#13;
      genesMarket = candidateContract;&#13;
    }&#13;
&#13;
    function getGenesMarketAddress() public view returns (address) {&#13;
        return address(genesMarket);&#13;
    }&#13;
&#13;
    function sellPop(uint256 _popId, uint256 _price) public {&#13;
        Pop storage pop = pops[_popId];&#13;
        require(pop.cooldownEndTimestamp &lt;= now);&#13;
        approve(address(marketManager),_popId);&#13;
        marketManager.sellPop(msg.sender,_popId,_price);&#13;
        emit SellingPop(msg.sender, _popId, _price);&#13;
    }&#13;
&#13;
    function sellGenes(uint256 _popId, uint256 _price) public {&#13;
        require(_popId &gt; 0);&#13;
        approve(address(genesMarket),_popId);&#13;
        genesMarket.startSellingGenes(_popId,_price,msg.sender);&#13;
        emit SellingGenes(msg.sender, _popId, _price);&#13;
    }&#13;
&#13;
    function getOwnerInAnyPlatformById(uint256 popId) public view returns (address){&#13;
      if(ownerOf(popId) == address(marketManager)){&#13;
        return marketManager.sellerOf(popId);&#13;
      }&#13;
      else if(ownerOf(popId) == address(genesMarket)){&#13;
        return genesMarket.sellerOf(popId);&#13;
      }&#13;
      else if(ownerOf(popId) == address(auctionManager)){&#13;
        return ceoAddress;&#13;
      }&#13;
      else{&#13;
        return ownerOf(popId);&#13;
      }&#13;
      return 0x0;&#13;
    }&#13;
&#13;
    function setPopName(uint256 popId, string newName) external {&#13;
      require(_ownerOfPopInAnyPlatform(popId));&#13;
      Pop storage pop = pops[popId];&#13;
      require(pop.generation &gt; 0);&#13;
      bytes32 name32 = stringToBytes32(newName);&#13;
      pop.popName = name32;&#13;
      emit ChangedPopName(msg.sender, popId, name32);&#13;
    }&#13;
&#13;
    function removeCooldown(uint256 popId)&#13;
      external&#13;
      payable&#13;
      {&#13;
        require(_ownerOfPopInAnyPlatform(popId));&#13;
        require(msg.value &gt;= refresherFee);&#13;
        Pop storage pop = pops[popId];&#13;
        pop.cooldownEndTimestamp = 1;&#13;
        emit CooldownRemoval(popId, msg.sender, refresherFee);&#13;
      }&#13;
&#13;
    function _ownerOfPopInAnyPlatform(uint _popId) internal view returns (bool) {&#13;
      return ownerOf(_popId) == msg.sender || genesMarket.sellerOf(_popId) == msg.sender || marketManager.sellerOf(_popId) == msg.sender;&#13;
    }&#13;
&#13;
    function getOwnershipForCloning(uint _popId) internal view returns (bool) {&#13;
        return ownerOf(_popId) == msg.sender || genesMarket.sellerOf(_popId) == msg.sender;&#13;
    }&#13;
&#13;
    function changeRefresherFee(uint256 _newFee) public onlyCLevel{&#13;
        refresherFee = _newFee;&#13;
    }&#13;
&#13;
    function cloneWithTwoPops(uint256 _aParentId, uint256 _bParentId)&#13;
      external&#13;
      whenNotPaused&#13;
      returns (uint256)&#13;
      {&#13;
        require(_aParentId &gt; 0);&#13;
        require(_bParentId &gt; 0);&#13;
        require(getOwnershipForCloning(_aParentId));&#13;
        require(getOwnershipForCloning(_bParentId));&#13;
        Pop storage aParent = pops[_aParentId];&#13;
&#13;
        Pop storage bParent = pops[_bParentId];&#13;
&#13;
        require(aParent.genes != bParent.genes);&#13;
        require(aParent.cooldownEndTimestamp &lt;= now);&#13;
        require(bParent.cooldownEndTimestamp &lt;= now);&#13;
&#13;
        uint16 parentGen = aParent.generation;&#13;
        if (bParent.generation &gt; aParent.generation) {&#13;
            parentGen = bParent.generation;&#13;
        }&#13;
&#13;
        uint16 cooldownIndex = parentGen + 1;&#13;
        if (cooldownIndex &gt; 13) {&#13;
            cooldownIndex = 13;&#13;
        }&#13;
&#13;
        uint256 childGenes = geneScience.mixGenes(aParent.genes, bParent.genes);&#13;
&#13;
        _triggerCooldown(aParent);&#13;
        _triggerCooldown(bParent);&#13;
&#13;
        uint256 index = pops.push(Pop(childGenes,uint64(now), 1, uint32(_aParentId), uint32(_bParentId), 0, cooldownIndex, parentGen + 1)) -1;&#13;
&#13;
        popIndexToOwner[index] = msg.sender;&#13;
        ownershipTokenCount[msg.sender] = ownershipTokenCount[msg.sender]+1;&#13;
&#13;
        emit CloneWithTwoPops(msg.sender, index, _aParentId, _bParentId);&#13;
        emit Birth(msg.sender, index, _aParentId, _bParentId,childGenes);&#13;
&#13;
        return index;&#13;
    }&#13;
&#13;
    function cloneWithPopAndBottle(uint256 _aParentId, uint256 _bParentId_bottle)&#13;
        external&#13;
        whenNotPaused&#13;
        returns (uint256)&#13;
        {&#13;
          require(_aParentId &gt; 0);&#13;
          require(getOwnershipForCloning(_aParentId));&#13;
          Pop storage aParent = pops[_aParentId];&#13;
          Pop memory bParent = pops[_bParentId_bottle];&#13;
&#13;
          require(aParent.genes != bParent.genes);&#13;
          require(aParent.cooldownEndTimestamp &lt;= now);&#13;
&#13;
          uint16 parentGen = aParent.generation;&#13;
          if (bParent.generation &gt; aParent.generation) {&#13;
              parentGen = bParent.generation;&#13;
          }&#13;
&#13;
          uint16 cooldownIndex = parentGen + 1;&#13;
          if (cooldownIndex &gt; 13) {&#13;
              cooldownIndex = 13;&#13;
          }&#13;
&#13;
          genesMarket.useBottle(msg.sender, _bParentId_bottle);&#13;
&#13;
          uint256 childGenes = geneScience.mixGenes(aParent.genes, bParent.genes);&#13;
&#13;
          _triggerCooldown(aParent);&#13;
&#13;
          uint256 index = pops.push(Pop(childGenes,uint64(now), 1, uint32(_aParentId), uint32(_bParentId_bottle), 0, cooldownIndex, parentGen + 1)) -1;&#13;
&#13;
          popIndexToOwner[index] = msg.sender;&#13;
          ownershipTokenCount[msg.sender] = ownershipTokenCount[msg.sender]+1;&#13;
&#13;
          emit CloneWithPopAndBottle(msg.sender, index, _aParentId, _bParentId_bottle);&#13;
          emit Birth(msg.sender, index, _aParentId, _bParentId_bottle, childGenes);&#13;
&#13;
          return index;&#13;
        }&#13;
}