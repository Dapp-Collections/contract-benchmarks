pragma solidity ^0.4.17;

/*

 * source       https://github.com/blockbitsio/

 * @name        Application Entity Generic Contract
 * @package     BlockBitsIO
 * @author      Micky Socaci <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="e78a8e848c9ea78988908b8e9182c99588">[email protected]</a>&gt;&#13;
&#13;
    Used for the ABI interface when assets need to call Application Entity.&#13;
&#13;
    This is required, otherwise we end up loading the assets themselves when we load the ApplicationEntity contract&#13;
    and end up in a loop&#13;
*/&#13;
&#13;
&#13;
&#13;
contract ApplicationEntityABI {&#13;
&#13;
    address public ProposalsEntity;&#13;
    address public FundingEntity;&#13;
    address public MilestonesEntity;&#13;
    address public MeetingsEntity;&#13;
    address public BountyManagerEntity;&#13;
    address public TokenManagerEntity;&#13;
    address public ListingContractEntity;&#13;
    address public FundingManagerEntity;&#13;
    address public NewsContractEntity;&#13;
&#13;
    bool public _initialized = false;&#13;
    bool public _locked = false;&#13;
    uint8 public CurrentEntityState;&#13;
    uint8 public AssetCollectionNum;&#13;
    address public GatewayInterfaceAddress;&#13;
    address public deployerAddress;&#13;
    address testAddressAllowUpgradeFrom;&#13;
    mapping (bytes32 =&gt; uint8) public EntityStates;&#13;
    mapping (bytes32 =&gt; address) public AssetCollection;&#13;
    mapping (uint8 =&gt; bytes32) public AssetCollectionIdToName;&#13;
    mapping (bytes32 =&gt; uint256) public BylawsUint256;&#13;
    mapping (bytes32 =&gt; bytes32) public BylawsBytes32;&#13;
&#13;
    function ApplicationEntity() public;&#13;
    function getEntityState(bytes32 name) public view returns (uint8);&#13;
    function linkToGateway( address _GatewayInterfaceAddress, bytes32 _sourceCodeUrl ) external;&#13;
    function setUpgradeState(uint8 state) public ;&#13;
    function addAssetProposals(address _assetAddresses) external;&#13;
    function addAssetFunding(address _assetAddresses) external;&#13;
    function addAssetMilestones(address _assetAddresses) external;&#13;
    function addAssetMeetings(address _assetAddresses) external;&#13;
    function addAssetBountyManager(address _assetAddresses) external;&#13;
    function addAssetTokenManager(address _assetAddresses) external;&#13;
    function addAssetFundingManager(address _assetAddresses) external;&#13;
    function addAssetListingContract(address _assetAddresses) external;&#13;
    function addAssetNewsContract(address _assetAddresses) external;&#13;
    function getAssetAddressByName(bytes32 _name) public view returns (address);&#13;
    function setBylawUint256(bytes32 name, uint256 value) public;&#13;
    function getBylawUint256(bytes32 name) public view returns (uint256);&#13;
    function setBylawBytes32(bytes32 name, bytes32 value) public;&#13;
    function getBylawBytes32(bytes32 name) public view returns (bytes32);&#13;
    function initialize() external returns (bool);&#13;
    function getParentAddress() external view returns(address);&#13;
    function createCodeUpgradeProposal( address _newAddress, bytes32 _sourceCodeUrl ) external returns (uint256);&#13;
    function acceptCodeUpgradeProposal(address _newAddress) external;&#13;
    function initializeAssetsToThisApplication() external returns (bool);&#13;
    function transferAssetsToNewApplication(address _newAddress) external returns (bool);&#13;
    function lock() external returns (bool);&#13;
    function canInitiateCodeUpgrade(address _sender) public view returns(bool);&#13;
    function doStateChanges() public;&#13;
    function hasRequiredStateChanges() public view returns (bool);&#13;
    function anyAssetHasChanges() public view returns (bool);&#13;
    function extendedAnyAssetHasChanges() internal view returns (bool);&#13;
    function getRequiredStateChanges() public view returns (uint8, uint8);&#13;
    function getTimestamp() view public returns (uint256);&#13;
&#13;
}&#13;
&#13;
/*&#13;
&#13;
 * source       https://github.com/blockbitsio/&#13;
&#13;
 * @name        Gateway Interface Contract&#13;
 * @package     BlockBitsIO&#13;
 * @author      Micky Socaci &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="0c61656f67754c62637b60657a69227e63">[email protected]</a>&gt;&#13;
&#13;
 Used as a resolver to retrieve the latest deployed version of the Application&#13;
&#13;
 ENS: gateway.main.blockbits.eth will point directly to this contract.&#13;
&#13;
    ADD ENS domain ownership / transfer methods&#13;
&#13;
*/&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
contract ABIGatewayInterface {&#13;
    address public currentApplicationEntityAddress;&#13;
    ApplicationEntityABI private currentApp;&#13;
    address public deployerAddress;&#13;
&#13;
    function getApplicationAddress() external view returns (address);&#13;
    function requestCodeUpgrade( address _newAddress, bytes32 _sourceCodeUrl ) external returns (bool);&#13;
    function approveCodeUpgrade( address _newAddress ) external returns (bool);&#13;
    function link( address _newAddress ) internal returns (bool);&#13;
    function getNewsContractAddress() external view returns (address);&#13;
    function getListingContractAddress() external view returns (address);&#13;
}&#13;
&#13;
/*&#13;
&#13;
 * source       https://github.com/blockbitsio/&#13;
&#13;
 * @name        Application Asset Contract ABI&#13;
 * @package     BlockBitsIO&#13;
 * @author      Micky Socaci &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="35585c565e4c755b5a42595c43501b475a">[email protected]</a>&gt;&#13;
&#13;
 Any contract inheriting this will be usable as an Asset in the Application Entity&#13;
&#13;
*/&#13;
&#13;
&#13;
&#13;
contract ABIApplicationAsset {&#13;
&#13;
    bytes32 public assetName;&#13;
    uint8 public CurrentEntityState;&#13;
    uint8 public RecordNum;&#13;
    bool public _initialized;&#13;
    bool public _settingsApplied;&#13;
    address public owner;&#13;
    address public deployerAddress;&#13;
    mapping (bytes32 =&gt; uint8) public EntityStates;&#13;
    mapping (bytes32 =&gt; uint8) public RecordStates;&#13;
&#13;
    function setInitialApplicationAddress(address _ownerAddress) public;&#13;
    function setInitialOwnerAndName(bytes32 _name) external returns (bool);&#13;
    function getRecordState(bytes32 name) public view returns (uint8);&#13;
    function getEntityState(bytes32 name) public view returns (uint8);&#13;
    function applyAndLockSettings() public returns(bool);&#13;
    function transferToNewOwner(address _newOwner) public returns (bool);&#13;
    function getApplicationAssetAddressByName(bytes32 _name) public returns(address);&#13;
    function getApplicationState() public view returns (uint8);&#13;
    function getApplicationEntityState(bytes32 name) public view returns (uint8);&#13;
    function getAppBylawUint256(bytes32 name) public view returns (uint256);&#13;
    function getAppBylawBytes32(bytes32 name) public view returns (bytes32);&#13;
    function getTimestamp() view public returns (uint256);&#13;
&#13;
&#13;
}&#13;
&#13;
/*&#13;
&#13;
 * source       https://github.com/blockbitsio/&#13;
&#13;
 * @name        Proposals Contract&#13;
 * @package     BlockBitsIO&#13;
 * @author      Micky Socaci &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="b5d8dcd6deccf5dbdac2d9dcc3d09bc7da">[email protected]</a>&gt;&#13;
&#13;
 Contains the Proposals Contract code deployed and linked to the Application Entity&#13;
&#13;
*/&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
contract ABIProposals is ABIApplicationAsset {&#13;
&#13;
    address public Application;&#13;
    address public ListingContractEntity;&#13;
    address public FundingEntity;&#13;
    address public FundingManagerEntity;&#13;
    address public TokenManagerEntity;&#13;
    address public TokenEntity;&#13;
    address public MilestonesEntity;&#13;
&#13;
    struct ProposalRecord {&#13;
        address creator;&#13;
        bytes32 name;&#13;
        uint8 actionType;&#13;
        uint8 state;&#13;
        bytes32 hash;                       // action name + args hash&#13;
        address addr;&#13;
        bytes32 sourceCodeUrl;&#13;
        uint256 extra;&#13;
        uint256 time_start;&#13;
        uint256 time_end;&#13;
        uint256 index;&#13;
    }&#13;
&#13;
    struct VoteStruct {&#13;
        address voter;&#13;
        uint256 time;&#13;
        bool    vote;&#13;
        uint256 power;&#13;
        bool    annulled;&#13;
        uint256 index;&#13;
    }&#13;
&#13;
    struct ResultRecord {&#13;
        uint256 totalAvailable;&#13;
        uint256 requiredForResult;&#13;
        uint256 totalSoFar;&#13;
        uint256 yes;&#13;
        uint256 no;&#13;
        bool    requiresCounting;&#13;
    }&#13;
&#13;
    uint8 public ActiveProposalNum;&#13;
    uint256 public VoteCountPerProcess;&#13;
    bool public EmergencyFundingReleaseApproved;&#13;
&#13;
    mapping (bytes32 =&gt; uint8) public ActionTypes;&#13;
    mapping (uint8 =&gt; uint256) public ActiveProposalIds;&#13;
    mapping (uint256 =&gt; bool) public ExpiredProposalIds;&#13;
    mapping (uint256 =&gt; ProposalRecord) public ProposalsById;&#13;
    mapping (bytes32 =&gt; uint256) public ProposalIdByHash;&#13;
    mapping (uint256 =&gt; mapping (uint256 =&gt; VoteStruct) ) public VotesByProposalId;&#13;
    mapping (uint256 =&gt; mapping (address =&gt; VoteStruct) ) public VotesByCaster;&#13;
    mapping (uint256 =&gt; uint256) public VotesNumByProposalId;&#13;
    mapping (uint256 =&gt; ResultRecord ) public ResultsByProposalId;&#13;
    mapping (uint256 =&gt; uint256) public lastProcessedVoteIdByProposal;&#13;
    mapping (uint256 =&gt; uint256) public ProcessedVotesByProposal;&#13;
    mapping (uint256 =&gt; uint256) public VoteCountAtProcessingStartByProposal;&#13;
&#13;
    function getRecordState(bytes32 name) public view returns (uint8);&#13;
    function getActionType(bytes32 name) public view returns (uint8);&#13;
    function getProposalState(uint256 _proposalId) public view returns (uint8);&#13;
    function getBylawsProposalVotingDuration() public view returns (uint256);&#13;
    function getBylawsMilestoneMinPostponing() public view returns (uint256);&#13;
    function getBylawsMilestoneMaxPostponing() public view returns (uint256);&#13;
    function getHash(uint8 actionType, bytes32 arg1, bytes32 arg2) public pure returns ( bytes32 );&#13;
    function process() public;&#13;
    function hasRequiredStateChanges() public view returns (bool);&#13;
    function getRequiredStateChanges() public view returns (uint8);&#13;
    function addCodeUpgradeProposal(address _addr, bytes32 _sourceCodeUrl) external returns (uint256);&#13;
    function createMilestoneAcceptanceProposal() external returns (uint256);&#13;
    function createMilestonePostponingProposal(uint256 _duration) external returns (uint256);&#13;
    function getCurrentMilestonePostponingProposalDuration() public view returns (uint256);&#13;
    function getCurrentMilestoneProposalStatusForType(uint8 _actionType ) public view returns (uint8);&#13;
    function createEmergencyFundReleaseProposal() external returns (uint256);&#13;
    function createDelistingProposal(uint256 _projectId) external returns (uint256);&#13;
    function RegisterVote(uint256 _proposalId, bool _myVote) public;&#13;
    function hasPreviousVote(uint256 _proposalId, address _voter) public view returns (bool);&#13;
    function getTotalTokenVotingPower(address _voter) public view returns ( uint256 );&#13;
    function getVotingPower(uint256 _proposalId, address _voter) public view returns ( uint256 );&#13;
    function setVoteCountPerProcess(uint256 _perProcess) external;&#13;
    function ProcessVoteTotals(uint256 _proposalId, uint256 length) public;&#13;
    function canEndVoting(uint256 _proposalId) public view returns (bool);&#13;
    function getProposalType(uint256 _proposalId) public view returns (uint8);&#13;
    function expiryChangesState(uint256 _proposalId) public view returns (bool);&#13;
    function needsProcessing(uint256 _proposalId) public view returns (bool);&#13;
    function getMyVoteForCurrentMilestoneRelease(address _voter) public view returns (bool);&#13;
    function getHasVoteForCurrentMilestoneRelease(address _voter) public view returns (bool);&#13;
    function getMyVote(uint256 _proposalId, address _voter) public view returns (bool);&#13;
&#13;
}&#13;
&#13;
/*&#13;
&#13;
 * source       https://github.com/blockbitsio/&#13;
&#13;
 * @name        Funding Contract ABI&#13;
 * @package     BlockBitsIO&#13;
 * @author      Micky Socaci &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="5835313b33211836372f34312e3d762a37">[email protected]</a>&gt;&#13;
&#13;
 Contains the Funding Contract code deployed and linked to the Application Entity&#13;
&#13;
&#13;
    !!! Links directly to Milestones&#13;
&#13;
*/&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
contract ABIFunding is ABIApplicationAsset {&#13;
&#13;
    address public multiSigOutputAddress;&#13;
    address public DirectInput;&#13;
    address public MilestoneInput;&#13;
    address public TokenManagerEntity;&#13;
    address public FundingManagerEntity;&#13;
&#13;
    struct FundingStage {&#13;
        bytes32 name;&#13;
        uint8   state;&#13;
        uint256 time_start;&#13;
        uint256 time_end;&#13;
        uint256 amount_cap_soft;            // 0 = not enforced&#13;
        uint256 amount_cap_hard;            // 0 = not enforced&#13;
        uint256 amount_raised;              // 0 = not enforced&#13;
        // funding method settings&#13;
        uint256 minimum_entry;&#13;
        uint8   methods;                    // FundingMethodIds&#13;
        // token settings&#13;
        uint256 fixed_tokens;&#13;
        uint8   price_addition_percentage;  //&#13;
        uint8   token_share_percentage;&#13;
        uint8   index;&#13;
    }&#13;
&#13;
    mapping (uint8 =&gt; FundingStage) public Collection;&#13;
    uint8 public FundingStageNum;&#13;
    uint8 public currentFundingStage;&#13;
    uint256 public AmountRaised;&#13;
    uint256 public MilestoneAmountRaised;&#13;
    uint256 public GlobalAmountCapSoft;&#13;
    uint256 public GlobalAmountCapHard;&#13;
    uint8 public TokenSellPercentage;&#13;
    uint256 public Funding_Setting_funding_time_start;&#13;
    uint256 public Funding_Setting_funding_time_end;&#13;
    uint256 public Funding_Setting_cashback_time_start;&#13;
    uint256 public Funding_Setting_cashback_time_end;&#13;
    uint256 public Funding_Setting_cashback_before_start_wait_duration;&#13;
    uint256 public Funding_Setting_cashback_duration;&#13;
&#13;
&#13;
    function addFundingStage(&#13;
        bytes32 _name,&#13;
        uint256 _time_start,&#13;
        uint256 _time_end,&#13;
        uint256 _amount_cap_soft,&#13;
        uint256 _amount_cap_hard,   // required &gt; 0&#13;
        uint8   _methods,&#13;
        uint256 _minimum_entry,&#13;
        uint256 _fixed_tokens,&#13;
        uint8   _price_addition_percentage,&#13;
        uint8   _token_share_percentage&#13;
    )&#13;
    public;&#13;
&#13;
    function addSettings(address _outputAddress, uint256 soft_cap, uint256 hard_cap, uint8 sale_percentage, address _direct, address _milestone ) public;&#13;
    function getStageAmount(uint8 StageId) public view returns ( uint256 );&#13;
    function allowedPaymentMethod(uint8 _payment_method) public pure returns (bool);&#13;
    function receivePayment(address _sender, uint8 _payment_method) payable public returns(bool);&#13;
    function canAcceptPayment(uint256 _amount) public view returns (bool);&#13;
    function getValueOverCurrentCap(uint256 _amount) public view returns (uint256);&#13;
    function isFundingStageUpdateAllowed(uint8 _new_state ) public view returns (bool);&#13;
    function getRecordStateRequiredChanges() public view returns (uint8);&#13;
    function doStateChanges() public;&#13;
    function hasRequiredStateChanges() public view returns (bool);&#13;
    function getRequiredStateChanges() public view returns (uint8, uint8, uint8);&#13;
&#13;
}&#13;
&#13;
/*&#13;
&#13;
 * source       https://github.com/blockbitsio/&#13;
&#13;
 * @name        Meetings Contract ABI&#13;
 * @package     BlockBitsIO&#13;
 * @author      Micky Socaci &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="6b06020800122b05041c07021d0e451904">[email protected]</a>&gt;&#13;
&#13;
 Contains the Meetings Contract code deployed and linked to the Application Entity&#13;
&#13;
*/&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
contract ABIMeetings is ABIApplicationAsset {&#13;
    struct Record {&#13;
        bytes32 hash;&#13;
        bytes32 name;&#13;
        uint8 state;&#13;
        uint256 time_start;                     // start at unixtimestamp&#13;
        uint256 duration;&#13;
        uint8 index;&#13;
    }&#13;
    mapping (uint8 =&gt; Record) public Collection;&#13;
}&#13;
&#13;
/*&#13;
&#13;
 * source       https://github.com/blockbitsio/&#13;
&#13;
 * @name        Milestones Contract&#13;
 * @package     BlockBitsIO&#13;
 * @author      Micky Socaci &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="1e73777d75675e7071697277687b306c71">[email protected]</a>&gt;&#13;
&#13;
 Contains the Milestones Contract code deployed and linked to the Application Entity&#13;
&#13;
*/&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
contract ABIMilestones is ABIApplicationAsset {&#13;
&#13;
    struct Record {&#13;
        bytes32 name;&#13;
        string description;                     // will change to hash pointer ( external storage )&#13;
        uint8 state;&#13;
        uint256 duration;&#13;
        uint256 time_start;                     // start at unixtimestamp&#13;
        uint256 last_state_change_time;         // time of last state change&#13;
        uint256 time_end;                       // estimated end time &gt;&gt; can be increased by proposal&#13;
        uint256 time_ended;                     // actual end time&#13;
        uint256 meeting_time;&#13;
        uint8 funding_percentage;&#13;
        uint8 index;&#13;
    }&#13;
&#13;
    uint8 public currentRecord;&#13;
    uint256 public MilestoneCashBackTime = 0;&#13;
    mapping (uint8 =&gt; Record) public Collection;&#13;
    mapping (bytes32 =&gt; bool) public MilestonePostponingHash;&#13;
    mapping (bytes32 =&gt; uint256) public ProposalIdByHash;&#13;
&#13;
    function getBylawsProjectDevelopmentStart() public view returns (uint256);&#13;
    function getBylawsMinTimeInTheFutureForMeetingCreation() public view returns (uint256);&#13;
    function getBylawsCashBackVoteRejectedDuration() public view returns (uint256);&#13;
    function addRecord( bytes32 _name, string _description, uint256 _duration, uint8 _perc ) public;&#13;
    function getMilestoneFundingPercentage(uint8 recordId) public view returns (uint8);&#13;
    function doStateChanges() public;&#13;
    function getRecordStateRequiredChanges() public view returns (uint8);&#13;
    function hasRequiredStateChanges() public view returns (bool);&#13;
    function afterVoteNoCashBackTime() public view returns ( bool );&#13;
    function getHash(uint8 actionType, bytes32 arg1, bytes32 arg2) public pure returns ( bytes32 );&#13;
    function getCurrentHash() public view returns ( bytes32 );&#13;
    function getCurrentProposalId() internal view returns ( uint256 );&#13;
    function setCurrentMilestoneMeetingTime(uint256 _meeting_time) public;&#13;
    function isRecordUpdateAllowed(uint8 _new_state ) public view returns (bool);&#13;
    function getRequiredStateChanges() public view returns (uint8, uint8, uint8);&#13;
    function ApplicationIsInDevelopment() public view returns(bool);&#13;
    function MeetingTimeSetFailure() public view returns (bool);&#13;
&#13;
}&#13;
&#13;
/*&#13;
&#13;
 * source       https://github.com/blockbitsio/&#13;
&#13;
 * @name        Bounty Program Contract ABI&#13;
 * @package     BlockBitsIO&#13;
 * @author      Micky Socaci &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="660b0f050d1f260809110a0f1003481409">[email protected]</a>&gt;&#13;
&#13;
  Bounty program contract that holds and distributes tokens upon successful funding.&#13;
&#13;
*/&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
contract ABIBountyManager is ABIApplicationAsset {&#13;
    function sendBounty( address _receiver, uint256 _amount ) public;&#13;
}&#13;
&#13;
/*&#13;
&#13;
 * source       https://github.com/blockbitsio/&#13;
&#13;
 * @name        Token Manager Contract&#13;
 * @package     BlockBitsIO&#13;
 * @author      Micky Socaci &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="96fbfff5fdefd6f8f9e1faffe0f3b8e4f9">[email protected]</a>&gt;&#13;
&#13;
*/&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
contract ABITokenManager is ABIApplicationAsset {&#13;
&#13;
    address public TokenSCADAEntity;&#13;
    address public TokenEntity;&#13;
    address public MarketingMethodAddress;&#13;
    bool OwnerTokenBalancesReleased = false;&#13;
&#13;
    function addSettings(address _scadaAddress, address _tokenAddress, address _marketing ) public;&#13;
    function getTokenSCADARequiresHardCap() public view returns (bool);&#13;
    function mint(address _to, uint256 _amount) public returns (bool);&#13;
    function finishMinting() public returns (bool);&#13;
    function mintForMarketingPool(address _to, uint256 _amount) external returns (bool);&#13;
    function ReleaseOwnersLockedTokens(address _multiSigOutputAddress) public returns (bool);&#13;
&#13;
}&#13;
&#13;
/*&#13;
&#13;
 * source       https://github.com/blockbitsio/&#13;
&#13;
 * @name        Funding Contract ABI&#13;
 * @package     BlockBitsIO&#13;
 * @author      Micky Socaci &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="f5989c969e8cb59b9a82999c8390db879a">[email protected]</a>&gt;&#13;
&#13;
 Contains the Funding Contract code deployed and linked to the Application Entity&#13;
&#13;
*/&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
contract ABIFundingManager is ABIApplicationAsset {&#13;
&#13;
    bool public fundingProcessed;&#13;
    bool FundingPoolBalancesAllocated;&#13;
    uint8 public VaultCountPerProcess;&#13;
    uint256 public lastProcessedVaultId;&#13;
    uint256 public vaultNum;&#13;
    uint256 public LockedVotingTokens;&#13;
    bytes32 public currentTask;&#13;
    mapping (bytes32 =&gt; bool) public taskByHash;&#13;
    mapping  (address =&gt; address) public vaultList;&#13;
    mapping  (uint256 =&gt; address) public vaultById;&#13;
&#13;
    function receivePayment(address _sender, uint8 _payment_method, uint8 _funding_stage) payable public returns(bool);&#13;
    function getMyVaultAddress(address _sender) public view returns (address);&#13;
    function setVaultCountPerProcess(uint8 _perProcess) external;&#13;
    function getHash(bytes32 actionType, bytes32 arg1) public pure returns ( bytes32 );&#13;
    function getCurrentMilestoneProcessed() public view returns (bool);&#13;
    function processFundingFailedFinished() public view returns (bool);&#13;
    function processFundingSuccessfulFinished() public view returns (bool);&#13;
    function getCurrentMilestoneIdHash() internal view returns (bytes32);&#13;
    function processMilestoneFinished() public view returns (bool);&#13;
    function processEmergencyFundReleaseFinished() public view returns (bool);&#13;
    function getAfterTransferLockedTokenBalances(address vaultAddress, bool excludeCurrent) public view returns (uint256);&#13;
    function VaultRequestedUpdateForLockedVotingTokens(address owner) public;&#13;
    function doStateChanges() public;&#13;
    function hasRequiredStateChanges() public view returns (bool);&#13;
    function getRequiredStateChanges() public view returns (uint8, uint8);&#13;
    function ApplicationInFundingOrDevelopment() public view returns(bool);&#13;
&#13;
}&#13;
&#13;
/*&#13;
&#13;
 * source       https://github.com/blockbitsio/&#13;
&#13;
 * @name        Listing Contract ABI&#13;
 * @package     BlockBitsIO&#13;
 * @author      Micky Socaci &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="e885818b8391a886879f84819e8dc69a87">[email protected]</a>&gt;&#13;
&#13;
*/&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
contract ABIListingContract is ABIApplicationAsset {&#13;
&#13;
    address public managerAddress;&#13;
    // child items&#13;
    struct item {&#13;
        bytes32 name;&#13;
        address itemAddress;&#13;
        bool    status;&#13;
        uint256 index;&#13;
    }&#13;
&#13;
    mapping ( uint256 =&gt; item ) public items;&#13;
    uint256 public itemNum;&#13;
&#13;
    function setManagerAddress(address _manager) public;&#13;
    function addItem(bytes32 _name, address _address) public;&#13;
    function getNewsContractAddress(uint256 _childId) external view returns (address);&#13;
    function canBeDelisted(uint256 _childId) public view returns (bool);&#13;
    function getChildStatus( uint256 _childId ) public view returns (bool);&#13;
    function delistChild( uint256 _childId ) public;&#13;
&#13;
}&#13;
&#13;
/*&#13;
&#13;
 * source       https://github.com/blockbitsio/&#13;
&#13;
 * @name        News Contract ABI&#13;
 * @package     BlockBitsIO&#13;
 * @author      Micky Socaci &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="4924202a22300927263e25203f2c673b26">[email protected]</a>&gt;&#13;
&#13;
*/&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
contract ABINewsContract is ABIApplicationAsset {&#13;
&#13;
    struct item {&#13;
        string hash;&#13;
        uint8 itemType;&#13;
        uint256 length;&#13;
    }&#13;
&#13;
    uint256 public itemNum = 0;&#13;
    mapping ( uint256 =&gt; item ) public items;&#13;
&#13;
    function addInternalMessage(uint8 state) public;&#13;
    function addItem(string _hash, uint256 _length) public;&#13;
}&#13;
&#13;
/*&#13;
&#13;
 * source       https://github.com/blockbitsio/&#13;
&#13;
 * @name        Application Entity Contract&#13;
 * @package     BlockBitsIO&#13;
 * @author      Micky Socaci &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="0f62666c64764f6160786366796a217d60">[email protected]</a>&gt;&#13;
&#13;
 Contains the main company Entity Contract code deployed and linked to the Gateway Interface.&#13;
&#13;
*/&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
contract ApplicationEntity {&#13;
&#13;
    /* Source Code Url */&#13;
    bytes32 sourceCodeUrl;&#13;
&#13;
    /* Entity initialised or not */&#13;
    bool public _initialized = false;&#13;
&#13;
    /* Entity locked or not */&#13;
    bool public _locked = false;&#13;
&#13;
    /* Current Entity State */&#13;
    uint8 public CurrentEntityState;&#13;
&#13;
    /* Available Entity State */&#13;
    mapping (bytes32 =&gt; uint8) public EntityStates;&#13;
&#13;
    /* GatewayInterface address */&#13;
    address public GatewayInterfaceAddress;&#13;
&#13;
    /* Parent Entity Instance */&#13;
    ABIGatewayInterface GatewayInterfaceEntity;&#13;
&#13;
    /* Asset Entities */&#13;
    ABIProposals public ProposalsEntity;&#13;
    ABIFunding public FundingEntity;&#13;
    ABIMilestones public MilestonesEntity;&#13;
    ABIMeetings public MeetingsEntity;&#13;
    ABIBountyManager public BountyManagerEntity;&#13;
    ABITokenManager public TokenManagerEntity;&#13;
    ABIListingContract public ListingContractEntity;&#13;
    ABIFundingManager public FundingManagerEntity;&#13;
    ABINewsContract public NewsContractEntity;&#13;
&#13;
    /* Asset Collection */&#13;
    mapping (bytes32 =&gt; address) public AssetCollection;&#13;
    mapping (uint8 =&gt; bytes32) public AssetCollectionIdToName;&#13;
    uint8 public AssetCollectionNum = 0;&#13;
&#13;
    event EventAppEntityReady ( address indexed _address );&#13;
    event EventAppEntityCodeUpgradeProposal ( address indexed _address, bytes32 indexed _sourceCodeUrl );&#13;
    event EventAppEntityInitAsset ( bytes32 indexed _name, address indexed _address );&#13;
    event EventAppEntityInitAssetsToThis ( uint8 indexed _assetNum );&#13;
    event EventAppEntityAssetsToNewApplication ( address indexed _address );&#13;
    event EventAppEntityLocked ( address indexed _address );&#13;
&#13;
    address public deployerAddress;&#13;
&#13;
    function ApplicationEntity() public {&#13;
        deployerAddress = msg.sender;&#13;
        setEntityStates();&#13;
        CurrentEntityState = getEntityState("NEW");&#13;
    }&#13;
&#13;
    function setEntityStates() internal {&#13;
&#13;
        // ApplicationEntity States&#13;
        EntityStates["__IGNORED__"]                 = 0;&#13;
        EntityStates["NEW"]                         = 1;&#13;
        EntityStates["WAITING"]                     = 2;&#13;
&#13;
        EntityStates["IN_FUNDING"]                  = 3;&#13;
&#13;
        EntityStates["IN_DEVELOPMENT"]              = 5;&#13;
        EntityStates["IN_CODE_UPGRADE"]             = 50;&#13;
&#13;
        EntityStates["UPGRADED"]                    = 100;&#13;
&#13;
        EntityStates["IN_GLOBAL_CASHBACK"]          = 150;&#13;
        EntityStates["LOCKED"]                      = 200;&#13;
&#13;
        EntityStates["DEVELOPMENT_COMPLETE"]        = 250;&#13;
    }&#13;
&#13;
    function getEntityState(bytes32 name) public view returns (uint8) {&#13;
        return EntityStates[name];&#13;
    }&#13;
&#13;
    /*&#13;
    * Initialize Application and it's assets&#13;
    * If gateway is freshly deployed, just link&#13;
    * else, create a voting proposal that needs to be accepted for the linking&#13;
    *&#13;
    * @param        address _newAddress&#13;
    * @param        bytes32 _sourceCodeUrl&#13;
    *&#13;
    * @modifiers    requireNoParent, requireNotInitialised&#13;
    */&#13;
    function linkToGateway(&#13;
        address _GatewayInterfaceAddress,&#13;
        bytes32 _sourceCodeUrl&#13;
    )&#13;
        external&#13;
        requireNoParent&#13;
        requireNotInitialised&#13;
        onlyDeployer&#13;
    {&#13;
        GatewayInterfaceAddress = _GatewayInterfaceAddress;&#13;
        sourceCodeUrl = _sourceCodeUrl;&#13;
&#13;
        // init gateway entity and set app address&#13;
        GatewayInterfaceEntity = ABIGatewayInterface(GatewayInterfaceAddress);&#13;
        GatewayInterfaceEntity.requestCodeUpgrade( address(this), sourceCodeUrl );&#13;
    }&#13;
&#13;
    function setUpgradeState(uint8 state) public onlyGatewayInterface {&#13;
        CurrentEntityState = state;&#13;
    }&#13;
&#13;
    /*&#13;
        For the sake of simplicity, and solidity warnings about "unknown gas usage" do this.. instead of sending&#13;
        an array of addresses&#13;
    */&#13;
    function addAssetProposals(address _assetAddresses) external requireNotInitialised onlyDeployer {&#13;
        ProposalsEntity = ABIProposals(_assetAddresses);&#13;
        assetInitialized("Proposals", _assetAddresses);&#13;
    }&#13;
&#13;
    function addAssetFunding(address _assetAddresses) external requireNotInitialised onlyDeployer {&#13;
        FundingEntity = ABIFunding(_assetAddresses);&#13;
        assetInitialized("Funding", _assetAddresses);&#13;
    }&#13;
&#13;
    function addAssetMilestones(address _assetAddresses) external requireNotInitialised onlyDeployer {&#13;
        MilestonesEntity = ABIMilestones(_assetAddresses);&#13;
        assetInitialized("Milestones", _assetAddresses);&#13;
    }&#13;
&#13;
    function addAssetMeetings(address _assetAddresses) external requireNotInitialised onlyDeployer {&#13;
        MeetingsEntity = ABIMeetings(_assetAddresses);&#13;
        assetInitialized("Meetings", _assetAddresses);&#13;
    }&#13;
&#13;
    function addAssetBountyManager(address _assetAddresses) external requireNotInitialised onlyDeployer {&#13;
        BountyManagerEntity = ABIBountyManager(_assetAddresses);&#13;
        assetInitialized("BountyManager", _assetAddresses);&#13;
    }&#13;
&#13;
    function addAssetTokenManager(address _assetAddresses) external requireNotInitialised onlyDeployer {&#13;
        TokenManagerEntity = ABITokenManager(_assetAddresses);&#13;
        assetInitialized("TokenManager", _assetAddresses);&#13;
    }&#13;
&#13;
    function addAssetFundingManager(address _assetAddresses) external requireNotInitialised onlyDeployer {&#13;
        FundingManagerEntity = ABIFundingManager(_assetAddresses);&#13;
        assetInitialized("FundingManager", _assetAddresses);&#13;
    }&#13;
&#13;
    function addAssetListingContract(address _assetAddresses) external requireNotInitialised onlyDeployer {&#13;
        ListingContractEntity = ABIListingContract(_assetAddresses);&#13;
        assetInitialized("ListingContract", _assetAddresses);&#13;
    }&#13;
&#13;
    function addAssetNewsContract(address _assetAddresses) external requireNotInitialised onlyDeployer {&#13;
        NewsContractEntity = ABINewsContract(_assetAddresses);&#13;
        assetInitialized("NewsContract", _assetAddresses);&#13;
    }&#13;
&#13;
    function assetInitialized(bytes32 name, address _assetAddresses) internal {&#13;
        if(AssetCollection[name] == 0x0) {&#13;
            AssetCollectionIdToName[AssetCollectionNum] = name;&#13;
            AssetCollection[name] = _assetAddresses;&#13;
            AssetCollectionNum++;&#13;
        } else {&#13;
            // just replace&#13;
            AssetCollection[name] = _assetAddresses;&#13;
        }&#13;
        EventAppEntityInitAsset(name, _assetAddresses);&#13;
    }&#13;
&#13;
    function getAssetAddressByName(bytes32 _name) public view returns (address) {&#13;
        return AssetCollection[_name];&#13;
    }&#13;
&#13;
    /* Application Bylaws mapping */&#13;
    mapping (bytes32 =&gt; uint256) public BylawsUint256;&#13;
    mapping (bytes32 =&gt; bytes32) public BylawsBytes32;&#13;
&#13;
&#13;
    function setBylawUint256(bytes32 name, uint256 value) public requireNotInitialised onlyDeployer {&#13;
        BylawsUint256[name] = value;&#13;
    }&#13;
&#13;
    function getBylawUint256(bytes32 name) public view requireInitialised returns (uint256) {&#13;
        return BylawsUint256[name];&#13;
    }&#13;
&#13;
    function setBylawBytes32(bytes32 name, bytes32 value) public requireNotInitialised onlyDeployer {&#13;
        BylawsBytes32[name] = value;&#13;
    }&#13;
&#13;
    function getBylawBytes32(bytes32 name) public view requireInitialised returns (bytes32) {&#13;
        return BylawsBytes32[name];&#13;
    }&#13;
&#13;
    function initialize() external requireNotInitialised onlyGatewayInterface returns (bool) {&#13;
        _initialized = true;&#13;
        EventAppEntityReady( address(this) );&#13;
        return true;&#13;
    }&#13;
&#13;
    function getParentAddress() external view returns(address) {&#13;
        return GatewayInterfaceAddress;&#13;
    }&#13;
&#13;
    function createCodeUpgradeProposal(&#13;
        address _newAddress,&#13;
        bytes32 _sourceCodeUrl&#13;
    )&#13;
        external&#13;
        requireInitialised&#13;
        onlyGatewayInterface&#13;
        returns (uint256)&#13;
    {&#13;
        // proposals create new.. code upgrade proposal&#13;
        EventAppEntityCodeUpgradeProposal ( _newAddress, _sourceCodeUrl );&#13;
&#13;
        // return true;&#13;
        return ProposalsEntity.addCodeUpgradeProposal(_newAddress, _sourceCodeUrl);&#13;
    }&#13;
&#13;
    /*&#13;
    * Only a proposal can update the ApplicationEntity Contract address&#13;
    *&#13;
    * @param        address _newAddress&#13;
    * @modifiers    onlyProposalsAsset&#13;
    */&#13;
    function acceptCodeUpgradeProposal(address _newAddress) external onlyProposalsAsset  {&#13;
        GatewayInterfaceEntity.approveCodeUpgrade( _newAddress );&#13;
    }&#13;
&#13;
    function initializeAssetsToThisApplication() external onlyGatewayInterface returns (bool) {&#13;
&#13;
        for(uint8 i = 0; i &lt; AssetCollectionNum; i++ ) {&#13;
            bytes32 _name = AssetCollectionIdToName[i];&#13;
            address current = AssetCollection[_name];&#13;
            if(current != address(0x0)) {&#13;
                if(!current.call(bytes4(keccak256("setInitialOwnerAndName(bytes32)")), _name) ) {&#13;
                    revert();&#13;
                }&#13;
            } else {&#13;
                revert();&#13;
            }&#13;
        }&#13;
        EventAppEntityInitAssetsToThis( AssetCollectionNum );&#13;
&#13;
        return true;&#13;
    }&#13;
&#13;
    function transferAssetsToNewApplication(address _newAddress) external onlyGatewayInterface returns (bool){&#13;
        for(uint8 i = 0; i &lt; AssetCollectionNum; i++ ) {&#13;
            &#13;
            bytes32 _name = AssetCollectionIdToName[i];&#13;
            address current = AssetCollection[_name];&#13;
            if(current != address(0x0)) {&#13;
                if(!current.call(bytes4(keccak256("transferToNewOwner(address)")), _newAddress) ) {&#13;
                    revert();&#13;
                }&#13;
            } else {&#13;
                revert();&#13;
            }&#13;
        }&#13;
        EventAppEntityAssetsToNewApplication ( _newAddress );&#13;
        return true;&#13;
    }&#13;
&#13;
    /*&#13;
    * Only the gateway interface can lock current app after a successful code upgrade proposal&#13;
    *&#13;
    * @modifiers    onlyGatewayInterface&#13;
    */&#13;
    function lock() external onlyGatewayInterface returns (bool) {&#13;
        _locked = true;&#13;
        CurrentEntityState = getEntityState("UPGRADED");&#13;
        EventAppEntityLocked(address(this));&#13;
        return true;&#13;
    }&#13;
&#13;
    /*&#13;
        DUMMY METHOD, to be replaced in a future Code Upgrade with a check to determine if sender should be able to initiate a code upgrade&#13;
        specifically used after milestone development completes&#13;
    */&#13;
    address testAddressAllowUpgradeFrom;&#13;
    function canInitiateCodeUpgrade(address _sender) public view returns(bool) {&#13;
        // suppress warning&#13;
        if(testAddressAllowUpgradeFrom != 0x0 &amp;&amp; testAddressAllowUpgradeFrom == _sender) {&#13;
            return true;&#13;
        }&#13;
        return false;&#13;
    }&#13;
&#13;
    /*&#13;
    * Throws if called by any other entity except GatewayInterface&#13;
    */&#13;
    modifier onlyGatewayInterface() {&#13;
        require(GatewayInterfaceAddress != address(0) &amp;&amp; msg.sender == GatewayInterfaceAddress);&#13;
        _;&#13;
    }&#13;
&#13;
    /*&#13;
    * Throws if called by any other entity except Proposals Asset Contract&#13;
    */&#13;
    modifier onlyProposalsAsset() {&#13;
        require(msg.sender == address(ProposalsEntity));&#13;
        _;&#13;
    }&#13;
&#13;
    modifier requireNoParent() {&#13;
        require(GatewayInterfaceAddress == address(0x0));&#13;
        _;&#13;
    }&#13;
&#13;
    modifier requireNotInitialised() {&#13;
        require(_initialized == false &amp;&amp; _locked == false);&#13;
        _;&#13;
    }&#13;
&#13;
    modifier requireInitialised() {&#13;
        require(_initialized == true &amp;&amp; _locked == false);&#13;
        _;&#13;
    }&#13;
&#13;
    modifier onlyDeployer() {&#13;
        require(msg.sender == deployerAddress);&#13;
        _;&#13;
    }&#13;
&#13;
    event DebugApplicationRequiredChanges( uint8 indexed _current, uint8 indexed _required );&#13;
    event EventApplicationEntityProcessor(uint8 indexed _current, uint8 indexed _required);&#13;
&#13;
    /*&#13;
        We could create a generic method that iterates through all assets, and using assembly language get the return&#13;
        value of the "hasRequiredStateChanges" method on each asset. Based on return, run doStateChanges on them or not.&#13;
&#13;
        Or we could be using a generic ABI contract that only defines the "hasRequiredStateChanges" and "doStateChanges"&#13;
        methods thus not requiring any assembly variable / memory management&#13;
&#13;
        Problem with both cases is the fact that our application needs to change only specific asset states depending&#13;
        on it's own current state, thus making a generic call wasteful in gas usage.&#13;
&#13;
        Let's stay away from that and follow the same approach as we do inside an asset.&#13;
        - view method: -&gt; get required state changes&#13;
        - view method: -&gt; has state changes&#13;
        - processor that does the actual changes.&#13;
        - doStateChanges recursive method that runs the processor if views require it to.&#13;
&#13;
        // pretty similar to FundingManager&#13;
    */&#13;
&#13;
    function doStateChanges() public {&#13;
&#13;
        if(!_locked) {&#13;
            // process assets first so we can initialize them from NEW to WAITING&#13;
            AssetProcessor();&#13;
&#13;
            var (returnedCurrentEntityState, EntityStateRequired) = getRequiredStateChanges();&#13;
            bool callAgain = false;&#13;
&#13;
            DebugApplicationRequiredChanges( returnedCurrentEntityState, EntityStateRequired );&#13;
&#13;
            if(EntityStateRequired != getEntityState("__IGNORED__") ) {&#13;
                EntityProcessor(EntityStateRequired);&#13;
                callAgain = true;&#13;
            }&#13;
        } else {&#13;
            revert();&#13;
        }&#13;
    }&#13;
&#13;
    function hasRequiredStateChanges() public view returns (bool) {&#13;
        bool hasChanges = false;&#13;
        if(!_locked) {&#13;
            var (returnedCurrentEntityState, EntityStateRequired) = getRequiredStateChanges();&#13;
            // suppress unused local variable warning&#13;
            returnedCurrentEntityState = 0;&#13;
            if(EntityStateRequired != getEntityState("__IGNORED__") ) {&#13;
                hasChanges = true;&#13;
            }&#13;
&#13;
            if(anyAssetHasChanges()) {&#13;
                hasChanges = true;&#13;
            }&#13;
        }&#13;
        return hasChanges;&#13;
    }&#13;
&#13;
    function anyAssetHasChanges() public view returns (bool) {&#13;
        if( FundingEntity.hasRequiredStateChanges() ) {&#13;
            return true;&#13;
        }&#13;
        if( FundingManagerEntity.hasRequiredStateChanges() ) {&#13;
            return true;&#13;
        }&#13;
        if( MilestonesEntity.hasRequiredStateChanges() ) {&#13;
            return true;&#13;
        }&#13;
        if( ProposalsEntity.hasRequiredStateChanges() ) {&#13;
            return true;&#13;
        }&#13;
&#13;
        return extendedAnyAssetHasChanges();&#13;
    }&#13;
&#13;
    // use this when extending "has changes"&#13;
    function extendedAnyAssetHasChanges() internal view returns (bool) {&#13;
        if(_initialized) {}&#13;
        return false;&#13;
    }&#13;
&#13;
    // use this when extending "asset state processor"&#13;
    function extendedAssetProcessor() internal  {&#13;
        // does not exist, but we check anyway to bypass compier warning about function state mutability&#13;
        if ( CurrentEntityState == 255 ) {&#13;
            ProposalsEntity.process();&#13;
        }&#13;
    }&#13;
&#13;
    // view methods decide if changes are to be made&#13;
    // in case of tasks, we do them in the Processors.&#13;
&#13;
    function AssetProcessor() internal {&#13;
&#13;
&#13;
        if ( CurrentEntityState == getEntityState("NEW") ) {&#13;
&#13;
            // move all assets that have states to "WAITING"&#13;
            if(FundingEntity.hasRequiredStateChanges()) {&#13;
                FundingEntity.doStateChanges();&#13;
            }&#13;
&#13;
            if(FundingManagerEntity.hasRequiredStateChanges()) {&#13;
                FundingManagerEntity.doStateChanges();&#13;
            }&#13;
&#13;
            if( MilestonesEntity.hasRequiredStateChanges() ) {&#13;
                MilestonesEntity.doStateChanges();&#13;
            }&#13;
&#13;
        } else if ( CurrentEntityState == getEntityState("WAITING") ) {&#13;
&#13;
            if( FundingEntity.hasRequiredStateChanges() ) {&#13;
                FundingEntity.doStateChanges();&#13;
            }&#13;
        }&#13;
        else if ( CurrentEntityState == getEntityState("IN_FUNDING") ) {&#13;
&#13;
            if( FundingEntity.hasRequiredStateChanges() ) {&#13;
                FundingEntity.doStateChanges();&#13;
            }&#13;
&#13;
            if( FundingManagerEntity.hasRequiredStateChanges() ) {&#13;
                FundingManagerEntity.doStateChanges();&#13;
            }&#13;
        }&#13;
        else if ( CurrentEntityState == getEntityState("IN_DEVELOPMENT") ) {&#13;
&#13;
            if( FundingManagerEntity.hasRequiredStateChanges() ) {&#13;
                FundingManagerEntity.doStateChanges();&#13;
            }&#13;
&#13;
            if(MilestonesEntity.hasRequiredStateChanges()) {&#13;
                MilestonesEntity.doStateChanges();&#13;
            }&#13;
&#13;
            if(ProposalsEntity.hasRequiredStateChanges()) {&#13;
                ProposalsEntity.process();&#13;
            }&#13;
        }&#13;
        else if ( CurrentEntityState == getEntityState("DEVELOPMENT_COMPLETE") ) {&#13;
&#13;
            if(ProposalsEntity.hasRequiredStateChanges()) {&#13;
                ProposalsEntity.process();&#13;
            }&#13;
        }&#13;
&#13;
        extendedAssetProcessor();&#13;
    }&#13;
&#13;
    function EntityProcessor(uint8 EntityStateRequired) internal {&#13;
&#13;
        EventApplicationEntityProcessor( CurrentEntityState, EntityStateRequired );&#13;
&#13;
        // Update our Entity State&#13;
        CurrentEntityState = EntityStateRequired;&#13;
&#13;
        // Do State Specific Updates&#13;
&#13;
        if ( EntityStateRequired == getEntityState("IN_FUNDING") ) {&#13;
            // run Funding state changer&#13;
            // doStateChanges&#13;
        }&#13;
&#13;
        // EntityStateRequired = getEntityState("IN_FUNDING");&#13;
&#13;
&#13;
        // Funding Failed&#13;
        /*&#13;
        if ( EntityStateRequired == getEntityState("FUNDING_FAILED_START") ) {&#13;
            // set ProcessVaultList Task&#13;
            currentTask = getHash("FUNDING_FAILED_START", "");&#13;
            CurrentEntityState = getEntityState("FUNDING_FAILED_PROGRESS");&#13;
        } else if ( EntityStateRequired == getEntityState("FUNDING_FAILED_PROGRESS") ) {&#13;
            ProcessVaultList(VaultCountPerProcess);&#13;
&#13;
            // Funding Successful&#13;
        } else if ( EntityStateRequired == getEntityState("FUNDING_SUCCESSFUL_START") ) {&#13;
&#13;
            // init SCADA variable cache.&#13;
            if(TokenSCADAEntity.initCacheForVariables()) {&#13;
                // start processing vaults&#13;
                currentTask = getHash("FUNDING_SUCCESSFUL_START", "");&#13;
                CurrentEntityState = getEntityState("FUNDING_SUCCESSFUL_PROGRESS");&#13;
            } else {&#13;
                // something went really wrong, just bail out for now&#13;
                CurrentEntityState = getEntityState("FUNDING_FAILED_START");&#13;
            }&#13;
        } else if ( EntityStateRequired == getEntityState("FUNDING_SUCCESSFUL_PROGRESS") ) {&#13;
            ProcessVaultList(VaultCountPerProcess);&#13;
            // Milestones&#13;
        } else if ( EntityStateRequired == getEntityState("MILESTONE_PROCESS_START") ) {&#13;
            currentTask = getHash("MILESTONE_PROCESS_START", getCurrentMilestoneId() );&#13;
            CurrentEntityState = getEntityState("MILESTONE_PROCESS_PROGRESS");&#13;
        } else if ( EntityStateRequired == getEntityState("MILESTONE_PROCESS_PROGRESS") ) {&#13;
            ProcessVaultList(VaultCountPerProcess);&#13;
&#13;
            // Completion&#13;
        } else if ( EntityStateRequired == getEntityState("COMPLETE_PROCESS_START") ) {&#13;
            currentTask = getHash("COMPLETE_PROCESS_START", "");&#13;
            CurrentEntityState = getEntityState("COMPLETE_PROCESS_PROGRESS");&#13;
        } else if ( EntityStateRequired == getEntityState("COMPLETE_PROCESS_PROGRESS") ) {&#13;
            ProcessVaultList(VaultCountPerProcess);&#13;
        }&#13;
        */&#13;
    }&#13;
&#13;
    /*&#13;
     * Method: Get Entity Required State Changes&#13;
     *&#13;
     * @access       public&#13;
     * @type         method&#13;
     *&#13;
     * @return       ( uint8 CurrentEntityState, uint8 EntityStateRequired )&#13;
     */&#13;
    function getRequiredStateChanges() public view returns (uint8, uint8) {&#13;
&#13;
        uint8 EntityStateRequired = getEntityState("__IGNORED__");&#13;
&#13;
        if( CurrentEntityState == getEntityState("NEW") ) {&#13;
            // general so we know we initialized&#13;
            EntityStateRequired = getEntityState("WAITING");&#13;
&#13;
        } else if ( CurrentEntityState == getEntityState("WAITING") ) {&#13;
&#13;
            // Funding Started&#13;
            if( FundingEntity.CurrentEntityState() == FundingEntity.getEntityState("IN_PROGRESS") ) {&#13;
                EntityStateRequired = getEntityState("IN_FUNDING");&#13;
            }&#13;
&#13;
        } else if ( CurrentEntityState == getEntityState("IN_FUNDING") ) {&#13;
&#13;
            if(FundingEntity.CurrentEntityState() == FundingEntity.getEntityState("SUCCESSFUL_FINAL")) {&#13;
                // SUCCESSFUL_FINAL means FUNDING was successful, and FundingManager has finished distributing tokens and ether&#13;
                EntityStateRequired = getEntityState("IN_DEVELOPMENT");&#13;
&#13;
            } else if(FundingEntity.CurrentEntityState() == FundingEntity.getEntityState("FAILED_FINAL")) {&#13;
                // Funding failed..&#13;
                EntityStateRequired = getEntityState("IN_GLOBAL_CASHBACK");&#13;
            }&#13;
&#13;
        } else if ( CurrentEntityState == getEntityState("IN_DEVELOPMENT") ) {&#13;
&#13;
            // this is where most things happen&#13;
            // milestones get developed&#13;
            // code upgrades get initiated&#13;
            // proposals get created and voted&#13;
&#13;
            /*&#13;
            if(ProposalsEntity.CurrentEntityState() == ProposalsEntity.getEntityState("CODE_UPGRADE_ACCEPTED")) {&#13;
                // check if we have an upgrade proposal that is accepted and move into said state&#13;
                EntityStateRequired = getEntityState("START_CODE_UPGRADE");&#13;
            }&#13;
            else&#13;
            */&#13;
&#13;
            if(MilestonesEntity.CurrentEntityState() == MilestonesEntity.getEntityState("DEVELOPMENT_COMPLETE")) {&#13;
                // check if we finished developing all milestones .. and if so move state to complete.&#13;
                EntityStateRequired = getEntityState("DEVELOPMENT_COMPLETE");&#13;
            }&#13;
&#13;
            if(MilestonesEntity.CurrentEntityState() == MilestonesEntity.getEntityState("DEADLINE_MEETING_TIME_FAILED")) {&#13;
                EntityStateRequired = getEntityState("IN_GLOBAL_CASHBACK");&#13;
            }&#13;
&#13;
        } else if ( CurrentEntityState == getEntityState("START_CODE_UPGRADE") ) {&#13;
&#13;
            // check stuff to move into IN_CODE_UPGRADE&#13;
            // EntityStateRequired = getEntityState("IN_CODE_UPGRADE");&#13;
&#13;
        } else if ( CurrentEntityState == getEntityState("IN_CODE_UPGRADE") ) {&#13;
&#13;
            // check stuff to finish&#13;
            // EntityStateRequired = getEntityState("FINISHED_CODE_UPGRADE");&#13;
&#13;
        } else if ( CurrentEntityState == getEntityState("FINISHED_CODE_UPGRADE") ) {&#13;
&#13;
            // move to IN_DEVELOPMENT or DEVELOPMENT_COMPLETE based on state before START_CODE_UPGRADE.&#13;
            // EntityStateRequired = getEntityState("DEVELOPMENT_COMPLETE");&#13;
            // EntityStateRequired = getEntityState("FINISHED_CODE_UPGRADE");&#13;
&#13;
        }&#13;
&#13;
        return (CurrentEntityState, EntityStateRequired);&#13;
    }&#13;
&#13;
    function getTimestamp() view public returns (uint256) {&#13;
        return now;&#13;
    }&#13;
&#13;
}