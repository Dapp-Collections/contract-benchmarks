pragma solidity ^0.4.18;

// File: contracts/Ownable.sol

/**
 * @title Ownable
 * @dev The Ownable contract has an owner address, and provides basic authorization control
 * functions, this simplifies the implementation of "user permissions".
 */
contract Ownable {
  address public owner;


  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);


  /**
   * @dev The Ownable constructor sets the original `owner` of the contract to the sender
   * account.
   */
  function Ownable() public {
    owner = msg.sender;
  }

  /**
   * @dev Throws if called by any account other than the owner.
   */
  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }

  /**
   * @dev Allows the current owner to transfer control of the contract to a newOwner.
   * @param newOwner The address to transfer ownership to.
   */
  function transferOwnership(address newOwner) public onlyOwner {
    require(newOwner != address(0));
    OwnershipTransferred(owner, newOwner);
    owner = newOwner;
  }

}

// File: contracts/strings.sol

/*
 * @title String & slice utility library for Solidity contracts.
 * @author Nick Johnson <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="74150615171c1a1d10341a1b00101b005a1a1100">[emailÂ protected]</a>&gt;&#13;
 *&#13;
 * @dev Functionality in this library is largely implemented using an&#13;
 *      abstraction called a 'slice'. A slice represents a part of a string -&#13;
 *      anything from the entire string to a single character, or even no&#13;
 *      characters at all (a 0-length slice). Since a slice only has to specify&#13;
 *      an offset and a length, copying and manipulating slices is a lot less&#13;
 *      expensive than copying and manipulating the strings they reference.&#13;
 *&#13;
 *      To further reduce gas costs, most functions on slice that need to return&#13;
 *      a slice modify the original one instead of allocating a new one; for&#13;
 *      instance, `s.split(".")` will return the text up to the first '.',&#13;
 *      modifying s to only contain the remainder of the string after the '.'.&#13;
 *      In situations where you do not want to modify the original slice, you&#13;
 *      can make a copy first with `.copy()`, for example:&#13;
 *      `s.copy().split(".")`. Try and avoid using this idiom in loops; since&#13;
 *      Solidity has no memory management, it will result in allocating many&#13;
 *      short-lived slices that are later discarded.&#13;
 *&#13;
 *      Functions that return two slices come in two versions: a non-allocating&#13;
 *      version that takes the second slice as an argument, modifying it in&#13;
 *      place, and an allocating version that allocates and returns the second&#13;
 *      slice; see `nextRune` for example.&#13;
 *&#13;
 *      Functions that have to copy string data will return strings rather than&#13;
 *      slices; these can be cast back to slices for further processing if&#13;
 *      required.&#13;
 *&#13;
 *      For convenience, some functions are provided with non-modifying&#13;
 *      variants that create a new slice and return both; for instance,&#13;
 *      `s.splitNew('.')` leaves s unmodified, and returns two values&#13;
 *      corresponding to the left and right parts of the string.&#13;
 */&#13;
&#13;
pragma solidity ^0.4.14;&#13;
&#13;
library strings {&#13;
    struct slice {&#13;
        uint _len;&#13;
        uint _ptr;&#13;
    }&#13;
&#13;
    function memcpy(uint dest, uint src, uint len) private pure {&#13;
        // Copy word-length chunks while possible&#13;
        for(; len &gt;= 32; len -= 32) {&#13;
            assembly {&#13;
                mstore(dest, mload(src))&#13;
            }&#13;
            dest += 32;&#13;
            src += 32;&#13;
        }&#13;
&#13;
        // Copy remaining bytes&#13;
        uint mask = 256 ** (32 - len) - 1;&#13;
        assembly {&#13;
            let srcpart := and(mload(src), not(mask))&#13;
            let destpart := and(mload(dest), mask)&#13;
            mstore(dest, or(destpart, srcpart))&#13;
        }&#13;
    }&#13;
&#13;
    /*&#13;
     * @dev Returns a slice containing the entire string.&#13;
     * @param self The string to make a slice from.&#13;
     * @return A newly allocated slice containing the entire string.&#13;
     */&#13;
    function toSlice(string self) internal pure returns (slice) {&#13;
        uint ptr;&#13;
        assembly {&#13;
            ptr := add(self, 0x20)&#13;
        }&#13;
        return slice(bytes(self).length, ptr);&#13;
    }&#13;
&#13;
    /*&#13;
     * @dev Returns the length of a null-terminated bytes32 string.&#13;
     * @param self The value to find the length of.&#13;
     * @return The length of the string, from 0 to 32.&#13;
     */&#13;
    function len(bytes32 self) internal pure returns (uint) {&#13;
        uint ret;&#13;
        if (self == 0)&#13;
            return 0;&#13;
        if (self &amp; 0xffffffffffffffffffffffffffffffff == 0) {&#13;
            ret += 16;&#13;
            self = bytes32(uint(self) / 0x100000000000000000000000000000000);&#13;
        }&#13;
        if (self &amp; 0xffffffffffffffff == 0) {&#13;
            ret += 8;&#13;
            self = bytes32(uint(self) / 0x10000000000000000);&#13;
        }&#13;
        if (self &amp; 0xffffffff == 0) {&#13;
            ret += 4;&#13;
            self = bytes32(uint(self) / 0x100000000);&#13;
        }&#13;
        if (self &amp; 0xffff == 0) {&#13;
            ret += 2;&#13;
            self = bytes32(uint(self) / 0x10000);&#13;
        }&#13;
        if (self &amp; 0xff == 0) {&#13;
            ret += 1;&#13;
        }&#13;
        return 32 - ret;&#13;
    }&#13;
&#13;
    /*&#13;
     * @dev Returns a slice containing the entire bytes32, interpreted as a&#13;
     *      null-terminated utf-8 string.&#13;
     * @param self The bytes32 value to convert to a slice.&#13;
     * @return A new slice containing the value of the input argument up to the&#13;
     *         first null.&#13;
     */&#13;
    function toSliceB32(bytes32 self) internal pure returns (slice ret) {&#13;
        // Allocate space for `self` in memory, copy it there, and point ret at it&#13;
        assembly {&#13;
            let ptr := mload(0x40)&#13;
            mstore(0x40, add(ptr, 0x20))&#13;
            mstore(ptr, self)&#13;
            mstore(add(ret, 0x20), ptr)&#13;
        }&#13;
        ret._len = len(self);&#13;
    }&#13;
&#13;
    /*&#13;
     * @dev Returns a new slice containing the same data as the current slice.&#13;
     * @param self The slice to copy.&#13;
     * @return A new slice containing the same data as `self`.&#13;
     */&#13;
    function copy(slice self) internal pure returns (slice) {&#13;
        return slice(self._len, self._ptr);&#13;
    }&#13;
&#13;
    /*&#13;
     * @dev Copies a slice to a new string.&#13;
     * @param self The slice to copy.&#13;
     * @return A newly allocated string containing the slice's text.&#13;
     */&#13;
    function toString(slice self) internal pure returns (string) {&#13;
        string memory ret = new string(self._len);&#13;
        uint retptr;&#13;
        assembly { retptr := add(ret, 32) }&#13;
&#13;
        memcpy(retptr, self._ptr, self._len);&#13;
        return ret;&#13;
    }&#13;
&#13;
    /*&#13;
     * @dev Returns the length in runes of the slice. Note that this operation&#13;
     *      takes time proportional to the length of the slice; avoid using it&#13;
     *      in loops, and call `slice.empty()` if you only need to know whether&#13;
     *      the slice is empty or not.&#13;
     * @param self The slice to operate on.&#13;
     * @return The length of the slice in runes.&#13;
     */&#13;
    function len(slice self) internal pure returns (uint l) {&#13;
        // Starting at ptr-31 means the LSB will be the byte we care about&#13;
        uint ptr = self._ptr - 31;&#13;
        uint end = ptr + self._len;&#13;
        for (l = 0; ptr &lt; end; l++) {&#13;
            uint8 b;&#13;
            assembly { b := and(mload(ptr), 0xFF) }&#13;
            if (b &lt; 0x80) {&#13;
                ptr += 1;&#13;
            } else if(b &lt; 0xE0) {&#13;
                ptr += 2;&#13;
            } else if(b &lt; 0xF0) {&#13;
                ptr += 3;&#13;
            } else if(b &lt; 0xF8) {&#13;
                ptr += 4;&#13;
            } else if(b &lt; 0xFC) {&#13;
                ptr += 5;&#13;
            } else {&#13;
                ptr += 6;&#13;
            }&#13;
        }&#13;
    }&#13;
&#13;
    /*&#13;
     * @dev Returns true if the slice is empty (has a length of 0).&#13;
     * @param self The slice to operate on.&#13;
     * @return True if the slice is empty, False otherwise.&#13;
     */&#13;
    function empty(slice self) internal pure returns (bool) {&#13;
        return self._len == 0;&#13;
    }&#13;
&#13;
    /*&#13;
     * @dev Returns a positive number if `other` comes lexicographically after&#13;
     *      `self`, a negative number if it comes before, or zero if the&#13;
     *      contents of the two slices are equal. Comparison is done per-rune,&#13;
     *      on unicode codepoints.&#13;
     * @param self The first slice to compare.&#13;
     * @param other The second slice to compare.&#13;
     * @return The result of the comparison.&#13;
     */&#13;
    function compare(slice self, slice other) internal pure returns (int) {&#13;
        uint shortest = self._len;&#13;
        if (other._len &lt; self._len)&#13;
            shortest = other._len;&#13;
&#13;
        uint selfptr = self._ptr;&#13;
        uint otherptr = other._ptr;&#13;
        for (uint idx = 0; idx &lt; shortest; idx += 32) {&#13;
            uint a;&#13;
            uint b;&#13;
            assembly {&#13;
                a := mload(selfptr)&#13;
                b := mload(otherptr)&#13;
            }&#13;
            if (a != b) {&#13;
                // Mask out irrelevant bytes and check again&#13;
                uint256 mask = uint256(-1); // 0xffff...&#13;
                if(shortest &lt; 32) {&#13;
                  mask = ~(2 ** (8 * (32 - shortest + idx)) - 1);&#13;
                }&#13;
                uint256 diff = (a &amp; mask) - (b &amp; mask);&#13;
                if (diff != 0)&#13;
                    return int(diff);&#13;
            }&#13;
            selfptr += 32;&#13;
            otherptr += 32;&#13;
        }&#13;
        return int(self._len) - int(other._len);&#13;
    }&#13;
&#13;
    /*&#13;
     * @dev Returns true if the two slices contain the same text.&#13;
     * @param self The first slice to compare.&#13;
     * @param self The second slice to compare.&#13;
     * @return True if the slices are equal, false otherwise.&#13;
     */&#13;
    function equals(slice self, slice other) internal pure returns (bool) {&#13;
        return compare(self, other) == 0;&#13;
    }&#13;
&#13;
    /*&#13;
     * @dev Extracts the first rune in the slice into `rune`, advancing the&#13;
     *      slice to point to the next rune and returning `self`.&#13;
     * @param self The slice to operate on.&#13;
     * @param rune The slice that will contain the first rune.&#13;
     * @return `rune`.&#13;
     */&#13;
    function nextRune(slice self, slice rune) internal pure returns (slice) {&#13;
        rune._ptr = self._ptr;&#13;
&#13;
        if (self._len == 0) {&#13;
            rune._len = 0;&#13;
            return rune;&#13;
        }&#13;
&#13;
        uint l;&#13;
        uint b;&#13;
        // Load the first byte of the rune into the LSBs of b&#13;
        assembly { b := and(mload(sub(mload(add(self, 32)), 31)), 0xFF) }&#13;
        if (b &lt; 0x80) {&#13;
            l = 1;&#13;
        } else if(b &lt; 0xE0) {&#13;
            l = 2;&#13;
        } else if(b &lt; 0xF0) {&#13;
            l = 3;&#13;
        } else {&#13;
            l = 4;&#13;
        }&#13;
&#13;
        // Check for truncated codepoints&#13;
        if (l &gt; self._len) {&#13;
            rune._len = self._len;&#13;
            self._ptr += self._len;&#13;
            self._len = 0;&#13;
            return rune;&#13;
        }&#13;
&#13;
        self._ptr += l;&#13;
        self._len -= l;&#13;
        rune._len = l;&#13;
        return rune;&#13;
    }&#13;
&#13;
    /*&#13;
     * @dev Returns the first rune in the slice, advancing the slice to point&#13;
     *      to the next rune.&#13;
     * @param self The slice to operate on.&#13;
     * @return A slice containing only the first rune from `self`.&#13;
     */&#13;
    function nextRune(slice self) internal pure returns (slice ret) {&#13;
        nextRune(self, ret);&#13;
    }&#13;
&#13;
    /*&#13;
     * @dev Returns the number of the first codepoint in the slice.&#13;
     * @param self The slice to operate on.&#13;
     * @return The number of the first codepoint in the slice.&#13;
     */&#13;
    function ord(slice self) internal pure returns (uint ret) {&#13;
        if (self._len == 0) {&#13;
            return 0;&#13;
        }&#13;
&#13;
        uint word;&#13;
        uint length;&#13;
        uint divisor = 2 ** 248;&#13;
&#13;
        // Load the rune into the MSBs of b&#13;
        assembly { word:= mload(mload(add(self, 32))) }&#13;
        uint b = word / divisor;&#13;
        if (b &lt; 0x80) {&#13;
            ret = b;&#13;
            length = 1;&#13;
        } else if(b &lt; 0xE0) {&#13;
            ret = b &amp; 0x1F;&#13;
            length = 2;&#13;
        } else if(b &lt; 0xF0) {&#13;
            ret = b &amp; 0x0F;&#13;
            length = 3;&#13;
        } else {&#13;
            ret = b &amp; 0x07;&#13;
            length = 4;&#13;
        }&#13;
&#13;
        // Check for truncated codepoints&#13;
        if (length &gt; self._len) {&#13;
            return 0;&#13;
        }&#13;
&#13;
        for (uint i = 1; i &lt; length; i++) {&#13;
            divisor = divisor / 256;&#13;
            b = (word / divisor) &amp; 0xFF;&#13;
            if (b &amp; 0xC0 != 0x80) {&#13;
                // Invalid UTF-8 sequence&#13;
                return 0;&#13;
            }&#13;
            ret = (ret * 64) | (b &amp; 0x3F);&#13;
        }&#13;
&#13;
        return ret;&#13;
    }&#13;
&#13;
    /*&#13;
     * @dev Returns the keccak-256 hash of the slice.&#13;
     * @param self The slice to hash.&#13;
     * @return The hash of the slice.&#13;
     */&#13;
    function keccak(slice self) internal pure returns (bytes32 ret) {&#13;
        assembly {&#13;
            ret := keccak256(mload(add(self, 32)), mload(self))&#13;
        }&#13;
    }&#13;
&#13;
    /*&#13;
     * @dev Returns true if `self` starts with `needle`.&#13;
     * @param self The slice to operate on.&#13;
     * @param needle The slice to search for.&#13;
     * @return True if the slice starts with the provided text, false otherwise.&#13;
     */&#13;
    function startsWith(slice self, slice needle) internal pure returns (bool) {&#13;
        if (self._len &lt; needle._len) {&#13;
            return false;&#13;
        }&#13;
&#13;
        if (self._ptr == needle._ptr) {&#13;
            return true;&#13;
        }&#13;
&#13;
        bool equal;&#13;
        assembly {&#13;
            let length := mload(needle)&#13;
            let selfptr := mload(add(self, 0x20))&#13;
            let needleptr := mload(add(needle, 0x20))&#13;
            equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))&#13;
        }&#13;
        return equal;&#13;
    }&#13;
&#13;
    /*&#13;
     * @dev If `self` starts with `needle`, `needle` is removed from the&#13;
     *      beginning of `self`. Otherwise, `self` is unmodified.&#13;
     * @param self The slice to operate on.&#13;
     * @param needle The slice to search for.&#13;
     * @return `self`&#13;
     */&#13;
    function beyond(slice self, slice needle) internal pure returns (slice) {&#13;
        if (self._len &lt; needle._len) {&#13;
            return self;&#13;
        }&#13;
&#13;
        bool equal = true;&#13;
        if (self._ptr != needle._ptr) {&#13;
            assembly {&#13;
                let length := mload(needle)&#13;
                let selfptr := mload(add(self, 0x20))&#13;
                let needleptr := mload(add(needle, 0x20))&#13;
                equal := eq(sha3(selfptr, length), sha3(needleptr, length))&#13;
            }&#13;
        }&#13;
&#13;
        if (equal) {&#13;
            self._len -= needle._len;&#13;
            self._ptr += needle._len;&#13;
        }&#13;
&#13;
        return self;&#13;
    }&#13;
&#13;
    /*&#13;
     * @dev Returns true if the slice ends with `needle`.&#13;
     * @param self The slice to operate on.&#13;
     * @param needle The slice to search for.&#13;
     * @return True if the slice starts with the provided text, false otherwise.&#13;
     */&#13;
    function endsWith(slice self, slice needle) internal pure returns (bool) {&#13;
        if (self._len &lt; needle._len) {&#13;
            return false;&#13;
        }&#13;
&#13;
        uint selfptr = self._ptr + self._len - needle._len;&#13;
&#13;
        if (selfptr == needle._ptr) {&#13;
            return true;&#13;
        }&#13;
&#13;
        bool equal;&#13;
        assembly {&#13;
            let length := mload(needle)&#13;
            let needleptr := mload(add(needle, 0x20))&#13;
            equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))&#13;
        }&#13;
&#13;
        return equal;&#13;
    }&#13;
&#13;
    /*&#13;
     * @dev If `self` ends with `needle`, `needle` is removed from the&#13;
     *      end of `self`. Otherwise, `self` is unmodified.&#13;
     * @param self The slice to operate on.&#13;
     * @param needle The slice to search for.&#13;
     * @return `self`&#13;
     */&#13;
    function until(slice self, slice needle) internal pure returns (slice) {&#13;
        if (self._len &lt; needle._len) {&#13;
            return self;&#13;
        }&#13;
&#13;
        uint selfptr = self._ptr + self._len - needle._len;&#13;
        bool equal = true;&#13;
        if (selfptr != needle._ptr) {&#13;
            assembly {&#13;
                let length := mload(needle)&#13;
                let needleptr := mload(add(needle, 0x20))&#13;
                equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))&#13;
            }&#13;
        }&#13;
&#13;
        if (equal) {&#13;
            self._len -= needle._len;&#13;
        }&#13;
&#13;
        return self;&#13;
    }&#13;
&#13;
    event log_bytemask(bytes32 mask);&#13;
&#13;
    // Returns the memory address of the first byte of the first occurrence of&#13;
    // `needle` in `self`, or the first byte after `self` if not found.&#13;
    function findPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) {&#13;
        uint ptr = selfptr;&#13;
        uint idx;&#13;
&#13;
        if (needlelen &lt;= selflen) {&#13;
            if (needlelen &lt;= 32) {&#13;
                bytes32 mask = bytes32(~(2 ** (8 * (32 - needlelen)) - 1));&#13;
&#13;
                bytes32 needledata;&#13;
                assembly { needledata := and(mload(needleptr), mask) }&#13;
&#13;
                uint end = selfptr + selflen - needlelen;&#13;
                bytes32 ptrdata;&#13;
                assembly { ptrdata := and(mload(ptr), mask) }&#13;
&#13;
                while (ptrdata != needledata) {&#13;
                    if (ptr &gt;= end)&#13;
                        return selfptr + selflen;&#13;
                    ptr++;&#13;
                    assembly { ptrdata := and(mload(ptr), mask) }&#13;
                }&#13;
                return ptr;&#13;
            } else {&#13;
                // For long needles, use hashing&#13;
                bytes32 hash;&#13;
                assembly { hash := sha3(needleptr, needlelen) }&#13;
&#13;
                for (idx = 0; idx &lt;= selflen - needlelen; idx++) {&#13;
                    bytes32 testHash;&#13;
                    assembly { testHash := sha3(ptr, needlelen) }&#13;
                    if (hash == testHash)&#13;
                        return ptr;&#13;
                    ptr += 1;&#13;
                }&#13;
            }&#13;
        }&#13;
        return selfptr + selflen;&#13;
    }&#13;
&#13;
    // Returns the memory address of the first byte after the last occurrence of&#13;
    // `needle` in `self`, or the address of `self` if not found.&#13;
    function rfindPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) {&#13;
        uint ptr;&#13;
&#13;
        if (needlelen &lt;= selflen) {&#13;
            if (needlelen &lt;= 32) {&#13;
                bytes32 mask = bytes32(~(2 ** (8 * (32 - needlelen)) - 1));&#13;
&#13;
                bytes32 needledata;&#13;
                assembly { needledata := and(mload(needleptr), mask) }&#13;
&#13;
                ptr = selfptr + selflen - needlelen;&#13;
                bytes32 ptrdata;&#13;
                assembly { ptrdata := and(mload(ptr), mask) }&#13;
&#13;
                while (ptrdata != needledata) {&#13;
                    if (ptr &lt;= selfptr)&#13;
                        return selfptr;&#13;
                    ptr--;&#13;
                    assembly { ptrdata := and(mload(ptr), mask) }&#13;
                }&#13;
                return ptr + needlelen;&#13;
            } else {&#13;
                // For long needles, use hashing&#13;
                bytes32 hash;&#13;
                assembly { hash := sha3(needleptr, needlelen) }&#13;
                ptr = selfptr + (selflen - needlelen);&#13;
                while (ptr &gt;= selfptr) {&#13;
                    bytes32 testHash;&#13;
                    assembly { testHash := sha3(ptr, needlelen) }&#13;
                    if (hash == testHash)&#13;
                        return ptr + needlelen;&#13;
                    ptr -= 1;&#13;
                }&#13;
            }&#13;
        }&#13;
        return selfptr;&#13;
    }&#13;
&#13;
    /*&#13;
     * @dev Modifies `self` to contain everything from the first occurrence of&#13;
     *      `needle` to the end of the slice. `self` is set to the empty slice&#13;
     *      if `needle` is not found.&#13;
     * @param self The slice to search and modify.&#13;
     * @param needle The text to search for.&#13;
     * @return `self`.&#13;
     */&#13;
    function find(slice self, slice needle) internal pure returns (slice) {&#13;
        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr);&#13;
        self._len -= ptr - self._ptr;&#13;
        self._ptr = ptr;&#13;
        return self;&#13;
    }&#13;
&#13;
    /*&#13;
     * @dev Modifies `self` to contain the part of the string from the start of&#13;
     *      `self` to the end of the first occurrence of `needle`. If `needle`&#13;
     *      is not found, `self` is set to the empty slice.&#13;
     * @param self The slice to search and modify.&#13;
     * @param needle The text to search for.&#13;
     * @return `self`.&#13;
     */&#13;
    function rfind(slice self, slice needle) internal pure returns (slice) {&#13;
        uint ptr = rfindPtr(self._len, self._ptr, needle._len, needle._ptr);&#13;
        self._len = ptr - self._ptr;&#13;
        return self;&#13;
    }&#13;
&#13;
    /*&#13;
     * @dev Splits the slice, setting `self` to everything after the first&#13;
     *      occurrence of `needle`, and `token` to everything before it. If&#13;
     *      `needle` does not occur in `self`, `self` is set to the empty slice,&#13;
     *      and `token` is set to the entirety of `self`.&#13;
     * @param self The slice to split.&#13;
     * @param needle The text to search for in `self`.&#13;
     * @param token An output parameter to which the first token is written.&#13;
     * @return `token`.&#13;
     */&#13;
    function split(slice self, slice needle, slice token) internal pure returns (slice) {&#13;
        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr);&#13;
        token._ptr = self._ptr;&#13;
        token._len = ptr - self._ptr;&#13;
        if (ptr == self._ptr + self._len) {&#13;
            // Not found&#13;
            self._len = 0;&#13;
        } else {&#13;
            self._len -= token._len + needle._len;&#13;
            self._ptr = ptr + needle._len;&#13;
        }&#13;
        return token;&#13;
    }&#13;
&#13;
    /*&#13;
     * @dev Splits the slice, setting `self` to everything after the first&#13;
     *      occurrence of `needle`, and returning everything before it. If&#13;
     *      `needle` does not occur in `self`, `self` is set to the empty slice,&#13;
     *      and the entirety of `self` is returned.&#13;
     * @param self The slice to split.&#13;
     * @param needle The text to search for in `self`.&#13;
     * @return The part of `self` up to the first occurrence of `delim`.&#13;
     */&#13;
    function split(slice self, slice needle) internal pure returns (slice token) {&#13;
        split(self, needle, token);&#13;
    }&#13;
&#13;
    /*&#13;
     * @dev Splits the slice, setting `self` to everything before the last&#13;
     *      occurrence of `needle`, and `token` to everything after it. If&#13;
     *      `needle` does not occur in `self`, `self` is set to the empty slice,&#13;
     *      and `token` is set to the entirety of `self`.&#13;
     * @param self The slice to split.&#13;
     * @param needle The text to search for in `self`.&#13;
     * @param token An output parameter to which the first token is written.&#13;
     * @return `token`.&#13;
     */&#13;
    function rsplit(slice self, slice needle, slice token) internal pure returns (slice) {&#13;
        uint ptr = rfindPtr(self._len, self._ptr, needle._len, needle._ptr);&#13;
        token._ptr = ptr;&#13;
        token._len = self._len - (ptr - self._ptr);&#13;
        if (ptr == self._ptr) {&#13;
            // Not found&#13;
            self._len = 0;&#13;
        } else {&#13;
            self._len -= token._len + needle._len;&#13;
        }&#13;
        return token;&#13;
    }&#13;
&#13;
    /*&#13;
     * @dev Splits the slice, setting `self` to everything before the last&#13;
     *      occurrence of `needle`, and returning everything after it. If&#13;
     *      `needle` does not occur in `self`, `self` is set to the empty slice,&#13;
     *      and the entirety of `self` is returned.&#13;
     * @param self The slice to split.&#13;
     * @param needle The text to search for in `self`.&#13;
     * @return The part of `self` after the last occurrence of `delim`.&#13;
     */&#13;
    function rsplit(slice self, slice needle) internal pure returns (slice token) {&#13;
        rsplit(self, needle, token);&#13;
    }&#13;
&#13;
    /*&#13;
     * @dev Counts the number of nonoverlapping occurrences of `needle` in `self`.&#13;
     * @param self The slice to search.&#13;
     * @param needle The text to search for in `self`.&#13;
     * @return The number of occurrences of `needle` found in `self`.&#13;
     */&#13;
    function count(slice self, slice needle) internal pure returns (uint cnt) {&#13;
        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr) + needle._len;&#13;
        while (ptr &lt;= self._ptr + self._len) {&#13;
            cnt++;&#13;
            ptr = findPtr(self._len - (ptr - self._ptr), ptr, needle._len, needle._ptr) + needle._len;&#13;
        }&#13;
    }&#13;
&#13;
    /*&#13;
     * @dev Returns True if `self` contains `needle`.&#13;
     * @param self The slice to search.&#13;
     * @param needle The text to search for in `self`.&#13;
     * @return True if `needle` is found in `self`, false otherwise.&#13;
     */&#13;
    function contains(slice self, slice needle) internal pure returns (bool) {&#13;
        return rfindPtr(self._len, self._ptr, needle._len, needle._ptr) != self._ptr;&#13;
    }&#13;
&#13;
    /*&#13;
     * @dev Returns a newly allocated string containing the concatenation of&#13;
     *      `self` and `other`.&#13;
     * @param self The first slice to concatenate.&#13;
     * @param other The second slice to concatenate.&#13;
     * @return The concatenation of the two strings.&#13;
     */&#13;
    function concat(slice self, slice other) internal pure returns (string) {&#13;
        string memory ret = new string(self._len + other._len);&#13;
        uint retptr;&#13;
        assembly { retptr := add(ret, 32) }&#13;
        memcpy(retptr, self._ptr, self._len);&#13;
        memcpy(retptr + self._len, other._ptr, other._len);&#13;
        return ret;&#13;
    }&#13;
&#13;
    /*&#13;
     * @dev Joins an array of slices, using `self` as a delimiter, returning a&#13;
     *      newly allocated string.&#13;
     * @param self The delimiter to use.&#13;
     * @param parts A list of slices to join.&#13;
     * @return A newly allocated string containing all the slices in `parts`,&#13;
     *         joined with `self`.&#13;
     */&#13;
    function join(slice self, slice[] parts) internal pure returns (string) {&#13;
        if (parts.length == 0)&#13;
            return "";&#13;
&#13;
        uint length = self._len * (parts.length - 1);&#13;
        for(uint i = 0; i &lt; parts.length; i++)&#13;
            length += parts[i]._len;&#13;
&#13;
        string memory ret = new string(length);&#13;
        uint retptr;&#13;
        assembly { retptr := add(ret, 32) }&#13;
&#13;
        for(i = 0; i &lt; parts.length; i++) {&#13;
            memcpy(retptr, parts[i]._ptr, parts[i]._len);&#13;
            retptr += parts[i]._len;&#13;
            if (i &lt; parts.length - 1) {&#13;
                memcpy(retptr, self._ptr, self._len);&#13;
                retptr += self._len;&#13;
            }&#13;
        }&#13;
&#13;
        return ret;&#13;
    }&#13;
}&#13;
&#13;
// File: contracts/usingOraclize.sol&#13;
&#13;
// &lt;ORACLIZE_API&gt;&#13;
/*&#13;
Copyright (c) 2015-2016 Oraclize SRL&#13;
Copyright (c) 2016 Oraclize LTD&#13;
&#13;
&#13;
&#13;
Permission is hereby granted, free of charge, to any person obtaining a copy&#13;
of this software and associated documentation files (the "Software"), to deal&#13;
in the Software without restriction, including without limitation the rights&#13;
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell&#13;
copies of the Software, and to permit persons to whom the Software is&#13;
furnished to do so, subject to the following conditions:&#13;
&#13;
&#13;
&#13;
The above copyright notice and this permission notice shall be included in&#13;
all copies or substantial portions of the Software.&#13;
&#13;
&#13;
&#13;
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR&#13;
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,&#13;
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE&#13;
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER&#13;
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,&#13;
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN&#13;
THE SOFTWARE.&#13;
*/&#13;
&#13;
// This api is currently targeted at 0.4.18, please import oraclizeAPI_pre0.4.sol or oraclizeAPI_0.4 where necessary&#13;
pragma solidity ^0.4.18;&#13;
&#13;
contract OraclizeI {&#13;
    address public cbAddress;&#13;
    function query(uint _timestamp, string _datasource, string _arg) external payable returns (bytes32 _id);&#13;
    function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) external payable returns (bytes32 _id);&#13;
    function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) public payable returns (bytes32 _id);&#13;
    function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) external payable returns (bytes32 _id);&#13;
    function queryN(uint _timestamp, string _datasource, bytes _argN) public payable returns (bytes32 _id);&#13;
    function queryN_withGasLimit(uint _timestamp, string _datasource, bytes _argN, uint _gaslimit) external payable returns (bytes32 _id);&#13;
    function getPrice(string _datasource) public returns (uint _dsprice);&#13;
    function getPrice(string _datasource, uint gaslimit) public returns (uint _dsprice);&#13;
    function setProofType(byte _proofType) external;&#13;
    function setCustomGasPrice(uint _gasPrice) external;&#13;
    function randomDS_getSessionPubKeyHash() external constant returns(bytes32);&#13;
}&#13;
contract OraclizeAddrResolverI {&#13;
    function getAddress() public returns (address _addr);&#13;
}&#13;
contract usingOraclize {&#13;
    uint constant day = 60*60*24;&#13;
    uint constant week = 60*60*24*7;&#13;
    uint constant month = 60*60*24*30;&#13;
    byte constant proofType_NONE = 0x00;&#13;
    byte constant proofType_TLSNotary = 0x10;&#13;
    byte constant proofType_Android = 0x20;&#13;
    byte constant proofType_Ledger = 0x30;&#13;
    byte constant proofType_Native = 0xF0;&#13;
    byte constant proofStorage_IPFS = 0x01;&#13;
    uint8 constant networkID_auto = 0;&#13;
    uint8 constant networkID_mainnet = 1;&#13;
    uint8 constant networkID_testnet = 2;&#13;
    uint8 constant networkID_morden = 2;&#13;
    uint8 constant networkID_consensys = 161;&#13;
&#13;
    OraclizeAddrResolverI OAR;&#13;
&#13;
    OraclizeI oraclize;&#13;
    modifier oraclizeAPI {&#13;
        if((address(OAR)==0)||(getCodeSize(address(OAR))==0))&#13;
            oraclize_setNetwork(networkID_auto);&#13;
&#13;
        if(address(oraclize) != OAR.getAddress())&#13;
            oraclize = OraclizeI(OAR.getAddress());&#13;
&#13;
        _;&#13;
    }&#13;
    modifier coupon(string code){&#13;
        oraclize = OraclizeI(OAR.getAddress());&#13;
        _;&#13;
    }&#13;
&#13;
    function oraclize_setNetwork(uint8 networkID) internal returns(bool){&#13;
      return oraclize_setNetwork();&#13;
      networkID; // silence the warning and remain backwards compatible&#13;
    }&#13;
    function oraclize_setNetwork() internal returns(bool){&#13;
        if (getCodeSize(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed)&gt;0){ //mainnet&#13;
            OAR = OraclizeAddrResolverI(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed);&#13;
            oraclize_setNetworkName("eth_mainnet");&#13;
            return true;&#13;
        }&#13;
        if (getCodeSize(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1)&gt;0){ //ropsten testnet&#13;
            OAR = OraclizeAddrResolverI(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1);&#13;
            oraclize_setNetworkName("eth_ropsten3");&#13;
            return true;&#13;
        }&#13;
        if (getCodeSize(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e)&gt;0){ //kovan testnet&#13;
            OAR = OraclizeAddrResolverI(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e);&#13;
            oraclize_setNetworkName("eth_kovan");&#13;
            return true;&#13;
        }&#13;
        if (getCodeSize(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48)&gt;0){ //rinkeby testnet&#13;
            OAR = OraclizeAddrResolverI(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48);&#13;
            oraclize_setNetworkName("eth_rinkeby");&#13;
            return true;&#13;
        }&#13;
        if (getCodeSize(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475)&gt;0){ //ethereum-bridge&#13;
            OAR = OraclizeAddrResolverI(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475);&#13;
            return true;&#13;
        }&#13;
        if (getCodeSize(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF)&gt;0){ //ether.camp ide&#13;
            OAR = OraclizeAddrResolverI(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF);&#13;
            return true;&#13;
        }&#13;
        if (getCodeSize(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA)&gt;0){ //browser-solidity&#13;
            OAR = OraclizeAddrResolverI(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA);&#13;
            return true;&#13;
        }&#13;
        return false;&#13;
    }&#13;
&#13;
    function __callback(bytes32 myid, string result) public {&#13;
        __callback(myid, result, new bytes(0));&#13;
    }&#13;
    function __callback(bytes32 myid, string result, bytes proof) public {&#13;
      return;&#13;
      myid; result; proof; // Silence compiler warnings&#13;
    }&#13;
&#13;
    function oraclize_getPrice(string datasource) oraclizeAPI internal returns (uint){&#13;
        return oraclize.getPrice(datasource);&#13;
    }&#13;
&#13;
    function oraclize_getPrice(string datasource, uint gaslimit) oraclizeAPI internal returns (uint){&#13;
        return oraclize.getPrice(datasource, gaslimit);&#13;
    }&#13;
&#13;
    function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){&#13;
        uint price = oraclize.getPrice(datasource);&#13;
        if (price &gt; 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price&#13;
        return oraclize.query.value(price)(0, datasource, arg);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){&#13;
        uint price = oraclize.getPrice(datasource);&#13;
        if (price &gt; 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price&#13;
        return oraclize.query.value(price)(timestamp, datasource, arg);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){&#13;
        uint price = oraclize.getPrice(datasource, gaslimit);&#13;
        if (price &gt; 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price&#13;
        return oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){&#13;
        uint price = oraclize.getPrice(datasource, gaslimit);&#13;
        if (price &gt; 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price&#13;
        return oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){&#13;
        uint price = oraclize.getPrice(datasource);&#13;
        if (price &gt; 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price&#13;
        return oraclize.query2.value(price)(0, datasource, arg1, arg2);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){&#13;
        uint price = oraclize.getPrice(datasource);&#13;
        if (price &gt; 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price&#13;
        return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){&#13;
        uint price = oraclize.getPrice(datasource, gaslimit);&#13;
        if (price &gt; 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price&#13;
        return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){&#13;
        uint price = oraclize.getPrice(datasource, gaslimit);&#13;
        if (price &gt; 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price&#13;
        return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, string[] argN) oraclizeAPI internal returns (bytes32 id){&#13;
        uint price = oraclize.getPrice(datasource);&#13;
        if (price &gt; 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price&#13;
        bytes memory args = stra2cbor(argN);&#13;
        return oraclize.queryN.value(price)(0, datasource, args);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, string[] argN) oraclizeAPI internal returns (bytes32 id){&#13;
        uint price = oraclize.getPrice(datasource);&#13;
        if (price &gt; 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price&#13;
        bytes memory args = stra2cbor(argN);&#13;
        return oraclize.queryN.value(price)(timestamp, datasource, args);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, string[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){&#13;
        uint price = oraclize.getPrice(datasource, gaslimit);&#13;
        if (price &gt; 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price&#13;
        bytes memory args = stra2cbor(argN);&#13;
        return oraclize.queryN_withGasLimit.value(price)(timestamp, datasource, args, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, string[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){&#13;
        uint price = oraclize.getPrice(datasource, gaslimit);&#13;
        if (price &gt; 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price&#13;
        bytes memory args = stra2cbor(argN);&#13;
        return oraclize.queryN_withGasLimit.value(price)(0, datasource, args, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, string[1] args) oraclizeAPI internal returns (bytes32 id) {&#13;
        string[] memory dynargs = new string[](1);&#13;
        dynargs[0] = args[0];&#13;
        return oraclize_query(datasource, dynargs);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, string[1] args) oraclizeAPI internal returns (bytes32 id) {&#13;
        string[] memory dynargs = new string[](1);&#13;
        dynargs[0] = args[0];&#13;
        return oraclize_query(timestamp, datasource, dynargs);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, string[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {&#13;
        string[] memory dynargs = new string[](1);&#13;
        dynargs[0] = args[0];&#13;
        return oraclize_query(timestamp, datasource, dynargs, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, string[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {&#13;
        string[] memory dynargs = new string[](1);&#13;
        dynargs[0] = args[0];&#13;
        return oraclize_query(datasource, dynargs, gaslimit);&#13;
    }&#13;
&#13;
    function oraclize_query(string datasource, string[2] args) oraclizeAPI internal returns (bytes32 id) {&#13;
        string[] memory dynargs = new string[](2);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        return oraclize_query(datasource, dynargs);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, string[2] args) oraclizeAPI internal returns (bytes32 id) {&#13;
        string[] memory dynargs = new string[](2);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        return oraclize_query(timestamp, datasource, dynargs);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, string[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {&#13;
        string[] memory dynargs = new string[](2);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        return oraclize_query(timestamp, datasource, dynargs, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, string[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {&#13;
        string[] memory dynargs = new string[](2);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        return oraclize_query(datasource, dynargs, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, string[3] args) oraclizeAPI internal returns (bytes32 id) {&#13;
        string[] memory dynargs = new string[](3);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        return oraclize_query(datasource, dynargs);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, string[3] args) oraclizeAPI internal returns (bytes32 id) {&#13;
        string[] memory dynargs = new string[](3);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        return oraclize_query(timestamp, datasource, dynargs);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, string[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {&#13;
        string[] memory dynargs = new string[](3);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        return oraclize_query(timestamp, datasource, dynargs, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, string[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {&#13;
        string[] memory dynargs = new string[](3);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        return oraclize_query(datasource, dynargs, gaslimit);&#13;
    }&#13;
&#13;
    function oraclize_query(string datasource, string[4] args) oraclizeAPI internal returns (bytes32 id) {&#13;
        string[] memory dynargs = new string[](4);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        dynargs[3] = args[3];&#13;
        return oraclize_query(datasource, dynargs);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, string[4] args) oraclizeAPI internal returns (bytes32 id) {&#13;
        string[] memory dynargs = new string[](4);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        dynargs[3] = args[3];&#13;
        return oraclize_query(timestamp, datasource, dynargs);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, string[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {&#13;
        string[] memory dynargs = new string[](4);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        dynargs[3] = args[3];&#13;
        return oraclize_query(timestamp, datasource, dynargs, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, string[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {&#13;
        string[] memory dynargs = new string[](4);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        dynargs[3] = args[3];&#13;
        return oraclize_query(datasource, dynargs, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, string[5] args) oraclizeAPI internal returns (bytes32 id) {&#13;
        string[] memory dynargs = new string[](5);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        dynargs[3] = args[3];&#13;
        dynargs[4] = args[4];&#13;
        return oraclize_query(datasource, dynargs);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, string[5] args) oraclizeAPI internal returns (bytes32 id) {&#13;
        string[] memory dynargs = new string[](5);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        dynargs[3] = args[3];&#13;
        dynargs[4] = args[4];&#13;
        return oraclize_query(timestamp, datasource, dynargs);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, string[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {&#13;
        string[] memory dynargs = new string[](5);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        dynargs[3] = args[3];&#13;
        dynargs[4] = args[4];&#13;
        return oraclize_query(timestamp, datasource, dynargs, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, string[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {&#13;
        string[] memory dynargs = new string[](5);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        dynargs[3] = args[3];&#13;
        dynargs[4] = args[4];&#13;
        return oraclize_query(datasource, dynargs, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, bytes[] argN) oraclizeAPI internal returns (bytes32 id){&#13;
        uint price = oraclize.getPrice(datasource);&#13;
        if (price &gt; 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price&#13;
        bytes memory args = ba2cbor(argN);&#13;
        return oraclize.queryN.value(price)(0, datasource, args);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, bytes[] argN) oraclizeAPI internal returns (bytes32 id){&#13;
        uint price = oraclize.getPrice(datasource);&#13;
        if (price &gt; 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price&#13;
        bytes memory args = ba2cbor(argN);&#13;
        return oraclize.queryN.value(price)(timestamp, datasource, args);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, bytes[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){&#13;
        uint price = oraclize.getPrice(datasource, gaslimit);&#13;
        if (price &gt; 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price&#13;
        bytes memory args = ba2cbor(argN);&#13;
        return oraclize.queryN_withGasLimit.value(price)(timestamp, datasource, args, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, bytes[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){&#13;
        uint price = oraclize.getPrice(datasource, gaslimit);&#13;
        if (price &gt; 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price&#13;
        bytes memory args = ba2cbor(argN);&#13;
        return oraclize.queryN_withGasLimit.value(price)(0, datasource, args, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, bytes[1] args) oraclizeAPI internal returns (bytes32 id) {&#13;
        bytes[] memory dynargs = new bytes[](1);&#13;
        dynargs[0] = args[0];&#13;
        return oraclize_query(datasource, dynargs);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, bytes[1] args) oraclizeAPI internal returns (bytes32 id) {&#13;
        bytes[] memory dynargs = new bytes[](1);&#13;
        dynargs[0] = args[0];&#13;
        return oraclize_query(timestamp, datasource, dynargs);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, bytes[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {&#13;
        bytes[] memory dynargs = new bytes[](1);&#13;
        dynargs[0] = args[0];&#13;
        return oraclize_query(timestamp, datasource, dynargs, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, bytes[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {&#13;
        bytes[] memory dynargs = new bytes[](1);&#13;
        dynargs[0] = args[0];&#13;
        return oraclize_query(datasource, dynargs, gaslimit);&#13;
    }&#13;
&#13;
    function oraclize_query(string datasource, bytes[2] args) oraclizeAPI internal returns (bytes32 id) {&#13;
        bytes[] memory dynargs = new bytes[](2);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        return oraclize_query(datasource, dynargs);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, bytes[2] args) oraclizeAPI internal returns (bytes32 id) {&#13;
        bytes[] memory dynargs = new bytes[](2);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        return oraclize_query(timestamp, datasource, dynargs);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, bytes[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {&#13;
        bytes[] memory dynargs = new bytes[](2);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        return oraclize_query(timestamp, datasource, dynargs, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, bytes[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {&#13;
        bytes[] memory dynargs = new bytes[](2);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        return oraclize_query(datasource, dynargs, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, bytes[3] args) oraclizeAPI internal returns (bytes32 id) {&#13;
        bytes[] memory dynargs = new bytes[](3);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        return oraclize_query(datasource, dynargs);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, bytes[3] args) oraclizeAPI internal returns (bytes32 id) {&#13;
        bytes[] memory dynargs = new bytes[](3);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        return oraclize_query(timestamp, datasource, dynargs);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, bytes[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {&#13;
        bytes[] memory dynargs = new bytes[](3);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        return oraclize_query(timestamp, datasource, dynargs, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, bytes[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {&#13;
        bytes[] memory dynargs = new bytes[](3);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        return oraclize_query(datasource, dynargs, gaslimit);&#13;
    }&#13;
&#13;
    function oraclize_query(string datasource, bytes[4] args) oraclizeAPI internal returns (bytes32 id) {&#13;
        bytes[] memory dynargs = new bytes[](4);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        dynargs[3] = args[3];&#13;
        return oraclize_query(datasource, dynargs);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, bytes[4] args) oraclizeAPI internal returns (bytes32 id) {&#13;
        bytes[] memory dynargs = new bytes[](4);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        dynargs[3] = args[3];&#13;
        return oraclize_query(timestamp, datasource, dynargs);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, bytes[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {&#13;
        bytes[] memory dynargs = new bytes[](4);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        dynargs[3] = args[3];&#13;
        return oraclize_query(timestamp, datasource, dynargs, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, bytes[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {&#13;
        bytes[] memory dynargs = new bytes[](4);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        dynargs[3] = args[3];&#13;
        return oraclize_query(datasource, dynargs, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, bytes[5] args) oraclizeAPI internal returns (bytes32 id) {&#13;
        bytes[] memory dynargs = new bytes[](5);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        dynargs[3] = args[3];&#13;
        dynargs[4] = args[4];&#13;
        return oraclize_query(datasource, dynargs);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, bytes[5] args) oraclizeAPI internal returns (bytes32 id) {&#13;
        bytes[] memory dynargs = new bytes[](5);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        dynargs[3] = args[3];&#13;
        dynargs[4] = args[4];&#13;
        return oraclize_query(timestamp, datasource, dynargs);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, bytes[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {&#13;
        bytes[] memory dynargs = new bytes[](5);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        dynargs[3] = args[3];&#13;
        dynargs[4] = args[4];&#13;
        return oraclize_query(timestamp, datasource, dynargs, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, bytes[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {&#13;
        bytes[] memory dynargs = new bytes[](5);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        dynargs[3] = args[3];&#13;
        dynargs[4] = args[4];&#13;
        return oraclize_query(datasource, dynargs, gaslimit);&#13;
    }&#13;
&#13;
    function oraclize_cbAddress() oraclizeAPI internal returns (address){&#13;
        return oraclize.cbAddress();&#13;
    }&#13;
    function oraclize_setProof(byte proofP) oraclizeAPI internal {&#13;
        return oraclize.setProofType(proofP);&#13;
    }&#13;
    function oraclize_setCustomGasPrice(uint gasPrice) oraclizeAPI internal {&#13;
        return oraclize.setCustomGasPrice(gasPrice);&#13;
    }&#13;
&#13;
    function oraclize_randomDS_getSessionPubKeyHash() oraclizeAPI internal returns (bytes32){&#13;
        return oraclize.randomDS_getSessionPubKeyHash();&#13;
    }&#13;
&#13;
    function getCodeSize(address _addr) constant internal returns(uint _size) {&#13;
        assembly {&#13;
            _size := extcodesize(_addr)&#13;
        }&#13;
    }&#13;
&#13;
    function parseAddr(string _a) internal pure returns (address){&#13;
        bytes memory tmp = bytes(_a);&#13;
        uint160 iaddr = 0;&#13;
        uint160 b1;&#13;
        uint160 b2;&#13;
        for (uint i=2; i&lt;2+2*20; i+=2){&#13;
            iaddr *= 256;&#13;
            b1 = uint160(tmp[i]);&#13;
            b2 = uint160(tmp[i+1]);&#13;
            if ((b1 &gt;= 97)&amp;&amp;(b1 &lt;= 102)) b1 -= 87;&#13;
            else if ((b1 &gt;= 65)&amp;&amp;(b1 &lt;= 70)) b1 -= 55;&#13;
            else if ((b1 &gt;= 48)&amp;&amp;(b1 &lt;= 57)) b1 -= 48;&#13;
            if ((b2 &gt;= 97)&amp;&amp;(b2 &lt;= 102)) b2 -= 87;&#13;
            else if ((b2 &gt;= 65)&amp;&amp;(b2 &lt;= 70)) b2 -= 55;&#13;
            else if ((b2 &gt;= 48)&amp;&amp;(b2 &lt;= 57)) b2 -= 48;&#13;
            iaddr += (b1*16+b2);&#13;
        }&#13;
        return address(iaddr);&#13;
    }&#13;
&#13;
    function strCompare(string _a, string _b) internal pure returns (int) {&#13;
        bytes memory a = bytes(_a);&#13;
        bytes memory b = bytes(_b);&#13;
        uint minLength = a.length;&#13;
        if (b.length &lt; minLength) minLength = b.length;&#13;
        for (uint i = 0; i &lt; minLength; i ++)&#13;
            if (a[i] &lt; b[i])&#13;
                return -1;&#13;
            else if (a[i] &gt; b[i])&#13;
                return 1;&#13;
        if (a.length &lt; b.length)&#13;
            return -1;&#13;
        else if (a.length &gt; b.length)&#13;
            return 1;&#13;
        else&#13;
            return 0;&#13;
    }&#13;
&#13;
    function indexOf(string _haystack, string _needle) internal pure returns (int) {&#13;
        bytes memory h = bytes(_haystack);&#13;
        bytes memory n = bytes(_needle);&#13;
        if(h.length &lt; 1 || n.length &lt; 1 || (n.length &gt; h.length))&#13;
            return -1;&#13;
        else if(h.length &gt; (2**128 -1))&#13;
            return -1;&#13;
        else&#13;
        {&#13;
            uint subindex = 0;&#13;
            for (uint i = 0; i &lt; h.length; i ++)&#13;
            {&#13;
                if (h[i] == n[0])&#13;
                {&#13;
                    subindex = 1;&#13;
                    while(subindex &lt; n.length &amp;&amp; (i + subindex) &lt; h.length &amp;&amp; h[i + subindex] == n[subindex])&#13;
                    {&#13;
                        subindex++;&#13;
                    }&#13;
                    if(subindex == n.length)&#13;
                        return int(i);&#13;
                }&#13;
            }&#13;
            return -1;&#13;
        }&#13;
    }&#13;
&#13;
    function strConcat(string _a, string _b, string _c, string _d, string _e) internal pure returns (string) {&#13;
        bytes memory _ba = bytes(_a);&#13;
        bytes memory _bb = bytes(_b);&#13;
        bytes memory _bc = bytes(_c);&#13;
        bytes memory _bd = bytes(_d);&#13;
        bytes memory _be = bytes(_e);&#13;
        string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);&#13;
        bytes memory babcde = bytes(abcde);&#13;
        uint k = 0;&#13;
        for (uint i = 0; i &lt; _ba.length; i++) babcde[k++] = _ba[i];&#13;
        for (i = 0; i &lt; _bb.length; i++) babcde[k++] = _bb[i];&#13;
        for (i = 0; i &lt; _bc.length; i++) babcde[k++] = _bc[i];&#13;
        for (i = 0; i &lt; _bd.length; i++) babcde[k++] = _bd[i];&#13;
        for (i = 0; i &lt; _be.length; i++) babcde[k++] = _be[i];&#13;
        return string(babcde);&#13;
    }&#13;
&#13;
    function strConcat(string _a, string _b, string _c, string _d) internal pure returns (string) {&#13;
        return strConcat(_a, _b, _c, _d, "");&#13;
    }&#13;
&#13;
    function strConcat(string _a, string _b, string _c) internal pure returns (string) {&#13;
        return strConcat(_a, _b, _c, "", "");&#13;
    }&#13;
&#13;
    function strConcat(string _a, string _b) internal pure returns (string) {&#13;
        return strConcat(_a, _b, "", "", "");&#13;
    }&#13;
&#13;
    // parseInt&#13;
    function parseInt(string _a) internal pure returns (uint) {&#13;
        return parseInt(_a, 0);&#13;
    }&#13;
&#13;
    // parseInt(parseFloat*10^_b)&#13;
    function parseInt(string _a, uint _b) internal pure returns (uint) {&#13;
        bytes memory bresult = bytes(_a);&#13;
        uint mint = 0;&#13;
        bool decimals = false;&#13;
        for (uint i=0; i&lt;bresult.length; i++){&#13;
            if ((bresult[i] &gt;= 48)&amp;&amp;(bresult[i] &lt;= 57)){&#13;
                if (decimals){&#13;
                   if (_b == 0) break;&#13;
                    else _b--;&#13;
                }&#13;
                mint *= 10;&#13;
                mint += uint(bresult[i]) - 48;&#13;
            } else if (bresult[i] == 46) decimals = true;&#13;
        }&#13;
        if (_b &gt; 0) mint *= 10**_b;&#13;
        return mint;&#13;
    }&#13;
&#13;
    function uint2str(uint i) internal pure returns (string){&#13;
        if (i == 0) return "0";&#13;
        uint j = i;&#13;
        uint len;&#13;
        while (j != 0){&#13;
            len++;&#13;
            j /= 10;&#13;
        }&#13;
        bytes memory bstr = new bytes(len);&#13;
        uint k = len - 1;&#13;
        while (i != 0){&#13;
            bstr[k--] = byte(48 + i % 10);&#13;
            i /= 10;&#13;
        }&#13;
        return string(bstr);&#13;
    }&#13;
&#13;
    function stra2cbor(string[] arr) internal pure returns (bytes) {&#13;
            uint arrlen = arr.length;&#13;
&#13;
            // get correct cbor output length&#13;
            uint outputlen = 0;&#13;
            bytes[] memory elemArray = new bytes[](arrlen);&#13;
            for (uint i = 0; i &lt; arrlen; i++) {&#13;
                elemArray[i] = (bytes(arr[i]));&#13;
                outputlen += elemArray[i].length + (elemArray[i].length - 1)/23 + 3; //+3 accounts for paired identifier types&#13;
            }&#13;
            uint ctr = 0;&#13;
            uint cborlen = arrlen + 0x80;&#13;
            outputlen += byte(cborlen).length;&#13;
            bytes memory res = new bytes(outputlen);&#13;
&#13;
            while (byte(cborlen).length &gt; ctr) {&#13;
                res[ctr] = byte(cborlen)[ctr];&#13;
                ctr++;&#13;
            }&#13;
            for (i = 0; i &lt; arrlen; i++) {&#13;
                res[ctr] = 0x5F;&#13;
                ctr++;&#13;
                for (uint x = 0; x &lt; elemArray[i].length; x++) {&#13;
                    // if there's a bug with larger strings, this may be the culprit&#13;
                    if (x % 23 == 0) {&#13;
                        uint elemcborlen = elemArray[i].length - x &gt;= 24 ? 23 : elemArray[i].length - x;&#13;
                        elemcborlen += 0x40;&#13;
                        uint lctr = ctr;&#13;
                        while (byte(elemcborlen).length &gt; ctr - lctr) {&#13;
                            res[ctr] = byte(elemcborlen)[ctr - lctr];&#13;
                            ctr++;&#13;
                        }&#13;
                    }&#13;
                    res[ctr] = elemArray[i][x];&#13;
                    ctr++;&#13;
                }&#13;
                res[ctr] = 0xFF;&#13;
                ctr++;&#13;
            }&#13;
            return res;&#13;
        }&#13;
&#13;
    function ba2cbor(bytes[] arr) internal pure returns (bytes) {&#13;
            uint arrlen = arr.length;&#13;
&#13;
            // get correct cbor output length&#13;
            uint outputlen = 0;&#13;
            bytes[] memory elemArray = new bytes[](arrlen);&#13;
            for (uint i = 0; i &lt; arrlen; i++) {&#13;
                elemArray[i] = (bytes(arr[i]));&#13;
                outputlen += elemArray[i].length + (elemArray[i].length - 1)/23 + 3; //+3 accounts for paired identifier types&#13;
            }&#13;
            uint ctr = 0;&#13;
            uint cborlen = arrlen + 0x80;&#13;
            outputlen += byte(cborlen).length;&#13;
            bytes memory res = new bytes(outputlen);&#13;
&#13;
            while (byte(cborlen).length &gt; ctr) {&#13;
                res[ctr] = byte(cborlen)[ctr];&#13;
                ctr++;&#13;
            }&#13;
            for (i = 0; i &lt; arrlen; i++) {&#13;
                res[ctr] = 0x5F;&#13;
                ctr++;&#13;
                for (uint x = 0; x &lt; elemArray[i].length; x++) {&#13;
                    // if there's a bug with larger strings, this may be the culprit&#13;
                    if (x % 23 == 0) {&#13;
                        uint elemcborlen = elemArray[i].length - x &gt;= 24 ? 23 : elemArray[i].length - x;&#13;
                        elemcborlen += 0x40;&#13;
                        uint lctr = ctr;&#13;
                        while (byte(elemcborlen).length &gt; ctr - lctr) {&#13;
                            res[ctr] = byte(elemcborlen)[ctr - lctr];&#13;
                            ctr++;&#13;
                        }&#13;
                    }&#13;
                    res[ctr] = elemArray[i][x];&#13;
                    ctr++;&#13;
                }&#13;
                res[ctr] = 0xFF;&#13;
                ctr++;&#13;
            }&#13;
            return res;&#13;
        }&#13;
&#13;
&#13;
    string oraclize_network_name;&#13;
    function oraclize_setNetworkName(string _network_name) internal {&#13;
        oraclize_network_name = _network_name;&#13;
    }&#13;
&#13;
    function oraclize_getNetworkName() internal view returns (string) {&#13;
        return oraclize_network_name;&#13;
    }&#13;
&#13;
    function oraclize_newRandomDSQuery(uint _delay, uint _nbytes, uint _customGasLimit) internal returns (bytes32){&#13;
        require((_nbytes &gt; 0) &amp;&amp; (_nbytes &lt;= 32));&#13;
        // Convert from seconds to ledger timer ticks&#13;
        _delay *= 10; &#13;
        bytes memory nbytes = new bytes(1);&#13;
        nbytes[0] = byte(_nbytes);&#13;
        bytes memory unonce = new bytes(32);&#13;
        bytes memory sessionKeyHash = new bytes(32);&#13;
        bytes32 sessionKeyHash_bytes32 = oraclize_randomDS_getSessionPubKeyHash();&#13;
        assembly {&#13;
            mstore(unonce, 0x20)&#13;
            mstore(add(unonce, 0x20), xor(blockhash(sub(number, 1)), xor(coinbase, timestamp)))&#13;
            mstore(sessionKeyHash, 0x20)&#13;
            mstore(add(sessionKeyHash, 0x20), sessionKeyHash_bytes32)&#13;
        }&#13;
        bytes memory delay = new bytes(32);&#13;
        assembly { &#13;
            mstore(add(delay, 0x20), _delay) &#13;
        }&#13;
        &#13;
        bytes memory delay_bytes8 = new bytes(8);&#13;
        copyBytes(delay, 24, 8, delay_bytes8, 0);&#13;
&#13;
        bytes[4] memory args = [unonce, nbytes, sessionKeyHash, delay];&#13;
        bytes32 queryId = oraclize_query("random", args, _customGasLimit);&#13;
        &#13;
        bytes memory delay_bytes8_left = new bytes(8);&#13;
        &#13;
        assembly {&#13;
            let x := mload(add(delay_bytes8, 0x20))&#13;
            mstore8(add(delay_bytes8_left, 0x27), div(x, 0x100000000000000000000000000000000000000000000000000000000000000))&#13;
            mstore8(add(delay_bytes8_left, 0x26), div(x, 0x1000000000000000000000000000000000000000000000000000000000000))&#13;
            mstore8(add(delay_bytes8_left, 0x25), div(x, 0x10000000000000000000000000000000000000000000000000000000000))&#13;
            mstore8(add(delay_bytes8_left, 0x24), div(x, 0x100000000000000000000000000000000000000000000000000000000))&#13;
            mstore8(add(delay_bytes8_left, 0x23), div(x, 0x1000000000000000000000000000000000000000000000000000000))&#13;
            mstore8(add(delay_bytes8_left, 0x22), div(x, 0x10000000000000000000000000000000000000000000000000000))&#13;
            mstore8(add(delay_bytes8_left, 0x21), div(x, 0x100000000000000000000000000000000000000000000000000))&#13;
            mstore8(add(delay_bytes8_left, 0x20), div(x, 0x1000000000000000000000000000000000000000000000000))&#13;
&#13;
        }&#13;
        &#13;
        oraclize_randomDS_setCommitment(queryId, keccak256(delay_bytes8_left, args[1], sha256(args[0]), args[2]));&#13;
        return queryId;&#13;
    }&#13;
    &#13;
    function oraclize_randomDS_setCommitment(bytes32 queryId, bytes32 commitment) internal {&#13;
        oraclize_randomDS_args[queryId] = commitment;&#13;
    }&#13;
&#13;
    mapping(bytes32=&gt;bytes32) oraclize_randomDS_args;&#13;
    mapping(bytes32=&gt;bool) oraclize_randomDS_sessionKeysHashVerified;&#13;
&#13;
    function verifySig(bytes32 tosignh, bytes dersig, bytes pubkey) internal returns (bool){&#13;
        bool sigok;&#13;
        address signer;&#13;
&#13;
        bytes32 sigr;&#13;
        bytes32 sigs;&#13;
&#13;
        bytes memory sigr_ = new bytes(32);&#13;
        uint offset = 4+(uint(dersig[3]) - 0x20);&#13;
        sigr_ = copyBytes(dersig, offset, 32, sigr_, 0);&#13;
        bytes memory sigs_ = new bytes(32);&#13;
        offset += 32 + 2;&#13;
        sigs_ = copyBytes(dersig, offset+(uint(dersig[offset-1]) - 0x20), 32, sigs_, 0);&#13;
&#13;
        assembly {&#13;
            sigr := mload(add(sigr_, 32))&#13;
            sigs := mload(add(sigs_, 32))&#13;
        }&#13;
&#13;
&#13;
        (sigok, signer) = safer_ecrecover(tosignh, 27, sigr, sigs);&#13;
        if (address(keccak256(pubkey)) == signer) return true;&#13;
        else {&#13;
            (sigok, signer) = safer_ecrecover(tosignh, 28, sigr, sigs);&#13;
            return (address(keccak256(pubkey)) == signer);&#13;
        }&#13;
    }&#13;
&#13;
    function oraclize_randomDS_proofVerify__sessionKeyValidity(bytes proof, uint sig2offset) internal returns (bool) {&#13;
        bool sigok;&#13;
&#13;
        // Step 6: verify the attestation signature, APPKEY1 must sign the sessionKey from the correct ledger app (CODEHASH)&#13;
        bytes memory sig2 = new bytes(uint(proof[sig2offset+1])+2);&#13;
        copyBytes(proof, sig2offset, sig2.length, sig2, 0);&#13;
&#13;
        bytes memory appkey1_pubkey = new bytes(64);&#13;
        copyBytes(proof, 3+1, 64, appkey1_pubkey, 0);&#13;
&#13;
        bytes memory tosign2 = new bytes(1+65+32);&#13;
        tosign2[0] = byte(1); //role&#13;
        copyBytes(proof, sig2offset-65, 65, tosign2, 1);&#13;
        bytes memory CODEHASH = hex"fd94fa71bc0ba10d39d464d0d8f465efeef0a2764e3887fcc9df41ded20f505c";&#13;
        copyBytes(CODEHASH, 0, 32, tosign2, 1+65);&#13;
        sigok = verifySig(sha256(tosign2), sig2, appkey1_pubkey);&#13;
&#13;
        if (sigok == false) return false;&#13;
&#13;
&#13;
        // Step 7: verify the APPKEY1 provenance (must be signed by Ledger)&#13;
        bytes memory LEDGERKEY = hex"7fb956469c5c9b89840d55b43537e66a98dd4811ea0a27224272c2e5622911e8537a2f8e86a46baec82864e98dd01e9ccc2f8bc5dfc9cbe5a91a290498dd96e4";&#13;
&#13;
        bytes memory tosign3 = new bytes(1+65);&#13;
        tosign3[0] = 0xFE;&#13;
        copyBytes(proof, 3, 65, tosign3, 1);&#13;
&#13;
        bytes memory sig3 = new bytes(uint(proof[3+65+1])+2);&#13;
        copyBytes(proof, 3+65, sig3.length, sig3, 0);&#13;
&#13;
        sigok = verifySig(sha256(tosign3), sig3, LEDGERKEY);&#13;
&#13;
        return sigok;&#13;
    }&#13;
&#13;
    modifier oraclize_randomDS_proofVerify(bytes32 _queryId, string _result, bytes _proof) {&#13;
        // Step 1: the prefix has to match 'LP\x01' (Ledger Proof version 1)&#13;
        require((_proof[0] == "L") &amp;&amp; (_proof[1] == "P") &amp;&amp; (_proof[2] == 1));&#13;
&#13;
        bool proofVerified = oraclize_randomDS_proofVerify__main(_proof, _queryId, bytes(_result), oraclize_getNetworkName());&#13;
        require(proofVerified);&#13;
&#13;
        _;&#13;
    }&#13;
&#13;
    function oraclize_randomDS_proofVerify__returnCode(bytes32 _queryId, string _result, bytes _proof) internal returns (uint8){&#13;
        // Step 1: the prefix has to match 'LP\x01' (Ledger Proof version 1)&#13;
        if ((_proof[0] != "L")||(_proof[1] != "P")||(_proof[2] != 1)) return 1;&#13;
&#13;
        bool proofVerified = oraclize_randomDS_proofVerify__main(_proof, _queryId, bytes(_result), oraclize_getNetworkName());&#13;
        if (proofVerified == false) return 2;&#13;
&#13;
        return 0;&#13;
    }&#13;
&#13;
    function matchBytes32Prefix(bytes32 content, bytes prefix, uint n_random_bytes) internal pure returns (bool){&#13;
        bool match_ = true;&#13;
        &#13;
        require(prefix.length == n_random_bytes);&#13;
&#13;
        for (uint256 i=0; i&lt; n_random_bytes; i++) {&#13;
            if (content[i] != prefix[i]) match_ = false;&#13;
        }&#13;
&#13;
        return match_;&#13;
    }&#13;
&#13;
    function oraclize_randomDS_proofVerify__main(bytes proof, bytes32 queryId, bytes result, string context_name) internal returns (bool){&#13;
&#13;
        // Step 2: the unique keyhash has to match with the sha256 of (context name + queryId)&#13;
        uint ledgerProofLength = 3+65+(uint(proof[3+65+1])+2)+32;&#13;
        bytes memory keyhash = new bytes(32);&#13;
        copyBytes(proof, ledgerProofLength, 32, keyhash, 0);&#13;
        if (!(keccak256(keyhash) == keccak256(sha256(context_name, queryId)))) return false;&#13;
&#13;
        bytes memory sig1 = new bytes(uint(proof[ledgerProofLength+(32+8+1+32)+1])+2);&#13;
        copyBytes(proof, ledgerProofLength+(32+8+1+32), sig1.length, sig1, 0);&#13;
&#13;
        // Step 3: we assume sig1 is valid (it will be verified during step 5) and we verify if 'result' is the prefix of sha256(sig1)&#13;
        if (!matchBytes32Prefix(sha256(sig1), result, uint(proof[ledgerProofLength+32+8]))) return false;&#13;
&#13;
        // Step 4: commitment match verification, keccak256(delay, nbytes, unonce, sessionKeyHash) == commitment in storage.&#13;
        // This is to verify that the computed args match with the ones specified in the query.&#13;
        bytes memory commitmentSlice1 = new bytes(8+1+32);&#13;
        copyBytes(proof, ledgerProofLength+32, 8+1+32, commitmentSlice1, 0);&#13;
&#13;
        bytes memory sessionPubkey = new bytes(64);&#13;
        uint sig2offset = ledgerProofLength+32+(8+1+32)+sig1.length+65;&#13;
        copyBytes(proof, sig2offset-64, 64, sessionPubkey, 0);&#13;
&#13;
        bytes32 sessionPubkeyHash = sha256(sessionPubkey);&#13;
        if (oraclize_randomDS_args[queryId] == keccak256(commitmentSlice1, sessionPubkeyHash)){ //unonce, nbytes and sessionKeyHash match&#13;
            delete oraclize_randomDS_args[queryId];&#13;
        } else return false;&#13;
&#13;
&#13;
        // Step 5: validity verification for sig1 (keyhash and args signed with the sessionKey)&#13;
        bytes memory tosign1 = new bytes(32+8+1+32);&#13;
        copyBytes(proof, ledgerProofLength, 32+8+1+32, tosign1, 0);&#13;
        if (!verifySig(sha256(tosign1), sig1, sessionPubkey)) return false;&#13;
&#13;
        // verify if sessionPubkeyHash was verified already, if not.. let's do it!&#13;
        if (oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash] == false){&#13;
            oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash] = oraclize_randomDS_proofVerify__sessionKeyValidity(proof, sig2offset);&#13;
        }&#13;
&#13;
        return oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash];&#13;
    }&#13;
&#13;
    // the following function has been written by Alex Beregszaszi (@axic), use it under the terms of the MIT license&#13;
    function copyBytes(bytes from, uint fromOffset, uint length, bytes to, uint toOffset) internal pure returns (bytes) {&#13;
        uint minLength = length + toOffset;&#13;
&#13;
        // Buffer too small&#13;
        require(to.length &gt;= minLength); // Should be a better way?&#13;
&#13;
        // NOTE: the offset 32 is added to skip the `size` field of both bytes variables&#13;
        uint i = 32 + fromOffset;&#13;
        uint j = 32 + toOffset;&#13;
&#13;
        while (i &lt; (32 + fromOffset + length)) {&#13;
            assembly {&#13;
                let tmp := mload(add(from, i))&#13;
                mstore(add(to, j), tmp)&#13;
            }&#13;
            i += 32;&#13;
            j += 32;&#13;
        }&#13;
&#13;
        return to;&#13;
    }&#13;
&#13;
    // the following function has been written by Alex Beregszaszi (@axic), use it under the terms of the MIT license&#13;
    // Duplicate Solidity's ecrecover, but catching the CALL return value&#13;
    function safer_ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal returns (bool, address) {&#13;
        // We do our own memory management here. Solidity uses memory offset&#13;
        // 0x40 to store the current end of memory. We write past it (as&#13;
        // writes are memory extensions), but don't update the offset so&#13;
        // Solidity will reuse it. The memory used here is only needed for&#13;
        // this context.&#13;
&#13;
        // FIXME: inline assembly can't access return values&#13;
        bool ret;&#13;
        address addr;&#13;
&#13;
        assembly {&#13;
            let size := mload(0x40)&#13;
            mstore(size, hash)&#13;
            mstore(add(size, 32), v)&#13;
            mstore(add(size, 64), r)&#13;
            mstore(add(size, 96), s)&#13;
&#13;
            // NOTE: we can reuse the request memory because we deal with&#13;
            //       the return code&#13;
            ret := call(3000, 1, 0, size, 128, size, 32)&#13;
            addr := mload(size)&#13;
        }&#13;
&#13;
        return (ret, addr);&#13;
    }&#13;
&#13;
    // the following function has been written by Alex Beregszaszi (@axic), use it under the terms of the MIT license&#13;
    function ecrecovery(bytes32 hash, bytes sig) internal returns (bool, address) {&#13;
        bytes32 r;&#13;
        bytes32 s;&#13;
        uint8 v;&#13;
&#13;
        if (sig.length != 65)&#13;
          return (false, 0);&#13;
&#13;
        // The signature format is a compact form of:&#13;
        //   {bytes32 r}{bytes32 s}{uint8 v}&#13;
        // Compact means, uint8 is not padded to 32 bytes.&#13;
        assembly {&#13;
            r := mload(add(sig, 32))&#13;
            s := mload(add(sig, 64))&#13;
&#13;
            // Here we are loading the last 32 bytes. We exploit the fact that&#13;
            // 'mload' will pad with zeroes if we overread.&#13;
            // There is no 'mload8' to do this, but that would be nicer.&#13;
            v := byte(0, mload(add(sig, 96)))&#13;
&#13;
            // Alternative solution:&#13;
            // 'byte' is not working due to the Solidity parser, so lets&#13;
            // use the second best option, 'and'&#13;
            // v := and(mload(add(sig, 65)), 255)&#13;
        }&#13;
&#13;
        // albeit non-transactional signatures are not specified by the YP, one would expect it&#13;
        // to match the YP range of [27, 28]&#13;
        //&#13;
        // geth uses [0, 1] and some clients have followed. This might change, see:&#13;
        //  https://github.com/ethereum/go-ethereum/issues/2053&#13;
        if (v &lt; 27)&#13;
          v += 27;&#13;
&#13;
        if (v != 27 &amp;&amp; v != 28)&#13;
            return (false, 0);&#13;
&#13;
        return safer_ecrecover(hash, v, r, s);&#13;
    }&#13;
&#13;
}&#13;
// &lt;/ORACLIZE_API&gt;&#13;
&#13;
// File: contracts/WorldCupBroker.sol&#13;
&#13;
/*&#13;
 * @title String &amp; slice utility library for Solidity contracts.&#13;
 * @author Daniel Bennett &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="e88c8a8d86868d9c9cd9d0a8989a879c878685898184c68b8785">[emailÂ protected]</a>&gt;&#13;
 *&#13;
 * @dev This is a solitidy contract that facilitates betting for the 2018&#13;
        world cup. The contract on does not act as a counter party &#13;
        to any bets placed and thus users bet on a decision pool for a match&#13;
        (win, lose, draw), and based on the results of users will be credited winnings&#13;
        proportional to their contributions to the winning pool.&#13;
    */&#13;
&#13;
&#13;
pragma solidity ^0.4.4;&#13;
&#13;
&#13;
&#13;
&#13;
contract WorldCupBroker is Ownable, usingOraclize {&#13;
&#13;
    using strings for *;&#13;
&#13;
    struct Bet {&#13;
        bool    cancelled;&#13;
        bool    claimed;&#13;
        uint    amount;&#13;
        uint8   option; // 1 - teamA, 2 - teamB, 3 - Draw&#13;
        address better;&#13;
    }&#13;
    &#13;
    struct Match {&#13;
        bool   locked; // match will be locked after payout or all bets returned&#13;
        bool   cancelled;&#13;
        uint8  teamA;&#13;
        uint8  teamB;&#13;
        uint8  winner; // 0 - not set, 1 - teamA, 2 - teamB, 3- Draw, 4 - no winner&#13;
        uint   start;&#13;
        uint   closeBettingTime; // since this the close delay is constant &#13;
        // this will always be the same, save gas for betters and just set the close time once&#13;
        uint   totalTeamABets;&#13;
        uint   totalTeamBBets;&#13;
        uint   totalDrawBets;&#13;
        uint   numBets;&#13;
        string fixtureId;&#13;
        string secondaryFixtureId;&#13;
        bool   inverted; // inverted if the secondary api has the home team and away teams inverted&#13;
        string name;&#13;
        mapping(uint =&gt; Bet) bets;&#13;
    }&#13;
&#13;
    event MatchCreated(uint8);&#13;
&#13;
    event MatchUpdated(uint8);&#13;
&#13;
    event MatchFailedPayoutRelease(uint8);&#13;
&#13;
    event BetPlaced(&#13;
        uint8   matchId,&#13;
        uint8   outcome,&#13;
        uint    betId,&#13;
        uint    amount,&#13;
        address better&#13;
    );&#13;
&#13;
    event BetClaimed(&#13;
        uint8   matchId,&#13;
        uint    betId&#13;
    );&#13;
&#13;
    event BetCancelled(&#13;
        uint8   matchId,&#13;
        uint    betId&#13;
    );&#13;
    &#13;
    string[32] public TEAMS = [&#13;
        "Russia", &#13;
        "Saudi Arabia", &#13;
        "Egypt", &#13;
        "Uruguay", &#13;
        "Morocco", &#13;
        "Iran", &#13;
        "Portugal", &#13;
        "Spain", &#13;
        "France", &#13;
        "Australia", &#13;
        "Argentina", &#13;
        "Iceland", &#13;
        "Peru", &#13;
        "Denmark", &#13;
        "Croatia", &#13;
        "Nigeria", &#13;
        "Costa Rica", &#13;
        "Serbia", &#13;
        "Germany", &#13;
        "Mexico", &#13;
        "Brazil", &#13;
        "Switzerland", &#13;
        "Sweden", &#13;
        "South Korea", &#13;
        "Belgium", &#13;
        "Panama", &#13;
        "Tunisia", &#13;
        "England", &#13;
        "Poland", &#13;
        "Senegal", &#13;
        "Colombia", &#13;
        "Japan"&#13;
    ];&#13;
    uint public constant MAX_NUM_PAYOUT_ATTEMPTS = 3; // after 3 consecutive failed payout attempts, lock the match&#13;
    uint public constant PAYOUT_ATTEMPT_INTERVAL = 10 minutes; // try every 10 minutes to release payout&#13;
    uint public  commission_rate = 7;&#13;
    uint public  minimum_bet = 0.01 ether;&#13;
    uint private commissions = 0;&#13;
    uint public  primaryGasLimit = 225000;&#13;
    uint public  secondaryGasLimit = 250000;&#13;
    &#13;
&#13;
    Match[] matches;&#13;
    mapping(bytes32 =&gt; uint8) oraclizeIds;&#13;
    mapping(uint8 =&gt; uint8) payoutAttempts;&#13;
    mapping(uint8 =&gt; bool) firstStepVerified;&#13;
    mapping(uint8 =&gt; uint8) pendingWinner;&#13;
&#13;
     /*&#13;
     * @dev Ensures a matchId points to a legitimate match&#13;
     * @param _matchId the uint to check if it points to a valid match.&#13;
     */&#13;
    modifier validMatch(uint8 _matchId) {&#13;
        require(_matchId &lt; uint8(matches.length));&#13;
        _;&#13;
    }&#13;
&#13;
    /*&#13;
     * @dev the validBet modifier does as it's name implies and ensures that a bet&#13;
     * is valid before proceeding with any methods called on the contract&#13;
     * that would require access to such a bet&#13;
     * @param _matchId the uint to check if it points to a valid match.&#13;
     * @param _betId the uint to check if it points to a valid bet for a match.&#13;
     */&#13;
    modifier validBet(uint8 _matchId, uint _betId) {&#13;
        // short circuit to save gas&#13;
        require(_matchId &lt; uint8(matches.length) &amp;&amp; _betId &lt; matches[_matchId].numBets);&#13;
        _;&#13;
    }&#13;
&#13;
    /*&#13;
     * @dev Adds a new match to the smart contract and schedules an oraclize query call&#13;
     *      to determine the winner of a match within 3 hours. Additionally emits an event&#13;
     *      signifying a match was created.&#13;
     * @param _name      the unique identifier of the match, should be of format Stage:Team A vs Team B&#13;
     * @param _fixture   the fixtureId for the football-data.org endpoint&#13;
     * @param _secondary the fixtureId for the sportsmonk.com endpoint&#13;
     * @param _inverted  should be set to true if the teams are inverted on either of the API &#13;
     *                   that is if the hometeam and localteam are swapped&#13;
     * @param _teamA     index of the homeTeam from the TEAMS array&#13;
     * @param _teamB     index of the awayTeam from the TEAMS array&#13;
     * @param _start     the unix timestamp for when the match is scheduled to begin&#13;
     * @return `uint`     the Id of the match in the matches array&#13;
     */ &#13;
    function addMatch(string _name, string _fixture, string _secondary, bool _invert, uint8 _teamA, uint8 _teamB, uint _start) public onlyOwner returns (uint8) {&#13;
        // Check that there's at least 15 minutes until the match starts&#13;
        require(_teamA &lt; 32 &amp;&amp; _teamB &lt; 32 &amp;&amp; _teamA != _teamB &amp;&amp; (_start - 15 minutes) &gt;= now);&#13;
        Match memory newMatch = Match({&#13;
            locked: false, &#13;
            cancelled: false, &#13;
            teamA: _teamA,&#13;
            teamB: _teamB, &#13;
            winner: 0,&#13;
            fixtureId: _fixture, // The primary fixtureId that will be used to query the football-data API&#13;
            secondaryFixtureId: _secondary, // The secondary fixtureID used to query sports monk&#13;
            inverted: _invert,&#13;
            start: _start, &#13;
            closeBettingTime: _start - 3 minutes, // betting closes 3 minutes before a match starts&#13;
            totalTeamABets: 0, &#13;
            totalTeamBBets: 0, &#13;
            totalDrawBets: 0, &#13;
            numBets: 0,&#13;
            name: _name&#13;
        });&#13;
        uint8 matchId = uint8(matches.push(newMatch)) - 1;&#13;
        // concatinate oraclize query&#13;
        string memory url = strConcat(&#13;
            "[URL] json(https://soccer.sportmonks.com/api/v2.0/fixtures/",&#13;
            newMatch.secondaryFixtureId,&#13;
            "?api_token=${[decrypt] BNxYykO2hsQ7iA7yRuDLSu1km6jFZwN5X87TY1BSmU30llRn8uWkJjHgx+YGytA1tmbRjb20CW0gIzcFmvq3yLZnitsvW28SPjlf+s9MK7hU+uRXqwhoW6dmWqKsBrCigrggFwMBRk4kA16jugtIr+enXHjOnAKSxd1dO4YXTCYvZc3T1pFA9PVyFFnd}).data.scores[localteam_score,visitorteam_score]");&#13;
        // store the oraclize query id for later use&#13;
        // use hours to over estimate the amount of time it would take to safely get a correct result&#13;
        // 90 minutes of regulation play time + potential 30 minutes of extra time + 15 minutes break&#13;
        // + potential 10 minutes of stoppage time + potential 10 minutes of penalties&#13;
        // + 25 minutes of time for any APIs to correct and ensure their information is correct&#13;
        bytes32 oraclizeId = oraclize_query((_start + (3 hours)), "nested", url, primaryGasLimit);&#13;
        oraclizeIds[oraclizeId] = matchId;&#13;
        emit MatchCreated(matchId);&#13;
        return matchId;&#13;
    }&#13;
&#13;
    function cancelMatch(uint8 _matchId) public onlyOwner validMatch(_matchId) returns (bool) {&#13;
        Match storage mtch = matches[_matchId];&#13;
        require(!mtch.cancelled &amp;&amp; now &lt; mtch.closeBettingTime);&#13;
        mtch.cancelled = true;&#13;
        mtch.locked = true;&#13;
        emit MatchUpdated(_matchId);&#13;
        return true;&#13;
    }&#13;
&#13;
    /*&#13;
     * @dev returns the number of matches on the contract&#13;
     */ &#13;
    function getNumMatches() public view returns (uint) {&#13;
        return matches.length;&#13;
    }&#13;
&#13;
    &#13;
    /*&#13;
     * @dev Returns some of the properties of a match. Functionality had to be seperated&#13;
     *      into 2 function calls to prevent stack too deep errors&#13;
     * @param _matchId   the index of that match in the matches array&#13;
     * @return `string`  the match name&#13;
     * @return `string`  the fixutre Id of the match for the football-data endpoint&#13;
     * @return `string`  the fixture Id fo the match for the sports monk endpoint&#13;
     * @return `uint8`   the index of the home team&#13;
     * @return `uint8`   the index of the away team&#13;
     * @return `uint8`   the winner of the match&#13;
     * @return `uint`    the unix timestamp for the match start time&#13;
     * @return `bool`    Match cancelled boolean&#13;
     * @return `bool`    Match locked boolean which is set to true if the match is payed out or bets are returned&#13;
     */ &#13;
    function getMatch(uint8 _matchId) public view validMatch(_matchId) returns (string, string, string, bool, uint8, uint8, uint8, uint, bool, bool) {&#13;
        Match memory mtch = matches[_matchId];&#13;
        return (&#13;
            mtch.name,&#13;
            mtch.fixtureId, &#13;
            mtch.secondaryFixtureId,&#13;
            mtch.inverted,&#13;
            mtch.teamA, &#13;
            mtch.teamB,&#13;
            mtch.winner, &#13;
            mtch.start,&#13;
            mtch.cancelled,&#13;
            mtch.locked&#13;
        );&#13;
    }&#13;
&#13;
    /*&#13;
     * @dev Returns remaining of the properties of a match. Functionality had to be seperated&#13;
     *      into 2 function calls to prevent stack too deep errors&#13;
     * @param _matchId   the index of that match in the matches array&#13;
     * @return `uint`  timestamp for when betting for the match closes&#13;
     * @return `uint`  total size of the home team bet pool&#13;
     * @return `uint`  total size of the away team bet pool&#13;
     * @return `uint`  total size of the draw bet pool&#13;
     * @return `uint`  the total number of bets&#13;
     * @return `uint8` the number of payout attempts for the match&#13;
     */ &#13;
    function getMatchBettingDetails(uint8 _matchId) public view validMatch(_matchId) returns (uint, uint, uint, uint, uint, uint8) {&#13;
        Match memory mtch = matches[_matchId];&#13;
        return (&#13;
            mtch.closeBettingTime,&#13;
            mtch.totalTeamABets, &#13;
            mtch.totalTeamBBets, &#13;
            mtch.totalDrawBets,&#13;
            mtch.numBets,&#13;
            payoutAttempts[_matchId]&#13;
        );&#13;
    }&#13;
&#13;
    /*&#13;
     * @dev Adds a new bet to a match with the outcome passed where there are 3 possible outcomes&#13;
     *      homeTeam wins(1), awayTeam wins(2), draw(3). While it is possible for some matches&#13;
     *      to end in a draw, not all matches will have the possibility of ending in a draw&#13;
     *      this functionality will be added in front end code to prevent betting on invalid decisions.&#13;
     *      Emits a BetPlaced event.&#13;
     * @param _matchId   the index of the match in matches that the bet is for&#13;
     * @param _outcome   the possible outcome for the match that this bet is betting on &#13;
     * @return `uint`    the Id of the bet in a match's bet array&#13;
     */ &#13;
    function placeBet(uint8 _matchId, uint8 _outcome) public payable validMatch(_matchId) returns (uint) {&#13;
        Match storage mtch = matches[_matchId];&#13;
        // A bet must be a valid option, 1, 2, or 3, and cannot be less that the minimum bet amount&#13;
        require(&#13;
            !mtch.locked &amp;&amp;&#13;
            !mtch.cancelled &amp;&amp;&#13;
            now &lt; mtch.closeBettingTime &amp;&amp;&#13;
            _outcome &gt; 0 &amp;&amp; &#13;
            _outcome &lt; 4 &amp;&amp; &#13;
            msg.value &gt;= minimum_bet&#13;
        );&#13;
        Bet memory bet = Bet(false, false, msg.value, _outcome, msg.sender);&#13;
        uint betId = mtch.numBets;&#13;
        mtch.bets[betId] = bet;&#13;
        mtch.numBets++;&#13;
        if (_outcome == 1) {&#13;
            mtch.totalTeamABets += msg.value;&#13;
            // a bit of safe math checking here&#13;
            assert(mtch.totalTeamABets &gt;= msg.value);&#13;
        } else if (_outcome == 2) {&#13;
            mtch.totalTeamBBets += msg.value;&#13;
            assert(mtch.totalTeamBBets &gt;= msg.value);&#13;
        } else {&#13;
            mtch.totalDrawBets += msg.value;&#13;
            assert(mtch.totalDrawBets &gt;= msg.value);&#13;
        }&#13;
        // emit bet placed event&#13;
        emit BetPlaced(_matchId, _outcome, betId, msg.value, msg.sender);&#13;
        return (betId);&#13;
    }&#13;
&#13;
    /*&#13;
     * @dev Returns the properties of a bet for a match&#13;
     * @param _matchId   the index of that match in the matches array&#13;
     * @param _betId     the index of that bet in the match bets array&#13;
     * @return `address` the address that placed the bet and thus it's owner&#13;
     * @return `uint`    the amount that was bet&#13;
     * @return `uint`    the option that was bet on&#13;
     * @return `bool`    wether or not the bet had been cancelled&#13;
     */ &#13;
    function getBet(uint8 _matchId, uint _betId) public view validBet(_matchId, _betId) returns (address, uint, uint, bool, bool) {&#13;
        Bet memory bet = matches[_matchId].bets[_betId];&#13;
        // Don't return matchId and betId since you had to know them in the first place&#13;
        return (bet.better, bet.amount, bet.option, bet.cancelled, bet.claimed);&#13;
    } &#13;
&#13;
    /*&#13;
     * @dev Cancel's a bet and returns the amount - commission fee. Emits a BetCancelled event&#13;
     * @param _matchId   the index of that match in the matches array&#13;
     * @param _betId     the index of that bet in the match bets array&#13;
     */ &#13;
    function cancelBet(uint8 _matchId, uint _betId) public validBet(_matchId, _betId) {&#13;
        Match memory mtch = matches[_matchId];&#13;
        require(!mtch.locked &amp;&amp; now &lt; mtch.closeBettingTime);&#13;
        Bet storage bet = matches[_matchId].bets[_betId];&#13;
        // only the person who made this bet can cancel it&#13;
        require(!bet.cancelled &amp;&amp; !bet.claimed &amp;&amp; bet.better == msg.sender );&#13;
        // stop re-entry just in case of malicious attack to withdraw all contract eth&#13;
        bet.cancelled = true;&#13;
        uint commission = bet.amount / 100 * commission_rate;&#13;
        commissions += commission;&#13;
        assert(commissions &gt;= commission);&#13;
        if (bet.option == 1) {&#13;
            matches[_matchId].totalTeamABets -= bet.amount;&#13;
        } else if (bet.option == 2) {&#13;
            matches[_matchId].totalTeamBBets -= bet.amount;&#13;
        } else if (bet.option == 3) {&#13;
            matches[_matchId].totalDrawBets -= bet.amount;&#13;
        }&#13;
        bet.better.transfer(bet.amount - commission);&#13;
        emit BetCancelled(_matchId, _betId);&#13;
    }&#13;
&#13;
    /*&#13;
     * @dev Betters can claim there winnings using this method or reclaim their bet&#13;
     *      if the match was cancelled&#13;
     * @param _matchId   the index of the match in the matches array&#13;
     * @param _betId     the bet being claimed&#13;
     */ &#13;
    function claimBet(uint8 _matchId, uint8 _betId) public validBet(_matchId, _betId) {&#13;
        Match storage mtch = matches[_matchId];&#13;
        Bet storage bet = mtch.bets[_betId];&#13;
        // ensures the match has been locked (payout either done or bets returned)&#13;
        // dead man's switch to prevent bets from ever getting locked in the contrat&#13;
        // from insufficient funds during an oracalize query&#13;
        // if the match isn't locked or cancelled, then you can claim your bet after&#13;
        // the world cup is over (noon July 16)&#13;
        require((mtch.locked || now &gt;= 1531742400) &amp;&amp;&#13;
            !bet.claimed &amp;&amp;&#13;
            !bet.cancelled &amp;&amp;&#13;
            msg.sender == bet.better&#13;
        );&#13;
        bet.claimed = true;&#13;
        if (mtch.winner == 0) {&#13;
            // If the match is locked with no winner set&#13;
            // then either it was cancelled or a winner couldn't be determined&#13;
            // transfer better back their bet amount&#13;
            bet.better.transfer(bet.amount);&#13;
        } else {&#13;
            if (bet.option != mtch.winner) {&#13;
                return;&#13;
            }&#13;
            uint totalPool;&#13;
            uint winPool;&#13;
            if (mtch.winner == 1) {&#13;
                totalPool = mtch.totalTeamBBets + mtch.totalDrawBets;&#13;
                // once again do some safe math&#13;
                assert(totalPool &gt;= mtch.totalTeamBBets);&#13;
                winPool = mtch.totalTeamABets;&#13;
            } else if (mtch.winner == 2) {&#13;
                totalPool = mtch.totalTeamABets + mtch.totalDrawBets;&#13;
                assert(totalPool &gt;= mtch.totalTeamABets);&#13;
                winPool = mtch.totalTeamBBets;&#13;
            } else {&#13;
                totalPool = mtch.totalTeamABets + mtch.totalTeamBBets;&#13;
                assert(totalPool &gt;= mtch.totalTeamABets);&#13;
                winPool = mtch.totalDrawBets;&#13;
            }&#13;
            uint winnings = totalPool * bet.amount / winPool;&#13;
            // calculate commissions percentage&#13;
            uint commission = winnings / 100 * commission_rate;&#13;
            commissions += commission;&#13;
            assert(commissions &gt;= commission);&#13;
            // return original bet amount + winnings - commission&#13;
            bet.better.transfer(winnings + bet.amount - commission);&#13;
        }&#13;
        emit BetClaimed(_matchId, _betId);&#13;
    }&#13;
&#13;
    /*&#13;
     * @dev Change the commission fee for the contract. The fee can never exceed 7%&#13;
     * @param _newCommission  the new fee rate to be charged in wei&#13;
     */ &#13;
    function changeFees(uint8 _newCommission) public onlyOwner {&#13;
        // Max commission is 7%, but it can be FREE!!&#13;
        require(_newCommission &lt;= 7);&#13;
        commission_rate = _newCommission;&#13;
    }&#13;
&#13;
    /*&#13;
     * @dev Withdraw a portion of the commission from the commission pool.&#13;
     * @param _amount  the amount of commission to be withdrawn&#13;
     */ &#13;
    function withdrawCommissions(uint _amount) public onlyOwner {&#13;
        require(_amount &lt;= commissions);&#13;
        commissions -= _amount;&#13;
        owner.transfer(_amount);&#13;
    }&#13;
&#13;
    /*&#13;
     * @dev Destroy the contract but only after the world cup is over for a month&#13;
     */ &#13;
    function withdrawBalance() public onlyOwner {&#13;
        // World cup is over for a full month withdraw the full balance of the contract&#13;
        // and destroy it to free space on the blockchain&#13;
        require(now &gt;= 1534291200); // This is 12am August 15, 2018&#13;
        selfdestruct(owner);&#13;
    }&#13;
&#13;
    &#13;
    /*&#13;
     * @dev Change the minimum bet amount. Just in case the price of eth skyrockets or drops.&#13;
     * @param _newMin   the new minimum bet amount&#13;
     */ &#13;
    function changeMiniumBet(uint _newMin) public onlyOwner {&#13;
        minimum_bet = _newMin;&#13;
    }&#13;
&#13;
    /*&#13;
     * @dev sets the gas price to be used for oraclize quries in the contract&#13;
     * @param _price          the price of each gas&#13;
     */ &#13;
    function setGasPrice(uint _price) public onlyOwner {&#13;
        require(_price &gt;= 20000000000 wei);&#13;
        oraclize_setCustomGasPrice(_price);&#13;
    }&#13;
&#13;
&#13;
     /*&#13;
     * @dev Oraclize query callback to determine the winner of the match.&#13;
     * @param _myid    the id for the oraclize query that is being returned&#13;
     * @param _result  the result of the query&#13;
     */ &#13;
    function __callback(bytes32 _myid, string _result) public {&#13;
        // only oraclize can call this method&#13;
        if (msg.sender != oraclize_cbAddress()) revert();&#13;
        uint8 matchId = oraclizeIds[_myid];&#13;
        Match storage mtch = matches[matchId];&#13;
        require(!mtch.locked &amp;&amp; !mtch.cancelled);&#13;
        bool firstVerification = firstStepVerified[matchId];&#13;
        // If there is no result or the result is null we want to do the following&#13;
        if (bytes(_result).length == 0 || (keccak256(_result) == keccak256("[null, null]"))) {&#13;
            // If max number of attempts has been reached then return all bets&#13;
            if (++payoutAttempts[matchId] &gt;= MAX_NUM_PAYOUT_ATTEMPTS) {&#13;
                mtch.locked = true;&#13;
                emit MatchFailedPayoutRelease(matchId);&#13;
            } else {&#13;
                emit MatchUpdated(matchId);&#13;
                string memory url;&#13;
                string memory querytype;&#13;
                uint limit;&#13;
                // if the contract has already verified the sportsmonks api&#13;
                // use football-data.org as a secondary source of truth&#13;
                if (firstVerification) {&#13;
                    url = strConcat(&#13;
                        "json(https://api.football-data.org/v1/fixtures/", &#13;
                        matches[matchId].fixtureId,&#13;
                        ").fixture.result.[goalsHomeTeam,goalsAwayTeam]");&#13;
                    querytype = "URL";&#13;
                    limit = secondaryGasLimit;&#13;
                } else {                &#13;
                    url = strConcat(&#13;
                        "[URL] json(https://soccer.sportmonks.com/api/v2.0/fixtures/",&#13;
                        matches[matchId].secondaryFixtureId,&#13;
                        "?api_token=${[decrypt] BNxYykO2hsQ7iA7yRuDLSu1km6jFZwN5X87TY1BSmU30llRn8uWkJjHgx+YGytA1tmbRjb20CW0gIzcFmvq3yLZnitsvW28SPjlf+s9MK7hU+uRXqwhoW6dmWqKsBrCigrggFwMBRk4kA16jugtIr+enXHjOnAKSxd1dO4YXTCYvZc3T1pFA9PVyFFnd}).data.scores[localteam_score,visitorteam_score]");&#13;
                    querytype = "nested";&#13;
                    // use primary gas limit since that query won't payout winners on callback&#13;
                    limit = primaryGasLimit;&#13;
                }&#13;
                bytes32 oraclizeId = oraclize_query(PAYOUT_ATTEMPT_INTERVAL, querytype, url, limit);&#13;
                oraclizeIds[oraclizeId] = matchId;&#13;
            }&#13;
        } else {&#13;
            payoutAttempts[matchId] = 0;&#13;
            // eg. result = "[2, 4]"&#13;
            strings.slice memory s = _result.toSlice();&#13;
            // remove the braces from the result&#13;
            s = s.beyond("[".toSlice());&#13;
            s = s.until("]".toSlice());&#13;
            // split the string to get the two string encoded ints&#13;
            strings.slice memory x = s.split(", ".toSlice());&#13;
            // parse them to int to get the scores&#13;
            uint homeScore = parseInt(s.toString()); &#13;
            uint awayScore = parseInt(x.toString());&#13;
            uint8 matchResult;&#13;
            // determine the winner&#13;
            if (homeScore &gt; awayScore) {&#13;
                matchResult = 1;&#13;
            } else if (homeScore &lt; awayScore) {&#13;
                matchResult = 2;&#13;
            } else {&#13;
                matchResult = 3;&#13;
            }&#13;
            // if this is the query to sportsmonks&#13;
            if (!firstVerification) {&#13;
                // set pending winner and call the second source of truth&#13;
                pendingWinner[matchId] = matchResult;&#13;
                firstStepVerified[matchId] = true;&#13;
                url = strConcat(&#13;
                    "json(https://api.football-data.org/v1/fixtures/", &#13;
                    matches[matchId].fixtureId,&#13;
                    ").fixture.result.[goalsHomeTeam,goalsAwayTeam]");&#13;
                oraclizeId = oraclize_query("nested", url, secondaryGasLimit);&#13;
                oraclizeIds[oraclizeId] = matchId;&#13;
            } else {&#13;
                mtch.locked = true;&#13;
                // if one of the APIs has the teams inverted then flip the result&#13;
                if (matches[matchId].inverted) {&#13;
                    if (matchResult == 1) {&#13;
                        matchResult = 2;&#13;
                    } else if (matchResult == 2) {&#13;
                        matchResult = 1;&#13;
                    }&#13;
                }&#13;
                // if the both APIs confirm the same winner then payout the winners&#13;
                if (pendingWinner[matchId] == matchResult) {&#13;
                    mtch.winner = matchResult;&#13;
                    emit MatchUpdated(matchId);&#13;
                } else {&#13;
                    // else don't set a winner because a source of truth couldn't be verified&#13;
                    // this way users can still reclaim their original bet amount&#13;
                    emit MatchFailedPayoutRelease(matchId);&#13;
                }&#13;
            }&#13;
        }&#13;
    }&#13;
    &#13;
    function() public payable {}&#13;
}