pragma solidity ^0.4.23; 
 
/*    
* Author:  Konstantin G...
* Telegram: @bunnygame
* 
* email: <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="8ee7e0e8e1ceecfbe0e0f7ede1e7e0a0ede1">[emailÂ protected]</a>&#13;
* site : http://bunnycoin.co&#13;
* @title Ownable&#13;
* @dev The Ownable contract has an owner address, and provides basic authorization control&#13;
* functions, this simplifies the implementation of "user permissions".&#13;
*/&#13;
&#13;
contract Ownable {&#13;
    &#13;
    address owner;&#13;
    address ownerMoney;   &#13;
    &#13;
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);&#13;
 &#13;
&#13;
    /**&#13;
    * @dev The Ownable constructor sets the original `owner` of the contract to the sender&#13;
    * account.&#13;
    */    &#13;
    constructor() public {&#13;
        owner = msg.sender;&#13;
        ownerMoney = msg.sender;&#13;
    }&#13;
&#13;
    /**&#13;
    * @dev Throws if called by any account other than the owner.&#13;
    */&#13;
    modifier onlyOwner() {&#13;
        require(msg.sender == owner);&#13;
        _;&#13;
    }&#13;
&#13;
 &#13;
&#13;
    function transferMoney(address _add) public  onlyOwner {&#13;
        if (_add != address(0)) {&#13;
            ownerMoney = _add;&#13;
        }&#13;
    }&#13;
    &#13;
 &#13;
    function transferOwner(address _add) public onlyOwner {&#13;
        if (_add != address(0)) {&#13;
            owner = _add;&#13;
        }&#13;
    } &#13;
      &#13;
    function getOwnerMoney() public view onlyOwner returns(address) {&#13;
        return ownerMoney;&#13;
    } &#13;
 &#13;
}&#13;
&#13;
 &#13;
&#13;
/**&#13;
 * @title Whitelist&#13;
 * @dev The Whitelist contract has a whitelist of addresses, and provides basic authorization control functions.&#13;
 * @dev This simplifies the implementation of "user permissions".&#13;
 */&#13;
contract Whitelist is Ownable {&#13;
    mapping(address =&gt; bool) public whitelist;&#13;
&#13;
    mapping(uint  =&gt; address)   whitelistCheck;&#13;
    uint public countAddress = 0;&#13;
&#13;
    event WhitelistedAddressAdded(address addr);&#13;
    event WhitelistedAddressRemoved(address addr);&#13;
 &#13;
  /**&#13;
   * @dev Throws if called by any account that's not whitelisted.&#13;
   */&#13;
    modifier onlyWhitelisted() {&#13;
        require(whitelist[msg.sender]);&#13;
        _;&#13;
    }&#13;
&#13;
    constructor() public {&#13;
            whitelist[msg.sender] = true;  &#13;
    }&#13;
&#13;
  /**&#13;
   * @dev add an address to the whitelist&#13;
   * @param addr address&#13;
   * @return true if the address was added to the whitelist, false if the address was already in the whitelist&#13;
   */&#13;
    function addAddressToWhitelist(address addr) onlyWhitelisted public returns(bool success) {&#13;
        if (!whitelist[addr]) {&#13;
            whitelist[addr] = true;&#13;
&#13;
            countAddress = countAddress + 1;&#13;
            whitelistCheck[countAddress] = addr;&#13;
&#13;
            emit WhitelistedAddressAdded(addr);&#13;
            success = true;&#13;
        }&#13;
    }&#13;
&#13;
    function getWhitelistCheck(uint key) onlyWhitelisted view public returns(address) {&#13;
        return whitelistCheck[key];&#13;
    }&#13;
&#13;
&#13;
    function getInWhitelist(address addr) public view returns(bool) {&#13;
        return whitelist[addr];&#13;
    }&#13;
 &#13;
    /**&#13;
    * @dev add addresses to the whitelist&#13;
    * @param addrs addresses&#13;
    * @return true if at least one address was added to the whitelist,&#13;
    * false if all addresses were already in the whitelist&#13;
    */&#13;
    function addAddressesToWhitelist(address[] addrs) onlyOwner public returns(bool success) {&#13;
        for (uint256 i = 0; i &lt; addrs.length; i++) {&#13;
            if (addAddressToWhitelist(addrs[i])) {&#13;
                success = true;&#13;
            }&#13;
        }&#13;
    }&#13;
&#13;
    /**&#13;
    * @dev remove an address from the whitelist&#13;
    * @param addr address&#13;
    * @return true if the address was removed from the whitelist,&#13;
    * false if the address wasn't in the whitelist in the first place&#13;
    */&#13;
    function removeAddressFromWhitelist(address addr) onlyOwner public returns(bool success) {&#13;
        if (whitelist[addr]) {&#13;
            whitelist[addr] = false;&#13;
            emit WhitelistedAddressRemoved(addr);&#13;
            success = true;&#13;
        }&#13;
    }&#13;
&#13;
    /**&#13;
    * @dev remove addresses from the whitelist&#13;
    * @param addrs addresses&#13;
    * @return true if at least one address was removed from the whitelist,&#13;
    * false if all addresses weren't in the whitelist in the first place&#13;
    */&#13;
    function removeAddressesFromWhitelist(address[] addrs) onlyOwner public returns(bool success) {&#13;
        for (uint256 i = 0; i &lt; addrs.length; i++) {&#13;
            if (removeAddressFromWhitelist(addrs[i])) {&#13;
                success = true;&#13;
            }&#13;
        }&#13;
    }&#13;
}&#13;
&#13;
/**&#13;
 * @title SafeMath&#13;
 * @dev Math operations with safety checks that throw on error&#13;
 */&#13;
library SafeMath {&#13;
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
        assert(b &lt;= a);&#13;
        return a - b;&#13;
    }&#13;
    function add(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
        uint256 c = a + b;&#13;
        assert(c &gt;= a);&#13;
        return c;&#13;
    }&#13;
}&#13;
 &#13;
contract StorageMarket  is Whitelist {&#13;
&#13;
  using SafeMath for uint256;&#13;
 &#13;
    // the last cost of a sold seal&#13;
    uint public lastmoney = 0;   &#13;
    uint public lastBunny = 0;   &#13;
    uint public countBunny = 0;   &#13;
&#13;
&#13;
    bool public pause = false; &#13;
&#13;
    // how many a bunny&#13;
    mapping (uint32 =&gt; uint) public bunnyCost;&#13;
&#13;
    event AddCost(uint32 bunnyId, uint money);&#13;
    event DeleteCost(uint32 bunnyId);&#13;
&#13;
    function setPause() public onlyWhitelisted {&#13;
        pause = !pause;&#13;
    }&#13;
&#13;
    function isPauseSave() public  view returns(bool){&#13;
        return !pause;&#13;
    }&#13;
&#13;
&#13;
    function setBunnyCost(uint32 _bunnyID, uint _money) external onlyWhitelisted {&#13;
        require(isPauseSave());&#13;
        lastmoney = _money;   &#13;
        lastBunny = _bunnyID;  &#13;
        bunnyCost[_bunnyID] = _money;&#13;
        if (bunnyCost[_bunnyID] == 0) { &#13;
            countBunny = countBunny.add(1);&#13;
        }&#13;
        emit AddCost(_bunnyID, _money);&#13;
    }&#13;
    &#13;
    function getBunnyCost(uint32 _bunnyID) public view returns (uint money) {&#13;
        return bunnyCost[_bunnyID];&#13;
    }&#13;
&#13;
    function deleteBunnyCost(uint32 _bunnyID) external onlyWhitelisted { &#13;
        require(isPauseSave()); &#13;
        bunnyCost[_bunnyID] = 0;&#13;
        if (bunnyCost[_bunnyID] != 0) { &#13;
            countBunny = countBunny.sub(1);&#13;
            emit DeleteCost(_bunnyID); &#13;
        }&#13;
    }&#13;
 &#13;
}