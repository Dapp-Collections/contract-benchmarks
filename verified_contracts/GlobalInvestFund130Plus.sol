pragma solidity 0.4.25;

/*
 *  GLOBAL  INVEST FUND PROJECT 130+
 * Web:         http://Globalinvest.fund 
 * Twitter:     https://twitter.com/InvestFund_twit?lang=ru 
 * Telegram:    https://telegram.me/GIFund_Chat
 * Iinstagram:  https://www.instagram.com/globalinvestfund/
 * Email:       <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="11767d7e73707d737d7e727a727970787f77647f7551767c70787d3f727e7c">[email protected]</a>  &#13;
 * &#13;
 * &#13;
 *  About the Project&#13;
 * Blockchain-enabled smart contracts have opened a new era of trustless relationships without   intermediaries. &#13;
 * This technology opens incredible financial possibilities. &#13;
 * Our automated investment  distribution model is written into a smart contract, uploaded to the Ethereum    blockchain and can be  freely accessed online.&#13;
 * In order to insure our investors' complete security, full control over the  project has been transferred from the organizers to the smart contract: nobody can influence the  system's permanent autonomous functioning.&#13;
 */&#13;
&#13;
/**&#13;
 * @title SafeMath&#13;
 * @dev Math operations with safety checks that revert on error&#13;
 */&#13;
library SafeMath {&#13;
&#13;
    /**&#13;
    * @dev Multiplies two numbers, reverts on overflow.&#13;
    */&#13;
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the&#13;
        // benefit is lost if 'b' is also tested.&#13;
        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522&#13;
        if (a == 0) {&#13;
            return 0;&#13;
        }&#13;
&#13;
        uint256 c = a * b;&#13;
        require(c / a == b);&#13;
&#13;
        return c;&#13;
    }&#13;
&#13;
    /**&#13;
    * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.&#13;
    */&#13;
    function div(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
        require(b &gt; 0); // Solidity only automatically asserts when dividing by 0&#13;
        uint256 c = a / b;&#13;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold&#13;
&#13;
        return c;&#13;
    }&#13;
&#13;
    /**&#13;
    * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).&#13;
    */&#13;
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
        require(b &lt;= a);&#13;
        uint256 c = a - b;&#13;
&#13;
        return c;&#13;
    }&#13;
&#13;
    /**&#13;
    * @dev Adds two numbers, reverts on overflow.&#13;
    */&#13;
    function add(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
        uint256 c = a + b;&#13;
        require(c &gt;= a);&#13;
&#13;
        return c;&#13;
    }&#13;
&#13;
    /**&#13;
    * @dev Divides two numbers and returns the remainder (unsigned integer modulo),&#13;
    * reverts when dividing by zero.&#13;
    */&#13;
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
        require(b != 0);&#13;
        return a % b;&#13;
    }&#13;
}&#13;
&#13;
library Address {&#13;
    function toAddress(bytes source) internal pure returns(address addr) {&#13;
        assembly { addr := mload(add(source,0x14)) }&#13;
        return addr;&#13;
    }&#13;
}&#13;
&#13;
&#13;
/**&#13;
 * @title Helps contracts guard against reentrancy attacks.&#13;
 * @author Remco Bloemen &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="1c6e79717f735c2e">[email protected]</a>π.com&gt;, Eenae &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="650409001d001c25080c1d071c1100164b0c0a">[email protected]</a>&gt;&#13;
 * @dev If you mark a function `nonReentrant`, you should also&#13;
 * mark it `external`.&#13;
 */&#13;
contract ReentrancyGuard {&#13;
&#13;
    /// @dev counter to allow mutex lock with only one SSTORE operation&#13;
    uint256 private _guardCounter;&#13;
&#13;
    constructor() internal {&#13;
        // The counter starts at one to prevent changing it from zero to a non-zero&#13;
        // value, which is a more expensive operation.&#13;
        _guardCounter = 1;&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Prevents a contract from calling itself, directly or indirectly.&#13;
     * Calling a `nonReentrant` function from another `nonReentrant`&#13;
     * function is not supported. It is possible to prevent this from happening&#13;
     * by making the `nonReentrant` function external, and make it call a&#13;
     * `private` function that does the actual work.&#13;
     */&#13;
    modifier nonReentrant() {&#13;
        _guardCounter += 1;&#13;
        uint256 localCounter = _guardCounter;&#13;
        _;&#13;
        require(localCounter == _guardCounter);&#13;
    }&#13;
&#13;
}&#13;
&#13;
&#13;
contract GlobalInvestFund130Plus is ReentrancyGuard {&#13;
&#13;
    using SafeMath for uint;&#13;
    using Address for *;&#13;
&#13;
    address public marketingAddress;&#13;
    address public techSupportAddress;&#13;
    uint public creationDate;&#13;
    uint constant twoWeeks = 14 days;&#13;
    uint constant oneDay = 1 days;&#13;
    uint constant minInvestment = 100000000000000000 wei;&#13;
    uint constant maxInvestment = 100 ether;&#13;
&#13;
    struct Investor {&#13;
        uint fullInvestment;&#13;
        uint[] eachInvestmentValues;&#13;
        mapping (uint =&gt; uint) timestampsForInvestments;&#13;
        bool isInvestor;&#13;
        bool isLast;&#13;
        bool emergencyAvailable;&#13;
        bool withdrawn;&#13;
    }&#13;
&#13;
    address[] public allInvestors;&#13;
    mapping (address =&gt; Investor) investors;&#13;
    mapping (address =&gt; uint) public sendedDividends;&#13;
    mapping (address =&gt; uint) public refferalDividends;&#13;
    mapping (address =&gt; uint[]) doublePercentsEnd;&#13;
    mapping (address =&gt; uint) lastWithdraw;&#13;
&#13;
    event Invest(address _address, uint _value);&#13;
    event Withdraw(address _address, uint _value);&#13;
&#13;
    modifier onlyInRangeDeposit() {&#13;
        require(msg.value &gt;= minInvestment &amp;&amp; msg.value &lt;= maxInvestment);&#13;
        _;&#13;
    }&#13;
&#13;
    modifier onlyInvestor() {&#13;
        require(investors[msg.sender].isInvestor &amp;&amp; investors[msg.sender].fullInvestment &gt; 0);&#13;
        _;&#13;
    }&#13;
&#13;
    function() external payable {&#13;
        if(msg.value &gt;= minInvestment &amp;&amp; msg.value &lt;= maxInvestment){&#13;
            deposit(msg.data.toAddress());&#13;
        } else {&#13;
            if(msg.value == 112000000000000){&#13;
                emergencyWithdraw();&#13;
            } else {&#13;
                if(msg.value == 0){&#13;
                    withdraw();&#13;
                }&#13;
            }&#13;
        }&#13;
    }&#13;
&#13;
    constructor(address _marketingAddress, address _techSupportAddress) public {&#13;
        creationDate = block.timestamp;&#13;
        marketingAddress = _marketingAddress;&#13;
        techSupportAddress = _techSupportAddress;&#13;
    }&#13;
&#13;
    function getDepositAmountFor(address _addr) public view returns(uint){&#13;
        return investors[_addr].fullInvestment;&#13;
    }&#13;
&#13;
    function calculatePercentsFor(address _addr) external view returns(uint){&#13;
        return calculatePercents(_addr);&#13;
    }&#13;
    &#13;
    function getInvestorsAmount() external view returns(uint){&#13;
        return allInvestors.length;&#13;
    }&#13;
&#13;
    function deposit(address _refferal) public payable onlyInRangeDeposit {&#13;
&#13;
        uint investmentValue = msg.value;&#13;
&#13;
        investmentValue = investmentValue.sub(msg.value.mul(2).div(100));&#13;
        techSupportAddress.transfer(msg.value.mul(2).div(100));&#13;
&#13;
        investmentValue = investmentValue.sub(msg.value.mul(5).div(100));&#13;
        marketingAddress.transfer(msg.value.mul(5).div(100));&#13;
&#13;
        // if refferal address is not investor or if it's myself, fine&#13;
        if(!investors[_refferal].isInvestor || _refferal == msg.sender){&#13;
            marketingAddress.transfer(msg.value.mul(2).div(100));&#13;
            investmentValue = investmentValue.sub(msg.value.mul(2).div(100));&#13;
        } else {&#13;
            _refferal.transfer(msg.value.mul(2).div(100));&#13;
            refferalDividends[_refferal] = refferalDividends[_refferal].add(msg.value.mul(2).div(100));&#13;
            investmentValue = investmentValue.sub(msg.value.mul(2).div(100));&#13;
        }&#13;
&#13;
        // if first investment or investment after emergenct withdraw&#13;
        if(!investors[msg.sender].isInvestor){&#13;
            allInvestors.push(msg.sender);&#13;
            investors[msg.sender].isInvestor = true;&#13;
            investors[msg.sender].isLast = true;&#13;
            if(allInvestors.length &gt; 3) {&#13;
                doublePercentsEnd[allInvestors[allInvestors.length.sub(4)]].push(block.timestamp);&#13;
                investors[allInvestors[allInvestors.length.sub(4)]].isLast = false;&#13;
            }&#13;
        }&#13;
&#13;
        investors[msg.sender].emergencyAvailable = true;&#13;
        investors[msg.sender].fullInvestment = investors[msg.sender].fullInvestment.add(investmentValue);&#13;
        investors[msg.sender].timestampsForInvestments[investors[msg.sender].eachInvestmentValues.length] = block.timestamp;&#13;
        investors[msg.sender].eachInvestmentValues.push(investmentValue);&#13;
&#13;
        // if investor is not one of the 3 last investors&#13;
        if(!investors[msg.sender].isLast){&#13;
            allInvestors.push(msg.sender);&#13;
            investors[msg.sender].isLast = true;&#13;
            if(allInvestors.length &gt; 3) {&#13;
                doublePercentsEnd[allInvestors[allInvestors.length.sub(4)]].push(block.timestamp);&#13;
                investors[allInvestors[allInvestors.length.sub(4)]].isLast = false;&#13;
            }&#13;
        }&#13;
&#13;
        emit Invest(msg.sender, investmentValue);&#13;
    }&#13;
&#13;
    function withdraw() public nonReentrant onlyInvestor {&#13;
        require(creationDate.add(twoWeeks)&lt;=block.timestamp);&#13;
        require(lastWithdraw[msg.sender].add(3 days) &lt;= block.timestamp);&#13;
        require(address(this).balance &gt; 0);&#13;
&#13;
        uint fullDividends;&#13;
        uint marketingFee;&#13;
&#13;
        investors[msg.sender].emergencyAvailable = false;&#13;
        address receiver = msg.sender;&#13;
&#13;
        fullDividends = calculatePercents(msg.sender);&#13;
        fullDividends = fullDividends.sub(sendedDividends[receiver]);&#13;
&#13;
        if(fullDividends &lt; investors[msg.sender].fullInvestment.mul(130).div(100)){&#13;
            marketingFee = fullDividends.mul(5).div(100);&#13;
            marketingAddress.transfer(marketingFee);&#13;
        }&#13;
&#13;
        lastWithdraw[msg.sender] = block.timestamp;&#13;
        &#13;
        if(address(this).balance &gt;= fullDividends.sub(marketingFee)) {&#13;
            receiver.transfer(fullDividends.sub(marketingFee));&#13;
        } else{&#13;
            receiver.transfer(address(this).balance);&#13;
        }&#13;
&#13;
        sendedDividends[receiver] = sendedDividends[receiver].add(fullDividends);&#13;
        investors[receiver].withdrawn = true;&#13;
&#13;
&#13;
        emit Withdraw(receiver, fullDividends);&#13;
    }&#13;
&#13;
    function calculatePercents(address _for) internal view returns(uint){&#13;
        uint dividends;&#13;
        uint fullDividends;&#13;
        uint count = 0;&#13;
        for(uint i = 1; i &lt;= investors[_for].eachInvestmentValues.length; i++) {&#13;
            if(i == investors[_for].eachInvestmentValues.length){&#13;
                if(doublePercentsEnd[_for].length &gt; count &amp;&amp; doublePercentsEnd[_for][count] &lt; block.timestamp){&#13;
                    dividends = getDividendsForOnePeriod(investors[_for].timestampsForInvestments[i.sub(1)], block.timestamp, investors[_for].eachInvestmentValues[i.sub(1)], doublePercentsEnd[_for][count++]);&#13;
                }&#13;
                else{&#13;
                    dividends = getDividendsForOnePeriod(investors[_for].timestampsForInvestments[i.sub(1)], block.timestamp, investors[_for].eachInvestmentValues[i.sub(1)], 0);&#13;
                }&#13;
&#13;
            } else {&#13;
                if(doublePercentsEnd[_for].length &gt; count &amp;&amp; doublePercentsEnd[_for][count] &lt; investors[_for].timestampsForInvestments[i]){&#13;
                    dividends = getDividendsForOnePeriod(investors[_for].timestampsForInvestments[i.sub(1)], investors[_for].timestampsForInvestments[i], investors[_for].eachInvestmentValues[i.sub(1)], doublePercentsEnd[_for][count++]);&#13;
                }&#13;
                else {&#13;
                    dividends = getDividendsForOnePeriod(investors[_for].timestampsForInvestments[i.sub(1)], investors[_for].timestampsForInvestments[i], investors[_for].eachInvestmentValues[i.sub(1)], 0);&#13;
                }&#13;
&#13;
            }&#13;
            fullDividends = fullDividends.add(dividends);&#13;
        }&#13;
        return fullDividends;&#13;
    }&#13;
&#13;
    function getDividendsForOnePeriod(uint _startTime, uint _endTime, uint _investmentValue, uint _doublePercentsEnd) internal view returns(uint) {&#13;
        uint fullDaysForDividents = _endTime.sub(_startTime).div(oneDay);&#13;
        uint maxDividends = investors[msg.sender].fullInvestment.mul(130).div(100);&#13;
        uint maxDaysWithFullDividends = maxDividends.div(_investmentValue.mul(35).div(1000));&#13;
        uint maxDaysWithDoubleDividends = maxDividends.div(_investmentValue.mul(7).div(100));&#13;
        uint daysWithDoublePercents;&#13;
&#13;
        if(_doublePercentsEnd != 0){&#13;
            daysWithDoublePercents = _doublePercentsEnd.sub(_startTime).div(oneDay);&#13;
        } else {&#13;
            daysWithDoublePercents = fullDaysForDividents;&#13;
        }&#13;
&#13;
        uint dividends;&#13;
&#13;
        if(daysWithDoublePercents &gt; maxDaysWithDoubleDividends &amp;&amp; !investors[msg.sender].withdrawn){&#13;
            dividends = _investmentValue.mul(7).div(100).mul(maxDaysWithDoubleDividends);&#13;
            dividends = dividends.add(_investmentValue.div(100).mul(daysWithDoublePercents.sub(maxDaysWithDoubleDividends)));&#13;
            return dividends;&#13;
        } else {&#13;
            if(daysWithDoublePercents &gt; maxDaysWithDoubleDividends){&#13;
                dividends = _investmentValue.mul(7).div(100).mul(maxDaysWithDoubleDividends);&#13;
            } else {&#13;
                dividends = _investmentValue.mul(7).div(100).mul(daysWithDoublePercents);&#13;
            }&#13;
            if(fullDaysForDividents != daysWithDoublePercents){&#13;
                fullDaysForDividents = fullDaysForDividents.sub(daysWithDoublePercents);&#13;
            } else {&#13;
                return dividends;&#13;
            }&#13;
&#13;
            maxDividends = maxDividends.sub(dividends);&#13;
            maxDaysWithFullDividends = maxDividends.div(_investmentValue.mul(35).div(1000));&#13;
&#13;
            if(fullDaysForDividents &gt; maxDaysWithFullDividends &amp;&amp; !investors[msg.sender].withdrawn){&#13;
                dividends = dividends.add(_investmentValue.mul(35).div(1000).mul(maxDaysWithFullDividends));&#13;
                dividends = dividends.add(_investmentValue.mul(5).div(1000).mul(fullDaysForDividents.sub(maxDaysWithFullDividends)));&#13;
                return dividends;&#13;
            } else {&#13;
                dividends = dividends.add(_investmentValue.mul(35).div(1000).mul(fullDaysForDividents));&#13;
                return dividends;&#13;
            }&#13;
        }&#13;
    }&#13;
&#13;
    function emergencyWithdraw() public payable nonReentrant onlyInvestor {&#13;
        require(investors[msg.sender].emergencyAvailable == true);&#13;
&#13;
        // send 35% of full investment from this address to the tech support address&#13;
        techSupportAddress.transfer(investors[msg.sender].fullInvestment.mul(35).div(100));&#13;
&#13;
        uint returnValue = investors[msg.sender].fullInvestment.sub(investors[msg.sender].fullInvestment.mul(35).div(100));&#13;
&#13;
        investors[msg.sender].fullInvestment = 0;&#13;
        investors[msg.sender].isInvestor = false;&#13;
&#13;
        if(address(this).balance &gt;= returnValue) {&#13;
            // return remaining investments to the investor&#13;
            msg.sender.transfer(returnValue);&#13;
        } else {&#13;
            // if eth is not enough on the contract return remaining eth of the contract to the investor&#13;
            msg.sender.transfer(address(this).balance);&#13;
        }&#13;
&#13;
&#13;
        for(uint c = 0; c &lt; investors[msg.sender].eachInvestmentValues.length; c++){&#13;
            investors[msg.sender].eachInvestmentValues[c] = 0;&#13;
        }&#13;
&#13;
        if(investors[msg.sender].isLast == true){&#13;
            //DELETE from last investors&#13;
            investors[msg.sender].isLast = false;&#13;
            if(allInvestors.length &gt; 3){&#13;
                for(uint i = allInvestors.length.sub(1); i &gt; allInvestors.length.sub(4); i--){&#13;
                    if(allInvestors[i] == msg.sender){&#13;
                        allInvestors[i] = address(0);&#13;
                    }&#13;
                }&#13;
            } else {&#13;
                for(uint y = 0; y &lt; allInvestors.length.sub(1); y++){&#13;
                    if(allInvestors[y] == msg.sender){&#13;
                        allInvestors[y] = address(0);&#13;
                    }&#13;
                }&#13;
            }&#13;
        }&#13;
    }&#13;
}