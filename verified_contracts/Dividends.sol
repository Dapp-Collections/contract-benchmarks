pragma solidity ^0.4.21;

// Dev fee payout contract + dividend options 
// EtherGuy DApp fee will be stored here 
// Buying any token gives right to claim 
// UI: etherguy.surge.sh/dividend.html
// Made by EtherGuy, <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="f89d8c909d8a9f8d81b895999194d69b9795">[emailÂ protected]</a> &#13;
&#13;
// IF THERE IS ANY BUG the data will be rerolled from here. See the discord https://discord.gg/R84hD6f if anything happens or mail me &#13;
&#13;
&#13;
contract Dividends{&#13;
    // 10 million token supply &#13;
    uint256 constant TokenSupply = 10000000;&#13;
    &#13;
    uint256 public TotalPaid = 0;&#13;
    &#13;
    uint16 public Tax = 1250; &#13;
    &#13;
    address dev;&#13;
    &#13;
    mapping (address =&gt; uint256) public MyTokens;&#13;
    mapping (address =&gt; uint256) public DividendCollectSince;&#13;
    &#13;
    // TKNS / PRICE &#13;
    mapping(address =&gt; uint256[2]) public SellOrder;&#13;
    &#13;
    // web &#13;
    // returns tokens + price (in wei)&#13;
    function GetSellOrderDetails(address who) public view returns (uint256, uint256){&#13;
        return (SellOrder[who][0], SellOrder[who][1]);&#13;
    }&#13;
    &#13;
    function ViewMyTokens(address who) public view returns (uint256){&#13;
        return MyTokens[who];&#13;
    }&#13;
    &#13;
    function ViewMyDivs(address who) public view returns (uint256){&#13;
        uint256 tkns = MyTokens[who];&#13;
        if (tkns==0){&#13;
            return 0;&#13;
        }&#13;
        return (GetDividends(who, tkns));&#13;
    }&#13;
    &#13;
    function Bal() public view returns (uint256){&#13;
        return (address(this).balance);&#13;
    }&#13;
    &#13;
    // &gt;MINT IT&#13;
    function Dividends() public {&#13;
        dev = msg.sender;&#13;
        // EG&#13;
        MyTokens[msg.sender] = TokenSupply - 400000;&#13;
        // HE&#13;
        MyTokens[address(0x83c0Efc6d8B16D87BFe1335AB6BcAb3Ed3960285)] = 200000;&#13;
        // PG&#13;
        MyTokens[address(0x26581d1983ced8955C170eB4d3222DCd3845a092)] = 200000;&#13;
        //MyTokens[address(0x0)] = 400000;&#13;
        PlaceSellOrder(1600000, (0.5 szabo)); // 1 token per 0.5 szabo / 500 gwei or 1000 tokens per 0.5 finney / 0.0005 ether or 1M tokens per 0.5 ETH &#13;
    }&#13;
    &#13;
    function GetDividends(address who, uint256 TokenAmount) internal view  returns(uint256){&#13;
        if (TokenAmount == 0){&#13;
            return 0;&#13;
        }&#13;
        uint256 TotalContractIn = address(this).balance + TotalPaid;&#13;
        // division rounds DOWN so we never pay too much&#13;
        // no revert errors due to this. &#13;
        &#13;
        uint256 MyBalance = sub(TotalContractIn, DividendCollectSince[who]);&#13;
        &#13;
        return  ((MyBalance * TokenAmount) / (TokenSupply));&#13;
    }&#13;
    &#13;
&#13;
    event Sold(address Buyer, address Seller, uint256 price, uint256 tokens);&#13;
    function Buy(address who) public payable {&#13;
       // require(msg.value &gt;= (1 szabo)); // normal amounts pls &#13;
        // lookup order by addr &#13;
        uint256[2] memory order = SellOrder[who];&#13;
        uint256 amt_available = order[0];&#13;
        uint256 price = order[1];&#13;
        &#13;
        uint256 excess = 0;&#13;
        &#13;
        // nothing to sell &#13;
        if (amt_available == 0){&#13;
            revert();&#13;
        }&#13;
        &#13;
        uint256 max = amt_available * price; &#13;
        uint256 currval = msg.value;&#13;
        // more than max buy value &#13;
        if (currval &gt; max){&#13;
            excess = (currval-max);&#13;
            currval = max;&#13;
        }&#13;
        &#13;
&#13;
&#13;
&#13;
        uint256 take = currval / price;&#13;
        &#13;
        if (take == 0){&#13;
            revert(); // very high price apparently &#13;
        }&#13;
        excess = excess + sub(currval, take * price); &#13;
&#13;
        &#13;
        if (excess &gt; 0){&#13;
            msg.sender.transfer(excess);&#13;
        }&#13;
        &#13;
        currval = sub(currval,excess);&#13;
        &#13;
        // pay fees &#13;
&#13;
        uint256 fee = (Tax * currval)/10000;&#13;
        dev.transfer(fee);&#13;
        who.transfer(currval-fee);&#13;
        &#13;
        // the person with these tokens will also receive dividend over this buy order (this.balance)&#13;
        // however the excess is removed, see the excess transfer above &#13;
     //   if (msg.value &gt; (excess+currval+fee)){&#13;
      //      msg.sender.transfer(msg.value-excess-currval-fee);&#13;
     //   }&#13;
        _withdraw(who, MyTokens[who]);&#13;
        if (MyTokens[msg.sender] &gt; 0){&#13;
            &#13;
            _withdraw(msg.sender, MyTokens[msg.sender]);&#13;
        }&#13;
        MyTokens[who] = MyTokens[who] - take; &#13;
        SellOrder[who][0] = SellOrder[who][0]-take; &#13;
        MyTokens[msg.sender] = MyTokens[msg.sender] + take;&#13;
    //    MyPayouts[msg.sender] = MyPayouts[msg.sender] + GetDividends(msg.sender, take);&#13;
        DividendCollectSince[msg.sender] = (address(this).balance) + TotalPaid;&#13;
        &#13;
        emit Sold(msg.sender, who, price, take);&#13;
       // push((excess + currval)/(1 finney), (msg.value)/(1 finney));&#13;
    }&#13;
    &#13;
    function Withdraw() public {&#13;
        _withdraw(msg.sender, MyTokens[msg.sender]);&#13;
    }&#13;
    &#13;
    function _withdraw(address who, uint256 amt) internal{&#13;
        // withdraws from amt. &#13;
        // (amt not used in current code, always same value)&#13;
        if (MyTokens[who] &lt; amt){&#13;
            revert(); // ??? security check &#13;
        }&#13;
        &#13;
        uint256 divs = GetDividends(who, amt);&#13;
        &#13;
        who.transfer(divs);&#13;
        TotalPaid = TotalPaid + divs;&#13;
        &#13;
        DividendCollectSince[who] = TotalPaid + address(this).balance;&#13;
    }&#13;
    &#13;
    event SellOrderPlaced(address who, uint256 amt, uint256 price);&#13;
    function PlaceSellOrder(uint256 amt, uint256 price) public {&#13;
        // replaces old order &#13;
        if (amt &gt; MyTokens[msg.sender]){&#13;
            revert(); // ?? more sell than you got &#13;
        }&#13;
        SellOrder[msg.sender] = [amt,price];&#13;
        emit SellOrderPlaced(msg.sender, amt, price);&#13;
    }&#13;
    &#13;
    function ChangeTax(uint16 amt) public {&#13;
        require (amt &lt;= 2500);&#13;
        require(msg.sender == dev);&#13;
        Tax=amt;&#13;
    }&#13;
    &#13;
    &#13;
    // dump divs in contract &#13;
    function() public payable {&#13;
        &#13;
    }&#13;
    &#13;
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
        assert(b &lt;= a);&#13;
        return a - b;&#13;
    } &#13;
    &#13;
}