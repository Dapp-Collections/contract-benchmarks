pragma solidity ^0.4.15;

/**
 * @title Ownable
 * @dev The Ownable contract has an owner address, and provides basic authorization control
 * functions, this simplifies the implementation of "user permissions".
 */
contract Ownable {
    address public owner;


    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);


    /**
     * @dev The Ownable constructor sets the original `owner` of the contract to the sender
     * account.
     */
    function Ownable() {
        owner = msg.sender;
    }


    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }


    /**
     * @dev Allows the current owner to transfer control of the contract to a newOwner.
     * @param newOwner The address to transfer ownership to.
     */
    function transferOwnership(address newOwner) onlyOwner public {
        require(newOwner != address(0));
        OwnershipTransferred(owner, newOwner);
        owner = newOwner;
    }

}

/**
 * @title Contracts that should not own Ether
 * @author Remco Bloemen <<span class="__cf_email__" data-cfemail="295b4c444a46691b">[email protected]</span>π.com&gt;&#13;
 * @dev This tries to block incoming ether to prevent accidental loss of Ether. Should Ether end up&#13;
 * in the contract, it will allow the owner to reclaim this ether.&#13;
 * @notice Ether can still be send to this contract by:&#13;
 * calling functions labeled `payable`&#13;
 * `selfdestruct(contract_address)`&#13;
 * mining directly to the contract address&#13;
*/&#13;
contract HasNoEther is Ownable {&#13;
&#13;
    /**&#13;
    * @dev Constructor that rejects incoming Ether&#13;
    * @dev The `payable` flag is added so we can access `msg.value` without compiler warning. If we&#13;
    * leave out payable, then Solidity will allow inheriting contracts to implement a payable&#13;
    * constructor. By doing it this way we prevent a payable constructor from working. Alternatively&#13;
    * we could use assembly to access msg.value.&#13;
    */&#13;
    function HasNoEther() payable {&#13;
        require(msg.value == 0);&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Disallows direct send by settings a default function without the `payable` flag.&#13;
     */&#13;
    function() external {&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Transfer all Ether held by the contract to the owner.&#13;
     */&#13;
    function reclaimEther() external onlyOwner {&#13;
        assert(owner.send(this.balance));&#13;
    }&#13;
}&#13;
&#13;
/**&#13;
 * @title SafeMath&#13;
 * @dev Math operations with safety checks that throw on error&#13;
 */&#13;
library SafeMath {&#13;
    function mul(uint256 a, uint256 b) internal constant returns (uint256) {&#13;
        uint256 c = a * b;&#13;
        assert(a == 0 || c / a == b);&#13;
        return c;&#13;
    }&#13;
&#13;
    function div(uint256 a, uint256 b) internal constant returns (uint256) {&#13;
        // assert(b &gt; 0); // Solidity automatically throws when dividing by 0&#13;
        uint256 c = a / b;&#13;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold&#13;
        return c;&#13;
    }&#13;
&#13;
    function sub(uint256 a, uint256 b) internal constant returns (uint256) {&#13;
        assert(b &lt;= a);&#13;
        return a - b;&#13;
    }&#13;
&#13;
    function add(uint256 a, uint256 b) internal constant returns (uint256) {&#13;
        uint256 c = a + b;&#13;
        assert(c &gt;= a);&#13;
        return c;&#13;
    }&#13;
}&#13;
&#13;
/**&#13;
 * Fixed crowdsale pricing - everybody gets the same price.&#13;
 */&#13;
contract PricingStrategy is HasNoEther {&#13;
    using SafeMath for uint;&#13;
&#13;
    /* How many weis one token costs */&#13;
    uint256 public oneTokenInWei;&#13;
&#13;
    address public crowdsaleAddress;&#13;
&#13;
    function PricingStrategy(address _crowdsale) {&#13;
        crowdsaleAddress = _crowdsale;&#13;
    }&#13;
&#13;
    modifier onlyCrowdsale() {&#13;
        require(msg.sender == crowdsaleAddress);&#13;
        _;&#13;
    }&#13;
&#13;
    /**&#13;
     * Calculate the current price for buy in amount.&#13;
     *&#13;
     */&#13;
    function calculatePrice(uint256 _value, uint256 _decimals) public constant returns (uint) {&#13;
        uint256 multiplier = 10 ** _decimals;&#13;
        uint256 weiAmount = _value.mul(multiplier);&#13;
        uint256 tokens = weiAmount.div(oneTokenInWei);&#13;
        return tokens;&#13;
    }&#13;
&#13;
    function setTokenPriceInWei(uint _oneTokenInWei) onlyCrowdsale public returns (bool) {&#13;
        oneTokenInWei = _oneTokenInWei;&#13;
        return true;&#13;
    }&#13;
}&#13;
&#13;
/**&#13;
 * @title Pausable&#13;
 * @dev Base contract which allows children to implement an emergency stop mechanism.&#13;
 */&#13;
contract Pausable is Ownable {&#13;
    event Pause();&#13;
    event Unpause();&#13;
&#13;
    bool public paused = false;&#13;
&#13;
&#13;
    /**&#13;
     * @dev Modifier to make a function callable only when the contract is not paused.&#13;
     */&#13;
    modifier whenNotPaused() {&#13;
        require(!paused);&#13;
        _;&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Modifier to make a function callable only when the contract is paused.&#13;
     */&#13;
    modifier whenPaused() {&#13;
        require(paused);&#13;
        _;&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev called by the owner to pause, triggers stopped state&#13;
     */&#13;
    function pause() onlyOwner whenNotPaused public {&#13;
        paused = true;&#13;
        Pause();&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev called by the owner to unpause, returns to normal state&#13;
     */&#13;
    function unpause() onlyOwner whenPaused public {&#13;
        paused = false;&#13;
        Unpause();&#13;
    }&#13;
}&#13;
&#13;
contract RNTMultiSigWallet {&#13;
    /*&#13;
     *  Events&#13;
     */&#13;
    event Confirmation(address indexed sender, uint indexed transactionId);&#13;
&#13;
    event Revocation(address indexed sender, uint indexed transactionId);&#13;
&#13;
    event Submission(uint indexed transactionId);&#13;
&#13;
    event Execution(uint indexed transactionId);&#13;
&#13;
    event ExecutionFailure(uint indexed transactionId);&#13;
&#13;
    event Deposit(address indexed sender, uint value);&#13;
&#13;
    event OwnerAddition(address indexed owner);&#13;
&#13;
    event OwnerRemoval(address indexed owner);&#13;
&#13;
    event RequirementChange(uint required);&#13;
&#13;
    event Pause();&#13;
&#13;
    event Unpause();&#13;
&#13;
    /*&#13;
     *  Constants&#13;
     */&#13;
    uint constant public MAX_OWNER_COUNT = 10;&#13;
&#13;
    uint constant public ADMINS_COUNT = 2;&#13;
&#13;
    /*&#13;
     *  Storage&#13;
     */&#13;
    mapping(uint =&gt; WalletTransaction) public transactions;&#13;
&#13;
    mapping(uint =&gt; mapping(address =&gt; bool)) public confirmations;&#13;
&#13;
    mapping(address =&gt; bool) public isOwner;&#13;
&#13;
    mapping(address =&gt; bool) public isAdmin;&#13;
&#13;
    address[] public owners;&#13;
&#13;
    address[] public admins;&#13;
&#13;
    uint public required;&#13;
&#13;
    uint public transactionCount;&#13;
&#13;
    bool public paused = false;&#13;
&#13;
    struct WalletTransaction {&#13;
        address sender;&#13;
        address destination;&#13;
        uint value;&#13;
        bytes data;&#13;
        bool executed;&#13;
    }&#13;
&#13;
    /*&#13;
     *  Modifiers&#13;
     */&#13;
&#13;
    /// @dev Modifier to make a function callable only when the contract is not paused.&#13;
    modifier whenNotPaused() {&#13;
        require(!paused);&#13;
        _;&#13;
    }&#13;
&#13;
    /// @dev Modifier to make a function callable only when the contract is paused.&#13;
    modifier whenPaused() {&#13;
        require(paused);&#13;
        _;&#13;
    }&#13;
&#13;
    modifier onlyWallet() {&#13;
        require(msg.sender == address(this));&#13;
        _;&#13;
    }&#13;
&#13;
    modifier ownerDoesNotExist(address owner) {&#13;
        require(!isOwner[owner]);&#13;
        _;&#13;
    }&#13;
&#13;
    modifier ownerExists(address owner) {&#13;
        require(isOwner[owner]);&#13;
        _;&#13;
    }&#13;
&#13;
    modifier adminExists(address admin) {&#13;
        require(isAdmin[admin]);&#13;
        _;&#13;
    }&#13;
&#13;
    modifier adminDoesNotExist(address admin) {&#13;
        require(!isAdmin[admin]);&#13;
        _;&#13;
    }&#13;
&#13;
    modifier transactionExists(uint transactionId) {&#13;
        require(transactions[transactionId].destination != 0);&#13;
        _;&#13;
    }&#13;
&#13;
    modifier confirmed(uint transactionId, address owner) {&#13;
        require(confirmations[transactionId][owner]);&#13;
        _;&#13;
    }&#13;
&#13;
    modifier notConfirmed(uint transactionId, address owner) {&#13;
        require(!confirmations[transactionId][owner]);&#13;
        _;&#13;
    }&#13;
&#13;
    modifier notExecuted(uint transactionId) {&#13;
        if (transactions[transactionId].executed)&#13;
            require(false);&#13;
        _;&#13;
    }&#13;
&#13;
    modifier notNull(address _address) {&#13;
        require(_address != 0);&#13;
        _;&#13;
    }&#13;
&#13;
    modifier validRequirement(uint ownerCount, uint _required) {&#13;
        if (ownerCount &gt; MAX_OWNER_COUNT&#13;
        || _required &gt; ownerCount&#13;
        || _required == 0&#13;
        || ownerCount == 0) {&#13;
            require(false);&#13;
        }&#13;
        _;&#13;
    }&#13;
&#13;
    modifier validAdminsCount(uint adminsCount) {&#13;
        require(adminsCount == ADMINS_COUNT);&#13;
        _;&#13;
    }&#13;
&#13;
    /// @dev Fallback function allows to deposit ether.&#13;
    function()&#13;
    whenNotPaused&#13;
    payable&#13;
    {&#13;
        if (msg.value &gt; 0)&#13;
            Deposit(msg.sender, msg.value);&#13;
    }&#13;
&#13;
    /*&#13;
     * Public functions&#13;
     */&#13;
    /// @dev Contract constructor sets initial admins and required number of confirmations.&#13;
    /// @param _admins List of initial owners.&#13;
    /// @param _required Number of required confirmations.&#13;
    function RNTMultiSigWallet(address[] _admins, uint _required)&#13;
    public&#13;
        //    validAdminsCount(_admins.length)&#13;
        //    validRequirement(_admins.length, _required)&#13;
    {&#13;
        for (uint i = 0; i &lt; _admins.length; i++) {&#13;
            require(_admins[i] != 0 &amp;&amp; !isOwner[_admins[i]] &amp;&amp; !isAdmin[_admins[i]]);&#13;
            isAdmin[_admins[i]] = true;&#13;
            isOwner[_admins[i]] = true;&#13;
        }&#13;
&#13;
        admins = _admins;&#13;
        owners = _admins;&#13;
        required = _required;&#13;
    }&#13;
&#13;
    /// @dev called by the owner to pause, triggers stopped state&#13;
    function pause() adminExists(msg.sender) whenNotPaused public {&#13;
        paused = true;&#13;
        Pause();&#13;
    }&#13;
&#13;
    /// @dev called by the owner to unpause, returns to normal state&#13;
    function unpause() adminExists(msg.sender) whenPaused public {&#13;
        paused = false;&#13;
        Unpause();&#13;
    }&#13;
&#13;
    /// @dev Allows to add a new owner. Transaction has to be sent by wallet.&#13;
    /// @param owner Address of new owner.&#13;
    function addOwner(address owner)&#13;
    public&#13;
    whenNotPaused&#13;
    adminExists(msg.sender)&#13;
    ownerDoesNotExist(owner)&#13;
    notNull(owner)&#13;
    validRequirement(owners.length + 1, required)&#13;
    {&#13;
        isOwner[owner] = true;&#13;
        owners.push(owner);&#13;
        OwnerAddition(owner);&#13;
    }&#13;
&#13;
    /// @dev Allows to remove an owner. Transaction has to be sent by wallet.&#13;
    /// @param owner Address of owner.&#13;
    function removeOwner(address owner)&#13;
    public&#13;
    whenNotPaused&#13;
    adminExists(msg.sender)&#13;
    adminDoesNotExist(owner)&#13;
    ownerExists(owner)&#13;
    {&#13;
        isOwner[owner] = false;&#13;
        for (uint i = 0; i &lt; owners.length - 1; i++)&#13;
            if (owners[i] == owner) {&#13;
                owners[i] = owners[owners.length - 1];&#13;
                break;&#13;
            }&#13;
        owners.length -= 1;&#13;
        if (required &gt; owners.length)&#13;
            changeRequirement(owners.length);&#13;
        OwnerRemoval(owner);&#13;
    }&#13;
&#13;
    /// @dev Allows to replace an owner with a new owner. Transaction has to be sent by wallet.&#13;
    /// @param owner Address of owner to be replaced.&#13;
    /// @param newOwner Address of new owner.&#13;
    function replaceOwner(address owner, address newOwner)&#13;
    public&#13;
    whenNotPaused&#13;
    adminExists(msg.sender)&#13;
    adminDoesNotExist(owner)&#13;
    ownerExists(owner)&#13;
    ownerDoesNotExist(newOwner)&#13;
    {&#13;
        for (uint i = 0; i &lt; owners.length; i++)&#13;
            if (owners[i] == owner) {&#13;
                owners[i] = newOwner;&#13;
                break;&#13;
            }&#13;
        isOwner[owner] = false;&#13;
        isOwner[newOwner] = true;&#13;
        OwnerRemoval(owner);&#13;
        OwnerAddition(newOwner);&#13;
    }&#13;
&#13;
    /// @dev Allows to change the number of required confirmations. Transaction has to be sent by wallet.&#13;
    /// @param _required Number of required confirmations.&#13;
    function changeRequirement(uint _required)&#13;
    public&#13;
    whenNotPaused&#13;
    adminExists(msg.sender)&#13;
    validRequirement(owners.length, _required)&#13;
    {&#13;
        required = _required;&#13;
        RequirementChange(_required);&#13;
    }&#13;
&#13;
    /// @dev Allows an owner to submit and confirm a transaction.&#13;
    /// @param destination Transaction target address.&#13;
    /// @param value Transaction ether value.&#13;
    /// @param data Transaction data payload.&#13;
    /// @return Returns transaction ID.&#13;
    function submitTransaction(address destination, uint value, bytes data)&#13;
    public&#13;
    whenNotPaused&#13;
    ownerExists(msg.sender)&#13;
    returns (uint transactionId)&#13;
    {&#13;
        transactionId = addTransaction(destination, value, data);&#13;
        confirmTransaction(transactionId);&#13;
    }&#13;
&#13;
    /// @dev Allows an owner to confirm a transaction.&#13;
    /// @param transactionId Transaction ID.&#13;
    function confirmTransaction(uint transactionId)&#13;
    public&#13;
    whenNotPaused&#13;
    ownerExists(msg.sender)&#13;
    transactionExists(transactionId)&#13;
    notConfirmed(transactionId, msg.sender)&#13;
    {&#13;
        confirmations[transactionId][msg.sender] = true;&#13;
        Confirmation(msg.sender, transactionId);&#13;
        executeTransaction(transactionId);&#13;
    }&#13;
&#13;
    /// @dev Allows an owner to revoke a confirmation for a transaction.&#13;
    /// @param transactionId Transaction ID.&#13;
    function revokeConfirmation(uint transactionId)&#13;
    public&#13;
    whenNotPaused&#13;
    ownerExists(msg.sender)&#13;
    confirmed(transactionId, msg.sender)&#13;
    notExecuted(transactionId)&#13;
    {&#13;
        confirmations[transactionId][msg.sender] = false;&#13;
        Revocation(msg.sender, transactionId);&#13;
    }&#13;
&#13;
    /// @dev Allows anyone to execute a confirmed transaction.&#13;
    /// @param transactionId Transaction ID.&#13;
    function executeTransaction(uint transactionId)&#13;
    public&#13;
    whenNotPaused&#13;
    ownerExists(msg.sender)&#13;
    confirmed(transactionId, msg.sender)&#13;
    notExecuted(transactionId)&#13;
    {&#13;
        if (isConfirmed(transactionId)) {&#13;
            WalletTransaction storage walletTransaction = transactions[transactionId];&#13;
            walletTransaction.executed = true;&#13;
            if (walletTransaction.destination.call.value(walletTransaction.value)(walletTransaction.data))&#13;
                Execution(transactionId);&#13;
            else {&#13;
                ExecutionFailure(transactionId);&#13;
                walletTransaction.executed = false;&#13;
            }&#13;
        }&#13;
    }&#13;
&#13;
    /// @dev Returns the confirmation status of a transaction.&#13;
    /// @param transactionId Transaction ID.&#13;
    /// @return Confirmation status.&#13;
    function isConfirmed(uint transactionId)&#13;
    public&#13;
    constant&#13;
    returns (bool)&#13;
    {&#13;
        uint count = 0;&#13;
        for (uint i = 0; i &lt; owners.length; i++) {&#13;
            if (confirmations[transactionId][owners[i]])&#13;
                count += 1;&#13;
            if (count == required)&#13;
                return true;&#13;
        }&#13;
    }&#13;
&#13;
    /*&#13;
     * Internal functions&#13;
     */&#13;
    /// @dev Adds a new transaction to the transaction mapping, if transaction does not exist yet.&#13;
    /// @param destination Transaction target address.&#13;
    /// @param value Transaction ether value.&#13;
    /// @param data Transaction data payload.&#13;
    /// @return Returns transaction ID.&#13;
    function addTransaction(address destination, uint value, bytes data)&#13;
    internal&#13;
    notNull(destination)&#13;
    returns (uint transactionId)&#13;
    {&#13;
        transactionId = transactionCount;&#13;
        transactions[transactionId] = WalletTransaction({&#13;
            sender : msg.sender,&#13;
            destination : destination,&#13;
            value : value,&#13;
            data : data,&#13;
            executed : false&#13;
            });&#13;
        transactionCount += 1;&#13;
        Submission(transactionId);&#13;
    }&#13;
&#13;
    /*&#13;
     * Web3 call functions&#13;
     */&#13;
    /// @dev Returns number of confirmations of a transaction.&#13;
    /// @param transactionId Transaction ID.&#13;
    /// @return Number of confirmations.&#13;
    function getConfirmationCount(uint transactionId)&#13;
    public&#13;
    constant&#13;
    returns (uint count)&#13;
    {&#13;
        for (uint i = 0; i &lt; owners.length; i++)&#13;
            if (confirmations[transactionId][owners[i]])&#13;
                count += 1;&#13;
    }&#13;
&#13;
    /// @dev Returns total number of transactions after filers are applied.&#13;
    /// @param pending Include pending transactions.&#13;
    /// @param executed Include executed transactions.&#13;
    /// @return Total number of transactions after filters are applied.&#13;
    function getTransactionCount(bool pending, bool executed)&#13;
    public&#13;
    constant&#13;
    returns (uint count)&#13;
    {&#13;
        for (uint i = 0; i &lt; transactionCount; i++)&#13;
            if (pending &amp;&amp; !transactions[i].executed&#13;
            || executed &amp;&amp; transactions[i].executed)&#13;
                count += 1;&#13;
    }&#13;
&#13;
    /// @dev Returns list of owners.&#13;
    /// @return List of owner addresses.&#13;
    function getOwners()&#13;
    public&#13;
    constant&#13;
    returns (address[])&#13;
    {&#13;
        return owners;&#13;
    }&#13;
&#13;
    // @dev Returns list of admins.&#13;
    // @return List of admin addresses&#13;
    function getAdmins()&#13;
    public&#13;
    constant&#13;
    returns (address[])&#13;
    {&#13;
        return admins;&#13;
    }&#13;
&#13;
    /// @dev Returns array with owner addresses, which confirmed transaction.&#13;
    /// @param transactionId Transaction ID.&#13;
    /// @return Returns array of owner addresses.&#13;
    function getConfirmations(uint transactionId)&#13;
    public&#13;
    constant&#13;
    returns (address[] _confirmations)&#13;
    {&#13;
        address[] memory confirmationsTemp = new address[](owners.length);&#13;
        uint count = 0;&#13;
        uint i;&#13;
        for (i = 0; i &lt; owners.length; i++)&#13;
            if (confirmations[transactionId][owners[i]]) {&#13;
                confirmationsTemp[count] = owners[i];&#13;
                count += 1;&#13;
            }&#13;
        _confirmations = new address[](count);&#13;
        for (i = 0; i &lt; count; i++)&#13;
            _confirmations[i] = confirmationsTemp[i];&#13;
    }&#13;
&#13;
    /// @dev Returns list of transaction IDs in defined range.&#13;
    /// @param from Index start position of transaction array.&#13;
    /// @param to Index end position of transaction array.&#13;
    /// @param pending Include pending transactions.&#13;
    /// @param executed Include executed transactions.&#13;
    /// @return Returns array of transaction IDs.&#13;
    function getTransactionIds(uint from, uint to, bool pending, bool executed)&#13;
    public&#13;
    constant&#13;
    returns (uint[] _transactionIds)&#13;
    {&#13;
        uint[] memory transactionIdsTemp = new uint[](transactionCount);&#13;
        uint count = 0;&#13;
        uint i;&#13;
        for (i = 0; i &lt; transactionCount; i++)&#13;
            if (pending &amp;&amp; !transactions[i].executed&#13;
            || executed &amp;&amp; transactions[i].executed)&#13;
            {&#13;
                transactionIdsTemp[count] = i;&#13;
                count += 1;&#13;
            }&#13;
        _transactionIds = new uint[](to - from);&#13;
        for (i = from; i &lt; to; i++)&#13;
            _transactionIds[i - from] = transactionIdsTemp[i];&#13;
    }&#13;
}&#13;
&#13;
contract RntPresaleEthereumDeposit is Pausable {&#13;
    using SafeMath for uint256;&#13;
&#13;
    uint256 public overallTakenEther = 0;&#13;
&#13;
    mapping(address =&gt; uint256) public receivedEther;&#13;
&#13;
    struct Donator {&#13;
        address addr;&#13;
        uint256 donated;&#13;
    }&#13;
&#13;
    Donator[] donators;&#13;
&#13;
    RNTMultiSigWallet public wallet;&#13;
&#13;
    function RntPresaleEthereumDeposit(address _walletAddress) {&#13;
        wallet = RNTMultiSigWallet(_walletAddress);&#13;
    }&#13;
&#13;
    function updateDonator(address _address) internal {&#13;
        bool isFound = false;&#13;
        for (uint i = 0; i &lt; donators.length; i++) {&#13;
            if (donators[i].addr == _address) {&#13;
                donators[i].donated = receivedEther[_address];&#13;
                isFound = true;&#13;
                break;&#13;
            }&#13;
        }&#13;
        if (!isFound) {&#13;
            donators.push(Donator(_address, receivedEther[_address]));&#13;
        }&#13;
    }&#13;
&#13;
    function getDonatorsNumber() external constant returns (uint256) {&#13;
        return donators.length;&#13;
    }&#13;
&#13;
    function getDonator(uint pos) external constant returns (address, uint256) {&#13;
        return (donators[pos].addr, donators[pos].donated);&#13;
    }&#13;
&#13;
    /*&#13;
     * Fallback function for sending ether to wallet and update donators info&#13;
     */&#13;
    function() whenNotPaused payable {&#13;
        wallet.transfer(msg.value);&#13;
&#13;
        overallTakenEther = overallTakenEther.add(msg.value);&#13;
        receivedEther[msg.sender] = receivedEther[msg.sender].add(msg.value);&#13;
&#13;
        updateDonator(msg.sender);&#13;
    }&#13;
&#13;
    function receivedEtherFrom(address _from) whenNotPaused constant public returns (uint256) {&#13;
        return receivedEther[_from];&#13;
    }&#13;
&#13;
    function myEther() whenNotPaused constant public returns (uint256) {&#13;
        return receivedEther[msg.sender];&#13;
    }&#13;
}&#13;
&#13;
contract PresaleFinalizeAgent is HasNoEther {&#13;
    using SafeMath for uint256;&#13;
&#13;
    RntPresaleEthereumDeposit public deposit;&#13;
&#13;
    address public crowdsaleAddress;&#13;
&#13;
    mapping(address =&gt; uint256) public tokensForAddress;&#13;
&#13;
    uint256 public weiPerToken = 0;&#13;
&#13;
    bool public sane = true;&#13;
&#13;
    function PresaleFinalizeAgent(address _deposit, address _crowdsale){&#13;
        deposit = RntPresaleEthereumDeposit(_deposit);&#13;
        crowdsaleAddress = _crowdsale;&#13;
    }&#13;
&#13;
    modifier onlyCrowdsale() {&#13;
        require(msg.sender == crowdsaleAddress);&#13;
        _;&#13;
    }&#13;
&#13;
    function isSane() public constant returns (bool) {&#13;
        return sane;&#13;
    }&#13;
&#13;
    function setCrowdsaleAddress(address _address) onlyOwner public {&#13;
        crowdsaleAddress = _address;&#13;
    }&#13;
&#13;
    function finalizePresale(uint256 presaleTokens) onlyCrowdsale public {&#13;
        require(sane);&#13;
        uint256 overallEther = deposit.overallTakenEther();&#13;
        uint256 multiplier = 10 ** 18;&#13;
        overallEther = overallEther.mul(multiplier);&#13;
        weiPerToken = overallEther.div(presaleTokens);&#13;
        require(weiPerToken &gt; 0);&#13;
        sane = false;&#13;
    }&#13;
}&#13;
&#13;
contract IRntToken {&#13;
    uint256 public decimals = 18;&#13;
&#13;
    uint256 public totalSupply = 1000000000 * (10 ** 18);&#13;
&#13;
    string public name = "RNT Token";&#13;
&#13;
    string public code = "RNT";&#13;
&#13;
&#13;
    function balanceOf() public constant returns (uint256 balance);&#13;
&#13;
    function transfer(address _to, uint _value) public returns (bool success);&#13;
&#13;
    function transferFrom(address _from, address _to, uint _value) public returns (bool success);&#13;
}&#13;
&#13;
contract RntCrowdsale is Pausable {&#13;
    using SafeMath for uint256;&#13;
&#13;
    enum Status {Unknown, Presale, ICO, Finalized} // Crowdsale status&#13;
&#13;
    Status public currentStatus = Status.Unknown;&#13;
&#13;
    bool public isPresaleStarted = false;&#13;
&#13;
    bool public isPresaleFinalized = false;&#13;
&#13;
    bool public isIcoStarted = false;&#13;
&#13;
    bool public isIcoFinalized = false;&#13;
&#13;
    uint256 public icoReceivedWei;&#13;
&#13;
    uint256 public icoTokensSold;&#13;
&#13;
    uint256 public icoInvestmentsCount = 0;&#13;
&#13;
    mapping(address =&gt; uint256) public icoInvestments;&#13;
&#13;
    mapping(address =&gt; uint256) public icoTokenTransfers;&#13;
&#13;
    IRntToken public token;&#13;
&#13;
    PricingStrategy public pricingStrategy;&#13;
&#13;
    PresaleFinalizeAgent public presaleFinalizeAgent;&#13;
&#13;
    RntPresaleEthereumDeposit public deposit;&#13;
&#13;
    address public wallet;&#13;
&#13;
    address public proxy;&#13;
&#13;
    mapping(address =&gt; bool) public tokensAllocationAllowed;&#13;
&#13;
    uint public presaleStartTime;&#13;
&#13;
    uint public presaleEndTime;&#13;
&#13;
    uint public icoStartTime;&#13;
&#13;
    uint public icoEndTime;&#13;
&#13;
    /**&#13;
    @notice A new investment was made.&#13;
    */&#13;
    event Invested(address indexed investor, uint weiAmount, uint tokenAmount, bytes16 indexed customerId);&#13;
&#13;
    event PresaleStarted(uint timestamp);&#13;
&#13;
    event PresaleFinalized(uint timestamp);&#13;
&#13;
    event IcoStarted(uint timestamp);&#13;
&#13;
    event IcoFinalized(uint timestamp);&#13;
&#13;
    /**&#13;
    @notice Token price was calculated.&#13;
    */&#13;
    event TokensPerWeiReceived(uint tokenPrice);&#13;
&#13;
    /**&#13;
    @notice Presale tokens was claimed.&#13;
    */&#13;
    event PresaleTokensClaimed(uint count);&#13;
&#13;
    function RntCrowdsale(address _tokenAddress) {&#13;
        token = IRntToken(_tokenAddress);&#13;
    }&#13;
&#13;
    /**&#13;
    @notice Allow call function only if crowdsale on specified status.&#13;
    */&#13;
    modifier inStatus(Status status) {&#13;
        require(getCrowdsaleStatus() == status);&#13;
        _;&#13;
    }&#13;
&#13;
    /**&#13;
    @notice Check that address can allocate tokens.&#13;
    */&#13;
    modifier canAllocateTokens {&#13;
        require(tokensAllocationAllowed[msg.sender] == true);&#13;
        _;&#13;
    }&#13;
&#13;
    /**&#13;
    @notice Allow address to call allocate function.&#13;
    @param _addr Address for allowance&#13;
    @param _allow Allowance&#13;
    */&#13;
    function allowAllocation(address _addr, bool _allow) onlyOwner external {&#13;
        tokensAllocationAllowed[_addr] = _allow;&#13;
    }&#13;
&#13;
    /**&#13;
    @notice Set PresaleFinalizeAgent address.&#13;
    @dev Used to calculate price for one token.&#13;
    */&#13;
    function setPresaleFinalizeAgent(address _agentAddress) whenNotPaused onlyOwner external {&#13;
        presaleFinalizeAgent = PresaleFinalizeAgent(_agentAddress);&#13;
    }&#13;
&#13;
    /**&#13;
    @notice Set PricingStrategy address.&#13;
    @dev Used to calculate tokens that will be received through investment.&#13;
    */&#13;
    function setPricingStartegy(address _pricingStrategyAddress) whenNotPaused onlyOwner external {&#13;
        pricingStrategy = PricingStrategy(_pricingStrategyAddress);&#13;
    }&#13;
&#13;
    /**&#13;
    @notice Set RNTMultiSigWallet address.&#13;
    @dev Wallet for invested wei.&#13;
    */&#13;
    function setMultiSigWallet(address _walletAddress) whenNotPaused onlyOwner external {&#13;
        wallet = _walletAddress;&#13;
    }&#13;
&#13;
&#13;
    /**&#13;
    @notice Set RntTokenProxy address.&#13;
    */&#13;
    function setBackendProxyBuyer(address _proxyAddress) whenNotPaused onlyOwner external {&#13;
        proxy = _proxyAddress;&#13;
    }&#13;
&#13;
    /**&#13;
    @notice Set RntPresaleEhtereumDeposit address.&#13;
    @dev Deposit used to calculate presale tokens.&#13;
    */&#13;
    function setPresaleEthereumDeposit(address _depositAddress) whenNotPaused onlyOwner external {&#13;
        deposit = RntPresaleEthereumDeposit(_depositAddress);&#13;
    }&#13;
&#13;
    /**&#13;
    @notice Get current crowdsale status.&#13;
    @return { One of possible crowdsale statuses [Unknown, Presale, ICO, Finalized] }&#13;
    */&#13;
    function getCrowdsaleStatus() constant public returns (Status) {&#13;
        return currentStatus;&#13;
    }&#13;
&#13;
    /**&#13;
    @notice Start presale and track start time.&#13;
    */&#13;
    function startPresale() whenNotPaused onlyOwner external {&#13;
        require(!isPresaleStarted);&#13;
&#13;
        currentStatus = Status.Presale;&#13;
        isPresaleStarted = true;&#13;
&#13;
        presaleStartTime = now;&#13;
        PresaleStarted(presaleStartTime);&#13;
    }&#13;
&#13;
    /**&#13;
    @notice Finalize presale, calculate token price, track finalize time.&#13;
    */&#13;
    function finalizePresale() whenNotPaused onlyOwner external {&#13;
        require(isPresaleStarted &amp;&amp; !isPresaleFinalized);&#13;
        require(presaleFinalizeAgent.isSane());&#13;
&#13;
        uint256 presaleSupply = token.totalSupply();&#13;
&#13;
        // Presale supply is 20% of total&#13;
        presaleSupply = presaleSupply.div(5);&#13;
&#13;
        presaleFinalizeAgent.finalizePresale(presaleSupply);&#13;
        uint tokenWei = presaleFinalizeAgent.weiPerToken();&#13;
        pricingStrategy.setTokenPriceInWei(tokenWei);&#13;
        TokensPerWeiReceived(tokenWei);&#13;
&#13;
        require(tokenWei &gt; 0);&#13;
&#13;
        currentStatus = Status.Unknown;&#13;
        isPresaleFinalized = true;&#13;
&#13;
        presaleEndTime = now;&#13;
        PresaleFinalized(presaleEndTime);&#13;
    }&#13;
&#13;
    /**&#13;
    @notice Start ICO and track start time.&#13;
    */&#13;
    function startIco() whenNotPaused onlyOwner external {&#13;
        require(!isIcoStarted &amp;&amp; isPresaleFinalized);&#13;
&#13;
        currentStatus = Status.ICO;&#13;
        isIcoStarted = true;&#13;
&#13;
        icoStartTime = now;&#13;
        IcoStarted(icoStartTime);&#13;
    }&#13;
&#13;
    /**&#13;
    @notice Finalize ICO and track finalize time.&#13;
    */&#13;
    function finalizeIco() whenNotPaused onlyOwner external {&#13;
        require(!isIcoFinalized &amp;&amp; isIcoStarted);&#13;
&#13;
        currentStatus = Status.Finalized;&#13;
        isIcoFinalized = true;&#13;
&#13;
        icoEndTime = now;&#13;
        IcoFinalized(icoEndTime);&#13;
    }&#13;
&#13;
&#13;
    /**&#13;
    @notice Handle invested wei.&#13;
    @dev Send some amount of wei to wallet and get tokens that will be calculated according Pricing Strategy.&#13;
         It will transfer ether to wallet only if investment did inside ethereum using payable method.&#13;
    @param _receiver The Ethereum address who receives the tokens.&#13;
    @param _customerUuid (optional) UUID v4 to track the successful payments on the server side.&#13;
    */&#13;
    function investInternal(address _receiver, bytes16 _customerUuid) private {&#13;
        uint weiAmount = msg.value;&#13;
&#13;
        uint256 tokenAmount = pricingStrategy.calculatePrice(weiAmount, 18);&#13;
&#13;
        require(tokenAmount != 0);&#13;
&#13;
        if (icoInvestments[_receiver] == 0) {&#13;
            // A new investor&#13;
            icoInvestmentsCount++;&#13;
        }&#13;
        icoInvestments[_receiver] = icoInvestments[_receiver].add(weiAmount);&#13;
        icoTokenTransfers[_receiver] = icoTokenTransfers[_receiver].add(tokenAmount);&#13;
        icoReceivedWei = icoReceivedWei.add(weiAmount);&#13;
        icoTokensSold = icoTokensSold.add(tokenAmount);&#13;
&#13;
        assignTokens(owner, _receiver, tokenAmount);&#13;
&#13;
        // Pocket the money&#13;
        wallet.transfer(weiAmount);&#13;
&#13;
        // Tell us invest was success&#13;
        Invested(_receiver, weiAmount, tokenAmount, _customerUuid);&#13;
    }&#13;
&#13;
    /**&#13;
    @notice Handle tokens allocating.&#13;
    @dev Uses when tokens was bought not in ethereum&#13;
    @param _receiver The Ethereum address who receives the tokens.&#13;
    @param _customerUuid (optional) UUID v4 to track the successful payments on the server side.&#13;
    @param _weiAmount Wei amount, that should be specified only if user was invested out&#13;
    */&#13;
    function allocateInternal(address _receiver, bytes16 _customerUuid, uint256 _weiAmount) private {&#13;
        uint256 tokenAmount = pricingStrategy.calculatePrice(_weiAmount, 18);&#13;
&#13;
        require(tokenAmount != 0);&#13;
&#13;
        if (icoInvestments[_receiver] == 0) {&#13;
            // A new investor&#13;
            icoInvestmentsCount++;&#13;
        }&#13;
        icoInvestments[_receiver] = icoInvestments[_receiver].add(_weiAmount);&#13;
        icoTokenTransfers[_receiver] = icoTokenTransfers[_receiver].add(tokenAmount);&#13;
        icoReceivedWei = icoReceivedWei.add(_weiAmount);&#13;
        icoTokensSold = icoTokensSold.add(tokenAmount);&#13;
&#13;
        assignTokens(owner, _receiver, tokenAmount);&#13;
&#13;
        // Tell us invest was success&#13;
        Invested(_receiver, _weiAmount, tokenAmount, _customerUuid);&#13;
    }&#13;
&#13;
    /**&#13;
    @notice Allocate tokens to specified address.&#13;
    @dev Function that should be used only by proxy to handle payments outside ethereum.&#13;
    @param _receiver The Ethereum address who receives the tokens.&#13;
    @param _customerUuid (optional) UUID v4 to track the successful payments on the server side.&#13;
    @param _weiAmount User invested amount of money in wei.&#13;
    */&#13;
    function allocateTokens(address _receiver, bytes16 _customerUuid, uint256 _weiAmount) whenNotPaused canAllocateTokens public {&#13;
        allocateInternal(_receiver, _customerUuid, _weiAmount);&#13;
    }&#13;
&#13;
    /**&#13;
    @notice Make an investment.&#13;
    @dev Can be called only at ICO status. Should have wei != 0.&#13;
    @param _customerUuid (optional) UUID v4 to track the successful payments on the server side&#13;
    */&#13;
    function invest(bytes16 _customerUuid) whenNotPaused inStatus(Status.ICO) public payable {&#13;
        investInternal(msg.sender, _customerUuid);&#13;
    }&#13;
&#13;
    /**&#13;
    @notice Function for claiming tokens for presale investors.&#13;
    @dev Can be called only after presale ends. Tokens will be transfered to callers address.&#13;
    */&#13;
    function claimPresaleTokens() whenNotPaused external {&#13;
        require(isPresaleFinalized == true);&#13;
&#13;
        uint256 senderEther = deposit.receivedEtherFrom(msg.sender);&#13;
        uint256 multiplier = 10 ** 18;&#13;
        senderEther = senderEther.mul(multiplier);&#13;
        uint256 tokenWei = pricingStrategy.oneTokenInWei();&#13;
        uint256 tokensAmount = senderEther.div(tokenWei);&#13;
&#13;
        require(tokensAmount &gt; 0);&#13;
        token.transferFrom(owner, msg.sender, tokensAmount);&#13;
        PresaleTokensClaimed(tokensAmount);&#13;
    }&#13;
&#13;
    /**&#13;
    @notice Transfer issued tokens to the investor.&#13;
    */&#13;
    function assignTokens(address _from, address _receiver, uint _tokenAmount) private {&#13;
        token.transferFrom(_from, _receiver, _tokenAmount);&#13;
    }&#13;
}