pragma solidity ^0.4.16;

// copyright <span class="__cf_email__" data-cfemail="b0d3dfdec4d1d3c4f0f5c4d8d5c2d5dddfde9ed3dfdd">[emailÂ protected]</span>&#13;
&#13;
contract SafeMath {&#13;
&#13;
    /* function assert(bool assertion) internal { */&#13;
    /*   if (!assertion) { */&#13;
    /*     throw; */&#13;
    /*   } */&#13;
    /* }      // assert no longer needed once solidity is on 0.4.10 */&#13;
&#13;
    function safeAdd(uint256 x, uint256 y) pure internal returns(uint256) {&#13;
      uint256 z = x + y;&#13;
      assert((z &gt;= x) &amp;&amp; (z &gt;= y));&#13;
      return z;&#13;
    }&#13;
&#13;
    function safeSubtract(uint256 x, uint256 y) pure internal returns(uint256) {&#13;
      assert(x &gt;= y);&#13;
      uint256 z = x - y;&#13;
      return z;&#13;
    }&#13;
&#13;
    function safeMult(uint256 x, uint256 y) pure internal returns(uint256) {&#13;
      uint256 z = x * y;&#13;
      assert((x == 0)||(z/x == y));&#13;
      return z;&#13;
    }&#13;
&#13;
}&#13;
&#13;
contract BasicAccessControl {&#13;
    address public owner;&#13;
    // address[] public moderators;&#13;
    uint16 public totalModerators = 0;&#13;
    mapping (address =&gt; bool) public moderators;&#13;
    bool public isMaintaining = true;&#13;
&#13;
    function BasicAccessControl() public {&#13;
        owner = msg.sender;&#13;
    }&#13;
&#13;
    modifier onlyOwner {&#13;
        require(msg.sender == owner);&#13;
        _;&#13;
    }&#13;
&#13;
    modifier onlyModerators() {&#13;
        require(moderators[msg.sender] == true);&#13;
        _;&#13;
    }&#13;
&#13;
    modifier isActive {&#13;
        require(!isMaintaining);&#13;
        _;&#13;
    }&#13;
&#13;
    function ChangeOwner(address _newOwner) onlyOwner public {&#13;
        if (_newOwner != address(0)) {&#13;
            owner = _newOwner;&#13;
        }&#13;
    }&#13;
&#13;
&#13;
    function AddModerator(address _newModerator) onlyOwner public {&#13;
        if (moderators[_newModerator] == false) {&#13;
            moderators[_newModerator] = true;&#13;
            totalModerators += 1;&#13;
        }&#13;
    }&#13;
    &#13;
    function RemoveModerator(address _oldModerator) onlyOwner public {&#13;
        if (moderators[_oldModerator] == true) {&#13;
            moderators[_oldModerator] = false;&#13;
            totalModerators -= 1;&#13;
        }&#13;
    }&#13;
&#13;
    function UpdateMaintaining(bool _isMaintaining) onlyOwner public {&#13;
        isMaintaining = _isMaintaining;&#13;
    }&#13;
}&#13;
&#13;
contract EtheremonEnum {&#13;
&#13;
    enum ResultCode {&#13;
        SUCCESS,&#13;
        ERROR_CLASS_NOT_FOUND,&#13;
        ERROR_LOW_BALANCE,&#13;
        ERROR_SEND_FAIL,&#13;
        ERROR_NOT_TRAINER,&#13;
        ERROR_NOT_ENOUGH_MONEY,&#13;
        ERROR_INVALID_AMOUNT&#13;
    }&#13;
    &#13;
    enum ArrayType {&#13;
        CLASS_TYPE,&#13;
        STAT_STEP,&#13;
        STAT_START,&#13;
        STAT_BASE,&#13;
        OBJ_SKILL&#13;
    }&#13;
}&#13;
&#13;
&#13;
contract EtheremonCastleBattle is EtheremonEnum, BasicAccessControl, SafeMath {&#13;
    uint8 constant public NO_BATTLE_LOG = 4;&#13;
    &#13;
    struct CastleData {&#13;
        uint index; // in active castle if &gt; 0&#13;
        string name;&#13;
        address owner;&#13;
        uint32 totalWin;&#13;
        uint32 totalLose;&#13;
        uint64[6] monsters; // 3 attackers, 3 supporters&#13;
        uint64[4] battleList;&#13;
        uint32 brickNumber;&#13;
        uint createTime;&#13;
    }&#13;
    &#13;
    struct BattleDataLog {&#13;
        uint32 castleId;&#13;
        address attacker;&#13;
        uint32[3] castleExps; // 3 attackers&#13;
        uint64[6] attackerObjIds;&#13;
        uint32[3] attackerExps;&#13;
        uint8[3] randoms;&#13;
        uint8 result;&#13;
    }&#13;
    &#13;
    struct TrainerBattleLog {&#13;
        uint32 lastCastle;&#13;
        uint32 totalWin;&#13;
        uint32 totalLose;&#13;
        uint64[4] battleList;&#13;
        uint32 totalBrick;&#13;
    }&#13;
    &#13;
    mapping(uint64 =&gt; BattleDataLog) battles;&#13;
    mapping(address =&gt; uint32) trainerCastle;&#13;
    mapping(address =&gt; TrainerBattleLog) trannerBattleLog;&#13;
    mapping(uint32 =&gt; CastleData) castleData;&#13;
    uint32[] activeCastleList;&#13;
&#13;
    uint32 public totalCastle = 0;&#13;
    uint64 public totalBattle = 0;&#13;
    &#13;
    // only moderators&#13;
    /*&#13;
    TO AVOID ANY BUGS, WE ALLOW MODERATORS TO HAVE PERMISSION TO ALL THESE FUNCTIONS AND UPDATE THEM IN EARLY BETA STAGE.&#13;
    AFTER THE SYSTEM IS STABLE, WE WILL REMOVE OWNER OF THIS SMART CONTRACT AND ONLY KEEP ONE MODERATOR WHICH IS ETHEREMON BATTLE CONTRACT.&#13;
    HENCE, THE DECENTRALIZED ATTRIBUTION IS GUARANTEED.&#13;
    */&#13;
    &#13;
    function addCastle(address _trainer, string _name, uint64 _a1, uint64 _a2, uint64 _a3, uint64 _s1, uint64 _s2, uint64 _s3, uint32 _brickNumber) onlyModerators external returns(uint32 currentCastleId){&#13;
        currentCastleId = trainerCastle[_trainer];&#13;
        if (currentCastleId &gt; 0)&#13;
            return currentCastleId;&#13;
&#13;
        totalCastle += 1;&#13;
        currentCastleId = totalCastle;&#13;
        CastleData storage castle = castleData[currentCastleId];&#13;
        castle.name = _name;&#13;
        castle.owner = _trainer;&#13;
        castle.monsters[0] = _a1;&#13;
        castle.monsters[1] = _a2;&#13;
        castle.monsters[2] = _a3;&#13;
        castle.monsters[3] = _s1;&#13;
        castle.monsters[4] = _s2;&#13;
        castle.monsters[5] = _s3;&#13;
        castle.brickNumber = _brickNumber;&#13;
        castle.createTime = now;&#13;
        &#13;
        castle.index = ++activeCastleList.length;&#13;
        activeCastleList[castle.index-1] = currentCastleId;&#13;
        // mark sender&#13;
        trainerCastle[_trainer] = currentCastleId;&#13;
    }&#13;
    &#13;
    function renameCastle(uint32 _castleId, string _name) onlyModerators external {&#13;
        CastleData storage castle = castleData[_castleId];&#13;
        castle.name = _name;&#13;
    }&#13;
    &#13;
    function removeCastleFromActive(uint32 _castleId) onlyModerators external {&#13;
        CastleData storage castle = castleData[_castleId];&#13;
        if (castle.index == 0)&#13;
            return;&#13;
        &#13;
        trainerCastle[castle.owner] = 0;&#13;
        if (castle.index &lt;= activeCastleList.length) {&#13;
            // Move an existing element into the vacated key slot.&#13;
            castleData[activeCastleList[activeCastleList.length-1]].index = castle.index;&#13;
            activeCastleList[castle.index-1] = activeCastleList[activeCastleList.length-1];&#13;
            activeCastleList.length -= 1;&#13;
            castle.index = 0;&#13;
        }&#13;
        &#13;
        trannerBattleLog[castle.owner].lastCastle = _castleId;&#13;
    }&#13;
    &#13;
    function addBattleLog(uint32 _castleId, address _attacker, &#13;
        uint8 _ran1, uint8 _ran2, uint8 _ran3, uint8 _result, uint32 _castleExp1, uint32 _castleExp2, uint32 _castleExp3) onlyModerators external returns(uint64) {&#13;
        totalBattle += 1;&#13;
        BattleDataLog storage battleLog = battles[totalBattle];&#13;
        battleLog.castleId = _castleId;&#13;
        battleLog.attacker = _attacker;&#13;
        battleLog.randoms[0] = _ran1;&#13;
        battleLog.randoms[1] = _ran2;&#13;
        battleLog.randoms[2] = _ran3;&#13;
        battleLog.result = _result;&#13;
        battleLog.castleExps[0] = _castleExp1;&#13;
        battleLog.castleExps[1] = _castleExp2;&#13;
        battleLog.castleExps[2] = _castleExp3;&#13;
        &#13;
        // &#13;
        CastleData storage castle = castleData[_castleId];&#13;
        TrainerBattleLog storage trainerLog = trannerBattleLog[_attacker];&#13;
        /*&#13;
        CASTLE_WIN = 0 &#13;
        CASTLE_LOSE = 1 &#13;
        CASTLE_DESTROYED= 2&#13;
        */&#13;
        if (_result == 0) { // win&#13;
            castle.totalWin += 1;&#13;
            trainerLog.totalLose += 1;              &#13;
        } else {&#13;
            castle.totalLose += 1;&#13;
            trainerLog.totalWin += 1;&#13;
            if (_result == 2) { // destroy&#13;
                trainerLog.totalBrick += castle.brickNumber / 2;&#13;
            }&#13;
        }&#13;
&#13;
        castle.battleList[(castle.totalLose + castle.totalWin - 1)%NO_BATTLE_LOG] = totalBattle;&#13;
        trainerLog.battleList[(trainerLog.totalWin + trainerLog.totalLose - 1)%NO_BATTLE_LOG] = totalBattle;&#13;
        &#13;
        return totalBattle;&#13;
    }&#13;
    &#13;
    function addBattleLogMonsterInfo(uint64 _battleId, uint64 _a1, uint64 _a2, uint64 _a3, uint64 _s1, uint64 _s2, uint64 _s3, uint32 _exp1, uint32 _exp2, uint32 _exp3) onlyModerators external {&#13;
        BattleDataLog storage battleLog = battles[_battleId];&#13;
        battleLog.attackerObjIds[0] = _a1;&#13;
        battleLog.attackerObjIds[1] = _a2;&#13;
        battleLog.attackerObjIds[2] = _a3;&#13;
        battleLog.attackerObjIds[3] = _s1;&#13;
        battleLog.attackerObjIds[4] = _s2;&#13;
        battleLog.attackerObjIds[5] = _s3;&#13;
        &#13;
        battleLog.attackerExps[0] = _exp1;&#13;
        battleLog.attackerExps[1] = _exp2;&#13;
        battleLog.attackerExps[2] = _exp3;&#13;
    }&#13;
    &#13;
    &#13;
    // read access &#13;
    function isCastleActive(uint32 _castleId) constant external returns(bool){&#13;
        CastleData storage castle = castleData[_castleId];&#13;
        return (castle.index &gt; 0);&#13;
    }&#13;
    &#13;
    function countActiveCastle() constant external returns(uint) {&#13;
        return activeCastleList.length;&#13;
    }&#13;
    &#13;
    function getActiveCastleId(uint index) constant external returns(uint32) {&#13;
        return activeCastleList[index];&#13;
    }&#13;
    &#13;
    function getCastleBasicInfo(address _owner) constant external returns(uint32, uint, uint32) {&#13;
        uint32 currentCastleId = trainerCastle[_owner];&#13;
        if (currentCastleId == 0)&#13;
            return (0, 0, 0);&#13;
        CastleData memory castle = castleData[currentCastleId];&#13;
        return (currentCastleId, castle.index, castle.brickNumber);&#13;
    }&#13;
    &#13;
    function getCastleBasicInfoById(uint32 _castleId) constant external returns(uint, address, uint32) {&#13;
        CastleData memory castle = castleData[_castleId];&#13;
        return (castle.index, castle.owner, castle.brickNumber);&#13;
    }&#13;
    &#13;
    function getCastleObjInfo(uint32 _castleId) constant external returns(uint64, uint64, uint64, uint64, uint64, uint64) {&#13;
        CastleData memory castle = castleData[_castleId];&#13;
        return (castle.monsters[0], castle.monsters[1], castle.monsters[2], castle.monsters[3], castle.monsters[4], castle.monsters[5]);&#13;
    }&#13;
    &#13;
    function getCastleWinLose(uint32 _castleId) constant external returns(uint32, uint32, uint32) {&#13;
        CastleData memory castle = castleData[_castleId];&#13;
        return (castle.totalWin, castle.totalLose, castle.brickNumber);&#13;
    }&#13;
    &#13;
    function getCastleStats(uint32 _castleId) constant external returns(string, address, uint32, uint32, uint32, uint) {&#13;
        CastleData memory castle = castleData[_castleId];&#13;
        return (castle.name, castle.owner, castle.brickNumber, castle.totalWin, castle.totalLose, castle.createTime);&#13;
    }&#13;
&#13;
    function getBattleDataLog(uint64 _battleId) constant external returns(uint32, address, uint8, uint8, uint8, uint8, uint32, uint32, uint32) {&#13;
        BattleDataLog memory battleLog = battles[_battleId];&#13;
        return (battleLog.castleId, battleLog.attacker, battleLog.result, battleLog.randoms[0], battleLog.randoms[1], &#13;
            battleLog.randoms[2], battleLog.castleExps[0], battleLog.castleExps[1], battleLog.castleExps[2]);&#13;
    }&#13;
    &#13;
    function getBattleAttackerLog(uint64 _battleId) constant external returns(uint64, uint64, uint64, uint64, uint64, uint64, uint32, uint32, uint32) {&#13;
        BattleDataLog memory battleLog = battles[_battleId];&#13;
        return (battleLog.attackerObjIds[0], battleLog.attackerObjIds[1], battleLog.attackerObjIds[2], battleLog.attackerObjIds[3], battleLog.attackerObjIds[4], &#13;
            battleLog.attackerObjIds[5], battleLog.attackerExps[0], battleLog.attackerExps[1], battleLog.attackerExps[2]);&#13;
    }&#13;
    &#13;
    function getCastleBattleList(uint32 _castleId) constant external returns(uint64, uint64, uint64, uint64) {&#13;
        CastleData storage castle = castleData[_castleId];&#13;
        return (castle.battleList[0], castle.battleList[1], castle.battleList[2], castle.battleList[3]);&#13;
    }&#13;
    &#13;
    function getTrainerBattleInfo(address _trainer) constant external returns(uint32, uint32, uint32, uint32, uint64, uint64, uint64, uint64) {&#13;
        TrainerBattleLog memory trainerLog = trannerBattleLog[_trainer];&#13;
        return (trainerLog.totalWin, trainerLog.totalLose, trainerLog.lastCastle, trainerLog.totalBrick, trainerLog.battleList[0], trainerLog.battleList[1], trainerLog.battleList[2], &#13;
            trainerLog.battleList[3]);&#13;
    }&#13;
    &#13;
    function getTrainerBrick(address _trainer) constant external returns(uint32) {&#13;
        return trannerBattleLog[_trainer].totalBrick;&#13;
    }&#13;
    &#13;
    function isOnCastle(uint32 _castleId, uint64 _objId) constant external returns(bool) {&#13;
        CastleData storage castle = castleData[_castleId];&#13;
        if (castle.index &gt; 0) {&#13;
            for (uint i = 0; i &lt; castle.monsters.length; i++)&#13;
                if (castle.monsters[i] == _objId)&#13;
                    return true;&#13;
            return false;&#13;
        }&#13;
        return false;&#13;
    }&#13;
}