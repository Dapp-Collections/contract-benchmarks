/*
 ______   _________  ___   ___   _______    _______             ________  ______      
/_____/\ /________/\/__/\ /__/\ /______/\  /______/\           /_______/\/_____/\     
\::::_\/_\__.::.__\/\::\ \\  \ \\::::__\/__\::::__\/__         \__.::._\/\:::_ \ \    
 \:\/___/\  \::\ \   \::\/_\ .\ \\:\ /____/\\:\ /____/\  ___      \::\ \  \:\ \ \ \   
  \::___\/_  \::\ \   \:: ___::\ \\:\\_  _\/ \:\\_  _\/ /__/\     _\::\ \__\:\ \ \ \  
   \:\____/\  \::\ \   \: \ \\::\ \\:\_\ \ \  \:\_\ \ \ \::\ \   /__\::\__/\\:\_\ \ \ 
    \_____\/   \__\/    \__\/ \::\/ \_____\/   \_____\/  \:_\/   \________\/ \_____\/ 
  ______ _______ _    _    _____  ____   ____  _____     _____          __  __ ______  _____ 
 |  ____|__   __| |  | |  / ____|/ __ \ / __ \|  __ \   / ____|   /\   |  \/  |  ____|/ ____|
 | |__     | |  | |__| | | |  __| |  | | |  | | |  | | | |  __   /  \  | \  / | |__  | (___  
 |  __|    | |  |  __  | | | |_ | |  | | |  | | |  | | | | |_ | / /\ \ | |\/| |  __|  \___ \ 
 | |____   | |  | |  | | | |__| | |__| | |__| | |__| | | |__| |/ ____ \| |  | | |____ ____) |
 |______|  |_|  |_|  |_|  \_____|\____/ \____/|_____/   \_____/_/    \_\_|  |_|______|_____/ 
                                                                                             
                                                         BY : <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="8ec2e3fddde5f7cec9e3efe7e2a0ede1e3">[emailÂ protected]</a>&#13;
*/                            &#13;
pragma solidity ^0.4.25;&#13;
contract OraclizeI {&#13;
    address public cbAddress;&#13;
    function query(uint _timestamp, string _datasource, string _arg) external payable returns (bytes32 _id);&#13;
    function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) external payable returns (bytes32 _id);&#13;
    function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) public payable returns (bytes32 _id);&#13;
    function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) external payable returns (bytes32 _id);&#13;
    function queryN(uint _timestamp, string _datasource, bytes _argN) public payable returns (bytes32 _id);&#13;
    function queryN_withGasLimit(uint _timestamp, string _datasource, bytes _argN, uint _gaslimit) external payable returns (bytes32 _id);&#13;
    function getPrice(string _datasource) public returns (uint _dsprice);&#13;
    function getPrice(string _datasource, uint gaslimit) public returns (uint _dsprice);&#13;
    function setProofType(byte _proofType) external;&#13;
    function setCustomGasPrice(uint _gasPrice) external;&#13;
    function randomDS_getSessionPubKeyHash() external constant returns(bytes32);&#13;
}&#13;
&#13;
contract OraclizeAddrResolverI {&#13;
    function getAddress() public returns (address _addr);&#13;
}&#13;
&#13;
/*&#13;
Begin solidity-cborutils&#13;
&#13;
https://github.com/smartcontractkit/solidity-cborutils&#13;
&#13;
MIT License&#13;
&#13;
Copyright (c) 2018 SmartContract ChainLink, Ltd.&#13;
&#13;
Permission is hereby granted, free of charge, to any person obtaining a copy&#13;
of this software and associated documentation files (the "Software"), to deal&#13;
in the Software without restriction, including without limitation the rights&#13;
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell&#13;
copies of the Software, and to permit persons to whom the Software is&#13;
furnished to do so, subject to the following conditions:&#13;
&#13;
The above copyright notice and this permission notice shall be included in all&#13;
copies or substantial portions of the Software.&#13;
&#13;
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR&#13;
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,&#13;
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE&#13;
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER&#13;
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,&#13;
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE&#13;
SOFTWARE.&#13;
 */&#13;
&#13;
library Buffer {&#13;
    struct buffer {&#13;
        bytes buf;&#13;
        uint capacity;&#13;
    }&#13;
&#13;
    function init(buffer memory buf, uint _capacity) internal pure {&#13;
        uint capacity = _capacity;&#13;
        if(capacity % 32 != 0) capacity += 32 - (capacity % 32);&#13;
        // Allocate space for the buffer data&#13;
        buf.capacity = capacity;&#13;
        assembly {&#13;
            let ptr := mload(0x40)&#13;
            mstore(buf, ptr)&#13;
            mstore(ptr, 0)&#13;
            mstore(0x40, add(ptr, capacity))&#13;
        }&#13;
    }&#13;
&#13;
    function resize(buffer memory buf, uint capacity) private pure {&#13;
        bytes memory oldbuf = buf.buf;&#13;
        init(buf, capacity);&#13;
        append(buf, oldbuf);&#13;
    }&#13;
&#13;
    function max(uint a, uint b) private pure returns(uint) {&#13;
        if(a &gt; b) {&#13;
            return a;&#13;
        }&#13;
        return b;&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Appends a byte array to the end of the buffer. Resizes if doing so&#13;
     *      would exceed the capacity of the buffer.&#13;
     * @param buf The buffer to append to.&#13;
     * @param data The data to append.&#13;
     * @return The original buffer.&#13;
     */&#13;
    function append(buffer memory buf, bytes data) internal pure returns(buffer memory) {&#13;
        if(data.length + buf.buf.length &gt; buf.capacity) {&#13;
            resize(buf, max(buf.capacity, data.length) * 2);&#13;
        }&#13;
&#13;
        uint dest;&#13;
        uint src;&#13;
        uint len = data.length;&#13;
        assembly {&#13;
            // Memory address of the buffer data&#13;
            let bufptr := mload(buf)&#13;
            // Length of existing buffer data&#13;
            let buflen := mload(bufptr)&#13;
            // Start address = buffer address + buffer length + sizeof(buffer length)&#13;
            dest := add(add(bufptr, buflen), 32)&#13;
            // Update buffer length&#13;
            mstore(bufptr, add(buflen, mload(data)))&#13;
            src := add(data, 32)&#13;
        }&#13;
&#13;
        // Copy word-length chunks while possible&#13;
        for(; len &gt;= 32; len -= 32) {&#13;
            assembly {&#13;
                mstore(dest, mload(src))&#13;
            }&#13;
            dest += 32;&#13;
            src += 32;&#13;
        }&#13;
&#13;
        // Copy remaining bytes&#13;
        uint mask = 256 ** (32 - len) - 1;&#13;
        assembly {&#13;
            let srcpart := and(mload(src), not(mask))&#13;
            let destpart := and(mload(dest), mask)&#13;
            mstore(dest, or(destpart, srcpart))&#13;
        }&#13;
&#13;
        return buf;&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Appends a byte to the end of the buffer. Resizes if doing so would&#13;
     * exceed the capacity of the buffer.&#13;
     * @param buf The buffer to append to.&#13;
     * @param data The data to append.&#13;
     * @return The original buffer.&#13;
     */&#13;
    function append(buffer memory buf, uint8 data) internal pure {&#13;
        if(buf.buf.length + 1 &gt; buf.capacity) {&#13;
            resize(buf, buf.capacity * 2);&#13;
        }&#13;
&#13;
        assembly {&#13;
            // Memory address of the buffer data&#13;
            let bufptr := mload(buf)&#13;
            // Length of existing buffer data&#13;
            let buflen := mload(bufptr)&#13;
            // Address = buffer address + buffer length + sizeof(buffer length)&#13;
            let dest := add(add(bufptr, buflen), 32)&#13;
            mstore8(dest, data)&#13;
            // Update buffer length&#13;
            mstore(bufptr, add(buflen, 1))&#13;
        }&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Appends a byte to the end of the buffer. Resizes if doing so would&#13;
     * exceed the capacity of the buffer.&#13;
     * @param buf The buffer to append to.&#13;
     * @param data The data to append.&#13;
     * @return The original buffer.&#13;
     */&#13;
    function appendInt(buffer memory buf, uint data, uint len) internal pure returns(buffer memory) {&#13;
        if(len + buf.buf.length &gt; buf.capacity) {&#13;
            resize(buf, max(buf.capacity, len) * 2);&#13;
        }&#13;
&#13;
        uint mask = 256 ** len - 1;&#13;
        assembly {&#13;
            // Memory address of the buffer data&#13;
            let bufptr := mload(buf)&#13;
            // Length of existing buffer data&#13;
            let buflen := mload(bufptr)&#13;
            // Address = buffer address + buffer length + sizeof(buffer length) + len&#13;
            let dest := add(add(bufptr, buflen), len)&#13;
            mstore(dest, or(and(mload(dest), not(mask)), data))&#13;
            // Update buffer length&#13;
            mstore(bufptr, add(buflen, len))&#13;
        }&#13;
        return buf;&#13;
    }&#13;
}&#13;
&#13;
library CBOR {&#13;
    using Buffer for Buffer.buffer;&#13;
&#13;
    uint8 private constant MAJOR_TYPE_INT = 0;&#13;
    uint8 private constant MAJOR_TYPE_NEGATIVE_INT = 1;&#13;
    uint8 private constant MAJOR_TYPE_BYTES = 2;&#13;
    uint8 private constant MAJOR_TYPE_STRING = 3;&#13;
    uint8 private constant MAJOR_TYPE_ARRAY = 4;&#13;
    uint8 private constant MAJOR_TYPE_MAP = 5;&#13;
    uint8 private constant MAJOR_TYPE_CONTENT_FREE = 7;&#13;
&#13;
    function encodeType(Buffer.buffer memory buf, uint8 major, uint value) private pure {&#13;
        if(value &lt;= 23) {&#13;
            buf.append(uint8((major &lt;&lt; 5) | value));&#13;
        } else if(value &lt;= 0xFF) {&#13;
            buf.append(uint8((major &lt;&lt; 5) | 24));&#13;
            buf.appendInt(value, 1);&#13;
        } else if(value &lt;= 0xFFFF) {&#13;
            buf.append(uint8((major &lt;&lt; 5) | 25));&#13;
            buf.appendInt(value, 2);&#13;
        } else if(value &lt;= 0xFFFFFFFF) {&#13;
            buf.append(uint8((major &lt;&lt; 5) | 26));&#13;
            buf.appendInt(value, 4);&#13;
        } else if(value &lt;= 0xFFFFFFFFFFFFFFFF) {&#13;
            buf.append(uint8((major &lt;&lt; 5) | 27));&#13;
            buf.appendInt(value, 8);&#13;
        }&#13;
    }&#13;
&#13;
    function encodeIndefiniteLengthType(Buffer.buffer memory buf, uint8 major) private pure {&#13;
        buf.append(uint8((major &lt;&lt; 5) | 31));&#13;
    }&#13;
&#13;
    function encodeUInt(Buffer.buffer memory buf, uint value) internal pure {&#13;
        encodeType(buf, MAJOR_TYPE_INT, value);&#13;
    }&#13;
&#13;
    function encodeInt(Buffer.buffer memory buf, int value) internal pure {&#13;
        if(value &gt;= 0) {&#13;
            encodeType(buf, MAJOR_TYPE_INT, uint(value));&#13;
        } else {&#13;
            encodeType(buf, MAJOR_TYPE_NEGATIVE_INT, uint(-1 - value));&#13;
        }&#13;
    }&#13;
&#13;
    function encodeBytes(Buffer.buffer memory buf, bytes value) internal pure {&#13;
        encodeType(buf, MAJOR_TYPE_BYTES, value.length);&#13;
        buf.append(value);&#13;
    }&#13;
&#13;
    function encodeString(Buffer.buffer memory buf, string value) internal pure {&#13;
        encodeType(buf, MAJOR_TYPE_STRING, bytes(value).length);&#13;
        buf.append(bytes(value));&#13;
    }&#13;
&#13;
    function startArray(Buffer.buffer memory buf) internal pure {&#13;
        encodeIndefiniteLengthType(buf, MAJOR_TYPE_ARRAY);&#13;
    }&#13;
&#13;
    function startMap(Buffer.buffer memory buf) internal pure {&#13;
        encodeIndefiniteLengthType(buf, MAJOR_TYPE_MAP);&#13;
    }&#13;
&#13;
    function endSequence(Buffer.buffer memory buf) internal pure {&#13;
        encodeIndefiniteLengthType(buf, MAJOR_TYPE_CONTENT_FREE);&#13;
    }&#13;
}&#13;
&#13;
/*&#13;
End solidity-cborutils&#13;
 */&#13;
&#13;
contract usingOraclize {&#13;
    uint constant day = 60*60*24;&#13;
    uint constant week = 60*60*24*7;&#13;
    uint constant month = 60*60*24*30;&#13;
    byte constant proofType_NONE = 0x00;&#13;
    byte constant proofType_TLSNotary = 0x10;&#13;
    byte constant proofType_Ledger = 0x30;&#13;
    byte constant proofType_Android = 0x40;&#13;
    byte constant proofType_Native = 0xF0;&#13;
    byte constant proofStorage_IPFS = 0x01;&#13;
    uint8 constant networkID_auto = 0;&#13;
    uint8 constant networkID_mainnet = 1;&#13;
    uint8 constant networkID_testnet = 2;&#13;
    uint8 constant networkID_morden = 2;&#13;
    uint8 constant networkID_consensys = 161;&#13;
&#13;
    OraclizeAddrResolverI OAR;&#13;
&#13;
    OraclizeI oraclize;&#13;
    modifier oraclizeAPI {&#13;
        if((address(OAR)==0)||(getCodeSize(address(OAR))==0))&#13;
            oraclize_setNetwork(networkID_auto);&#13;
&#13;
        if(address(oraclize) != OAR.getAddress())&#13;
            oraclize = OraclizeI(OAR.getAddress());&#13;
&#13;
        _;&#13;
    }&#13;
    modifier coupon(string code){&#13;
        oraclize = OraclizeI(OAR.getAddress());&#13;
        _;&#13;
    }&#13;
&#13;
    function oraclize_setNetwork(uint8 networkID) internal returns(bool){&#13;
      return oraclize_setNetwork();&#13;
      networkID; // silence the warning and remain backwards compatible&#13;
    }&#13;
    function oraclize_setNetwork() internal returns(bool){&#13;
        if (getCodeSize(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed)&gt;0){ //mainnet&#13;
            OAR = OraclizeAddrResolverI(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed);&#13;
            oraclize_setNetworkName("eth_mainnet");&#13;
            return true;&#13;
        }&#13;
        if (getCodeSize(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1)&gt;0){ //ropsten testnet&#13;
            OAR = OraclizeAddrResolverI(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1);&#13;
            oraclize_setNetworkName("eth_ropsten3");&#13;
            return true;&#13;
        }&#13;
        if (getCodeSize(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e)&gt;0){ //kovan testnet&#13;
            OAR = OraclizeAddrResolverI(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e);&#13;
            oraclize_setNetworkName("eth_kovan");&#13;
            return true;&#13;
        }&#13;
        if (getCodeSize(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48)&gt;0){ //rinkeby testnet&#13;
            OAR = OraclizeAddrResolverI(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48);&#13;
            oraclize_setNetworkName("eth_rinkeby");&#13;
            return true;&#13;
        }&#13;
        if (getCodeSize(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475)&gt;0){ //ethereum-bridge&#13;
            OAR = OraclizeAddrResolverI(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475);&#13;
            return true;&#13;
        }&#13;
        if (getCodeSize(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF)&gt;0){ //ether.camp ide&#13;
            OAR = OraclizeAddrResolverI(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF);&#13;
            return true;&#13;
        }&#13;
        if (getCodeSize(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA)&gt;0){ //browser-solidity&#13;
            OAR = OraclizeAddrResolverI(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA);&#13;
            return true;&#13;
        }&#13;
        return false;&#13;
    }&#13;
&#13;
    function __callback(bytes32 myid, string result) public {&#13;
        __callback(myid, result, new bytes(0));&#13;
    }&#13;
    function __callback(bytes32 myid, string result, bytes proof) public {&#13;
      return;&#13;
      myid; result; proof; // Silence compiler warnings&#13;
    }&#13;
&#13;
    function oraclize_getPrice(string datasource) oraclizeAPI internal returns (uint){&#13;
        return oraclize.getPrice(datasource);&#13;
    }&#13;
&#13;
    function oraclize_getPrice(string datasource, uint gaslimit) oraclizeAPI internal returns (uint){&#13;
        return oraclize.getPrice(datasource, gaslimit);&#13;
    }&#13;
&#13;
    function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){&#13;
        uint price = oraclize.getPrice(datasource);&#13;
        if (price &gt; 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price&#13;
        return oraclize.query.value(price)(0, datasource, arg);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){&#13;
        uint price = oraclize.getPrice(datasource);&#13;
        if (price &gt; 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price&#13;
        return oraclize.query.value(price)(timestamp, datasource, arg);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){&#13;
        uint price = oraclize.getPrice(datasource, gaslimit);&#13;
        if (price &gt; 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price&#13;
        return oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){&#13;
        uint price = oraclize.getPrice(datasource, gaslimit);&#13;
        if (price &gt; 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price&#13;
        return oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){&#13;
        uint price = oraclize.getPrice(datasource);&#13;
        if (price &gt; 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price&#13;
        return oraclize.query2.value(price)(0, datasource, arg1, arg2);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){&#13;
        uint price = oraclize.getPrice(datasource);&#13;
        if (price &gt; 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price&#13;
        return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){&#13;
        uint price = oraclize.getPrice(datasource, gaslimit);&#13;
        if (price &gt; 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price&#13;
        return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){&#13;
        uint price = oraclize.getPrice(datasource, gaslimit);&#13;
        if (price &gt; 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price&#13;
        return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, string[] argN) oraclizeAPI internal returns (bytes32 id){&#13;
        uint price = oraclize.getPrice(datasource);&#13;
        if (price &gt; 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price&#13;
        bytes memory args = stra2cbor(argN);&#13;
        return oraclize.queryN.value(price)(0, datasource, args);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, string[] argN) oraclizeAPI internal returns (bytes32 id){&#13;
        uint price = oraclize.getPrice(datasource);&#13;
        if (price &gt; 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price&#13;
        bytes memory args = stra2cbor(argN);&#13;
        return oraclize.queryN.value(price)(timestamp, datasource, args);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, string[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){&#13;
        uint price = oraclize.getPrice(datasource, gaslimit);&#13;
        if (price &gt; 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price&#13;
        bytes memory args = stra2cbor(argN);&#13;
        return oraclize.queryN_withGasLimit.value(price)(timestamp, datasource, args, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, string[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){&#13;
        uint price = oraclize.getPrice(datasource, gaslimit);&#13;
        if (price &gt; 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price&#13;
        bytes memory args = stra2cbor(argN);&#13;
        return oraclize.queryN_withGasLimit.value(price)(0, datasource, args, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, string[1] args) oraclizeAPI internal returns (bytes32 id) {&#13;
        string[] memory dynargs = new string[](1);&#13;
        dynargs[0] = args[0];&#13;
        return oraclize_query(datasource, dynargs);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, string[1] args) oraclizeAPI internal returns (bytes32 id) {&#13;
        string[] memory dynargs = new string[](1);&#13;
        dynargs[0] = args[0];&#13;
        return oraclize_query(timestamp, datasource, dynargs);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, string[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {&#13;
        string[] memory dynargs = new string[](1);&#13;
        dynargs[0] = args[0];&#13;
        return oraclize_query(timestamp, datasource, dynargs, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, string[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {&#13;
        string[] memory dynargs = new string[](1);&#13;
        dynargs[0] = args[0];&#13;
        return oraclize_query(datasource, dynargs, gaslimit);&#13;
    }&#13;
&#13;
    function oraclize_query(string datasource, string[2] args) oraclizeAPI internal returns (bytes32 id) {&#13;
        string[] memory dynargs = new string[](2);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        return oraclize_query(datasource, dynargs);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, string[2] args) oraclizeAPI internal returns (bytes32 id) {&#13;
        string[] memory dynargs = new string[](2);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        return oraclize_query(timestamp, datasource, dynargs);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, string[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {&#13;
        string[] memory dynargs = new string[](2);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        return oraclize_query(timestamp, datasource, dynargs, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, string[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {&#13;
        string[] memory dynargs = new string[](2);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        return oraclize_query(datasource, dynargs, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, string[3] args) oraclizeAPI internal returns (bytes32 id) {&#13;
        string[] memory dynargs = new string[](3);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        return oraclize_query(datasource, dynargs);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, string[3] args) oraclizeAPI internal returns (bytes32 id) {&#13;
        string[] memory dynargs = new string[](3);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        return oraclize_query(timestamp, datasource, dynargs);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, string[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {&#13;
        string[] memory dynargs = new string[](3);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        return oraclize_query(timestamp, datasource, dynargs, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, string[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {&#13;
        string[] memory dynargs = new string[](3);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        return oraclize_query(datasource, dynargs, gaslimit);&#13;
    }&#13;
&#13;
    function oraclize_query(string datasource, string[4] args) oraclizeAPI internal returns (bytes32 id) {&#13;
        string[] memory dynargs = new string[](4);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        dynargs[3] = args[3];&#13;
        return oraclize_query(datasource, dynargs);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, string[4] args) oraclizeAPI internal returns (bytes32 id) {&#13;
        string[] memory dynargs = new string[](4);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        dynargs[3] = args[3];&#13;
        return oraclize_query(timestamp, datasource, dynargs);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, string[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {&#13;
        string[] memory dynargs = new string[](4);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        dynargs[3] = args[3];&#13;
        return oraclize_query(timestamp, datasource, dynargs, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, string[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {&#13;
        string[] memory dynargs = new string[](4);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        dynargs[3] = args[3];&#13;
        return oraclize_query(datasource, dynargs, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, string[5] args) oraclizeAPI internal returns (bytes32 id) {&#13;
        string[] memory dynargs = new string[](5);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        dynargs[3] = args[3];&#13;
        dynargs[4] = args[4];&#13;
        return oraclize_query(datasource, dynargs);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, string[5] args) oraclizeAPI internal returns (bytes32 id) {&#13;
        string[] memory dynargs = new string[](5);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        dynargs[3] = args[3];&#13;
        dynargs[4] = args[4];&#13;
        return oraclize_query(timestamp, datasource, dynargs);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, string[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {&#13;
        string[] memory dynargs = new string[](5);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        dynargs[3] = args[3];&#13;
        dynargs[4] = args[4];&#13;
        return oraclize_query(timestamp, datasource, dynargs, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, string[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {&#13;
        string[] memory dynargs = new string[](5);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        dynargs[3] = args[3];&#13;
        dynargs[4] = args[4];&#13;
        return oraclize_query(datasource, dynargs, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, bytes[] argN) oraclizeAPI internal returns (bytes32 id){&#13;
        uint price = oraclize.getPrice(datasource);&#13;
        if (price &gt; 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price&#13;
        bytes memory args = ba2cbor(argN);&#13;
        return oraclize.queryN.value(price)(0, datasource, args);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, bytes[] argN) oraclizeAPI internal returns (bytes32 id){&#13;
        uint price = oraclize.getPrice(datasource);&#13;
        if (price &gt; 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price&#13;
        bytes memory args = ba2cbor(argN);&#13;
        return oraclize.queryN.value(price)(timestamp, datasource, args);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, bytes[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){&#13;
        uint price = oraclize.getPrice(datasource, gaslimit);&#13;
        if (price &gt; 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price&#13;
        bytes memory args = ba2cbor(argN);&#13;
        return oraclize.queryN_withGasLimit.value(price)(timestamp, datasource, args, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, bytes[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){&#13;
        uint price = oraclize.getPrice(datasource, gaslimit);&#13;
        if (price &gt; 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price&#13;
        bytes memory args = ba2cbor(argN);&#13;
        return oraclize.queryN_withGasLimit.value(price)(0, datasource, args, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, bytes[1] args) oraclizeAPI internal returns (bytes32 id) {&#13;
        bytes[] memory dynargs = new bytes[](1);&#13;
        dynargs[0] = args[0];&#13;
        return oraclize_query(datasource, dynargs);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, bytes[1] args) oraclizeAPI internal returns (bytes32 id) {&#13;
        bytes[] memory dynargs = new bytes[](1);&#13;
        dynargs[0] = args[0];&#13;
        return oraclize_query(timestamp, datasource, dynargs);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, bytes[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {&#13;
        bytes[] memory dynargs = new bytes[](1);&#13;
        dynargs[0] = args[0];&#13;
        return oraclize_query(timestamp, datasource, dynargs, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, bytes[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {&#13;
        bytes[] memory dynargs = new bytes[](1);&#13;
        dynargs[0] = args[0];&#13;
        return oraclize_query(datasource, dynargs, gaslimit);&#13;
    }&#13;
&#13;
    function oraclize_query(string datasource, bytes[2] args) oraclizeAPI internal returns (bytes32 id) {&#13;
        bytes[] memory dynargs = new bytes[](2);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        return oraclize_query(datasource, dynargs);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, bytes[2] args) oraclizeAPI internal returns (bytes32 id) {&#13;
        bytes[] memory dynargs = new bytes[](2);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        return oraclize_query(timestamp, datasource, dynargs);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, bytes[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {&#13;
        bytes[] memory dynargs = new bytes[](2);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        return oraclize_query(timestamp, datasource, dynargs, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, bytes[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {&#13;
        bytes[] memory dynargs = new bytes[](2);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        return oraclize_query(datasource, dynargs, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, bytes[3] args) oraclizeAPI internal returns (bytes32 id) {&#13;
        bytes[] memory dynargs = new bytes[](3);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        return oraclize_query(datasource, dynargs);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, bytes[3] args) oraclizeAPI internal returns (bytes32 id) {&#13;
        bytes[] memory dynargs = new bytes[](3);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        return oraclize_query(timestamp, datasource, dynargs);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, bytes[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {&#13;
        bytes[] memory dynargs = new bytes[](3);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        return oraclize_query(timestamp, datasource, dynargs, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, bytes[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {&#13;
        bytes[] memory dynargs = new bytes[](3);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        return oraclize_query(datasource, dynargs, gaslimit);&#13;
    }&#13;
&#13;
    function oraclize_query(string datasource, bytes[4] args) oraclizeAPI internal returns (bytes32 id) {&#13;
        bytes[] memory dynargs = new bytes[](4);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        dynargs[3] = args[3];&#13;
        return oraclize_query(datasource, dynargs);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, bytes[4] args) oraclizeAPI internal returns (bytes32 id) {&#13;
        bytes[] memory dynargs = new bytes[](4);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        dynargs[3] = args[3];&#13;
        return oraclize_query(timestamp, datasource, dynargs);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, bytes[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {&#13;
        bytes[] memory dynargs = new bytes[](4);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        dynargs[3] = args[3];&#13;
        return oraclize_query(timestamp, datasource, dynargs, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, bytes[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {&#13;
        bytes[] memory dynargs = new bytes[](4);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        dynargs[3] = args[3];&#13;
        return oraclize_query(datasource, dynargs, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, bytes[5] args) oraclizeAPI internal returns (bytes32 id) {&#13;
        bytes[] memory dynargs = new bytes[](5);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        dynargs[3] = args[3];&#13;
        dynargs[4] = args[4];&#13;
        return oraclize_query(datasource, dynargs);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, bytes[5] args) oraclizeAPI internal returns (bytes32 id) {&#13;
        bytes[] memory dynargs = new bytes[](5);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        dynargs[3] = args[3];&#13;
        dynargs[4] = args[4];&#13;
        return oraclize_query(timestamp, datasource, dynargs);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, bytes[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {&#13;
        bytes[] memory dynargs = new bytes[](5);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        dynargs[3] = args[3];&#13;
        dynargs[4] = args[4];&#13;
        return oraclize_query(timestamp, datasource, dynargs, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, bytes[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {&#13;
        bytes[] memory dynargs = new bytes[](5);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        dynargs[3] = args[3];&#13;
        dynargs[4] = args[4];&#13;
        return oraclize_query(datasource, dynargs, gaslimit);&#13;
    }&#13;
&#13;
    function oraclize_cbAddress() oraclizeAPI internal returns (address){&#13;
        return oraclize.cbAddress();&#13;
    }&#13;
    function oraclize_setProof(byte proofP) oraclizeAPI internal {&#13;
        return oraclize.setProofType(proofP);&#13;
    }&#13;
    function oraclize_setCustomGasPrice(uint gasPrice) oraclizeAPI internal {&#13;
        return oraclize.setCustomGasPrice(gasPrice);&#13;
    }&#13;
&#13;
    function oraclize_randomDS_getSessionPubKeyHash() oraclizeAPI internal returns (bytes32){&#13;
        return oraclize.randomDS_getSessionPubKeyHash();&#13;
    }&#13;
&#13;
    function getCodeSize(address _addr) constant internal returns(uint _size) {&#13;
        assembly {&#13;
            _size := extcodesize(_addr)&#13;
        }&#13;
    }&#13;
&#13;
    function parseAddr(string _a) internal pure returns (address){&#13;
        bytes memory tmp = bytes(_a);&#13;
        uint160 iaddr = 0;&#13;
        uint160 b1;&#13;
        uint160 b2;&#13;
        for (uint i=2; i&lt;2+2*20; i+=2){&#13;
            iaddr *= 256;&#13;
            b1 = uint160(tmp[i]);&#13;
            b2 = uint160(tmp[i+1]);&#13;
            if ((b1 &gt;= 97)&amp;&amp;(b1 &lt;= 102)) b1 -= 87;&#13;
            else if ((b1 &gt;= 65)&amp;&amp;(b1 &lt;= 70)) b1 -= 55;&#13;
            else if ((b1 &gt;= 48)&amp;&amp;(b1 &lt;= 57)) b1 -= 48;&#13;
            if ((b2 &gt;= 97)&amp;&amp;(b2 &lt;= 102)) b2 -= 87;&#13;
            else if ((b2 &gt;= 65)&amp;&amp;(b2 &lt;= 70)) b2 -= 55;&#13;
            else if ((b2 &gt;= 48)&amp;&amp;(b2 &lt;= 57)) b2 -= 48;&#13;
            iaddr += (b1*16+b2);&#13;
        }&#13;
        return address(iaddr);&#13;
    }&#13;
&#13;
    function strCompare(string _a, string _b) internal pure returns (int) {&#13;
        bytes memory a = bytes(_a);&#13;
        bytes memory b = bytes(_b);&#13;
        uint minLength = a.length;&#13;
        if (b.length &lt; minLength) minLength = b.length;&#13;
        for (uint i = 0; i &lt; minLength; i ++)&#13;
            if (a[i] &lt; b[i])&#13;
                return -1;&#13;
            else if (a[i] &gt; b[i])&#13;
                return 1;&#13;
        if (a.length &lt; b.length)&#13;
            return -1;&#13;
        else if (a.length &gt; b.length)&#13;
            return 1;&#13;
        else&#13;
            return 0;&#13;
    }&#13;
&#13;
    function indexOf(string _haystack, string _needle) internal pure returns (int) {&#13;
        bytes memory h = bytes(_haystack);&#13;
        bytes memory n = bytes(_needle);&#13;
        if(h.length &lt; 1 || n.length &lt; 1 || (n.length &gt; h.length))&#13;
            return -1;&#13;
        else if(h.length &gt; (2**128 -1))&#13;
            return -1;&#13;
        else&#13;
        {&#13;
            uint subindex = 0;&#13;
            for (uint i = 0; i &lt; h.length; i ++)&#13;
            {&#13;
                if (h[i] == n[0])&#13;
                {&#13;
                    subindex = 1;&#13;
                    while(subindex &lt; n.length &amp;&amp; (i + subindex) &lt; h.length &amp;&amp; h[i + subindex] == n[subindex])&#13;
                    {&#13;
                        subindex++;&#13;
                    }&#13;
                    if(subindex == n.length)&#13;
                        return int(i);&#13;
                }&#13;
            }&#13;
            return -1;&#13;
        }&#13;
    }&#13;
&#13;
    function strConcat(string _a, string _b, string _c, string _d, string _e) internal pure returns (string) {&#13;
        bytes memory _ba = bytes(_a);&#13;
        bytes memory _bb = bytes(_b);&#13;
        bytes memory _bc = bytes(_c);&#13;
        bytes memory _bd = bytes(_d);&#13;
        bytes memory _be = bytes(_e);&#13;
        string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);&#13;
        bytes memory babcde = bytes(abcde);&#13;
        uint k = 0;&#13;
        for (uint i = 0; i &lt; _ba.length; i++) babcde[k++] = _ba[i];&#13;
        for (i = 0; i &lt; _bb.length; i++) babcde[k++] = _bb[i];&#13;
        for (i = 0; i &lt; _bc.length; i++) babcde[k++] = _bc[i];&#13;
        for (i = 0; i &lt; _bd.length; i++) babcde[k++] = _bd[i];&#13;
        for (i = 0; i &lt; _be.length; i++) babcde[k++] = _be[i];&#13;
        return string(babcde);&#13;
    }&#13;
&#13;
    function strConcat(string _a, string _b, string _c, string _d) internal pure returns (string) {&#13;
        return strConcat(_a, _b, _c, _d, "");&#13;
    }&#13;
&#13;
    function strConcat(string _a, string _b, string _c) internal pure returns (string) {&#13;
        return strConcat(_a, _b, _c, "", "");&#13;
    }&#13;
&#13;
    function strConcat(string _a, string _b) internal pure returns (string) {&#13;
        return strConcat(_a, _b, "", "", "");&#13;
    }&#13;
&#13;
    // parseInt&#13;
    function parseInt(string _a) internal pure returns (uint) {&#13;
        return parseInt(_a, 0);&#13;
    }&#13;
&#13;
    // parseInt(parseFloat*10^_b)&#13;
    function parseInt(string _a, uint _b) internal pure returns (uint) {&#13;
        bytes memory bresult = bytes(_a);&#13;
        uint mint = 0;&#13;
        bool decimals = false;&#13;
        for (uint i=0; i&lt;bresult.length; i++){&#13;
            if ((bresult[i] &gt;= 48)&amp;&amp;(bresult[i] &lt;= 57)){&#13;
                if (decimals){&#13;
                   if (_b == 0) break;&#13;
                    else _b--;&#13;
                }&#13;
                mint *= 10;&#13;
                mint += uint(bresult[i]) - 48;&#13;
            } else if (bresult[i] == 46) decimals = true;&#13;
        }&#13;
        if (_b &gt; 0) mint *= 10**_b;&#13;
        return mint;&#13;
    }&#13;
&#13;
    function uint2str(uint i) internal pure returns (string){&#13;
        if (i == 0) return "0";&#13;
        uint j = i;&#13;
        uint len;&#13;
        while (j != 0){&#13;
            len++;&#13;
            j /= 10;&#13;
        }&#13;
        bytes memory bstr = new bytes(len);&#13;
        uint k = len - 1;&#13;
        while (i != 0){&#13;
            bstr[k--] = byte(48 + i % 10);&#13;
            i /= 10;&#13;
        }&#13;
        return string(bstr);&#13;
    }&#13;
&#13;
    using CBOR for Buffer.buffer;&#13;
    function stra2cbor(string[] arr) internal pure returns (bytes) {&#13;
        safeMemoryCleaner();&#13;
        Buffer.buffer memory buf;&#13;
        Buffer.init(buf, 1024);&#13;
        buf.startArray();&#13;
        for (uint i = 0; i &lt; arr.length; i++) {&#13;
            buf.encodeString(arr[i]);&#13;
        }&#13;
        buf.endSequence();&#13;
        return buf.buf;&#13;
    }&#13;
&#13;
    function ba2cbor(bytes[] arr) internal pure returns (bytes) {&#13;
        safeMemoryCleaner();&#13;
        Buffer.buffer memory buf;&#13;
        Buffer.init(buf, 1024);&#13;
        buf.startArray();&#13;
        for (uint i = 0; i &lt; arr.length; i++) {&#13;
            buf.encodeBytes(arr[i]);&#13;
        }&#13;
        buf.endSequence();&#13;
        return buf.buf;&#13;
    }&#13;
&#13;
    string oraclize_network_name;&#13;
    function oraclize_setNetworkName(string _network_name) internal {&#13;
        oraclize_network_name = _network_name;&#13;
    }&#13;
&#13;
    function oraclize_getNetworkName() internal view returns (string) {&#13;
        return oraclize_network_name;&#13;
    }&#13;
&#13;
    function oraclize_newRandomDSQuery(uint _delay, uint _nbytes, uint _customGasLimit) internal returns (bytes32){&#13;
        require((_nbytes &gt; 0) &amp;&amp; (_nbytes &lt;= 32));&#13;
        // Convert from seconds to ledger timer ticks&#13;
        _delay *= 10;&#13;
        bytes memory nbytes = new bytes(1);&#13;
        nbytes[0] = byte(_nbytes);&#13;
        bytes memory unonce = new bytes(32);&#13;
        bytes memory sessionKeyHash = new bytes(32);&#13;
        bytes32 sessionKeyHash_bytes32 = oraclize_randomDS_getSessionPubKeyHash();&#13;
        assembly {&#13;
            mstore(unonce, 0x20)&#13;
            // the following variables can be relaxed&#13;
            // check relaxed random contract under ethereum-examples repo&#13;
            // for an idea on how to override and replace comit hash vars&#13;
            mstore(add(unonce, 0x20), xor(blockhash(sub(number, 1)), xor(coinbase, timestamp)))&#13;
            mstore(sessionKeyHash, 0x20)&#13;
            mstore(add(sessionKeyHash, 0x20), sessionKeyHash_bytes32)&#13;
        }&#13;
        bytes memory delay = new bytes(32);&#13;
        assembly {&#13;
            mstore(add(delay, 0x20), _delay)&#13;
        }&#13;
&#13;
        bytes memory delay_bytes8 = new bytes(8);&#13;
        copyBytes(delay, 24, 8, delay_bytes8, 0);&#13;
&#13;
        bytes[4] memory args = [unonce, nbytes, sessionKeyHash, delay];&#13;
        bytes32 queryId = oraclize_query("random", args, _customGasLimit);&#13;
&#13;
        bytes memory delay_bytes8_left = new bytes(8);&#13;
&#13;
        assembly {&#13;
            let x := mload(add(delay_bytes8, 0x20))&#13;
            mstore8(add(delay_bytes8_left, 0x27), div(x, 0x100000000000000000000000000000000000000000000000000000000000000))&#13;
            mstore8(add(delay_bytes8_left, 0x26), div(x, 0x1000000000000000000000000000000000000000000000000000000000000))&#13;
            mstore8(add(delay_bytes8_left, 0x25), div(x, 0x10000000000000000000000000000000000000000000000000000000000))&#13;
            mstore8(add(delay_bytes8_left, 0x24), div(x, 0x100000000000000000000000000000000000000000000000000000000))&#13;
            mstore8(add(delay_bytes8_left, 0x23), div(x, 0x1000000000000000000000000000000000000000000000000000000))&#13;
            mstore8(add(delay_bytes8_left, 0x22), div(x, 0x10000000000000000000000000000000000000000000000000000))&#13;
            mstore8(add(delay_bytes8_left, 0x21), div(x, 0x100000000000000000000000000000000000000000000000000))&#13;
            mstore8(add(delay_bytes8_left, 0x20), div(x, 0x1000000000000000000000000000000000000000000000000))&#13;
&#13;
        }&#13;
&#13;
        oraclize_randomDS_setCommitment(queryId, keccak256(delay_bytes8_left, args[1], sha256(args[0]), args[2]));&#13;
        return queryId;&#13;
    }&#13;
&#13;
    function oraclize_randomDS_setCommitment(bytes32 queryId, bytes32 commitment) internal {&#13;
        oraclize_randomDS_args[queryId] = commitment;&#13;
    }&#13;
&#13;
    mapping(bytes32=&gt;bytes32) oraclize_randomDS_args;&#13;
    mapping(bytes32=&gt;bool) oraclize_randomDS_sessionKeysHashVerified;&#13;
&#13;
    function verifySig(bytes32 tosignh, bytes dersig, bytes pubkey) internal returns (bool){&#13;
        bool sigok;&#13;
        address signer;&#13;
&#13;
        bytes32 sigr;&#13;
        bytes32 sigs;&#13;
&#13;
        bytes memory sigr_ = new bytes(32);&#13;
        uint offset = 4+(uint(dersig[3]) - 0x20);&#13;
        sigr_ = copyBytes(dersig, offset, 32, sigr_, 0);&#13;
        bytes memory sigs_ = new bytes(32);&#13;
        offset += 32 + 2;&#13;
        sigs_ = copyBytes(dersig, offset+(uint(dersig[offset-1]) - 0x20), 32, sigs_, 0);&#13;
&#13;
        assembly {&#13;
            sigr := mload(add(sigr_, 32))&#13;
            sigs := mload(add(sigs_, 32))&#13;
        }&#13;
&#13;
&#13;
        (sigok, signer) = safer_ecrecover(tosignh, 27, sigr, sigs);&#13;
        if (address(keccak256(pubkey)) == signer) return true;&#13;
        else {&#13;
            (sigok, signer) = safer_ecrecover(tosignh, 28, sigr, sigs);&#13;
            return (address(keccak256(pubkey)) == signer);&#13;
        }&#13;
    }&#13;
&#13;
    function oraclize_randomDS_proofVerify__sessionKeyValidity(bytes proof, uint sig2offset) internal returns (bool) {&#13;
        bool sigok;&#13;
&#13;
        // Step 6: verify the attestation signature, APPKEY1 must sign the sessionKey from the correct ledger app (CODEHASH)&#13;
        bytes memory sig2 = new bytes(uint(proof[sig2offset+1])+2);&#13;
        copyBytes(proof, sig2offset, sig2.length, sig2, 0);&#13;
&#13;
        bytes memory appkey1_pubkey = new bytes(64);&#13;
        copyBytes(proof, 3+1, 64, appkey1_pubkey, 0);&#13;
&#13;
        bytes memory tosign2 = new bytes(1+65+32);&#13;
        tosign2[0] = byte(1); //role&#13;
        copyBytes(proof, sig2offset-65, 65, tosign2, 1);&#13;
        bytes memory CODEHASH = hex"fd94fa71bc0ba10d39d464d0d8f465efeef0a2764e3887fcc9df41ded20f505c";&#13;
        copyBytes(CODEHASH, 0, 32, tosign2, 1+65);&#13;
        sigok = verifySig(sha256(tosign2), sig2, appkey1_pubkey);&#13;
&#13;
        if (sigok == false) return false;&#13;
&#13;
&#13;
        // Step 7: verify the APPKEY1 provenance (must be signed by Ledger)&#13;
        bytes memory LEDGERKEY = hex"7fb956469c5c9b89840d55b43537e66a98dd4811ea0a27224272c2e5622911e8537a2f8e86a46baec82864e98dd01e9ccc2f8bc5dfc9cbe5a91a290498dd96e4";&#13;
&#13;
        bytes memory tosign3 = new bytes(1+65);&#13;
        tosign3[0] = 0xFE;&#13;
        copyBytes(proof, 3, 65, tosign3, 1);&#13;
&#13;
        bytes memory sig3 = new bytes(uint(proof[3+65+1])+2);&#13;
        copyBytes(proof, 3+65, sig3.length, sig3, 0);&#13;
&#13;
        sigok = verifySig(sha256(tosign3), sig3, LEDGERKEY);&#13;
&#13;
        return sigok;&#13;
    }&#13;
&#13;
    modifier oraclize_randomDS_proofVerify(bytes32 _queryId, string _result, bytes _proof) {&#13;
        // Step 1: the prefix has to match 'LP\x01' (Ledger Proof version 1)&#13;
        require((_proof[0] == "L") &amp;&amp; (_proof[1] == "P") &amp;&amp; (_proof[2] == 1));&#13;
&#13;
        bool proofVerified = oraclize_randomDS_proofVerify__main(_proof, _queryId, bytes(_result), oraclize_getNetworkName());&#13;
        require(proofVerified);&#13;
&#13;
        _;&#13;
    }&#13;
&#13;
    function oraclize_randomDS_proofVerify__returnCode(bytes32 _queryId, string _result, bytes _proof) internal returns (uint8){&#13;
        // Step 1: the prefix has to match 'LP\x01' (Ledger Proof version 1)&#13;
        if ((_proof[0] != "L")||(_proof[1] != "P")||(_proof[2] != 1)) return 1;&#13;
&#13;
        bool proofVerified = oraclize_randomDS_proofVerify__main(_proof, _queryId, bytes(_result), oraclize_getNetworkName());&#13;
        if (proofVerified == false) return 2;&#13;
&#13;
        return 0;&#13;
    }&#13;
&#13;
    function matchBytes32Prefix(bytes32 content, bytes prefix, uint n_random_bytes) internal pure returns (bool){&#13;
        bool match_ = true;&#13;
&#13;
        require(prefix.length == n_random_bytes);&#13;
&#13;
        for (uint256 i=0; i&lt; n_random_bytes; i++) {&#13;
            if (content[i] != prefix[i]) match_ = false;&#13;
        }&#13;
&#13;
        return match_;&#13;
    }&#13;
&#13;
    function oraclize_randomDS_proofVerify__main(bytes proof, bytes32 queryId, bytes result, string context_name) internal returns (bool){&#13;
&#13;
        // Step 2: the unique keyhash has to match with the sha256 of (context name + queryId)&#13;
        uint ledgerProofLength = 3+65+(uint(proof[3+65+1])+2)+32;&#13;
        bytes memory keyhash = new bytes(32);&#13;
        copyBytes(proof, ledgerProofLength, 32, keyhash, 0);&#13;
        if (!(keccak256(keyhash) == keccak256(sha256(context_name, queryId)))) return false;&#13;
&#13;
        bytes memory sig1 = new bytes(uint(proof[ledgerProofLength+(32+8+1+32)+1])+2);&#13;
        copyBytes(proof, ledgerProofLength+(32+8+1+32), sig1.length, sig1, 0);&#13;
&#13;
        // Step 3: we assume sig1 is valid (it will be verified during step 5) and we verify if 'result' is the prefix of sha256(sig1)&#13;
        if (!matchBytes32Prefix(sha256(sig1), result, uint(proof[ledgerProofLength+32+8]))) return false;&#13;
&#13;
        // Step 4: commitment match verification, keccak256(delay, nbytes, unonce, sessionKeyHash) == commitment in storage.&#13;
        // This is to verify that the computed args match with the ones specified in the query.&#13;
        bytes memory commitmentSlice1 = new bytes(8+1+32);&#13;
        copyBytes(proof, ledgerProofLength+32, 8+1+32, commitmentSlice1, 0);&#13;
&#13;
        bytes memory sessionPubkey = new bytes(64);&#13;
        uint sig2offset = ledgerProofLength+32+(8+1+32)+sig1.length+65;&#13;
        copyBytes(proof, sig2offset-64, 64, sessionPubkey, 0);&#13;
&#13;
        bytes32 sessionPubkeyHash = sha256(sessionPubkey);&#13;
        if (oraclize_randomDS_args[queryId] == keccak256(commitmentSlice1, sessionPubkeyHash)){ //unonce, nbytes and sessionKeyHash match&#13;
            delete oraclize_randomDS_args[queryId];&#13;
        } else return false;&#13;
&#13;
&#13;
        // Step 5: validity verification for sig1 (keyhash and args signed with the sessionKey)&#13;
        bytes memory tosign1 = new bytes(32+8+1+32);&#13;
        copyBytes(proof, ledgerProofLength, 32+8+1+32, tosign1, 0);&#13;
        if (!verifySig(sha256(tosign1), sig1, sessionPubkey)) return false;&#13;
&#13;
        // verify if sessionPubkeyHash was verified already, if not.. let's do it!&#13;
        if (oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash] == false){&#13;
            oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash] = oraclize_randomDS_proofVerify__sessionKeyValidity(proof, sig2offset);&#13;
        }&#13;
&#13;
        return oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash];&#13;
    }&#13;
&#13;
    // the following function has been written by Alex Beregszaszi (@axic), use it under the terms of the MIT license&#13;
    function copyBytes(bytes from, uint fromOffset, uint length, bytes to, uint toOffset) internal pure returns (bytes) {&#13;
        uint minLength = length + toOffset;&#13;
&#13;
        // Buffer too small&#13;
        require(to.length &gt;= minLength); // Should be a better way?&#13;
&#13;
        // NOTE: the offset 32 is added to skip the `size` field of both bytes variables&#13;
        uint i = 32 + fromOffset;&#13;
        uint j = 32 + toOffset;&#13;
&#13;
        while (i &lt; (32 + fromOffset + length)) {&#13;
            assembly {&#13;
                let tmp := mload(add(from, i))&#13;
                mstore(add(to, j), tmp)&#13;
            }&#13;
            i += 32;&#13;
            j += 32;&#13;
        }&#13;
&#13;
        return to;&#13;
    }&#13;
&#13;
    // the following function has been written by Alex Beregszaszi (@axic), use it under the terms of the MIT license&#13;
    // Duplicate Solidity's ecrecover, but catching the CALL return value&#13;
    function safer_ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal returns (bool, address) {&#13;
        // We do our own memory management here. Solidity uses memory offset&#13;
        // 0x40 to store the current end of memory. We write past it (as&#13;
        // writes are memory extensions), but don't update the offset so&#13;
        // Solidity will reuse it. The memory used here is only needed for&#13;
        // this context.&#13;
&#13;
        // FIXME: inline assembly can't access return values&#13;
        bool ret;&#13;
        address addr;&#13;
&#13;
        assembly {&#13;
            let size := mload(0x40)&#13;
            mstore(size, hash)&#13;
            mstore(add(size, 32), v)&#13;
            mstore(add(size, 64), r)&#13;
            mstore(add(size, 96), s)&#13;
&#13;
            // NOTE: we can reuse the request memory because we deal with&#13;
            //       the return code&#13;
            ret := call(3000, 1, 0, size, 128, size, 32)&#13;
            addr := mload(size)&#13;
        }&#13;
&#13;
        return (ret, addr);&#13;
    }&#13;
&#13;
    // the following function has been written by Alex Beregszaszi (@axic), use it under the terms of the MIT license&#13;
    function ecrecovery(bytes32 hash, bytes sig) internal returns (bool, address) {&#13;
        bytes32 r;&#13;
        bytes32 s;&#13;
        uint8 v;&#13;
&#13;
        if (sig.length != 65)&#13;
          return (false, 0);&#13;
&#13;
        // The signature format is a compact form of:&#13;
        //   {bytes32 r}{bytes32 s}{uint8 v}&#13;
        // Compact means, uint8 is not padded to 32 bytes.&#13;
        assembly {&#13;
            r := mload(add(sig, 32))&#13;
            s := mload(add(sig, 64))&#13;
&#13;
            // Here we are loading the last 32 bytes. We exploit the fact that&#13;
            // 'mload' will pad with zeroes if we overread.&#13;
            // There is no 'mload8' to do this, but that would be nicer.&#13;
            v := byte(0, mload(add(sig, 96)))&#13;
&#13;
            // Alternative solution:&#13;
            // 'byte' is not working due to the Solidity parser, so lets&#13;
            // use the second best option, 'and'&#13;
            // v := and(mload(add(sig, 65)), 255)&#13;
        }&#13;
&#13;
        // albeit non-transactional signatures are not specified by the YP, one would expect it&#13;
        // to match the YP range of [27, 28]&#13;
        //&#13;
        // geth uses [0, 1] and some clients have followed. This might change, see:&#13;
        //  https://github.com/ethereum/go-ethereum/issues/2053&#13;
        if (v &lt; 27)&#13;
          v += 27;&#13;
&#13;
        if (v != 27 &amp;&amp; v != 28)&#13;
            return (false, 0);&#13;
&#13;
        return safer_ecrecover(hash, v, r, s);&#13;
    }&#13;
&#13;
    function safeMemoryCleaner() internal pure {&#13;
        assembly {&#13;
            let fmem := mload(0x40)&#13;
            codecopy(fmem, codesize, sub(msize, fmem))&#13;
        }&#13;
    }&#13;
&#13;
}&#13;
contract safeApi{&#13;
    &#13;
   modifier safe(){&#13;
        address _addr = msg.sender;&#13;
        require (_addr == tx.origin,'Error Action!');&#13;
        uint256 _codeLength;&#13;
        assembly {_codeLength := extcodesize(_addr)}&#13;
        require(_codeLength == 0, "Sender not authorized!");&#13;
            _;&#13;
    }&#13;
&#13;
&#13;
    &#13;
 function toBytes(uint256 _num) internal returns (bytes _ret) {&#13;
   assembly {&#13;
        _ret := mload(0x10)&#13;
        mstore(_ret, 0x20)&#13;
        mstore(add(_ret, 0x20), _num)&#13;
    }&#13;
}&#13;
&#13;
function subStr(string _s, uint start, uint end) internal pure returns (string){&#13;
        bytes memory s = bytes(_s);&#13;
        string memory copy = new string(end - start);&#13;
//        string memory copy = new string(5);&#13;
          uint k = 0;&#13;
        for (uint i = start; i &lt; end; i++){ &#13;
            bytes(copy)[k++] = bytes(_s)[i];&#13;
        }&#13;
        return copy;&#13;
    }&#13;
     &#13;
&#13;
 function safePercent(uint256 a,uint256 b) &#13;
      internal&#13;
      constant&#13;
      returns(uint256)&#13;
      {&#13;
        assert(a&gt;0 &amp;&amp; a &lt;=100);&#13;
        return  div(mul(b,a),100);&#13;
      }&#13;
      &#13;
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
    uint256 c = a * b;&#13;
    assert(a == 0 || c / a == b);&#13;
    return c;&#13;
  }&#13;
 &#13;
  function div(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
    // assert(b &gt; 0); // Solidity automatically throws when dividing by 0â&#13;
    uint256 c = a / b;&#13;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold&#13;
    return c;&#13;
  }&#13;
 &#13;
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
    assert(b &lt;= a);&#13;
    return a - b;&#13;
  }&#13;
 &#13;
  function add(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
    uint256 c = a + b;&#13;
    assert(c &gt;= a);&#13;
    return c;&#13;
  }&#13;
&#13;
}&#13;
contract gameLotto is safeApi,usingOraclize{&#13;
    mapping(bytes32=&gt;bool) private validQueryId;&#13;
    struct player&#13;
    {&#13;
        uint256 id;&#13;
        address addr;&#13;
        uint256 balance;//wei&#13;
        uint256 ticket;&#13;
        uint256 affNumLevel_1;&#13;
        uint256 affNumLevel_2;&#13;
        uint256 timeStamp;&#13;
        mapping(uint256=&gt; playerRecord) index;&#13;
    }&#13;
    &#13;
    struct playerRecord{&#13;
        mapping(uint256=&gt;uint256) numberOfTickets;&#13;
        uint8 betNumbers;&#13;
        uint32 betTickets;&#13;
        bool isReceive;&#13;
    }&#13;
    &#13;
    &#13;
    struct  gameConfig&#13;
    {&#13;
        uint256 unitPrice;&#13;
        uint256 singleLimit;&#13;
        uint256 ticketNum;&#13;
        uint256 dividendPct;&#13;
        uint256 lotteryPoolPct;&#13;
        uint256 prize_1;&#13;
        uint256 prize_2;&#13;
        uint256 prize_3;&#13;
        uint256 lotteryInterval;&#13;
        uint256 level1Rewards;&#13;
        uint256 level2Rewards;&#13;
        uint256 minBetNum;&#13;
        uint256 betMaxNumber;&#13;
        uint256 receiveAwardPct;&#13;
    }&#13;
    &#13;
    struct lotteryRecord{&#13;
        uint256 index;&#13;
        uint256 number;&#13;
        uint256 prize2number;&#13;
        uint256 prize3number;&#13;
        uint256 betOfNumber;&#13;
        uint256 prize1Wei;&#13;
        uint256 prize2Wei;&#13;
        uint256 prize3Wei;&#13;
        uint256 time;&#13;
    }&#13;
    &#13;
    struct gameInfo{&#13;
        uint256 nextLottery;&#13;
        uint256 totalTicket;&#13;
        uint256 useTicket;&#13;
        uint256 index;&#13;
        uint256 prizePool;&#13;
        mapping (uint256 =&gt; lotteryRecord) lotteryResult;&#13;
    }&#13;
    &#13;
    event Lottery(&#13;
      uint256 number,&#13;
      uint256 nextLottery,&#13;
      uint256 indexed index&#13;
   );&#13;
   &#13;
   event Bet(&#13;
      address indexed addr,&#13;
      uint256 indexed index,&#13;
      uint256 number,&#13;
      uint256 use&#13;
   );&#13;
   &#13;
    event Buy(&#13;
       address indexed addr,&#13;
       uint256 number,&#13;
       uint256 value&#13;
   );&#13;
   &#13;
    mapping (uint256 =&gt; player) public player_;&#13;
    mapping (address =&gt; uint256) public playAddr_;&#13;
    mapping (uint256 =&gt; uint256) public playAff_;&#13;
&#13;
    mapping (uint256 =&gt; mapping(uint256 =&gt; uint256)) private indexNumberTicket_;&#13;
    mapping (uint256 =&gt; mapping(uint256 =&gt; uint256[])) private playIndexBetNumber_;&#13;
&#13;
    &#13;
     gameConfig public gameConfig_;&#13;
     gameInfo public gameInfo_;&#13;
     address public admin__;&#13;
     uint256 adminPct__;&#13;
     uint256 private autoPlayId_=123456;&#13;
     uint256 constant CUSTOM_GASLIMIT = 250000;&#13;
     address shareContract=0x55b65bdbe29a1b2d29e28038b09075bac320d11d;&#13;
     bool betSwitch=true;&#13;
    constructor() public {&#13;
        admin__ = msg.sender;&#13;
        gameConfig_.unitPrice=10000000000000000;//0.01 eth&#13;
        gameConfig_.singleLimit=1000;//One-time ticket limit&#13;
        gameConfig_.ticketNum=3;//unitPrice Number of tickets&#13;
        gameConfig_.dividendPct=5;//%Buy tickets for the prize pool pct&#13;
        gameConfig_.lotteryPoolPct=50;//% Draw Prize Pool Use pct&#13;
        gameConfig_.prize_1=55;//%First prize pct&#13;
        gameConfig_.prize_2=30;//%Second prize pct&#13;
        gameConfig_.prize_3=15;//%Third prize pct&#13;
        gameConfig_.lotteryInterval=86400 seconds;//Draw Interval 1 day&#13;
        gameConfig_.level1Rewards=30;//%Inviter Level 1&#13;
        gameConfig_.level2Rewards=10;//%Inviter Level 2&#13;
        gameConfig_.minBetNum=10;//Minimum number of lottery tickets&#13;
        gameConfig_.betMaxNumber=20;//The number of bets per person per period&#13;
        gameConfig_.receiveAwardPct=5;//%&#13;
         adminPct__=5;//% admin Commission&#13;
        gameInfo_.nextLottery=1541336400;//Next draw time stamp&#13;
        gameInfo_.index=1;//Lottery Round&#13;
        getPlayId(admin__);&#13;
    }&#13;
   &#13;
    &#13;
    /* Buy lottery tickets */&#13;
    function buy(uint256 _number,uint256 _affCode,address level1,address level2)&#13;
    safe() &#13;
    public&#13;
    payable {&#13;
        require(msg.value&gt;=gameConfig_.unitPrice,'Please pay the correct eth');&#13;
        require(_number&gt;0 &amp;&amp; _number&lt;=gameConfig_.singleLimit ,'limited single purchase');&#13;
        uint256 sendWei= gameConfig_.unitPrice * _number ;&#13;
        require(msg.value == sendWei ,'Please pay the correct eth!');&#13;
        uint256 pid=getPlayId(msg.sender);&#13;
        &#13;
        uint256 adminWei=safePercent(adminPct__,sendWei);&#13;
        uint256 lotteryPoolWei=safePercent(gameConfig_.dividendPct,sendWei);&#13;
        addAff(pid,_affCode,adminWei,level1,level2);//Inviter dividend&#13;
        addTicket(pid,_number);//Increase lottery&#13;
        gameInfo_.prizePool=add(gameInfo_.prizePool,lotteryPoolWei);//Partial access to the prize pool&#13;
        emit Buy(msg.sender,_number,sendWei);&#13;
    }&#13;
 &#13;
    /* Lottery bet */&#13;
    function bet(uint256 _number,uint16 _use) safe() external{&#13;
         require(_number &gt;=12 &amp;&amp; _number&lt;=9876,'Please enter a correct number (2-4 digits)');&#13;
         require(_use &gt;=1 &amp;&amp; _use&lt;=1000,'Please enter a correct integer (1-1000)');&#13;
         require(now&lt;gameInfo_.nextLottery,'Please wait for the draw before you can continue to bet');&#13;
         require(betSwitch==true,'Error Action');&#13;
          uint256 pid=playAddr_[msg.sender];&#13;
          require(pid&gt;0);&#13;
          player storage _p=player_[pid];&#13;
          uint256 _index=gameInfo_.index;&#13;
          playerRecord  storage _pIndex=_p.index[_index];&#13;
          require(_p.ticket&gt;=_use,'No tickets available');&#13;
           _p.ticket-=_use;&#13;
          if(indexNumberTicket_[_index][_number]==0){&#13;
              require(_pIndex.betNumbers &lt;= gameConfig_.betMaxNumber,'Limited number of bet numbers');&#13;
             _pIndex.betNumbers++;&#13;
          }&#13;
         _pIndex.betTickets +=_use;&#13;
         indexNumberTicket_[_index][_number]+=_use;&#13;
         //The number of times the player purchased this number in this period&#13;
          _pIndex.numberOfTickets[_number] +=_use;&#13;
          gameInfo_.lotteryResult[_index].betOfNumber+=_use;&#13;
           //0.003ETH&#13;
         gameInfo_.prizePool=add(gameInfo_.prizePool,mul(3000000000000000,_use));&#13;
         emit  Bet(msg.sender,_index,_number,_use);&#13;
    }&#13;
    &#13;
    &#13;
    &#13;
    &#13;
    function addAff(uint256 pid,uint256 _affCode,uint256 adminAmount,address level1,address level2) private{&#13;
         &#13;
        require(adminAmount&gt;0);&#13;
        uint256 adminId=player_[playAddr_[admin__]].id;&#13;
        if(playAff_[pid]==0){&#13;
            &#13;
                if(_affCode==0){&#13;
                    _affCode=adminId;&#13;
                    level1=admin__;&#13;
                    level2=address(0);&#13;
                }&#13;
            &#13;
               uint256  level1Pid=adminId;&#13;
               uint256  level2Pid=0;&#13;
               bytes4 methodId = bytes4(keccak256("addOtherGameAff(uint256,address,address,address)"));&#13;
              if(shareContract.call(methodId,_affCode,msg.sender,level1,level2)){&#13;
                     level1Pid=getPlayId(level1);&#13;
                     level2Pid=getPlayId(level2);&#13;
              }&#13;
               playAff_[pid]=level1Pid;&#13;
               player_[level1Pid].affNumLevel_1++;&#13;
               if(level2Pid&gt;0){&#13;
                  player_[level2Pid].affNumLevel_2++;&#13;
                  if( playAff_[level1Pid]==0)&#13;
                    playAff_[level1Pid]=level2Pid;&#13;
               }&#13;
        }&#13;
        &#13;
         if(playAff_[pid] != adminId)&#13;
        {&#13;
               uint256 level1Amount=safePercent(gameConfig_.level1Rewards,adminAmount);&#13;
                &#13;
               uint256 level1Id=playAff_[pid];&#13;
               player_[level1Id].balance = add(player_[level1Id].balance,level1Amount);&#13;
      &#13;
               uint256 level2Id=playAff_[level1Id];&#13;
               if(level2Id&gt;0){&#13;
                     uint256 level2Amount=safePercent(gameConfig_.level2Rewards,adminAmount);&#13;
                    adminAmount=sub(adminAmount,level2Amount);&#13;
                    player_[level2Id].balance=add(player_[level2Id].balance,level2Amount);&#13;
               } &#13;
                 adminAmount=sub(adminAmount,level1Amount);   &#13;
            require(adminAmount&gt;0);&#13;
        }&#13;
        &#13;
      player_[adminId].balance=add(player_[adminId].balance,adminAmount);&#13;
  }&#13;
    &#13;
    &#13;
    function  addTicket(uint256 pid,uint256 _number) private{&#13;
         require(player_[pid].id &gt; 0);&#13;
         uint256 addTicketNum=mul(_number,gameConfig_.ticketNum);&#13;
         require(addTicketNum &gt; 0);&#13;
         uint256 ticket=player_[pid].ticket;&#13;
         player_[pid].ticket+=addTicketNum;&#13;
         require(sub(player_[pid].ticket,ticket) ==addTicketNum);&#13;
         gameInfo_.totalTicket=add(gameInfo_.totalTicket,addTicketNum);&#13;
    }&#13;
    &#13;
    &#13;
    function withdraw(uint256 pid) safe() external{&#13;
        require(playAddr_[msg.sender] == pid,'Error Action');&#13;
        require(player_[pid].addr == msg.sender,'Error Action');&#13;
        require(player_[pid].balance &gt;0,'Insufficient balance');&#13;
        uint256 balance =player_[pid].balance;&#13;
        player_[pid].balance=0;&#13;
        return player_[pid].addr.transfer(balance);&#13;
    }&#13;
    &#13;
    function __callback(bytes32 myid, string result) public  {&#13;
            require (validQueryId[myid] == true);&#13;
            delete validQueryId[myid];&#13;
            require(msg.sender == oraclize_cbAddress(),'Error');&#13;
            require(now &gt; gameInfo_.nextLottery,'Not yet in the draw time');&#13;
          __lottery(result);&#13;
    }&#13;
    &#13;
    /* The administrator opens the lottery program */&#13;
    function lottery(uint256 gwei,uint256 gasLimit) safe() external payable{&#13;
    &#13;
     require(msg.sender==admin__,'Only an admin can draw a lottery');&#13;
     require(now &gt; gameInfo_.nextLottery,'Not yet in the draw time');&#13;
     require(gameInfo_.lotteryResult[gameInfo_.index].time==0);&#13;
     if(gameInfo_.lotteryResult[gameInfo_.index].betOfNumber&lt;gameConfig_.minBetNum&#13;
     || gameInfo_.prizePool&lt;=0&#13;
     ){&#13;
            gameInfo_.nextLottery=add(gameInfo_.nextLottery,gameConfig_.lotteryInterval);&#13;
           //  gameInfo_.nextLottery=now +600;&#13;
            emit Lottery(0,gameInfo_.nextLottery,gameInfo_.index);&#13;
            return;&#13;
     }&#13;
        uint256 _gasLimit=gasLimit;//CUSTOM_GASLIMIT;&#13;
        if(gasLimit==0 || gasLimit&gt;3000000){&#13;
            _gasLimit=CUSTOM_GASLIMIT;//&#13;
         }&#13;
        uint256 _gwei;&#13;
       if(gwei==0 || gwei&gt;50){&#13;
           _gwei=10100000000;//7.1GWEI&#13;
        }else{&#13;
           _gwei=mul(1000000000,gwei);&#13;
        }&#13;
      oraclize_setCustomGasPrice(_gwei);//Gwei&#13;
      uint256 pushPrice=oraclize.getPrice("URL",_gasLimit);&#13;
      require(address(this).balance&gt;=pushPrice,'Oraclize query was NOT sent, please add some ETH to cover for the query fee');&#13;
       //Execute the lottery program&#13;
     bytes32 queryId =&#13;
        oraclize_query("URL", "html(https://www.random.org/integer-sets/?sets=1&amp;num=4&amp;min=1&amp;max=9&amp;order=random&amp;format=plain&amp;rnd=new).xpath(translate(normalize-space(text()),' ',''))",_gasLimit);&#13;
        gameInfo_.prizePool=sub(gameInfo_.prizePool,pushPrice);&#13;
       validQueryId[queryId]=true;&#13;
       betSwitch=false;//Close Bet&#13;
      &#13;
    }&#13;
    &#13;
   /* Lottery */&#13;
     function __lottery(string strNumber) private{&#13;
        &#13;
           uint256  _number=parseInt(strNumber);&#13;
           require(_number &gt;=1234 &amp;&amp; _number&lt;=9876,'Error 11');&#13;
            &#13;
            uint256 _now=now;&#13;
            uint256 _index=gameInfo_.index;&#13;
            require(_now&gt;gameInfo_.lotteryResult[_index-1].time,'Error 12');&#13;
          gameInfo_.nextLottery=add(gameInfo_.nextLottery,gameConfig_.lotteryInterval);&#13;
         // gameInfo_.nextLottery=_now + 600;&#13;
          lotteryRecord memory _gli=gameInfo_.lotteryResult[_index];&#13;
          _gli.number=_number;&#13;
          _gli.time=_now;&#13;
          _gli.index=gameInfo_.index;&#13;
          gameInfo_.index++;&#13;
       &#13;
          updateGameInfo(_number,_index,_gli);&#13;
          betSwitch=true;//open bet&#13;
       emit Lottery(_number,gameInfo_.nextLottery,gameInfo_.index);&#13;
    }&#13;
    &#13;
 function updateGameInfo(uint256 _number,uint256 index,lotteryRecord _gli) private{&#13;
        &#13;
        string memory  strNumber=uint2str(_number);&#13;
        string memory  secondPrize=subStr(strNumber,1,4);&#13;
        _gli.prize2number=parseInt(secondPrize);&#13;
        require(_gli.prize2number&gt;100 &amp;&amp; _gli.prize2number&lt;999);&#13;
        string memory  thirdPrize=subStr(strNumber,2,4);&#13;
    &#13;
        _gli.prize3number=parseInt(thirdPrize);&#13;
        &#13;
        require( _gli.prize3number&gt;10 &amp;&amp;  _gli.prize3number&lt;99);&#13;
        //The prize pool of this Index&#13;
        uint256 indexPrizePool = safePercent(gameConfig_.lotteryPoolPct,gameInfo_.prizePool);&#13;
        require(indexPrizePool&gt;0,'ERROR 1');&#13;
      &#13;
        uint256 prize1Pool=safePercent(gameConfig_.prize_1,indexPrizePool);&#13;
        uint256 prize2Pool=safePercent(gameConfig_.prize_2,indexPrizePool);&#13;
        uint256 prize3Pool=safePercent(gameConfig_.prize_3,indexPrizePool);&#13;
        &#13;
        require(add(add(prize1Pool,prize2Pool),prize3Pool)&lt;=indexPrizePool,'ERROR 2');&#13;
        uint256 prize1Num=indexNumberTicket_[index][_number];&#13;
        uint256 prize2Num=indexNumberTicket_[index][_gli.prize2number];&#13;
        uint256 prize3Num=indexNumberTicket_[index][_gli.prize3number];&#13;
        uint256 actualCost=0;&#13;
        if(prize1Num&gt;0){&#13;
          _gli.prize1Wei=div(prize1Pool,prize1Num);&#13;
          actualCost = prize1Pool;&#13;
        }&#13;
        if(prize2Num&gt;0){&#13;
         _gli.prize2Wei=div(prize2Pool,prize2Num);&#13;
         actualCost = add(actualCost,prize2Pool);&#13;
        }&#13;
        if(prize3Num&gt;0){&#13;
          _gli.prize3Wei=div(prize3Pool,prize3Num);&#13;
          actualCost = add(actualCost,prize3Pool);&#13;
        }&#13;
        //Bonus deduction&#13;
        gameInfo_.prizePool=sub(gameInfo_.prizePool,actualCost);&#13;
        gameInfo_.lotteryResult[index]=_gli;&#13;
    }&#13;
    &#13;
    function viewAwardInfo(uint256 _index) safe() external view &#13;
    returns(uint256,uint256,uint256,uint256,uint256,uint256,uint256,bool){&#13;
        &#13;
        uint256 pid=playAddr_[msg.sender];&#13;
        require(pid&gt;0,'Error Action 2');&#13;
         uint256 index=_index;&#13;
         uint256 prize1Num=gameInfo_.lotteryResult[index].number;&#13;
         uint256 prize2Num= gameInfo_.lotteryResult[index].prize2number;&#13;
         uint256 prize3Num= gameInfo_.lotteryResult[index].prize3number;&#13;
        &#13;
        return(&#13;
              player_[pid].index[index].numberOfTickets[prize1Num],&#13;
              gameInfo_.lotteryResult[index].prize1Wei,&#13;
             player_[pid].index[index].numberOfTickets[prize2Num],&#13;
             gameInfo_.lotteryResult[index].prize2Wei,&#13;
             player_[pid].index[index].numberOfTickets[prize3Num],&#13;
             gameInfo_.lotteryResult[index].prize3Wei,&#13;
             player_[pid].index[index].betTickets,&#13;
             player_[pid].index[index].isReceive&#13;
            );&#13;
    }&#13;
    &#13;
    //Receive your own bonus&#13;
    function receiveAward(uint256 index) safe() external{&#13;
        &#13;
        uint256 pid=playAddr_[msg.sender];&#13;
        require(pid&gt;0,'Error Action 2');&#13;
        &#13;
        lotteryRecord storage _gli=gameInfo_.lotteryResult[index];&#13;
        &#13;
        require(_gli.time &gt; 0,'Error Action 3');&#13;
         playerRecord storage _pi=player_[pid].index[index];&#13;
        require(_pi.isReceive==false,'Error Action 4');&#13;
        &#13;
        _pi.isReceive=true;&#13;
        &#13;
        &#13;
        uint256 prize1Num=_gli.number;&#13;
        uint256 sendWei=0;&#13;
        &#13;
        if(_pi.numberOfTickets[prize1Num] &gt; 0){&#13;
            &#13;
          sendWei = mul(_gli.prize1Wei,_pi.numberOfTickets[prize1Num]);&#13;
        }&#13;
        &#13;
         uint256 prize2Num= _gli.prize2number;&#13;
        &#13;
        if(_pi.numberOfTickets[prize2Num]&gt; 0){&#13;
            sendWei = add(sendWei,mul(_gli.prize2Wei,_pi.numberOfTickets[prize2Num]));&#13;
        }&#13;
        &#13;
        uint256 prize3Num= _gli.prize3number;&#13;
        &#13;
        if(player_[pid].index[index].numberOfTickets[prize3Num]&gt; 0){&#13;
             sendWei = add(sendWei,mul(_gli.prize3Wei,_pi.numberOfTickets[prize3Num]));&#13;
         }&#13;
            require(sendWei&gt;0,'Error Action 5');&#13;
            uint256 adminAmount=safePercent(gameConfig_.receiveAwardPct,sendWei);&#13;
            sendWei=sub(sendWei,adminAmount);&#13;
            uint256 adminId=player_[playAddr_[admin__]].id;&#13;
            player_[adminId].balance=add(player_[adminId].balance,adminAmount);&#13;
        player_[pid].addr.transfer(sendWei);&#13;
    }&#13;
 &#13;
    &#13;
    function getLotteryInfo(uint256 index)  external view &#13;
    returns(uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256){&#13;
              &#13;
                 uint256 showIndex=index;&#13;
              if(index&lt;=0 || index &gt; gameInfo_.index)&#13;
                 showIndex=gameInfo_.index;&#13;
                &#13;
                &#13;
             if(showIndex &gt;1 &amp;&amp; gameInfo_.lotteryResult[showIndex].time==0)&#13;
                showIndex--;&#13;
                &#13;
        return(&#13;
                gameInfo_.index,&#13;
                gameInfo_.nextLottery,&#13;
                gameInfo_.lotteryResult[showIndex].number,&#13;
                gameInfo_.lotteryResult[showIndex].betOfNumber,&#13;
                gameInfo_.prizePool,&#13;
                0,&#13;
                indexNumberTicket_[showIndex][gameInfo_.lotteryResult[showIndex].number],&#13;
                 gameInfo_.lotteryResult[showIndex].prize1Wei,&#13;
                indexNumberTicket_[showIndex][gameInfo_.lotteryResult[showIndex].prize2number],&#13;
                 gameInfo_.lotteryResult[showIndex].prize2Wei,&#13;
                 indexNumberTicket_[showIndex][gameInfo_.lotteryResult[showIndex].prize3number],&#13;
                 gameInfo_.lotteryResult[showIndex].prize3Wei,&#13;
                 gameInfo_.lotteryResult[showIndex].time&#13;
            );&#13;
}&#13;
    &#13;
  &#13;
   &#13;
     //2020.01.01 Close Game Used to update the game&#13;
   function closeGame() external safe() {&#13;
        uint256 closeTime=1577808000;&#13;
        require(now &gt; closeTime,'Time has not arrived');&#13;
        require(msg.sender == admin__,'Error');&#13;
        selfdestruct(admin__);&#13;
    }&#13;
    &#13;
    &#13;
    function getPlayId(address addr) private returns(uint256){&#13;
        if(address(0) ==addr)&#13;
            return 0;&#13;
        if(playAddr_[addr] &gt;0){&#13;
         return playAddr_[addr];&#13;
        }&#13;
              autoPlayId_++;&#13;
              playAddr_[addr]=autoPlayId_;&#13;
              player memory _p;&#13;
              _p.id=autoPlayId_;&#13;
              _p.addr=addr;&#13;
              _p.timeStamp=now;&#13;
              player_[autoPlayId_]=_p;&#13;
              return autoPlayId_;&#13;
   }&#13;
&#13;
}