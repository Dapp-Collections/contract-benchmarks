pragma solidity ^0.4.18;
/*
Author:     www.purplethrone.com
Email:      <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="4322392a3903333631332f26372b312c2d266d202c2e">[emailÂ protected]</a>&#13;
&#13;
&#13;
*/&#13;
// Math contract to avoid overflow and underflow of variables&#13;
contract SafeMath {&#13;
&#13;
    function safeAdd(uint256 x, uint256 y) internal returns(uint256) {&#13;
      uint256 z = x + y;&#13;
      assert((z &gt;= x) &amp;&amp; (z &gt;= y));&#13;
      return z;&#13;
    }&#13;
&#13;
    function safeSubtract(uint256 x, uint256 y) internal returns(uint256) {&#13;
      assert(x &gt;= y);&#13;
      uint256 z = x - y;&#13;
      return z;&#13;
    }&#13;
&#13;
    function safeMult(uint256 x, uint256 y) internal returns(uint256) {&#13;
      uint256 z = x * y;&#13;
      assert((x == 0)||(z/x == y));&#13;
      return z;&#13;
    }&#13;
&#13;
}&#13;
// Abstracct of ERC20 Token&#13;
contract Token {&#13;
    uint256 public totalSupply;&#13;
    function balanceOf(address _owner) constant returns (uint256 balance);&#13;
    function transfer(address _to, uint256 _value) returns (bool success);&#13;
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);&#13;
    function approve(address _spender, uint256 _value) returns (bool success);&#13;
    function allowance(address _owner, address _spender) constant returns (uint256 remaining);&#13;
    event Transfer(address indexed _from, address indexed _to, uint256 _value);&#13;
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);&#13;
}&#13;
&#13;
&#13;
/*  Implementation of ERC20 token standard functions */&#13;
contract StandardToken is Token {&#13;
&#13;
    function transfer(address _to, uint256 _value) returns (bool success) {&#13;
      if (balances[msg.sender] &gt;= _value &amp;&amp; _value &gt; 0) {&#13;
        balances[msg.sender] -= _value;&#13;
        balances[_to] += _value;&#13;
        Transfer(msg.sender, _to, _value);&#13;
        return true;&#13;
      } else {&#13;
        return false;&#13;
      }&#13;
    }&#13;
&#13;
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {&#13;
      if (balances[_from] &gt;= _value &amp;&amp; allowed[_from][msg.sender] &gt;= _value &amp;&amp; _value &gt; 0) {&#13;
        balances[_to] += _value;&#13;
        balances[_from] -= _value;&#13;
        allowed[_from][msg.sender] -= _value;&#13;
        Transfer(_from, _to, _value);&#13;
        return true;&#13;
      } else {&#13;
        return false;&#13;
      }&#13;
    }&#13;
&#13;
    function balanceOf(address _owner) constant returns (uint256 balance) {&#13;
        return balances[_owner];&#13;
    }&#13;
&#13;
    function approve(address _spender, uint256 _value) returns (bool success) {&#13;
        allowed[msg.sender][_spender] = _value;&#13;
        Approval(msg.sender, _spender, _value);&#13;
        return true;&#13;
    }&#13;
&#13;
    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {&#13;
      return allowed[_owner][_spender];&#13;
    }&#13;
&#13;
    mapping (address =&gt; uint256) balances;&#13;
    mapping (address =&gt; mapping (address =&gt; uint256)) allowed;&#13;
}&#13;
&#13;
contract Ownable {&#13;
  address public owner;&#13;
&#13;
/**&#13;
* @dev The Ownable constructor sets the original `owner` of the contract to the sender&#13;
* account.&#13;
*/&#13;
function Ownable() {&#13;
  owner = msg.sender;&#13;
}&#13;
/**&#13;
* @dev Throws if called by any account other than the owner.&#13;
*/&#13;
modifier onlyOwner() {&#13;
  require(msg.sender == owner);&#13;
_;&#13;
}&#13;
/**&#13;
* @dev Allows the current owner to transfer control of the contract to a newOwner.&#13;
* @param newOwner The address to transfer ownership to.&#13;
*/&#13;
function transferOwnership(address newOwner) onlyOwner {&#13;
  if (newOwner != address(0)) {&#13;
      owner = newOwner;&#13;
  }&#13;
}&#13;
&#13;
}&#13;
&#13;
&#13;
contract PPCToken is StandardToken,Ownable, SafeMath {&#13;
&#13;
    // crowdsale parameters&#13;
    string  public constant name = "PPCCoin";&#13;
    string  public constant symbol = "PPC";&#13;
    uint256 public constant decimals = 18;&#13;
    string  public version = "1.0";&#13;
    address public constant ethFundDeposit= 0x20D9053d3f7fccC069c9a8e7dDEf5374CD22b6C8;                         // Deposit address for ETH&#13;
    bool public emergencyFlag;                                      //  Switched to true in  crownsale end  state&#13;
    uint256 public fundingStartBlock;                              //   Starting blocknumber&#13;
    uint256 public fundingEndBlock;                               //    Ending blocknumber&#13;
    uint256 public constant minTokenPurchaseAmount= .008 ether;  //     Minimum purchase&#13;
    uint256 public constant tokenPreSaleRate=800;    // PPCCoin per 1 ETH during presale&#13;
    uint256 public constant tokenCrowdsaleRate=500; //  PPCCoin per 1 ETH during crowdsale&#13;
    uint256 public constant tokenCreationPreSaleCap =  10 * (10**6) * 10**decimals;// 10 million token cap for presale&#13;
    uint256 public constant tokenCreationCap =  100 * (10**6) * 10**decimals;      //  100 million token generated&#13;
    uint256 public constant preSaleBlockNumber = 169457;&#13;
    uint256 public finalBlockNumber =370711;&#13;
&#13;
&#13;
    // events&#13;
    event CreatePPC(address indexed _to, uint256 _value);// Return address of buyer and purchase token&#13;
    event Mint(address indexed _to,uint256 _value);     //  Reutn address to which we send the mint token and token assigned.&#13;
    // Constructor&#13;
    function PPCToken(){&#13;
      emergencyFlag = false;                             // False at initialization will be false during ICO&#13;
      fundingStartBlock = block.number;                 //  Current deploying block number is the starting block number for ICO&#13;
      fundingEndBlock=safeAdd(fundingStartBlock,finalBlockNumber);  //   Ending time depending upon the block number&#13;
    }&#13;
&#13;
    /**&#13;
    * @dev creates new PPC tokens&#13;
    *      It is a internal function it will be called by fallback function or buyToken functions.&#13;
    */&#13;
    function createTokens() internal  {&#13;
      if (emergencyFlag) revert();                     //  Revert when the sale is over before time and emergencyFlag is true.&#13;
      if (block.number &gt; fundingEndBlock) revert();   //   If the blocknumber exceed the ending block it will revert&#13;
      if (msg.value&lt;minTokenPurchaseAmount)revert();  //    If someone send 0.08 ether it will fail&#13;
      uint256 tokenExchangeRate=tokenRate();        //     It will get value depending upon block number and presale cap&#13;
      uint256 tokens = safeMult(msg.value, tokenExchangeRate);//  Calculating number of token for sender&#13;
      totalSupply = safeAdd(totalSupply, tokens);            //   Add token to total supply&#13;
      if(totalSupply&gt;tokenCreationCap)revert();             //    Check the total supply if it is more then hardcap it will throw&#13;
      balances[msg.sender] += tokens;                      //     Adding token to sender account&#13;
      forwardfunds();                                     //      forwardfunds to the owner&#13;
      CreatePPC(msg.sender, tokens);                      //      Logs sender address and  token creation&#13;
    }&#13;
&#13;
    /**&#13;
    * @dev people can access contract and choose buyToken function to get token&#13;
    *It is used by using myetherwallet&#13;
    *It is a payable function it will be called by sender.&#13;
    */&#13;
    function buyToken() payable external{&#13;
      createTokens();   // This will call the internal createToken function to get token&#13;
    }&#13;
&#13;
    /**&#13;
    * @dev      it is a internal function called by create function to get the amount according to the blocknumber.&#13;
    * @return   It will return the token price at a particular time.&#13;
    */&#13;
    function tokenRate() internal returns (uint256 _tokenPrice){&#13;
      // It is a presale it will return price for presale&#13;
      if(block.number&lt;safeAdd(fundingStartBlock,preSaleBlockNumber)&amp;&amp;(totalSupply&lt;tokenCreationPreSaleCap)){&#13;
          return tokenPreSaleRate;&#13;
        }else&#13;
            return tokenCrowdsaleRate;&#13;
    }&#13;
&#13;
    /**&#13;
    * @dev     it will  assign token to a particular address by owner only&#13;
    * @param   _to the address whom you want to send token to&#13;
    * @param   _amount the amount you want to send&#13;
    * @return  It will return true if success.&#13;
    */&#13;
    function mint(address _to, uint256 _amount) external onlyOwner returns (bool) {&#13;
      if (emergencyFlag) revert();&#13;
      totalSupply = safeAdd(totalSupply,_amount);// Add the minted token to total suppy&#13;
      if(totalSupply&gt;tokenCreationCap)revert();&#13;
      balances[_to] +=_amount;                 //   Adding token to the input address&#13;
      Mint(_to, _amount);                     //    Log the mint with address and token given to particular address&#13;
      return true;&#13;
    }&#13;
&#13;
    /**&#13;
    * @dev     it will change the ending date of ico and access by owner only&#13;
    * @param   _newBlock enter the future blocknumber&#13;
    * @return  It will return the blocknumber&#13;
    */&#13;
    function changeEndBlock(uint256 _newBlock) external onlyOwner returns (uint256 _endblock )&#13;
    {   // we are expecting that owner will input number greater than current block.&#13;
        require(_newBlock &gt; fundingStartBlock);&#13;
        fundingEndBlock = _newBlock;         // New block is assigned to extend the Crowd Sale time&#13;
        return fundingEndBlock;&#13;
    }&#13;
&#13;
    /**&#13;
    * @dev   it will let Owner withdrawn ether at any time during the ICO&#13;
    **/&#13;
    function drain() external onlyOwner {&#13;
        if (!ethFundDeposit.send(this.balance)) revert();// It will revert if transfer fails.&#13;
    }&#13;
&#13;
    &#13;
    &#13;
    // Automate the ETH drain&#13;
    &#13;
    function forwardfunds() internal {&#13;
         if (!ethFundDeposit.send(this.balance)) revert(); // It will revert if transfer fails.&#13;
        &#13;
        &#13;
    }&#13;
    &#13;
    /**&#13;
    * @dev  it will let Owner Stop the crowdsale and mint function to work.&#13;
    *&#13;
    */&#13;
    &#13;
    function emergencyToggle() external onlyOwner{&#13;
      emergencyFlag = !emergencyFlag;&#13;
    }&#13;
&#13;
    // Fallback function let user send ether without calling the buy function.&#13;
    function() payable {&#13;
      createTokens();&#13;
&#13;
    }&#13;
&#13;
&#13;
}