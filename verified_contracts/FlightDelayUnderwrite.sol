/*
 * @title String & slice utility library for Solidity contracts.
 * @author Nick Johnson <<span class="__cf_email__" data-cfemail="d3b2a1b2b0bbbdbab793bdbca7b7bca7fdbdb6a7">[emailÂ protected]</span>&gt;&#13;
 *&#13;
 * @dev Functionality in this library is largely implemented using an&#13;
 *      abstraction called a 'slice'. A slice represents a part of a string -&#13;
 *      anything from the entire string to a single character, or even no&#13;
 *      characters at all (a 0-length slice). Since a slice only has to specify&#13;
 *      an offset and a length, copying and manipulating slices is a lot less&#13;
 *      expensive than copying and manipulating the strings they reference.&#13;
 *&#13;
 *      To further reduce gas costs, most functions on slice that need to return&#13;
 *      a slice modify the original one instead of allocating a new one; for&#13;
 *      instance, `s.split(".")` will return the text up to the first '.',&#13;
 *      modifying s to only contain the remainder of the string after the '.'.&#13;
 *      In situations where you do not want to modify the original slice, you&#13;
 *      can make a copy first with `.copy()`, for example:&#13;
 *      `s.copy().split(".")`. Try and avoid using this idiom in loops; since&#13;
 *      Solidity has no memory management, it will result in allocating many&#13;
 *      short-lived slices that are later discarded.&#13;
 *&#13;
 *      Functions that return two slices come in two versions: a non-allocating&#13;
 *      version that takes the second slice as an argument, modifying it in&#13;
 *      place, and an allocating version that allocates and returns the second&#13;
 *      slice; see `nextRune` for example.&#13;
 *&#13;
 *      Functions that have to copy string data will return strings rather than&#13;
 *      slices; these can be cast back to slices for further processing if&#13;
 *      required.&#13;
 *&#13;
 *      For convenience, some functions are provided with non-modifying&#13;
 *      variants that create a new slice and return both; for instance,&#13;
 *      `s.splitNew('.')` leaves s unmodified, and returns two values&#13;
 *      corresponding to the left and right parts of the string.&#13;
 */&#13;
&#13;
pragma solidity ^0.4.7;&#13;
&#13;
library strings {&#13;
    struct slice {&#13;
        uint _len;&#13;
        uint _ptr;&#13;
    }&#13;
&#13;
    function memcpy(uint dest, uint src, uint len) private {&#13;
        // Copy word-length chunks while possible&#13;
        for(; len &gt;= 32; len -= 32) {&#13;
            assembly {&#13;
                mstore(dest, mload(src))&#13;
            }&#13;
            dest += 32;&#13;
            src += 32;&#13;
        }&#13;
&#13;
        // Copy remaining bytes&#13;
        uint mask = 256 ** (32 - len) - 1;&#13;
        assembly {&#13;
            let srcpart := and(mload(src), not(mask))&#13;
            let destpart := and(mload(dest), mask)&#13;
            mstore(dest, or(destpart, srcpart))&#13;
        }&#13;
    }&#13;
&#13;
    /*&#13;
     * @dev Returns a slice containing the entire string.&#13;
     * @param self The string to make a slice from.&#13;
     * @return A newly allocated slice containing the entire string.&#13;
     */&#13;
    function toSlice(string self) internal returns (slice) {&#13;
        uint ptr;&#13;
        assembly {&#13;
            ptr := add(self, 0x20)&#13;
        }&#13;
        return slice(bytes(self).length, ptr);&#13;
    }&#13;
&#13;
    /*&#13;
     * @dev Returns the length of a null-terminated bytes32 string.&#13;
     * @param self The value to find the length of.&#13;
     * @return The length of the string, from 0 to 32.&#13;
     */&#13;
    function len(bytes32 self) internal returns (uint) {&#13;
        uint ret;&#13;
        if (self == 0)&#13;
            return 0;&#13;
        if (self &amp; 0xffffffffffffffffffffffffffffffff == 0) {&#13;
            ret += 16;&#13;
            self = bytes32(uint(self) / 0x100000000000000000000000000000000);&#13;
        }&#13;
        if (self &amp; 0xffffffffffffffff == 0) {&#13;
            ret += 8;&#13;
            self = bytes32(uint(self) / 0x10000000000000000);&#13;
        }&#13;
        if (self &amp; 0xffffffff == 0) {&#13;
            ret += 4;&#13;
            self = bytes32(uint(self) / 0x100000000);&#13;
        }&#13;
        if (self &amp; 0xffff == 0) {&#13;
            ret += 2;&#13;
            self = bytes32(uint(self) / 0x10000);&#13;
        }&#13;
        if (self &amp; 0xff == 0) {&#13;
            ret += 1;&#13;
        }&#13;
        return 32 - ret;&#13;
    }&#13;
&#13;
    /*&#13;
     * @dev Returns a slice containing the entire bytes32, interpreted as a&#13;
     *      null-termintaed utf-8 string.&#13;
     * @param self The bytes32 value to convert to a slice.&#13;
     * @return A new slice containing the value of the input argument up to the&#13;
     *         first null.&#13;
     */&#13;
    function toSliceB32(bytes32 self) internal returns (slice ret) {&#13;
        // Allocate space for `self` in memory, copy it there, and point ret at it&#13;
        assembly {&#13;
            let ptr := mload(0x40)&#13;
            mstore(0x40, add(ptr, 0x20))&#13;
            mstore(ptr, self)&#13;
            mstore(add(ret, 0x20), ptr)&#13;
        }&#13;
        ret._len = len(self);&#13;
    }&#13;
&#13;
    /*&#13;
     * @dev Returns a new slice containing the same data as the current slice.&#13;
     * @param self The slice to copy.&#13;
     * @return A new slice containing the same data as `self`.&#13;
     */&#13;
    function copy(slice self) internal returns (slice) {&#13;
        return slice(self._len, self._ptr);&#13;
    }&#13;
&#13;
    /*&#13;
     * @dev Copies a slice to a new string.&#13;
     * @param self The slice to copy.&#13;
     * @return A newly allocated string containing the slice's text.&#13;
     */&#13;
    function toString(slice self) internal returns (string) {&#13;
        var ret = new string(self._len);&#13;
        uint retptr;&#13;
        assembly { retptr := add(ret, 32) }&#13;
&#13;
        memcpy(retptr, self._ptr, self._len);&#13;
        return ret;&#13;
    }&#13;
&#13;
    /*&#13;
     * @dev Returns the length in runes of the slice. Note that this operation&#13;
     *      takes time proportional to the length of the slice; avoid using it&#13;
     *      in loops, and call `slice.empty()` if you only need to know whether&#13;
     *      the slice is empty or not.&#13;
     * @param self The slice to operate on.&#13;
     * @return The length of the slice in runes.&#13;
     */&#13;
    function len(slice self) internal returns (uint) {&#13;
        // Starting at ptr-31 means the LSB will be the byte we care about&#13;
        var ptr = self._ptr - 31;&#13;
        var end = ptr + self._len;&#13;
        for (uint len = 0; ptr &lt; end; len++) {&#13;
            uint8 b;&#13;
            assembly { b := and(mload(ptr), 0xFF) }&#13;
            if (b &lt; 0x80) {&#13;
                ptr += 1;&#13;
            } else if(b &lt; 0xE0) {&#13;
                ptr += 2;&#13;
            } else if(b &lt; 0xF0) {&#13;
                ptr += 3;&#13;
            } else if(b &lt; 0xF8) {&#13;
                ptr += 4;&#13;
            } else if(b &lt; 0xFC) {&#13;
                ptr += 5;&#13;
            } else {&#13;
                ptr += 6;&#13;
            }&#13;
        }&#13;
        return len;&#13;
    }&#13;
&#13;
    /*&#13;
     * @dev Returns true if the slice is empty (has a length of 0).&#13;
     * @param self The slice to operate on.&#13;
     * @return True if the slice is empty, False otherwise.&#13;
     */&#13;
    function empty(slice self) internal returns (bool) {&#13;
        return self._len == 0;&#13;
    }&#13;
&#13;
    /*&#13;
     * @dev Returns a positive number if `other` comes lexicographically after&#13;
     *      `self`, a negative number if it comes before, or zero if the&#13;
     *      contents of the two slices are equal. Comparison is done per-rune,&#13;
     *      on unicode codepoints.&#13;
     * @param self The first slice to compare.&#13;
     * @param other The second slice to compare.&#13;
     * @return The result of the comparison.&#13;
     */&#13;
    function compare(slice self, slice other) internal returns (int) {&#13;
        uint shortest = self._len;&#13;
        if (other._len &lt; self._len)&#13;
            shortest = other._len;&#13;
&#13;
        var selfptr = self._ptr;&#13;
        var otherptr = other._ptr;&#13;
        for (uint idx = 0; idx &lt; shortest; idx += 32) {&#13;
            uint a;&#13;
            uint b;&#13;
            assembly {&#13;
                a := mload(selfptr)&#13;
                b := mload(otherptr)&#13;
            }&#13;
            if (a != b) {&#13;
                // Mask out irrelevant bytes and check again&#13;
                uint mask = ~(2 ** (8 * (32 - shortest + idx)) - 1);&#13;
                var diff = (a &amp; mask) - (b &amp; mask);&#13;
                if (diff != 0)&#13;
                    return int(diff);&#13;
            }&#13;
            selfptr += 32;&#13;
            otherptr += 32;&#13;
        }&#13;
        return int(self._len) - int(other._len);&#13;
    }&#13;
&#13;
    /*&#13;
     * @dev Returns true if the two slices contain the same text.&#13;
     * @param self The first slice to compare.&#13;
     * @param self The second slice to compare.&#13;
     * @return True if the slices are equal, false otherwise.&#13;
     */&#13;
    function equals(slice self, slice other) internal returns (bool) {&#13;
        return compare(self, other) == 0;&#13;
    }&#13;
&#13;
    /*&#13;
     * @dev Extracts the first rune in the slice into `rune`, advancing the&#13;
     *      slice to point to the next rune and returning `self`.&#13;
     * @param self The slice to operate on.&#13;
     * @param rune The slice that will contain the first rune.&#13;
     * @return `rune`.&#13;
     */&#13;
    function nextRune(slice self, slice rune) internal returns (slice) {&#13;
        rune._ptr = self._ptr;&#13;
&#13;
        if (self._len == 0) {&#13;
            rune._len = 0;&#13;
            return rune;&#13;
        }&#13;
&#13;
        uint len;&#13;
        uint b;&#13;
        // Load the first byte of the rune into the LSBs of b&#13;
        assembly { b := and(mload(sub(mload(add(self, 32)), 31)), 0xFF) }&#13;
        if (b &lt; 0x80) {&#13;
            len = 1;&#13;
        } else if(b &lt; 0xE0) {&#13;
            len = 2;&#13;
        } else if(b &lt; 0xF0) {&#13;
            len = 3;&#13;
        } else {&#13;
            len = 4;&#13;
        }&#13;
&#13;
        // Check for truncated codepoints&#13;
        if (len &gt; self._len) {&#13;
            rune._len = self._len;&#13;
            self._ptr += self._len;&#13;
            self._len = 0;&#13;
            return rune;&#13;
        }&#13;
&#13;
        self._ptr += len;&#13;
        self._len -= len;&#13;
        rune._len = len;&#13;
        return rune;&#13;
    }&#13;
&#13;
    /*&#13;
     * @dev Returns the first rune in the slice, advancing the slice to point&#13;
     *      to the next rune.&#13;
     * @param self The slice to operate on.&#13;
     * @return A slice containing only the first rune from `self`.&#13;
     */&#13;
    function nextRune(slice self) internal returns (slice ret) {&#13;
        nextRune(self, ret);&#13;
    }&#13;
&#13;
    /*&#13;
     * @dev Returns the number of the first codepoint in the slice.&#13;
     * @param self The slice to operate on.&#13;
     * @return The number of the first codepoint in the slice.&#13;
     */&#13;
    function ord(slice self) internal returns (uint ret) {&#13;
        if (self._len == 0) {&#13;
            return 0;&#13;
        }&#13;
&#13;
        uint word;&#13;
        uint len;&#13;
        uint div = 2 ** 248;&#13;
&#13;
        // Load the rune into the MSBs of b&#13;
        assembly { word:= mload(mload(add(self, 32))) }&#13;
        var b = word / div;&#13;
        if (b &lt; 0x80) {&#13;
            ret = b;&#13;
            len = 1;&#13;
        } else if(b &lt; 0xE0) {&#13;
            ret = b &amp; 0x1F;&#13;
            len = 2;&#13;
        } else if(b &lt; 0xF0) {&#13;
            ret = b &amp; 0x0F;&#13;
            len = 3;&#13;
        } else {&#13;
            ret = b &amp; 0x07;&#13;
            len = 4;&#13;
        }&#13;
&#13;
        // Check for truncated codepoints&#13;
        if (len &gt; self._len) {&#13;
            return 0;&#13;
        }&#13;
&#13;
        for (uint i = 1; i &lt; len; i++) {&#13;
            div = div / 256;&#13;
            b = (word / div) &amp; 0xFF;&#13;
            if (b &amp; 0xC0 != 0x80) {&#13;
                // Invalid UTF-8 sequence&#13;
                return 0;&#13;
            }&#13;
            ret = (ret * 64) | (b &amp; 0x3F);&#13;
        }&#13;
&#13;
        return ret;&#13;
    }&#13;
&#13;
    /*&#13;
     * @dev Returns the keccak-256 hash of the slice.&#13;
     * @param self The slice to hash.&#13;
     * @return The hash of the slice.&#13;
     */&#13;
    function keccak(slice self) internal returns (bytes32 ret) {&#13;
        assembly {&#13;
            ret := sha3(mload(add(self, 32)), mload(self))&#13;
        }&#13;
    }&#13;
&#13;
    /*&#13;
     * @dev Returns true if `self` starts with `needle`.&#13;
     * @param self The slice to operate on.&#13;
     * @param needle The slice to search for.&#13;
     * @return True if the slice starts with the provided text, false otherwise.&#13;
     */&#13;
    function startsWith(slice self, slice needle) internal returns (bool) {&#13;
        if (self._len &lt; needle._len) {&#13;
            return false;&#13;
        }&#13;
&#13;
        if (self._ptr == needle._ptr) {&#13;
            return true;&#13;
        }&#13;
&#13;
        bool equal;&#13;
        assembly {&#13;
            let len := mload(needle)&#13;
            let selfptr := mload(add(self, 0x20))&#13;
            let needleptr := mload(add(needle, 0x20))&#13;
            equal := eq(sha3(selfptr, len), sha3(needleptr, len))&#13;
        }&#13;
        return equal;&#13;
    }&#13;
&#13;
    /*&#13;
     * @dev If `self` starts with `needle`, `needle` is removed from the&#13;
     *      beginning of `self`. Otherwise, `self` is unmodified.&#13;
     * @param self The slice to operate on.&#13;
     * @param needle The slice to search for.&#13;
     * @return `self`&#13;
     */&#13;
    function beyond(slice self, slice needle) internal returns (slice) {&#13;
        if (self._len &lt; needle._len) {&#13;
            return self;&#13;
        }&#13;
&#13;
        bool equal = true;&#13;
        if (self._ptr != needle._ptr) {&#13;
            assembly {&#13;
                let len := mload(needle)&#13;
                let selfptr := mload(add(self, 0x20))&#13;
                let needleptr := mload(add(needle, 0x20))&#13;
                equal := eq(sha3(selfptr, len), sha3(needleptr, len))&#13;
            }&#13;
        }&#13;
&#13;
        if (equal) {&#13;
            self._len -= needle._len;&#13;
            self._ptr += needle._len;&#13;
        }&#13;
&#13;
        return self;&#13;
    }&#13;
&#13;
    /*&#13;
     * @dev Returns true if the slice ends with `needle`.&#13;
     * @param self The slice to operate on.&#13;
     * @param needle The slice to search for.&#13;
     * @return True if the slice starts with the provided text, false otherwise.&#13;
     */&#13;
    function endsWith(slice self, slice needle) internal returns (bool) {&#13;
        if (self._len &lt; needle._len) {&#13;
            return false;&#13;
        }&#13;
&#13;
        var selfptr = self._ptr + self._len - needle._len;&#13;
&#13;
        if (selfptr == needle._ptr) {&#13;
            return true;&#13;
        }&#13;
&#13;
        bool equal;&#13;
        assembly {&#13;
            let len := mload(needle)&#13;
            let needleptr := mload(add(needle, 0x20))&#13;
            equal := eq(sha3(selfptr, len), sha3(needleptr, len))&#13;
        }&#13;
&#13;
        return equal;&#13;
    }&#13;
&#13;
    /*&#13;
     * @dev If `self` ends with `needle`, `needle` is removed from the&#13;
     *      end of `self`. Otherwise, `self` is unmodified.&#13;
     * @param self The slice to operate on.&#13;
     * @param needle The slice to search for.&#13;
     * @return `self`&#13;
     */&#13;
    function until(slice self, slice needle) internal returns (slice) {&#13;
        if (self._len &lt; needle._len) {&#13;
            return self;&#13;
        }&#13;
&#13;
        var selfptr = self._ptr + self._len - needle._len;&#13;
        bool equal = true;&#13;
        if (selfptr != needle._ptr) {&#13;
            assembly {&#13;
                let len := mload(needle)&#13;
                let needleptr := mload(add(needle, 0x20))&#13;
                equal := eq(sha3(selfptr, len), sha3(needleptr, len))&#13;
            }&#13;
        }&#13;
&#13;
        if (equal) {&#13;
            self._len -= needle._len;&#13;
        }&#13;
&#13;
        return self;&#13;
    }&#13;
&#13;
    // Returns the memory address of the first byte of the first occurrence of&#13;
    // `needle` in `self`, or the first byte after `self` if not found.&#13;
    function findPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private returns (uint) {&#13;
        uint ptr;&#13;
        uint idx;&#13;
&#13;
        if (needlelen &lt;= selflen) {&#13;
            if (needlelen &lt;= 32) {&#13;
                // Optimized assembly for 68 gas per byte on short strings&#13;
                assembly {&#13;
                    let mask := not(sub(exp(2, mul(8, sub(32, needlelen))), 1))&#13;
                    let needledata := and(mload(needleptr), mask)&#13;
                    let end := add(selfptr, sub(selflen, needlelen))&#13;
                    ptr := selfptr&#13;
                    loop:&#13;
                    jumpi(exit, eq(and(mload(ptr), mask), needledata))&#13;
                    ptr := add(ptr, 1)&#13;
                    jumpi(loop, lt(sub(ptr, 1), end))&#13;
                    ptr := add(selfptr, selflen)&#13;
                    exit:&#13;
                }&#13;
                return ptr;&#13;
            } else {&#13;
                // For long needles, use hashing&#13;
                bytes32 hash;&#13;
                assembly { hash := sha3(needleptr, needlelen) }&#13;
                ptr = selfptr;&#13;
                for (idx = 0; idx &lt;= selflen - needlelen; idx++) {&#13;
                    bytes32 testHash;&#13;
                    assembly { testHash := sha3(ptr, needlelen) }&#13;
                    if (hash == testHash)&#13;
                        return ptr;&#13;
                    ptr += 1;&#13;
                }&#13;
            }&#13;
        }&#13;
        return selfptr + selflen;&#13;
    }&#13;
&#13;
    // Returns the memory address of the first byte after the last occurrence of&#13;
    // `needle` in `self`, or the address of `self` if not found.&#13;
    function rfindPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private returns (uint) {&#13;
        uint ptr;&#13;
&#13;
        if (needlelen &lt;= selflen) {&#13;
            if (needlelen &lt;= 32) {&#13;
                // Optimized assembly for 69 gas per byte on short strings&#13;
                assembly {&#13;
                    let mask := not(sub(exp(2, mul(8, sub(32, needlelen))), 1))&#13;
                    let needledata := and(mload(needleptr), mask)&#13;
                    ptr := add(selfptr, sub(selflen, needlelen))&#13;
                    loop:&#13;
                    jumpi(ret, eq(and(mload(ptr), mask), needledata))&#13;
                    ptr := sub(ptr, 1)&#13;
                    jumpi(loop, gt(add(ptr, 1), selfptr))&#13;
                    ptr := selfptr&#13;
                    jump(exit)&#13;
                    ret:&#13;
                    ptr := add(ptr, needlelen)&#13;
                    exit:&#13;
                }&#13;
                return ptr;&#13;
            } else {&#13;
                // For long needles, use hashing&#13;
                bytes32 hash;&#13;
                assembly { hash := sha3(needleptr, needlelen) }&#13;
                ptr = selfptr + (selflen - needlelen);&#13;
                while (ptr &gt;= selfptr) {&#13;
                    bytes32 testHash;&#13;
                    assembly { testHash := sha3(ptr, needlelen) }&#13;
                    if (hash == testHash)&#13;
                        return ptr + needlelen;&#13;
                    ptr -= 1;&#13;
                }&#13;
            }&#13;
        }&#13;
        return selfptr;&#13;
    }&#13;
&#13;
    /*&#13;
     * @dev Modifies `self` to contain everything from the first occurrence of&#13;
     *      `needle` to the end of the slice. `self` is set to the empty slice&#13;
     *      if `needle` is not found.&#13;
     * @param self The slice to search and modify.&#13;
     * @param needle The text to search for.&#13;
     * @return `self`.&#13;
     */&#13;
    function find(slice self, slice needle) internal returns (slice) {&#13;
        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr);&#13;
        self._len -= ptr - self._ptr;&#13;
        self._ptr = ptr;&#13;
        return self;&#13;
    }&#13;
&#13;
    /*&#13;
     * @dev Modifies `self` to contain the part of the string from the start of&#13;
     *      `self` to the end of the first occurrence of `needle`. If `needle`&#13;
     *      is not found, `self` is set to the empty slice.&#13;
     * @param self The slice to search and modify.&#13;
     * @param needle The text to search for.&#13;
     * @return `self`.&#13;
     */&#13;
    function rfind(slice self, slice needle) internal returns (slice) {&#13;
        uint ptr = rfindPtr(self._len, self._ptr, needle._len, needle._ptr);&#13;
        self._len = ptr - self._ptr;&#13;
        return self;&#13;
    }&#13;
&#13;
    /*&#13;
     * @dev Splits the slice, setting `self` to everything after the first&#13;
     *      occurrence of `needle`, and `token` to everything before it. If&#13;
     *      `needle` does not occur in `self`, `self` is set to the empty slice,&#13;
     *      and `token` is set to the entirety of `self`.&#13;
     * @param self The slice to split.&#13;
     * @param needle The text to search for in `self`.&#13;
     * @param token An output parameter to which the first token is written.&#13;
     * @return `token`.&#13;
     */&#13;
    function split(slice self, slice needle, slice token) internal returns (slice) {&#13;
        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr);&#13;
        token._ptr = self._ptr;&#13;
        token._len = ptr - self._ptr;&#13;
        if (ptr == self._ptr + self._len) {&#13;
            // Not found&#13;
            self._len = 0;&#13;
        } else {&#13;
            self._len -= token._len + needle._len;&#13;
            self._ptr = ptr + needle._len;&#13;
        }&#13;
        return token;&#13;
    }&#13;
&#13;
    /*&#13;
     * @dev Splits the slice, setting `self` to everything after the first&#13;
     *      occurrence of `needle`, and returning everything before it. If&#13;
     *      `needle` does not occur in `self`, `self` is set to the empty slice,&#13;
     *      and the entirety of `self` is returned.&#13;
     * @param self The slice to split.&#13;
     * @param needle The text to search for in `self`.&#13;
     * @return The part of `self` up to the first occurrence of `delim`.&#13;
     */&#13;
    function split(slice self, slice needle) internal returns (slice token) {&#13;
        split(self, needle, token);&#13;
    }&#13;
&#13;
    /*&#13;
     * @dev Splits the slice, setting `self` to everything before the last&#13;
     *      occurrence of `needle`, and `token` to everything after it. If&#13;
     *      `needle` does not occur in `self`, `self` is set to the empty slice,&#13;
     *      and `token` is set to the entirety of `self`.&#13;
     * @param self The slice to split.&#13;
     * @param needle The text to search for in `self`.&#13;
     * @param token An output parameter to which the first token is written.&#13;
     * @return `token`.&#13;
     */&#13;
    function rsplit(slice self, slice needle, slice token) internal returns (slice) {&#13;
        uint ptr = rfindPtr(self._len, self._ptr, needle._len, needle._ptr);&#13;
        token._ptr = ptr;&#13;
        token._len = self._len - (ptr - self._ptr);&#13;
        if (ptr == self._ptr) {&#13;
            // Not found&#13;
            self._len = 0;&#13;
        } else {&#13;
            self._len -= token._len + needle._len;&#13;
        }&#13;
        return token;&#13;
    }&#13;
&#13;
    /*&#13;
     * @dev Splits the slice, setting `self` to everything before the last&#13;
     *      occurrence of `needle`, and returning everything after it. If&#13;
     *      `needle` does not occur in `self`, `self` is set to the empty slice,&#13;
     *      and the entirety of `self` is returned.&#13;
     * @param self The slice to split.&#13;
     * @param needle The text to search for in `self`.&#13;
     * @return The part of `self` after the last occurrence of `delim`.&#13;
     */&#13;
    function rsplit(slice self, slice needle) internal returns (slice token) {&#13;
        rsplit(self, needle, token);&#13;
    }&#13;
&#13;
    /*&#13;
     * @dev Counts the number of nonoverlapping occurrences of `needle` in `self`.&#13;
     * @param self The slice to search.&#13;
     * @param needle The text to search for in `self`.&#13;
     * @return The number of occurrences of `needle` found in `self`.&#13;
     */&#13;
    function count(slice self, slice needle) internal returns (uint count) {&#13;
        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr) + needle._len;&#13;
        while (ptr &lt;= self._ptr + self._len) {&#13;
            count++;&#13;
            ptr = findPtr(self._len - (ptr - self._ptr), ptr, needle._len, needle._ptr) + needle._len;&#13;
        }&#13;
    }&#13;
&#13;
    /*&#13;
     * @dev Returns True if `self` contains `needle`.&#13;
     * @param self The slice to search.&#13;
     * @param needle The text to search for in `self`.&#13;
     * @return True if `needle` is found in `self`, false otherwise.&#13;
     */&#13;
    function contains(slice self, slice needle) internal returns (bool) {&#13;
        return rfindPtr(self._len, self._ptr, needle._len, needle._ptr) != self._ptr;&#13;
    }&#13;
&#13;
    /*&#13;
     * @dev Returns a newly allocated string containing the concatenation of&#13;
     *      `self` and `other`.&#13;
     * @param self The first slice to concatenate.&#13;
     * @param other The second slice to concatenate.&#13;
     * @return The concatenation of the two strings.&#13;
     */&#13;
    function concat(slice self, slice other) internal returns (string) {&#13;
        var ret = new string(self._len + other._len);&#13;
        uint retptr;&#13;
        assembly { retptr := add(ret, 32) }&#13;
        memcpy(retptr, self._ptr, self._len);&#13;
        memcpy(retptr + self._len, other._ptr, other._len);&#13;
        return ret;&#13;
    }&#13;
&#13;
    /*&#13;
     * @dev Joins an array of slices, using `self` as a delimiter, returning a&#13;
     *      newly allocated string.&#13;
     * @param self The delimiter to use.&#13;
     * @param parts A list of slices to join.&#13;
     * @return A newly allocated string containing all the slices in `parts`,&#13;
     *         joined with `self`.&#13;
     */&#13;
    function join(slice self, slice[] parts) internal returns (string) {&#13;
        if (parts.length == 0)&#13;
            return "";&#13;
&#13;
        uint len = self._len * (parts.length - 1);&#13;
        for(uint i = 0; i &lt; parts.length; i++)&#13;
            len += parts[i]._len;&#13;
&#13;
        var ret = new string(len);&#13;
        uint retptr;&#13;
        assembly { retptr := add(ret, 32) }&#13;
&#13;
        for(i = 0; i &lt; parts.length; i++) {&#13;
            memcpy(retptr, parts[i]._ptr, parts[i]._len);&#13;
            retptr += parts[i]._len;&#13;
            if (i &lt; parts.length - 1) {&#13;
                memcpy(retptr, self._ptr, self._len);&#13;
                retptr += self._len;&#13;
            }&#13;
        }&#13;
&#13;
        return ret;&#13;
    }&#13;
}&#13;
&#13;
// File: contracts/FlightDelayAccessControllerInterface.sol&#13;
&#13;
/**&#13;
 * FlightDelay with Oraclized Underwriting and Payout&#13;
 *&#13;
 * @description	AccessControllerInterface&#13;
 * @copyright (c) 2017 etherisc GmbH&#13;
 * @author Christoph Mussenbrock&#13;
 */&#13;
&#13;
pragma solidity ^0.4.11;&#13;
&#13;
&#13;
contract FlightDelayAccessControllerInterface {&#13;
&#13;
    function setPermissionById(uint8 _perm, bytes32 _id) public;&#13;
&#13;
    function setPermissionById(uint8 _perm, bytes32 _id, bool _access) public;&#13;
&#13;
    function setPermissionByAddress(uint8 _perm, address _addr) public;&#13;
&#13;
    function setPermissionByAddress(uint8 _perm, address _addr, bool _access) public;&#13;
&#13;
    function checkPermission(uint8 _perm, address _addr) public returns (bool _success);&#13;
}&#13;
&#13;
// File: contracts/FlightDelayConstants.sol&#13;
&#13;
/**&#13;
 * FlightDelay with Oraclized Underwriting and Payout&#13;
 *&#13;
 * @description	Events and Constants&#13;
 * @copyright (c) 2017 etherisc GmbH&#13;
 * @author Christoph Mussenbrock&#13;
 */&#13;
&#13;
pragma solidity ^0.4.11;&#13;
&#13;
&#13;
contract FlightDelayConstants {&#13;
&#13;
    /*&#13;
    * General events&#13;
    */&#13;
&#13;
// --&gt; test-mode&#13;
//        event LogUint(string _message, uint _uint);&#13;
//        event LogUintEth(string _message, uint ethUint);&#13;
//        event LogUintTime(string _message, uint timeUint);&#13;
//        event LogInt(string _message, int _int);&#13;
//        event LogAddress(string _message, address _address);&#13;
//        event LogBytes32(string _message, bytes32 hexBytes32);&#13;
//        event LogBytes(string _message, bytes hexBytes);&#13;
//        event LogBytes32Str(string _message, bytes32 strBytes32);&#13;
//        event LogString(string _message, string _string);&#13;
//        event LogBool(string _message, bool _bool);&#13;
//        event Log(address);&#13;
// &lt;-- test-mode&#13;
&#13;
    event LogPolicyApplied(&#13;
        uint _policyId,&#13;
        address _customer,&#13;
        bytes32 strCarrierFlightNumber,&#13;
        uint ethPremium&#13;
    );&#13;
    event LogPolicyAccepted(&#13;
        uint _policyId,&#13;
        uint _statistics0,&#13;
        uint _statistics1,&#13;
        uint _statistics2,&#13;
        uint _statistics3,&#13;
        uint _statistics4,&#13;
        uint _statistics5&#13;
    );&#13;
    event LogPolicyPaidOut(&#13;
        uint _policyId,&#13;
        uint ethAmount&#13;
    );&#13;
    event LogPolicyExpired(&#13;
        uint _policyId&#13;
    );&#13;
    event LogPolicyDeclined(&#13;
        uint _policyId,&#13;
        bytes32 strReason&#13;
    );&#13;
    event LogPolicyManualPayout(&#13;
        uint _policyId,&#13;
        bytes32 strReason&#13;
    );&#13;
    event LogSendFunds(&#13;
        address _recipient,&#13;
        uint8 _from,&#13;
        uint ethAmount&#13;
    );&#13;
    event LogReceiveFunds(&#13;
        address _sender,&#13;
        uint8 _to,&#13;
        uint ethAmount&#13;
    );&#13;
    event LogSendFail(&#13;
        uint _policyId,&#13;
        bytes32 strReason&#13;
    );&#13;
    event LogOraclizeCall(&#13;
        uint _policyId,&#13;
        bytes32 hexQueryId,&#13;
        string _oraclizeUrl,&#13;
        uint256 _oraclizeTime&#13;
    );&#13;
    event LogOraclizeCallback(&#13;
        uint _policyId,&#13;
        bytes32 hexQueryId,&#13;
        string _result,&#13;
        bytes hexProof&#13;
    );&#13;
    event LogSetState(&#13;
        uint _policyId,&#13;
        uint8 _policyState,&#13;
        uint _stateTime,&#13;
        bytes32 _stateMessage&#13;
    );&#13;
    event LogExternal(&#13;
        uint256 _policyId,&#13;
        address _address,&#13;
        bytes32 _externalId&#13;
    );&#13;
&#13;
    /*&#13;
    * General constants&#13;
    */&#13;
&#13;
    // minimum observations for valid prediction&#13;
    uint constant MIN_OBSERVATIONS = 10;&#13;
    // minimum premium to cover costs&#13;
    uint constant MIN_PREMIUM = 50 finney;&#13;
    // maximum premium&#13;
    uint constant MAX_PREMIUM = 1 ether;&#13;
    // maximum payout&#13;
    uint constant MAX_PAYOUT = 1100 finney;&#13;
&#13;
    uint constant MIN_PREMIUM_EUR = 1500 wei;&#13;
    uint constant MAX_PREMIUM_EUR = 29000 wei;&#13;
    uint constant MAX_PAYOUT_EUR = 30000 wei;&#13;
&#13;
    uint constant MIN_PREMIUM_USD = 1700 wei;&#13;
    uint constant MAX_PREMIUM_USD = 34000 wei;&#13;
    uint constant MAX_PAYOUT_USD = 35000 wei;&#13;
&#13;
    uint constant MIN_PREMIUM_GBP = 1300 wei;&#13;
    uint constant MAX_PREMIUM_GBP = 25000 wei;&#13;
    uint constant MAX_PAYOUT_GBP = 270 wei;&#13;
&#13;
    // maximum cumulated weighted premium per risk&#13;
    uint constant MAX_CUMULATED_WEIGHTED_PREMIUM = 60 ether;&#13;
    // 1 percent for DAO, 1 percent for maintainer&#13;
    uint8 constant REWARD_PERCENT = 2;&#13;
    // reserve for tail risks&#13;
    uint8 constant RESERVE_PERCENT = 1;&#13;
    // the weight pattern; in future versions this may become part of the policy struct.&#13;
    // currently can't be constant because of compiler restrictions&#13;
    // WEIGHT_PATTERN[0] is not used, just to be consistent&#13;
    uint8[6] WEIGHT_PATTERN = [&#13;
        0,&#13;
        10,&#13;
        20,&#13;
        30,&#13;
        50,&#13;
        50&#13;
    ];&#13;
&#13;
// --&gt; prod-mode&#13;
    // DEFINITIONS FOR ROPSTEN AND MAINNET&#13;
    // minimum time before departure for applying&#13;
    uint constant MIN_TIME_BEFORE_DEPARTURE	= 24 hours; // for production&#13;
    // check for delay after .. minutes after scheduled arrival&#13;
    uint constant CHECK_PAYOUT_OFFSET = 15 minutes; // for production&#13;
// &lt;-- prod-mode&#13;
&#13;
// --&gt; test-mode&#13;
//        // DEFINITIONS FOR LOCAL TESTNET&#13;
//        // minimum time before departure for applying&#13;
//        uint constant MIN_TIME_BEFORE_DEPARTURE = 1 seconds; // for testing&#13;
//        // check for delay after .. minutes after scheduled arrival&#13;
//        uint constant CHECK_PAYOUT_OFFSET = 1 seconds; // for testing&#13;
// &lt;-- test-mode&#13;
&#13;
    // maximum duration of flight&#13;
    uint constant MAX_FLIGHT_DURATION = 2 days;&#13;
    // Deadline for acceptance of policies: 31.12.2030 (Testnet)&#13;
    uint constant CONTRACT_DEAD_LINE = 1922396399;&#13;
&#13;
    // gas Constants for oraclize&#13;
    uint constant ORACLIZE_GAS = 700000;&#13;
    uint constant ORACLIZE_GASPRICE = 4000000000;&#13;
&#13;
&#13;
    /*&#13;
    * URLs and query strings for oraclize&#13;
    */&#13;
&#13;
// --&gt; prod-mode&#13;
    // DEFINITIONS FOR ROPSTEN AND MAINNET&#13;
    string constant ORACLIZE_RATINGS_BASE_URL =&#13;
        // ratings api is v1, see https://developer.flightstats.com/api-docs/ratings/v1&#13;
        "[URL] json(https://api.flightstats.com/flex/ratings/rest/v1/json/flight/";&#13;
    string constant ORACLIZE_RATINGS_QUERY =&#13;
        "?${[decrypt] BAr6Z9QolM2PQimF/pNC6zXldOvZ2qquOSKm/qJkJWnSGgAeRw21wBGnBbXiamr/ISC5SlcJB6wEPKthdc6F+IpqM/iXavKsalRUrGNuBsGfaMXr8fRQw6gLzqk0ecOFNeCa48/yqBvC/kas+jTKHiYxA3wTJrVZCq76Y03lZI2xxLaoniRk}).ratings[0]['observations','late15','late30','late45','cancelled','diverted','arrivalAirportFsCode','departureAirportFsCode']";&#13;
    string constant ORACLIZE_STATUS_BASE_URL =&#13;
        // flight status api is v2, see https://developer.flightstats.com/api-docs/flightstatus/v2/flight&#13;
        "[URL] json(https://api.flightstats.com/flex/flightstatus/rest/v2/json/flight/status/";&#13;
    string constant ORACLIZE_STATUS_QUERY =&#13;
        // pattern:&#13;
        "?${[decrypt] BJxpwRaHujYTT98qI5slQJplj/VbfV7vYkMOp/Mr5D/5+gkgJQKZb0gVSCa6aKx2Wogo/cG7yaWINR6vnuYzccQE5yVJSr7RQilRawxnAtZXt6JB70YpX4xlfvpipit4R+OmQTurJGGwb8Pgnr4LvotydCjup6wv2Bk/z3UdGA7Sl+FU5a+0}&amp;utc=true).flightStatuses[0]['status','delays','operationalTimes']";&#13;
// &lt;-- prod-mode&#13;
&#13;
// --&gt; test-mode&#13;
//        // DEFINITIONS FOR LOCAL TESTNET&#13;
//        string constant ORACLIZE_RATINGS_BASE_URL =&#13;
//            // ratings api is v1, see https://developer.flightstats.com/api-docs/ratings/v1&#13;
//            "[URL] json(https://api-test.etherisc.com/flex/ratings/rest/v1/json/flight/";&#13;
//        string constant ORACLIZE_RATINGS_QUERY =&#13;
//            // for testrpc:&#13;
//            ").ratings[0]['observations','late15','late30','late45','cancelled','diverted','arrivalAirportFsCode','departureAirportFsCode']";&#13;
//        string constant ORACLIZE_STATUS_BASE_URL =&#13;
//            // flight status api is v2, see https://developer.flightstats.com/api-docs/flightstatus/v2/flight&#13;
//            "[URL] json(https://api-test.etherisc.com/flex/flightstatus/rest/v2/json/flight/status/";&#13;
//        string constant ORACLIZE_STATUS_QUERY =&#13;
//            // for testrpc:&#13;
//            "?utc=true).flightStatuses[0]['status','delays','operationalTimes']";&#13;
// &lt;-- test-mode&#13;
}&#13;
&#13;
// File: contracts/FlightDelayControllerInterface.sol&#13;
&#13;
/**&#13;
 * FlightDelay with Oraclized Underwriting and Payout&#13;
 *&#13;
 * @description Contract interface&#13;
 * @copyright (c) 2017 etherisc GmbH&#13;
 * @author Christoph Mussenbrock, Stephan Karpischek&#13;
 */&#13;
&#13;
pragma solidity ^0.4.11;&#13;
&#13;
&#13;
contract FlightDelayControllerInterface {&#13;
&#13;
    function isOwner(address _addr) public returns (bool _isOwner);&#13;
&#13;
    function selfRegister(bytes32 _id) public returns (bool result);&#13;
&#13;
    function getContract(bytes32 _id) public returns (address _addr);&#13;
}&#13;
&#13;
// File: contracts/FlightDelayDatabaseModel.sol&#13;
&#13;
/**&#13;
 * FlightDelay with Oraclized Underwriting and Payout&#13;
 *&#13;
 * @description Database model&#13;
 * @copyright (c) 2017 etherisc GmbH&#13;
 * @author Christoph Mussenbrock, Stephan Karpischek&#13;
 */&#13;
&#13;
pragma solidity ^0.4.11;&#13;
&#13;
&#13;
contract FlightDelayDatabaseModel {&#13;
&#13;
    // Ledger accounts.&#13;
    enum Acc {&#13;
        Premium,      // 0&#13;
        RiskFund,     // 1&#13;
        Payout,       // 2&#13;
        Balance,      // 3&#13;
        Reward,       // 4&#13;
        OraclizeCosts // 5&#13;
    }&#13;
&#13;
    // policy Status Codes and meaning:&#13;
    //&#13;
    // 00 = Applied:	  the customer has payed a premium, but the oracle has&#13;
    //					        not yet checked and confirmed.&#13;
    //					        The customer can still revoke the policy.&#13;
    // 01 = Accepted:	  the oracle has checked and confirmed.&#13;
    //					        The customer can still revoke the policy.&#13;
    // 02 = Revoked:	  The customer has revoked the policy.&#13;
    //					        The premium minus cancellation fee is payed back to the&#13;
    //					        customer by the oracle.&#13;
    // 03 = PaidOut:	  The flight has ended with delay.&#13;
    //					        The oracle has checked and payed out.&#13;
    // 04 = Expired:	  The flight has endet with &lt;15min. delay.&#13;
    //					        No payout.&#13;
    // 05 = Declined:	  The application was invalid.&#13;
    //					        The premium minus cancellation fee is payed back to the&#13;
    //					        customer by the oracle.&#13;
    // 06 = SendFailed:	During Revoke, Decline or Payout, sending ether failed&#13;
    //					        for unknown reasons.&#13;
    //					        The funds remain in the contracts RiskFund.&#13;
&#13;
&#13;
    //                   00       01        02       03        04      05           06&#13;
    enum policyState { Applied, Accepted, Revoked, PaidOut, Expired, Declined, SendFailed }&#13;
&#13;
    // oraclize callback types:&#13;
    enum oraclizeState { ForUnderwriting, ForPayout }&#13;
&#13;
    //               00   01   02   03&#13;
    enum Currency { ETH, EUR, USD, GBP }&#13;
&#13;
    // the policy structure: this structure keeps track of the individual parameters of a policy.&#13;
    // typically customer address, premium and some status information.&#13;
    struct Policy {&#13;
        // 0 - the customer&#13;
        address customer;&#13;
&#13;
        // 1 - premium&#13;
        uint premium;&#13;
        // risk specific parameters:&#13;
        // 2 - pointer to the risk in the risks mapping&#13;
        bytes32 riskId;&#13;
        // custom payout pattern&#13;
        // in future versions, customer will be able to tamper with this array.&#13;
        // to keep things simple, we have decided to hard-code the array for all policies.&#13;
        // uint8[5] pattern;&#13;
        // 3 - probability weight. this is the central parameter&#13;
        uint weight;&#13;
        // 4 - calculated Payout&#13;
        uint calculatedPayout;&#13;
        // 5 - actual Payout&#13;
        uint actualPayout;&#13;
&#13;
        // status fields:&#13;
        // 6 - the state of the policy&#13;
        policyState state;&#13;
        // 7 - time of last state change&#13;
        uint stateTime;&#13;
        // 8 - state change message/reason&#13;
        bytes32 stateMessage;&#13;
        // 9 - TLSNotary Proof&#13;
        bytes proof;&#13;
        // 10 - Currency&#13;
        Currency currency;&#13;
        // 10 - External customer id&#13;
        bytes32 customerExternalId;&#13;
    }&#13;
&#13;
    // the risk structure; this structure keeps track of the risk-&#13;
    // specific parameters.&#13;
    // several policies can share the same risk structure (typically&#13;
    // some people flying with the same plane)&#13;
    struct Risk {&#13;
        // 0 - Airline Code + FlightNumber&#13;
        bytes32 carrierFlightNumber;&#13;
        // 1 - scheduled departure and arrival time in the format /dep/YYYY/MM/DD&#13;
        bytes32 departureYearMonthDay;&#13;
        // 2 - the inital arrival time&#13;
        uint arrivalTime;&#13;
        // 3 - the final delay in minutes&#13;
        uint delayInMinutes;&#13;
        // 4 - the determined delay category (0-5)&#13;
        uint8 delay;&#13;
        // 5 - we limit the cumulated weighted premium to avoid cluster risks&#13;
        uint cumulatedWeightedPremium;&#13;
        // 6 - max cumulated Payout for this risk&#13;
        uint premiumMultiplier;&#13;
    }&#13;
&#13;
    // the oraclize callback structure: we use several oraclize calls.&#13;
    // all oraclize calls will result in a common callback to __callback(...).&#13;
    // to keep track of the different querys we have to introduce this struct.&#13;
    struct OraclizeCallback {&#13;
        // for which policy have we called?&#13;
        uint policyId;&#13;
        // for which purpose did we call? {ForUnderwrite | ForPayout}&#13;
        oraclizeState oState;&#13;
        // time&#13;
        uint oraclizeTime;&#13;
    }&#13;
&#13;
    struct Customer {&#13;
        bytes32 customerExternalId;&#13;
        bool identityConfirmed;&#13;
    }&#13;
}&#13;
&#13;
// File: contracts/FlightDelayControlledContract.sol&#13;
&#13;
/**&#13;
 * FlightDelay with Oraclized Underwriting and Payout&#13;
 *&#13;
 * @description Controlled contract Interface&#13;
 * @copyright (c) 2017 etherisc GmbH&#13;
 * @author Christoph Mussenbrock&#13;
 */&#13;
&#13;
pragma solidity ^0.4.11;&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
contract FlightDelayControlledContract is FlightDelayDatabaseModel {&#13;
&#13;
    address public controller;&#13;
    FlightDelayControllerInterface FD_CI;&#13;
&#13;
    modifier onlyController() {&#13;
        require(msg.sender == controller);&#13;
        _;&#13;
    }&#13;
&#13;
    function setController(address _controller) internal returns (bool _result) {&#13;
        controller = _controller;&#13;
        FD_CI = FlightDelayControllerInterface(_controller);&#13;
        _result = true;&#13;
    }&#13;
&#13;
    function destruct() public onlyController {&#13;
        selfdestruct(controller);&#13;
    }&#13;
&#13;
    function setContracts() public onlyController {}&#13;
&#13;
    function getContract(bytes32 _id) internal returns (address _addr) {&#13;
        _addr = FD_CI.getContract(_id);&#13;
    }&#13;
}&#13;
&#13;
// File: contracts/FlightDelayDatabaseInterface.sol&#13;
&#13;
/**&#13;
 * FlightDelay with Oraclized Underwriting and Payout&#13;
 *&#13;
 * @description Database contract interface&#13;
 * @copyright (c) 2017 etherisc GmbH&#13;
 * @author Christoph Mussenbrock, Stephan Karpischek&#13;
 */&#13;
&#13;
pragma solidity ^0.4.11;&#13;
&#13;
&#13;
&#13;
&#13;
contract FlightDelayDatabaseInterface is FlightDelayDatabaseModel {&#13;
&#13;
    uint public MIN_DEPARTURE_LIM;&#13;
&#13;
    uint public MAX_DEPARTURE_LIM;&#13;
&#13;
    bytes32[] public validOrigins;&#13;
&#13;
    bytes32[] public validDestinations;&#13;
&#13;
    function countOrigins() public constant returns (uint256 _length);&#13;
&#13;
    function getOriginByIndex(uint256 _i) public constant returns (bytes32 _origin);&#13;
&#13;
    function countDestinations() public constant returns (uint256 _length);&#13;
&#13;
    function getDestinationByIndex(uint256 _i) public constant returns (bytes32 _destination);&#13;
&#13;
    function setAccessControl(address _contract, address _caller, uint8 _perm) public;&#13;
&#13;
    function setAccessControl(&#13;
        address _contract,&#13;
        address _caller,&#13;
        uint8 _perm,&#13;
        bool _access&#13;
    ) public;&#13;
&#13;
    function getAccessControl(address _contract, address _caller, uint8 _perm) public returns (bool _allowed) ;&#13;
&#13;
    function setLedger(uint8 _index, int _value) public;&#13;
&#13;
    function getLedger(uint8 _index) public returns (int _value) ;&#13;
&#13;
    function getCustomerPremium(uint _policyId) public returns (address _customer, uint _premium) ;&#13;
&#13;
    function getPolicyData(uint _policyId) public returns (address _customer, uint _premium, uint _weight) ;&#13;
&#13;
    function getPolicyState(uint _policyId) public returns (policyState _state) ;&#13;
&#13;
    function getRiskId(uint _policyId) public returns (bytes32 _riskId);&#13;
&#13;
    function createPolicy(address _customer, uint _premium, Currency _currency, bytes32 _customerExternalId, bytes32 _riskId) public returns (uint _policyId) ;&#13;
&#13;
    function setState(&#13;
        uint _policyId,&#13;
        policyState _state,&#13;
        uint _stateTime,&#13;
        bytes32 _stateMessage&#13;
    ) public;&#13;
&#13;
    function setWeight(uint _policyId, uint _weight, bytes _proof) public;&#13;
&#13;
    function setPayouts(uint _policyId, uint _calculatedPayout, uint _actualPayout) public;&#13;
&#13;
    function setDelay(uint _policyId, uint8 _delay, uint _delayInMinutes) public;&#13;
&#13;
    function getRiskParameters(bytes32 _riskId)&#13;
        public returns (bytes32 _carrierFlightNumber, bytes32 _departureYearMonthDay, uint _arrivalTime) ;&#13;
&#13;
    function getPremiumFactors(bytes32 _riskId)&#13;
        public returns (uint _cumulatedWeightedPremium, uint _premiumMultiplier);&#13;
&#13;
    function createUpdateRisk(bytes32 _carrierFlightNumber, bytes32 _departureYearMonthDay, uint _arrivalTime)&#13;
        public returns (bytes32 _riskId);&#13;
&#13;
    function setPremiumFactors(bytes32 _riskId, uint _cumulatedWeightedPremium, uint _premiumMultiplier) public;&#13;
&#13;
    function getOraclizeCallback(bytes32 _queryId)&#13;
        public returns (uint _policyId, uint _oraclizeTime) ;&#13;
&#13;
    function getOraclizePolicyId(bytes32 _queryId)&#13;
        public returns (uint _policyId) ;&#13;
&#13;
    function createOraclizeCallback(&#13;
        bytes32 _queryId,&#13;
        uint _policyId,&#13;
        oraclizeState _oraclizeState,&#13;
        uint _oraclizeTime&#13;
    ) public;&#13;
&#13;
    function checkTime(bytes32 _queryId, bytes32 _riskId, uint _offset)&#13;
        public returns (bool _result) ;&#13;
}&#13;
&#13;
// File: contracts/FlightDelayLedgerInterface.sol&#13;
&#13;
/**&#13;
 * FlightDelay with Oraclized Underwriting and Payout&#13;
 *&#13;
 * @description	Ledger contract interface&#13;
 * @copyright (c) 2017 etherisc GmbH&#13;
 * @author Christoph Mussenbrock, Stephan Karpischek&#13;
 */&#13;
&#13;
pragma solidity ^0.4.11;&#13;
&#13;
&#13;
&#13;
&#13;
contract FlightDelayLedgerInterface is FlightDelayDatabaseModel {&#13;
&#13;
    function receiveFunds(Acc _to) public payable;&#13;
&#13;
    function sendFunds(address _recipient, Acc _from, uint _amount) public returns (bool _success);&#13;
&#13;
    function bookkeeping(Acc _from, Acc _to, uint amount) public;&#13;
}&#13;
&#13;
// File: vendors/usingOraclize.sol&#13;
&#13;
// &lt;ORACLIZE_API&gt;&#13;
/*&#13;
Copyright (c) 2015-2016 Oraclize SRL&#13;
Copyright (c) 2016 Oraclize LTD&#13;
&#13;
&#13;
&#13;
Permission is hereby granted, free of charge, to any person obtaining a copy&#13;
of this software and associated documentation files (the "Software"), to deal&#13;
in the Software without restriction, including without limitation the rights&#13;
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell&#13;
copies of the Software, and to permit persons to whom the Software is&#13;
furnished to do so, subject to the following conditions:&#13;
&#13;
&#13;
&#13;
The above copyright notice and this permission notice shall be included in&#13;
all copies or substantial portions of the Software.&#13;
&#13;
&#13;
&#13;
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR&#13;
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,&#13;
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE&#13;
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER&#13;
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,&#13;
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN&#13;
THE SOFTWARE.&#13;
*/&#13;
&#13;
&#13;
&#13;
contract OraclizeI {&#13;
    address public cbAddress;&#13;
    function query(uint _timestamp, string _datasource, string _arg) payable returns (bytes32 _id);&#13;
    function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) payable returns (bytes32 _id);&#13;
    function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) payable returns (bytes32 _id);&#13;
    function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) payable returns (bytes32 _id);&#13;
    function queryN(uint _timestamp, string _datasource, bytes _argN) payable returns (bytes32 _id);&#13;
    function queryN_withGasLimit(uint _timestamp, string _datasource, bytes _argN, uint _gaslimit) payable returns (bytes32 _id);&#13;
    function getPrice(string _datasource) returns (uint _dsprice);&#13;
    function getPrice(string _datasource, uint gaslimit) returns (uint _dsprice);&#13;
    function useCoupon(string _coupon);&#13;
    function setProofType(byte _proofType);&#13;
    function setConfig(bytes32 _config);&#13;
    function setCustomGasPrice(uint _gasPrice);&#13;
    function randomDS_getSessionPubKeyHash() returns(bytes32);&#13;
}&#13;
contract OraclizeAddrResolverI {&#13;
    function getAddress() returns (address _addr);&#13;
}&#13;
contract usingOraclize {&#13;
    uint constant day = 60*60*24;&#13;
    uint constant week = 60*60*24*7;&#13;
    uint constant month = 60*60*24*30;&#13;
    byte constant proofType_NONE = 0x00;&#13;
    byte constant proofType_TLSNotary = 0x10;&#13;
    byte constant proofType_Android = 0x20;&#13;
    byte constant proofType_Ledger = 0x30;&#13;
    byte constant proofType_Native = 0xF0;&#13;
    byte constant proofStorage_IPFS = 0x01;&#13;
    uint8 constant networkID_auto = 0;&#13;
    uint8 constant networkID_mainnet = 1;&#13;
    uint8 constant networkID_testnet = 2;&#13;
    uint8 constant networkID_morden = 2;&#13;
    uint8 constant networkID_consensys = 161;&#13;
&#13;
    OraclizeAddrResolverI OAR;&#13;
&#13;
    OraclizeI oraclize;&#13;
    modifier oraclizeAPI {&#13;
        if((address(OAR)==0)||(getCodeSize(address(OAR))==0)) oraclize_setNetwork(networkID_auto);&#13;
        oraclize = OraclizeI(OAR.getAddress());&#13;
        _;&#13;
    }&#13;
    modifier coupon(string code){&#13;
        oraclize = OraclizeI(OAR.getAddress());&#13;
        oraclize.useCoupon(code);&#13;
        _;&#13;
    }&#13;
&#13;
    function oraclize_setNetwork(uint8 networkID) internal returns(bool){&#13;
        if (getCodeSize(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed)&gt;0){ //mainnet&#13;
            OAR = OraclizeAddrResolverI(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed);&#13;
            oraclize_setNetworkName("eth_mainnet");&#13;
            return true;&#13;
        }&#13;
        if (getCodeSize(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1)&gt;0){ //ropsten testnet&#13;
            OAR = OraclizeAddrResolverI(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1);&#13;
            oraclize_setNetworkName("eth_ropsten3");&#13;
            return true;&#13;
        }&#13;
        if (getCodeSize(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e)&gt;0){ //kovan testnet&#13;
            OAR = OraclizeAddrResolverI(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e);&#13;
            oraclize_setNetworkName("eth_kovan");&#13;
            return true;&#13;
        }&#13;
        if (getCodeSize(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48)&gt;0){ //rinkeby testnet&#13;
            OAR = OraclizeAddrResolverI(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48);&#13;
            oraclize_setNetworkName("eth_rinkeby");&#13;
            return true;&#13;
        }&#13;
        if (getCodeSize(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475)&gt;0){ //ethereum-bridge&#13;
            OAR = OraclizeAddrResolverI(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475);&#13;
            return true;&#13;
        }&#13;
        if (getCodeSize(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF)&gt;0){ //ether.camp ide&#13;
            OAR = OraclizeAddrResolverI(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF);&#13;
            return true;&#13;
        }&#13;
        if (getCodeSize(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA)&gt;0){ //browser-solidity&#13;
            OAR = OraclizeAddrResolverI(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA);&#13;
            return true;&#13;
        }&#13;
        return false;&#13;
    }&#13;
&#13;
    function __callback(bytes32 myid, string result) {&#13;
        __callback(myid, result, new bytes(0));&#13;
    }&#13;
    function __callback(bytes32 myid, string result, bytes proof) {&#13;
    }&#13;
&#13;
    function oraclize_useCoupon(string code) oraclizeAPI internal {&#13;
        oraclize.useCoupon(code);&#13;
    }&#13;
&#13;
    function oraclize_getPrice(string datasource) oraclizeAPI internal returns (uint){&#13;
        return oraclize.getPrice(datasource);&#13;
    }&#13;
&#13;
    function oraclize_getPrice(string datasource, uint gaslimit) oraclizeAPI internal returns (uint){&#13;
        return oraclize.getPrice(datasource, gaslimit);&#13;
    }&#13;
&#13;
    function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){&#13;
        uint price = oraclize.getPrice(datasource);&#13;
        if (price &gt; 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price&#13;
        return oraclize.query.value(price)(0, datasource, arg);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){&#13;
        uint price = oraclize.getPrice(datasource);&#13;
        if (price &gt; 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price&#13;
        return oraclize.query.value(price)(timestamp, datasource, arg);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){&#13;
        uint price = oraclize.getPrice(datasource, gaslimit);&#13;
        if (price &gt; 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price&#13;
        return oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){&#13;
        uint price = oraclize.getPrice(datasource, gaslimit);&#13;
        if (price &gt; 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price&#13;
        return oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){&#13;
        uint price = oraclize.getPrice(datasource);&#13;
        if (price &gt; 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price&#13;
        return oraclize.query2.value(price)(0, datasource, arg1, arg2);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){&#13;
        uint price = oraclize.getPrice(datasource);&#13;
        if (price &gt; 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price&#13;
        return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){&#13;
        uint price = oraclize.getPrice(datasource, gaslimit);&#13;
        if (price &gt; 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price&#13;
        return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){&#13;
        uint price = oraclize.getPrice(datasource, gaslimit);&#13;
        if (price &gt; 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price&#13;
        return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, string[] argN) oraclizeAPI internal returns (bytes32 id){&#13;
        uint price = oraclize.getPrice(datasource);&#13;
        if (price &gt; 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price&#13;
        bytes memory args = stra2cbor(argN);&#13;
        return oraclize.queryN.value(price)(0, datasource, args);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, string[] argN) oraclizeAPI internal returns (bytes32 id){&#13;
        uint price = oraclize.getPrice(datasource);&#13;
        if (price &gt; 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price&#13;
        bytes memory args = stra2cbor(argN);&#13;
        return oraclize.queryN.value(price)(timestamp, datasource, args);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, string[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){&#13;
        uint price = oraclize.getPrice(datasource, gaslimit);&#13;
        if (price &gt; 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price&#13;
        bytes memory args = stra2cbor(argN);&#13;
        return oraclize.queryN_withGasLimit.value(price)(timestamp, datasource, args, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, string[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){&#13;
        uint price = oraclize.getPrice(datasource, gaslimit);&#13;
        if (price &gt; 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price&#13;
        bytes memory args = stra2cbor(argN);&#13;
        return oraclize.queryN_withGasLimit.value(price)(0, datasource, args, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, string[1] args) oraclizeAPI internal returns (bytes32 id) {&#13;
        string[] memory dynargs = new string[](1);&#13;
        dynargs[0] = args[0];&#13;
        return oraclize_query(datasource, dynargs);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, string[1] args) oraclizeAPI internal returns (bytes32 id) {&#13;
        string[] memory dynargs = new string[](1);&#13;
        dynargs[0] = args[0];&#13;
        return oraclize_query(timestamp, datasource, dynargs);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, string[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {&#13;
        string[] memory dynargs = new string[](1);&#13;
        dynargs[0] = args[0];&#13;
        return oraclize_query(timestamp, datasource, dynargs, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, string[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {&#13;
        string[] memory dynargs = new string[](1);&#13;
        dynargs[0] = args[0];&#13;
        return oraclize_query(datasource, dynargs, gaslimit);&#13;
    }&#13;
&#13;
    function oraclize_query(string datasource, string[2] args) oraclizeAPI internal returns (bytes32 id) {&#13;
        string[] memory dynargs = new string[](2);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        return oraclize_query(datasource, dynargs);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, string[2] args) oraclizeAPI internal returns (bytes32 id) {&#13;
        string[] memory dynargs = new string[](2);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        return oraclize_query(timestamp, datasource, dynargs);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, string[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {&#13;
        string[] memory dynargs = new string[](2);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        return oraclize_query(timestamp, datasource, dynargs, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, string[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {&#13;
        string[] memory dynargs = new string[](2);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        return oraclize_query(datasource, dynargs, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, string[3] args) oraclizeAPI internal returns (bytes32 id) {&#13;
        string[] memory dynargs = new string[](3);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        return oraclize_query(datasource, dynargs);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, string[3] args) oraclizeAPI internal returns (bytes32 id) {&#13;
        string[] memory dynargs = new string[](3);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        return oraclize_query(timestamp, datasource, dynargs);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, string[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {&#13;
        string[] memory dynargs = new string[](3);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        return oraclize_query(timestamp, datasource, dynargs, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, string[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {&#13;
        string[] memory dynargs = new string[](3);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        return oraclize_query(datasource, dynargs, gaslimit);&#13;
    }&#13;
&#13;
    function oraclize_query(string datasource, string[4] args) oraclizeAPI internal returns (bytes32 id) {&#13;
        string[] memory dynargs = new string[](4);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        dynargs[3] = args[3];&#13;
        return oraclize_query(datasource, dynargs);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, string[4] args) oraclizeAPI internal returns (bytes32 id) {&#13;
        string[] memory dynargs = new string[](4);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        dynargs[3] = args[3];&#13;
        return oraclize_query(timestamp, datasource, dynargs);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, string[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {&#13;
        string[] memory dynargs = new string[](4);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        dynargs[3] = args[3];&#13;
        return oraclize_query(timestamp, datasource, dynargs, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, string[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {&#13;
        string[] memory dynargs = new string[](4);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        dynargs[3] = args[3];&#13;
        return oraclize_query(datasource, dynargs, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, string[5] args) oraclizeAPI internal returns (bytes32 id) {&#13;
        string[] memory dynargs = new string[](5);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        dynargs[3] = args[3];&#13;
        dynargs[4] = args[4];&#13;
        return oraclize_query(datasource, dynargs);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, string[5] args) oraclizeAPI internal returns (bytes32 id) {&#13;
        string[] memory dynargs = new string[](5);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        dynargs[3] = args[3];&#13;
        dynargs[4] = args[4];&#13;
        return oraclize_query(timestamp, datasource, dynargs);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, string[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {&#13;
        string[] memory dynargs = new string[](5);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        dynargs[3] = args[3];&#13;
        dynargs[4] = args[4];&#13;
        return oraclize_query(timestamp, datasource, dynargs, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, string[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {&#13;
        string[] memory dynargs = new string[](5);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        dynargs[3] = args[3];&#13;
        dynargs[4] = args[4];&#13;
        return oraclize_query(datasource, dynargs, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, bytes[] argN) oraclizeAPI internal returns (bytes32 id){&#13;
        uint price = oraclize.getPrice(datasource);&#13;
        if (price &gt; 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price&#13;
        bytes memory args = ba2cbor(argN);&#13;
        return oraclize.queryN.value(price)(0, datasource, args);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, bytes[] argN) oraclizeAPI internal returns (bytes32 id){&#13;
        uint price = oraclize.getPrice(datasource);&#13;
        if (price &gt; 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price&#13;
        bytes memory args = ba2cbor(argN);&#13;
        return oraclize.queryN.value(price)(timestamp, datasource, args);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, bytes[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){&#13;
        uint price = oraclize.getPrice(datasource, gaslimit);&#13;
        if (price &gt; 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price&#13;
        bytes memory args = ba2cbor(argN);&#13;
        return oraclize.queryN_withGasLimit.value(price)(timestamp, datasource, args, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, bytes[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){&#13;
        uint price = oraclize.getPrice(datasource, gaslimit);&#13;
        if (price &gt; 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price&#13;
        bytes memory args = ba2cbor(argN);&#13;
        return oraclize.queryN_withGasLimit.value(price)(0, datasource, args, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, bytes[1] args) oraclizeAPI internal returns (bytes32 id) {&#13;
        bytes[] memory dynargs = new bytes[](1);&#13;
        dynargs[0] = args[0];&#13;
        return oraclize_query(datasource, dynargs);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, bytes[1] args) oraclizeAPI internal returns (bytes32 id) {&#13;
        bytes[] memory dynargs = new bytes[](1);&#13;
        dynargs[0] = args[0];&#13;
        return oraclize_query(timestamp, datasource, dynargs);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, bytes[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {&#13;
        bytes[] memory dynargs = new bytes[](1);&#13;
        dynargs[0] = args[0];&#13;
        return oraclize_query(timestamp, datasource, dynargs, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, bytes[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {&#13;
        bytes[] memory dynargs = new bytes[](1);&#13;
        dynargs[0] = args[0];&#13;
        return oraclize_query(datasource, dynargs, gaslimit);&#13;
    }&#13;
&#13;
    function oraclize_query(string datasource, bytes[2] args) oraclizeAPI internal returns (bytes32 id) {&#13;
        bytes[] memory dynargs = new bytes[](2);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        return oraclize_query(datasource, dynargs);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, bytes[2] args) oraclizeAPI internal returns (bytes32 id) {&#13;
        bytes[] memory dynargs = new bytes[](2);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        return oraclize_query(timestamp, datasource, dynargs);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, bytes[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {&#13;
        bytes[] memory dynargs = new bytes[](2);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        return oraclize_query(timestamp, datasource, dynargs, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, bytes[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {&#13;
        bytes[] memory dynargs = new bytes[](2);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        return oraclize_query(datasource, dynargs, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, bytes[3] args) oraclizeAPI internal returns (bytes32 id) {&#13;
        bytes[] memory dynargs = new bytes[](3);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        return oraclize_query(datasource, dynargs);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, bytes[3] args) oraclizeAPI internal returns (bytes32 id) {&#13;
        bytes[] memory dynargs = new bytes[](3);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        return oraclize_query(timestamp, datasource, dynargs);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, bytes[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {&#13;
        bytes[] memory dynargs = new bytes[](3);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        return oraclize_query(timestamp, datasource, dynargs, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, bytes[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {&#13;
        bytes[] memory dynargs = new bytes[](3);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        return oraclize_query(datasource, dynargs, gaslimit);&#13;
    }&#13;
&#13;
    function oraclize_query(string datasource, bytes[4] args) oraclizeAPI internal returns (bytes32 id) {&#13;
        bytes[] memory dynargs = new bytes[](4);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        dynargs[3] = args[3];&#13;
        return oraclize_query(datasource, dynargs);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, bytes[4] args) oraclizeAPI internal returns (bytes32 id) {&#13;
        bytes[] memory dynargs = new bytes[](4);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        dynargs[3] = args[3];&#13;
        return oraclize_query(timestamp, datasource, dynargs);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, bytes[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {&#13;
        bytes[] memory dynargs = new bytes[](4);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        dynargs[3] = args[3];&#13;
        return oraclize_query(timestamp, datasource, dynargs, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, bytes[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {&#13;
        bytes[] memory dynargs = new bytes[](4);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        dynargs[3] = args[3];&#13;
        return oraclize_query(datasource, dynargs, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, bytes[5] args) oraclizeAPI internal returns (bytes32 id) {&#13;
        bytes[] memory dynargs = new bytes[](5);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        dynargs[3] = args[3];&#13;
        dynargs[4] = args[4];&#13;
        return oraclize_query(datasource, dynargs);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, bytes[5] args) oraclizeAPI internal returns (bytes32 id) {&#13;
        bytes[] memory dynargs = new bytes[](5);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        dynargs[3] = args[3];&#13;
        dynargs[4] = args[4];&#13;
        return oraclize_query(timestamp, datasource, dynargs);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, bytes[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {&#13;
        bytes[] memory dynargs = new bytes[](5);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        dynargs[3] = args[3];&#13;
        dynargs[4] = args[4];&#13;
        return oraclize_query(timestamp, datasource, dynargs, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, bytes[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {&#13;
        bytes[] memory dynargs = new bytes[](5);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        dynargs[3] = args[3];&#13;
        dynargs[4] = args[4];&#13;
        return oraclize_query(datasource, dynargs, gaslimit);&#13;
    }&#13;
&#13;
    function oraclize_cbAddress() oraclizeAPI internal returns (address){&#13;
        return oraclize.cbAddress();&#13;
    }&#13;
    function oraclize_setProof(byte proofP) oraclizeAPI internal {&#13;
        return oraclize.setProofType(proofP);&#13;
    }&#13;
    function oraclize_setCustomGasPrice(uint gasPrice) oraclizeAPI internal {&#13;
        return oraclize.setCustomGasPrice(gasPrice);&#13;
    }&#13;
    function oraclize_setConfig(bytes32 config) oraclizeAPI internal {&#13;
        return oraclize.setConfig(config);&#13;
    }&#13;
&#13;
    function oraclize_randomDS_getSessionPubKeyHash() oraclizeAPI internal returns (bytes32){&#13;
        return oraclize.randomDS_getSessionPubKeyHash();&#13;
    }&#13;
&#13;
    function getCodeSize(address _addr) constant internal returns(uint _size) {&#13;
        assembly {&#13;
            _size := extcodesize(_addr)&#13;
        }&#13;
    }&#13;
&#13;
    function parseAddr(string _a) internal returns (address){&#13;
        bytes memory tmp = bytes(_a);&#13;
        uint160 iaddr = 0;&#13;
        uint160 b1;&#13;
        uint160 b2;&#13;
        for (uint i=2; i&lt;2+2*20; i+=2){&#13;
            iaddr *= 256;&#13;
            b1 = uint160(tmp[i]);&#13;
            b2 = uint160(tmp[i+1]);&#13;
            if ((b1 &gt;= 97)&amp;&amp;(b1 &lt;= 102)) b1 -= 87;&#13;
            else if ((b1 &gt;= 65)&amp;&amp;(b1 &lt;= 70)) b1 -= 55;&#13;
            else if ((b1 &gt;= 48)&amp;&amp;(b1 &lt;= 57)) b1 -= 48;&#13;
            if ((b2 &gt;= 97)&amp;&amp;(b2 &lt;= 102)) b2 -= 87;&#13;
            else if ((b2 &gt;= 65)&amp;&amp;(b2 &lt;= 70)) b2 -= 55;&#13;
            else if ((b2 &gt;= 48)&amp;&amp;(b2 &lt;= 57)) b2 -= 48;&#13;
            iaddr += (b1*16+b2);&#13;
        }&#13;
        return address(iaddr);&#13;
    }&#13;
&#13;
    function strCompare(string _a, string _b) internal returns (int) {&#13;
        bytes memory a = bytes(_a);&#13;
        bytes memory b = bytes(_b);&#13;
        uint minLength = a.length;&#13;
        if (b.length &lt; minLength) minLength = b.length;&#13;
        for (uint i = 0; i &lt; minLength; i ++)&#13;
            if (a[i] &lt; b[i])&#13;
                return -1;&#13;
            else if (a[i] &gt; b[i])&#13;
                return 1;&#13;
        if (a.length &lt; b.length)&#13;
            return -1;&#13;
        else if (a.length &gt; b.length)&#13;
            return 1;&#13;
        else&#13;
            return 0;&#13;
    }&#13;
&#13;
    function indexOf(string _haystack, string _needle) internal returns (int) {&#13;
        bytes memory h = bytes(_haystack);&#13;
        bytes memory n = bytes(_needle);&#13;
        if(h.length &lt; 1 || n.length &lt; 1 || (n.length &gt; h.length))&#13;
            return -1;&#13;
        else if(h.length &gt; (2**128 -1))&#13;
            return -1;&#13;
        else&#13;
        {&#13;
            uint subindex = 0;&#13;
            for (uint i = 0; i &lt; h.length; i ++)&#13;
            {&#13;
                if (h[i] == n[0])&#13;
                {&#13;
                    subindex = 1;&#13;
                    while(subindex &lt; n.length &amp;&amp; (i + subindex) &lt; h.length &amp;&amp; h[i + subindex] == n[subindex])&#13;
                    {&#13;
                        subindex++;&#13;
                    }&#13;
                    if(subindex == n.length)&#13;
                        return int(i);&#13;
                }&#13;
            }&#13;
            return -1;&#13;
        }&#13;
    }&#13;
&#13;
    function strConcat(string _a, string _b, string _c, string _d, string _e) internal returns (string) {&#13;
        bytes memory _ba = bytes(_a);&#13;
        bytes memory _bb = bytes(_b);&#13;
        bytes memory _bc = bytes(_c);&#13;
        bytes memory _bd = bytes(_d);&#13;
        bytes memory _be = bytes(_e);&#13;
        string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);&#13;
        bytes memory babcde = bytes(abcde);&#13;
        uint k = 0;&#13;
        for (uint i = 0; i &lt; _ba.length; i++) babcde[k++] = _ba[i];&#13;
        for (i = 0; i &lt; _bb.length; i++) babcde[k++] = _bb[i];&#13;
        for (i = 0; i &lt; _bc.length; i++) babcde[k++] = _bc[i];&#13;
        for (i = 0; i &lt; _bd.length; i++) babcde[k++] = _bd[i];&#13;
        for (i = 0; i &lt; _be.length; i++) babcde[k++] = _be[i];&#13;
        return string(babcde);&#13;
    }&#13;
&#13;
    function strConcat(string _a, string _b, string _c, string _d) internal returns (string) {&#13;
        return strConcat(_a, _b, _c, _d, "");&#13;
    }&#13;
&#13;
    function strConcat(string _a, string _b, string _c) internal returns (string) {&#13;
        return strConcat(_a, _b, _c, "", "");&#13;
    }&#13;
&#13;
    function strConcat(string _a, string _b) internal returns (string) {&#13;
        return strConcat(_a, _b, "", "", "");&#13;
    }&#13;
&#13;
    // parseInt&#13;
    function parseInt(string _a) internal returns (uint) {&#13;
        return parseInt(_a, 0);&#13;
    }&#13;
&#13;
    // parseInt(parseFloat*10^_b)&#13;
    function parseInt(string _a, uint _b) internal returns (uint) {&#13;
        bytes memory bresult = bytes(_a);&#13;
        uint mint = 0;&#13;
        bool decimals = false;&#13;
        for (uint i=0; i&lt;bresult.length; i++){&#13;
            if ((bresult[i] &gt;= 48)&amp;&amp;(bresult[i] &lt;= 57)){&#13;
                if (decimals){&#13;
                   if (_b == 0) break;&#13;
                    else _b--;&#13;
                }&#13;
                mint *= 10;&#13;
                mint += uint(bresult[i]) - 48;&#13;
            } else if (bresult[i] == 46) decimals = true;&#13;
        }&#13;
        if (_b &gt; 0) mint *= 10**_b;&#13;
        return mint;&#13;
    }&#13;
&#13;
    function uint2str(uint i) internal returns (string){&#13;
        if (i == 0) return "0";&#13;
        uint j = i;&#13;
        uint len;&#13;
        while (j != 0){&#13;
            len++;&#13;
            j /= 10;&#13;
        }&#13;
        bytes memory bstr = new bytes(len);&#13;
        uint k = len - 1;&#13;
        while (i != 0){&#13;
            bstr[k--] = byte(48 + i % 10);&#13;
            i /= 10;&#13;
        }&#13;
        return string(bstr);&#13;
    }&#13;
&#13;
    function stra2cbor(string[] arr) internal returns (bytes) {&#13;
            uint arrlen = arr.length;&#13;
&#13;
            // get correct cbor output length&#13;
            uint outputlen = 0;&#13;
            bytes[] memory elemArray = new bytes[](arrlen);&#13;
            for (uint i = 0; i &lt; arrlen; i++) {&#13;
                elemArray[i] = (bytes(arr[i]));&#13;
                outputlen += elemArray[i].length + (elemArray[i].length - 1)/23 + 3; //+3 accounts for paired identifier types&#13;
            }&#13;
            uint ctr = 0;&#13;
            uint cborlen = arrlen + 0x80;&#13;
            outputlen += byte(cborlen).length;&#13;
            bytes memory res = new bytes(outputlen);&#13;
&#13;
            while (byte(cborlen).length &gt; ctr) {&#13;
                res[ctr] = byte(cborlen)[ctr];&#13;
                ctr++;&#13;
            }&#13;
            for (i = 0; i &lt; arrlen; i++) {&#13;
                res[ctr] = 0x5F;&#13;
                ctr++;&#13;
                for (uint x = 0; x &lt; elemArray[i].length; x++) {&#13;
                    // if there's a bug with larger strings, this may be the culprit&#13;
                    if (x % 23 == 0) {&#13;
                        uint elemcborlen = elemArray[i].length - x &gt;= 24 ? 23 : elemArray[i].length - x;&#13;
                        elemcborlen += 0x40;&#13;
                        uint lctr = ctr;&#13;
                        while (byte(elemcborlen).length &gt; ctr - lctr) {&#13;
                            res[ctr] = byte(elemcborlen)[ctr - lctr];&#13;
                            ctr++;&#13;
                        }&#13;
                    }&#13;
                    res[ctr] = elemArray[i][x];&#13;
                    ctr++;&#13;
                }&#13;
                res[ctr] = 0xFF;&#13;
                ctr++;&#13;
            }&#13;
            return res;&#13;
        }&#13;
&#13;
    function ba2cbor(bytes[] arr) internal returns (bytes) {&#13;
            uint arrlen = arr.length;&#13;
&#13;
            // get correct cbor output length&#13;
            uint outputlen = 0;&#13;
            bytes[] memory elemArray = new bytes[](arrlen);&#13;
            for (uint i = 0; i &lt; arrlen; i++) {&#13;
                elemArray[i] = (bytes(arr[i]));&#13;
                outputlen += elemArray[i].length + (elemArray[i].length - 1)/23 + 3; //+3 accounts for paired identifier types&#13;
            }&#13;
            uint ctr = 0;&#13;
            uint cborlen = arrlen + 0x80;&#13;
            outputlen += byte(cborlen).length;&#13;
            bytes memory res = new bytes(outputlen);&#13;
&#13;
            while (byte(cborlen).length &gt; ctr) {&#13;
                res[ctr] = byte(cborlen)[ctr];&#13;
                ctr++;&#13;
            }&#13;
            for (i = 0; i &lt; arrlen; i++) {&#13;
                res[ctr] = 0x5F;&#13;
                ctr++;&#13;
                for (uint x = 0; x &lt; elemArray[i].length; x++) {&#13;
                    // if there's a bug with larger strings, this may be the culprit&#13;
                    if (x % 23 == 0) {&#13;
                        uint elemcborlen = elemArray[i].length - x &gt;= 24 ? 23 : elemArray[i].length - x;&#13;
                        elemcborlen += 0x40;&#13;
                        uint lctr = ctr;&#13;
                        while (byte(elemcborlen).length &gt; ctr - lctr) {&#13;
                            res[ctr] = byte(elemcborlen)[ctr - lctr];&#13;
                            ctr++;&#13;
                        }&#13;
                    }&#13;
                    res[ctr] = elemArray[i][x];&#13;
                    ctr++;&#13;
                }&#13;
                res[ctr] = 0xFF;&#13;
                ctr++;&#13;
            }&#13;
            return res;&#13;
        }&#13;
&#13;
&#13;
    string oraclize_network_name;&#13;
    function oraclize_setNetworkName(string _network_name) internal {&#13;
        oraclize_network_name = _network_name;&#13;
    }&#13;
&#13;
    function oraclize_getNetworkName() internal returns (string) {&#13;
        return oraclize_network_name;&#13;
    }&#13;
&#13;
    function oraclize_newRandomDSQuery(uint _delay, uint _nbytes, uint _customGasLimit) internal returns (bytes32){&#13;
        if ((_nbytes == 0)||(_nbytes &gt; 32)) throw;&#13;
        bytes memory nbytes = new bytes(1);&#13;
        nbytes[0] = byte(_nbytes);&#13;
        bytes memory unonce = new bytes(32);&#13;
        bytes memory sessionKeyHash = new bytes(32);&#13;
        bytes32 sessionKeyHash_bytes32 = oraclize_randomDS_getSessionPubKeyHash();&#13;
        assembly {&#13;
            mstore(unonce, 0x20)&#13;
            mstore(add(unonce, 0x20), xor(blockhash(sub(number, 1)), xor(coinbase, timestamp)))&#13;
            mstore(sessionKeyHash, 0x20)&#13;
            mstore(add(sessionKeyHash, 0x20), sessionKeyHash_bytes32)&#13;
        }&#13;
        bytes[3] memory args = [unonce, nbytes, sessionKeyHash];&#13;
        bytes32 queryId = oraclize_query(_delay, "random", args, _customGasLimit);&#13;
        oraclize_randomDS_setCommitment(queryId, sha3(bytes8(_delay), args[1], sha256(args[0]), args[2]));&#13;
        return queryId;&#13;
    }&#13;
&#13;
    function oraclize_randomDS_setCommitment(bytes32 queryId, bytes32 commitment) internal {&#13;
        oraclize_randomDS_args[queryId] = commitment;&#13;
    }&#13;
&#13;
    mapping(bytes32=&gt;bytes32) oraclize_randomDS_args;&#13;
    mapping(bytes32=&gt;bool) oraclize_randomDS_sessionKeysHashVerified;&#13;
&#13;
    function verifySig(bytes32 tosignh, bytes dersig, bytes pubkey) internal returns (bool){&#13;
        bool sigok;&#13;
        address signer;&#13;
&#13;
        bytes32 sigr;&#13;
        bytes32 sigs;&#13;
&#13;
        bytes memory sigr_ = new bytes(32);&#13;
        uint offset = 4+(uint(dersig[3]) - 0x20);&#13;
        sigr_ = copyBytes(dersig, offset, 32, sigr_, 0);&#13;
        bytes memory sigs_ = new bytes(32);&#13;
        offset += 32 + 2;&#13;
        sigs_ = copyBytes(dersig, offset+(uint(dersig[offset-1]) - 0x20), 32, sigs_, 0);&#13;
&#13;
        assembly {&#13;
            sigr := mload(add(sigr_, 32))&#13;
            sigs := mload(add(sigs_, 32))&#13;
        }&#13;
&#13;
&#13;
        (sigok, signer) = safer_ecrecover(tosignh, 27, sigr, sigs);&#13;
        if (address(sha3(pubkey)) == signer) return true;&#13;
        else {&#13;
            (sigok, signer) = safer_ecrecover(tosignh, 28, sigr, sigs);&#13;
            return (address(sha3(pubkey)) == signer);&#13;
        }&#13;
    }&#13;
&#13;
    function oraclize_randomDS_proofVerify__sessionKeyValidity(bytes proof, uint sig2offset) internal returns (bool) {&#13;
        bool sigok;&#13;
&#13;
        // Step 6: verify the attestation signature, APPKEY1 must sign the sessionKey from the correct ledger app (CODEHASH)&#13;
        bytes memory sig2 = new bytes(uint(proof[sig2offset+1])+2);&#13;
        copyBytes(proof, sig2offset, sig2.length, sig2, 0);&#13;
&#13;
        bytes memory appkey1_pubkey = new bytes(64);&#13;
        copyBytes(proof, 3+1, 64, appkey1_pubkey, 0);&#13;
&#13;
        bytes memory tosign2 = new bytes(1+65+32);&#13;
        tosign2[0] = 1; //role&#13;
        copyBytes(proof, sig2offset-65, 65, tosign2, 1);&#13;
        bytes memory CODEHASH = hex"fd94fa71bc0ba10d39d464d0d8f465efeef0a2764e3887fcc9df41ded20f505c";&#13;
        copyBytes(CODEHASH, 0, 32, tosign2, 1+65);&#13;
        sigok = verifySig(sha256(tosign2), sig2, appkey1_pubkey);&#13;
&#13;
        if (sigok == false) return false;&#13;
&#13;
&#13;
        // Step 7: verify the APPKEY1 provenance (must be signed by Ledger)&#13;
        bytes memory LEDGERKEY = hex"7fb956469c5c9b89840d55b43537e66a98dd4811ea0a27224272c2e5622911e8537a2f8e86a46baec82864e98dd01e9ccc2f8bc5dfc9cbe5a91a290498dd96e4";&#13;
&#13;
        bytes memory tosign3 = new bytes(1+65);&#13;
        tosign3[0] = 0xFE;&#13;
        copyBytes(proof, 3, 65, tosign3, 1);&#13;
&#13;
        bytes memory sig3 = new bytes(uint(proof[3+65+1])+2);&#13;
        copyBytes(proof, 3+65, sig3.length, sig3, 0);&#13;
&#13;
        sigok = verifySig(sha256(tosign3), sig3, LEDGERKEY);&#13;
&#13;
        return sigok;&#13;
    }&#13;
&#13;
    modifier oraclize_randomDS_proofVerify(bytes32 _queryId, string _result, bytes _proof) {&#13;
        // Step 1: the prefix has to match 'LP\x01' (Ledger Proof version 1)&#13;
        if ((_proof[0] != "L")||(_proof[1] != "P")||(_proof[2] != 1)) throw;&#13;
&#13;
        bool proofVerified = oraclize_randomDS_proofVerify__main(_proof, _queryId, bytes(_result), oraclize_getNetworkName());&#13;
        if (proofVerified == false) throw;&#13;
&#13;
        _;&#13;
    }&#13;
&#13;
    function oraclize_randomDS_proofVerify__returnCode(bytes32 _queryId, string _result, bytes _proof) internal returns (uint8){&#13;
        // Step 1: the prefix has to match 'LP\x01' (Ledger Proof version 1)&#13;
        if ((_proof[0] != "L")||(_proof[1] != "P")||(_proof[2] != 1)) return 1;&#13;
&#13;
        bool proofVerified = oraclize_randomDS_proofVerify__main(_proof, _queryId, bytes(_result), oraclize_getNetworkName());&#13;
        if (proofVerified == false) return 2;&#13;
&#13;
        return 0;&#13;
    }&#13;
&#13;
    function matchBytes32Prefix(bytes32 content, bytes prefix) internal returns (bool){&#13;
        bool match_ = true;&#13;
&#13;
        for (var i=0; i&lt;prefix.length; i++){&#13;
            if (content[i] != prefix[i]) match_ = false;&#13;
        }&#13;
&#13;
        return match_;&#13;
    }&#13;
&#13;
    function oraclize_randomDS_proofVerify__main(bytes proof, bytes32 queryId, bytes result, string context_name) internal returns (bool){&#13;
        bool checkok;&#13;
&#13;
&#13;
        // Step 2: the unique keyhash has to match with the sha256 of (context name + queryId)&#13;
        uint ledgerProofLength = 3+65+(uint(proof[3+65+1])+2)+32;&#13;
        bytes memory keyhash = new bytes(32);&#13;
        copyBytes(proof, ledgerProofLength, 32, keyhash, 0);&#13;
        checkok = (sha3(keyhash) == sha3(sha256(context_name, queryId)));&#13;
        if (checkok == false) return false;&#13;
&#13;
        bytes memory sig1 = new bytes(uint(proof[ledgerProofLength+(32+8+1+32)+1])+2);&#13;
        copyBytes(proof, ledgerProofLength+(32+8+1+32), sig1.length, sig1, 0);&#13;
&#13;
&#13;
        // Step 3: we assume sig1 is valid (it will be verified during step 5) and we verify if 'result' is the prefix of sha256(sig1)&#13;
        checkok = matchBytes32Prefix(sha256(sig1), result);&#13;
        if (checkok == false) return false;&#13;
&#13;
&#13;
        // Step 4: commitment match verification, sha3(delay, nbytes, unonce, sessionKeyHash) == commitment in storage.&#13;
        // This is to verify that the computed args match with the ones specified in the query.&#13;
        bytes memory commitmentSlice1 = new bytes(8+1+32);&#13;
        copyBytes(proof, ledgerProofLength+32, 8+1+32, commitmentSlice1, 0);&#13;
&#13;
        bytes memory sessionPubkey = new bytes(64);&#13;
        uint sig2offset = ledgerProofLength+32+(8+1+32)+sig1.length+65;&#13;
        copyBytes(proof, sig2offset-64, 64, sessionPubkey, 0);&#13;
&#13;
        bytes32 sessionPubkeyHash = sha256(sessionPubkey);&#13;
        if (oraclize_randomDS_args[queryId] == sha3(commitmentSlice1, sessionPubkeyHash)){ //unonce, nbytes and sessionKeyHash match&#13;
            delete oraclize_randomDS_args[queryId];&#13;
        } else return false;&#13;
&#13;
&#13;
        // Step 5: validity verification for sig1 (keyhash and args signed with the sessionKey)&#13;
        bytes memory tosign1 = new bytes(32+8+1+32);&#13;
        copyBytes(proof, ledgerProofLength, 32+8+1+32, tosign1, 0);&#13;
        checkok = verifySig(sha256(tosign1), sig1, sessionPubkey);&#13;
        if (checkok == false) return false;&#13;
&#13;
        // verify if sessionPubkeyHash was verified already, if not.. let's do it!&#13;
        if (oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash] == false){&#13;
            oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash] = oraclize_randomDS_proofVerify__sessionKeyValidity(proof, sig2offset);&#13;
        }&#13;
&#13;
        return oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash];&#13;
    }&#13;
&#13;
&#13;
    // the following function has been written by Alex Beregszaszi (@axic), use it under the terms of the MIT license&#13;
    function copyBytes(bytes from, uint fromOffset, uint length, bytes to, uint toOffset) internal returns (bytes) {&#13;
        uint minLength = length + toOffset;&#13;
&#13;
        if (to.length &lt; minLength) {&#13;
            // Buffer too small&#13;
            throw; // Should be a better way?&#13;
        }&#13;
&#13;
        // NOTE: the offset 32 is added to skip the `size` field of both bytes variables&#13;
        uint i = 32 + fromOffset;&#13;
        uint j = 32 + toOffset;&#13;
&#13;
        while (i &lt; (32 + fromOffset + length)) {&#13;
            assembly {&#13;
                let tmp := mload(add(from, i))&#13;
                mstore(add(to, j), tmp)&#13;
            }&#13;
            i += 32;&#13;
            j += 32;&#13;
        }&#13;
&#13;
        return to;&#13;
    }&#13;
&#13;
    // the following function has been written by Alex Beregszaszi (@axic), use it under the terms of the MIT license&#13;
    // Duplicate Solidity's ecrecover, but catching the CALL return value&#13;
    function safer_ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal returns (bool, address) {&#13;
        // We do our own memory management here. Solidity uses memory offset&#13;
        // 0x40 to store the current end of memory. We write past it (as&#13;
        // writes are memory extensions), but don't update the offset so&#13;
        // Solidity will reuse it. The memory used here is only needed for&#13;
        // this context.&#13;
&#13;
        // FIXME: inline assembly can't access return values&#13;
        bool ret;&#13;
        address addr;&#13;
&#13;
        assembly {&#13;
            let size := mload(0x40)&#13;
            mstore(size, hash)&#13;
            mstore(add(size, 32), v)&#13;
            mstore(add(size, 64), r)&#13;
            mstore(add(size, 96), s)&#13;
&#13;
            // NOTE: we can reuse the request memory because we deal with&#13;
            //       the return code&#13;
            ret := call(3000, 1, 0, size, 128, size, 32)&#13;
            addr := mload(size)&#13;
        }&#13;
&#13;
        return (ret, addr);&#13;
    }&#13;
&#13;
    // the following function has been written by Alex Beregszaszi (@axic), use it under the terms of the MIT license&#13;
    function ecrecovery(bytes32 hash, bytes sig) internal returns (bool, address) {&#13;
        bytes32 r;&#13;
        bytes32 s;&#13;
        uint8 v;&#13;
&#13;
        if (sig.length != 65)&#13;
          return (false, 0);&#13;
&#13;
        // The signature format is a compact form of:&#13;
        //   {bytes32 r}{bytes32 s}{uint8 v}&#13;
        // Compact means, uint8 is not padded to 32 bytes.&#13;
        assembly {&#13;
            r := mload(add(sig, 32))&#13;
            s := mload(add(sig, 64))&#13;
&#13;
            // Here we are loading the last 32 bytes. We exploit the fact that&#13;
            // 'mload' will pad with zeroes if we overread.&#13;
            // There is no 'mload8' to do this, but that would be nicer.&#13;
            v := byte(0, mload(add(sig, 96)))&#13;
&#13;
            // Alternative solution:&#13;
            // 'byte' is not working due to the Solidity parser, so lets&#13;
            // use the second best option, 'and'&#13;
            // v := and(mload(add(sig, 65)), 255)&#13;
        }&#13;
&#13;
        // albeit non-transactional signatures are not specified by the YP, one would expect it&#13;
        // to match the YP range of [27, 28]&#13;
        //&#13;
        // geth uses [0, 1] and some clients have followed. This might change, see:&#13;
        //  https://github.com/ethereum/go-ethereum/issues/2053&#13;
        if (v &lt; 27)&#13;
          v += 27;&#13;
&#13;
        if (v != 27 &amp;&amp; v != 28)&#13;
            return (false, 0);&#13;
&#13;
        return safer_ecrecover(hash, v, r, s);&#13;
    }&#13;
&#13;
}&#13;
// &lt;/ORACLIZE_API&gt;&#13;
&#13;
// File: contracts/FlightDelayOraclizeInterface.sol&#13;
&#13;
/**&#13;
 * FlightDelay with Oraclized Underwriting and Payout&#13;
 *&#13;
 * @description	Ocaclize API interface&#13;
 * @copyright (c) 2017 etherisc GmbH&#13;
 * @author Christoph Mussenbrock, Stephan Karpischek&#13;
 */&#13;
&#13;
pragma solidity ^0.4.11;&#13;
&#13;
&#13;
&#13;
&#13;
contract FlightDelayOraclizeInterface is usingOraclize {&#13;
&#13;
    modifier onlyOraclizeOr (address _emergency) {&#13;
// --&gt; prod-mode&#13;
        require(msg.sender == oraclize_cbAddress() || msg.sender == _emergency);&#13;
// &lt;-- prod-mode&#13;
        _;&#13;
    }&#13;
}&#13;
&#13;
// File: contracts/FlightDelayPayoutInterface.sol&#13;
&#13;
/**&#13;
 * FlightDelay with Oraclized Underwriting and Payout&#13;
 *&#13;
 * @description	Payout contract interface&#13;
 * @copyright (c) 2017 etherisc GmbH&#13;
 * @author Christoph Mussenbrock, Stephan Karpischek&#13;
 */&#13;
&#13;
pragma solidity ^0.4.11;&#13;
&#13;
&#13;
contract FlightDelayPayoutInterface {&#13;
&#13;
    function schedulePayoutOraclizeCall(uint _policyId, bytes32 _riskId, uint _offset) public;&#13;
}&#13;
&#13;
// File: contracts/FlightDelayUnderwriteInterface.sol&#13;
&#13;
/**&#13;
 * FlightDelay with Oraclized Underwriting and Payout&#13;
 *&#13;
 * @description	Underwrite contract interface&#13;
 * @copyright (c) 2017 etherisc GmbH&#13;
 * @author Christoph Mussenbrock, Stephan Karpischek&#13;
 */&#13;
&#13;
pragma solidity ^0.4.11;&#13;
&#13;
&#13;
contract FlightDelayUnderwriteInterface {&#13;
&#13;
    function scheduleUnderwriteOraclizeCall(uint _policyId, bytes32 _carrierFlightNumber) public;&#13;
}&#13;
&#13;
// File: contracts/convertLib.sol&#13;
&#13;
/**&#13;
 * FlightDelay with Oraclized Underwriting and Payout&#13;
 *&#13;
 * @description	Conversions&#13;
 * @copyright (c) 2017 etherisc GmbH&#13;
 * @author Christoph Mussenbrock&#13;
 */&#13;
&#13;
pragma solidity ^0.4.11;&#13;
&#13;
&#13;
contract ConvertLib {&#13;
&#13;
    // .. since beginning of the year&#13;
    uint16[12] days_since = [&#13;
        11,&#13;
        42,&#13;
        70,&#13;
        101,&#13;
        131,&#13;
        162,&#13;
        192,&#13;
        223,&#13;
        254,&#13;
        284,&#13;
        315,&#13;
        345&#13;
    ];&#13;
&#13;
    function b32toString(bytes32 x) internal returns (string) {&#13;
        // gas usage: about 1K gas per char.&#13;
        bytes memory bytesString = new bytes(32);&#13;
        uint charCount = 0;&#13;
&#13;
        for (uint j = 0; j &lt; 32; j++) {&#13;
            byte char = byte(bytes32(uint(x) * 2 ** (8 * j)));&#13;
            if (char != 0) {&#13;
                bytesString[charCount] = char;&#13;
                charCount++;&#13;
            }&#13;
        }&#13;
&#13;
        bytes memory bytesStringTrimmed = new bytes(charCount);&#13;
&#13;
        for (j = 0; j &lt; charCount; j++) {&#13;
            bytesStringTrimmed[j] = bytesString[j];&#13;
        }&#13;
&#13;
        return string(bytesStringTrimmed);&#13;
    }&#13;
&#13;
    function b32toHexString(bytes32 x) returns (string) {&#13;
        bytes memory b = new bytes(64);&#13;
        for (uint i = 0; i &lt; 32; i++) {&#13;
            uint8 by = uint8(uint(x) / (2**(8*(31 - i))));&#13;
            uint8 high = by/16;&#13;
            uint8 low = by - 16*high;&#13;
            if (high &gt; 9) {&#13;
                high += 39;&#13;
            }&#13;
            if (low &gt; 9) {&#13;
                low += 39;&#13;
            }&#13;
            b[2*i] = byte(high+48);&#13;
            b[2*i+1] = byte(low+48);&#13;
        }&#13;
&#13;
        return string(b);&#13;
    }&#13;
&#13;
    function parseInt(string _a) internal returns (uint) {&#13;
        return parseInt(_a, 0);&#13;
    }&#13;
&#13;
    // parseInt(parseFloat*10^_b)&#13;
    function parseInt(string _a, uint _b) internal returns (uint) {&#13;
        bytes memory bresult = bytes(_a);&#13;
        uint mint = 0;&#13;
        bool decimals = false;&#13;
        for (uint i = 0; i&lt;bresult.length; i++) {&#13;
            if ((bresult[i] &gt;= 48)&amp;&amp;(bresult[i] &lt;= 57)) {&#13;
                if (decimals) {&#13;
                    if (_b == 0) {&#13;
                        break;&#13;
                    } else {&#13;
                        _b--;&#13;
                    }&#13;
                }&#13;
                mint *= 10;&#13;
                mint += uint(bresult[i]) - 48;&#13;
            } else if (bresult[i] == 46) {&#13;
                decimals = true;&#13;
            }&#13;
        }&#13;
        if (_b &gt; 0) {&#13;
            mint *= 10**_b;&#13;
        }&#13;
        return mint;&#13;
    }&#13;
&#13;
    // the following function yields correct results in the time between 1.3.2016 and 28.02.2020,&#13;
    // so within the validity of the contract its correct.&#13;
    function toUnixtime(bytes32 _dayMonthYear) constant returns (uint unixtime) {&#13;
        // _day_month_year = /dep/2016/09/10&#13;
        bytes memory bDmy = bytes(b32toString(_dayMonthYear));&#13;
        bytes memory temp2 = bytes(new string(2));&#13;
        bytes memory temp4 = bytes(new string(4));&#13;
&#13;
        temp4[0] = bDmy[5];&#13;
        temp4[1] = bDmy[6];&#13;
        temp4[2] = bDmy[7];&#13;
        temp4[3] = bDmy[8];&#13;
        uint year = parseInt(string(temp4));&#13;
&#13;
        temp2[0] = bDmy[10];&#13;
        temp2[1] = bDmy[11];&#13;
        uint month = parseInt(string(temp2));&#13;
&#13;
        temp2[0] = bDmy[13];&#13;
        temp2[1] = bDmy[14];&#13;
        uint day = parseInt(string(temp2));&#13;
&#13;
        unixtime = ((year - 1970) * 365 + days_since[month-1] + day) * 86400;&#13;
    }&#13;
}&#13;
&#13;
// File: contracts/FlightDelayUnderwrite.sol&#13;
&#13;
/**&#13;
 * FlightDelay with Oraclized Underwriting and Payout&#13;
 *&#13;
 * @description	Underwrite contract&#13;
 * @copyright (c) 2017 etherisc GmbH&#13;
 * @author Christoph Mussenbrock&#13;
 */&#13;
&#13;
pragma solidity ^0.4.11;&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
contract FlightDelayUnderwrite is FlightDelayControlledContract, FlightDelayConstants, FlightDelayOraclizeInterface, ConvertLib {&#13;
&#13;
    using strings for *;&#13;
&#13;
    FlightDelayDatabaseInterface FD_DB;&#13;
    FlightDelayLedgerInterface FD_LG;&#13;
    FlightDelayPayoutInterface FD_PY;&#13;
    FlightDelayAccessControllerInterface FD_AC;&#13;
&#13;
    function FlightDelayUnderwrite(address _controller) public {&#13;
        setController(_controller);&#13;
        oraclize_setCustomGasPrice(ORACLIZE_GASPRICE);&#13;
    }&#13;
&#13;
    function setContracts() public onlyController {&#13;
        FD_AC = FlightDelayAccessControllerInterface(getContract("FD.AccessController"));&#13;
        FD_DB = FlightDelayDatabaseInterface(getContract("FD.Database"));&#13;
        FD_LG = FlightDelayLedgerInterface(getContract("FD.Ledger"));&#13;
        FD_PY = FlightDelayPayoutInterface(getContract("FD.Payout"));&#13;
&#13;
        FD_AC.setPermissionById(101, "FD.NewPolicy");&#13;
        FD_AC.setPermissionById(102, "FD.Funder");&#13;
    }&#13;
&#13;
    /*&#13;
     * @dev Fund contract&#13;
     */&#13;
    function () payable {&#13;
        require(FD_AC.checkPermission(102, msg.sender));&#13;
&#13;
        // todo: bookkeeping&#13;
        // todo: fire funding event&#13;
    }&#13;
&#13;
    function scheduleUnderwriteOraclizeCall(uint _policyId, bytes32 _carrierFlightNumber) public {&#13;
        require(FD_AC.checkPermission(101, msg.sender));&#13;
&#13;
        string memory oraclizeUrl = strConcat(&#13;
            ORACLIZE_RATINGS_BASE_URL,&#13;
            b32toString(_carrierFlightNumber),&#13;
            ORACLIZE_RATINGS_QUERY&#13;
        );&#13;
&#13;
// --&gt; debug-mode&#13;
//            LogUint("_policyId", _policyId);&#13;
//            LogBytes32Str("_carrierFlightNumber",_carrierFlightNumber);&#13;
//            LogString("oraclizeUrl", oraclizeUrl);&#13;
// &lt;-- debug-mode&#13;
&#13;
        bytes32 queryId = oraclize_query("nested", oraclizeUrl, ORACLIZE_GAS);&#13;
&#13;
        // call oraclize to get Flight Stats; this will also call underwrite()&#13;
        FD_DB.createOraclizeCallback(&#13;
            queryId,&#13;
            _policyId,&#13;
            oraclizeState.ForUnderwriting,&#13;
            0&#13;
        );&#13;
&#13;
        LogOraclizeCall(_policyId, queryId, oraclizeUrl, 0);&#13;
    }&#13;
&#13;
    function __callback(bytes32 _queryId, string _result, bytes _proof) onlyOraclizeOr(getContract('FD.Emergency')) public {&#13;
&#13;
        var (policyId,) = FD_DB.getOraclizeCallback(_queryId);&#13;
        LogOraclizeCallback(policyId, _queryId, _result, _proof);&#13;
&#13;
        var slResult = _result.toSlice();&#13;
&#13;
        // we expect result to contain 8 values, something like&#13;
        // "[61, 10, 4, 3, 0, 0, \"CUN\", \"SFO\"]" -&gt;&#13;
        // ['observations','late15','late30','late45','cancelled','diverted','arrivalAirportFsCode','departureAirportFsCode']&#13;
        if (bytes(_result).length == 0) {&#13;
            decline(policyId, "Declined (empty result)", _proof);&#13;
        } else {&#13;
            // now slice the string using&#13;
            // https://github.com/Arachnid/solidity-stringutils&#13;
            if (slResult.count(", ".toSlice()) != 7) {&#13;
                // check if result contains 8 values&#13;
                decline(policyId, "Declined (invalid result)", _proof);&#13;
            } else {&#13;
                slResult.beyond("[".toSlice()).until("]".toSlice());&#13;
&#13;
                uint observations = parseInt(slResult.split(", ".toSlice()).toString());&#13;
&#13;
                // decline on &lt; minObservations observations,&#13;
                // can't calculate reasonable probabibilities&#13;
                if (observations &lt;= MIN_OBSERVATIONS) {&#13;
                    decline(policyId, "Declined (too few observations)", _proof);&#13;
                } else {&#13;
                    uint[6] memory statistics;&#13;
                    // calculate statistics (scaled by 10000; 1% =&gt; 100)&#13;
                    statistics[0] = observations;&#13;
                    for (uint i = 1; i &lt;= 5; i++) {&#13;
                        statistics[i] = parseInt(slResult.split(", ".toSlice()).toString()) * 10000/observations;&#13;
                    }&#13;
&#13;
                    var origin = slResult.split(", ".toSlice());&#13;
                    for (uint j = 0; j &lt; FD_DB.countOrigins(); j++) {&#13;
                        if (b32toString(FD_DB.getOriginByIndex(j)).toSlice().equals(origin)) {&#13;
                            underwrite(policyId, statistics, _proof);&#13;
                            return;&#13;
                        }&#13;
                    }&#13;
&#13;
                    var destination = slResult.split(", ".toSlice());&#13;
                    for (uint k = 0; k &lt; FD_DB.countDestinations(); k++) {&#13;
                        if (b32toString(FD_DB.getDestinationByIndex(k)).toSlice().equals(destination)) {&#13;
                           underwrite(policyId, statistics, _proof);&#13;
                           return;&#13;
                        }&#13;
                    }&#13;
&#13;
                    decline(policyId, "Not acceptable airport", _proof);&#13;
                }&#13;
            }&#13;
        }&#13;
    } // __callback&#13;
&#13;
    function externalDecline(uint _policyId, bytes32 _reason) public {&#13;
        require(msg.sender == FD_CI.getContract("FD.CustomersAdmin"));&#13;
&#13;
        LogPolicyDeclined(_policyId, _reason);&#13;
&#13;
        FD_DB.setState(&#13;
            _policyId,&#13;
            policyState.Declined,&#13;
            now,&#13;
            _reason&#13;
        );&#13;
&#13;
        FD_DB.setWeight(_policyId, 0, "");&#13;
&#13;
        var (customer, premium) = FD_DB.getCustomerPremium(_policyId);&#13;
&#13;
        if (!FD_LG.sendFunds(customer, Acc.Premium, premium)) {&#13;
            FD_DB.setState(&#13;
                _policyId,&#13;
                policyState.SendFailed,&#13;
                now,&#13;
                "decline: Send failed."&#13;
            );&#13;
        }&#13;
    }&#13;
&#13;
    function decline(uint _policyId, bytes32 _reason, bytes _proof)	internal {&#13;
        LogPolicyDeclined(_policyId, _reason);&#13;
&#13;
        FD_DB.setState(&#13;
            _policyId,&#13;
            policyState.Declined,&#13;
            now,&#13;
            _reason&#13;
        );&#13;
&#13;
        FD_DB.setWeight(_policyId, 0, _proof);&#13;
&#13;
        var (customer, premium) = FD_DB.getCustomerPremium(_policyId);&#13;
&#13;
        // TODO: LOG&#13;
        if (!FD_LG.sendFunds(customer, Acc.Premium, premium)) {&#13;
            FD_DB.setState(&#13;
                _policyId,&#13;
                policyState.SendFailed,&#13;
                now,&#13;
                "decline: Send failed."&#13;
            );&#13;
        }&#13;
    }&#13;
&#13;
    function underwrite(uint _policyId, uint[6] _statistics, bytes _proof) internal {&#13;
        var (, premium) = FD_DB.getCustomerPremium(_policyId); // throws if _policyId invalid&#13;
        bytes32 riskId = FD_DB.getRiskId(_policyId);&#13;
&#13;
        var (, premiumMultiplier) = FD_DB.getPremiumFactors(riskId);&#13;
        var (, , arrivalTime) = FD_DB.getRiskParameters(riskId);&#13;
&#13;
        uint weight;&#13;
        for (uint8 i = 1; i &lt;= 5; i++ ) {&#13;
            weight += WEIGHT_PATTERN[i] * _statistics[i];&#13;
            // 1% = 100 / 100% = 10,000&#13;
        }&#13;
        // to avoid div0 in the payout section,&#13;
        // we have to make a minimal assumption on p.weight.&#13;
        if (weight == 0) {&#13;
            weight = 100000 / _statistics[0];&#13;
        }&#13;
&#13;
        // we calculate the factors to limit cluster risks.&#13;
        if (premiumMultiplier == 0) {&#13;
            // it's the first call, we accept any premium&#13;
            FD_DB.setPremiumFactors(riskId, premium * 100000 / weight, 100000 / weight);&#13;
        }&#13;
&#13;
        FD_DB.setWeight(_policyId, weight, _proof);&#13;
&#13;
        FD_DB.setState(&#13;
            _policyId,&#13;
            policyState.Accepted,&#13;
            now,&#13;
            "Policy underwritten by oracle"&#13;
        );&#13;
&#13;
        LogPolicyAccepted(&#13;
            _policyId,&#13;
            _statistics[0],&#13;
            _statistics[1],&#13;
            _statistics[2],&#13;
            _statistics[3],&#13;
            _statistics[4],&#13;
            _statistics[5]&#13;
        );&#13;
&#13;
        // schedule payout Oracle&#13;
        FD_PY.schedulePayoutOraclizeCall(_policyId, riskId, arrivalTime + CHECK_PAYOUT_OFFSET);&#13;
    }&#13;
}