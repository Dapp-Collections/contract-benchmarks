pragma solidity ^0.4.21;

// Written by EtherGuy
// UI: GasWar.surge.sh 
// Mail: <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="4c293824293e2b39350c212d2520622f2321">[emailÂ protected]</a>&#13;
&#13;
contract GasWar{&#13;
    &#13;
    &#13;
    // OPEN 20:00 -&gt; 22:00 UTC &#13;
  //  uint256 public UTCStart = (20 hours); &#13;
//    uint256 public UTCStop = (22 hours);&#13;
    &#13;
    // dev &#13;
    uint256 public UTCStart = (2 hours);&#13;
    uint256 public UTCStop = (4 hours);&#13;
    &#13;
    uint256 public RoundTime = (5 minutes);&#13;
    uint256 public Price = (0.005 ether);&#13;
    &#13;
    uint256 public RoundEndTime;&#13;
    &#13;
    &#13;
    uint256 public GasPrice = 0;&#13;
    address public Winner;&#13;
    //uint256 public  Pot;&#13;
    &#13;
    uint256 public TakePot = 8000; // 80% &#13;
    &#13;
&#13;
    &#13;
    event GameStart(uint256 EndTime);&#13;
    event GameWon(address Winner, uint256 Take);&#13;
    event NewGameLeader(address Leader, uint256 GasPrice, uint256 pot);&#13;
    event NewTX(uint256 pot);&#13;
    &#13;
    address owner;&#13;
&#13;
    function GasWar() public {&#13;
        owner = msg.sender;&#13;
    }&#13;
    &#13;
    function Open() public view returns (bool){&#13;
        uint256 sliced = now % (1 days);&#13;
        return (sliced &gt;= UTCStart &amp;&amp; sliced &lt;= UTCStop);&#13;
    }&#13;
    &#13;
    function NextOpen() public view returns (uint256, uint256){&#13;
        &#13;
        uint256 sliced = now % (1 days);&#13;
        if (sliced &gt; UTCStop){&#13;
            uint256 ret2 = (UTCStop) - sliced + UTCStop;&#13;
            return (ret2, now + ret2);&#13;
        }&#13;
        else{&#13;
            uint256 ret1 = (UTCStart - sliced);&#13;
            return (ret1, now + ret1);&#13;
        }&#13;
    }&#13;
    &#13;
    &#13;
&#13;
&#13;
    &#13;
    function Withdraw() public {&#13;
       &#13;
        //_withdraw(false);&#13;
        // check game withdraws from now on, false prevent re-entrancy&#13;
        CheckGameStart(false);&#13;
    }&#13;
    &#13;
    // please no re-entrancy&#13;
    function _withdraw(bool reduce_price) internal {&#13;
        // One call. &#13;
         require((now &gt; RoundEndTime));&#13;
        require (Winner != 0x0);&#13;
        &#13;
        uint256 subber = 0;&#13;
        if (reduce_price){&#13;
            subber = Price;&#13;
        }&#13;
        uint256 Take = (mul(sub(address(this).balance,subber), TakePot)) / 10000;&#13;
        Winner.transfer(Take);&#13;
&#13;
        &#13;
        emit GameWon(Winner, Take);&#13;
        &#13;
        Winner = 0x0;&#13;
        GasPrice = 0;&#13;
    }&#13;
    &#13;
    function CheckGameStart(bool remove_price) internal returns (bool){&#13;
        if (Winner != 0x0){&#13;
            // if game open remove price from balance &#13;
            // this is to make sure winner does not get extra eth from new round.&#13;
            _withdraw(remove_price &amp;&amp; Open()); // sorry mate, much gas.&#13;
&#13;
        }&#13;
        if (Winner == 0x0 &amp;&amp; Open()){&#13;
            Winner = msg.sender; // from withdraw the gas max is 0.&#13;
            RoundEndTime = now + RoundTime;&#13;
            emit GameStart(RoundEndTime);&#13;
            return true;&#13;
        }&#13;
        return false;&#13;
    }&#13;
    &#13;
    // Function to start game without spending gas. &#13;
    //function PublicCheckGameStart() public {&#13;
    //    require(now &gt; RoundEndTime);&#13;
    //    CheckGameStart();&#13;
    //}&#13;
    // reverted; allows contract drain @ inactive, this should not be the case.&#13;
        &#13;
    function BuyIn() public payable {&#13;
        // We are not going to do any retarded shit here &#13;
        // If you send too much or too less ETH you get rejected &#13;
        // Gas Price is OK but burning lots of it is BS &#13;
        // Sending a TX is 21k gas&#13;
        // If you are going to win you already gotta pay 20k gas to set setting &#13;
        require(msg.value == Price);&#13;
        &#13;
        &#13;
        if (now &gt; RoundEndTime){&#13;
            bool started = CheckGameStart(true);&#13;
            require(started);&#13;
            GasPrice = tx.gasprice;&#13;
            emit NewGameLeader(msg.sender, GasPrice, address(this).balance + (Price * 95)/100);&#13;
        }&#13;
        else{&#13;
            if (tx.gasprice &gt; GasPrice){&#13;
                GasPrice = tx.gasprice;&#13;
                Winner = msg.sender;&#13;
                emit NewGameLeader(msg.sender, GasPrice, address(this).balance + (Price * 95)/100);&#13;
            }&#13;
        }&#13;
        &#13;
        // not reverted &#13;
        &#13;
        owner.transfer((msg.value * 500)/10000); // 5%&#13;
        &#13;
        emit NewTX(address(this).balance + (Price * 95)/100);&#13;
    }&#13;
    &#13;
    // Dev functions to change settings after this line &#13;
 &#13;
     // dev close game &#13;
     // instructions &#13;
     // send v=10000 to this one &#13;
    function SetTakePot(uint256 v) public {&#13;
        require(msg.sender==owner);&#13;
        require (v &lt;= 10000);&#13;
        require(v &gt;= 1000); // do not set v &lt;10% prevent contract blackhole; &#13;
        TakePot = v;&#13;
    }&#13;
    &#13;
    function SetTimes(uint256 NS, uint256 NE) public {&#13;
        require(msg.sender==owner);&#13;
        require(NS &lt; (1 days));&#13;
        require(NE &lt; (1 days));&#13;
        UTCStart = NS;&#13;
        UTCStop = NE;&#13;
    }&#13;
    &#13;
    function SetPrice(uint256 p) public {&#13;
        require(msg.sender == owner);&#13;
        require(!Open() &amp;&amp; (Winner == 0x0)); // dont change game price while running you retard&#13;
        Price = p;&#13;
    }    &#13;
    &#13;
    function SetRoundTime(uint256 p) public{&#13;
        require(msg.sender == owner);&#13;
        require(!Open() &amp;&amp; (Winner == 0x0));&#13;
        RoundTime = p;&#13;
    }   &#13;
 &#13;
 &#13;
 &#13;
 	function mul(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
		if (a == 0) {&#13;
			return 0;&#13;
		}&#13;
		uint256 c = a * b;&#13;
		assert(c / a == b);&#13;
		return c;&#13;
	}&#13;
&#13;
	function div(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
		// assert(b &gt; 0); // Solidity automatically throws when dividing by 0&#13;
		uint256 c = a / b;&#13;
		// assert(a == b * c + a % b); // There is no case in which this doesn't hold&#13;
		return c;&#13;
	}&#13;
&#13;
	function sub(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
		assert(b &lt;= a);&#13;
		return a - b;&#13;
	}&#13;
&#13;
	function add(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
		uint256 c = a + b;&#13;
		assert(c &gt;= a);&#13;
		return c;&#13;
	}&#13;
 &#13;
 &#13;
    &#13;
}