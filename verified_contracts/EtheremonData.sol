pragma solidity ^0.4.16;

// copyright <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="492a26273d282a3d090c3d212c3b2c242627672a2624">[emailÂ protected]</a>&#13;
&#13;
contract SafeMath {&#13;
&#13;
    /* function assert(bool assertion) internal { */&#13;
    /*   if (!assertion) { */&#13;
    /*     throw; */&#13;
    /*   } */&#13;
    /* }      // assert no longer needed once solidity is on 0.4.10 */&#13;
&#13;
    function safeAdd(uint256 x, uint256 y) pure internal returns(uint256) {&#13;
      uint256 z = x + y;&#13;
      assert((z &gt;= x) &amp;&amp; (z &gt;= y));&#13;
      return z;&#13;
    }&#13;
&#13;
    function safeSubtract(uint256 x, uint256 y) pure internal returns(uint256) {&#13;
      assert(x &gt;= y);&#13;
      uint256 z = x - y;&#13;
      return z;&#13;
    }&#13;
&#13;
    function safeMult(uint256 x, uint256 y) pure internal returns(uint256) {&#13;
      uint256 z = x * y;&#13;
      assert((x == 0)||(z/x == y));&#13;
      return z;&#13;
    }&#13;
&#13;
}&#13;
&#13;
contract BasicAccessControl {&#13;
    address public owner;&#13;
    address[] public moderators;&#13;
&#13;
    function BasicAccessControl() public {&#13;
        owner = msg.sender;&#13;
    }&#13;
&#13;
    modifier onlyOwner {&#13;
        require(msg.sender == owner);&#13;
        _;&#13;
    }&#13;
&#13;
    modifier onlyModerators() {&#13;
        if (msg.sender != owner) {&#13;
            bool found = false;&#13;
            for (uint index = 0; index &lt; moderators.length; index++) {&#13;
                if (moderators[index] == msg.sender) {&#13;
                    found = true;&#13;
                    break;&#13;
                }&#13;
            }&#13;
            require(found);&#13;
        }&#13;
        _;&#13;
    }&#13;
&#13;
    function ChangeOwner(address _newOwner) onlyOwner public {&#13;
        if (_newOwner != address(0)) {&#13;
            owner = _newOwner;&#13;
        }&#13;
    }&#13;
&#13;
    function Kill() onlyOwner public {&#13;
        selfdestruct(owner);&#13;
    }&#13;
&#13;
    function AddModerator(address _newModerator) onlyOwner public {&#13;
        if (_newModerator != address(0)) {&#13;
            for (uint index = 0; index &lt; moderators.length; index++) {&#13;
                if (moderators[index] == _newModerator) {&#13;
                    return;&#13;
                }&#13;
            }&#13;
            moderators.push(_newModerator);&#13;
        }&#13;
    }&#13;
    &#13;
    function RemoveModerator(address _oldModerator) onlyOwner public {&#13;
        uint foundIndex = 0;&#13;
        for (; foundIndex &lt; moderators.length; foundIndex++) {&#13;
            if (moderators[foundIndex] == _oldModerator) {&#13;
                break;&#13;
            }&#13;
        }&#13;
        if (foundIndex &lt; moderators.length) {&#13;
            moderators[foundIndex] = moderators[moderators.length-1];&#13;
            delete moderators[moderators.length-1];&#13;
            moderators.length--;&#13;
        }&#13;
    }&#13;
}&#13;
&#13;
&#13;
contract EtheremonEnum {&#13;
&#13;
    enum ResultCode {&#13;
        SUCCESS,&#13;
        ERROR_CLASS_NOT_FOUND,&#13;
        ERROR_LOW_BALANCE,&#13;
        ERROR_SEND_FAIL,&#13;
        ERROR_NOT_TRAINER,&#13;
        ERROR_NOT_ENOUGH_MONEY,&#13;
        ERROR_INVALID_AMOUNT&#13;
    }&#13;
    &#13;
    enum ArrayType {&#13;
        CLASS_TYPE,&#13;
        STAT_STEP,&#13;
        STAT_START,&#13;
        STAT_BASE,&#13;
        OBJ_SKILL&#13;
    }&#13;
}&#13;
&#13;
contract EtheremonDataBase is EtheremonEnum, BasicAccessControl, SafeMath {&#13;
    &#13;
    uint64 public totalMonster;&#13;
    uint32 public totalClass;&#13;
    &#13;
    // write&#13;
    function addElementToArrayType(ArrayType _type, uint64 _id, uint8 _value) onlyModerators public returns(uint);&#13;
    function removeElementOfArrayType(ArrayType _type, uint64 _id, uint8 _value) onlyModerators public returns(uint);&#13;
    function setMonsterClass(uint32 _classId, uint256 _price, uint256 _returnPrice, bool _catchable) onlyModerators public returns(uint32);&#13;
    function addMonsterObj(uint32 _classId, address _trainer, string _name) onlyModerators public returns(uint64);&#13;
    function setMonsterObj(uint64 _objId, string _name, uint32 _exp, uint32 _createIndex, uint32 _lastClaimIndex) onlyModerators public;&#13;
    function increaseMonsterExp(uint64 _objId, uint32 amount) onlyModerators public;&#13;
    function decreaseMonsterExp(uint64 _objId, uint32 amount) onlyModerators public;&#13;
    function removeMonsterIdMapping(address _trainer, uint64 _monsterId) onlyModerators public;&#13;
    function addMonsterIdMapping(address _trainer, uint64 _monsterId) onlyModerators public;&#13;
    function clearMonsterReturnBalance(uint64 _monsterId) onlyModerators public returns(uint256 amount);&#13;
    function collectAllReturnBalance(address _trainer) onlyModerators public returns(uint256 amount);&#13;
    function transferMonster(address _from, address _to, uint64 _monsterId) onlyModerators public returns(ResultCode);&#13;
    function addExtraBalance(address _trainer, uint256 _amount) onlyModerators public returns(uint256);&#13;
    function deductExtraBalance(address _trainer, uint256 _amount) onlyModerators public returns(uint256);&#13;
    function setExtraBalance(address _trainer, uint256 _amount) onlyModerators public;&#13;
    &#13;
    // read&#13;
    function getSizeArrayType(ArrayType _type, uint64 _id) constant public returns(uint);&#13;
    function getElementInArrayType(ArrayType _type, uint64 _id, uint _index) constant public returns(uint8);&#13;
    function getMonsterClass(uint32 _classId) constant public returns(uint32 classId, uint256 price, uint256 returnPrice, uint32 total, bool catchable);&#13;
    function getMonsterObj(uint64 _objId) constant public returns(uint64 objId, uint32 classId, address trainer, uint32 exp, uint32 createIndex, uint32 lastClaimIndex, uint createTime);&#13;
    function getMonsterName(uint64 _objId) constant public returns(string name);&#13;
    function getExtraBalance(address _trainer) constant public returns(uint256);&#13;
    function getMonsterDexSize(address _trainer) constant public returns(uint);&#13;
    function getMonsterObjId(address _trainer, uint index) constant public returns(uint64);&#13;
    function getExpectedBalance(address _trainer) constant public returns(uint256);&#13;
    function getMonsterReturn(uint64 _objId) constant public returns(uint256 current, uint256 total);&#13;
}&#13;
&#13;
contract EtheremonData is EtheremonDataBase {&#13;
&#13;
    struct MonsterClass {&#13;
        uint32 classId;&#13;
        uint8[] types;&#13;
        uint8[] statSteps;&#13;
        uint8[] statStarts;&#13;
        uint256 price;&#13;
        uint256 returnPrice;&#13;
        uint32 total;&#13;
        bool catchable;&#13;
    }&#13;
    &#13;
    struct MonsterObj {&#13;
        uint64 monsterId;&#13;
        uint32 classId;&#13;
        address trainer;&#13;
        string name;&#13;
        uint32 exp;&#13;
        uint8[] statBases;&#13;
        uint8[] skills;&#13;
        uint32 createIndex;&#13;
        uint32 lastClaimIndex;&#13;
        uint createTime;&#13;
    }&#13;
&#13;
    mapping(uint32 =&gt; MonsterClass) public monsterClass;&#13;
    mapping(uint64 =&gt; MonsterObj) public monsterWorld;&#13;
    mapping(address =&gt; uint64[]) public trainerDex;&#13;
    mapping(address =&gt; uint256) public trainerExtraBalance;&#13;
    &#13;
    &#13;
    // write access&#13;
    function withdrawEther(address _sendTo, uint _amount) onlyOwner public returns(ResultCode) {&#13;
        if (_amount &gt; this.balance) {&#13;
            return ResultCode.ERROR_INVALID_AMOUNT;&#13;
        }&#13;
        &#13;
        _sendTo.transfer(_amount);&#13;
        return ResultCode.SUCCESS;&#13;
    }&#13;
    &#13;
    function addElementToArrayType(ArrayType _type, uint64 _id, uint8 _value) onlyModerators public returns(uint) {&#13;
        uint8[] storage array = monsterWorld[_id].statBases;&#13;
        if (_type == ArrayType.CLASS_TYPE) {&#13;
            array = monsterClass[uint32(_id)].types;&#13;
        } else if (_type == ArrayType.STAT_STEP) {&#13;
            array = monsterClass[uint32(_id)].statSteps;&#13;
        } else if (_type == ArrayType.STAT_START) {&#13;
            array = monsterClass[uint32(_id)].statStarts;&#13;
        } else if (_type == ArrayType.OBJ_SKILL) {&#13;
            array = monsterWorld[_id].skills;&#13;
        } &#13;
        for (uint index = 0; index &lt; array.length; index++) {&#13;
            if (array[index] == _value) {&#13;
                return array.length;&#13;
            }&#13;
        }&#13;
        array.push(_value);&#13;
        return array.length;&#13;
    }&#13;
    &#13;
    function removeElementOfArrayType(ArrayType _type, uint64 _id, uint8 _value) onlyModerators public returns(uint) {&#13;
        uint8[] storage array = monsterWorld[_id].statBases;&#13;
        if (_type == ArrayType.CLASS_TYPE) {&#13;
            array = monsterClass[uint32(_id)].types;&#13;
        } else if (_type == ArrayType.STAT_STEP) {&#13;
            array = monsterClass[uint32(_id)].statSteps;&#13;
        } else if (_type == ArrayType.STAT_START) {&#13;
            array = monsterClass[uint32(_id)].statStarts;&#13;
        } else if (_type == ArrayType.OBJ_SKILL) {&#13;
            array = monsterWorld[_id].skills;&#13;
        }&#13;
        uint foundIndex = 0;&#13;
        for (; foundIndex &lt; array.length; foundIndex++) {&#13;
            if (array[foundIndex] == _value) {&#13;
                break;&#13;
            }&#13;
        }&#13;
        if (foundIndex &lt; array.length) {&#13;
            array[foundIndex] = array[array.length-1];&#13;
            delete array[array.length-1];&#13;
            array.length--;&#13;
        }&#13;
    }&#13;
    &#13;
    function setMonsterClass(uint32 _classId, uint256 _price, uint256 _returnPrice, bool _catchable) onlyModerators public returns(uint32) {&#13;
        MonsterClass storage class = monsterClass[_classId];&#13;
        if (class.classId == 0) {&#13;
            totalClass += 1;&#13;
        }&#13;
        class.classId = _classId;&#13;
        class.price = _price;&#13;
        class.returnPrice = _returnPrice;&#13;
        class.catchable = _catchable;&#13;
        return totalClass;&#13;
    }&#13;
    &#13;
    function addMonsterObj(uint32 _classId, address _trainer, string _name) onlyModerators public returns(uint64) {&#13;
        MonsterClass storage class = monsterClass[_classId];&#13;
        if (class.classId == 0)&#13;
            return 0;&#13;
                &#13;
        // construct new monster&#13;
        totalMonster += 1;&#13;
        class.total += 1;&#13;
&#13;
        MonsterObj storage obj = monsterWorld[totalMonster];&#13;
        obj.monsterId = totalMonster;&#13;
        obj.classId = _classId;&#13;
        obj.trainer = _trainer;&#13;
        obj.name = _name;&#13;
        obj.exp = 1;&#13;
        obj.createIndex = class.total;&#13;
        obj.lastClaimIndex = class.total;&#13;
        obj.createTime = now;&#13;
&#13;
        // add to monsterdex&#13;
        addMonsterIdMapping(_trainer, obj.monsterId);&#13;
        return obj.monsterId;&#13;
    }&#13;
    &#13;
    function setMonsterObj(uint64 _objId, string _name, uint32 _exp, uint32 _createIndex, uint32 _lastClaimIndex) onlyModerators public {&#13;
        MonsterObj storage obj = monsterWorld[_objId];&#13;
        if (obj.monsterId == _objId) {&#13;
            obj.name = _name;&#13;
            obj.exp = _exp;&#13;
            obj.createIndex = _createIndex;&#13;
            obj.lastClaimIndex = _lastClaimIndex;&#13;
        }&#13;
    }&#13;
&#13;
    function increaseMonsterExp(uint64 _objId, uint32 amount) onlyModerators public {&#13;
        MonsterObj storage obj = monsterWorld[_objId];&#13;
        if (obj.monsterId == _objId) {&#13;
            obj.exp = uint32(safeAdd(obj.exp, amount));&#13;
        }&#13;
    }&#13;
&#13;
    function decreaseMonsterExp(uint64 _objId, uint32 amount) onlyModerators public {&#13;
        MonsterObj storage obj = monsterWorld[_objId];&#13;
        if (obj.monsterId == _objId) {&#13;
            obj.exp = uint32(safeSubtract(obj.exp, amount));&#13;
        }&#13;
    }&#13;
&#13;
    function removeMonsterIdMapping(address _trainer, uint64 _monsterId) onlyModerators public {&#13;
        uint foundIndex = 0;&#13;
        uint64[] storage objIdList = trainerDex[_trainer];&#13;
        for (; foundIndex &lt; objIdList.length; foundIndex++) {&#13;
            if (objIdList[foundIndex] == _monsterId) {&#13;
                break;&#13;
            }&#13;
        }&#13;
        if (foundIndex &lt; objIdList.length) {&#13;
            objIdList[foundIndex] = objIdList[objIdList.length-1];&#13;
            delete objIdList[objIdList.length-1];&#13;
            objIdList.length--;&#13;
            MonsterObj storage monster = monsterWorld[_monsterId];&#13;
            monster.trainer = 0;&#13;
        }&#13;
    }&#13;
    &#13;
    function addMonsterIdMapping(address _trainer, uint64 _monsterId) onlyModerators public {&#13;
        if (_trainer != address(0) &amp;&amp; _monsterId &gt; 0) {&#13;
            uint64[] storage objIdList = trainerDex[_trainer];&#13;
            for (uint i = 0; i &lt; objIdList.length; i++) {&#13;
                if (objIdList[i] == _monsterId) {&#13;
                    return;&#13;
                }&#13;
            }&#13;
            objIdList.push(_monsterId);&#13;
            MonsterObj storage monster = monsterWorld[_monsterId];&#13;
            monster.trainer = _trainer;&#13;
        }&#13;
    }&#13;
    &#13;
    function clearMonsterReturnBalance(uint64 _monsterId) onlyModerators public returns(uint256) {&#13;
        MonsterObj storage monster = monsterWorld[_monsterId];&#13;
        MonsterClass storage class = monsterClass[monster.classId];&#13;
        if (monster.monsterId == 0 || class.classId == 0)&#13;
            return 0;&#13;
        uint256 amount = 0;&#13;
        uint32 gap = uint32(safeSubtract(class.total, monster.lastClaimIndex));&#13;
        if (gap &gt; 0) {&#13;
            monster.lastClaimIndex = class.total;&#13;
            amount = safeMult(gap, class.returnPrice);&#13;
            trainerExtraBalance[monster.trainer] = safeAdd(trainerExtraBalance[monster.trainer], amount);&#13;
        }&#13;
        return amount;&#13;
    }&#13;
    &#13;
    function collectAllReturnBalance(address _trainer) onlyModerators public returns(uint256 amount) {&#13;
        uint64[] storage objIdList = trainerDex[_trainer];&#13;
        for (uint i = 0; i &lt; objIdList.length; i++) {&#13;
            clearMonsterReturnBalance(objIdList[i]);&#13;
        }&#13;
        return trainerExtraBalance[_trainer];&#13;
    }&#13;
    &#13;
    function transferMonster(address _from, address _to, uint64 _monsterId) onlyModerators public returns(ResultCode) {&#13;
        MonsterObj storage monster = monsterWorld[_monsterId];&#13;
        if (monster.trainer != _from) {&#13;
            return ResultCode.ERROR_NOT_TRAINER;&#13;
        }&#13;
        &#13;
        clearMonsterReturnBalance(_monsterId);&#13;
        &#13;
        removeMonsterIdMapping(_from, _monsterId);&#13;
        addMonsterIdMapping(_to, _monsterId);&#13;
        return ResultCode.SUCCESS;&#13;
    }&#13;
    &#13;
    function addExtraBalance(address _trainer, uint256 _amount) onlyModerators public returns(uint256) {&#13;
        trainerExtraBalance[_trainer] = safeAdd(trainerExtraBalance[_trainer], _amount);&#13;
        return trainerExtraBalance[_trainer];&#13;
    }&#13;
    &#13;
    function deductExtraBalance(address _trainer, uint256 _amount) onlyModerators public returns(uint256) {&#13;
        trainerExtraBalance[_trainer] = safeSubtract(trainerExtraBalance[_trainer], _amount);&#13;
        return trainerExtraBalance[_trainer];&#13;
    }&#13;
    &#13;
    function setExtraBalance(address _trainer, uint256 _amount) onlyModerators public {&#13;
        trainerExtraBalance[_trainer] = _amount;&#13;
    }&#13;
    &#13;
    &#13;
    // public&#13;
    function () payable public {&#13;
        addExtraBalance(msg.sender, msg.value);&#13;
    }&#13;
&#13;
    // read access&#13;
    function getSizeArrayType(ArrayType _type, uint64 _id) constant public returns(uint) {&#13;
        uint8[] storage array = monsterWorld[_id].statBases;&#13;
        if (_type == ArrayType.CLASS_TYPE) {&#13;
            array = monsterClass[uint32(_id)].types;&#13;
        } else if (_type == ArrayType.STAT_STEP) {&#13;
            array = monsterClass[uint32(_id)].statSteps;&#13;
        } else if (_type == ArrayType.STAT_START) {&#13;
            array = monsterClass[uint32(_id)].statStarts;&#13;
        } else if (_type == ArrayType.OBJ_SKILL) {&#13;
            array = monsterWorld[_id].skills;&#13;
        }&#13;
        return array.length;&#13;
    }&#13;
    &#13;
    function getElementInArrayType(ArrayType _type, uint64 _id, uint _index) constant public returns(uint8) {&#13;
        uint8[] storage array = monsterWorld[_id].statBases;&#13;
        if (_type == ArrayType.CLASS_TYPE) {&#13;
            array = monsterClass[uint32(_id)].types;&#13;
        } else if (_type == ArrayType.STAT_STEP) {&#13;
            array = monsterClass[uint32(_id)].statSteps;&#13;
        } else if (_type == ArrayType.STAT_START) {&#13;
            array = monsterClass[uint32(_id)].statStarts;&#13;
        } else if (_type == ArrayType.OBJ_SKILL) {&#13;
            array = monsterWorld[_id].skills;&#13;
        }&#13;
        if (_index &gt;= array.length)&#13;
            return 0;&#13;
        return array[_index];&#13;
    }&#13;
    &#13;
    &#13;
    function getMonsterClass(uint32 _classId) constant public returns(uint32 classId, uint256 price, uint256 returnPrice, uint32 total, bool catchable) {&#13;
        MonsterClass storage class = monsterClass[_classId];&#13;
        classId = class.classId;&#13;
        price = class.price;&#13;
        returnPrice = class.returnPrice;&#13;
        total = class.total;&#13;
        catchable = class.catchable;&#13;
    }&#13;
    &#13;
    function getMonsterObj(uint64 _objId) constant public returns(uint64 objId, uint32 classId, address trainer, uint32 exp, uint32 createIndex, uint32 lastClaimIndex, uint createTime) {&#13;
        MonsterObj storage monster = monsterWorld[_objId];&#13;
        objId = monster.monsterId;&#13;
        classId = monster.classId;&#13;
        trainer = monster.trainer;&#13;
        exp = monster.exp;&#13;
        createIndex = monster.createIndex;&#13;
        lastClaimIndex = monster.lastClaimIndex;&#13;
        createTime = monster.createTime;&#13;
    }&#13;
    &#13;
    function getMonsterName(uint64 _objId) constant public returns(string name) {&#13;
        return monsterWorld[_objId].name;&#13;
    }&#13;
&#13;
    function getExtraBalance(address _trainer) constant public returns(uint256) {&#13;
        return trainerExtraBalance[_trainer];&#13;
    }&#13;
    &#13;
    function getMonsterDexSize(address _trainer) constant public returns(uint) {&#13;
        return trainerDex[_trainer].length;&#13;
    }&#13;
    &#13;
    function getMonsterObjId(address _trainer, uint index) constant public returns(uint64) {&#13;
        if (index &gt;= trainerDex[_trainer].length)&#13;
            return 0;&#13;
        return trainerDex[_trainer][index];&#13;
    }&#13;
    &#13;
    function getExpectedBalance(address _trainer) constant public returns(uint256) {&#13;
        uint64[] storage objIdList = trainerDex[_trainer];&#13;
        uint256 monsterBalance = 0;&#13;
        for (uint i = 0; i &lt; objIdList.length; i++) {&#13;
            MonsterObj memory monster = monsterWorld[objIdList[i]];&#13;
            MonsterClass storage class = monsterClass[monster.classId];&#13;
            uint32 gap = uint32(safeSubtract(class.total, monster.lastClaimIndex));&#13;
            monsterBalance += safeMult(gap, class.returnPrice);&#13;
        }&#13;
        return monsterBalance;&#13;
    }&#13;
    &#13;
    function getMonsterReturn(uint64 _objId) constant public returns(uint256 current, uint256 total) {&#13;
        MonsterObj memory monster = monsterWorld[_objId];&#13;
        MonsterClass storage class = monsterClass[monster.classId];&#13;
        uint32 totalGap = uint32(safeSubtract(class.total, monster.createIndex));&#13;
        uint32 currentGap = uint32(safeSubtract(class.total, monster.lastClaimIndex));&#13;
        return (safeMult(currentGap, class.returnPrice), safeMult(totalGap, class.returnPrice));&#13;
    }&#13;
&#13;
}