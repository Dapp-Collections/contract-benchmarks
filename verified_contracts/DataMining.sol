/* ==================================================================== */
/* Copyright (c) 2018 The ether.online Project.  All rights reserved.
/* 
/* https://ether.online  The first RPG game of blockchain 
/*  
/* authors <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="83f1eae0e8ebf6edf7e6f1adf0ebe6edc3e4eee2eaefade0ecee">[email protected]</a>   &#13;
/*         <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="097a7a6c7a7c676d60676e496e64686065276a6664">[email protected]</a>            &#13;
/* ==================================================================== */&#13;
&#13;
pragma solidity ^0.4.20;&#13;
&#13;
contract AccessAdmin {&#13;
    bool public isPaused = false;&#13;
    address public addrAdmin;  &#13;
&#13;
    event AdminTransferred(address indexed preAdmin, address indexed newAdmin);&#13;
&#13;
    function AccessAdmin() public {&#13;
        addrAdmin = msg.sender;&#13;
    }  &#13;
&#13;
    modifier onlyAdmin() {&#13;
        require(msg.sender == addrAdmin);&#13;
        _;&#13;
    }&#13;
&#13;
    modifier whenNotPaused() {&#13;
        require(!isPaused);&#13;
        _;&#13;
    }&#13;
&#13;
    modifier whenPaused {&#13;
        require(isPaused);&#13;
        _;&#13;
    }&#13;
&#13;
    function setAdmin(address _newAdmin) external onlyAdmin {&#13;
        require(_newAdmin != address(0));&#13;
        AdminTransferred(addrAdmin, _newAdmin);&#13;
        addrAdmin = _newAdmin;&#13;
    }&#13;
&#13;
    function doPause() external onlyAdmin whenNotPaused {&#13;
        isPaused = true;&#13;
    }&#13;
&#13;
    function doUnpause() external onlyAdmin whenPaused {&#13;
        isPaused = false;&#13;
    }&#13;
}&#13;
&#13;
contract AccessService is AccessAdmin {&#13;
    address public addrService;&#13;
    address public addrFinance;&#13;
&#13;
    modifier onlyService() {&#13;
        require(msg.sender == addrService);&#13;
        _;&#13;
    }&#13;
&#13;
    modifier onlyFinance() {&#13;
        require(msg.sender == addrFinance);&#13;
        _;&#13;
    }&#13;
&#13;
    function setService(address _newService) external {&#13;
        require(msg.sender == addrService || msg.sender == addrAdmin);&#13;
        require(_newService != address(0));&#13;
        addrService = _newService;&#13;
    }&#13;
&#13;
    function setFinance(address _newFinance) external {&#13;
        require(msg.sender == addrFinance || msg.sender == addrAdmin);&#13;
        require(_newFinance != address(0));&#13;
        addrFinance = _newFinance;&#13;
    }&#13;
&#13;
    function withdraw(address _target, uint256 _amount) &#13;
        external &#13;
    {&#13;
        require(msg.sender == addrFinance || msg.sender == addrAdmin);&#13;
        require(_amount &gt; 0);&#13;
        address receiver = _target == address(0) ? addrFinance : _target;&#13;
        uint256 balance = this.balance;&#13;
        if (_amount &lt; balance) {&#13;
            receiver.transfer(_amount);&#13;
        } else {&#13;
            receiver.transfer(this.balance);&#13;
        }      &#13;
    }&#13;
}&#13;
&#13;
interface IDataMining {&#13;
    function getRecommender(address _target) external view returns(address);&#13;
    function subFreeMineral(address _target) external returns(bool);&#13;
}&#13;
&#13;
interface IDataEquip {&#13;
    function isEquiped(address _target, uint256 _tokenId) external view returns(bool);&#13;
    function isEquipedAny2(address _target, uint256 _tokenId1, uint256 _tokenId2) external view returns(bool);&#13;
    function isEquipedAny3(address _target, uint256 _tokenId1, uint256 _tokenId2, uint256 _tokenId3) external view returns(bool);&#13;
}&#13;
&#13;
contract DataMining is AccessService, IDataMining {&#13;
    event RecommenderChange(address indexed _target, address _recommender);&#13;
    event FreeMineralChange(address indexed _target, uint32 _accCnt);&#13;
&#13;
    /// @dev Recommend relationship map&#13;
    mapping (address =&gt; address) recommendRelation;&#13;
    /// @dev Free mining count map&#13;
    mapping (address =&gt; uint32) freeMineral;&#13;
    /// @dev Trust contract&#13;
    mapping (address =&gt; bool) actionContracts;&#13;
&#13;
    function DataMining() public {&#13;
        addrAdmin = msg.sender;&#13;
        addrService = msg.sender;&#13;
        addrFinance = msg.sender;&#13;
    }&#13;
&#13;
    function setRecommender(address _target, address _recommender) &#13;
        external&#13;
        onlyService&#13;
    {&#13;
        require(_target != address(0));&#13;
        recommendRelation[_target] = _recommender;&#13;
        RecommenderChange(_target, _recommender);&#13;
    }&#13;
&#13;
    function setRecommenderMulti(address[] _targets, address[] _recommenders) &#13;
        external&#13;
        onlyService&#13;
    {&#13;
        uint256 targetLength = _targets.length;&#13;
        require(targetLength &lt;= 64);&#13;
        require(targetLength == _recommenders.length);&#13;
        address addrZero = address(0);&#13;
        for (uint256 i = 0; i &lt; targetLength; ++i) {&#13;
            if (_targets[i] != addrZero) {&#13;
                recommendRelation[_targets[i]] = _recommenders[i];&#13;
                RecommenderChange(_targets[i], _recommenders[i]);&#13;
            }&#13;
        }&#13;
    }&#13;
&#13;
    function getRecommender(address _target) external view returns(address) {&#13;
        return recommendRelation[_target];&#13;
    }&#13;
&#13;
    function addFreeMineral(address _target, uint32 _cnt)  &#13;
        external&#13;
        onlyService&#13;
    {&#13;
        require(_target != address(0));&#13;
        require(_cnt &lt;= 32);&#13;
        uint32 oldCnt = freeMineral[_target];&#13;
        freeMineral[_target] = oldCnt + _cnt;&#13;
        FreeMineralChange(_target, freeMineral[_target]);&#13;
    }&#13;
&#13;
    function addFreeMineralMulti(address[] _targets, uint32[] _cnts)&#13;
        external&#13;
        onlyService&#13;
    {&#13;
        uint256 targetLength = _targets.length;&#13;
        require(targetLength &lt;= 64);&#13;
        require(targetLength == _cnts.length);&#13;
        address addrZero = address(0);&#13;
        uint32 oldCnt;&#13;
        uint32 newCnt;&#13;
        address addr;&#13;
        for (uint256 i = 0; i &lt; targetLength; ++i) {&#13;
            addr = _targets[i];&#13;
            if (addr != addrZero &amp;&amp; _cnts[i] &lt;= 32) {&#13;
                oldCnt = freeMineral[addr];&#13;
                newCnt = oldCnt + _cnts[i];&#13;
                assert(oldCnt &lt; newCnt);&#13;
                freeMineral[addr] = newCnt;&#13;
                FreeMineralChange(addr, freeMineral[addr]);&#13;
            }&#13;
        }&#13;
    }&#13;
&#13;
    function setActionContract(address _actionAddr, bool _useful) external onlyAdmin {&#13;
        actionContracts[_actionAddr] = _useful;&#13;
    }&#13;
&#13;
    function getActionContract(address _actionAddr) external view onlyAdmin returns(bool) {&#13;
        return actionContracts[_actionAddr];&#13;
    }&#13;
&#13;
    function subFreeMineral(address _target) external returns(bool) {&#13;
        require(actionContracts[msg.sender]);&#13;
        require(_target != address(0));&#13;
        uint32 cnts = freeMineral[_target];&#13;
        assert(cnts &gt; 0);&#13;
        freeMineral[_target] = cnts - 1;&#13;
        FreeMineralChange(_target, cnts - 1);&#13;
        return true;&#13;
    }&#13;
&#13;
    function getFreeMineral(address _target) external view returns(uint32) {&#13;
        return freeMineral[_target];&#13;
    }&#13;
}