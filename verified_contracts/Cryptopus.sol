//sol Cryptopus
// @authors:
// Alexandr Romanov <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="70021d1e16165e1415063009111e1415085e0205">[emailÂ protected]</a>&gt;&#13;
// usage:&#13;
// use modifiers isOwner (just own owned).&#13;
pragma solidity ^0.4.10;&#13;
&#13;
contract checkedMathematics {&#13;
    function checkedAddition(uint256 x, uint256 y) pure internal returns(uint256) {&#13;
      uint256 z = x + y;&#13;
      assert((z &gt;= x) &amp;&amp; (z &gt;= y));&#13;
      return z;&#13;
    }&#13;
    function checkedSubtract(uint256 x, uint256 y) pure internal returns(uint256) {&#13;
      assert(x &gt;= y);&#13;
      uint256 z = x - y;&#13;
      return z;&#13;
    }&#13;
    function checkedMultiplication(uint256 x, uint256 y) pure internal returns(uint256) {&#13;
      uint256 z = x * y;&#13;
      assert((x == 0)||(z/x == y));&#13;
      return z;&#13;
    }&#13;
    function checkedDivision(uint256 a, uint256 b) pure internal returns (uint256) {&#13;
      assert(b &gt; 0);&#13;
      uint c = a / b;&#13;
      assert(a == b * c + a % b);&#13;
      return c;&#13;
    }&#13;
}&#13;
&#13;
contract ERC20Token {&#13;
    uint256 public totalSupply;&#13;
    function balanceOf(address _owner) public constant returns (uint256 balance);&#13;
    function transfer(address _to, uint256 _value) public returns (bool success);&#13;
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);&#13;
    function approve(address _spender, uint256 _value) public returns (bool success);&#13;
    function allowance(address _owner, address _spender) public constant returns (uint256 remaining);&#13;
    event Transfer(address indexed _from, address indexed _to, uint256 _value);&#13;
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);&#13;
}&#13;
&#13;
contract StandardToken is ERC20Token {&#13;
&#13;
    function transfer(address _to, uint256 _value) public returns (bool success) {&#13;
      if (balances[msg.sender] &gt;= _value &amp;&amp; _value &gt; 0) {&#13;
        balances[msg.sender] -= _value;&#13;
        balances[_to] += _value;&#13;
        Transfer(msg.sender, _to, _value);&#13;
        return true;&#13;
      } else {&#13;
        return false;&#13;
      }&#13;
    }&#13;
&#13;
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {&#13;
      if (balances[_from] &gt;= _value &amp;&amp; allowed[_from][msg.sender] &gt;= _value &amp;&amp; _value &gt; 0) {&#13;
        balances[_to] += _value;&#13;
        balances[_from] -= _value;&#13;
        allowed[_from][msg.sender] -= _value;&#13;
        Transfer(_from, _to, _value);&#13;
        return true;&#13;
      } else {&#13;
        return false;&#13;
      }&#13;
    }&#13;
&#13;
    function balanceOf(address _owner) public constant returns (uint256 balance) {&#13;
        return balances[_owner];&#13;
    }&#13;
&#13;
    function approve(address _spender, uint256 _value) public returns (bool success) {&#13;
        allowed[msg.sender][_spender] = _value;&#13;
        Approval(msg.sender, _spender, _value);&#13;
        return true;&#13;
    }&#13;
&#13;
    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {&#13;
      return allowed[_owner][_spender];&#13;
    }&#13;
&#13;
    mapping (address =&gt; uint256) balances;&#13;
    mapping (address =&gt; mapping (address =&gt; uint256)) allowed;&#13;
}&#13;
&#13;
contract Cryptopus is checkedMathematics, StandardToken {&#13;
&#13;
    string public constant name                      = "Cryptopus Token";&#13;
    string public constant symbol                    = "CPP"; // Still unused symbol we are using now&#13;
    uint256 public constant decimals                 = 18;&#13;
    uint256 private constant tokenCreationCapICO025  = 10000000**decimals;&#13;
    uint256 private constant tokenCreationCapICO030  = 10000000**decimals;&#13;
    uint256 public  constant tokenCreationCapOverall = 20000000**decimals;&#13;
&#13;
    address public owner;&#13;
&#13;
    // 1 ETH = $470 USD Date: December 1st, 2017&#13;
    uint private oneTokenInWeiSale1  = 530000000000000; // $0.25 USD&#13;
    uint private oneTokenInWeiSale2  = 590000000000000; // $0.28 USD&#13;
    uint private oneTokenInWeiSale3  = 640000000000000; // $0.30 USD&#13;
    uint private oneTokenInWeiNormal = 680000000000000; // $0.32 USD&#13;
&#13;
    Phase public currentPhase = Phase.ICOweek1;&#13;
&#13;
    enum Phase {&#13;
        ICOweek1,&#13;
        ICOweek2,&#13;
        ICOweek3,&#13;
        NormalLife&#13;
    }&#13;
&#13;
    modifier isOwner {&#13;
        if(owner != msg.sender) revert();&#13;
        _;&#13;
    }&#13;
&#13;
    event CreateCPP(address indexed _to, uint256 _value);&#13;
&#13;
    function Cryptopus() public {&#13;
      owner = msg.sender;&#13;
    }&#13;
&#13;
    function () public payable {&#13;
        createTokens();&#13;
    }&#13;
&#13;
    function createTokens() internal {&#13;
        if (msg.value &lt;= 0) revert();&#13;
&#13;
        if (currentPhase == Phase.ICOweek1) {&#13;
            if (totalSupply &lt;= tokenCreationCapICO025) {&#13;
                generateTokens(oneTokenInWeiSale1);&#13;
            }&#13;
        }&#13;
        else if (currentPhase == Phase.ICOweek2) {&#13;
            if (totalSupply &gt; tokenCreationCapICO025 &amp;&amp; totalSupply &lt;= tokenCreationCapICO030) {&#13;
                generateTokens(oneTokenInWeiSale2);&#13;
            }&#13;
        }&#13;
        else if (currentPhase == Phase.ICOweek3) {&#13;
            if (totalSupply &gt; tokenCreationCapICO030 &amp;&amp; totalSupply &lt;= tokenCreationCapOverall) {&#13;
                generateTokens(oneTokenInWeiSale3);&#13;
            }&#13;
        } else {&#13;
            revert();&#13;
        }&#13;
    }&#13;
&#13;
    function generateTokens(uint _oneTokenInWei) internal {&#13;
        uint multiplier = 10**decimals;&#13;
        uint256 tokens = checkedDivision(msg.value, _oneTokenInWei)*multiplier;&#13;
        uint256 checkedSupply = checkedAddition(totalSupply, tokens);&#13;
        if (tokenCreationCapOverall &lt;= checkedSupply) revert();&#13;
        balances[msg.sender] += tokens;&#13;
        totalSupply = checkedAddition(totalSupply, tokens);&#13;
        CreateCPP(msg.sender,tokens);&#13;
    }&#13;
&#13;
    function changePhaseToICOweek2() external isOwner returns (bool){&#13;
        currentPhase = Phase.ICOweek2;&#13;
        return true;&#13;
    }&#13;
&#13;
    function changePhaseToICOweek3() external isOwner returns (bool){&#13;
        currentPhase = Phase.ICOweek3;&#13;
        return true;&#13;
    }&#13;
&#13;
    function changePhaseToNormalLife() external isOwner returns (bool){&#13;
        currentPhase = Phase.NormalLife;&#13;
        return true;&#13;
    }&#13;
&#13;
    function changeTokenPrice(uint tpico1, uint tpico2, uint tpico3) external isOwner returns (bool){&#13;
        oneTokenInWeiSale1 = tpico1;&#13;
        oneTokenInWeiSale2 = tpico2;&#13;
        oneTokenInWeiSale3 = tpico3;&#13;
        return true;&#13;
    }&#13;
&#13;
    function finalize() external isOwner returns (bool){&#13;
      owner.transfer(this.balance);&#13;
      return true;&#13;
    }&#13;
}