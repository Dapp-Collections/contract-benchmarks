/**
 *
 * @author  David Rosen <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="771c16161913181e03371a14181959180510">[emailÂ protected]</a>&gt;&#13;
 *&#13;
 * Version A&#13;
 *&#13;
 * Overview:&#13;
 * This is an implimentation of a `burnable` token. The tokens do not pay any dividends; however if/when tokens&#13;
 * are `burned`, the burner gets a share of whatever funds the contract owns at that time. No provision is made&#13;
 * for how tokens are sold; all tokens are initially credited to the contract owner. There is a provision to&#13;
 * establish a single `restricted` account. The restricted account can own tokens, but cannot transfer them or&#13;
 * burn them until after a certain date. . There is also a function to burn tokens without getting paid. This is&#13;
 * useful, for example, if the sale-contract/owner wants to reduce the supply of tokens.&#13;
 *&#13;
 */&#13;
&#13;
/*&#13;
    Overflow protected math functions&#13;
*/&#13;
contract SafeMath {&#13;
    /**&#13;
        constructor&#13;
    */&#13;
    function SafeMath() {&#13;
    }&#13;
&#13;
    /**&#13;
        @dev returns the sum of _x and _y, asserts if the calculation overflows&#13;
&#13;
        @param _x   value 1&#13;
        @param _y   value 2&#13;
&#13;
        @return sum&#13;
    */&#13;
    function safeAdd(uint256 _x, uint256 _y) internal returns (uint256) {&#13;
        uint256 z = _x + _y;&#13;
        assert(z &gt;= _x);&#13;
        return z;&#13;
    }&#13;
&#13;
    /**&#13;
        @dev returns the difference of _x minus _y, asserts if the subtraction results in a negative number&#13;
&#13;
        @param _x   minuend&#13;
        @param _y   subtrahend&#13;
&#13;
        @return difference&#13;
    */&#13;
    function safeSub(uint256 _x, uint256 _y) internal returns (uint256) {&#13;
        assert(_x &gt;= _y);&#13;
        return _x - _y;&#13;
    }&#13;
&#13;
    /**&#13;
        @dev returns the product of multiplying _x by _y, asserts if the calculation overflows&#13;
&#13;
        @param _x   factor 1&#13;
        @param _y   factor 2&#13;
&#13;
        @return product&#13;
    */&#13;
    function safeMul(uint256 _x, uint256 _y) internal returns (uint256) {&#13;
        uint256 z = _x * _y;&#13;
        assert(_x == 0 || z / _x == _y);&#13;
        return z;&#13;
    }&#13;
}&#13;
contract iERC20Token {&#13;
  function totalSupply() constant returns (uint supply);&#13;
  function balanceOf( address who ) constant returns (uint value);&#13;
  function allowance( address owner, address spender ) constant returns (uint remaining);&#13;
&#13;
  function transfer( address to, uint value) returns (bool ok);&#13;
  function transferFrom( address from, address to, uint value) returns (bool ok);&#13;
  function approve( address spender, uint value ) returns (bool ok);&#13;
&#13;
  event Transfer( address indexed from, address indexed to, uint value);&#13;
  event Approval( address indexed owner, address indexed spender, uint value);&#13;
}&#13;
contract iBurnableToken is iERC20Token {&#13;
  function burnTokens(uint _burnCount) public;&#13;
  function unPaidBurnTokens(uint _burnCount) public;&#13;
}&#13;
&#13;
&#13;
contract BurnableToken is iBurnableToken, SafeMath {&#13;
&#13;
  event PaymentEvent(address indexed from, uint amount);&#13;
  event TransferEvent(address indexed from, address indexed to, uint amount);&#13;
  event ApprovalEvent(address indexed from, address indexed to, uint amount);&#13;
  event BurnEvent(address indexed from, uint count, uint value);&#13;
&#13;
  string  public symbol;&#13;
  string  public name;&#13;
  bool    public isLocked;&#13;
  uint    public decimals;&#13;
  uint    public restrictUntil;                              //vesting for developer tokens&#13;
  uint           tokenSupply;                                //can never be increased; but tokens can be burned&#13;
  address public owner;&#13;
  address public restrictedAcct;                             //no transfers from this addr during vest time&#13;
  mapping (address =&gt; uint) balances;&#13;
  mapping (address =&gt; mapping (address =&gt; uint)) approvals;  //transfer approvals, from -&gt; to&#13;
&#13;
&#13;
  modifier ownerOnly {                                                                                                                                                                                             &#13;
    require(msg.sender == owner);                                                                                                                                                                                  &#13;
    _;                                                                                                                                                                                                             &#13;
  }                                                                                                                                                                                                                &#13;
                                                                                                                                                                                                                   &#13;
  modifier unlockedOnly {                                                                                                                                                                                          &#13;
    require(!isLocked);                                                                                                                                                                                            &#13;
    _;                                                                                                                                                                                                             &#13;
  }                                                                                                                                                                                                                &#13;
                                                                                                                                                                                                                   &#13;
  modifier preventRestricted {                                                                                                                                                                                     &#13;
    require((msg.sender != restrictedAcct) || (now &gt;= restrictUntil));                                                                                                                                             &#13;
    _;                                                                                                                                                                                                             &#13;
  }                                                                                                                                                                                                                &#13;
                                                                                                                                                                                                                   &#13;
                                                                                                                                                                                                                   &#13;
  //                                                                                                                                                                                                               &#13;
  //constructor                                                                                                                                                                                                    &#13;
  //                                                                                                                                                                                                               &#13;
  function BurnableToken() {&#13;
    owner = msg.sender;&#13;
  }&#13;
&#13;
&#13;
  //&#13;
  // ERC-20&#13;
  //&#13;
&#13;
  function totalSupply() public constant returns (uint supply) { supply = tokenSupply; }&#13;
&#13;
  function transfer(address _to, uint _value) public preventRestricted returns (bool success) {&#13;
    //if token supply was not limited then we would prevent wrap:&#13;
    //if (balances[msg.sender] &gt;= _value &amp;&amp; balances[_to] + _value &gt; balances[_to])&#13;
    if (balances[msg.sender] &gt;= _value &amp;&amp; _value &gt; 0) {&#13;
      balances[msg.sender] -= _value;&#13;
      balances[_to] += _value;&#13;
      TransferEvent(msg.sender, _to, _value);&#13;
      return true;&#13;
    } else {&#13;
      return false;&#13;
    }&#13;
  }&#13;
&#13;
&#13;
  function transferFrom(address _from, address _to, uint _value) public returns (bool success) {&#13;
    //if token supply was not limited then we would prevent wrap:&#13;
    //if (balances[_from] &gt;= _value &amp;&amp; approvals[_from][msg.sender] &gt;= _value &amp;&amp; balances[_to] + _value &gt; balances[_to])&#13;
    if (balances[_from] &gt;= _value &amp;&amp; approvals[_from][msg.sender] &gt;= _value &amp;&amp; _value &gt; 0) {&#13;
      balances[_from] -= _value;&#13;
      balances[_to] += _value;&#13;
      approvals[_from][msg.sender] -= _value;&#13;
      TransferEvent(_from, _to, _value);&#13;
      return true;&#13;
    } else {&#13;
      return false;&#13;
    }&#13;
  }&#13;
&#13;
&#13;
  function balanceOf(address _owner) public constant returns (uint balance) {&#13;
    balance = balances[_owner];&#13;
  }&#13;
&#13;
&#13;
  function approve(address _spender, uint _value) public preventRestricted returns (bool success) {&#13;
    approvals[msg.sender][_spender] = _value;&#13;
    ApprovalEvent(msg.sender, _spender, _value);&#13;
    return true;&#13;
  }&#13;
&#13;
&#13;
  function allowance(address _owner, address _spender) public constant returns (uint remaining) {&#13;
    return approvals[_owner][_spender];&#13;
  }&#13;
&#13;
&#13;
  //&#13;
  // END ERC20&#13;
  //&#13;
&#13;
&#13;
  //&#13;
  // default payable function.&#13;
  //&#13;
  function () payable {&#13;
    PaymentEvent(msg.sender, msg.value);&#13;
  }&#13;
&#13;
  function initTokenSupply(uint _tokenSupply) public ownerOnly {&#13;
    require(tokenSupply == 0);&#13;
    tokenSupply = _tokenSupply;&#13;
    balances[owner] = tokenSupply;&#13;
  }&#13;
&#13;
  function lock() public ownerOnly {&#13;
    isLocked = true;&#13;
  }&#13;
&#13;
  function setRestrictedAcct(address _restrictedAcct, uint _restrictUntil) public ownerOnly unlockedOnly {&#13;
    restrictedAcct = _restrictedAcct;&#13;
    restrictUntil = _restrictUntil;&#13;
  }&#13;
&#13;
  function tokenValue() constant public returns (uint value) {&#13;
    value = this.balance / tokenSupply;&#13;
  }&#13;
&#13;
  function valueOf(address _owner) constant public returns (uint value) {&#13;
    value = this.balance * balances[_owner] / tokenSupply;&#13;
  }&#13;
&#13;
  function burnTokens(uint _burnCount) public preventRestricted {&#13;
    if (balances[msg.sender] &gt;= _burnCount &amp;&amp; _burnCount &gt; 0) {&#13;
      uint _value = this.balance * _burnCount / tokenSupply;&#13;
      tokenSupply -= _burnCount;&#13;
      balances[msg.sender] -= _burnCount;&#13;
      msg.sender.transfer(_value);&#13;
      BurnEvent(msg.sender, _burnCount, _value);&#13;
    }&#13;
  }&#13;
&#13;
  function unPaidBurnTokens(uint _burnCount) public preventRestricted {&#13;
    if (balances[msg.sender] &gt;= _burnCount &amp;&amp; _burnCount &gt; 0) {&#13;
      tokenSupply -= _burnCount;&#13;
      balances[msg.sender] -= _burnCount;&#13;
      BurnEvent(msg.sender, _burnCount, 0);&#13;
    }&#13;
  }&#13;
&#13;
  //for debug&#13;
  //only available before the contract is locked&#13;
  function haraKiri() ownerOnly unlockedOnly {&#13;
    selfdestruct(owner);&#13;
  }&#13;
&#13;
}