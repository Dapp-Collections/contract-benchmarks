pragma solidity ^0.4.21;

/**
 * @title Serpentio Contract <http://serpentio.com> - April 2018
 * @Author Alber Erre <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="056477676970626a456268646c692b666a68">[emailÂ protected]</a>&gt; &lt;http://albererre.com&gt;&#13;
 * Technical details here: https://medium.com/@alber_erre/serpentio-a-snake-on-the-ethereum-blockchain-non-linear-distribution-scheme-b116bfa187d8&#13;
 */&#13;
&#13;
/**&#13;
 * The Serpent contract distributes its acummulated balance between investors using a non-linear scheme, inside a period of time.&#13;
 * As such, every new investor help to fund previous investors, under the promise that future new investors will fund itself.&#13;
 * Result: Early investors receive more funds than last investors.&#13;
 */&#13;
&#13;
/**&#13;
 * Based on Open Zeppelin - https://github.com/OpenZeppelin/zeppelin-solidity&#13;
 * &#13;
 * @title SafeMath&#13;
 * @dev Math operations with safety checks that throw on error&#13;
 */&#13;
&#13;
library SafeMath {&#13;
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
    if (a == 0) {&#13;
      return 0;&#13;
    }&#13;
    uint256 c = a * b;&#13;
    assert(c / a == b);&#13;
    return c;&#13;
  }&#13;
&#13;
  function div(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
    // assert(b &gt; 0); // Solidity automatically throws when dividing by 0&#13;
    uint256 c = a / b;&#13;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold&#13;
    return c;&#13;
  }&#13;
&#13;
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
    assert(b &lt;= a);&#13;
    return a - b;&#13;
  }&#13;
&#13;
  function add(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
    uint256 c = a + b;&#13;
    assert(c &gt;= a);&#13;
    return c;&#13;
  }&#13;
}&#13;
&#13;
/**&#13;
 * @title Ownable&#13;
 * @dev The Ownable contract has an owner address, and provides basic authorization control&#13;
 * functions, this simplifies the implementation of "user permissions".&#13;
 */&#13;
contract Ownable {&#13;
  address public owner;&#13;
&#13;
  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);&#13;
&#13;
  /**&#13;
   * @dev The Ownable constructor sets the original `owner` of the contract to the sender&#13;
   * account.&#13;
   */&#13;
  function Ownable() public {&#13;
    owner = msg.sender;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Throws if called by any account other than the owner.&#13;
   */&#13;
  modifier onlyOwner() {&#13;
    require(msg.sender == owner);&#13;
    _;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Allows the current owner to transfer control of the contract to a newOwner.&#13;
   * @param newOwner The address to transfer ownership to.&#13;
   */&#13;
  function transferOwnership(address newOwner) public onlyOwner {&#13;
    require(newOwner != address(0));&#13;
    emit OwnershipTransferred(owner, newOwner);&#13;
    owner = newOwner;&#13;
  }&#13;
}&#13;
&#13;
contract Serpent is Ownable {&#13;
	using SafeMath for uint256;&#13;
&#13;
	// everyone should check this measure to find out how much they have earned.&#13;
	mapping (address =&gt; uint256) public investorReturn;&#13;
&#13;
	uint256 public SerpenSegmentCount;&#13;
	uint256 public SerpentCountDown;&#13;
	address public SerpentHead;&#13;
	address[] investormapping;&#13;
&#13;
	struct investorDetails {&#13;
	    address investorAddress;&#13;
	    uint256 amountInvested;&#13;
	    uint256 SegmentNumber;&#13;
	    uint256 time;&#13;
	    string  quote;&#13;
	}&#13;
&#13;
	investorDetails[] public investorsList;&#13;
&#13;
	function Serpent () {&#13;
		// Constructor: init public variables and add creator as SerpentHead&#13;
		SerpentHead = owner;&#13;
		SerpenSegmentCount = 0;&#13;
		SerpentCountDown = uint256(block.timestamp);&#13;
	}&#13;
&#13;
	function Play (string _quote) payable public {&#13;
&#13;
		require (msg.value &gt; 0);&#13;
        require (msg.sender != address(0)); // just in case&#13;
        require (uint256(block.timestamp) &lt; SerpentCountDown); // nobody can play once countdown is finished&#13;
&#13;
        address thisAddress = msg.sender;&#13;
		uint256 thisAmmount = msg.value;&#13;
&#13;
        AddReturnsMapping(thisAmmount);&#13;
	    // AddReturnsMapping MUST be before AddNewSegment, to avoid counting the new segment while calculating returns&#13;
&#13;
	    SerpenSegmentCount = SerpenSegmentCount.add(1);&#13;
		AddNewSegment(thisAddress, thisAmmount, SerpenSegmentCount, uint256(block.timestamp), _quote);&#13;
	    // Adding new segment - the same address can send more than once.&#13;
        // Although, distribution is based on chronological amounts, not addresses.&#13;
	}&#13;
&#13;
	// Callback function&#13;
	function () payable public {&#13;
		require(msg.value &gt; 0);&#13;
&#13;
		Play("Callback, No quote");&#13;
	}&#13;
&#13;
	function NewSerpent (uint256 _SerpentCountDown) public onlyOwner {&#13;
&#13;
		// this is to avoid deleting current serpent game until the previous game has finished&#13;
		require (uint256(block.timestamp) &gt; SerpentCountDown);&#13;
		&#13;
		SerpenSegmentCount = 0;&#13;
		SerpentCountDown = _SerpentCountDown;&#13;
&#13;
		//Collect prime-number reminders from previous game calculations&#13;
		uint256 nonPrimeReminders = 0;&#13;
		for (uint256 p = 0; p &lt; investormapping.length; p++) {&#13;
			nonPrimeReminders.add(investorReturn[investormapping[p]]);&#13;
		}&#13;
		uint256 PrimeReminder = uint256(address(this).balance) - nonPrimeReminders;&#13;
		SerpentHead.transfer(PrimeReminder);&#13;
&#13;
		//Delete current investormapping array elements, to init new-serpent investormapping&#13;
		while (investormapping.length != 0) {&#13;
			delete investormapping[investormapping.length-1]; //delete last element&#13;
			investormapping.length--;&#13;
		}&#13;
&#13;
		// Start first serpent segment&#13;
	    SerpenSegmentCount = SerpenSegmentCount.add(1);&#13;
	    investormapping.push(SerpentHead);&#13;
	    AddNewSegment(SerpentHead, 1 ether, SerpenSegmentCount, uint256(block.timestamp), "Everything started with Salazar Slytherin");&#13;
	}&#13;
	&#13;
	&#13;
	function AddNewSegment (address _address, uint256 _amount, uint256 _segmentNumber, uint256 _time, string _quote) internal {&#13;
	    require (_amount &gt; 0); // just in case&#13;
&#13;
		// in case this is a new address, add it to mappings, if not, just do nothing&#13;
		uint256 inList = 0;&#13;
		for (uint256 n = 0; n &lt; investormapping.length; n++) {&#13;
			if (investormapping[n] == _address) {&#13;
				inList = 1;&#13;
			}&#13;
		}&#13;
		if (inList == 0) {&#13;
			investorReturn[_address] = 0;&#13;
			investormapping.push(_address); //add only once per address&#13;
		}&#13;
&#13;
		// add to struct list, but after inList check&#13;
		investorsList.push(investorDetails(_address, _amount, _segmentNumber, _time, _quote));&#13;
	}&#13;
&#13;
	function AddReturnsMapping (uint256 _amount) internal {&#13;
&#13;
		uint256 individualAmount = _amount.div(investormapping.length);&#13;
&#13;
		for (uint256 a = 0; a &lt; investormapping.length; a++) {&#13;
			investorReturn[investormapping[a]] = investorReturn[investormapping[a]].add(individualAmount); &#13;
		}&#13;
	}&#13;
	&#13;
	function CollectReturns () external {&#13;
&#13;
		uint256 currentTime = uint256(block.timestamp);&#13;
		uint256 amountToCollect = getReturns(msg.sender);&#13;
		require (currentTime &gt; SerpentCountDown); // collect if serpent has finished&#13;
		require(address(this).balance &gt;= amountToCollect);&#13;
&#13;
		address(msg.sender).transfer(amountToCollect);&#13;
		investorReturn[msg.sender] = 0;&#13;
	}&#13;
&#13;
	function getBalance () public view returns(uint256) {&#13;
		return uint256(address(this).balance);&#13;
	}&#13;
&#13;
	function getParticipants () public view returns(uint256) {&#13;
		return uint256(investormapping.length);&#13;
	}&#13;
&#13;
	function getCountdownDate () public view returns(uint256) {&#13;
		return uint256(SerpentCountDown);&#13;
	}&#13;
&#13;
	function getReturns (address _address) public view returns(uint256) {&#13;
		return uint256(investorReturn[_address]);&#13;
	}&#13;
	&#13;
	function SerpentIsRunning () public view returns(bool) {&#13;
		return bool(uint256(block.timestamp) &lt; SerpentCountDown);&#13;
	}&#13;
&#13;
  // End of contract&#13;
}