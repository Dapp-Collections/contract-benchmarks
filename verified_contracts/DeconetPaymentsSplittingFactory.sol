pragma solidity 0.4.25;
// produced by the Solididy File Flattener (c) David Appleton 2018
// contact : <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="ec888d9a89ac8d8783818e8dc28f8381">[emailÂ protected]</a>&#13;
// released under Apache 2.0 licence&#13;
contract CloneFactory {&#13;
&#13;
  event CloneCreated(address indexed target, address clone);&#13;
&#13;
  function createClone(address target) internal returns (address result) {&#13;
    bytes memory clone = hex"3d602d80600a3d3981f3363d3d373d3d3d363d73bebebebebebebebebebebebebebebebebebebebe5af43d82803e903d91602b57fd5bf3";&#13;
    bytes20 targetBytes = bytes20(target);&#13;
    for (uint i = 0; i &lt; 20; i++) {&#13;
      clone[20 + i] = targetBytes[i];&#13;
    }&#13;
    assembly {&#13;
      let len := mload(clone)&#13;
      let data := add(clone, 0x20)&#13;
      result := create(0, data, len)&#13;
    }&#13;
  }&#13;
}&#13;
&#13;
library SafeMath {&#13;
&#13;
  /**&#13;
  * @dev Multiplies two numbers, throws on overflow.&#13;
  */&#13;
  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {&#13;
    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the&#13;
    // benefit is lost if 'b' is also tested.&#13;
    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522&#13;
    if (_a == 0) {&#13;
      return 0;&#13;
    }&#13;
&#13;
    c = _a * _b;&#13;
    assert(c / _a == _b);&#13;
    return c;&#13;
  }&#13;
&#13;
  /**&#13;
  * @dev Integer division of two numbers, truncating the quotient.&#13;
  */&#13;
  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {&#13;
    // assert(_b &gt; 0); // Solidity automatically throws when dividing by 0&#13;
    // uint256 c = _a / _b;&#13;
    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold&#13;
    return _a / _b;&#13;
  }&#13;
&#13;
  /**&#13;
  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).&#13;
  */&#13;
  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {&#13;
    assert(_b &lt;= _a);&#13;
    return _a - _b;&#13;
  }&#13;
&#13;
  /**&#13;
  * @dev Adds two numbers, throws on overflow.&#13;
  */&#13;
  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {&#13;
    c = _a + _b;&#13;
    assert(c &gt;= _a);&#13;
    return c;&#13;
  }&#13;
}&#13;
&#13;
contract DeconetPaymentsSplitting {&#13;
    using SafeMath for uint;&#13;
&#13;
    // Logged on this distribution set up completion.&#13;
    event DistributionCreated (&#13;
        address[] destinations,&#13;
        uint[] sharesMantissa,&#13;
        uint sharesExponent&#13;
    );&#13;
&#13;
    // Logged when funds landed to or been sent out from this contract balance.&#13;
    event FundsOperation (&#13;
        address indexed senderOrAddressee,&#13;
        uint amount,&#13;
        FundsOperationType indexed operationType&#13;
    );&#13;
&#13;
    // Enumeration of possible funds operations.&#13;
    enum FundsOperationType { Incoming, Outgoing }&#13;
&#13;
    // Describes Distribution destination and its share of all incoming funds.&#13;
    struct Distribution {&#13;
        // Destination address of the distribution.&#13;
        address destination;&#13;
&#13;
        // Floating-point number mantissa of a share allotted for a destination address.&#13;
        uint mantissa;&#13;
    }&#13;
&#13;
    // Stores exponent of a power term of a floating-point number.&#13;
    uint public sharesExponent;&#13;
&#13;
    // Stores list of distributions.&#13;
    Distribution[] public distributions;&#13;
&#13;
    /**&#13;
     * @dev Payable fallback that tries to send over incoming funds to the distribution destinations splitted&#13;
     * by pre-configured shares. In case when there is not enough gas sent for the transaction to complete&#13;
     * distribution, all funds will be kept in contract untill somebody calls `withdrawFullContractBalance` to&#13;
     * run postponed distribution and withdraw contract's balance funds.&#13;
     */&#13;
    function () public payable {&#13;
        emit FundsOperation(msg.sender, msg.value, FundsOperationType.Incoming);&#13;
        distributeFunds();&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Set up distribution for the current clone, can be called only once.&#13;
     * @param _destinations Destination addresses of the current payments splitting contract clone.&#13;
     * @param _sharesMantissa Mantissa values for destinations shares ordered respectively with `_destinations`.&#13;
     * @param _sharesExponent Exponent of a power term that forms shares floating-point numbers, expected to&#13;
     * be the same for all values in `_sharesMantissa`.&#13;
     */&#13;
    function setUpDistribution(&#13;
        address[] _destinations,&#13;
        uint[] _sharesMantissa,&#13;
        uint _sharesExponent&#13;
    )&#13;
        external&#13;
    {&#13;
        require(distributions.length == 0, "Contract can only be initialized once"); // Make sure the clone isn't initialized yet.&#13;
        require(_destinations.length &lt;= 8 &amp;&amp; _destinations.length &gt; 0, "There is a maximum of 8 destinations allowed");  // max of 8 destinations&#13;
        // prevent integer overflow when math with _sharesExponent happens&#13;
        // also ensures that low balances can be distributed because balance must always be &gt;= 10**(sharesExponent + 2)&#13;
        require(_sharesExponent &lt;= 4, "The maximum allowed sharesExponent is 4");&#13;
        // ensure that lengths of arrays match so array out of bounds can't happen&#13;
        require(_destinations.length == _sharesMantissa.length, "Length of destinations does not match length of sharesMantissa");&#13;
&#13;
        uint sum = 0;&#13;
        for (uint i = 0; i &lt; _destinations.length; i++) {&#13;
            // Forbid contract as destination so that transfer can never fail&#13;
            require(!isContract(_destinations[i]), "A contract may not be a destination address");&#13;
            sum = sum.add(_sharesMantissa[i]);&#13;
            distributions.push(Distribution(_destinations[i], _sharesMantissa[i]));&#13;
        }&#13;
         // taking into account 100% by adding 2 to the exponent.&#13;
        require(sum == 10**(_sharesExponent.add(2)), "The sum of all sharesMantissa should equal 10 ** ( _sharesExponent + 2 ) but it does not.");&#13;
        sharesExponent = _sharesExponent;&#13;
        emit DistributionCreated(_destinations, _sharesMantissa, _sharesExponent);&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Process the available balance through the distribution and send money over to destination addresses.&#13;
     */&#13;
    function distributeFunds() public {&#13;
        uint balance = address(this).balance;&#13;
        require(balance &gt;= 10**(sharesExponent.add(2)), "You can not split up less wei than sum of all shares");&#13;
        for (uint i = 0; i &lt; distributions.length; i++) {&#13;
            Distribution memory distribution = distributions[i];&#13;
            uint amount = calculatePayout(balance, distribution.mantissa, sharesExponent);&#13;
            distribution.destination.transfer(amount);&#13;
            emit FundsOperation(distribution.destination, amount, FundsOperationType.Outgoing);&#13;
        }&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Returns length of distributions array&#13;
     * @return Length of distributions array&#13;
    */&#13;
    function distributionsLength() public view returns (uint256) {&#13;
        return distributions.length;&#13;
    }&#13;
&#13;
&#13;
    /**&#13;
     * @dev Calculates a share of the full amount.&#13;
     * @param _fullAmount Full amount.&#13;
     * @param _shareMantissa Mantissa of the percentage floating-point number.&#13;
     * @param _shareExponent Exponent of the percentage floating-point number.&#13;
     * @return An uint of the payout.&#13;
     */&#13;
    function calculatePayout(uint _fullAmount, uint _shareMantissa, uint _shareExponent) private pure returns(uint) {&#13;
        return (_fullAmount.div(10 ** (_shareExponent.add(2)))).mul(_shareMantissa);&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Checks whether or not a given address contains a contract&#13;
     * @param _addr The address to check&#13;
     * @return A boolean indicating whether or not the address is a contract&#13;
     */&#13;
    function isContract(address _addr) private view returns (bool) {&#13;
        uint32 size;&#13;
        assembly {&#13;
            size := extcodesize(_addr)&#13;
        }&#13;
        return (size &gt; 0);&#13;
    }&#13;
}&#13;
&#13;
contract DeconetPaymentsSplittingFactory is CloneFactory {&#13;
&#13;
    // PaymentsSplitting master-contract address.&#13;
    address public libraryAddress;&#13;
&#13;
    // Logged when a new PaymentsSplitting clone is deployed to the chain.&#13;
    event PaymentsSplittingCreated(address newCloneAddress);&#13;
&#13;
    /**&#13;
     * @dev Constructor for the contract.&#13;
     * @param _libraryAddress PaymentsSplitting master-contract address.&#13;
     */&#13;
    constructor(address _libraryAddress) public {&#13;
        libraryAddress = _libraryAddress;&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Create PaymentsSplitting clone.&#13;
     * @param _destinations Destination addresses of the new PaymentsSplitting contract clone.&#13;
     * @param _sharesMantissa Mantissa values for destinations shares ordered respectively with `_destinations`.&#13;
     * @param _sharesExponent Exponent of a power term that forms shares floating-point numbers, expected to&#13;
     * be the same for all values in `_sharesMantissa`.&#13;
     */&#13;
    function createPaymentsSplitting(&#13;
        address[] _destinations,&#13;
        uint[] _sharesMantissa,&#13;
        uint _sharesExponent&#13;
    )&#13;
        external&#13;
        returns(address)&#13;
    {&#13;
        address clone = createClone(libraryAddress);&#13;
        DeconetPaymentsSplitting(clone).setUpDistribution(_destinations, _sharesMantissa, _sharesExponent);&#13;
        emit PaymentsSplittingCreated(clone);&#13;
        return clone;&#13;
    }&#13;
}