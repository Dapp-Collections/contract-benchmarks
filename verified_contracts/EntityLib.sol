/* EntityLib.sol
 *
 * Copyright (C) 2018 Ethertify B.V. <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="7b12151d143b1e0f131e090f121d0255181416">[emailÂ protected]</a>&gt;&#13;
 *&#13;
 * This program is free software: you can redistribute it and/or modify&#13;
 * it under the terms of the GNU Lesser General Public License as published by&#13;
 * the Free Software Foundation, either version 3 of the License, or&#13;
 * (at your option) any later version.&#13;
 *&#13;
 * This program is distributed in the hope that it will be useful,&#13;
 * but WITHOUT ANY WARRANTY; without even the implied warranty of&#13;
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&#13;
 * GNU Lesser General Public License for more details.&#13;
 *&#13;
 * You should have received a copy of the GNU Lesser General Public License&#13;
 * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.&#13;
 */&#13;
&#13;
pragma solidity 0.4.19;&#13;
&#13;
library EntityLib {&#13;
  struct SignerData {&#13;
    string signerDataHash;&#13;
    /*&#13;
     * status == 0 =&gt; NOT_VALID&#13;
     * status == 1 =&gt; VALIDATION_PENDING&#13;
     * status == 2 =&gt; VALID&#13;
     * status == 3 =&gt; DATA_UPDATED&#13;
     */&#13;
    uint status;&#13;
  }&#13;
&#13;
  struct EntityData {&#13;
    address owner;&#13;
    string dataHash; // hash entity data&#13;
    /*&#13;
      * status == 0 =&gt; NOT_VALID&#13;
      * status == 1 =&gt; VALIDATION_PENDING&#13;
      * status == 2 =&gt; VALID&#13;
      * status == 4 =&gt; RENEWAL_REQUESTED&#13;
      * status == 8 =&gt; CLOSED&#13;
      * otherwise =&gt; UNKNOWN&#13;
      */&#13;
    uint status;&#13;
    bytes32 urlHash;         // hash url only&#13;
    uint expiration;         // Expiration date&#13;
    uint renewalPeriod;      // Renewal period to be used for 3rd party renewals (3rd party paying the validation expenses)&#13;
    bytes32 oraclizeQueryId; // Last query Id from oraclize. We will only process the last request&#13;
&#13;
    /*&#13;
      * signers[a] == 0;&#13;
      * signers[a] = ipfs multihash address for signer data file in json format&#13;
      */&#13;
    mapping(address =&gt; SignerData) signers;&#13;
    address[] signersArr;&#13;
  }&#13;
&#13;
  struct Data {&#13;
    mapping(uint =&gt; EntityData) entities;&#13;
    mapping(bytes32 =&gt; uint) entityIds;&#13;
    uint nEntities;&#13;
  }&#13;
&#13;
  // METHODS&#13;
&#13;
  /**&#13;
   * Creates a new entity&#13;
   * @param self {object} - The data containing the entity mappings&#13;
   * @param entitDatayHash {string} - The ipfs multihash address of the entity information in json format&#13;
   * @param urlHash {bytes32} - The sha256 hash of the URL of the entity&#13;
   * @param expirationDate {uint} - The expiration date of the current entity&#13;
   * @param renewalPeriod {uint} - The time period which will be added to the current date or expiration date when a renewal is requested&#13;
   * @return {uint} The id of the created entity&#13;
   */&#13;
  function create(Data storage self, uint entityId, string entitDatayHash, bytes32 urlHash, uint expirationDate, uint renewalPeriod) isExpirationDateValid(expirationDate) isRenewalPeriodValid(renewalPeriod) public {&#13;
    self.entities[entityId] = EntityData({&#13;
        owner: msg.sender,&#13;
        dataHash: entitDatayHash,&#13;
        urlHash: urlHash,&#13;
        status: 1,&#13;
        expiration: expirationDate,&#13;
        renewalPeriod: renewalPeriod,&#13;
        oraclizeQueryId: 0,&#13;
        signersArr: new address[](0)&#13;
    });&#13;
    EntityCreated(entityId);&#13;
  }&#13;
&#13;
  /**&#13;
   * Process validation after the oraclize callback&#13;
   * @param self {object} - The data containing the entity mappings&#13;
   * @param queryId {bytes32} - The id of the oraclize query (returned by the call to oraclize_query method)&#13;
   * @param result {string} - The result of the query&#13;
   */&#13;
  function processValidation(Data storage self, bytes32 queryId, string result) public {&#13;
    uint entityId = self.entityIds[queryId];&#13;
    self.entityIds[queryId] = 0;&#13;
    &#13;
    EntityData storage entity = self.entities[entityId];&#13;
&#13;
    require (queryId == entity.oraclizeQueryId);&#13;
&#13;
    string memory entityIdStr = uintToString(entityId);&#13;
    string memory toCompare = strConcat(entityIdStr, ":", entity.dataHash); &#13;
&#13;
    if (stringsEqual(result, toCompare)) {&#13;
      if (entity.status == 4) { // if entity is waiting for renewal&#13;
        uint initDate = max(entity.expiration, now);&#13;
        entity.expiration = initDate + entity.renewalPeriod;&#13;
      }&#13;
&#13;
      entity.status = 2; // set entity status to valid&#13;
      EntityValidated(entityId);&#13;
    } else {&#13;
      entity.status = 1;  // set entity status to validation pending&#13;
      EntityInvalid(entityId);&#13;
    }&#13;
  }&#13;
&#13;
  /**&#13;
   * Sets a new expiration date for the entity. It will trigger an entity validation through the oracle, so it must be paid.&#13;
   * @param self {object} - The data containing the entity mappings&#13;
   * @param entityId {uint} - The id of the entity&#13;
   * @param expirationDate {uint} - The new expiration date of the entity&#13;
   */&#13;
  function setExpiration (Data storage self, uint entityId, uint expirationDate) isNotClosed(self, entityId) onlyEntity(self, entityId) isExpirationDateValid(expirationDate) public {&#13;
    EntityData storage entity = self.entities[entityId];&#13;
    entity.status = 1;&#13;
    entity.expiration = expirationDate;&#13;
    EntityExpirationSet(entityId);&#13;
  }&#13;
  &#13;
  /**&#13;
   * Sets a new renewal interval&#13;
   * @param self {object} - The data containing the entity mappings&#13;
   * @param entityId {uint} - The id of the entity&#13;
   * @param renewalPeriod {uint} - The new renewal interval (in seconds)&#13;
   */&#13;
  function setRenewalPeriod (Data storage self, uint entityId, uint renewalPeriod) isNotClosed(self, entityId) onlyEntity(self, entityId) isRenewalPeriodValid(renewalPeriod) public {&#13;
    EntityData storage entity = self.entities[entityId];&#13;
    entity.renewalPeriod = renewalPeriod;&#13;
    EntityRenewalSet(entityId);&#13;
  }&#13;
&#13;
  /**&#13;
   * Close an entity. This status will not allow further operations on the entity.&#13;
   * @param self {object} - The data containing the entity mappings&#13;
   * @param entityId {uint} - The id of the entity&#13;
   */&#13;
  function closeEntity(Data storage self, uint entityId) isNotClosed(self, entityId) onlyEntity(self, entityId) public {&#13;
    self.entities[entityId].status = 8;&#13;
    EntityClosed(entityId);&#13;
  }&#13;
&#13;
  /**&#13;
   * Registers a new signer in an entity&#13;
   * @param self {object} - The data containing the entity mappings&#13;
   * @param entityId {uint} - The id of the entity&#13;
   * @param signerAddress {address} - The address of the signer to be registered&#13;
   * @param signerDataHash {uint} - The IPFS multihash address of signer information in json format&#13;
   */&#13;
  function registerSigner(Data storage self, uint entityId, address signerAddress, string signerDataHash) isValidEntity(self, entityId) onlyEntity(self, entityId) signerIsNotYetRegistered(self, entityId, signerAddress) public {&#13;
    self.entities[entityId].signersArr.push(signerAddress);&#13;
    self.entities[entityId].signers[signerAddress] = SignerData({&#13;
      signerDataHash: signerDataHash,&#13;
      status: 1&#13;
    });&#13;
    SignerAdded(entityId, signerAddress);&#13;
  }&#13;
&#13;
  /**&#13;
   * Confirms signer registration&#13;
   * @param self {object} - The data containing the entity mappings&#13;
   * @param entityId {uint} - The id of the entity&#13;
   * @param signerDataHash {string} - The ipfs data hash of the signer to confirm&#13;
   */&#13;
  function confirmSignerRegistration(Data storage self, uint entityId, string signerDataHash) isValidEntity(self, entityId) isWaitingConfirmation(self, entityId, signerDataHash) public {&#13;
    self.entities[entityId].signers[msg.sender].status = 2;&#13;
    SignerConfirmed(entityId, msg.sender);&#13;
  }&#13;
&#13;
  /**&#13;
   * Removes a signer from an entity&#13;
   * @param self {object} - The data containing the entity mappings&#13;
   * @param entityId {uint} - The id of the entity&#13;
   * @param signerAddress {address} - The address of the signer to be removed&#13;
   */&#13;
  function removeSigner(Data storage self, uint entityId, address signerAddress) isValidEntity(self, entityId) onlyEntity(self, entityId) public {&#13;
    internalRemoveSigner(self, entityId, signerAddress);&#13;
  }&#13;
&#13;
&#13;
  /**&#13;
   * Removes a signer from an entity (internal use, without modifiers)&#13;
   * @param self {object} - The data containing the entity mappings&#13;
   * @param entityId {uint} - The id of the entity&#13;
   * @param signerAddress {address} - The address of the signer to be removed&#13;
   */&#13;
  function internalRemoveSigner(Data storage self, uint entityId, address signerAddress) private {&#13;
    EntityData storage entity = self.entities[entityId];&#13;
    address[] storage signersArr = entity.signersArr;&#13;
    SignerData storage signer = entity.signers[signerAddress];&#13;
&#13;
    if (bytes(signer.signerDataHash).length != 0 || signer.status != 0) {&#13;
      signer.status = 0;&#13;
      signer.signerDataHash = '';&#13;
      delete entity.signers[signerAddress];&#13;
&#13;
      // Update array for iterator&#13;
      uint i = 0;&#13;
      for (i; signerAddress != signersArr[i]; i++) {}&#13;
      signersArr[i] = signersArr[signersArr.length - 1];&#13;
      signersArr[signersArr.length - 1] = 0;&#13;
      signersArr.length = signersArr.length - 1;&#13;
      &#13;
      SignerRemoved(entityId, signerAddress);&#13;
    }&#13;
  }&#13;
&#13;
  /**&#13;
   * Leave the specified entity (remove signer if found)&#13;
   * @param self {object} - The data containing the entity mappings&#13;
   * @param entityId {uint} - The id of the entity&#13;
   */&#13;
  function leaveEntity(Data storage self, uint entityId) signerBelongsToEntity(self, entityId) public {&#13;
    internalRemoveSigner(self, entityId, msg.sender);&#13;
  }&#13;
&#13;
  /**&#13;
    * Checks if an entity can be validated&#13;
    * @param entityId {uint} - The id of the entity to validate&#13;
    * @param url {string} - The URL of the entity&#13;
    * @return {bytes32} - The id of the oraclize query&#13;
    */&#13;
  function canValidateSigningEntity(Data storage self, uint entityId, string url) isNotClosed(self, entityId) isRegisteredURL(self, entityId, url) view public returns (bool) {&#13;
    return true;&#13;
  }&#13;
&#13;
  /**&#13;
   * Checks if an entity validity can be renewed&#13;
   * @param self {object} - The data containing the entity mappings&#13;
   * @param entityId {uint} - The id of the entity to validate&#13;
   * @param url {string} - The URL of the entity&#13;
   * @return {bool} - True if renewal is possible&#13;
   */&#13;
  function canRenew(Data storage self, uint entityId, string url) isValidatedEntity(self, entityId) isRenewalPeriod(self, entityId) isRegisteredURL(self, entityId, url) view public returns (bool) {&#13;
    return true;&#13;
  }&#13;
&#13;
  /**&#13;
   * Checks if an entity can issue certificate (from its signers)&#13;
   * @param self {object} - The data containing the entity mappings&#13;
   * @param entityId {uint} - The id of the entity to check&#13;
   * @return {bool} - True if issuance is possible&#13;
   */&#13;
  function canIssueCertificates(Data storage self, uint entityId) isNotClosed(self, entityId) notExpired(self, entityId) signerBelongsToEntity(self, entityId) view public returns (bool) {&#13;
    return true;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Updates entity data&#13;
   * @param self {object} - The data containing the entity mappings&#13;
   * @param entityId {uint} - The id of the entity&#13;
   * @param entityDataHash {string} - The ipfs multihash address of the entity information in json format&#13;
   * @param urlHash {bytes32} - The sha256 hash of the URL of the entity&#13;
   */&#13;
  function updateEntityData(Data storage self, uint entityId, string entityDataHash, bytes32 urlHash) isNotClosed(self, entityId) onlyEntity(self, entityId) public {&#13;
    EntityData storage entity = self.entities[entityId];&#13;
    entity.dataHash = entityDataHash;&#13;
    entity.urlHash = urlHash;&#13;
    entity.status = 1;&#13;
    EntityDataUpdated(entityId);&#13;
  }&#13;
&#13;
&#13;
  /**&#13;
   * Update the signer data in the requestes entities&#13;
   * @param self {object} - The data containing the entity mappings&#13;
   * @param entityIds {array} - The ids of the entities to update&#13;
   * @param signerDataHash {string} - The ipfs multihash of the new signer data&#13;
   */&#13;
  function updateSignerData(Data storage self, uint[] entityIds, string signerDataHash) signerBelongsToEntities(self, entityIds) public {&#13;
    uint[] memory updated = new uint[](entityIds.length);&#13;
    for (uint i = 0; i &lt; entityIds.length; i++) {&#13;
      uint entityId = entityIds[i];&#13;
      SignerData storage signer = self.entities[entityId].signers[msg.sender];&#13;
&#13;
      if (signer.status != 2) {&#13;
        continue;&#13;
      }&#13;
      signer.status = 3;&#13;
      signer.signerDataHash = signerDataHash;&#13;
      updated[i] = entityId;&#13;
    }&#13;
    SignerDataUpdated(updated, msg.sender);&#13;
  }&#13;
&#13;
  /**&#13;
   * Accepts a new signer data update in the entity&#13;
   * @param self {object} - The data containing the entity mappings&#13;
   * @param entityId {uint} - The id of the entity&#13;
   * @param signerAddress {address} - The address of the signer update to be accepted&#13;
   * @param signerDataHash {uint} - The IPFS multihash address of signer information in json format to be accepted&#13;
   */&#13;
  function acceptSignerUpdate(Data storage self, uint entityId, address signerAddress, string signerDataHash) onlyEntity(self, entityId) notExpired(self, entityId) signerUpdateCanBeAccepted(self, entityId, signerAddress, signerDataHash) public {&#13;
    EntityData storage entity = self.entities[entityId];&#13;
    entity.signers[signerAddress].status = 2;&#13;
    SignerUpdateAccepted(entityId, signerAddress);&#13;
  }&#13;
&#13;
  // HELPER METHODS&#13;
&#13;
  /**&#13;
   * Returns the max of two numbers&#13;
   * @param a {uint} - Input number a&#13;
   * @param b {uint} - Input number b&#13;
   * @return {uint} - The maximum of the two inputs&#13;
   */&#13;
  function max(uint a, uint b) pure public returns(uint) {&#13;
    if (a &gt; b) {&#13;
      return a;&#13;
    } else {&#13;
      return b;&#13;
    }&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Compares two strings&#13;
   * @param _a {string} - One of the strings&#13;
   * @param _b {string} - The other string&#13;
   * @return {bool} True if the two strings are equal, false otherwise&#13;
   */&#13;
  function stringsEqual(string memory _a, string memory _b) pure internal returns (bool) {&#13;
    bytes memory a = bytes(_a);&#13;
    bytes memory b = bytes(_b);&#13;
    if (a.length != b.length)&#13;
      return false;&#13;
    for (uint i = 0; i &lt; a.length; i ++) {&#13;
      if (a[i] != b[i])&#13;
        return false;&#13;
        }&#13;
    return true;&#13;
  }&#13;
&#13;
  function strConcat(string _a, string _b, string _c, string _d, string _e) pure internal returns (string){&#13;
    bytes memory _ba = bytes(_a);&#13;
    bytes memory _bb = bytes(_b);&#13;
    bytes memory _bc = bytes(_c);&#13;
    bytes memory _bd = bytes(_d);&#13;
    bytes memory _be = bytes(_e);&#13;
    string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);&#13;
    bytes memory babcde = bytes(abcde);&#13;
    uint k = 0;&#13;
    for (uint i = 0; i &lt; _ba.length; i++) {babcde[k++] = _ba[i];}&#13;
    for (i = 0; i &lt; _bb.length; i++) {babcde[k++] = _bb[i];}&#13;
    for (i = 0; i &lt; _bc.length; i++) {babcde[k++] = _bc[i];}&#13;
    for (i = 0; i &lt; _bd.length; i++) {babcde[k++] = _bd[i];}&#13;
    for (i = 0; i &lt; _be.length; i++) {babcde[k++] = _be[i];}&#13;
    return string(babcde);&#13;
  }&#13;
&#13;
  function strConcat(string _a, string _b, string _c, string _d) pure internal returns (string) {&#13;
      return strConcat(_a, _b, _c, _d, "");&#13;
  }&#13;
&#13;
  function strConcat(string _a, string _b, string _c) pure internal returns (string) {&#13;
      return strConcat(_a, _b, _c, "", "");&#13;
  }&#13;
&#13;
  function strConcat(string _a, string _b) pure internal returns (string) {&#13;
      return strConcat(_a, _b, "", "", "");&#13;
  }&#13;
&#13;
  // uint to string&#13;
  function uintToString(uint v) pure public returns (string) {&#13;
    uint maxlength = 100;&#13;
    bytes memory reversed = new bytes(maxlength);&#13;
    uint i = 0;&#13;
    while (v != 0) {&#13;
      uint remainder = v % 10;&#13;
      v = v / 10;&#13;
      reversed[i++] = byte(48 + remainder);&#13;
    }&#13;
    bytes memory s = new bytes(i); // i + 1 is inefficient&#13;
    for (uint j = 0; j &lt; i; j++) {&#13;
        s[j] = reversed[i - j - 1]; // to avoid the off-by-one error&#13;
    }&#13;
    string memory str = string(s); // memory isn't implicitly convertible to storage&#13;
    return str;&#13;
  }&#13;
&#13;
  /**&#13;
   * Set the oraclize query id of the last request&#13;
   * @param self {object} - The data containing the entity mappings&#13;
   * @param id {uint} - The id of the entity&#13;
   * @param queryId {bytes32} - The query id from the oraclize request&#13;
   */&#13;
  function setOraclizeQueryId(Data storage self, uint id, bytes32 queryId) public {&#13;
    self.entities[id].oraclizeQueryId = queryId;&#13;
  }&#13;
&#13;
  // Helper functions&#13;
&#13;
  /**&#13;
   * Returns True if specified entity is validated or waiting to be renewed. False otherwise.&#13;
   * @param self {object} - The data containing the entity mappings&#13;
   * @param id {uint} - The id of the entity to check &#13;
   * @return {bool} - True if the entity is validated&#13;
   */&#13;
  function isValidated(Data storage self, uint id) view public returns (bool) {&#13;
    return (id &gt; 0 &amp;&amp; (self.entities[id].status == 2 || self.entities[id].status == 4));&#13;
  }&#13;
&#13;
 /**&#13;
  * Returns True if specified entity is not expired. False otherwise.&#13;
  * @param self {object} - The data containing the entity mappings&#13;
  * @param id {uint} - The id of the entity to check &#13;
  * @return {bool} - True if the entity is not expired&#13;
  */&#13;
  function isExpired(Data storage self, uint id) view public returns (bool) {&#13;
    return (id &gt; 0 &amp;&amp; (self.entities[id].expiration &lt; now));&#13;
  }&#13;
&#13;
  /**&#13;
  * Returns True if specified entity is closed.&#13;
  * @param self {object} - The data containing the entity mappings&#13;
  * @param id {uint} - The id of the entity to check &#13;
  * @return {bool} - True if the entity is closed&#13;
  */&#13;
  function isClosed(Data storage self, uint id) view public returns (bool) {&#13;
    return self.entities[id].status == 8;&#13;
  }&#13;
&#13;
 /**&#13;
   * Returns True if specified entity is validated and not expired&#13;
   * @param self {object} - The data containing the entity mappings&#13;
   * @param id {uint} - The id of the entity to check &#13;
   * @return {bool} - True if the entity is validated&#13;
   */&#13;
  function isValid(Data storage self, uint id) view public returns (bool) {&#13;
    return isValidated(self, id) &amp;&amp; !isExpired(self, id) &amp;&amp; !isClosed(self, id);&#13;
  }&#13;
&#13;
 /**&#13;
   * Returns True if specified entity exists&#13;
   * @param self {object} - The data containing the entity mappings&#13;
   * @param id {uint} - The id of the entity to check &#13;
   * @return {bool} - True if the entity exists&#13;
   */&#13;
  function exists(Data storage self, uint id) view public returns(bool) {&#13;
    EntityData storage entity = self.entities[id];&#13;
    return entity.status &gt; 0;&#13;
  }&#13;
&#13;
  // MODIFIERS&#13;
  &#13;
  /**&#13;
   * Valid if the renewal period is less than 31 days&#13;
   * @param renewalPeriod {uint} - The renewal period to check (in seconds)&#13;
   */&#13;
  modifier isRenewalPeriodValid(uint renewalPeriod) {&#13;
    require(renewalPeriod &gt;= 0 &amp;&amp; renewalPeriod &lt;= 32 * 24 * 60 * 60); // Renewal period less than 32 days&#13;
    _;&#13;
  }&#13;
&#13;
  /**&#13;
   * Valid if the expiration date is in less than 31 days&#13;
   * @param expiration {uint} - The expiration date (in seconds)&#13;
   */&#13;
  modifier isExpirationDateValid(uint expiration) {&#13;
    require(expiration - now &gt; 0 &amp;&amp; expiration - now &lt;= 32 * 24 * 60 * 60); // Expiration date is in less than 32 days in the future&#13;
    _;&#13;
  }&#13;
  &#13;
  /**&#13;
   * Returns True if specified entity is validated or waiting to be renewed. False otherwise.&#13;
   * @param self {object} - The data containing the entity mappings&#13;
   * @param id {uint} - The id of the entity to check &#13;
   */&#13;
  modifier isValidatedEntity(Data storage self, uint id) {&#13;
    require (isValidated(self, id));&#13;
    _;&#13;
  }&#13;
&#13;
  /**&#13;
   * Returns True if specified entity is validated or waiting to be renewed, not expired and not closed. False otherwise.&#13;
   * @param self {object} - The data containing the entity mappings&#13;
   * @param id {uint} - The id of the entity to check &#13;
   */&#13;
  modifier isValidEntity(Data storage self, uint id) {&#13;
    require (isValid(self, id));&#13;
    _;&#13;
  }&#13;
&#13;
  /**&#13;
  * Returns True if specified entity is validated. False otherwise.&#13;
  * @param self {object} - The data containing the entity mappings&#13;
  * @param id {uint} - The id of the entity to check &#13;
  */&#13;
  modifier notExpired(Data storage self, uint id) {&#13;
    require (!isExpired(self, id));&#13;
    _;  &#13;
  }&#13;
&#13;
  /**&#13;
    * Returns True if tansaction sent by owner of entity. False otherwise.&#13;
    * @param self {object} - The data containing the entity mappings&#13;
    * @param id {uint} - The id of the entity to check&#13;
    */&#13;
  modifier onlyEntity(Data storage self, uint id) {&#13;
    require (msg.sender == self.entities[id].owner);&#13;
    _;&#13;
  }&#13;
&#13;
  /**&#13;
    * Returns True if an URL is the one associated to the entity. False otherwise.&#13;
    * @param self {object} - The data containing the entity mappings&#13;
    * @param entityId {uint} - The id of the entity&#13;
    * @param url {string} - The  URL&#13;
    */&#13;
  modifier isRegisteredURL(Data storage self, uint entityId, string url) {&#13;
    require (self.entities[entityId].urlHash == sha256(url));&#13;
    _;&#13;
  }&#13;
&#13;
  /**&#13;
   * Returns True if current time is in renewal period for a valid entity. False otherwise.&#13;
   * @param self {object} - The data containing the entity mappings&#13;
   * @param entityId {uint} - The id of the entity to check &#13;
   */&#13;
  modifier isRenewalPeriod(Data storage self, uint entityId) {&#13;
    EntityData storage entity = self.entities[entityId];&#13;
    require (entity.renewalPeriod &gt; 0 &amp;&amp; entityId &gt; 0 &amp;&amp; (entity.expiration - entity.renewalPeriod &lt; now) &amp;&amp; entity.status == 2);&#13;
    _;&#13;
  }&#13;
&#13;
  /**&#13;
   * True if sender is registered in entity. False otherwise.&#13;
   * @param self {object} - The data containing the entity mappings&#13;
   * @param entityId {uint} - The id of the entity &#13;
   */&#13;
  modifier signerBelongsToEntity(Data storage self, uint entityId) {&#13;
    EntityData storage entity = self.entities[entityId];&#13;
    require (entityId &gt; 0 &amp;&amp; (bytes(entity.signers[msg.sender].signerDataHash).length != 0) &amp;&amp; (entity.signers[msg.sender].status == 2));&#13;
    _;&#13;
  }&#13;
&#13;
  /**&#13;
   * True if sender is registered in all the entities. False otherwise.&#13;
   * @param self {object} - The data containing the entity mappings&#13;
   * @param entityIds {array} - The ids of the entities&#13;
   */&#13;
  modifier signerBelongsToEntities(Data storage self, uint[] entityIds) {&#13;
    for (uint i = 0; i &lt; entityIds.length; i++) {&#13;
      uint entityId = entityIds[i];&#13;
      EntityData storage entity = self.entities[entityId];&#13;
      require (entityId &gt; 0 &amp;&amp; (entity.signers[msg.sender].status != 0));&#13;
    }&#13;
    _;&#13;
  }&#13;
&#13;
  /**&#13;
   * True if the signer was not yet added to an entity.&#13;
   * @param self {object} - The data containing the entity mappings&#13;
   * @param entityId {uint} - The id of the entity &#13;
   * @param signerAddress {address} - The signer to check&#13;
   */&#13;
  modifier signerIsNotYetRegistered(Data storage self, uint entityId, address signerAddress) {&#13;
    EntityData storage entity = self.entities[entityId];&#13;
    require (entity.signers[signerAddress].status == 0);&#13;
    _;&#13;
  }&#13;
&#13;
  /**&#13;
   * True if the entity is validated AND the signer has a pending update with a matching IPFS data hash&#13;
   * @param self {object} - The data containing the entity mappings&#13;
   * @param entityId {uint} - The id of the entity &#13;
   * @param signerAddress {address} - The signer to check&#13;
   * @param signerDataHash {string} - The signer IPFS data pending of confirmation&#13;
   */&#13;
  modifier signerUpdateCanBeAccepted(Data storage self, uint entityId, address signerAddress, string signerDataHash) {&#13;
    require (isValid(self, entityId));&#13;
    EntityData storage entity = self.entities[entityId];&#13;
    string memory oldSignerDatHash = entity.signers[signerAddress].signerDataHash;&#13;
    require (entity.signers[signerAddress].status == 3 &amp;&amp; stringsEqual(oldSignerDatHash, signerDataHash));&#13;
    _;&#13;
  }&#13;
&#13;
  /**&#13;
   * True if the sender is registered as a signer in entityId and the status is VALIDATION_PENDING. False otherwise.&#13;
   * @param self {object} - The data containing the entity mappings&#13;
   * @param entityId {uint} - The id of the entity to check&#13;
   */&#13;
  modifier isWaitingConfirmation(Data storage self, uint entityId, string signerDataHash) {&#13;
    EntityData storage entity = self.entities[entityId];&#13;
    SignerData storage signer = entity.signers[msg.sender];&#13;
    require ((bytes(signer.signerDataHash).length != 0) &amp;&amp; (signer.status == 1) &amp;&amp; stringsEqual(signer.signerDataHash, signerDataHash));&#13;
    _;&#13;
  }&#13;
&#13;
  /**&#13;
   * True if the entity has not been closed&#13;
   * @param self {object} - The data containing the entity mappings&#13;
   * @param entityId {uint} - The id of the entity to check&#13;
   */&#13;
  modifier isNotClosed(Data storage self, uint entityId) {&#13;
    require(!isClosed(self, entityId));&#13;
    _;&#13;
  }&#13;
&#13;
  // EVENTS&#13;
&#13;
  event EntityCreated(uint indexed entityId);&#13;
  event EntityValidated(uint indexed entityId);&#13;
  event EntityDataUpdated(uint indexed entityId);&#13;
  event EntityInvalid(uint indexed entityId);&#13;
  event SignerAdded(uint indexed entityId, address indexed signerAddress);&#13;
  event SignerDataUpdated(uint[] entities, address indexed signerAddress);&#13;
  event SignerUpdateAccepted(uint indexed entityId, address indexed signerAddress);&#13;
  event SignerRemoved(uint indexed entityId, address signerAddress);&#13;
  event EntityClosed(uint indexed entityId);&#13;
  event SignerConfirmed(uint indexed entityId, address signerAddress);&#13;
  event EntityExpirationSet(uint indexed entityId);&#13;
  event EntityRenewalSet(uint indexed entityId);  &#13;
 }