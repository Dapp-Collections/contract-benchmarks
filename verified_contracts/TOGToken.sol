pragma solidity ^0.4.18;
// ----------------------------------------------------------------------------
// 'TOG' token contract
//
// Deployed to     : 0x916186f2959aC103C458485A2681C0cd805ad7A2
// Symbol          : TOG
// Name            : Tool of God Token
// Total supply    : 1000000000
// Frozen Amount   :  400000000
// First Release   :   50000000
// Seconad Release :   50000000
// Decimals        : 8
//
//
// (c) by <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="2d6a4c5f540365584c434a6d5942554f594e034e424003">[email protected]</a>&#13;
// ----------------------------------------------------------------------------&#13;
&#13;
// ----------------------------------------------------------------------------&#13;
// Safe maths&#13;
// ----------------------------------------------------------------------------&#13;
contract SafeMath {&#13;
    function safeAdd(uint256 a, uint256 b) public pure returns (uint256 c) {&#13;
        c = a + b;&#13;
        require(c &gt;= a);&#13;
    }&#13;
    function safeSub(uint256 a, uint256 b) public pure returns (uint256 c) {&#13;
        require(b &lt;= a);&#13;
        c = a - b;&#13;
    }&#13;
    function safeMul(uint256 a, uint256 b) public pure returns (uint256 c) {&#13;
        c = a * b;&#13;
        require(a == 0 || c / a == b);&#13;
    }&#13;
    function safeDiv(uint256 a, uint256 b) public pure returns (uint256 c) {&#13;
        require(b &gt; 0);&#13;
        c = a / b;&#13;
    }&#13;
}&#13;
&#13;
&#13;
contract ERC20Interface {&#13;
    function totalSupply() public constant returns (uint256);&#13;
    function balanceOf(address tokenOwner) public constant returns (uint256 balance);&#13;
    function allowance(address tokenOwner, address spender) public constant returns (uint256 remaining);&#13;
    function transfer(address to, uint256 tokens) public returns (bool success);&#13;
    function approve(address spender, uint256 tokens) public returns (bool success);&#13;
    function transferFrom(address from, address to, uint256 tokens) public returns (bool success);&#13;
&#13;
    event Transfer(address indexed from, address indexed to, uint256 tokens);&#13;
    event Approval(address indexed tokenOwner, address indexed spender, uint256 tokens);&#13;
}&#13;
&#13;
&#13;
contract ApproveAndCallFallBack {&#13;
    function receiveApproval(address from, uint256 tokens, address token, bytes data) public;&#13;
}&#13;
&#13;
&#13;
contract Owned {&#13;
    address public owner;&#13;
    address public newOwner;&#13;
&#13;
    event OwnershipTransferred(address indexed _from, address indexed _to);&#13;
&#13;
    function Constructor() public { owner = msg.sender; }&#13;
&#13;
    modifier onlyOwner {&#13;
        require(msg.sender == owner);&#13;
        _;&#13;
    }&#13;
&#13;
    function transferOwnership(address _newOwner) public onlyOwner {&#13;
        newOwner = _newOwner;&#13;
    }&#13;
    function acceptOwnership() public {&#13;
        require(msg.sender == newOwner);&#13;
        emit OwnershipTransferred(owner, newOwner);&#13;
        owner = newOwner;&#13;
        newOwner = address(0);&#13;
    }&#13;
}&#13;
&#13;
contract TOGToken is ERC20Interface, Owned, SafeMath {&#13;
    string public symbol;&#13;
    string public  name;&#13;
    uint8 public decimals;&#13;
    uint256 public _totalSupply;&#13;
    uint256 public _frozeAmount;&#13;
    uint256 _firstUnlockAmmount;&#13;
    uint256 _secondUnlockAmmount;&#13;
    uint256 _firstUnlockTime;&#13;
    uint256 _secondUnlockTime;&#13;
&#13;
&#13;
    mapping(address =&gt; uint256) balances;&#13;
    mapping(address =&gt; mapping(address =&gt; uint256)) allowed;&#13;
&#13;
&#13;
    function Constructor() public {&#13;
        symbol = "TOG";&#13;
        name = "Tool of God Token";&#13;
        decimals = 8;               // decimals 可以有的小数点个数，最小的代币单位。&#13;
        _totalSupply = 1000000000;   // 总共发行10亿枚&#13;
        _frozeAmount =  400000000;   // 冻结4亿枚&#13;
        _firstUnlockAmmount  =  50000000;  //第一年解冻数量&#13;
        _secondUnlockAmmount =  50000000;  //第一年解冻数量&#13;
        balances[msg.sender] = 500000000;&#13;
        _firstUnlockTime  = now + 31536000;&#13;
        _secondUnlockTime = now + 63072000;&#13;
        emit Transfer(address(0), msg.sender, 500000000);&#13;
    }&#13;
&#13;
    function totalSupply() public constant returns (uint256) {&#13;
        return _totalSupply  - balances[address(0)];&#13;
    }&#13;
&#13;
    &#13;
    function balanceOf(address tokenOwner) public constant returns (uint256 balance) {&#13;
        return balances[tokenOwner];&#13;
    }&#13;
&#13;
    function releaseFirstUnlock() public onlyOwner returns (bool success){&#13;
        require(now &gt;= _firstUnlockTime);&#13;
        require(_firstUnlockAmmount &gt; 0);&#13;
        balances[msg.sender] = safeAdd(balances[msg.sender], _firstUnlockAmmount);&#13;
        _firstUnlockAmmount = 0;&#13;
        emit Transfer(address(0), msg.sender, _firstUnlockAmmount);&#13;
        return true;&#13;
    }&#13;
&#13;
    function releaseSecondUnlock() public onlyOwner returns (bool success){&#13;
        require(now &gt;= _secondUnlockTime);&#13;
        require(_secondUnlockAmmount &gt; 0);&#13;
        balances[msg.sender] = safeAdd(balances[msg.sender], _secondUnlockAmmount);&#13;
        _secondUnlockAmmount = 0;&#13;
        emit Transfer(address(0), msg.sender, _secondUnlockAmmount);&#13;
        return true;&#13;
    }&#13;
&#13;
    function transfer(address to, uint256 tokens) public returns (bool success) {&#13;
        require (to != 0x0);                                             // 收币帐户不能为空帐号&#13;
        require (balances[msg.sender] &gt;= tokens);                        // 转出帐户的余额足够&#13;
        require (balances[to] + tokens &gt;= balances[to]);                 // 转入帐户余额未溢出  &#13;
        uint256 previousBalances = balances[msg.sender] + balances[to];  // 两帐户总余额&#13;
        balances[msg.sender] = safeSub(balances[msg.sender], tokens);    // 转出&#13;
        balances[to] = safeAdd(balances[to], tokens);                    // 转入&#13;
        emit Transfer(msg.sender, to, tokens);&#13;
        assert(balances[msg.sender] + balances[to] == previousBalances); //两帐户总余额不变&#13;
        return true;&#13;
    }&#13;
&#13;
    function approve(address spender, uint256 tokens) public returns (bool success) {&#13;
        allowed[msg.sender][spender] = tokens;&#13;
        emit Approval(msg.sender, spender, tokens);&#13;
        return true;&#13;
    }&#13;
&#13;
    function transferFrom(address from, address to, uint256 tokens) public returns (bool success) {&#13;
        require (to != 0x0);                               // 收币帐户不能为空帐号&#13;
        require (balances[from] &gt;= tokens);                // 转出帐户的余额足够&#13;
        require (balances[to] + tokens &gt;= balances[to]);   // 转入帐户余额未溢出                    &#13;
        uint256 previousBalances = balances[from] + balances[to];&#13;
        balances[from] = safeSub(balances[from], tokens);&#13;
        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);&#13;
        balances[to] = safeAdd(balances[to], tokens);&#13;
        emit Transfer(from, to, tokens);&#13;
        assert(balances[from] + balances[to] == previousBalances);&#13;
        return true;&#13;
    }&#13;
&#13;
    function allowance(address tokenOwner, address spender) public constant returns (uint256 remaining) {&#13;
        return allowed[tokenOwner][spender];&#13;
    }&#13;
&#13;
    function approveAndCall(address spender, uint256 tokens, bytes data) public returns (bool success) {&#13;
        allowed[msg.sender][spender] = tokens;&#13;
        emit Approval(msg.sender, spender, tokens);&#13;
        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);&#13;
        return true;&#13;
    }&#13;
&#13;
    function transferAnyERC20Token(address tokenAddress, uint256 tokens) public onlyOwner returns (bool success) {&#13;
        return ERC20Interface(tokenAddress).transfer(owner, tokens);&#13;
    }&#13;
}