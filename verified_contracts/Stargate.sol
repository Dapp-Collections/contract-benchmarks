pragma solidity ^0.4.24;

/*
*                                Stargate V1.0
*
* 
 _______ _________ _______  _______  _______  _______ _________ _______ 
(  ____ \\__   __/(  ___  )(  ____ )(  ____ \(  ___  )\__   __/(  ____ \
| (    \/   ) (   | (   ) || (    )|| (    \/| (   ) |   ) (   | (    \/
| (_____    | |   | (___) || (____)|| |      | (___) |   | |   | (__    
(_____  )   | |   |  ___  ||     __)| | ____ |  ___  |   | |   |  __)   
      ) |   | |   | (   ) || (\ (   | | \_  )| (   ) |   | |   | (      
/\____) |   | |   | )   ( || ) \ \__| (___) || )   ( |   | |   | (____/\
\_______)   )_(   |/     \||/   \__/(_______)|/     \|   )_(   (_______/
                                                                      
*
*
*                       Website:  https://playstargate.com
*
*                       Discord:  https://discord.gg/PnbFSa2
*
*                       Support:  <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="50352438352237313d3534352610373d31393c7e333f3d">[emailÂ protected]</a>&#13;
*&#13;
*&#13;
*&#13;
*   Stargate is a unique game of chance where you can win 10X or more of you&#13;
*   original wager.  Stargate features a progressive jackpot which grows with each bet.&#13;
*&#13;
*&#13;
*&#13;
*&#13;
*&#13;
*/&#13;
&#13;
&#13;
// &lt;ORACLIZE_API&gt;&#13;
/*&#13;
Copyright (c) 2015-2016 Oraclize SRL&#13;
Copyright (c) 2016 Oraclize LTD&#13;
&#13;
&#13;
&#13;
Permission is hereby granted, free of charge, to any person obtaining a copy&#13;
of this software and associated documentation files (the "Software"), to deal&#13;
in the Software without restriction, including without limitation the rights&#13;
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell&#13;
copies of the Software, and to permit persons to whom the Software is&#13;
furnished to do so, subject to the following conditions:&#13;
&#13;
&#13;
&#13;
The above copyright notice and this permission notice shall be included in&#13;
all copies or substantial portions of the Software.&#13;
&#13;
&#13;
&#13;
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR&#13;
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,&#13;
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE&#13;
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER&#13;
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,&#13;
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN&#13;
THE SOFTWARE.&#13;
*/&#13;
&#13;
pragma solidity ^0.4.0; //please import oraclizeAPI_pre0.4.sol when solidity &lt; 0.4.0&#13;
&#13;
contract OraclizeI {&#13;
    address public cbAddress;&#13;
    function query(uint _timestamp, string _datasource, string _arg) payable returns (bytes32 _id);&#13;
    function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) payable returns (bytes32 _id);&#13;
    function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) payable returns (bytes32 _id);&#13;
    function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) payable returns (bytes32 _id);&#13;
    function getPrice(string _datasource) returns (uint _dsprice);&#13;
    function getPrice(string _datasource, uint gaslimit) returns (uint _dsprice);&#13;
    function useCoupon(string _coupon);&#13;
    function setProofType(byte _proofType);&#13;
    function setConfig(bytes32 _config);&#13;
    function setCustomGasPrice(uint _gasPrice);&#13;
}&#13;
contract OraclizeAddrResolverI {&#13;
    function getAddress() returns (address _addr);&#13;
}&#13;
contract usingOraclize {&#13;
    uint constant day = 60*60*24;&#13;
    uint constant week = 60*60*24*7;&#13;
    uint constant month = 60*60*24*30;&#13;
    byte constant proofType_NONE = 0x00;&#13;
    byte constant proofType_TLSNotary = 0x10;&#13;
    byte constant proofStorage_IPFS = 0x01;&#13;
    uint8 constant networkID_auto = 0;&#13;
    uint8 constant networkID_mainnet = 1;&#13;
    uint8 constant networkID_testnet = 2;&#13;
    uint8 constant networkID_morden = 2;&#13;
    uint8 constant networkID_consensys = 161;&#13;
&#13;
    OraclizeAddrResolverI OAR;&#13;
    &#13;
    OraclizeI oraclize;&#13;
    modifier oraclizeAPI {&#13;
        if(address(OAR)==0) oraclize_setNetwork(networkID_auto);&#13;
        oraclize = OraclizeI(OAR.getAddress());&#13;
        _;&#13;
    }&#13;
    modifier coupon(string code){&#13;
        oraclize = OraclizeI(OAR.getAddress());&#13;
        oraclize.useCoupon(code);&#13;
        _;&#13;
    }&#13;
&#13;
    function oraclize_setNetwork(uint8 networkID) internal returns(bool){&#13;
        if (getCodeSize(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed)&gt;0){ //mainnet&#13;
            OAR = OraclizeAddrResolverI(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed);&#13;
            return true;&#13;
        }&#13;
        if (getCodeSize(0xc03a2615d5efaf5f49f60b7bb6583eaec212fdf1)&gt;0){ //ropsten testnet&#13;
            OAR = OraclizeAddrResolverI(0xc03a2615d5efaf5f49f60b7bb6583eaec212fdf1);&#13;
            return true;&#13;
        }&#13;
        if (getCodeSize(0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa)&gt;0){ //browser-solidity&#13;
            OAR = OraclizeAddrResolverI(0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa);&#13;
            return true;&#13;
        }&#13;
        return false;&#13;
    }&#13;
    &#13;
    function __callback(bytes32 myid, string result) {&#13;
        __callback(myid, result, new bytes(0));&#13;
    }&#13;
    function __callback(bytes32 myid, string result, bytes proof) {&#13;
    }&#13;
    &#13;
    function oraclize_getPrice(string datasource) oraclizeAPI internal returns (uint){&#13;
        return oraclize.getPrice(datasource);&#13;
    }&#13;
    function oraclize_getPrice(string datasource, uint gaslimit) oraclizeAPI internal returns (uint){&#13;
        return oraclize.getPrice(datasource, gaslimit);&#13;
    }&#13;
    &#13;
    function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){&#13;
        uint price = oraclize.getPrice(datasource);&#13;
        if (price &gt; 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price&#13;
        return oraclize.query.value(price)(0, datasource, arg);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){&#13;
        uint price = oraclize.getPrice(datasource);&#13;
        if (price &gt; 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price&#13;
        return oraclize.query.value(price)(timestamp, datasource, arg);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){&#13;
        uint price = oraclize.getPrice(datasource, gaslimit);&#13;
        if (price &gt; 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price&#13;
        return oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){&#13;
        uint price = oraclize.getPrice(datasource, gaslimit);&#13;
        if (price &gt; 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price&#13;
        return oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){&#13;
        uint price = oraclize.getPrice(datasource);&#13;
        if (price &gt; 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price&#13;
        return oraclize.query2.value(price)(0, datasource, arg1, arg2);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){&#13;
        uint price = oraclize.getPrice(datasource);&#13;
        if (price &gt; 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price&#13;
        return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){&#13;
        uint price = oraclize.getPrice(datasource, gaslimit);&#13;
        if (price &gt; 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price&#13;
        return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){&#13;
        uint price = oraclize.getPrice(datasource, gaslimit);&#13;
        if (price &gt; 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price&#13;
        return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit);&#13;
    }&#13;
    function oraclize_cbAddress() oraclizeAPI internal returns (address){&#13;
        return oraclize.cbAddress();&#13;
    }&#13;
    function oraclize_setProof(byte proofP) oraclizeAPI internal {&#13;
        return oraclize.setProofType(proofP);&#13;
    }&#13;
    function oraclize_setCustomGasPrice(uint gasPrice) oraclizeAPI internal {&#13;
        return oraclize.setCustomGasPrice(gasPrice);&#13;
    }    &#13;
    function oraclize_setConfig(bytes32 config) oraclizeAPI internal {&#13;
        return oraclize.setConfig(config);&#13;
    }&#13;
&#13;
    function getCodeSize(address _addr) constant internal returns(uint _size) {&#13;
        assembly {&#13;
            _size := extcodesize(_addr)&#13;
        }&#13;
    }&#13;
&#13;
&#13;
    function parseAddr(string _a) internal returns (address){&#13;
        bytes memory tmp = bytes(_a);&#13;
        uint160 iaddr = 0;&#13;
        uint160 b1;&#13;
        uint160 b2;&#13;
        for (uint i=2; i&lt;2+2*20; i+=2){&#13;
            iaddr *= 256;&#13;
            b1 = uint160(tmp[i]);&#13;
            b2 = uint160(tmp[i+1]);&#13;
            if ((b1 &gt;= 97)&amp;&amp;(b1 &lt;= 102)) b1 -= 87;&#13;
            else if ((b1 &gt;= 48)&amp;&amp;(b1 &lt;= 57)) b1 -= 48;&#13;
            if ((b2 &gt;= 97)&amp;&amp;(b2 &lt;= 102)) b2 -= 87;&#13;
            else if ((b2 &gt;= 48)&amp;&amp;(b2 &lt;= 57)) b2 -= 48;&#13;
            iaddr += (b1*16+b2);&#13;
        }&#13;
        return address(iaddr);&#13;
    }&#13;
&#13;
&#13;
    function strCompare(string _a, string _b) internal returns (int) {&#13;
        bytes memory a = bytes(_a);&#13;
        bytes memory b = bytes(_b);&#13;
        uint minLength = a.length;&#13;
        if (b.length &lt; minLength) minLength = b.length;&#13;
        for (uint i = 0; i &lt; minLength; i ++)&#13;
            if (a[i] &lt; b[i])&#13;
                return -1;&#13;
            else if (a[i] &gt; b[i])&#13;
                return 1;&#13;
        if (a.length &lt; b.length)&#13;
            return -1;&#13;
        else if (a.length &gt; b.length)&#13;
            return 1;&#13;
        else&#13;
            return 0;&#13;
   } &#13;
&#13;
    function indexOf(string _haystack, string _needle) internal returns (int)&#13;
    {&#13;
        bytes memory h = bytes(_haystack);&#13;
        bytes memory n = bytes(_needle);&#13;
        if(h.length &lt; 1 || n.length &lt; 1 || (n.length &gt; h.length)) &#13;
            return -1;&#13;
        else if(h.length &gt; (2**128 -1))&#13;
            return -1;                                  &#13;
        else&#13;
        {&#13;
            uint subindex = 0;&#13;
            for (uint i = 0; i &lt; h.length; i ++)&#13;
            {&#13;
                if (h[i] == n[0])&#13;
                {&#13;
                    subindex = 1;&#13;
                    while(subindex &lt; n.length &amp;&amp; (i + subindex) &lt; h.length &amp;&amp; h[i + subindex] == n[subindex])&#13;
                    {&#13;
                        subindex++;&#13;
                    }   &#13;
                    if(subindex == n.length)&#13;
                        return int(i);&#13;
                }&#13;
            }&#13;
            return -1;&#13;
        }   &#13;
    }&#13;
&#13;
    function strConcat(string _a, string _b, string _c, string _d, string _e) internal returns (string){&#13;
        bytes memory _ba = bytes(_a);&#13;
        bytes memory _bb = bytes(_b);&#13;
        bytes memory _bc = bytes(_c);&#13;
        bytes memory _bd = bytes(_d);&#13;
        bytes memory _be = bytes(_e);&#13;
        string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);&#13;
        bytes memory babcde = bytes(abcde);&#13;
        uint k = 0;&#13;
        for (uint i = 0; i &lt; _ba.length; i++) babcde[k++] = _ba[i];&#13;
        for (i = 0; i &lt; _bb.length; i++) babcde[k++] = _bb[i];&#13;
        for (i = 0; i &lt; _bc.length; i++) babcde[k++] = _bc[i];&#13;
        for (i = 0; i &lt; _bd.length; i++) babcde[k++] = _bd[i];&#13;
        for (i = 0; i &lt; _be.length; i++) babcde[k++] = _be[i];&#13;
        return string(babcde);&#13;
    }&#13;
    &#13;
    function strConcat(string _a, string _b, string _c, string _d) internal returns (string) {&#13;
        return strConcat(_a, _b, _c, _d, "");&#13;
    }&#13;
&#13;
    function strConcat(string _a, string _b, string _c) internal returns (string) {&#13;
        return strConcat(_a, _b, _c, "", "");&#13;
    }&#13;
&#13;
    function strConcat(string _a, string _b) internal returns (string) {&#13;
        return strConcat(_a, _b, "", "", "");&#13;
    }&#13;
&#13;
    // parseInt&#13;
    function parseInt(string _a) internal returns (uint) {&#13;
        return parseInt(_a, 0);&#13;
    }&#13;
&#13;
    // parseInt(parseFloat*10^_b)&#13;
    function parseInt(string _a, uint _b) internal returns (uint) {&#13;
        bytes memory bresult = bytes(_a);&#13;
        uint mint = 0;&#13;
        bool decimals = false;&#13;
        for (uint i=0; i&lt;bresult.length; i++){&#13;
            if ((bresult[i] &gt;= 48)&amp;&amp;(bresult[i] &lt;= 57)){&#13;
                if (decimals){&#13;
                   if (_b == 0) break;&#13;
                    else _b--;&#13;
                }&#13;
                mint *= 10;&#13;
                mint += uint(bresult[i]) - 48;&#13;
            } else if (bresult[i] == 46) decimals = true;&#13;
        }&#13;
        if (_b &gt; 0) mint *= 10**_b;&#13;
        return mint;&#13;
    }&#13;
    &#13;
    function uint2str(uint i) internal returns (string){&#13;
        if (i == 0) return "0";&#13;
        uint j = i;&#13;
        uint len;&#13;
        while (j != 0){&#13;
            len++;&#13;
            j /= 10;&#13;
        }&#13;
        bytes memory bstr = new bytes(len);&#13;
        uint k = len - 1;&#13;
        while (i != 0){&#13;
            bstr[k--] = byte(48 + i % 10);&#13;
            i /= 10;&#13;
        }&#13;
        return string(bstr);&#13;
    }&#13;
    &#13;
    &#13;
&#13;
}&#13;
// &lt;/ORACLIZE_API&gt;&#13;
&#13;
&#13;
&#13;
// Stargate game data setup&#13;
contract Stargate is usingOraclize {&#13;
    using SafeMath for uint;&#13;
&#13;
    // ---------------------- Events&#13;
&#13;
    event LogResult(&#13;
        address _wagerer,&#13;
        uint _result,&#13;
        uint _profit,&#13;
        uint _wagered,&#13;
        uint _category,&#13;
        bool _win,&#13;
        uint _originalBet&#13;
    );&#13;
&#13;
    event onWithdraw(&#13;
        address customerAddress,&#13;
        uint256 ethereumWithdrawn&#13;
    );&#13;
&#13;
    event betError(&#13;
        address indexed _wagerer,&#13;
        uint _result&#13;
    );&#13;
&#13;
    event modError(&#13;
        address indexed _wagerer,&#13;
        uint _result&#13;
    );&#13;
&#13;
     // Result announcement events&#13;
    event LOG_NewBet(address _wagerer, uint amount);&#13;
    event Deposit(address indexed sender, uint value);&#13;
    event Loss(address _wagerer, uint _block);                  // Category 0&#13;
    event Cat1(address _wagerer, uint _block);                  // Category 1&#13;
    event Cat2(address _wagerer, uint _block);                  // Category 2&#13;
    event Cat3(address _wagerer, uint _block);                  // Category 3&#13;
    event Cat4(address _wagerer, uint _block);                  // Category 4&#13;
    event Cat5(address _wagerer, uint _block);                  // Category 5&#13;
    event Cat6(address _wagerer, uint _block);                  // Category 6&#13;
    event Cat7(address _wagerer, uint _block);                  // Category 7&#13;
    event Cat8(address _wagerer, uint _block);                  // Category 8&#13;
    event Cat9(address _wagerer, uint _block);                  // Category 9&#13;
    event Cat10(address _wagerer, uint _block);                 // Category 10&#13;
    event Cat11(address _wagerer, uint _block);                 // Category 11&#13;
    event Cat12(address _wagerer, uint _block);                 // Category 12&#13;
    event Cat13(address _wagerer, uint _block);                 // Category 13&#13;
    event Cat14(address _wagerer, uint _block);                 // Category 14&#13;
    event Cat15(address _wagerer, uint _block);                 // Category 15&#13;
    event Cat16(address _wagerer, uint _block);                 // Category 16&#13;
    event Cat17(address _wagerer, uint _block);                 // Category 17&#13;
    event Cat18(address _wagerer, uint _block);                 // Category 18&#13;
    event Cat19(address _wagerer, uint _block);                 // Category 19    &#13;
    event BetConcluded(address _wagerer, uint _block);          // Debug event&#13;
&#13;
    event LogConstructorInitiated(string nextStep);&#13;
    event LogPriceUpdated(string price);&#13;
    event LogNewOraclizeQuery(string description);&#13;
&#13;
   &#13;
    // ---------------------- Modifiers&#13;
&#13;
    // Makes sure bet is within Min and Max Range&#13;
    modifier betIsValid(uint _betSize) {&#13;
        require(_betSize &lt;= maxBet);&#13;
        require(_betSize &gt;= minBet);&#13;
      _;&#13;
    }&#13;
&#13;
      // only people with winnings&#13;
    modifier onlyPlayers(address _player) {&#13;
        require(playerAccount[_player] &gt; 0);&#13;
        _;&#13;
    }&#13;
&#13;
    // Requires the game to be currently active&#13;
    modifier gameIsActive {&#13;
      require(gamePaused == false);&#13;
      _;&#13;
    }&#13;
&#13;
    // Require msg.sender to be owner&#13;
    modifier onlyOwner {&#13;
      require(msg.sender == owner); &#13;
      _;&#13;
    }&#13;
&#13;
    modifier onlyOraclize {&#13;
        if (msg.sender != oraclize_cbAddress()) throw; &#13;
        _;&#13;
    }&#13;
&#13;
    modifier onlyIfBetExist(bytes32 myid) {&#13;
        if(bets[myid].playerAddress == address(0x0)) throw;&#13;
        _;&#13;
    }&#13;
&#13;
    modifier onlyIfValidGas(uint newGasLimit) {&#13;
        if (ORACLIZE_GAS_LIMIT + newGasLimit &lt; ORACLIZE_GAS_LIMIT) throw;&#13;
        if (newGasLimit &lt; 25000) throw;&#13;
        _;&#13;
    }&#13;
&#13;
    modifier onlyIfNotProcessed(bytes32 myid) {&#13;
        if (bets[myid].numberRolled &gt; 0) throw;&#13;
        _;&#13;
    }&#13;
&#13;
    struct Bet {&#13;
        address playerAddress;&#13;
        uint amountBet;&#13;
        uint numberRolled;&#13;
        uint originalBet;&#13;
        bool instaPay;&#13;
    }&#13;
&#13;
    // ---------------------- Variables&#13;
&#13;
    // Configurables&#13;
    uint maxProfit;&#13;
&#13;
    mapping (address =&gt; uint256) public playerAccount;&#13;
    uint public maxProfitAsPercentOfHouse;&#13;
    uint public minBet = 5e16;  //0.05ETH&#13;
    uint public maxBet = 2e17;  //0.20ETH  This will increase with contract value&#13;
&#13;
    mapping (address =&gt; uint256) public playerETHWagered;&#13;
    mapping (address =&gt; uint256) public playerETHWon;&#13;
 &#13;
    address private owner;&#13;
    address private bankroll;&#13;
    bool gamePaused;&#13;
    bool boolJackpotFee;&#13;
    uint jackpotDivisor;&#13;
&#13;
    //Random Number Functions&#13;
    uint public randN = 3;          //numberof random bytes to be returned&#13;
    uint public randDelay = 0;      //number of seconds to delay result&#13;
    uint public maxRange = 1000000; //Max Random Number&#13;
&#13;
    // Trackers&#13;
    //uint  public totalSpins;&#13;
    uint  public totalBets;&#13;
     uint  public totalCalls;&#13;
    uint  public totalETHWagered;&#13;
    //mapping (uint =&gt; uint) public contractBalance;&#13;
    &#13;
    // Is betting allowed? (Administrative function, in the event of unforeseen bugs)&#13;
    bool public gameActive;&#13;
&#13;
&#13;
    uint256 public jackpot;&#13;
    uint256 private houseAccount;&#13;
    uint256 public bankAccount;&#13;
    uint256 public contractBalance;&#13;
    uint private maxPayoutMultiple;&#13;
    uint256 public totalPlayerBalance;&#13;
    uint public lastResult;&#13;
    uint256 private lastBlock;&#13;
    uint48 private lastSpinBlock; &#13;
    uint lastCategory;&#13;
    uint public lastProfit;&#13;
    uint public numBets;&#13;
&#13;
    mapping(uint =&gt; uint256) winThreshold;&#13;
    mapping(uint =&gt; uint) winPercentage;&#13;
&#13;
    &#13;
&#13;
    mapping (bytes32 =&gt; Bet) public bets;&#13;
    bytes32[] public betsKeys;&#13;
&#13;
    uint[] public arrResult;&#13;
&#13;
    uint ORACLIZE_GAS_LIMIT = 400000;   //250000;&#13;
    uint safeGas = 2300;&#13;
    uint public customGasPrice = 7000000000;  //7GWEI&#13;
&#13;
    uint public oracleFee = 0;&#13;
&#13;
    &#13;
&#13;
    &#13;
    uint256 public lastOraclePrice;&#13;
    //uint256 public contractBalance;&#13;
    uint public lastOracleFee;&#13;
&#13;
    bool public allowReferrals;&#13;
    uint public referralPercent;&#13;
    uint public minReferAmount = 100000000000000000;    //0.1 ETH min wagered to qualify for a masternode&#13;
&#13;
    // ---------------------- Functions &#13;
&#13;
    constructor() public  {&#13;
&#13;
        owner = msg.sender;&#13;
&#13;
        //oraclize_setProof(proofType_Ledger);&#13;
&#13;
        // Set starting variables&#13;
        gameActive  = true;&#13;
&#13;
        allowReferrals = false;&#13;
        referralPercent = 1;&#13;
&#13;
        jackpot = 0;&#13;
        totalPlayerBalance = 0;&#13;
        houseAccount = 0;&#13;
        bankAccount = 0;&#13;
        maxPayoutMultiple = 15;&#13;
&#13;
        boolJackpotFee = false;&#13;
        jackpotDivisor = 100;&#13;
&#13;
        winThreshold[0] = 900000;&#13;
        winThreshold[1] = 2;&#13;
        winThreshold[2] = 299;&#13;
        winThreshold[3] = 3128;&#13;
        winThreshold[4] = 16961;&#13;
        winThreshold[5] = 30794;&#13;
        winThreshold[6] = 44627;&#13;
        winThreshold[7] = 46627;&#13;
        winThreshold[8] = 49627;&#13;
        winThreshold[9] = 51627;&#13;
        winThreshold[10] = 53127;&#13;
        winThreshold[11] = 82530;&#13;
        winThreshold[12] = 150423;&#13;
        winThreshold[13] = 203888;&#13;
        winThreshold[14] = 257353;&#13;
        winThreshold[15] = 310818;&#13;
        winThreshold[16] = 364283;&#13;
        winThreshold[17] = 417748;&#13;
        winThreshold[18] = 471213;&#13;
&#13;
        winPercentage[2] = 1000;        &#13;
        winPercentage[3] = 500;        &#13;
        winPercentage[4] = 200;         &#13;
        winPercentage[5] = 200;         &#13;
        winPercentage[6] = 200;         &#13;
        winPercentage[7] = 500;        &#13;
        winPercentage[8] = 750;         &#13;
        winPercentage[9] = 400;         &#13;
        winPercentage[10] = 400;       &#13;
        winPercentage[11] = 250;        &#13;
        winPercentage[12] = 150;        &#13;
        winPercentage[13] = 75;         &#13;
        winPercentage[14] = 75;         &#13;
        winPercentage[15] = 75;         &#13;
        winPercentage[16] = 100;        &#13;
        winPercentage[17] = 75;        &#13;
        winPercentage[18] = 75;        &#13;
        winPercentage[19] = 33;        &#13;
&#13;
    }&#13;
&#13;
     function deposit()&#13;
        public&#13;
        payable&#13;
    {&#13;
        addContractBalance(msg.value);&#13;
        bankAccount = SafeMath.add(bankAccount, msg.value);&#13;
    }&#13;
&#13;
&#13;
    function withdrawWinnings()&#13;
        onlyPlayers(msg.sender)&#13;
        public&#13;
    {&#13;
        // setup data&#13;
        uint256 _winnings = playerAccount[msg.sender]; &#13;
        require( _winnings &lt; address(this).balance - jackpot);&#13;
        playerAccount[msg.sender] = 0;&#13;
        totalPlayerBalance = SafeMath.sub(totalPlayerBalance, _winnings);&#13;
        msg.sender.transfer(_winnings);&#13;
        subContractBalance(_winnings);&#13;
            &#13;
        // fire event&#13;
        emit onWithdraw(msg.sender, _winnings);&#13;
&#13;
    }&#13;
&#13;
     function()&#13;
        payable {&#13;
&#13;
        bet(true, 0x0000000000000000000000000000000000000000);&#13;
    }&#13;
&#13;
  // Execute bet.&#13;
    function bet(bool _instaPay, address _referrer) &#13;
      public&#13;
      payable&#13;
      betIsValid(msg.value)   &#13;
    {&#13;
        require(msg.value &gt; 0);&#13;
        require(gameActive);&#13;
&#13;
&#13;
        totalETHWagered += msg.value;&#13;
        playerETHWagered[msg.sender] = SafeMath.add(playerETHWagered[msg.sender], msg.value);&#13;
&#13;
        addContractBalance(msg.value);&#13;
&#13;
        uint betValue = msg.value - oracleFee;&#13;
&#13;
        if (allowReferrals &amp;&amp; _referrer != 0x0000000000000000000000000000000000000000 &amp;&amp; (_referrer != msg.sender) &amp;&amp; (playerETHWagered[_referrer] &gt;= minReferAmount)){&#13;
            &#13;
            uint refererAmount = SafeMath.div(SafeMath.mul(betValue,referralPercent),100);&#13;
            betValue = SafeMath.sub(betValue,refererAmount);&#13;
            playerAccount[_referrer] = SafeMath.add(playerAccount[_referrer], refererAmount);&#13;
            totalPlayerBalance = SafeMath.add(totalPlayerBalance, refererAmount);&#13;
        }&#13;
&#13;
        &#13;
       &#13;
        LOG_NewBet(msg.sender, msg.value);&#13;
&#13;
        // Increment total number of bets&#13;
        totalBets += 1;&#13;
&#13;
        oraclize_setCustomGasPrice(customGasPrice);&#13;
&#13;
        //bytes32 myid = oraclize_newRandomDSQuery(randDelay, randN, ORACLIZE_GAS_LIMIT + safeGas);&#13;
&#13;
        bytes32 myid = oraclize_query("WolframAlpha", "random number between 1 and 1000000", ORACLIZE_GAS_LIMIT + safeGas);&#13;
&#13;
        bets[myid] = Bet(msg.sender, betValue, 0, msg.value, _instaPay);&#13;
        betsKeys.push(myid);&#13;
&#13;
  &#13;
    }&#13;
&#13;
     function __callback(bytes32 myid, string strResult)&#13;
        onlyOraclize &#13;
        onlyIfBetExist(myid)&#13;
        onlyIfNotProcessed(myid)&#13;
      {&#13;
         &#13;
        totalCalls = totalCalls + 1;&#13;
        uint result = parseInt(strResult);&#13;
        bets[myid].numberRolled = result;&#13;
        arrResult.push(result);&#13;
&#13;
        //uint result = parseInt(strResult);&#13;
&#13;
        bets[myid].numberRolled = result;&#13;
        arrResult.push(result);&#13;
&#13;
&#13;
        uint256 betAmount = bets[myid].amountBet;&#13;
       &#13;
        jackpot = SafeMath.add(jackpot,SafeMath.div(betAmount,jackpotDivisor));&#13;
        &#13;
        if (boolJackpotFee){&#13;
            betAmount = SafeMath.sub(betAmount,SafeMath.div(betAmount,jackpotDivisor));&#13;
        }&#13;
&#13;
        uint profit = 0;&#13;
        uint category = 0;&#13;
&#13;
        lastResult = result;&#13;
&#13;
        checkResult(bets[myid].playerAddress, betAmount, category, result, myid);&#13;
       &#13;
        emit BetConcluded(bets[myid].playerAddress, result);&#13;
    &#13;
        }&#13;
    &#13;
&#13;
&#13;
function checkResult(address target, uint256 betAmount, uint category, uint _result, bytes32 myid) internal {&#13;
  &#13;
  uint _originalBet = bets[myid].amountBet;&#13;
  bool _instaPay = bets[myid].instaPay;&#13;
&#13;
  uint profit = 0; &#13;
&#13;
   if (_result &gt; winThreshold[0]) {   &#13;
            // Player has lost. &#13;
&#13;
            category = 0;&#13;
            emit Loss(target, _result);&#13;
           &#13;
        &#13;
        } else if (_result &lt; winThreshold[1]) {  //2&#13;
            // Player has won the jackpot!&#13;
      &#13;
            // Get profit amount via jackpot&#13;
            profit = jackpot;    &#13;
            category = 1;&#13;
            jackpot = 0;&#13;
            // Emit events&#13;
            emit Cat1(target, _result);&#13;
          &#13;
&#13;
           if (_instaPay){&#13;
                if(profit &gt; 0){&#13;
                    if (profit &lt;= (address(this).balance - jackpot - totalPlayerBalance)){&#13;
                        target.transfer(profit);&#13;
                        subContractBalance(profit);&#13;
                        playerETHWon[target] = SafeMath.add(playerETHWon[target], profit);&#13;
                    }else&#13;
                        {&#13;
                        playerAccount[target] = SafeMath.add(playerAccount[target],profit);&#13;
                        totalPlayerBalance = SafeMath.add(totalPlayerBalance, profit);&#13;
                        playerETHWon[target] = SafeMath.add(playerETHWon[target], profit);&#13;
                        }&#13;
&#13;
                    }&#13;
                }else{&#13;
                    playerAccount[target] = SafeMath.add(playerAccount[target], profit);&#13;
                    totalPlayerBalance = SafeMath.add(totalPlayerBalance, profit);&#13;
                    playerETHWon[target] = SafeMath.add(playerETHWon[target], profit);&#13;
                }&#13;
&#13;
&#13;
            } else {&#13;
                if (_result &lt; winThreshold[2]) {  //299&#13;
                    category = 2;&#13;
                    emit Cat2(target, _result);&#13;
                } else if (_result &lt; winThreshold[3]) {  //3128&#13;
                    category = 3;&#13;
                    emit Cat3(target, _result);&#13;
                } else if (_result &lt; winThreshold[4]) {  //16961&#13;
                    category = 4;&#13;
                    emit Cat4(target, _result);&#13;
                } else if (_result &lt; winThreshold[5]) {  //30794&#13;
                    category = 5;&#13;
                    emit Cat5(target, _result);&#13;
                } else if (_result &lt; winThreshold[6]) {  //44627&#13;
                    category = 6;&#13;
                    emit Cat6(target, _result);&#13;
                } else if (_result &lt; winThreshold[7]) {  //46627&#13;
                    category = 7;&#13;
                    emit Cat7(target, _result);&#13;
                } else if (_result &lt; winThreshold[8]) {  //49127&#13;
                    category = 8;&#13;
                    emit Cat8(target, _result);&#13;
                } else if (_result &lt; winThreshold[9]) {  //51627&#13;
                    category = 9;&#13;
                    emit Cat9(target, _result);&#13;
                } else if (_result &lt; winThreshold[10]) {  //53127&#13;
                    category = 10;&#13;
                    emit Cat10(target, _result);&#13;
                } else if (_result &lt; winThreshold[11]) {  //82530&#13;
                    category = 11;&#13;
                    emit Cat11(target, _result);&#13;
                } else if (_result &lt; winThreshold[12]) {  //150423&#13;
                    category = 12;&#13;
                    emit Cat12(target, _result);&#13;
                } else if (_result &lt; winThreshold[13]) {  //203888&#13;
                    category = 13;&#13;
                    emit Cat13(target, _result);&#13;
                } else if (_result &lt; winThreshold[14]) {  //257353&#13;
                    category = 14;&#13;
                    emit Cat14(target, _result);&#13;
                } else if (_result &lt; winThreshold[15]) {  //310818&#13;
                    category = 15;&#13;
                    emit Cat15(target, _result);&#13;
                } else if (_result &lt; winThreshold[16]) {  //364283&#13;
                    category = 16;&#13;
                    emit Cat16(target, _result);&#13;
                } else if (_result &lt; winThreshold[17]) {  //417748&#13;
                    category = 17;&#13;
                    emit Cat17(target, _result);&#13;
                } else if (_result &lt; winThreshold[18]) {  //471213&#13;
                    category = 18;&#13;
                    emit Cat18(target, _result);&#13;
                } else {&#13;
                    category = 19;&#13;
                    emit Cat19(target, _result);&#13;
                }&#13;
                lastCategory = category;&#13;
            }&#13;
&#13;
            distributePrize(target, betAmount, category, _result, _originalBet, _instaPay);&#13;
&#13;
        }&#13;
&#13;
    &#13;
&#13;
    //Distribute Prize&#13;
    function distributePrize(address target, uint256 betAmount, uint category, uint _result, uint _originalBet, bool _instaPay) internal {&#13;
        &#13;
        uint256 profit = 0;&#13;
     &#13;
        if (category &gt;= 2 &amp;&amp; category &lt;= 19){&#13;
            profit = SafeMath.div(SafeMath.mul(betAmount,winPercentage[category]),100);&#13;
        }&#13;
&#13;
        if (_instaPay){&#13;
            if(profit&gt;0){&#13;
&#13;
                uint256 _maxWithdraw = address(this).balance;&#13;
                if (profit &lt;= _maxWithdraw){&#13;
                    target.transfer(profit);&#13;
                    subContractBalance(profit);&#13;
                } else {&#13;
                    playerAccount[target] = SafeMath.add(playerAccount[target],profit);&#13;
                    totalPlayerBalance = SafeMath.add(totalPlayerBalance, profit);&#13;
                    playerETHWon[target] = SafeMath.add(playerETHWon[target], profit);&#13;
                }&#13;
&#13;
&#13;
            }&#13;
        }else{&#13;
            playerAccount[target] = SafeMath.add(playerAccount[target], profit);&#13;
            totalPlayerBalance = SafeMath.add(totalPlayerBalance, profit);&#13;
        }&#13;
&#13;
        lastProfit = profit;&#13;
        playerETHWon[target] = SafeMath.add(playerETHWon[target], profit);&#13;
&#13;
&#13;
        emit LogResult(target, _result, profit, betAmount, category, true, _originalBet);&#13;
   &#13;
        &#13;
    }&#13;
&#13;
&#13;
     function setWinPercentage(uint _category, uint _percentage) public onlyOwner {&#13;
        winPercentage[_category] = _percentage;&#13;
    }&#13;
&#13;
     function setWinThreshold(uint _category, uint _threshold) public onlyOwner {&#13;
        winThreshold[_category] = _threshold;&#13;
    }&#13;
&#13;
     function getWinPercentage(uint _category) public view returns(uint){&#13;
        return(winPercentage[_category]);&#13;
    }&#13;
&#13;
    function getWinThreshold(uint _category) public view returns(uint){&#13;
        return(winThreshold[_category]);&#13;
    }&#13;
&#13;
    // Subtracts from the contract balance tracking var&#13;
    function subContractBalance(uint256 sub) internal {&#13;
      contractBalance = contractBalance.sub(sub);&#13;
&#13;
    }&#13;
&#13;
    // Adds to the contract balance tracking var&#13;
    function addContractBalance(uint add) internal {&#13;
      contractBalance = contractBalance.add(add);&#13;
    }&#13;
&#13;
    // Only owner can set minBet   &#13;
    function ownerSetMinBet(uint newMinimumBet) public&#13;
    onlyOwner&#13;
    {&#13;
      minBet = newMinimumBet;&#13;
    }&#13;
&#13;
    // Only owner can set maxBet   &#13;
    function ownerSetMaxBet(uint newMaximumBet) public&#13;
    onlyOwner&#13;
    {&#13;
      maxBet = newMaximumBet;&#13;
    }&#13;
&#13;
    function setGasLimit(uint _gas) public onlyOwner   {&#13;
        ORACLIZE_GAS_LIMIT = _gas;&#13;
    }&#13;
&#13;
    function getGasLimit() public view returns(uint){&#13;
        return(ORACLIZE_GAS_LIMIT);&#13;
    }&#13;
&#13;
&#13;
    // If, for any reason, betting needs to be paused (very unlikely), this will freeze all bets.&#13;
    function pauseGame() public onlyOwner {&#13;
        gameActive = false;&#13;
    }&#13;
&#13;
    // The converse of the above, resuming betting if a freeze had been put in place.&#13;
    function resumeGame() public onlyOwner {&#13;
        gameActive = true;&#13;
    }&#13;
&#13;
    // Administrative function to change the owner of the contract.&#13;
    function changeOwner(address _newOwner) public onlyOwner {&#13;
        owner = _newOwner;&#13;
    }&#13;
&#13;
    function setOracleFee(uint256 _newFee) public onlyOwner {&#13;
        oracleFee = _newFee;&#13;
    }&#13;
&#13;
    function setAllowReferral(bool _allow) public onlyOwner {&#13;
        allowReferrals = _allow;&#13;
    }&#13;
&#13;
    function setReferralPercent(uint _percent) public onlyOwner {&#13;
        referralPercent = _percent;&#13;
    }&#13;
&#13;
    function setMaxRange(uint _newRange) public onlyOwner {&#13;
        maxRange = _newRange;&#13;
    }&#13;
&#13;
    function setRandN(uint _newN) public onlyOwner {&#13;
        randN = _newN;&#13;
    }&#13;
&#13;
    function setRandDelay(uint _newDelay) public onlyOwner {&#13;
        randDelay = _newDelay;&#13;
    }&#13;
&#13;
    function setMinReferer(uint _newAmount) public onlyOwner {&#13;
        minReferAmount = _newAmount;&#13;
    }&#13;
&#13;
    function setStargateCustomGasPrice(uint _newPrice) public onlyOwner {&#13;
        customGasPrice = _newPrice;&#13;
    }&#13;
    &#13;
    function getContractBalance() public view returns(uint256) {&#13;
        return(address(this).balance);&#13;
    }&#13;
&#13;
    function getMyBalance() public view returns(uint256) {&#13;
        return(playerAccount[msg.sender]);&#13;
    }&#13;
&#13;
    function getJackpot() public view returns(uint256){&#13;
        return(jackpot);&#13;
    }&#13;
&#13;
    function getBankAccount() public view returns(uint256){&#13;
        return(bankAccount);&#13;
    }&#13;
&#13;
    function getLastBlock() public view returns(uint256){&#13;
        return(lastBlock);&#13;
    }&#13;
&#13;
    function getLastResult() public view returns(uint){&#13;
        return(lastResult);&#13;
    }&#13;
&#13;
    function getLastCategory() public view returns(uint){&#13;
        return(lastCategory);&#13;
    }&#13;
    function getLastProfit() public view returns(uint){&#13;
        return(lastProfit);&#13;
    }&#13;
&#13;
    function refund(address _to, uint256 _Amount) public onlyOwner &#13;
    &#13;
    {&#13;
        uint256 _maxRefund = address(this).balance - jackpot - totalPlayerBalance;&#13;
&#13;
       require(_Amount &lt;= _maxRefund);&#13;
        _to.transfer(_Amount);&#13;
        subContractBalance(_Amount);&#13;
&#13;
        &#13;
    }&#13;
&#13;
}&#13;
&#13;
&#13;
/**&#13;
 * @title SafeMath&#13;
 * @dev Math operations with safety checks that throw on error&#13;
 */&#13;
library SafeMath {&#13;
&#13;
    /**&#13;
    * @dev Multiplies two numbers, throws on overflow.&#13;
    */&#13;
    function mul(uint a, uint b) internal pure returns (uint) {&#13;
        if (a == 0) {&#13;
            return 0;&#13;
        }&#13;
        uint c = a * b;&#13;
        assert(c / a == b);&#13;
        return c;&#13;
    }&#13;
&#13;
    /**&#13;
    * @dev Integer division of two numbers, truncating the quotient.&#13;
    */&#13;
    function div(uint a, uint b) internal pure returns (uint) {&#13;
        // assert(b &gt; 0); // Solidity automatically throws when dividing by 0&#13;
        uint c = a / b;&#13;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold&#13;
        return c;&#13;
    }&#13;
&#13;
    /**&#13;
    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).&#13;
    */&#13;
    function sub(uint a, uint b) internal pure returns (uint) {&#13;
        assert(b &lt;= a);&#13;
        return a - b;&#13;
    }&#13;
&#13;
    /**&#13;
    * @dev Adds two numbers, throws on overflow.&#13;
    */&#13;
    function add(uint a, uint b) internal pure returns (uint) {&#13;
        uint c = a + b;&#13;
        assert(c &gt;= a);&#13;
        return c;&#13;
    }&#13;
}