/* This source code is part of CACIB DocChain registered trademark
*  It is provided becaused published in the public blockchain of Ethereum.
*  Reusing this code is forbidden without approbation of CACIB first (<span class="__cf_email__" data-cfemail="0d6469686c4d6e6c206e646f236e6260">[emailÂ protected]</span>)&#13;
*  Providing this code in public repository is meant to provide clarity to the mechanism by which the DocChain product works&#13;
*&#13;
*  This contract represents a repository of document hashes linked to their signatories IEthIdentity and is the heart of the DocChain product&#13;
*/&#13;
pragma solidity ^0.4.11;&#13;
&#13;
/**&#13;
 * The IEthIdentity interface defines fundamental functionnalities&#13;
 * that every Ethereum identity in this framework must implement to be &#13;
 * usable with DocChain principles.&#13;
 * &#13;
 * The purpose of implementing IEthIdentity interface is to prove its own identity&#13;
 * and let others checking whether any proof has been made by its identity.&#13;
 */&#13;
interface IEthIdentity {&#13;
    &#13;
    /**&#13;
     * Add proof if it does not exist yet&#13;
     *  - address: the smart contract address where the identity proof has been stored (see eSignature contract)&#13;
     *  - bytes32: the attribute id or proof id for which the identity owner has made a proof&#13;
     */&#13;
    function addProof(address, bytes32) public returns(bool);&#13;
    &#13;
    /**&#13;
     * Remove proof of a source if existed&#13;
     *  - address: the smart contract address where the identity proof has been stored (see eSignature contract)&#13;
     *  - bytes32: the attribute id or proof id to be removed&#13;
     */&#13;
    function removeProof(address, bytes32) public returns(bool);&#13;
&#13;
    /**&#13;
     * Check whether the provided address is the controlling wallet (owner) of the identity&#13;
     */&#13;
    function checkOwner(address) public constant returns(bool);&#13;
    &#13;
    /**&#13;
     * Get the identity owner name&#13;
     */&#13;
    function getIdentityName() public constant returns(bytes32);&#13;
    &#13;
}&#13;
&#13;
&#13;
contract eSignature {&#13;
    &#13;
    /**&#13;
     * The document structure is composed of:&#13;
     * - A hash representing the document&#13;
     * - Address of the issuer IEthIdentity who initally creates the document&#13;
     * - A mapping list of all signing IEthIdentity that approve the document&#13;
     */&#13;
    struct DocStruct {&#13;
        bytes32 hash;&#13;
        IEthIdentity issuerIdentity;&#13;
&#13;
        uint nbSignatories;                             // counter of signatories&#13;
        mapping(address =&gt; bool) signatoryAddresses;    // mapping to know if an address is a signatory&#13;
        mapping(uint =&gt; IEthIdentity) signatories;      // mapping to get a signatory by position&#13;
    }&#13;
&#13;
    /**&#13;
     * The eSignature contract contains two data points:&#13;
     * - A mapping list of documents existing in eSignature contract&#13;
     * - A counter to keep track the number of existing documents in the list&#13;
     */&#13;
    uint public count;&#13;
    mapping(bytes20 =&gt; DocStruct) docs;&#13;
    &#13;
    /**&#13;
     * This event is used for notifying new document created&#13;
     * - key: document id generated by eSignature contract&#13;
     */&#13;
    event DocCreated(bytes20 key);&#13;
    &#13;
    /**&#13;
     * This event is used for notifying a new approval of a document&#13;
     * - key: document id generated by eSignature contract&#13;
     * - identity: address of signing IEthIdentity&#13;
     */&#13;
    event DocSigned(bytes20 key, IEthIdentity identity);&#13;
    &#13;
    /**&#13;
     * Create new document that is represented by its hash&#13;
     * Return the id of created document&#13;
     * - hash: hash string of the document content&#13;
     * - issuerId: address of EthIdentiy of issuer&#13;
     */&#13;
    function newDoc(bytes32 hash, IEthIdentity issuerId) public returns (bytes20 docKey) {&#13;
        &#13;
        /* Warning: Potential Violation of Checks-Effects-Interaction pattern &#13;
            If the issuerId is 0x00 or a fake address it will fail&#13;
            If the caller passes its own implementation of IEthIdentity to attempt re-entrant code &#13;
                it will call itself recursively first consuming all its gas and not altering the smart contract&#13;
            If the caller passes an identity implementation that returns true always and calls newDoc again&#13;
                two (or more) documents will be created with different docKey not altering the mechanism&#13;
        */&#13;
        // Check if valid identity via inter-contract call, limit gas used for this call&#13;
        require(issuerId.checkOwner.gas(800)(msg.sender)); &#13;
        &#13;
        // Generate the document Id and save to mapping&#13;
        count++;&#13;
        docKey = ripemd160(issuerId, count);&#13;
        &#13;
        // Additional check that docKey not exists to avoid overriding&#13;
        assert(checkExists(docKey) == false);&#13;
        &#13;
        docs[docKey].issuerIdentity = issuerId;&#13;
        docs[docKey].hash = hash;&#13;
        // docs[docKey].nbSignatories is by construction initialized to zero.&#13;
        &#13;
        DocCreated(docKey);&#13;
    }&#13;
    &#13;
    /**&#13;
     * Create and sign a new document that is represented by its hash&#13;
     * Return the id of created signed document&#13;
     * - hash: unique hash string of the document content&#13;
     * - ethIdentity: address of EthIdentiy of signer that allow to verify the signer's authenticity&#13;
     */&#13;
    function newSignedDoc(bytes32 hash, IEthIdentity ethIdentity) public returns (bytes20 docKey) {&#13;
        // Create &amp; sign a new document&#13;
        docKey = newDoc(hash, ethIdentity);&#13;
        &#13;
        // Verify document &amp; check if it is already signed by the current ethIdentity&#13;
        require(docs[docKey].signatoryAddresses[ethIdentity] == false); // Prevent re-signing document by the same signer&#13;
        &#13;
        docs[docKey].signatoryAddresses[ethIdentity] = true;&#13;
        docs[docKey].signatories[docs[docKey].nbSignatories] = ethIdentity;&#13;
        docs[docKey].nbSignatories++;&#13;
        &#13;
        DocSigned(docKey, ethIdentity);&#13;
    }&#13;
    &#13;
    /**&#13;
     * Sign an existing document with a valid IEthIdentity of signer&#13;
     * - key: unique id of the created document&#13;
     * - ethIdentity: address of EthIdentiy of signer that allow to verify the signer's authenticity&#13;
     */&#13;
    function signDoc(bytes20 docKey, IEthIdentity ethIdentity) public {&#13;
        &#13;
        /* Warning: Potential Violation of Checks-Effects-Interaction pattern &#13;
            If the issuerId is 0x00 or a fake address it will fail&#13;
            If the caller passes its own implementation of IEthIdentity to attempt re-entrant code &#13;
                it will call itself recursively first consuming all its gas and not altering the smart contract&#13;
            If the caller passes an identity implementation that returns true always and calls signDoc again&#13;
                the second check will prevent corrupting the logic&#13;
        */&#13;
        // Check if valid identity via inter-contract call, limit gas used for this call&#13;
        require(ethIdentity.checkOwner.gas(800)(msg.sender)); &#13;
&#13;
        // Verify document &amp; check if it is already signed by the current ethIdentity&#13;
        require(docs[docKey].signatoryAddresses[ethIdentity] == false); // Prevent re-signing document by the same signer&#13;
        &#13;
        docs[docKey].signatoryAddresses[ethIdentity] = true;&#13;
        docs[docKey].signatories[docs[docKey].nbSignatories] = ethIdentity;&#13;
        docs[docKey].nbSignatories++;&#13;
        &#13;
        DocSigned(docKey, ethIdentity);&#13;
    }&#13;
    &#13;
    /**&#13;
     * Get the document information by its id key. &#13;
     * Return a tuple containing the document's hash, its issuers and number of signatories&#13;
     * - key: a unique id of the created document&#13;
     */&#13;
    function getDoc(bytes20 docKey) public constant returns (bytes32 hash, IEthIdentity issuer, uint nbSignatories) {&#13;
        &#13;
        // Check if document exists by its key&#13;
        if (checkExists(docKey)) &#13;
            return (docs[docKey].hash, docs[docKey].issuerIdentity, docs[docKey].nbSignatories);&#13;
        else  // returns a tupple saying the key is not valid&#13;
            return ("No a valid key", IEthIdentity(0x0), 0);&#13;
    }&#13;
    &#13;
    /**&#13;
     * Get the specific signatory of a given document by its id key&#13;
     * Return a tuple containing the EthIdentity address and name of signatory&#13;
     * - key: a unique key representing the created document&#13;
     * - index: index of the signatory to get its information&#13;
     */&#13;
    function getSignatory(bytes20 docKey, uint index) public constant returns (IEthIdentity identity, string identityName) {&#13;
&#13;
        // Check if document exists by its key&#13;
        if (checkExists(docKey)) {&#13;
        &#13;
            // Check index is not outbound&#13;
            require(index &lt; docs[docKey].nbSignatories);&#13;
            &#13;
            identity = docs[docKey].signatories[index];&#13;
            // Get the signatory information from its identity contract&#13;
            identityName = bytes32ToString(identity.getIdentityName());&#13;
                    &#13;
            return (identity, identityName); &#13;
        } else {&#13;
            return (IEthIdentity(0x0), "");&#13;
        }    &#13;
    }&#13;
    &#13;
    /**&#13;
     * Check if a document exists by its key&#13;
     * Return true/false indicating the document existance&#13;
     * - key: a unique key representing the created document&#13;
     */&#13;
    function checkExists(bytes20 docKey) public constant returns(bool) {&#13;
        // Document exists only if its issuer is valid&#13;
        return docs[docKey].issuerIdentity != address(0x0);&#13;
    }&#13;
    &#13;
    /**&#13;
     * Convert bytes32 to string. Set modifier pure which means cannot&#13;
     * access the contract storage.&#13;
     */&#13;
    function bytes32ToString (bytes32 data) internal pure returns (string) {&#13;
        bytes memory bytesString = new bytes(32);&#13;
        for (uint j=0; j&lt;32; j++){&#13;
            if (data[j] != 0) {&#13;
                bytesString[j] = data[j];&#13;
            }&#13;
        }&#13;
        return string(bytesString);&#13;
    }&#13;
}