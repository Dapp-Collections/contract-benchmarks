pragma solidity 0.4.24;
/**
* @title TECH ICO Contract
* @dev TECH is an ERC-20 Standar Compliant Token
* Contact: <span class="__cf_email__" data-cfemail="fdaa928f96be959c9493be989389988f8ebd9a909c9491d39e9290">[emailÂ protected]</span>  www.WorkChainCenters.io&#13;
*/&#13;
&#13;
/**&#13;
 * @title SafeMath by OpenZeppelin&#13;
 * @dev Math operations with safety checks that throw on error&#13;
 */&#13;
library SafeMath {&#13;
&#13;
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
        uint256 c = a * b;&#13;
        assert(a == 0 || c / a == b);&#13;
        return c;&#13;
    }&#13;
&#13;
    function div(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
        uint256 c = a / b;&#13;
        return c;&#13;
    }&#13;
&#13;
    function add(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
        uint256 c = a + b;&#13;
        assert(c &gt;= a);&#13;
        return c;&#13;
    }&#13;
&#13;
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
        assert(b &lt;= a);&#13;
        return a - b;&#13;
    }&#13;
&#13;
}&#13;
&#13;
&#13;
/**&#13;
 * @title ERC20Basic&#13;
 * @dev Simpler version of ERC20 interface&#13;
 * @dev see https://github.com/ethereum/EIPs/issues/179&#13;
 */&#13;
contract ERC20Basic {&#13;
    function totalSupply() public view returns (uint256);&#13;
    function balanceOf(address who) public view returns (uint256);&#13;
    function transfer(address to, uint256 value) public returns (bool);&#13;
    function transferFrom(address from, address to, uint256 value) public returns (bool);&#13;
    event Transfer(address indexed from, address indexed to, uint256 value);&#13;
}&#13;
&#13;
/**&#13;
 * @title admined&#13;
 * @notice This contract is administered&#13;
 */&#13;
contract admined {&#13;
    //mapping to user levels&#13;
    mapping(address =&gt; uint8) public level;&#13;
    //0 normal user&#13;
    //1 basic admin&#13;
    //2 master admin&#13;
&#13;
    /**&#13;
    * @dev This contructor takes the msg.sender as the first master admin&#13;
    */&#13;
    constructor() internal {&#13;
        level[msg.sender] = 2; //Set initial admin to contract creator&#13;
        emit AdminshipUpdated(msg.sender,2); //Log the admin set&#13;
    }&#13;
&#13;
    /**&#13;
    * @dev This modifier limits function execution to the admin&#13;
    */&#13;
    modifier onlyAdmin(uint8 _level) { //A modifier to define admin-only functions&#13;
        require(level[msg.sender] &gt;= _level ); //It require the user level to be more or equal than _level&#13;
        _;&#13;
    }&#13;
&#13;
    /**&#13;
    * @notice This function transfer the adminship of the contract to _newAdmin&#13;
    * @param _newAdmin The new admin of the contract&#13;
    */&#13;
    function adminshipLevel(address _newAdmin, uint8 _level) onlyAdmin(2) public { //Admin can be set&#13;
        require(_newAdmin != address(0)); //The new admin must not be zero address&#13;
        level[_newAdmin] = _level; //New level is set&#13;
        emit AdminshipUpdated(_newAdmin,_level); //Log the admin set&#13;
    }&#13;
&#13;
    /**&#13;
    * @dev Log Events&#13;
    */&#13;
    event AdminshipUpdated(address _newAdmin, uint8 _level);&#13;
&#13;
}&#13;
&#13;
contract TECHICO is admined {&#13;
&#13;
    using SafeMath for uint256;&#13;
    //This ico have these possible states&#13;
    enum State {&#13;
        MainSale,&#13;
        Paused,&#13;
        Successful&#13;
    }&#13;
    //Public variables&#13;
&#13;
    //Time-state Related&#13;
    State public state = State.MainSale; //Set initial stage&#13;
    uint256 constant public SaleStart = 1527879600; //Human time (GMT): Friday, 1 de June de 2018 19:00:00&#13;
    uint256 public SaleDeadline = 1535569200; //Human time (GMT): Wednesday, 29 August 2018 19:00:00&#13;
    uint256 public completedAt; //Set when ico finish&#13;
    //Token-eth related&#13;
    uint256 public totalRaised; //eth collected in wei&#13;
    uint256 public totalDistributed; //Whole sale tokens distributed&#13;
    ERC20Basic public tokenReward; //Token contract address&#13;
    uint256 public hardCap = 31200000 * (10 ** 18); // 31.200.000 tokens&#13;
    mapping(address =&gt; uint256) public pending; //tokens pending to being transfered&#13;
    //Contract details&#13;
    address public creator; //Creator address&#13;
    string public version = '2'; //Contract version&#13;
    //Bonus Related - How much tokens per bonus&#13;
    uint256 bonus1Remain = 1440000*10**18; //+20%&#13;
    uint256 bonus2Remain = 2380000*10**18; //+15%&#13;
    uint256 bonus3Remain = 3420000*10**18; //+10%&#13;
    uint256 bonus4Remain = 5225000*10**18; //+5%&#13;
&#13;
    uint256 remainingActualState;&#13;
    State laststate;&#13;
&#13;
    //User rights handlers&#13;
    mapping (address =&gt; bool) public whiteList; //List of allowed to send eth&#13;
&#13;
    //Price related&#13;
    uint256 rate = 3000; //3000 tokens per ether unit&#13;
&#13;
    //events for log&#13;
    event LogFundrisingInitialized(address _creator);&#13;
    event LogFundingReceived(address _addr, uint _amount, uint _currentTotal);&#13;
    event LogBeneficiaryPaid(address _beneficiaryAddress);&#13;
    event LogContributorsPayout(address _addr, uint _amount);&#13;
    event LogFundingSuccessful(uint _totalRaised);&#13;
    event LogSalePaused(bool _paused);&#13;
&#13;
    //Modifier to prevent execution if ico has ended or is holded&#13;
    modifier notFinished() {&#13;
        require(state != State.Successful &amp;&amp; state != State.Paused);&#13;
        _;&#13;
    }&#13;
&#13;
    /**&#13;
    * @notice ICO constructor&#13;
    * @param _addressOfTokenUsedAsReward is the token to distribute&#13;
    */&#13;
    constructor(ERC20Basic _addressOfTokenUsedAsReward ) public {&#13;
&#13;
        creator = msg.sender; //Creator is set from deployer address&#13;
        tokenReward = _addressOfTokenUsedAsReward; //Token address is set during deployment&#13;
        emit LogFundrisingInitialized(creator); //Log contract initialization&#13;
&#13;
        //PreSale tokens already sold = 4.720.047 tokens&#13;
        pending[0x8eBBcb4c4177941428E9E9E68C4914fb5A89650E] = 4720047000000000000002000;&#13;
        //To no exceed total tokens to sell, update numbers - bonuses not affected&#13;
        totalDistributed = 4720047000000000000002000;&#13;
&#13;
    }&#13;
&#13;
    /**&#13;
    * @notice Check remaining and cost function&#13;
    * @dev The cost function doesn't include the bonuses calculation&#13;
    */&#13;
    function remainingTokensAndCost() public view returns (uint256[2]){&#13;
        uint256 remaining = hardCap.sub(totalDistributed);&#13;
        uint256 cost = remaining.sub((bonus1Remain.mul(2)).div(10));&#13;
        cost = cost.sub((bonus2Remain.mul(15)).div(100));&#13;
        cost = cost.sub(bonus3Remain.div(10));&#13;
        cost = cost.sub((bonus4Remain.mul(5)).div(100));&#13;
        cost = cost.div(3000);&#13;
        return [remaining,cost];&#13;
    }&#13;
&#13;
    /**&#13;
    * @notice Whitelist function&#13;
    * @param _user User address to be modified on list&#13;
    * @param _flag Whitelist status to set&#13;
    */&#13;
    function whitelistAddress(address _user, bool _flag) public onlyAdmin(1) {&#13;
        whiteList[_user] = _flag; //Assign status to user on whitelist&#13;
    }&#13;
&#13;
&#13;
    /**&#13;
    * @notice Pause function&#13;
    * @param _flag Pause status to set&#13;
    */&#13;
    function pauseSale(bool _flag) onlyAdmin(2) public {&#13;
        require(state != State.Successful);&#13;
&#13;
        if(_flag == true){&#13;
            require(state != State.Paused);&#13;
            laststate = state;&#13;
            remainingActualState = SaleDeadline.sub(now);&#13;
            state = State.Paused;&#13;
            emit LogSalePaused(true);&#13;
        } else {&#13;
            require(state == State.Paused);&#13;
            state = laststate;&#13;
            SaleDeadline = now.add(remainingActualState);&#13;
            emit LogSalePaused(false);&#13;
        }&#13;
    }&#13;
&#13;
    /**&#13;
    * @notice contribution handler&#13;
    */&#13;
    function contribute(address _target) public notFinished payable {&#13;
        require(now &gt; SaleStart); //This time must be equal or greater than the start time&#13;
&#13;
        //To handle admin guided contributions&#13;
        address user;&#13;
        //Let's if user is an admin and is givin a valid target&#13;
        if(_target != address(0) &amp;&amp; level[msg.sender] &gt;= 1){&#13;
          user = _target;&#13;
        } else {&#13;
          user = msg.sender; //If not the user is the sender&#13;
        }&#13;
&#13;
        require(whiteList[user] == true); //User must be whitelisted&#13;
&#13;
        totalRaised = totalRaised.add(msg.value); //ether received updated&#13;
&#13;
        uint256 tokenBought = msg.value.mul(rate); //base tokens amount calculation&#13;
&#13;
        //Bonus calc helpers&#13;
        uint256 bonus = 0; //How much bonus for this sale&#13;
        uint256 buyHelper = tokenBought; //Base tokens bought&#13;
&#13;
        //Bonus Stage 1&#13;
        if(bonus1Remain &gt; 0){ //If there still are some tokens with bonus&#13;
&#13;
          //Lets check if tokens bought are less or more than remaining available&#13;
          //tokens whit bonus&#13;
          if(buyHelper &lt;= bonus1Remain){ //If purchase is less&#13;
              bonus1Remain = bonus1Remain.sub(buyHelper); //Sub from remaining&#13;
              //Calculate the bonus for the total bought amount&#13;
              bonus = bonus.add((buyHelper.mul(2)).div(10));//+20%&#13;
              buyHelper = 0; //Clear buy helper&#13;
          }else{ //If purchase is more&#13;
              buyHelper = buyHelper.sub(bonus1Remain); //Sub from purchase helper the remaining&#13;
              //Calculate bonus for the remaining bonus tokens&#13;
              bonus = bonus.add((bonus1Remain.mul(2)).div(10));//+20%&#13;
              bonus1Remain = 0; //Clear bonus remaining tokens&#13;
          }&#13;
&#13;
        }&#13;
&#13;
        //Lets check if tokens bought are less or more than remaining available&#13;
        //tokens whit bonus&#13;
        if(bonus2Remain &gt; 0 &amp;&amp; buyHelper &gt; 0){&#13;
&#13;
          if(buyHelper &lt;= bonus2Remain){ //If purchase is less&#13;
              bonus2Remain = bonus2Remain.sub(buyHelper);//Sub from remaining&#13;
              //Calculate the bonus for the total bought amount&#13;
              bonus = bonus.add((buyHelper.mul(15)).div(100));//+15%&#13;
              buyHelper = 0; //Clear buy helper&#13;
          }else{ //If purchase is more&#13;
              buyHelper = buyHelper.sub(bonus2Remain);//Sub from purchase helper the remaining&#13;
              //Calculate bonus for the remaining bonus tokens&#13;
              bonus = bonus.add((bonus2Remain.mul(15)).div(100));//+15%&#13;
              bonus2Remain = 0; //Clear bonus remaining tokens&#13;
          }&#13;
&#13;
        }&#13;
&#13;
        //Lets check if tokens bought are less or more than remaining available&#13;
        //tokens whit bonus&#13;
        if(bonus3Remain &gt; 0 &amp;&amp; buyHelper &gt; 0){&#13;
&#13;
          if(buyHelper &lt;= bonus3Remain){ //If purchase is less&#13;
              bonus3Remain = bonus3Remain.sub(buyHelper);//Sub from remaining&#13;
              //Calculate the bonus for the total bought amount&#13;
              bonus = bonus.add(buyHelper.div(10));//+10%&#13;
              buyHelper = 0; //Clear buy helper&#13;
          }else{ //If purchase is more&#13;
              buyHelper = buyHelper.sub(bonus3Remain);//Sub from purchase helper the remaining&#13;
              //Calculate bonus for the remaining bonus tokens&#13;
              bonus = bonus.add(bonus3Remain.div(10));//+10%&#13;
              bonus3Remain = 0; //Clear bonus remaining tokens&#13;
          }&#13;
&#13;
        }&#13;
&#13;
        //Lets check if tokens bought are less or more than remaining available&#13;
        //tokens whit bonus&#13;
        if(bonus4Remain &gt; 0 &amp;&amp; buyHelper &gt; 0){&#13;
&#13;
          if(buyHelper &lt;= bonus4Remain){ //If purchase is less&#13;
              bonus4Remain = bonus4Remain.sub(buyHelper);//Sub from remaining&#13;
              //Calculate the bonus for the total bought amount&#13;
              bonus = bonus.add((buyHelper.mul(5)).div(100));//+5%&#13;
              buyHelper = 0; //Clear buy helper&#13;
          }else{ //If purchase is more&#13;
              buyHelper = buyHelper.sub(bonus4Remain);//Sub from purchase helper the remaining&#13;
              //Calculate bonus for the remaining bonus tokens&#13;
              bonus = bonus.add((bonus4Remain.mul(5)).div(100));//+5%&#13;
              bonus4Remain = 0; //Clear bonus remaining tokens&#13;
          }&#13;
&#13;
        }&#13;
&#13;
        tokenBought = tokenBought.add(bonus); //Sum Up Bonus(es) to base purchase&#13;
&#13;
        require(totalDistributed.add(tokenBought) &lt;= hardCap); //The total amount after sum up must not be more than the hardCap&#13;
&#13;
        pending[user] = pending[user].add(tokenBought); //Pending balance to distribute is updated&#13;
        totalDistributed = totalDistributed.add(tokenBought); //Whole tokens sold updated&#13;
&#13;
        emit LogFundingReceived(user, msg.value, totalRaised); //Log the purchase&#13;
&#13;
        checkIfFundingCompleteOrExpired(); //Execute state checks&#13;
    }&#13;
&#13;
    /**&#13;
    * @notice Funtion to let users claim their tokens at the end of ico process&#13;
    */&#13;
    function claimTokensByUser() public{&#13;
        require(state == State.Successful); //Once ico is successful&#13;
        uint256 temp = pending[msg.sender]; //Get the user pending balance&#13;
        pending[msg.sender] = 0; //Clear it&#13;
        require(tokenReward.transfer(msg.sender,temp)); //Try to transfer&#13;
        emit LogContributorsPayout(msg.sender,temp); //Log the claim&#13;
    }&#13;
&#13;
    /**&#13;
    * @notice Funtion to let admins claim users tokens on behalf of them at the end of ico process&#13;
    * @param _user Target user of token claim&#13;
    */&#13;
    function claimTokensByAdmin(address _user) onlyAdmin(1) public{&#13;
        require(state == State.Successful); //Once ico is successful&#13;
        uint256 temp = pending[_user]; //Get the user pending balance&#13;
        pending[_user] = 0; //Clear it&#13;
        require(tokenReward.transfer(_user,temp)); //Try to transfer&#13;
        emit LogContributorsPayout(_user,temp); //Log the claim&#13;
    }&#13;
&#13;
    /**&#13;
    * @notice Process to check contract current status&#13;
    */&#13;
    function checkIfFundingCompleteOrExpired() public {&#13;
         //If hardacap or deadline is reached and not yet successful&#13;
        if ( (totalDistributed == hardCap || now &gt; SaleDeadline)&#13;
            &amp;&amp; state != State.Successful &#13;
            &amp;&amp; state != State.Paused) {&#13;
            //remanent tokens are assigned to creator for later handle&#13;
            pending[creator] = tokenReward.balanceOf(address(this)).sub(totalDistributed);&#13;
&#13;
            state = State.Successful; //ICO becomes Successful&#13;
            completedAt = now; //ICO is complete&#13;
&#13;
            emit LogFundingSuccessful(totalRaised); //we log the finish&#13;
            successful(); //and execute closure&#13;
&#13;
        }&#13;
    }&#13;
&#13;
    /**&#13;
    * @notice successful closure handler&#13;
    */&#13;
    function successful() public {&#13;
        require(state == State.Successful); //When successful&#13;
        uint256 temp = pending[creator]; //Remanent tokens handle&#13;
        pending[creator] = 0; //Clear user balance&#13;
        require(tokenReward.transfer(creator,temp)); //Try to transfer&#13;
&#13;
        emit LogContributorsPayout(creator,temp); //Log transaction&#13;
&#13;
        creator.transfer(address(this).balance); //After successful, eth is send to creator&#13;
&#13;
        emit LogBeneficiaryPaid(creator); //Log transaction&#13;
&#13;
    }&#13;
&#13;
    /**&#13;
    * @notice Function to claim any token stuck on contract&#13;
    * @param _address Address of target token&#13;
    */&#13;
    function externalTokensRecovery(ERC20Basic _address) onlyAdmin(2) public{&#13;
        require(state == State.Successful); //Only when sale finish&#13;
        require(_address != address(tokenReward)); //Target token must be different from token on sale&#13;
&#13;
        uint256 remainder = _address.balanceOf(this); //Check remainder tokens&#13;
        _address.transfer(msg.sender,remainder); //Transfer tokens to admin&#13;
&#13;
    }&#13;
&#13;
    /*&#13;
    * @dev Direct payments handler&#13;
    */&#13;
    function () public payable {&#13;
&#13;
        contribute(address(0)); //Forward to contribute function&#13;
&#13;
    }&#13;
}