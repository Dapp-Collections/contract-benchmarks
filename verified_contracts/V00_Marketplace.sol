pragma solidity ^0.4.24;
// produced by the Solididy File Flattener (c) David Appleton 2018
// contact : <span class="__cf_email__" data-cfemail="99fdf8effcd9f8f2f6f4fbf8b7faf6f4">[emailÂ protected]</span>&#13;
// released under Apache 2.0 licence&#13;
contract Ownable {&#13;
  address public owner;&#13;
&#13;
&#13;
  event OwnershipRenounced(address indexed previousOwner);&#13;
  event OwnershipTransferred(&#13;
    address indexed previousOwner,&#13;
    address indexed newOwner&#13;
  );&#13;
&#13;
&#13;
  /**&#13;
   * @dev The Ownable constructor sets the original `owner` of the contract to the sender&#13;
   * account.&#13;
   */&#13;
  constructor() public {&#13;
    owner = msg.sender;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Throws if called by any account other than the owner.&#13;
   */&#13;
  modifier onlyOwner() {&#13;
    require(msg.sender == owner);&#13;
    _;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Allows the current owner to relinquish control of the contract.&#13;
   */&#13;
  function renounceOwnership() public onlyOwner {&#13;
    emit OwnershipRenounced(owner);&#13;
    owner = address(0);&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Allows the current owner to transfer control of the contract to a newOwner.&#13;
   * @param _newOwner The address to transfer ownership to.&#13;
   */&#13;
  function transferOwnership(address _newOwner) public onlyOwner {&#13;
    _transferOwnership(_newOwner);&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Transfers control of the contract to a newOwner.&#13;
   * @param _newOwner The address to transfer ownership to.&#13;
   */&#13;
  function _transferOwnership(address _newOwner) internal {&#13;
    require(_newOwner != address(0));&#13;
    emit OwnershipTransferred(owner, _newOwner);&#13;
    owner = _newOwner;&#13;
  }&#13;
}&#13;
&#13;
contract ERC20 {&#13;
    function transfer(address _to, uint256 _value) external returns (bool);&#13;
    function transferFrom(address _from, address _to, uint256 _value) external returns (bool);&#13;
}&#13;
&#13;
&#13;
contract V00_Marketplace is Ownable {&#13;
&#13;
    /**&#13;
    * @notice All events have the same indexed signature offsets for easy filtering&#13;
    */&#13;
    event MarketplaceData  (address indexed party, bytes32 ipfsHash);&#13;
    event AffiliateAdded   (address indexed party, bytes32 ipfsHash);&#13;
    event AffiliateRemoved (address indexed party, bytes32 ipfsHash);&#13;
    event ListingCreated   (address indexed party, uint indexed listingID, bytes32 ipfsHash);&#13;
    event ListingUpdated   (address indexed party, uint indexed listingID, bytes32 ipfsHash);&#13;
    event ListingWithdrawn (address indexed party, uint indexed listingID, bytes32 ipfsHash);&#13;
    event ListingArbitrated(address indexed party, uint indexed listingID, bytes32 ipfsHash);&#13;
    event ListingData      (address indexed party, uint indexed listingID, bytes32 ipfsHash);&#13;
    event OfferCreated     (address indexed party, uint indexed listingID, uint indexed offerID, bytes32 ipfsHash);&#13;
    event OfferAccepted    (address indexed party, uint indexed listingID, uint indexed offerID, bytes32 ipfsHash);&#13;
    event OfferFinalized   (address indexed party, uint indexed listingID, uint indexed offerID, bytes32 ipfsHash);&#13;
    event OfferWithdrawn   (address indexed party, uint indexed listingID, uint indexed offerID, bytes32 ipfsHash);&#13;
    event OfferFundsAdded  (address indexed party, uint indexed listingID, uint indexed offerID, bytes32 ipfsHash);&#13;
    event OfferDisputed    (address indexed party, uint indexed listingID, uint indexed offerID, bytes32 ipfsHash);&#13;
    event OfferRuling      (address indexed party, uint indexed listingID, uint indexed offerID, bytes32 ipfsHash, uint ruling);&#13;
    event OfferData        (address indexed party, uint indexed listingID, uint indexed offerID, bytes32 ipfsHash);&#13;
&#13;
    struct Listing {&#13;
        address seller;     // Seller wallet / identity contract / other contract&#13;
        uint deposit;       // Deposit in Origin Token&#13;
        address depositManager; // Address that decides token distribution&#13;
    }&#13;
&#13;
    struct Offer {&#13;
        uint value;         // Amount in Eth or ERC20 buyer is offering&#13;
        uint commission;    // Amount of commission earned if offer is finalized&#13;
        uint refund;        // Amount to refund buyer upon finalization&#13;
        ERC20 currency;     // Currency of listing&#13;
        address buyer;      // Buyer wallet / identity contract / other contract&#13;
        address affiliate;  // Address to send any commission&#13;
        address arbitrator; // Address that settles disputes&#13;
        uint finalizes;     // Timestamp offer finalizes&#13;
        uint8 status;       // 0: Undefined, 1: Created, 2: Accepted, 3: Disputed&#13;
    }&#13;
&#13;
    Listing[] public listings;&#13;
    mapping(uint =&gt; Offer[]) public offers; // listingID =&gt; Offers&#13;
    mapping(address =&gt; bool) public allowedAffiliates;&#13;
&#13;
    ERC20 public tokenAddr; // Origin Token address&#13;
&#13;
    constructor(address _tokenAddr) public {&#13;
        owner = msg.sender;&#13;
        setTokenAddr(_tokenAddr); // Origin Token contract&#13;
        allowedAffiliates[0x0] = true; // Allow null affiliate by default&#13;
    }&#13;
&#13;
    // @dev Return the total number of listings&#13;
    function totalListings() public view returns (uint) {&#13;
        return listings.length;&#13;
    }&#13;
&#13;
    // @dev Return the total number of offers&#13;
    function totalOffers(uint listingID) public view returns (uint) {&#13;
        return offers[listingID].length;&#13;
    }&#13;
&#13;
    // @dev Seller creates listing&#13;
    function createListing(bytes32 _ipfsHash, uint _deposit, address _depositManager)&#13;
        public&#13;
    {&#13;
        _createListing(msg.sender, _ipfsHash, _deposit, _depositManager);&#13;
    }&#13;
&#13;
    // @dev Can only be called by token&#13;
    function createListingWithSender(&#13;
        address _seller,&#13;
        bytes32 _ipfsHash,&#13;
        uint _deposit,&#13;
        address _depositManager&#13;
    )&#13;
        public returns (bool)&#13;
    {&#13;
        require(msg.sender == address(tokenAddr), "Token must call");&#13;
        _createListing(_seller, _ipfsHash, _deposit, _depositManager);&#13;
        return true;&#13;
    }&#13;
&#13;
    // Private&#13;
    function _createListing(&#13;
        address _seller,&#13;
        bytes32 _ipfsHash,  // IPFS JSON with details, pricing, availability&#13;
        uint _deposit,      // Deposit in Origin Token&#13;
        address _depositManager // Address of listing depositManager&#13;
    )&#13;
        private&#13;
    {&#13;
        /* require(_deposit &gt; 0); // Listings must deposit some amount of Origin Token */&#13;
        require(_depositManager != 0x0, "Must specify depositManager");&#13;
&#13;
        listings.push(Listing({&#13;
            seller: _seller,&#13;
            deposit: _deposit,&#13;
            depositManager: _depositManager&#13;
        }));&#13;
&#13;
        if (_deposit &gt; 0) {&#13;
            tokenAddr.transferFrom(_seller, this, _deposit); // Transfer Origin Token&#13;
        }&#13;
        emit ListingCreated(_seller, listings.length - 1, _ipfsHash);&#13;
    }&#13;
&#13;
    // @dev Seller updates listing&#13;
    function updateListing(&#13;
        uint listingID,&#13;
        bytes32 _ipfsHash,&#13;
        uint _additionalDeposit&#13;
    ) public {&#13;
        _updateListing(msg.sender, listingID, _ipfsHash, _additionalDeposit);&#13;
    }&#13;
&#13;
    function updateListingWithSender(&#13;
        address _seller,&#13;
        uint listingID,&#13;
        bytes32 _ipfsHash,&#13;
        uint _additionalDeposit&#13;
    )&#13;
        public returns (bool)&#13;
    {&#13;
        require(msg.sender == address(tokenAddr), "Token must call");&#13;
        _updateListing(_seller, listingID, _ipfsHash, _additionalDeposit);&#13;
        return true;&#13;
    }&#13;
&#13;
    function _updateListing(&#13;
        address _seller,&#13;
        uint listingID,&#13;
        bytes32 _ipfsHash,      // Updated IPFS hash&#13;
        uint _additionalDeposit // Additional deposit to add&#13;
    ) private {&#13;
        Listing storage listing = listings[listingID];&#13;
        require(listing.seller == _seller, "Seller must call");&#13;
&#13;
        if (_additionalDeposit &gt; 0) {&#13;
            tokenAddr.transferFrom(_seller, this, _additionalDeposit);&#13;
            listing.deposit += _additionalDeposit;&#13;
        }&#13;
&#13;
        emit ListingUpdated(listing.seller, listingID, _ipfsHash);&#13;
    }&#13;
&#13;
    // @dev Listing depositManager withdraws listing. IPFS hash contains reason for withdrawl.&#13;
    function withdrawListing(uint listingID, address _target, bytes32 _ipfsHash) public {&#13;
        Listing storage listing = listings[listingID];&#13;
        require(msg.sender == listing.depositManager, "Must be depositManager");&#13;
        require(_target != 0x0, "No target");&#13;
        tokenAddr.transfer(_target, listing.deposit); // Send deposit to target&#13;
        emit ListingWithdrawn(_target, listingID, _ipfsHash);&#13;
    }&#13;
&#13;
    // @dev Buyer makes offer.&#13;
    function makeOffer(&#13;
        uint listingID,&#13;
        bytes32 _ipfsHash,   // IPFS hash containing offer data&#13;
        uint _finalizes,     // Timestamp an accepted offer will finalize&#13;
        address _affiliate,  // Address to send any required commission to&#13;
        uint256 _commission, // Amount of commission to send in Origin Token if offer finalizes&#13;
        uint _value,         // Offer amount in ERC20 or Eth&#13;
        ERC20 _currency,     // ERC20 token address or 0x0 for Eth&#13;
        address _arbitrator  // Escrow arbitrator&#13;
    )&#13;
        public&#13;
        payable&#13;
    {&#13;
        bool affiliateWhitelistDisabled = allowedAffiliates[address(this)];&#13;
        require(&#13;
            affiliateWhitelistDisabled || allowedAffiliates[_affiliate],&#13;
            "Affiliate not allowed"&#13;
        );&#13;
&#13;
        if (_affiliate == 0x0) {&#13;
            // Avoid commission tokens being trapped in marketplace contract.&#13;
            require(_commission == 0, "commission requires affiliate");&#13;
        }&#13;
&#13;
        offers[listingID].push(Offer({&#13;
            status: 1,&#13;
            buyer: msg.sender,&#13;
            finalizes: _finalizes,&#13;
            affiliate: _affiliate,&#13;
            commission: _commission,&#13;
            currency: _currency,&#13;
            value: _value,&#13;
            arbitrator: _arbitrator,&#13;
            refund: 0&#13;
        }));&#13;
&#13;
        if (address(_currency) == 0x0) { // Listing is in ETH&#13;
            require(msg.value == _value, "ETH value doesn't match offer");&#13;
        } else { // Listing is in ERC20&#13;
            require(msg.value == 0, "ETH would be lost");&#13;
            require(&#13;
                _currency.transferFrom(msg.sender, this, _value),&#13;
                "transferFrom failed"&#13;
            );&#13;
        }&#13;
&#13;
        emit OfferCreated(msg.sender, listingID, offers[listingID].length-1, _ipfsHash);&#13;
    }&#13;
&#13;
    // @dev Make new offer after withdrawl&#13;
    function makeOffer(&#13;
        uint listingID,&#13;
        bytes32 _ipfsHash,&#13;
        uint _finalizes,&#13;
        address _affiliate,&#13;
        uint256 _commission,&#13;
        uint _value,&#13;
        ERC20 _currency,&#13;
        address _arbitrator,&#13;
        uint _withdrawOfferID&#13;
    )&#13;
        public&#13;
        payable&#13;
    {&#13;
        withdrawOffer(listingID, _withdrawOfferID, _ipfsHash);&#13;
        makeOffer(listingID, _ipfsHash, _finalizes, _affiliate, _commission, _value, _currency, _arbitrator);&#13;
    }&#13;
&#13;
    // @dev Seller accepts offer&#13;
    function acceptOffer(uint listingID, uint offerID, bytes32 _ipfsHash) public {&#13;
        Listing storage listing = listings[listingID];&#13;
        Offer storage offer = offers[listingID][offerID];&#13;
        require(msg.sender == listing.seller, "Seller must accept");&#13;
        require(offer.status == 1, "status != created");&#13;
        require(&#13;
            listing.deposit &gt;= offer.commission,&#13;
            "deposit must cover commission"&#13;
        );&#13;
        if (offer.finalizes &lt; 1000000000) { // Relative finalization window&#13;
            offer.finalizes = now + offer.finalizes;&#13;
        }&#13;
        listing.deposit -= offer.commission; // Accepting an offer puts Origin Token into escrow&#13;
        offer.status = 2; // Set offer to 'Accepted'&#13;
        emit OfferAccepted(msg.sender, listingID, offerID, _ipfsHash);&#13;
    }&#13;
&#13;
    // @dev Buyer withdraws offer. IPFS hash contains reason for withdrawl.&#13;
    function withdrawOffer(uint listingID, uint offerID, bytes32 _ipfsHash) public {&#13;
        Listing storage listing = listings[listingID];&#13;
        Offer storage offer = offers[listingID][offerID];&#13;
        require(&#13;
            msg.sender == offer.buyer || msg.sender == listing.seller,&#13;
            "Restricted to buyer or seller"&#13;
        );&#13;
        require(offer.status == 1, "status != created");&#13;
        refundBuyer(listingID, offerID);&#13;
        emit OfferWithdrawn(msg.sender, listingID, offerID, _ipfsHash);&#13;
        delete offers[listingID][offerID];&#13;
    }&#13;
&#13;
    // @dev Buyer adds extra funds to an accepted offer.&#13;
    function addFunds(uint listingID, uint offerID, bytes32 _ipfsHash, uint _value) public payable {&#13;
        Offer storage offer = offers[listingID][offerID];&#13;
        require(msg.sender == offer.buyer, "Buyer must call");&#13;
        require(offer.status == 2, "status != accepted");&#13;
        if (address(offer.currency) == 0x0) { // Listing is in ETH&#13;
            require(&#13;
                msg.value == _value,&#13;
                "sent != offered value"&#13;
            );&#13;
        } else { // Listing is in ERC20&#13;
            require(msg.value == 0, "ETH must not be sent");&#13;
            require(&#13;
                offer.currency.transferFrom(msg.sender, this, _value),&#13;
                "transferFrom failed"&#13;
            );&#13;
        }&#13;
        offer.value += _value;&#13;
        emit OfferFundsAdded(msg.sender, listingID, offerID, _ipfsHash);&#13;
    }&#13;
&#13;
    // @dev Buyer must finalize transaction to receive commission&#13;
    function finalize(uint listingID, uint offerID, bytes32 _ipfsHash) public {&#13;
        Listing storage listing = listings[listingID];&#13;
        Offer storage offer = offers[listingID][offerID];&#13;
        if (now &lt;= offer.finalizes) { // Only buyer can finalize before finalization window&#13;
            require(&#13;
                msg.sender == offer.buyer,&#13;
                "Only buyer can finalize"&#13;
            );&#13;
        } else { // Allow both seller and buyer to finalize if finalization window has passed&#13;
            require(&#13;
                msg.sender == offer.buyer || msg.sender == listing.seller,&#13;
                "Seller or buyer must finalize"&#13;
            );&#13;
        }&#13;
        require(offer.status == 2, "status != accepted");&#13;
        paySeller(listingID, offerID); // Pay seller&#13;
        if (msg.sender == offer.buyer) { // Only pay commission if buyer is finalizing&#13;
            payCommission(listingID, offerID);&#13;
        }&#13;
        emit OfferFinalized(msg.sender, listingID, offerID, _ipfsHash);&#13;
        delete offers[listingID][offerID];&#13;
    }&#13;
&#13;
    // @dev Buyer or seller can dispute transaction during finalization window&#13;
    function dispute(uint listingID, uint offerID, bytes32 _ipfsHash) public {&#13;
        Listing storage listing = listings[listingID];&#13;
        Offer storage offer = offers[listingID][offerID];&#13;
        require(&#13;
            msg.sender == offer.buyer || msg.sender == listing.seller,&#13;
            "Must be seller or buyer"&#13;
        );&#13;
        require(offer.status == 2, "status != accepted");&#13;
        require(now &lt;= offer.finalizes, "Already finalized");&#13;
        offer.status = 3; // Set status to "Disputed"&#13;
        emit OfferDisputed(msg.sender, listingID, offerID, _ipfsHash);&#13;
    }&#13;
&#13;
    // @dev Called by arbitrator&#13;
    function executeRuling(&#13;
        uint listingID,&#13;
        uint offerID,&#13;
        bytes32 _ipfsHash,&#13;
        uint _ruling, // 0: Seller, 1: Buyer, 2: Com + Seller, 3: Com + Buyer&#13;
        uint _refund&#13;
    ) public {&#13;
        Offer storage offer = offers[listingID][offerID];&#13;
        require(msg.sender == offer.arbitrator, "Must be arbitrator");&#13;
        require(offer.status == 3, "status != disputed");&#13;
        require(_refund &lt;= offer.value, "refund too high");&#13;
        offer.refund = _refund;&#13;
        if (_ruling &amp; 1 == 1) {&#13;
            refundBuyer(listingID, offerID);&#13;
        } else  {&#13;
            paySeller(listingID, offerID);&#13;
        }&#13;
        if (_ruling &amp; 2 == 2) {&#13;
            payCommission(listingID, offerID);&#13;
        } else  { // Refund commission to seller&#13;
            listings[listingID].deposit += offer.commission;&#13;
        }&#13;
        emit OfferRuling(offer.arbitrator, listingID, offerID, _ipfsHash, _ruling);&#13;
        delete offers[listingID][offerID];&#13;
    }&#13;
&#13;
    // @dev Sets the amount that a seller wants to refund to a buyer.&#13;
    function updateRefund(uint listingID, uint offerID, uint _refund, bytes32 _ipfsHash) public {&#13;
        Offer storage offer = offers[listingID][offerID];&#13;
        Listing storage listing = listings[listingID];&#13;
        require(msg.sender == listing.seller, "Seller must call");&#13;
        require(offer.status == 2, "status != accepted");&#13;
        require(_refund &lt;= offer.value, "Excessive refund");&#13;
        offer.refund = _refund;&#13;
        emit OfferData(msg.sender, listingID, offerID, _ipfsHash);&#13;
    }&#13;
&#13;
    // @dev Refunds buyer in ETH or ERC20 - used by 1) executeRuling() and 2) to allow a seller to refund a purchase&#13;
    function refundBuyer(uint listingID, uint offerID) private {&#13;
        Offer storage offer = offers[listingID][offerID];&#13;
        if (address(offer.currency) == 0x0) {&#13;
            require(offer.buyer.send(offer.value), "ETH refund failed");&#13;
        } else {&#13;
            require(&#13;
                offer.currency.transfer(offer.buyer, offer.value),&#13;
                "Refund failed"&#13;
            );&#13;
        }&#13;
    }&#13;
&#13;
    // @dev Pay seller in ETH or ERC20&#13;
    function paySeller(uint listingID, uint offerID) private {&#13;
        Listing storage listing = listings[listingID];&#13;
        Offer storage offer = offers[listingID][offerID];&#13;
        uint value = offer.value - offer.refund;&#13;
&#13;
        if (address(offer.currency) == 0x0) {&#13;
            require(offer.buyer.send(offer.refund), "ETH refund failed");&#13;
            require(listing.seller.send(value), "ETH send failed");&#13;
        } else {&#13;
            require(&#13;
                offer.currency.transfer(offer.buyer, offer.refund),&#13;
                "Refund failed"&#13;
            );&#13;
            require(&#13;
                offer.currency.transfer(listing.seller, value),&#13;
                "Transfer failed"&#13;
            );&#13;
        }&#13;
    }&#13;
&#13;
    // @dev Pay commission to affiliate&#13;
    function payCommission(uint listingID, uint offerID) private {&#13;
        Offer storage offer = offers[listingID][offerID];&#13;
        if (offer.affiliate != 0x0) {&#13;
            require(&#13;
                tokenAddr.transfer(offer.affiliate, offer.commission),&#13;
                "Commission transfer failed"&#13;
            );&#13;
        }&#13;
    }&#13;
&#13;
    // @dev Associate ipfs data with the marketplace&#13;
    function addData(bytes32 ipfsHash) public {&#13;
        emit MarketplaceData(msg.sender, ipfsHash);&#13;
    }&#13;
&#13;
    // @dev Associate ipfs data with a listing&#13;
    function addData(uint listingID, bytes32 ipfsHash) public {&#13;
        emit ListingData(msg.sender, listingID, ipfsHash);&#13;
    }&#13;
&#13;
    // @dev Associate ipfs data with an offer&#13;
    function addData(uint listingID, uint offerID, bytes32 ipfsHash) public {&#13;
        emit OfferData(msg.sender, listingID, offerID, ipfsHash);&#13;
    }&#13;
&#13;
    // @dev Allow listing depositManager to send deposit&#13;
    function sendDeposit(uint listingID, address target, uint value, bytes32 ipfsHash) public {&#13;
        Listing storage listing = listings[listingID];&#13;
        require(listing.depositManager == msg.sender, "depositManager must call");&#13;
        require(listing.deposit &gt;= value, "Value too high");&#13;
        listing.deposit -= value;&#13;
        require(tokenAddr.transfer(target, value), "Transfer failed");&#13;
        emit ListingArbitrated(target, listingID, ipfsHash);&#13;
    }&#13;
&#13;
    // @dev Set the address of the Origin token contract&#13;
    function setTokenAddr(address _tokenAddr) public onlyOwner {&#13;
        tokenAddr = ERC20(_tokenAddr);&#13;
    }&#13;
&#13;
    // @dev Add affiliate to whitelist. Set to address(this) to disable.&#13;
    function addAffiliate(address _affiliate, bytes32 ipfsHash) public onlyOwner {&#13;
        allowedAffiliates[_affiliate] = true;&#13;
        emit AffiliateAdded(_affiliate, ipfsHash);&#13;
    }&#13;
&#13;
    // @dev Remove affiliate from whitelist.&#13;
    function removeAffiliate(address _affiliate, bytes32 ipfsHash) public onlyOwner {&#13;
        delete allowedAffiliates[_affiliate];&#13;
        emit AffiliateRemoved(_affiliate, ipfsHash);&#13;
    }&#13;
}