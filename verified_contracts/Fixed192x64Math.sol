pragma solidity ^0.4.24;


/// @title Fixed192x64Math library - Allows calculation of logarithmic and exponential functions
/// @author Alan Lu - <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="3f5e535e5111534a7f5851504c564c114f52">[email protected]</a>&gt;&#13;
/// @author Stefan George - &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="4033342526212e00272e2f3329336e302d">[email protected]</a>&gt;&#13;
library Fixed192x64Math {&#13;
&#13;
    enum EstimationMode { LowerBound, UpperBound, Midpoint }&#13;
&#13;
    /*&#13;
     *  Constants&#13;
     */&#13;
    // This is equal to 1 in our calculations&#13;
    uint public constant ONE =  0x10000000000000000;&#13;
    uint public constant LN2 = 0xb17217f7d1cf79ac;&#13;
    uint public constant LOG2_E = 0x171547652b82fe177;&#13;
&#13;
    /*&#13;
     *  Public functions&#13;
     */&#13;
    /// @dev Returns natural exponential function value of given x&#13;
    /// @param x x&#13;
    /// @return e**x&#13;
    function exp(int x)&#13;
        public&#13;
        pure&#13;
        returns (uint)&#13;
    {&#13;
        // revert if x is &gt; MAX_POWER, where&#13;
        // MAX_POWER = int(mp.floor(mp.log(mpf(2**256 - 1) / ONE) * ONE))&#13;
        require(x &lt;= 2454971259878909886679);&#13;
        // return 0 if exp(x) is tiny, using&#13;
        // MIN_POWER = int(mp.floor(mp.log(mpf(1) / ONE) * ONE))&#13;
        if (x &lt;= -818323753292969962227)&#13;
            return 0;&#13;
&#13;
        // Transform so that e^x -&gt; 2^x&#13;
        (uint lower, uint upper) = pow2Bounds(x * int(ONE) / int(LN2));&#13;
        return (upper - lower) / 2 + lower;&#13;
    }&#13;
&#13;
    /// @dev Returns estimate of 2**x given x&#13;
    /// @param x exponent in fixed point&#13;
    /// @param estimationMode whether to return a lower bound, upper bound, or a midpoint&#13;
    /// @return estimate of 2**x in fixed point&#13;
    function pow2(int x, EstimationMode estimationMode)&#13;
        public&#13;
        pure&#13;
        returns (uint)&#13;
    {&#13;
        (uint lower, uint upper) = pow2Bounds(x);&#13;
        if(estimationMode == EstimationMode.LowerBound) {&#13;
            return lower;&#13;
        }&#13;
        if(estimationMode == EstimationMode.UpperBound) {&#13;
            return upper;&#13;
        }&#13;
        if(estimationMode == EstimationMode.Midpoint) {&#13;
            return (upper - lower) / 2 + lower;&#13;
        }&#13;
        revert();&#13;
    }&#13;
&#13;
    /// @dev Returns bounds for value of 2**x given x&#13;
    /// @param x exponent in fixed point&#13;
    /// @return {&#13;
    ///   "lower": "lower bound of 2**x in fixed point",&#13;
    ///   "upper": "upper bound of 2**x in fixed point"&#13;
    /// }&#13;
    function pow2Bounds(int x)&#13;
        public&#13;
        pure&#13;
        returns (uint lower, uint upper)&#13;
    {&#13;
        // revert if x is &gt; MAX_POWER, where&#13;
        // MAX_POWER = int(mp.floor(mp.log(mpf(2**256 - 1) / ONE, 2) * ONE))&#13;
        require(x &lt;= 3541774862152233910271);&#13;
        // return 0 if exp(x) is tiny, using&#13;
        // MIN_POWER = int(mp.floor(mp.log(mpf(1) / ONE, 2) * ONE))&#13;
        if (x &lt; -1180591620717411303424)&#13;
            return (0, 1);&#13;
&#13;
        // 2^x = 2^(floor(x)) * 2^(x-floor(x))&#13;
        //       ^^^^^^^^^^^^^^ is a bit shift of ceil(x)&#13;
        // so Taylor expand on z = x-floor(x), z in [0, 1)&#13;
        int shift;&#13;
        int z;&#13;
        if (x &gt;= 0) {&#13;
            shift = x / int(ONE);&#13;
            z = x % int(ONE);&#13;
        }&#13;
        else {&#13;
            shift = (x+1) / int(ONE) - 1;&#13;
            z = x - (int(ONE) * shift);&#13;
        }&#13;
        assert(z &gt;= 0);&#13;
        // 2^x = 1 + (ln 2) x + (ln 2)^2/2! x^2 + ...&#13;
        //&#13;
        // Can generate the z coefficients using mpmath and the following lines&#13;
        // &gt;&gt;&gt; from mpmath import mp&#13;
        // &gt;&gt;&gt; mp.dps = 100&#13;
        // &gt;&gt;&gt; coeffs = [mp.log(2)**i / mp.factorial(i) for i in range(1, 21)]&#13;
        // &gt;&gt;&gt; shifts = [64 - int(mp.log(c, 2)) for c in coeffs]&#13;
        // &gt;&gt;&gt; print('\n'.join(hex(int(c * (1 &lt;&lt; s))) + ', ' + str(s) for c, s in zip(coeffs, shifts)))&#13;
        int result = int(ONE) &lt;&lt; 64;&#13;
        int zpow = z;&#13;
        result += 0xb17217f7d1cf79ab * zpow;&#13;
        zpow = zpow * z / int(ONE);&#13;
        result += 0xf5fdeffc162c7543 * zpow &gt;&gt; (66 - 64);&#13;
        zpow = zpow * z / int(ONE);&#13;
        result += 0xe35846b82505fc59 * zpow &gt;&gt; (68 - 64);&#13;
        zpow = zpow * z / int(ONE);&#13;
        result += 0x9d955b7dd273b94e * zpow &gt;&gt; (70 - 64);&#13;
        zpow = zpow * z / int(ONE);&#13;
        result += 0xaec3ff3c53398883 * zpow &gt;&gt; (73 - 64);&#13;
        zpow = zpow * z / int(ONE);&#13;
        result += 0xa184897c363c3b7a * zpow &gt;&gt; (76 - 64);&#13;
        zpow = zpow * z / int(ONE);&#13;
        result += 0xffe5fe2c45863435 * zpow &gt;&gt; (80 - 64);&#13;
        zpow = zpow * z / int(ONE);&#13;
        result += 0xb160111d2e411fec * zpow &gt;&gt; (83 - 64);&#13;
        zpow = zpow * z / int(ONE);&#13;
        result += 0xda929e9caf3e1ed2 * zpow &gt;&gt; (87 - 64);&#13;
        zpow = zpow * z / int(ONE);&#13;
        result += 0xf267a8ac5c764fb7 * zpow &gt;&gt; (91 - 64);&#13;
        zpow = zpow * z / int(ONE);&#13;
        result += 0xf465639a8dd92607 * zpow &gt;&gt; (95 - 64);&#13;
        zpow = zpow * z / int(ONE);&#13;
        result += 0xe1deb287e14c2f15 * zpow &gt;&gt; (99 - 64);&#13;
        zpow = zpow * z / int(ONE);&#13;
        result += 0xc0b0c98b3687cb14 * zpow &gt;&gt; (103 - 64);&#13;
        zpow = zpow * z / int(ONE);&#13;
        result += 0x98a4b26ac3c54b9f * zpow &gt;&gt; (107 - 64);&#13;
        zpow = zpow * z / int(ONE);&#13;
        result += 0xe1b7421d82010f33 * zpow &gt;&gt; (112 - 64);&#13;
        zpow = zpow * z / int(ONE);&#13;
        result += 0x9c744d73cfc59c91 * zpow &gt;&gt; (116 - 64);&#13;
        zpow = zpow * z / int(ONE);&#13;
        result += 0xcc2225a0e12d3eab * zpow &gt;&gt; (121 - 64);&#13;
        zpow = zpow * z / int(ONE);&#13;
        zpow = 0xfb8bb5eda1b4aeb9 * zpow &gt;&gt; (126 - 64);&#13;
        result += zpow;&#13;
        zpow = int(8 * ONE);&#13;
&#13;
        shift -= 64;&#13;
        if (shift &gt;= 0) {&#13;
            if (result &gt;&gt; (256-shift) == 0) {&#13;
                lower = uint(result) &lt;&lt; shift;&#13;
                zpow &lt;&lt;= shift; // todo: is this safe?&#13;
                if (lower + uint(zpow) &gt;= lower)&#13;
                    upper = lower + uint(zpow);&#13;
                else&#13;
                    upper = 2**256-1;&#13;
                return;&#13;
            }&#13;
            else&#13;
                return (2**256-1, 2**256-1);&#13;
        }&#13;
        zpow = (zpow &gt;&gt; (-shift)) + 1;&#13;
        lower = uint(result) &gt;&gt; (-shift);&#13;
        upper = lower + uint(zpow);&#13;
        return;&#13;
    }&#13;
&#13;
    /// @dev Returns natural logarithm value of given x&#13;
    /// @param x x&#13;
    /// @return ln(x)&#13;
    function ln(uint x)&#13;
        public&#13;
        pure&#13;
        returns (int)&#13;
    {&#13;
        (int lower, int upper) = log2Bounds(x);&#13;
        return ((upper - lower) / 2 + lower) * int(ONE) / int(LOG2_E);&#13;
    }&#13;
&#13;
    /// @dev Returns estimate of binaryLog(x) given x&#13;
    /// @param x logarithm argument in fixed point&#13;
    /// @param estimationMode whether to return a lower bound, upper bound, or a midpoint&#13;
    /// @return estimate of binaryLog(x) in fixed point&#13;
    function binaryLog(uint x, EstimationMode estimationMode)&#13;
        public&#13;
        pure&#13;
        returns (int)&#13;
    {&#13;
        (int lower, int upper) = log2Bounds(x);&#13;
        if(estimationMode == EstimationMode.LowerBound) {&#13;
            return lower;&#13;
        }&#13;
        if(estimationMode == EstimationMode.UpperBound) {&#13;
            return upper;&#13;
        }&#13;
        if(estimationMode == EstimationMode.Midpoint) {&#13;
            return (upper - lower) / 2 + lower;&#13;
        }&#13;
        revert();&#13;
    }&#13;
&#13;
    /// @dev Returns bounds for value of binaryLog(x) given x&#13;
    /// @param x logarithm argument in fixed point&#13;
    /// @return {&#13;
    ///   "lower": "lower bound of binaryLog(x) in fixed point",&#13;
    ///   "upper": "upper bound of binaryLog(x) in fixed point"&#13;
    /// }&#13;
    function log2Bounds(uint x)&#13;
        public&#13;
        pure&#13;
        returns (int lower, int upper)&#13;
    {&#13;
        require(x &gt; 0);&#13;
        // compute ⌊log₂x⌋&#13;
        lower = floorLog2(x);&#13;
&#13;
        uint y;&#13;
        if (lower &lt; 0)&#13;
            y = x &lt;&lt; uint(-lower);&#13;
        else&#13;
            y = x &gt;&gt; uint(lower);&#13;
&#13;
        lower *= int(ONE);&#13;
&#13;
        // y = x * 2^(-⌊log₂x⌋)&#13;
        // so 1 &lt;= y &lt; 2&#13;
        // and log₂x = ⌊log₂x⌋ + log₂y&#13;
        for (int m = 1; m &lt;= 64; m++) {&#13;
            if(y == ONE) {&#13;
                break;&#13;
            }&#13;
            y = y * y / ONE;&#13;
            if(y &gt;= 2 * ONE) {&#13;
                lower += int(ONE &gt;&gt; m);&#13;
                y /= 2;&#13;
            }&#13;
        }&#13;
&#13;
        return (lower, lower + 4);&#13;
    }&#13;
&#13;
    /// @dev Returns base 2 logarithm value of given x&#13;
    /// @param x x&#13;
    /// @return logarithmic value&#13;
    function floorLog2(uint x)&#13;
        public&#13;
        pure&#13;
        returns (int lo)&#13;
    {&#13;
        lo = -64;&#13;
        int hi = 193;&#13;
        // I use a shift here instead of / 2 because it floors instead of rounding towards 0&#13;
        int mid = (hi + lo) &gt;&gt; 1;&#13;
        while((lo + 1) &lt; hi) {&#13;
            if (mid &lt; 0 &amp;&amp; x &lt;&lt; uint(-mid) &lt; ONE || mid &gt;= 0 &amp;&amp; x &gt;&gt; uint(mid) &lt; ONE)&#13;
                hi = mid;&#13;
            else&#13;
                lo = mid;&#13;
            mid = (hi + lo) &gt;&gt; 1;&#13;
        }&#13;
    }&#13;
&#13;
    /// @dev Returns maximum of an array&#13;
    /// @param nums Numbers to look through&#13;
    /// @return Maximum number&#13;
    function max(int[] nums)&#13;
        public&#13;
        pure&#13;
        returns (int maxNum)&#13;
    {&#13;
        require(nums.length &gt; 0);&#13;
        maxNum = -2**255;&#13;
        for (uint i = 0; i &lt; nums.length; i++)&#13;
            if (nums[i] &gt; maxNum)&#13;
                maxNum = nums[i];&#13;
    }&#13;
}