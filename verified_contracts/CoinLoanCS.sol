pragma solidity ^0.4.24;
// produced by the Solididy File Flattener (c) David Appleton 2018
// contact : <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="680c091e0d28090307050a09460b0705">[emailÂ protected]</a>&#13;
// released under Apache 2.0 licence&#13;
library SafeMath {&#13;
  function add(uint a, uint b) internal pure returns (uint c) {&#13;
    c = a + b;&#13;
    require(c &gt;= a);&#13;
  }&#13;
  function sub(uint a, uint b) internal pure returns (uint c) {&#13;
    require(b &lt;= a);&#13;
    c = a - b;&#13;
  }&#13;
  function mul(uint a, uint b) internal pure returns (uint c) {&#13;
    c = a * b;&#13;
    require(a == 0 || c / a == b);&#13;
  }&#13;
  function div(uint a, uint b) internal pure returns (uint c) {&#13;
    require(b &gt; 0);&#13;
    c = a / b;&#13;
  }&#13;
}&#13;
&#13;
contract ERC20 {&#13;
  function totalSupply() public constant returns (uint256);&#13;
  function balanceOf(address tokenOwner) public constant returns (uint256 balance);&#13;
  function allowance(address tokenOwner, address spender) public constant returns (uint256 remaining);&#13;
  function transfer(address to, uint tokens) public returns (bool success);&#13;
  function approve(address spender, uint tokens) public returns (bool success);&#13;
  function transferFrom(address from, address to, uint tokens) public returns (bool success);&#13;
&#13;
  event Transfer(address indexed from, address indexed to, uint256 tokens);&#13;
  event Approval(address indexed tokenOwner, address indexed spender, uint256 tokens);&#13;
}&#13;
&#13;
contract Owned {&#13;
  address public owner;&#13;
&#13;
  // ------------------------------------------------------------------------&#13;
  // Constructor&#13;
  // ------------------------------------------------------------------------&#13;
  constructor() public {&#13;
    owner = msg.sender;&#13;
  }&#13;
&#13;
  modifier onlyOwner {&#13;
    require(msg.sender == owner);&#13;
    _;&#13;
  }&#13;
&#13;
  function transferOwnership(address newOwner) public onlyOwner returns (address account) {&#13;
    owner = newOwner;&#13;
    return owner;&#13;
  }&#13;
}&#13;
contract CoinLoanCS is ERC20, Owned {&#13;
  using SafeMath for uint256;&#13;
&#13;
  string public symbol;&#13;
  string public  name;&#13;
  uint256 public decimals;&#13;
  uint256 _totalSupply;&#13;
&#13;
  address public token;&#13;
  uint256 public price;&#13;
&#13;
  mapping(address =&gt; uint256) balances;&#13;
  mapping(address =&gt; mapping(string =&gt; uint256)) orders;&#13;
&#13;
  event TransferETH(address indexed from, address indexed to, uint256 eth);&#13;
  event Sell(address indexed to, uint256 tokens);&#13;
&#13;
  // ------------------------------------------------------------------------&#13;
  // Constructor&#13;
  // ------------------------------------------------------------------------&#13;
  constructor() public {&#13;
    symbol = "CLT_CS";&#13;
    name = "CoinLoan CryptoStock Promo Token";&#13;
    decimals = 8;&#13;
    token = 0x2001f2A0Cf801EcFda622f6C28fb6E10d803D969;&#13;
    price = 3000000;  // = 0.03000000&#13;
    _totalSupply = 100000 * 10**decimals;&#13;
    balances[owner] = _totalSupply;&#13;
    emit Transfer(address(0), owner, _totalSupply);&#13;
  }&#13;
&#13;
  // ------------------------------------------------------------------------&#13;
  // Changes the address of the supported token&#13;
  // ------------------------------------------------------------------------&#13;
  function setToken(address newTokenAddress) public onlyOwner returns (bool success) {&#13;
    token = newTokenAddress;&#13;
    return true;&#13;
  }&#13;
&#13;
  // ------------------------------------------------------------------------&#13;
  // Return a contract address of the supported token&#13;
  // ------------------------------------------------------------------------&#13;
  function getToken() public view returns (address) {&#13;
    return token;&#13;
  }&#13;
&#13;
  // ------------------------------------------------------------------------&#13;
  // Sets `price` value&#13;
  // ------------------------------------------------------------------------&#13;
  function setPrice(uint256 newPrice) public onlyOwner returns (bool success) {&#13;
    price = newPrice;&#13;
    return true;&#13;
  }&#13;
&#13;
  // ------------------------------------------------------------------------&#13;
  // Returns current price (without decimals)&#13;
  // ------------------------------------------------------------------------&#13;
  function getPrice() public view returns (uint256) {&#13;
    return price;&#13;
  }&#13;
&#13;
  // ------------------------------------------------------------------------&#13;
  // Total supply&#13;
  // ------------------------------------------------------------------------&#13;
  function totalSupply() public view returns (uint256) {&#13;
    return _totalSupply.sub(balances[address(0)]);&#13;
  }&#13;
&#13;
  // ------------------------------------------------------------------------&#13;
  // Changes the total supply value&#13;
  //&#13;
  // a new supply must be no less then the current supply&#13;
  // or the owner must have enough amount to cover supply reduction&#13;
  // ------------------------------------------------------------------------&#13;
  function changeTotalSupply(uint256 newSupply) public onlyOwner returns (bool success) {&#13;
    require(newSupply &gt;= 0 &amp;&amp; (&#13;
      newSupply &gt;= _totalSupply || _totalSupply - newSupply &lt;= balances[owner]&#13;
    ));&#13;
    uint256 diff = 0;&#13;
    if (newSupply &gt;= _totalSupply) {&#13;
      diff = newSupply.sub(_totalSupply);&#13;
      balances[owner] = balances[owner].add(diff);&#13;
      emit Transfer(address(0), owner, diff);&#13;
    } else {&#13;
      diff = _totalSupply.sub(newSupply);&#13;
      balances[owner] = balances[owner].sub(diff);&#13;
      emit Transfer(owner, address(0), diff);&#13;
    }&#13;
    _totalSupply = newSupply;&#13;
    return true;&#13;
  }&#13;
&#13;
  // ------------------------------------------------------------------------&#13;
  // Get the token balance for account `tokenOwner`&#13;
  // ------------------------------------------------------------------------&#13;
  function balanceOf(address tokenOwner) public view returns (uint256 balance) {&#13;
    return balances[tokenOwner];&#13;
  }&#13;
&#13;
  // ------------------------------------------------------------------------&#13;
  // Get the order's balance of tokens for account `customer`&#13;
  // ------------------------------------------------------------------------&#13;
  function orderTokensOf(address customer) public view returns (uint256 balance) {&#13;
    return orders[customer]['tokens'];&#13;
  }&#13;
&#13;
  // ------------------------------------------------------------------------&#13;
  // Get the order's balance of ETH for account `customer`&#13;
  // ------------------------------------------------------------------------&#13;
  function orderEthOf(address customer) public view returns (uint256 balance) {&#13;
    return orders[customer]['eth'];&#13;
  }&#13;
&#13;
  // ------------------------------------------------------------------------&#13;
  // Delete customer's order&#13;
  // ------------------------------------------------------------------------&#13;
  function cancelOrder(address customer) public onlyOwner returns (bool success) {&#13;
    orders[customer]['eth'] = 0;&#13;
    orders[customer]['tokens'] = 0;&#13;
    return true;&#13;
  }&#13;
&#13;
  // ------------------------------------------------------------------------&#13;
  // Checks the order values by the customer's address and sends required&#13;
  // promo tokens based on the received amount of `this` tokens and ETH&#13;
  // ------------------------------------------------------------------------&#13;
  function _checkOrder(address customer) private returns (uint256) {&#13;
    require(price &gt; 0);&#13;
    if (orders[customer]['tokens'] &lt;= 0 || orders[customer]['eth'] &lt;= 0) {&#13;
      return 0;&#13;
    }&#13;
&#13;
    uint256 decimalsDiff = 10 ** (18 - 2 * decimals);&#13;
    uint256 eth = orders[customer]['eth'];&#13;
    uint256 tokens = orders[customer]['eth'] / price / decimalsDiff;&#13;
&#13;
    if (orders[customer]['tokens'] &lt; tokens) {&#13;
      tokens = orders[customer]['tokens'];&#13;
      eth = tokens * price * decimalsDiff;&#13;
    }&#13;
&#13;
    ERC20 tokenInstance = ERC20(token);&#13;
&#13;
    // complete the order&#13;
    require(tokenInstance.balanceOf(this) &gt;= tokens);&#13;
&#13;
    // charge required amount of the tokens and ETHs&#13;
    orders[customer]['tokens'] = orders[customer]['tokens'].sub(tokens);&#13;
    orders[customer]['eth'] = orders[customer]['eth'].sub(eth);&#13;
&#13;
    tokenInstance.transfer(customer, tokens);&#13;
&#13;
    emit Sell(customer, tokens);&#13;
&#13;
    return tokens;&#13;
  }&#13;
&#13;
  // ------------------------------------------------------------------------&#13;
  // public entry point for the `_checkOrder` function&#13;
  // ------------------------------------------------------------------------&#13;
  function checkOrder(address customer) public onlyOwner returns (uint256) {&#13;
    return _checkOrder(customer);&#13;
  }&#13;
&#13;
  // ------------------------------------------------------------------------&#13;
  // Transfer the balance from token owner's account to `to` account&#13;
  // - Owner's account must have sufficient balance to transfer&#13;
  // - 0 value transfers are allowed&#13;
  // - only owner is allowed to send tokens to any address&#13;
  // - not owners can transfer the balance only to owner's address&#13;
  // ------------------------------------------------------------------------&#13;
  function transfer(address to, uint256 tokens) public returns (bool success) {&#13;
    require(msg.sender == owner || to == owner || to == address(this));&#13;
    address receiver = msg.sender == owner ? to : owner;&#13;
    balances[msg.sender] = balances[msg.sender].sub(tokens);&#13;
    balances[receiver] = balances[receiver].add(tokens);&#13;
    emit Transfer(msg.sender, receiver, tokens);&#13;
    if (receiver == owner) {&#13;
      orders[msg.sender]['tokens'] = orders[msg.sender]['tokens'].add(tokens);&#13;
      _checkOrder(msg.sender);&#13;
    }&#13;
    return true;&#13;
  }&#13;
&#13;
  // ------------------------------------------------------------------------&#13;
  // `allowance` is not allowed&#13;
  // ------------------------------------------------------------------------&#13;
  function allowance(address tokenOwner, address spender) public constant returns (uint256 remaining) {&#13;
    tokenOwner;&#13;
    spender;&#13;
    return uint256(0);&#13;
  }&#13;
&#13;
  // ------------------------------------------------------------------------&#13;
  // `approve` is not allowed&#13;
  // ------------------------------------------------------------------------&#13;
  function approve(address spender, uint tokens) public returns (bool success) {&#13;
    spender;&#13;
    tokens;&#13;
    return true;&#13;
  }&#13;
&#13;
  // ------------------------------------------------------------------------&#13;
  // `transferFrom` is not allowed&#13;
  // ------------------------------------------------------------------------&#13;
  function transferFrom(address from, address to, uint256 tokens) public returns (bool success) {&#13;
    from;&#13;
    to;&#13;
    tokens;&#13;
    return true;&#13;
  }&#13;
&#13;
  // ------------------------------------------------------------------------&#13;
  // Accept ETH&#13;
  // ------------------------------------------------------------------------&#13;
  function () public payable {&#13;
    owner.transfer(msg.value);&#13;
    orders[msg.sender]['eth'] = orders[msg.sender]['eth'].add(msg.value);&#13;
    _checkOrder(msg.sender);&#13;
    emit TransferETH(msg.sender, address(this), msg.value);&#13;
  }&#13;
&#13;
  // ------------------------------------------------------------------------&#13;
  // Owner can transfer out any accidentally sent ERC20 tokens&#13;
  // ------------------------------------------------------------------------&#13;
  function transferAnyERC20Token(address tokenAddress, uint256 tokens) public onlyOwner returns (bool success) {&#13;
    return ERC20(tokenAddress).transfer(owner, tokens);&#13;
  }&#13;
&#13;
  // ------------------------------------------------------------------------&#13;
  // Owner can transfer out promo token&#13;
  // ------------------------------------------------------------------------&#13;
  function transferToken(uint256 tokens) public onlyOwner returns (bool success) {&#13;
    return transferAnyERC20Token(token, tokens);&#13;
  }&#13;
&#13;
  // ------------------------------------------------------------------------&#13;
  // Owner can return specified amount from `tokenOwner`&#13;
  // ------------------------------------------------------------------------&#13;
  function returnFrom(address tokenOwner, uint256 tokens) public onlyOwner returns (bool success) {&#13;
    balances[tokenOwner] = balances[tokenOwner].sub(tokens);&#13;
    balances[owner] = balances[owner].add(tokens);&#13;
    emit Transfer(tokenOwner, owner, tokens);&#13;
    return true;&#13;
  }&#13;
&#13;
  // ------------------------------------------------------------------------&#13;
  // Owner can returns all tokens from `tokenOwner`&#13;
  // ------------------------------------------------------------------------&#13;
  function nullifyFrom(address tokenOwner) public onlyOwner returns (bool success) {&#13;
    return returnFrom(tokenOwner, balances[tokenOwner]);&#13;
  }&#13;
}