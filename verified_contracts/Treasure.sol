/*
@author <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="d8aab9bcb9aaa2b0b0adb998bfb9b5b1b4f6bbb7b5">[emailÂ protected]</a>&#13;
*/&#13;
pragma solidity ^0.4.24;&#13;
&#13;
&#13;
library SafeMath {&#13;
    function add(uint a, uint b) internal pure returns (uint c) {&#13;
        c = a + b;&#13;
        require(c &gt;= a);&#13;
    }&#13;
&#13;
    function sub(uint a, uint b) internal pure returns (uint c) {&#13;
        require(b &lt;= a);&#13;
        c = a - b;&#13;
    }&#13;
&#13;
    function mul(uint a, uint b) internal pure returns (uint c) {&#13;
        c = a * b;&#13;
        require(a == 0 || c / a == b);&#13;
    }&#13;
&#13;
    function div(uint a, uint b) internal pure returns (uint c) {&#13;
        require(b &gt; 0);&#13;
        c = a / b;&#13;
    }&#13;
}&#13;
&#13;
library NameFilter {&#13;
&#13;
    /**&#13;
     * @dev filters name strings&#13;
     * -converts uppercase to lower case.&#13;
     * -makes sure it does not start/end with a space&#13;
     * -makes sure it does not contain multiple spaces in a row&#13;
     * -cannot be only numbers&#13;
     * -cannot start with 0x&#13;
     * -restricts characters to A-Z, a-z, 0-9, and space.&#13;
     * @return reprocessed string in bytes32 format&#13;
     */&#13;
    function nameFilter(string _input) internal pure returns (bytes32){&#13;
        bytes memory _temp = bytes(_input);&#13;
        uint _length = _temp.length;&#13;
        //sorry limited to 32 characters&#13;
        require(_length &lt;= 32 &amp;&amp; _length &gt; 0, "string must be between 1 and 32 characters");&#13;
        // make sure it doesnt start with or end with space&#13;
        require(_temp[0] != 0x20 &amp;&amp; _temp[_length - 1] != 0x20, "string cannot start or end with space");&#13;
        // make sure first two characters are not 0x&#13;
        if (_temp[0] == 0x30)&#13;
        {&#13;
            require(_temp[1] != 0x78, "string cannot start with 0x");&#13;
            require(_temp[1] != 0x58, "string cannot start with 0X");&#13;
        }&#13;
        // create a bool to track if we have a non number character&#13;
        bool _hasNonNumber;&#13;
        // convert &amp; check&#13;
        for (uint i = 0; i &lt; _length; i++)&#13;
        {&#13;
            // if its uppercase A-Z&#13;
            if (_temp[i] &gt; 0x40 &amp;&amp; _temp[i] &lt; 0x5b)&#13;
            {&#13;
                // convert to lower case a-z&#13;
                _temp[i] = byte(uint(_temp[i]) + 32);&#13;
&#13;
                // we have a non number&#13;
                if (_hasNonNumber == false)&#13;
                    _hasNonNumber = true;&#13;
            } else {&#13;
                require&#13;
                (&#13;
                // require character is a space&#13;
                    _temp[i] == 0x20 ||&#13;
                // OR lowercase a-z&#13;
                (_temp[i] &gt; 0x60 &amp;&amp; _temp[i] &lt; 0x7b) ||&#13;
                // or 0-9&#13;
                (_temp[i] &gt; 0x2f &amp;&amp; _temp[i] &lt; 0x3a),&#13;
                    "string contains invalid characters"&#13;
                );&#13;
                // make sure theres not 2x spaces in a row&#13;
                if (_temp[i] == 0x20)&#13;
                    require(_temp[i + 1] != 0x20, "string cannot contain consecutive spaces");&#13;
&#13;
                // see if we have a character other than a number&#13;
                if (_hasNonNumber == false &amp;&amp; (_temp[i] &lt; 0x30 || _temp[i] &gt; 0x39))&#13;
                    _hasNonNumber = true;&#13;
            }&#13;
        }&#13;
&#13;
        require(_hasNonNumber == true, "string cannot be only numbers");&#13;
        bytes32 _ret;&#13;
        assembly {&#13;
            _ret := mload(add(_temp, 32))&#13;
        }&#13;
        return (_ret);&#13;
    }&#13;
}&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
// ----------------------------------------------------------------------------&#13;
// Owned contract&#13;
// ----------------------------------------------------------------------------&#13;
contract Owned {&#13;
    address public owner;&#13;
    address public newOwner;&#13;
&#13;
    event OwnershipTransferred(address indexed _from, address indexed _to);&#13;
    constructor() public {&#13;
        owner = msg.sender;&#13;
    }&#13;
    modifier onlyOwner {&#13;
        require(msg.sender == owner);&#13;
        _;&#13;
    }&#13;
    function transferOwnership(address _newOwner) public onlyOwner {&#13;
        newOwner = _newOwner;&#13;
    }&#13;
    function acceptOwnership() public {&#13;
        require(msg.sender == newOwner);&#13;
        emit OwnershipTransferred(owner, newOwner);&#13;
        owner = newOwner;&#13;
        newOwner = address(0);&#13;
    }&#13;
}&#13;
&#13;
contract PlayerBook is Owned {&#13;
    using SafeMath for uint;&#13;
    using NameFilter for string;&#13;
    bool public actived = false;&#13;
    uint public registrationFee_ = 1 finney;            // price to register a name&#13;
    uint public pID_;        // total number of players&#13;
    mapping(address =&gt; uint) public pIDxAddr_;          // (addr =&gt; pID) returns player id by address&#13;
    mapping(uint =&gt; Player) public plyr_;               // (pID =&gt; data) player data&#13;
    mapping(bytes32 =&gt; uint) public pIDxName_;          // (name =&gt; pID) returns player id by name&#13;
    mapping(uint =&gt; mapping(bytes32 =&gt; bool)) public plyrNames_; // (pID =&gt; name =&gt; bool) list of names a player owns.  (used so you can change your display name amoungst any name you own)&#13;
    mapping(uint =&gt; mapping(uint =&gt; bytes32)) public plyrNameList_; // (pID =&gt; nameNum =&gt; name) list of names a player owns&#13;
    struct Player {&#13;
        address addr;&#13;
        bytes32 name;&#13;
        uint laff;&#13;
        uint names;&#13;
    }&#13;
    /**&#13;
     * @dev prevents contracts from interacting with playerBook&#13;
     */&#13;
    modifier isHuman {&#13;
        address _addr = msg.sender;&#13;
        uint _codeLength;&#13;
        assembly {_codeLength := extcodesize(_addr)}&#13;
        require(_codeLength == 0, "sorry humans only");&#13;
        _;&#13;
    }&#13;
    modifier isActive {&#13;
        require(actived, "sorry game paused");&#13;
        _;&#13;
    }&#13;
    modifier isRegistered {&#13;
        address _addr = msg.sender;&#13;
        uint _pid = pIDxAddr_[msg.sender];&#13;
        require(_pid != 0, " you need register the address");&#13;
        _;&#13;
    }&#13;
&#13;
    // ------------------------------------------------------------------------&#13;
    // Constructor&#13;
    // ------------------------------------------------------------------------&#13;
    constructor() public {&#13;
        // premine the admin names (sorry not sorry)&#13;
        plyr_[1].addr = 0x2ba0ECF5eC2dD51F115d8526333395beba490363;&#13;
        plyr_[1].name = "admin";&#13;
        plyr_[1].names = 1;&#13;
        pIDxAddr_[0x2ba0ECF5eC2dD51F115d8526333395beba490363] = 1;&#13;
        pIDxName_["admin"] = 1;&#13;
        plyrNames_[1]["admin"] = true;&#13;
        plyrNameList_[1][1] = "admin";&#13;
        pID_ = 1;&#13;
    }&#13;
&#13;
    function checkIfNameValid(string _nameStr) public view returns (bool){&#13;
        bytes32 _name = _nameStr.nameFilter();&#13;
        if (pIDxName_[_name] == 0)&#13;
            return (true);&#13;
        else&#13;
            return (false);&#13;
    }&#13;
&#13;
    function determinePID(address _addr) private returns (bool){&#13;
        if (pIDxAddr_[_addr] == 0) {&#13;
            pID_++;&#13;
            pIDxAddr_[_addr] = pID_;&#13;
            plyr_[pID_].addr = _addr;&#13;
            // set the new player bool to true&#13;
            return (true);&#13;
        } else {&#13;
            return (false);&#13;
        }&#13;
    }&#13;
&#13;
    function registerNameXID(string _nameString, uint _affCode) public isActive isHuman payable {&#13;
        // make sure name fees paid&#13;
        require(msg.value &gt;= registrationFee_, "umm.....  you have to pay the name fee");&#13;
        // filter name + condition checks&#13;
        bytes32 _name = NameFilter.nameFilter(_nameString);&#13;
        // set up address&#13;
        address _addr = msg.sender;&#13;
        // set up our tx event data and determine if player is new or not&#13;
        determinePID(_addr);&#13;
        // fetch player id&#13;
        uint _pID = pIDxAddr_[_addr];&#13;
        // manage affiliate residuals&#13;
        // if no affiliate code was given, no new affiliate code was given, or the&#13;
        // player tried to use their own pID as an affiliate code, lolz&#13;
        //_affCode must little than the pID_&#13;
        if (_affCode != 0 &amp;&amp; _affCode != plyr_[_pID].laff &amp;&amp; _affCode != _pID &amp;&amp; _affCode &lt;= pID_) {&#13;
            // update last affiliate&#13;
            plyr_[_pID].laff = _affCode;&#13;
        } else {&#13;
            if(plyr_[_pID].laff == 0)&#13;
              plyr_[_pID].laff = 1;&#13;
        }&#13;
        // register name&#13;
        plyr_[1].addr.transfer(msg.value);&#13;
        registerNameCore(_pID, _name);&#13;
    }&#13;
&#13;
    function registerNameCore(uint _pID, bytes32 _name) private {&#13;
        if (pIDxName_[_name] != 0)&#13;
            require(plyrNames_[_pID][_name] == true, "sorry that names already taken");&#13;
        plyr_[_pID].name = _name;&#13;
        pIDxName_[_name] = _pID;&#13;
        if (plyrNames_[_pID][_name] == false)&#13;
        {&#13;
            plyrNames_[_pID][_name] = true;&#13;
            plyr_[_pID].names++;&#13;
            plyrNameList_[_pID][plyr_[_pID].names] = _name;&#13;
        }&#13;
    }&#13;
&#13;
    function getPlayerLaffCount(address _addr) internal view returns (uint){&#13;
        uint _pid = pIDxAddr_[_addr];&#13;
        if (_pid == 0) {&#13;
            return 0;&#13;
        } else {&#13;
            uint result = 0;&#13;
            for (uint i = 1; i &lt;= pID_; i++) {&#13;
                if (plyr_[i].laff == _pid) {&#13;
                    result ++;&#13;
                }&#13;
            }&#13;
            return result;&#13;
        }&#13;
    }&#13;
&#13;
    function getPlayerID(address _addr) external view returns (uint) {&#13;
        return (pIDxAddr_[_addr]);&#13;
    }&#13;
&#13;
    function getPlayerCount() external view returns (uint){&#13;
        return pID_;&#13;
    }&#13;
&#13;
    function getPlayerName(uint _pID) external view returns (bytes32){&#13;
        return (plyr_[_pID].name);&#13;
    }&#13;
&#13;
    function getPlayerLAff(uint _pID) external view returns (uint){&#13;
        return (plyr_[_pID].laff);&#13;
    }&#13;
&#13;
    function getPlayerAddr(uint _pID) external view returns (address){&#13;
        return (plyr_[_pID].addr);&#13;
    }&#13;
&#13;
    function getNameFee() external view returns (uint){&#13;
        return (registrationFee_);&#13;
    }&#13;
&#13;
    function setRegistrationFee(uint _fee) public onlyOwner {&#13;
        require(_fee != 0);&#13;
        registrationFee_ = _fee;&#13;
    }&#13;
&#13;
    function active() public onlyOwner {&#13;
        actived = true;&#13;
    }&#13;
}&#13;
&#13;
&#13;
&#13;
// ----------------------------------------------------------------------------&#13;
contract Treasure is PlayerBook {&#13;
    uint private seed = 18;                    //random seed&#13;
    /* bool private canSet = true; */&#13;
    //module 0,1,2&#13;
    uint[3] public gameRound = [1, 1, 1];                         //rounds index by module&#13;
    uint[3] public maxKeys = [1200, 12000, 60000];              //index by module&#13;
    uint[3] public keyLimits = [100, 1000, 5000];               //index by module&#13;
    uint public keyPrice = 10 finney;&#13;
    uint public devFee = 10;&#13;
    uint public laffFee1 = 10;&#13;
    uint public laffFee2 = 1;&#13;
    address public devWallet = 0xB4D4709C2D537047683294c4040aBB9d616e23B5;&#13;
    mapping(uint =&gt; mapping(uint =&gt; RoundInfo)) public gameInfo;   //module =&gt; round =&gt; info&#13;
    mapping(uint =&gt; mapping(uint =&gt; mapping(uint =&gt; uint))) public userAff;     //module =&gt; round =&gt; pid =&gt; affCount&#13;
    struct RoundInfo {&#13;
        uint module;            //module 0,1,2&#13;
        uint rd;                // rounds&#13;
        uint count;             // player number and id&#13;
        uint keys;              // purchased keys&#13;
        uint maxKeys;           // end keys&#13;
        uint keyLimits;&#13;
        uint award;             //award of the round&#13;
        address winner;         //winner&#13;
        bool isEnd;&#13;
        mapping(uint =&gt; uint) userKeys;        // pid =&gt; keys&#13;
        mapping(uint =&gt; uint) userId;      // count =&gt; pid&#13;
    }&#13;
&#13;
    modifier validModule(uint _module){&#13;
        require(_module &gt;= 0 &amp;&amp; _module &lt;= 2, " error module");&#13;
        _;&#13;
    }&#13;
&#13;
    // ------------------------------------------------------------------------&#13;
    // Constructor&#13;
    // ------------------------------------------------------------------------&#13;
    constructor() public {&#13;
        initRoundInfo(0, 1);&#13;
        initRoundInfo(1, 1);&#13;
        initRoundInfo(2, 1);&#13;
    }&#13;
    //only be called once&#13;
    /* function setSeed(uint _seed) public onlyOwner {&#13;
      require(canSet);&#13;
      canSet = false;&#13;
      seed = _seed;&#13;
    } */&#13;
&#13;
    /**&#13;
   random int&#13;
    */&#13;
    function randInt(uint256 _start, uint256 _end, uint256 _nonce)&#13;
    private&#13;
    view&#13;
    returns (uint256)&#13;
    {&#13;
        uint256 _range = _end.sub(_start);&#13;
        uint256 value = uint256(keccak256(abi.encodePacked(&#13;
                (block.timestamp).add&#13;
                (block.difficulty).add&#13;
                ((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (now)).add&#13;
                (block.gaslimit).add&#13;
                ((uint256(keccak256(abi.encodePacked(msg.sender)))) / (now)).add&#13;
                (block.number),&#13;
                _nonce&#13;
            )));&#13;
        return (_start + value - ((value / _range) * _range));&#13;
    }&#13;
&#13;
    function initRoundInfo(uint _mode, uint _rd) private validModule(_mode) {&#13;
        uint _maxKeys = maxKeys[_mode];&#13;
        uint _keyLimits = keyLimits[_mode];&#13;
        RoundInfo memory rf = RoundInfo({&#13;
            module : _mode,&#13;
            rd : _rd,&#13;
            count : 0,&#13;
            keys : 0,&#13;
            maxKeys : _maxKeys,&#13;
            keyLimits : _keyLimits,&#13;
            award : 0,&#13;
            winner : address(0),&#13;
            isEnd : false&#13;
            });&#13;
        gameInfo[_mode][_rd] = rf;&#13;
    }&#13;
    //user detail of one round&#13;
    function getUserDetail(uint _mode, uint _rd) public validModule(_mode) view returns (uint _eth, uint _award, uint _affEth){&#13;
        address _addr = msg.sender;&#13;
        uint _pid = pIDxAddr_[_addr];&#13;
        require(_pid != 0, " you need register the address");&#13;
        uint _userKeys = gameInfo[_mode][_rd].userKeys[_pid];&#13;
        _eth = _userKeys * keyPrice;&#13;
        if (gameInfo[_mode][_rd].winner == _addr)&#13;
            _award = gameInfo[_mode][_rd].award;&#13;
        else&#13;
            _award = 0;&#13;
        _affEth = userAff[_mode][_rd][_pid];&#13;
    }&#13;
&#13;
    function getAllLaffAwards(address _addr) private view returns (uint){&#13;
        uint _pid = pIDxAddr_[_addr];&#13;
        require(_pid != 0, " you need register the address");&#13;
        uint sum = 0;&#13;
        for (uint i = 0; i &lt; 3; i++) {&#13;
            for (uint j = 1; j &lt;= gameRound[i]; j++) {&#13;
                uint value = userAff[i][j][_pid];&#13;
                if (value &gt; 0)&#13;
                    sum = sum.add(value);&#13;
            }&#13;
        }&#13;
        return sum;&#13;
    }&#13;
&#13;
    function getPlayerAllDetail() external view returns (uint[] modes, uint[] rounds, uint[] eths, uint[] awards, uint _laffAwards, uint _laffCount){&#13;
        address _addr = msg.sender;&#13;
        uint _pid = pIDxAddr_[_addr];&#13;
        require(_pid != 0, " you need register the address");&#13;
        uint i = gameRound[0] + gameRound[1] + gameRound[2];&#13;
        uint counter = 0;&#13;
        RoundInfo[] memory allInfo = new RoundInfo[](i);&#13;
        for (i = 0; i &lt; 3; i++) {&#13;
            for (uint j = 1; j &lt;= gameRound[i]; j++) {&#13;
                if (gameInfo[i][j].userKeys[_pid] &gt; 0) {&#13;
                    allInfo[counter] = gameInfo[i][j];&#13;
                    counter ++;&#13;
                }&#13;
            }&#13;
        }&#13;
        modes = new uint[](counter);&#13;
        rounds = new uint[](counter);&#13;
        eths = new uint[](counter);&#13;
        awards = new uint[](counter);&#13;
        for (i = 0; i &lt; counter; i++) {&#13;
            modes[i] = allInfo[i].module;&#13;
            rounds[i] = allInfo[i].rd;&#13;
            eths[i] = gameInfo[modes[i]][rounds[i]].userKeys[_pid].mul(keyPrice);&#13;
            if (_addr == allInfo[i].winner) {&#13;
                awards[i] = allInfo[i].award;&#13;
            } else {&#13;
                awards[i] = 0;&#13;
            }&#13;
        }&#13;
        _laffAwards = getAllLaffAwards(_addr);&#13;
        _laffCount = getPlayerLaffCount(_addr);&#13;
    }&#13;
&#13;
    function buyKeys(uint _mode, uint _rd) public isHuman isActive validModule(_mode) payable {&#13;
        address _addr = msg.sender;&#13;
        uint _pid = pIDxAddr_[_addr];&#13;
        require(_pid != 0, " you need register the address");&#13;
        uint _eth = msg.value;&#13;
        require(_eth &gt;= keyPrice, "you need buy one or more keys");&#13;
        require(_rd == gameRound[_mode], "error round");&#13;
        RoundInfo storage ri = gameInfo[_mode][_rd];&#13;
        require(!ri.isEnd, "the round is end");&#13;
        require(ri.keys &lt; ri.maxKeys, "the round maxKeys");&#13;
        uint _keys = _eth.div(keyPrice);&#13;
        require(ri.userKeys[_pid] &lt; ri.keyLimits);&#13;
        if (ri.userKeys[_pid] == 0) {&#13;
            ri.count ++;&#13;
            ri.userId[ri.count] = _pid;&#13;
        }&#13;
        if (_keys.add(ri.keys) &gt; ri.maxKeys) {&#13;
            _keys = ri.maxKeys.sub(ri.keys);&#13;
        }&#13;
        if (_keys.add(ri.userKeys[_pid]) &gt; ri.keyLimits) {&#13;
            _keys = ri.keyLimits - ri.userKeys[_pid];&#13;
        }&#13;
        require(_keys &gt; 0);&#13;
        uint rand = randInt(0, 100, seed+_keys);&#13;
        seed = seed.add(rand);&#13;
        _eth = _keys.mul(keyPrice);&#13;
        ri.userKeys[_pid] = ri.userKeys[_pid].add(_keys);&#13;
        ri.keys = ri.keys.add(_keys);&#13;
        //back&#13;
        if(msg.value - _eth &gt; 10 szabo )&#13;
          msg.sender.transfer(msg.value - _eth);&#13;
        checkAff(_mode, _rd, _pid, _eth);&#13;
        if (ri.keys &gt;= ri.maxKeys) {&#13;
            endRound(_mode, _rd);&#13;
        }&#13;
    }&#13;
&#13;
    function getUserInfo(address _addr) public view returns (uint _pID, bytes32 _name, uint _laff, uint[] _keys){&#13;
        _pID = pIDxAddr_[_addr];&#13;
        _name = plyr_[_pID].name;&#13;
        _laff = plyr_[_pID].laff;&#13;
        _keys = new uint[](3);&#13;
        for (uint i = 0; i &lt; 3; i++) {&#13;
            _keys[i] = gameInfo[i][gameRound[i]].userKeys[_pID];&#13;
        }&#13;
    }&#13;
&#13;
&#13;
    function endRound(uint _mode, uint _rd) private {&#13;
        RoundInfo storage ri = gameInfo[_mode][_rd];&#13;
        require(!ri.isEnd, "the rounds has end");&#13;
        ri.isEnd = true;&#13;
        uint _eth = ri.award.mul(devFee) / 100;&#13;
        uint _win = calWinner(_mode, _rd);&#13;
        ri.winner = plyr_[_win].addr;&#13;
        gameRound[_mode] = _rd + 1;&#13;
        initRoundInfo(_mode, _rd + 1);&#13;
        devWallet.transfer(_eth);&#13;
        plyr_[_win].addr.transfer(ri.award.sub(_eth));&#13;
    }&#13;
&#13;
    function calWinner(uint _mode, uint _rd) private returns (uint){&#13;
        RoundInfo storage ri = gameInfo[_mode][_rd];&#13;
        uint rand = randInt(0, ri.maxKeys, seed);&#13;
        seed = seed.add(rand);&#13;
        uint keySum = 0;&#13;
        uint _win = 0;&#13;
        for (uint i = 1; i &lt;= ri.count; i++) {&#13;
            uint _key = ri.userKeys[ri.userId[i]];&#13;
            keySum += _key;&#13;
            if (rand &lt; keySum) {&#13;
                _win = i;&#13;
                break;&#13;
            }&#13;
        }&#13;
        require(_win &gt; 0);&#13;
        return ri.userId[_win];&#13;
    }&#13;
&#13;
    function checkAff(uint _mode, uint _rd, uint _pid, uint _eth) private {&#13;
        uint fee1 = _eth.mul(laffFee1).div(100);&#13;
        uint fee2 = _eth.mul(laffFee2).div(100);&#13;
        uint res = _eth.sub(fee1).sub(fee2);&#13;
        gameInfo[_mode][_rd].award += res;&#13;
        uint laff1 = plyr_[_pid].laff;&#13;
        if (laff1 == 0) {&#13;
            plyr_[1].addr.transfer(fee1.add(fee2));&#13;
        } else {&#13;
            plyr_[laff1].addr.transfer(fee1);&#13;
            userAff[_mode][_rd][laff1] += fee1;&#13;
            uint laff2 = plyr_[laff1].laff;&#13;
            if (laff2 == 0) {&#13;
                plyr_[1].addr.transfer(fee2);&#13;
            } else {&#13;
                plyr_[laff2].addr.transfer(fee2);&#13;
                userAff[_mode][_rd][laff2] += fee2;&#13;
            }&#13;
        }&#13;
    }&#13;
&#13;
    function getRoundInfo(uint _mode) external validModule(_mode) view returns (uint _cr, uint _ck, uint _mk, uint _award){&#13;
        _cr = gameRound[_mode];&#13;
        _ck = gameInfo[_mode][_cr].keys;&#13;
        _mk = gameInfo[_mode][_cr].maxKeys;&#13;
        _award = gameInfo[_mode][_cr].award;&#13;
    }&#13;
&#13;
    function getRoundIsEnd(uint _mode, uint _rd) external validModule(_mode) view returns (bool){&#13;
        require(_rd &gt; 0 &amp;&amp; _rd &lt;= gameRound[_mode]);&#13;
        return gameInfo[_mode][_rd].isEnd;&#13;
    }&#13;
&#13;
    function getAwardHistorhy(uint _mode) external validModule(_mode) view returns (address[] dh, uint[] ah){&#13;
        uint hr = gameRound[_mode] - 1;&#13;
        dh = new address[](hr);&#13;
        ah = new uint[](hr);&#13;
        if (hr != 0) {&#13;
            for (uint i = 1; i &lt;= hr; i++) {&#13;
                RoundInfo memory rf = gameInfo[_mode][i];&#13;
                dh[i - 1] = rf.winner;&#13;
                ah[i - 1] = rf.award;&#13;
            }&#13;
        }&#13;
    }&#13;
        /* ****************************************************&#13;
              *********                            *********&#13;
                *********                        *********&#13;
                  *********    thanks a lot    *********&#13;
                    *********                *********&#13;
                      *********            *********&#13;
                        *********        *********&#13;
                          *********    *********&#13;
                            ******************&#13;
                              **************&#13;
                                **********&#13;
                                  *****&#13;
                                    *&#13;
         *********************************************************/&#13;
}