pragma solidity ^0.4.18;

// ----------------------------------------------------------------------------------------------
// Moviecoin Token by Xender Limited.
// An ERC20 standard
//
// author: Xender Team
// Contact: <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="2a594f585c43494f6a524f444e4f5804494547">[emailÂ protected]</a>&#13;
// ----------------------------------------------------------------------------------------------&#13;
&#13;
/*&#13;
    Standard Token interface&#13;
*/&#13;
contract ERC20Interface {&#13;
     // Get the total token name&#13;
    function name() public constant returns (string);&#13;
&#13;
    // Get the total token symbol&#13;
    function symbol() public constant returns (string); &#13;
&#13;
    // Get the total token decimals&#13;
    function decimals() public constant returns (uint);&#13;
&#13;
    // Get the total token supply&#13;
    function totalSupply() public constant returns (uint256);&#13;
&#13;
    // Get the account balance of another account with address _owner&#13;
    function balanceOf(address _owner) public constant returns (uint256);&#13;
  &#13;
    // Send _value amount of tokens to address _to&#13;
    function transfer(address _to, uint256 _value) public returns (bool);&#13;
    &#13;
    // transfer _value amount of token approved by address _from&#13;
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool);&#13;
&#13;
    // approve an address with _value amount of tokens&#13;
    function approve(address _spender, uint256 _value) public returns (bool);&#13;
&#13;
    // get remaining token approved by _owner to _spender&#13;
    function allowance(address _owner, address _spender) public constant returns (uint256);&#13;
   &#13;
    // Triggered when tokens are transferred.&#13;
    event Transfer(address indexed _from, address indexed _to, uint256 _value);&#13;
&#13;
    // Triggered whenever approve(address _spender, uint256 _value) is called.&#13;
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);&#13;
}&#13;
&#13;
/*&#13;
    owned manager&#13;
*/&#13;
contract Owned {&#13;
&#13;
	// Owner of this contract&#13;
    address owner;&#13;
    &#13;
    // permit transaction&#13;
    bool isLock = true;&#13;
    &#13;
    // white list&#13;
    mapping(address =&gt; bool) whitelisted;&#13;
 &#13;
    &#13;
    function Owned() public {&#13;
        owner = msg.sender;&#13;
        whitelisted[owner] = true;&#13;
    }&#13;
&#13;
    modifier onlyOwner {&#13;
        require(msg.sender == owner);&#13;
        _;&#13;
    }&#13;
	&#13;
	modifier isUnlock () {&#13;
        if (isLock){&#13;
            require(whitelisted[msg.sender] == true);&#13;
        }&#13;
        _;&#13;
    }&#13;
	&#13;
	 /**&#13;
     * add new address to white list&#13;
     */&#13;
     function addWhitelist(address _white) public onlyOwner {&#13;
         whitelisted[_white] = true;&#13;
     }&#13;
     &#13;
    /**&#13;
     * remove address from white list&#13;
     */&#13;
    function removeWhitelist(address _white) public onlyOwner {&#13;
        whitelisted[_white] = false;&#13;
    }&#13;
      &#13;
    /**&#13;
     * check whether the address is in the white list&#13;
     */&#13;
    function checkWhitelist(address _addr) public view returns (bool) {&#13;
        return whitelisted[_addr];&#13;
    }&#13;
    &#13;
    /**&#13;
    * unlock token. Only after unlock can it be traded.&#13;
    */&#13;
    function unlockToken() public onlyOwner returns (bool) {&#13;
        isLock = false;&#13;
        return isLock;&#13;
    } &#13;
}&#13;
&#13;
/*&#13;
    Utilities &amp; Common Modifiers&#13;
*/&#13;
contract Utils {&#13;
    /**&#13;
        constructor&#13;
    */&#13;
    function Utils() public {&#13;
    }&#13;
    &#13;
    // validates an address - currently only checks that it isn't null&#13;
    modifier validAddress(address _address) {&#13;
        require(_address != 0x0);&#13;
        _;&#13;
    }&#13;
&#13;
    // Overflow protected math functions&#13;
&#13;
    /**&#13;
        @dev returns the sum of _x and _y, asserts if the calculation overflows&#13;
&#13;
        @param _x   value 1&#13;
        @param _y   value 2&#13;
&#13;
        @return sum&#13;
    */&#13;
    function safeAdd(uint256 _x, uint256 _y) internal pure returns (uint256) {&#13;
        uint256 z = _x + _y;&#13;
        require(z &gt;= _x);&#13;
        return z;&#13;
    }&#13;
&#13;
    /**&#13;
        @dev returns the difference of _x minus _y, asserts if the subtraction results in a negative number&#13;
&#13;
        @param _x   minuend&#13;
        @param _y   subtrahend&#13;
&#13;
        @return difference&#13;
    */&#13;
    function safeSub(uint256 _x, uint256 _y) internal pure returns (uint256) {&#13;
        require(_x &gt;= _y);&#13;
        return _x - _y;&#13;
    }&#13;
}&#13;
&#13;
/*&#13;
    Moviecoin Token&#13;
*/&#13;
contract Moviecoin is ERC20Interface, Owned, Utils {&#13;
    string name_ = 'Dayibi';  &#13;
    string  symbol_ = 'DYB';&#13;
    uint8 decimals_ = 8; &#13;
    uint256 totalSupply_ = 10 ** 18;&#13;
&#13;
    mapping (address =&gt; uint256) balances;&#13;
    mapping (address =&gt; mapping (address =&gt; uint256)) allowed;&#13;
&#13;
    function Moviecoin() public {&#13;
        balances[msg.sender] = totalSupply_;&#13;
        Transfer(0x0, msg.sender, totalSupply_);&#13;
    }&#13;
&#13;
  /**&#13;
  * @dev token's symbol&#13;
  */&#13;
  &#13;
  function name() public constant returns (string){&#13;
      return name_;&#13;
  }&#13;
  &#13;
  /**&#13;
   * @dev set token name&#13;
   */&#13;
   function setName(string _name) public onlyOwner {&#13;
       name_ = _name;&#13;
   }&#13;
&#13;
  &#13;
  /**&#13;
  * @dev token's symbol&#13;
  */&#13;
  function symbol() public constant returns (string){&#13;
      return symbol_;&#13;
  }&#13;
  &#13;
   /**&#13;
   * @dev set token symbol&#13;
   */&#13;
   function setSymbol(string _symbol) public onlyOwner {&#13;
       symbol_ = _symbol;&#13;
   }&#13;
    &#13;
  /**&#13;
  * @dev token's decimals&#13;
  */&#13;
   function decimals() public constant returns (uint){&#13;
        return decimals_;&#13;
   }&#13;
 &#13;
  /**&#13;
  * @dev total number of tokens in existence&#13;
  */&#13;
  function totalSupply() public view returns (uint256) {&#13;
    return totalSupply_;&#13;
  }&#13;
&#13;
  /**&#13;
  * @dev Get the account balance of another account with address _owner&#13;
  */&#13;
  function balanceOf(address _owner) public constant returns (uint256) {&#13;
        return balances[_owner];&#13;
  }&#13;
 &#13;
  /**&#13;
  * @dev transfer token for a specified address&#13;
  * @param _to The address to transfer to.&#13;
  * @param _value The amount to be transferred.&#13;
  */&#13;
  function transfer(address _to, uint256 _value) public isUnlock returns (bool) {&#13;
    require(_value &lt;= balances[msg.sender]);&#13;
&#13;
    // SafeMath.sub will throw if there is not enough balance.&#13;
    balances[msg.sender] = safeSub(balances[msg.sender], _value);&#13;
    balances[_to] = safeAdd(balances[_to], _value);&#13;
    Transfer(msg.sender, _to, _value);&#13;
    return true;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Transfer tokens from one address to another&#13;
   * @param _from address The address which you want to send tokens from&#13;
   * @param _to address The address which you want to transfer to&#13;
   * @param _value uint256 the amount of tokens to be transferred&#13;
   */&#13;
  function transferFrom(address _from, address _to, uint256 _value) public isUnlock returns (bool) {&#13;
    require(_value &lt;= balances[_from]);&#13;
    require(_value &lt;= allowed[_from][msg.sender]);&#13;
&#13;
    balances[_from] = safeSub(balances[_from], _value);&#13;
    balances[_to] = safeAdd(balances[_to], _value);&#13;
    allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender], _value);&#13;
    Transfer(_from, _to, _value);&#13;
    return true;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.&#13;
   *&#13;
   * Beware that changing an allowance with this method brings the risk that someone may use both the old&#13;
   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this&#13;
   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:&#13;
   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729&#13;
   * @param _spender The address which will spend the funds.&#13;
   * @param _value The amount of tokens to be spent.&#13;
   */&#13;
  function approve(address _spender, uint256 _value) public isUnlock validAddress(_spender) returns (bool) {&#13;
    allowed[msg.sender][_spender] = _value;&#13;
    Approval(msg.sender, _spender, _value);&#13;
    return true;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Function to check the amount of tokens that an owner allowed to a spender.&#13;
   * @param _owner address The address which owns the funds.&#13;
   * @param _spender address The address which will spend the funds.&#13;
   * @return A uint256 specifying the amount of tokens still available for the spender.&#13;
   */&#13;
  function allowance(address _owner, address _spender) public view returns (uint256) {&#13;
    return allowed[_owner][_spender];&#13;
  }&#13;
  &#13;
  /**&#13;
   * @dev Don't accept ETH&#13;
   */&#13;
   function () public payable {&#13;
       revert();&#13;
   }&#13;
   &#13;
   /**&#13;
    * @dev Owner can transfer out any accidentally sent ERC20 tokens&#13;
    */&#13;
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {&#13;
        return ERC20Interface(tokenAddress).transfer(owner, tokens);&#13;
    }&#13;
&#13;
}