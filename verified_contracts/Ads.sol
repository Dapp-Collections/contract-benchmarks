pragma solidity ^0.4.24;

// File: openzeppelin-solidity/contracts/ownership/Ownable.sol

/**
 * @title Ownable
 * @dev The Ownable contract has an owner address, and provides basic authorization control
 * functions, this simplifies the implementation of "user permissions".
 */
contract Ownable {
  address public owner;


  event OwnershipRenounced(address indexed previousOwner);
  event OwnershipTransferred(
    address indexed previousOwner,
    address indexed newOwner
  );


  /**
   * @dev The Ownable constructor sets the original `owner` of the contract to the sender
   * account.
   */
  constructor() public {
    owner = msg.sender;
  }

  /**
   * @dev Throws if called by any account other than the owner.
   */
  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }

  /**
   * @dev Allows the current owner to relinquish control of the contract.
   * @notice Renouncing to ownership will leave the contract without an owner.
   * It will not be possible to call the functions with the `onlyOwner`
   * modifier anymore.
   */
  function renounceOwnership() public onlyOwner {
    emit OwnershipRenounced(owner);
    owner = address(0);
  }

  /**
   * @dev Allows the current owner to transfer control of the contract to a newOwner.
   * @param _newOwner The address to transfer ownership to.
   */
  function transferOwnership(address _newOwner) public onlyOwner {
    _transferOwnership(_newOwner);
  }

  /**
   * @dev Transfers control of the contract to a newOwner.
   * @param _newOwner The address to transfer ownership to.
   */
  function _transferOwnership(address _newOwner) internal {
    require(_newOwner != address(0));
    emit OwnershipTransferred(owner, _newOwner);
    owner = _newOwner;
  }
}

// File: openzeppelin-solidity/contracts/lifecycle/Pausable.sol

/**
 * @title Pausable
 * @dev Base contract which allows children to implement an emergency stop mechanism.
 */
contract Pausable is Ownable {
  event Pause();
  event Unpause();

  bool public paused = false;


  /**
   * @dev Modifier to make a function callable only when the contract is not paused.
   */
  modifier whenNotPaused() {
    require(!paused);
    _;
  }

  /**
   * @dev Modifier to make a function callable only when the contract is paused.
   */
  modifier whenPaused() {
    require(paused);
    _;
  }

  /**
   * @dev called by the owner to pause, triggers stopped state
   */
  function pause() public onlyOwner whenNotPaused {
    paused = true;
    emit Pause();
  }

  /**
   * @dev called by the owner to unpause, returns to normal state
   */
  function unpause() public onlyOwner whenPaused {
    paused = false;
    emit Unpause();
  }
}

// File: openzeppelin-solidity/contracts/ownership/HasNoEther.sol

/**
 * @title Contracts that should not own Ether
 * @author Remco Bloemen <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="1f6d7a727c705f2d">[email protected]</a>π.com&gt;&#13;
 * @dev This tries to block incoming ether to prevent accidental loss of Ether. Should Ether end up&#13;
 * in the contract, it will allow the owner to reclaim this Ether.&#13;
 * @notice Ether can still be sent to this contract by:&#13;
 * calling functions labeled `payable`&#13;
 * `selfdestruct(contract_address)`&#13;
 * mining directly to the contract address&#13;
 */&#13;
contract HasNoEther is Ownable {&#13;
&#13;
  /**&#13;
  * @dev Constructor that rejects incoming Ether&#13;
  * The `payable` flag is added so we can access `msg.value` without compiler warning. If we&#13;
  * leave out payable, then Solidity will allow inheriting contracts to implement a payable&#13;
  * constructor. By doing it this way we prevent a payable constructor from working. Alternatively&#13;
  * we could use assembly to access msg.value.&#13;
  */&#13;
  constructor() public payable {&#13;
    require(msg.value == 0);&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Disallows direct send by setting a default function without the `payable` flag.&#13;
   */&#13;
  function() external {&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Transfer all Ether held by the contract to the owner.&#13;
   */&#13;
  function reclaimEther() external onlyOwner {&#13;
    owner.transfer(address(this).balance);&#13;
  }&#13;
}&#13;
&#13;
// File: openzeppelin-solidity/contracts/lifecycle/Destructible.sol&#13;
&#13;
/**&#13;
 * @title Destructible&#13;
 * @dev Base contract that can be destroyed by owner. All funds in contract will be sent to the owner.&#13;
 */&#13;
contract Destructible is Ownable {&#13;
  /**&#13;
   * @dev Transfers the current balance to the owner and terminates the contract.&#13;
   */&#13;
  function destroy() public onlyOwner {&#13;
    selfdestruct(owner);&#13;
  }&#13;
&#13;
  function destroyAndSend(address _recipient) public onlyOwner {&#13;
    selfdestruct(_recipient);&#13;
  }&#13;
}&#13;
&#13;
// File: openzeppelin-solidity/contracts/math/SafeMath.sol&#13;
&#13;
/**&#13;
 * @title SafeMath&#13;
 * @dev Math operations with safety checks that throw on error&#13;
 */&#13;
library SafeMath {&#13;
&#13;
  /**&#13;
  * @dev Multiplies two numbers, throws on overflow.&#13;
  */&#13;
  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {&#13;
    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the&#13;
    // benefit is lost if 'b' is also tested.&#13;
    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522&#13;
    if (_a == 0) {&#13;
      return 0;&#13;
    }&#13;
&#13;
    c = _a * _b;&#13;
    assert(c / _a == _b);&#13;
    return c;&#13;
  }&#13;
&#13;
  /**&#13;
  * @dev Integer division of two numbers, truncating the quotient.&#13;
  */&#13;
  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {&#13;
    // assert(_b &gt; 0); // Solidity automatically throws when dividing by 0&#13;
    // uint256 c = _a / _b;&#13;
    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold&#13;
    return _a / _b;&#13;
  }&#13;
&#13;
  /**&#13;
  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).&#13;
  */&#13;
  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {&#13;
    assert(_b &lt;= _a);&#13;
    return _a - _b;&#13;
  }&#13;
&#13;
  /**&#13;
  * @dev Adds two numbers, throws on overflow.&#13;
  */&#13;
  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {&#13;
    c = _a + _b;&#13;
    assert(c &gt;= _a);&#13;
    return c;&#13;
  }&#13;
}&#13;
&#13;
// File: openzeppelin-solidity/contracts/introspection/ERC165.sol&#13;
&#13;
/**&#13;
 * @title ERC165&#13;
 * @dev https://github.com/ethereum/EIPs/blob/master/EIPS/eip-165.md&#13;
 */&#13;
interface ERC165 {&#13;
&#13;
  /**&#13;
   * @notice Query if a contract implements an interface&#13;
   * @param _interfaceId The interface identifier, as specified in ERC-165&#13;
   * @dev Interface identification is specified in ERC-165. This function&#13;
   * uses less than 30,000 gas.&#13;
   */&#13;
  function supportsInterface(bytes4 _interfaceId)&#13;
    external&#13;
    view&#13;
    returns (bool);&#13;
}&#13;
&#13;
// File: openzeppelin-solidity/contracts/token/ERC721/ERC721Basic.sol&#13;
&#13;
/**&#13;
 * @title ERC721 Non-Fungible Token Standard basic interface&#13;
 * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md&#13;
 */&#13;
contract ERC721Basic is ERC165 {&#13;
&#13;
  bytes4 internal constant InterfaceId_ERC721 = 0x80ac58cd;&#13;
  /*&#13;
   * 0x80ac58cd ===&#13;
   *   bytes4(keccak256('balanceOf(address)')) ^&#13;
   *   bytes4(keccak256('ownerOf(uint256)')) ^&#13;
   *   bytes4(keccak256('approve(address,uint256)')) ^&#13;
   *   bytes4(keccak256('getApproved(uint256)')) ^&#13;
   *   bytes4(keccak256('setApprovalForAll(address,bool)')) ^&#13;
   *   bytes4(keccak256('isApprovedForAll(address,address)')) ^&#13;
   *   bytes4(keccak256('transferFrom(address,address,uint256)')) ^&#13;
   *   bytes4(keccak256('safeTransferFrom(address,address,uint256)')) ^&#13;
   *   bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)'))&#13;
   */&#13;
&#13;
  bytes4 internal constant InterfaceId_ERC721Exists = 0x4f558e79;&#13;
  /*&#13;
   * 0x4f558e79 ===&#13;
   *   bytes4(keccak256('exists(uint256)'))&#13;
   */&#13;
&#13;
  bytes4 internal constant InterfaceId_ERC721Enumerable = 0x780e9d63;&#13;
  /**&#13;
   * 0x780e9d63 ===&#13;
   *   bytes4(keccak256('totalSupply()')) ^&#13;
   *   bytes4(keccak256('tokenOfOwnerByIndex(address,uint256)')) ^&#13;
   *   bytes4(keccak256('tokenByIndex(uint256)'))&#13;
   */&#13;
&#13;
  bytes4 internal constant InterfaceId_ERC721Metadata = 0x5b5e139f;&#13;
  /**&#13;
   * 0x5b5e139f ===&#13;
   *   bytes4(keccak256('name()')) ^&#13;
   *   bytes4(keccak256('symbol()')) ^&#13;
   *   bytes4(keccak256('tokenURI(uint256)'))&#13;
   */&#13;
&#13;
  event Transfer(&#13;
    address indexed _from,&#13;
    address indexed _to,&#13;
    uint256 indexed _tokenId&#13;
  );&#13;
  event Approval(&#13;
    address indexed _owner,&#13;
    address indexed _approved,&#13;
    uint256 indexed _tokenId&#13;
  );&#13;
  event ApprovalForAll(&#13;
    address indexed _owner,&#13;
    address indexed _operator,&#13;
    bool _approved&#13;
  );&#13;
&#13;
  function balanceOf(address _owner) public view returns (uint256 _balance);&#13;
  function ownerOf(uint256 _tokenId) public view returns (address _owner);&#13;
  function exists(uint256 _tokenId) public view returns (bool _exists);&#13;
&#13;
  function approve(address _to, uint256 _tokenId) public;&#13;
  function getApproved(uint256 _tokenId)&#13;
    public view returns (address _operator);&#13;
&#13;
  function setApprovalForAll(address _operator, bool _approved) public;&#13;
  function isApprovedForAll(address _owner, address _operator)&#13;
    public view returns (bool);&#13;
&#13;
  function transferFrom(address _from, address _to, uint256 _tokenId) public;&#13;
  function safeTransferFrom(address _from, address _to, uint256 _tokenId)&#13;
    public;&#13;
&#13;
  function safeTransferFrom(&#13;
    address _from,&#13;
    address _to,&#13;
    uint256 _tokenId,&#13;
    bytes _data&#13;
  )&#13;
    public;&#13;
}&#13;
&#13;
// File: openzeppelin-solidity/contracts/token/ERC721/ERC721.sol&#13;
&#13;
/**&#13;
 * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension&#13;
 * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md&#13;
 */&#13;
contract ERC721Enumerable is ERC721Basic {&#13;
  function totalSupply() public view returns (uint256);&#13;
  function tokenOfOwnerByIndex(&#13;
    address _owner,&#13;
    uint256 _index&#13;
  )&#13;
    public&#13;
    view&#13;
    returns (uint256 _tokenId);&#13;
&#13;
  function tokenByIndex(uint256 _index) public view returns (uint256);&#13;
}&#13;
&#13;
&#13;
/**&#13;
 * @title ERC-721 Non-Fungible Token Standard, optional metadata extension&#13;
 * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md&#13;
 */&#13;
contract ERC721Metadata is ERC721Basic {&#13;
  function name() external view returns (string _name);&#13;
  function symbol() external view returns (string _symbol);&#13;
  function tokenURI(uint256 _tokenId) public view returns (string);&#13;
}&#13;
&#13;
&#13;
/**&#13;
 * @title ERC-721 Non-Fungible Token Standard, full implementation interface&#13;
 * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md&#13;
 */&#13;
contract ERC721 is ERC721Basic, ERC721Enumerable, ERC721Metadata {&#13;
}&#13;
&#13;
// File: openzeppelin-solidity/contracts/token/ERC721/ERC721Receiver.sol&#13;
&#13;
/**&#13;
 * @title ERC721 token receiver interface&#13;
 * @dev Interface for any contract that wants to support safeTransfers&#13;
 * from ERC721 asset contracts.&#13;
 */&#13;
contract ERC721Receiver {&#13;
  /**&#13;
   * @dev Magic value to be returned upon successful reception of an NFT&#13;
   *  Equals to `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`,&#13;
   *  which can be also obtained as `ERC721Receiver(0).onERC721Received.selector`&#13;
   */&#13;
  bytes4 internal constant ERC721_RECEIVED = 0x150b7a02;&#13;
&#13;
  /**&#13;
   * @notice Handle the receipt of an NFT&#13;
   * @dev The ERC721 smart contract calls this function on the recipient&#13;
   * after a `safetransfer`. This function MAY throw to revert and reject the&#13;
   * transfer. Return of other than the magic value MUST result in the&#13;
   * transaction being reverted.&#13;
   * Note: the contract address is always the message sender.&#13;
   * @param _operator The address which called `safeTransferFrom` function&#13;
   * @param _from The address which previously owned the token&#13;
   * @param _tokenId The NFT identifier which is being transferred&#13;
   * @param _data Additional data with no specified format&#13;
   * @return `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`&#13;
   */&#13;
  function onERC721Received(&#13;
    address _operator,&#13;
    address _from,&#13;
    uint256 _tokenId,&#13;
    bytes _data&#13;
  )&#13;
    public&#13;
    returns(bytes4);&#13;
}&#13;
&#13;
// File: openzeppelin-solidity/contracts/AddressUtils.sol&#13;
&#13;
/**&#13;
 * Utility library of inline functions on addresses&#13;
 */&#13;
library AddressUtils {&#13;
&#13;
  /**&#13;
   * Returns whether the target address is a contract&#13;
   * @dev This function will return false if invoked during the constructor of a contract,&#13;
   * as the code is not actually created until after the constructor finishes.&#13;
   * @param _addr address to check&#13;
   * @return whether the target address is a contract&#13;
   */&#13;
  function isContract(address _addr) internal view returns (bool) {&#13;
    uint256 size;&#13;
    // XXX Currently there is no better way to check if there is a contract in an address&#13;
    // than to check the size of the code at that address.&#13;
    // See https://ethereum.stackexchange.com/a/14016/36603&#13;
    // for more details about how this works.&#13;
    // TODO Check this again before the Serenity release, because all addresses will be&#13;
    // contracts then.&#13;
    // solium-disable-next-line security/no-inline-assembly&#13;
    assembly { size := extcodesize(_addr) }&#13;
    return size &gt; 0;&#13;
  }&#13;
&#13;
}&#13;
&#13;
// File: openzeppelin-solidity/contracts/introspection/SupportsInterfaceWithLookup.sol&#13;
&#13;
/**&#13;
 * @title SupportsInterfaceWithLookup&#13;
 * @author Matt Condon (@shrugs)&#13;
 * @dev Implements ERC165 using a lookup table.&#13;
 */&#13;
contract SupportsInterfaceWithLookup is ERC165 {&#13;
&#13;
  bytes4 public constant InterfaceId_ERC165 = 0x01ffc9a7;&#13;
  /**&#13;
   * 0x01ffc9a7 ===&#13;
   *   bytes4(keccak256('supportsInterface(bytes4)'))&#13;
   */&#13;
&#13;
  /**&#13;
   * @dev a mapping of interface id to whether or not it's supported&#13;
   */&#13;
  mapping(bytes4 =&gt; bool) internal supportedInterfaces;&#13;
&#13;
  /**&#13;
   * @dev A contract implementing SupportsInterfaceWithLookup&#13;
   * implement ERC165 itself&#13;
   */&#13;
  constructor()&#13;
    public&#13;
  {&#13;
    _registerInterface(InterfaceId_ERC165);&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev implement supportsInterface(bytes4) using a lookup table&#13;
   */&#13;
  function supportsInterface(bytes4 _interfaceId)&#13;
    external&#13;
    view&#13;
    returns (bool)&#13;
  {&#13;
    return supportedInterfaces[_interfaceId];&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev private method for registering an interface&#13;
   */&#13;
  function _registerInterface(bytes4 _interfaceId)&#13;
    internal&#13;
  {&#13;
    require(_interfaceId != 0xffffffff);&#13;
    supportedInterfaces[_interfaceId] = true;&#13;
  }&#13;
}&#13;
&#13;
// File: openzeppelin-solidity/contracts/token/ERC721/ERC721BasicToken.sol&#13;
&#13;
/**&#13;
 * @title ERC721 Non-Fungible Token Standard basic implementation&#13;
 * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md&#13;
 */&#13;
contract ERC721BasicToken is SupportsInterfaceWithLookup, ERC721Basic {&#13;
&#13;
  using SafeMath for uint256;&#13;
  using AddressUtils for address;&#13;
&#13;
  // Equals to `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`&#13;
  // which can be also obtained as `ERC721Receiver(0).onERC721Received.selector`&#13;
  bytes4 private constant ERC721_RECEIVED = 0x150b7a02;&#13;
&#13;
  // Mapping from token ID to owner&#13;
  mapping (uint256 =&gt; address) internal tokenOwner;&#13;
&#13;
  // Mapping from token ID to approved address&#13;
  mapping (uint256 =&gt; address) internal tokenApprovals;&#13;
&#13;
  // Mapping from owner to number of owned token&#13;
  mapping (address =&gt; uint256) internal ownedTokensCount;&#13;
&#13;
  // Mapping from owner to operator approvals&#13;
  mapping (address =&gt; mapping (address =&gt; bool)) internal operatorApprovals;&#13;
&#13;
  constructor()&#13;
    public&#13;
  {&#13;
    // register the supported interfaces to conform to ERC721 via ERC165&#13;
    _registerInterface(InterfaceId_ERC721);&#13;
    _registerInterface(InterfaceId_ERC721Exists);&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Gets the balance of the specified address&#13;
   * @param _owner address to query the balance of&#13;
   * @return uint256 representing the amount owned by the passed address&#13;
   */&#13;
  function balanceOf(address _owner) public view returns (uint256) {&#13;
    require(_owner != address(0));&#13;
    return ownedTokensCount[_owner];&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Gets the owner of the specified token ID&#13;
   * @param _tokenId uint256 ID of the token to query the owner of&#13;
   * @return owner address currently marked as the owner of the given token ID&#13;
   */&#13;
  function ownerOf(uint256 _tokenId) public view returns (address) {&#13;
    address owner = tokenOwner[_tokenId];&#13;
    require(owner != address(0));&#13;
    return owner;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Returns whether the specified token exists&#13;
   * @param _tokenId uint256 ID of the token to query the existence of&#13;
   * @return whether the token exists&#13;
   */&#13;
  function exists(uint256 _tokenId) public view returns (bool) {&#13;
    address owner = tokenOwner[_tokenId];&#13;
    return owner != address(0);&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Approves another address to transfer the given token ID&#13;
   * The zero address indicates there is no approved address.&#13;
   * There can only be one approved address per token at a given time.&#13;
   * Can only be called by the token owner or an approved operator.&#13;
   * @param _to address to be approved for the given token ID&#13;
   * @param _tokenId uint256 ID of the token to be approved&#13;
   */&#13;
  function approve(address _to, uint256 _tokenId) public {&#13;
    address owner = ownerOf(_tokenId);&#13;
    require(_to != owner);&#13;
    require(msg.sender == owner || isApprovedForAll(owner, msg.sender));&#13;
&#13;
    tokenApprovals[_tokenId] = _to;&#13;
    emit Approval(owner, _to, _tokenId);&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Gets the approved address for a token ID, or zero if no address set&#13;
   * @param _tokenId uint256 ID of the token to query the approval of&#13;
   * @return address currently approved for the given token ID&#13;
   */&#13;
  function getApproved(uint256 _tokenId) public view returns (address) {&#13;
    return tokenApprovals[_tokenId];&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Sets or unsets the approval of a given operator&#13;
   * An operator is allowed to transfer all tokens of the sender on their behalf&#13;
   * @param _to operator address to set the approval&#13;
   * @param _approved representing the status of the approval to be set&#13;
   */&#13;
  function setApprovalForAll(address _to, bool _approved) public {&#13;
    require(_to != msg.sender);&#13;
    operatorApprovals[msg.sender][_to] = _approved;&#13;
    emit ApprovalForAll(msg.sender, _to, _approved);&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Tells whether an operator is approved by a given owner&#13;
   * @param _owner owner address which you want to query the approval of&#13;
   * @param _operator operator address which you want to query the approval of&#13;
   * @return bool whether the given operator is approved by the given owner&#13;
   */&#13;
  function isApprovedForAll(&#13;
    address _owner,&#13;
    address _operator&#13;
  )&#13;
    public&#13;
    view&#13;
    returns (bool)&#13;
  {&#13;
    return operatorApprovals[_owner][_operator];&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Transfers the ownership of a given token ID to another address&#13;
   * Usage of this method is discouraged, use `safeTransferFrom` whenever possible&#13;
   * Requires the msg sender to be the owner, approved, or operator&#13;
   * @param _from current owner of the token&#13;
   * @param _to address to receive the ownership of the given token ID&#13;
   * @param _tokenId uint256 ID of the token to be transferred&#13;
  */&#13;
  function transferFrom(&#13;
    address _from,&#13;
    address _to,&#13;
    uint256 _tokenId&#13;
  )&#13;
    public&#13;
  {&#13;
    require(isApprovedOrOwner(msg.sender, _tokenId));&#13;
    require(_from != address(0));&#13;
    require(_to != address(0));&#13;
&#13;
    clearApproval(_from, _tokenId);&#13;
    removeTokenFrom(_from, _tokenId);&#13;
    addTokenTo(_to, _tokenId);&#13;
&#13;
    emit Transfer(_from, _to, _tokenId);&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Safely transfers the ownership of a given token ID to another address&#13;
   * If the target address is a contract, it must implement `onERC721Received`,&#13;
   * which is called upon a safe transfer, and return the magic value&#13;
   * `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`; otherwise,&#13;
   * the transfer is reverted.&#13;
   *&#13;
   * Requires the msg sender to be the owner, approved, or operator&#13;
   * @param _from current owner of the token&#13;
   * @param _to address to receive the ownership of the given token ID&#13;
   * @param _tokenId uint256 ID of the token to be transferred&#13;
  */&#13;
  function safeTransferFrom(&#13;
    address _from,&#13;
    address _to,&#13;
    uint256 _tokenId&#13;
  )&#13;
    public&#13;
  {&#13;
    // solium-disable-next-line arg-overflow&#13;
    safeTransferFrom(_from, _to, _tokenId, "");&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Safely transfers the ownership of a given token ID to another address&#13;
   * If the target address is a contract, it must implement `onERC721Received`,&#13;
   * which is called upon a safe transfer, and return the magic value&#13;
   * `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`; otherwise,&#13;
   * the transfer is reverted.&#13;
   * Requires the msg sender to be the owner, approved, or operator&#13;
   * @param _from current owner of the token&#13;
   * @param _to address to receive the ownership of the given token ID&#13;
   * @param _tokenId uint256 ID of the token to be transferred&#13;
   * @param _data bytes data to send along with a safe transfer check&#13;
   */&#13;
  function safeTransferFrom(&#13;
    address _from,&#13;
    address _to,&#13;
    uint256 _tokenId,&#13;
    bytes _data&#13;
  )&#13;
    public&#13;
  {&#13;
    transferFrom(_from, _to, _tokenId);&#13;
    // solium-disable-next-line arg-overflow&#13;
    require(checkAndCallSafeTransfer(_from, _to, _tokenId, _data));&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Returns whether the given spender can transfer a given token ID&#13;
   * @param _spender address of the spender to query&#13;
   * @param _tokenId uint256 ID of the token to be transferred&#13;
   * @return bool whether the msg.sender is approved for the given token ID,&#13;
   *  is an operator of the owner, or is the owner of the token&#13;
   */&#13;
  function isApprovedOrOwner(&#13;
    address _spender,&#13;
    uint256 _tokenId&#13;
  )&#13;
    internal&#13;
    view&#13;
    returns (bool)&#13;
  {&#13;
    address owner = ownerOf(_tokenId);&#13;
    // Disable solium check because of&#13;
    // https://github.com/duaraghav8/Solium/issues/175&#13;
    // solium-disable-next-line operator-whitespace&#13;
    return (&#13;
      _spender == owner ||&#13;
      getApproved(_tokenId) == _spender ||&#13;
      isApprovedForAll(owner, _spender)&#13;
    );&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Internal function to mint a new token&#13;
   * Reverts if the given token ID already exists&#13;
   * @param _to The address that will own the minted token&#13;
   * @param _tokenId uint256 ID of the token to be minted by the msg.sender&#13;
   */&#13;
  function _mint(address _to, uint256 _tokenId) internal {&#13;
    require(_to != address(0));&#13;
    addTokenTo(_to, _tokenId);&#13;
    emit Transfer(address(0), _to, _tokenId);&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Internal function to burn a specific token&#13;
   * Reverts if the token does not exist&#13;
   * @param _tokenId uint256 ID of the token being burned by the msg.sender&#13;
   */&#13;
  function _burn(address _owner, uint256 _tokenId) internal {&#13;
    clearApproval(_owner, _tokenId);&#13;
    removeTokenFrom(_owner, _tokenId);&#13;
    emit Transfer(_owner, address(0), _tokenId);&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Internal function to clear current approval of a given token ID&#13;
   * Reverts if the given address is not indeed the owner of the token&#13;
   * @param _owner owner of the token&#13;
   * @param _tokenId uint256 ID of the token to be transferred&#13;
   */&#13;
  function clearApproval(address _owner, uint256 _tokenId) internal {&#13;
    require(ownerOf(_tokenId) == _owner);&#13;
    if (tokenApprovals[_tokenId] != address(0)) {&#13;
      tokenApprovals[_tokenId] = address(0);&#13;
    }&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Internal function to add a token ID to the list of a given address&#13;
   * @param _to address representing the new owner of the given token ID&#13;
   * @param _tokenId uint256 ID of the token to be added to the tokens list of the given address&#13;
   */&#13;
  function addTokenTo(address _to, uint256 _tokenId) internal {&#13;
    require(tokenOwner[_tokenId] == address(0));&#13;
    tokenOwner[_tokenId] = _to;&#13;
    ownedTokensCount[_to] = ownedTokensCount[_to].add(1);&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Internal function to remove a token ID from the list of a given address&#13;
   * @param _from address representing the previous owner of the given token ID&#13;
   * @param _tokenId uint256 ID of the token to be removed from the tokens list of the given address&#13;
   */&#13;
  function removeTokenFrom(address _from, uint256 _tokenId) internal {&#13;
    require(ownerOf(_tokenId) == _from);&#13;
    ownedTokensCount[_from] = ownedTokensCount[_from].sub(1);&#13;
    tokenOwner[_tokenId] = address(0);&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Internal function to invoke `onERC721Received` on a target address&#13;
   * The call is not executed if the target address is not a contract&#13;
   * @param _from address representing the previous owner of the given token ID&#13;
   * @param _to target address that will receive the tokens&#13;
   * @param _tokenId uint256 ID of the token to be transferred&#13;
   * @param _data bytes optional data to send along with the call&#13;
   * @return whether the call correctly returned the expected magic value&#13;
   */&#13;
  function checkAndCallSafeTransfer(&#13;
    address _from,&#13;
    address _to,&#13;
    uint256 _tokenId,&#13;
    bytes _data&#13;
  )&#13;
    internal&#13;
    returns (bool)&#13;
  {&#13;
    if (!_to.isContract()) {&#13;
      return true;&#13;
    }&#13;
    bytes4 retval = ERC721Receiver(_to).onERC721Received(&#13;
      msg.sender, _from, _tokenId, _data);&#13;
    return (retval == ERC721_RECEIVED);&#13;
  }&#13;
}&#13;
&#13;
// File: openzeppelin-solidity/contracts/token/ERC721/ERC721Token.sol&#13;
&#13;
/**&#13;
 * @title Full ERC721 Token&#13;
 * This implementation includes all the required and some optional functionality of the ERC721 standard&#13;
 * Moreover, it includes approve all functionality using operator terminology&#13;
 * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md&#13;
 */&#13;
contract ERC721Token is SupportsInterfaceWithLookup, ERC721BasicToken, ERC721 {&#13;
&#13;
  // Token name&#13;
  string internal name_;&#13;
&#13;
  // Token symbol&#13;
  string internal symbol_;&#13;
&#13;
  // Mapping from owner to list of owned token IDs&#13;
  mapping(address =&gt; uint256[]) internal ownedTokens;&#13;
&#13;
  // Mapping from token ID to index of the owner tokens list&#13;
  mapping(uint256 =&gt; uint256) internal ownedTokensIndex;&#13;
&#13;
  // Array with all token ids, used for enumeration&#13;
  uint256[] internal allTokens;&#13;
&#13;
  // Mapping from token id to position in the allTokens array&#13;
  mapping(uint256 =&gt; uint256) internal allTokensIndex;&#13;
&#13;
  // Optional mapping for token URIs&#13;
  mapping(uint256 =&gt; string) internal tokenURIs;&#13;
&#13;
  /**&#13;
   * @dev Constructor function&#13;
   */&#13;
  constructor(string _name, string _symbol) public {&#13;
    name_ = _name;&#13;
    symbol_ = _symbol;&#13;
&#13;
    // register the supported interfaces to conform to ERC721 via ERC165&#13;
    _registerInterface(InterfaceId_ERC721Enumerable);&#13;
    _registerInterface(InterfaceId_ERC721Metadata);&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Gets the token name&#13;
   * @return string representing the token name&#13;
   */&#13;
  function name() external view returns (string) {&#13;
    return name_;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Gets the token symbol&#13;
   * @return string representing the token symbol&#13;
   */&#13;
  function symbol() external view returns (string) {&#13;
    return symbol_;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Returns an URI for a given token ID&#13;
   * Throws if the token ID does not exist. May return an empty string.&#13;
   * @param _tokenId uint256 ID of the token to query&#13;
   */&#13;
  function tokenURI(uint256 _tokenId) public view returns (string) {&#13;
    require(exists(_tokenId));&#13;
    return tokenURIs[_tokenId];&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Gets the token ID at a given index of the tokens list of the requested owner&#13;
   * @param _owner address owning the tokens list to be accessed&#13;
   * @param _index uint256 representing the index to be accessed of the requested tokens list&#13;
   * @return uint256 token ID at the given index of the tokens list owned by the requested address&#13;
   */&#13;
  function tokenOfOwnerByIndex(&#13;
    address _owner,&#13;
    uint256 _index&#13;
  )&#13;
    public&#13;
    view&#13;
    returns (uint256)&#13;
  {&#13;
    require(_index &lt; balanceOf(_owner));&#13;
    return ownedTokens[_owner][_index];&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Gets the total amount of tokens stored by the contract&#13;
   * @return uint256 representing the total amount of tokens&#13;
   */&#13;
  function totalSupply() public view returns (uint256) {&#13;
    return allTokens.length;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Gets the token ID at a given index of all the tokens in this contract&#13;
   * Reverts if the index is greater or equal to the total number of tokens&#13;
   * @param _index uint256 representing the index to be accessed of the tokens list&#13;
   * @return uint256 token ID at the given index of the tokens list&#13;
   */&#13;
  function tokenByIndex(uint256 _index) public view returns (uint256) {&#13;
    require(_index &lt; totalSupply());&#13;
    return allTokens[_index];&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Internal function to set the token URI for a given token&#13;
   * Reverts if the token ID does not exist&#13;
   * @param _tokenId uint256 ID of the token to set its URI&#13;
   * @param _uri string URI to assign&#13;
   */&#13;
  function _setTokenURI(uint256 _tokenId, string _uri) internal {&#13;
    require(exists(_tokenId));&#13;
    tokenURIs[_tokenId] = _uri;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Internal function to add a token ID to the list of a given address&#13;
   * @param _to address representing the new owner of the given token ID&#13;
   * @param _tokenId uint256 ID of the token to be added to the tokens list of the given address&#13;
   */&#13;
  function addTokenTo(address _to, uint256 _tokenId) internal {&#13;
    super.addTokenTo(_to, _tokenId);&#13;
    uint256 length = ownedTokens[_to].length;&#13;
    ownedTokens[_to].push(_tokenId);&#13;
    ownedTokensIndex[_tokenId] = length;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Internal function to remove a token ID from the list of a given address&#13;
   * @param _from address representing the previous owner of the given token ID&#13;
   * @param _tokenId uint256 ID of the token to be removed from the tokens list of the given address&#13;
   */&#13;
  function removeTokenFrom(address _from, uint256 _tokenId) internal {&#13;
    super.removeTokenFrom(_from, _tokenId);&#13;
&#13;
    // To prevent a gap in the array, we store the last token in the index of the token to delete, and&#13;
    // then delete the last slot.&#13;
    uint256 tokenIndex = ownedTokensIndex[_tokenId];&#13;
    uint256 lastTokenIndex = ownedTokens[_from].length.sub(1);&#13;
    uint256 lastToken = ownedTokens[_from][lastTokenIndex];&#13;
&#13;
    ownedTokens[_from][tokenIndex] = lastToken;&#13;
    // This also deletes the contents at the last position of the array&#13;
    ownedTokens[_from].length--;&#13;
&#13;
    // Note that this will handle single-element arrays. In that case, both tokenIndex and lastTokenIndex are going to&#13;
    // be zero. Then we can make sure that we will remove _tokenId from the ownedTokens list since we are first swapping&#13;
    // the lastToken to the first position, and then dropping the element placed in the last position of the list&#13;
&#13;
    ownedTokensIndex[_tokenId] = 0;&#13;
    ownedTokensIndex[lastToken] = tokenIndex;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Internal function to mint a new token&#13;
   * Reverts if the given token ID already exists&#13;
   * @param _to address the beneficiary that will own the minted token&#13;
   * @param _tokenId uint256 ID of the token to be minted by the msg.sender&#13;
   */&#13;
  function _mint(address _to, uint256 _tokenId) internal {&#13;
    super._mint(_to, _tokenId);&#13;
&#13;
    allTokensIndex[_tokenId] = allTokens.length;&#13;
    allTokens.push(_tokenId);&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Internal function to burn a specific token&#13;
   * Reverts if the token does not exist&#13;
   * @param _owner owner of the token to burn&#13;
   * @param _tokenId uint256 ID of the token being burned by the msg.sender&#13;
   */&#13;
  function _burn(address _owner, uint256 _tokenId) internal {&#13;
    super._burn(_owner, _tokenId);&#13;
&#13;
    // Clear metadata (if any)&#13;
    if (bytes(tokenURIs[_tokenId]).length != 0) {&#13;
      delete tokenURIs[_tokenId];&#13;
    }&#13;
&#13;
    // Reorg all tokens array&#13;
    uint256 tokenIndex = allTokensIndex[_tokenId];&#13;
    uint256 lastTokenIndex = allTokens.length.sub(1);&#13;
    uint256 lastToken = allTokens[lastTokenIndex];&#13;
&#13;
    allTokens[tokenIndex] = lastToken;&#13;
    allTokens[lastTokenIndex] = 0;&#13;
&#13;
    allTokens.length--;&#13;
    allTokensIndex[_tokenId] = 0;&#13;
    allTokensIndex[lastToken] = tokenIndex;&#13;
  }&#13;
&#13;
}&#13;
&#13;
// File: contracts/MEHAccessControl.sol&#13;
&#13;
contract MarketInerface {&#13;
    function buyBlocks(address, uint16[]) external returns (uint) {}&#13;
    function sellBlocks(address, uint, uint16[]) external returns (uint) {}&#13;
    function isMarket() public view returns (bool) {}&#13;
    function isOnSale(uint16) public view returns (bool) {}&#13;
    function areaPrice(uint16[]) public view returns (uint) {}&#13;
    function importOldMEBlock(uint8, uint8) external returns (uint, address) {}&#13;
}&#13;
&#13;
contract RentalsInterface {&#13;
    function rentOutBlocks(address, uint, uint16[]) external returns (uint) {}&#13;
    function rentBlocks(address, uint, uint16[]) external returns (uint) {}&#13;
    function blocksRentPrice(uint, uint16[]) external view returns (uint) {}&#13;
    function isRentals() public view returns (bool) {}&#13;
    function isRented(uint16) public view returns (bool) {}&#13;
    function renterOf(uint16) public view returns (address) {}&#13;
}&#13;
&#13;
contract AdsInterface {&#13;
    function advertiseOnBlocks(address, uint16[], string, string, string) external returns (uint) {}&#13;
    function canAdvertiseOnBlocks(address, uint16[]) public view returns (bool) {}&#13;
    function isAds() public view returns (bool) {}&#13;
}&#13;
&#13;
/// @title MEHAccessControl: Part of MEH contract responsible for communication with external modules:&#13;
///  Market, Rentals, Ads contracts. Provides authorization and upgradability methods.&#13;
contract MEHAccessControl is Pausable {&#13;
&#13;
    // Allows a module being plugged in to verify it is MEH contract. &#13;
    bool public isMEH = true;&#13;
&#13;
    // Modules&#13;
    MarketInerface public market;&#13;
    RentalsInterface public rentals;&#13;
    AdsInterface public ads;&#13;
&#13;
    // Emitted when a module is plugged.&#13;
    event LogModuleUpgrade(address newAddress, string moduleName);&#13;
    &#13;
// GUARDS&#13;
    &#13;
    /// @dev Functions allowed to market module only. &#13;
    modifier onlyMarket() {&#13;
        require(msg.sender == address(market));&#13;
        _;&#13;
    }&#13;
&#13;
    /// @dev Functions allowed to balance operators only (market and rentals contracts are the &#13;
    ///  only balance operators)&#13;
    modifier onlyBalanceOperators() {&#13;
        require(msg.sender == address(market) || msg.sender == address(rentals));&#13;
        _;&#13;
    }&#13;
&#13;
// ** Admin set Access ** //&#13;
    /// @dev Allows admin to plug a new Market contract in.&#13;
    // credits to cryptokittes! - https://github.com/Lunyr/crowdsale-contracts/blob/cfadd15986c30521d8ba7d5b6f57b4fefcc7ac38/contracts/LunyrToken.sol#L117&#13;
    // NOTE: verify that a contract is what we expect&#13;
    function adminSetMarket(address _address) external onlyOwner {&#13;
        MarketInerface candidateContract = MarketInerface(_address);&#13;
        require(candidateContract.isMarket());&#13;
        market = candidateContract;&#13;
        emit LogModuleUpgrade(_address, "Market");&#13;
    }&#13;
&#13;
    /// @dev Allows admin to plug a new Rentals contract in.&#13;
    function adminSetRentals(address _address) external onlyOwner {&#13;
        RentalsInterface candidateContract = RentalsInterface(_address);&#13;
        require(candidateContract.isRentals());&#13;
        rentals = candidateContract;&#13;
        emit LogModuleUpgrade(_address, "Rentals");&#13;
    }&#13;
&#13;
    /// @dev Allows admin to plug a new Ads contract in.&#13;
    function adminSetAds(address _address) external onlyOwner {&#13;
        AdsInterface candidateContract = AdsInterface(_address);&#13;
        require(candidateContract.isAds());&#13;
        ads = candidateContract;&#13;
        emit LogModuleUpgrade(_address, "Ads");&#13;
    }&#13;
}&#13;
&#13;
// File: contracts/MehERC721.sol&#13;
&#13;
// ERC721 &#13;
&#13;
&#13;
&#13;
/// @title MehERC721: Part of MEH contract responsible for ERC721 token management. Openzeppelin's&#13;
///  ERC721 implementation modified for the Million Ether Homepage. &#13;
contract MehERC721 is ERC721Token("MillionEtherHomePage","MEH"), MEHAccessControl {&#13;
&#13;
    /// @dev Checks rights to transfer block ownership. Locks tokens on sale.&#13;
    ///  Overrides OpenZEppelin's isApprovedOrOwner function - so that tokens marked for sale can &#13;
    ///  be transferred by Market contract only.&#13;
    function isApprovedOrOwner(&#13;
        address _spender,&#13;
        uint256 _tokenId&#13;
    )&#13;
        internal&#13;
        view&#13;
        returns (bool)&#13;
    {   &#13;
        bool onSale = market.isOnSale(uint16(_tokenId));&#13;
&#13;
        address owner = ownerOf(_tokenId);&#13;
        bool spenderIsApprovedOrOwner =&#13;
            _spender == owner ||&#13;
            getApproved(_tokenId) == _spender ||&#13;
            isApprovedForAll(owner, _spender);&#13;
&#13;
        return (&#13;
            (onSale &amp;&amp; _spender == address(market)) ||&#13;
            (!(onSale) &amp;&amp; spenderIsApprovedOrOwner)&#13;
        );&#13;
    }&#13;
&#13;
    /// @dev mints a new block.&#13;
    ///  overrides _mint function to add pause/unpause functionality, onlyMarket access,&#13;
    ///  restricts totalSupply of blocks to 10000 (as there is only a 100x100 blocks field).&#13;
    function _mintCrowdsaleBlock(address _to, uint16 _blockId) external onlyMarket whenNotPaused {&#13;
        if (totalSupply() &lt;= 9999) {&#13;
        _mint(_to, uint256(_blockId));&#13;
        }&#13;
    }&#13;
&#13;
    /// @dev overrides approve function to add pause/unpause functionality&#13;
    function approve(address _to, uint256 _tokenId) public whenNotPaused {&#13;
        super.approve(_to, _tokenId);&#13;
    }&#13;
 &#13;
    /// @dev overrides setApprovalForAll function to add pause/unpause functionality&#13;
    function setApprovalForAll(address _to, bool _approved) public whenNotPaused {&#13;
        super.setApprovalForAll(_to, _approved);&#13;
    }    &#13;
&#13;
    /// @dev overrides transferFrom function to add pause/unpause functionality&#13;
    ///  affects safeTransferFrom functions as well&#13;
    function transferFrom(&#13;
        address _from,&#13;
        address _to,&#13;
        uint256 _tokenId&#13;
    )&#13;
        public&#13;
        whenNotPaused&#13;
    {&#13;
        super.transferFrom(_from, _to, _tokenId);&#13;
    }&#13;
}&#13;
&#13;
// File: contracts/Accounting.sol&#13;
&#13;
// import "../installed_contracts/math.sol";&#13;
&#13;
&#13;
&#13;
// @title Accounting: Part of MEH contract responsible for eth accounting.&#13;
contract Accounting is MEHAccessControl {&#13;
    using SafeMath for uint256;&#13;
&#13;
    // Balances of users, admin, charity&#13;
    mapping(address =&gt; uint256) public balances;&#13;
&#13;
    // Emitted when a user deposits or withdraws funds from the contract&#13;
    event LogContractBalance(address payerOrPayee, int balanceChange);&#13;
&#13;
// ** PAYMENT PROCESSING ** //&#13;
    &#13;
    /// @dev Withdraws users available balance.&#13;
    function withdraw() external whenNotPaused {&#13;
        address payee = msg.sender;&#13;
        uint256 payment = balances[payee];&#13;
&#13;
        require(payment != 0);&#13;
        assert(address(this).balance &gt;= payment);&#13;
&#13;
        balances[payee] = 0;&#13;
&#13;
        // reentrancy safe&#13;
        payee.transfer(payment);&#13;
        emit LogContractBalance(payee, int256(-payment));&#13;
    }&#13;
&#13;
    /// @dev Lets external authorized contract (operators) to transfer balances within MEH contract.&#13;
    ///  MEH contract doesn't transfer funds on its own. Instead Market and Rentals contracts&#13;
    ///  are granted operator access.&#13;
    function operatorTransferFunds(&#13;
        address _payer, &#13;
        address _recipient, &#13;
        uint _amount) &#13;
    external &#13;
    onlyBalanceOperators&#13;
    whenNotPaused&#13;
    {&#13;
        require(balances[_payer] &gt;= _amount);&#13;
        _deductFrom(_payer, _amount);&#13;
        _depositTo(_recipient, _amount);&#13;
    }&#13;
&#13;
    /// @dev Deposits eth to msg.sender balance.&#13;
    function depositFunds() internal whenNotPaused {&#13;
        _depositTo(msg.sender, msg.value);&#13;
        emit LogContractBalance(msg.sender, int256(msg.value));&#13;
    }&#13;
&#13;
    /// @dev Increases recipients internal balance.&#13;
    function _depositTo(address _recipient, uint _amount) internal {&#13;
        balances[_recipient] = balances[_recipient].add(_amount);&#13;
    }&#13;
&#13;
    /// @dev Increases payers internal balance.&#13;
    function _deductFrom(address _payer, uint _amount) internal {&#13;
        balances[_payer] = balances[_payer].sub(_amount);&#13;
    }&#13;
&#13;
// ** ADMIN ** //&#13;
&#13;
    /// @notice Allows admin to withdraw contract balance in emergency. And distribute manualy&#13;
    ///  aftrewards.&#13;
    /// @dev As the contract is not designed to keep users funds (users can withdraw&#13;
    ///  at anytime) it should be relatively easy to manualy transfer unclaimed funds to &#13;
    ///  their owners. This is an alternatinve to selfdestruct allowing blocks ledger (ERC721 tokens)&#13;
    ///  to be immutable.&#13;
    function adminRescueFunds() external onlyOwner whenPaused {&#13;
        address payee = owner;&#13;
        uint256 payment = address(this).balance;&#13;
        payee.transfer(payment);&#13;
    }&#13;
&#13;
    /// @dev Checks if a msg.sender has enough balance to pay the price _needed.&#13;
    function canPay(uint _needed) internal view returns (bool) {&#13;
        return (msg.value.add(balances[msg.sender]) &gt;= _needed);&#13;
    }&#13;
}&#13;
&#13;
// File: contracts/MEH.sol&#13;
&#13;
/*&#13;
MillionEther smart contract - decentralized advertising platform.&#13;
&#13;
This program is free software: you can redistribute it and/or modifromY&#13;
it under the terms of the GNU General Public License as published by&#13;
the Free Software Foundation, either version 3 of the License, or&#13;
(at your option) any later version.&#13;
&#13;
This program is distributed in the hope that it will be useful,&#13;
but WITHOUT ANY WARRANTY; without even the implied warranty of&#13;
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&#13;
GNU General Public License for more details.&#13;
&#13;
You should have received a copy of the GNU General Public License&#13;
along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.&#13;
*/&#13;
&#13;
/*&#13;
* A 1000x1000 pixel field is displayed at TheMillionEtherHomepage.com. &#13;
* This smart contract lets anyone buy 10x10 pixel blocks and place ads there.&#13;
* It also allows to sell blocks and rent them out to other advertisers. &#13;
*&#13;
* 10x10 pixels blocks are addressed by xy coordinates. So 1000x1000 pixel field is 100 by 100 blocks.&#13;
* Making up 10 000 blocks in total. Each block is an ERC721 (non fungible token) token. &#13;
*&#13;
* At the initial sale the price for each block is $1 (price is feeded by an oracle). After&#13;
* every 1000 blocks sold (every 10%) the price doubles. Owners can sell and rent out blocks at any&#13;
* price they want. Owners and renters can place and replace ads to their blocks as many times they &#13;
* want.&#13;
*&#13;
* All heavy logic is delegated to external upgradable contracts. There are 4 main modules (contracts):&#13;
*     - MEH: Million Ether Homepage (MEH) contract. Provides user interface and accounting &#13;
*         functionality. It is immutable and it keeps Non fungible ERC721 tokens (10x10 pixel blocks) &#13;
*         ledger and eth balances. &#13;
*     - Market: Plugable. Provides methods for buy-sell functionality, keeps buy-sell ledger, &#13;
*         querries oracle for a ETH-USD price, &#13;
*     - Rentals: Plugable. Provides methods for rentout-rent functionality, keeps rentout-rent ledger.&#13;
*     - Ads: Plugable. Provides methods for image placement functionality.&#13;
* &#13;
*/&#13;
&#13;
/// @title MEH: Million Ether Homepage. Buy, sell, rent out pixels and place ads.&#13;
/// @author Peter Porobov (https://keybase.io/peterporobov)&#13;
/// @notice The main contract, accounting and user interface. Immutable.&#13;
contract MEH is MehERC721, Accounting {&#13;
&#13;
    /// @notice emited when an area blocks is bought&#13;
    event LogBuys(&#13;
        uint ID,&#13;
        uint8 fromX,&#13;
        uint8 fromY,&#13;
        uint8 toX,&#13;
        uint8 toY,&#13;
        address newLandlord&#13;
    );&#13;
&#13;
    /// @notice emited when an area blocks is marked for sale&#13;
    event LogSells(&#13;
        uint ID,&#13;
        uint8 fromX,&#13;
        uint8 fromY,&#13;
        uint8 toX,&#13;
        uint8 toY,&#13;
        uint sellPrice&#13;
    );&#13;
&#13;
    /// @notice emited when an area blocks is marked for rent&#13;
    event LogRentsOut(&#13;
        uint ID,&#13;
        uint8 fromX,&#13;
        uint8 fromY,&#13;
        uint8 toX,&#13;
        uint8 toY,&#13;
        uint rentPricePerPeriodWei&#13;
    );&#13;
&#13;
    /// @notice emited when an area blocks is rented&#13;
    event LogRents(&#13;
        uint ID,&#13;
        uint8 fromX,&#13;
        uint8 fromY,&#13;
        uint8 toX,&#13;
        uint8 toY,&#13;
        uint numberOfPeriods,&#13;
        uint rentedFrom&#13;
    );&#13;
&#13;
    /// @notice emited when an ad is placed to an area&#13;
    event LogAds(&#13;
        uint ID, &#13;
        uint8 fromX,&#13;
        uint8 fromY,&#13;
        uint8 toX,&#13;
        uint8 toY,&#13;
        string imageSourceUrl,&#13;
        string adUrl,&#13;
        string adText,&#13;
        address indexed advertiser);&#13;
&#13;
// ** BUY AND SELL BLOCKS ** //&#13;
    &#13;
    /// @notice lets a message sender to buy blocks within area&#13;
    /// @dev if using a contract to buy an area make sure to implement ERC721 functionality &#13;
    ///  as tokens are transfered using "transferFrom" function and not "safeTransferFrom"&#13;
    ///  in order to avoid external calls.&#13;
    function buyArea(uint8 fromX, uint8 fromY, uint8 toX, uint8 toY) &#13;
        external&#13;
        whenNotPaused&#13;
        payable&#13;
    {   &#13;
        // check input parameters and eth deposited&#13;
        require(isLegalCoordinates(fromX, fromY, toX, toY));&#13;
        require(canPay(areaPrice(fromX, fromY, toX, toY)));&#13;
        depositFunds();&#13;
&#13;
        // try to buy blocks through market contract&#13;
        // will get an id of buy-sell operation if succeeds (if all blocks available)&#13;
        uint id = market.buyBlocks(msg.sender, blocksList(fromX, fromY, toX, toY));&#13;
        emit LogBuys(id, fromX, fromY, toX, toY, msg.sender);&#13;
    }&#13;
&#13;
    /// @notice lets a message sender to mark blocks for sale at price set for each block in wei&#13;
    /// @dev (priceForEachBlockCents = 0 - not for sale)&#13;
    function sellArea(uint8 fromX, uint8 fromY, uint8 toX, uint8 toY, uint priceForEachBlockWei)&#13;
        external &#13;
        whenNotPaused&#13;
    {   &#13;
        // check input parameters&#13;
        require(isLegalCoordinates(fromX, fromY, toX, toY));&#13;
&#13;
        // try to mark blocks for sale through market contract&#13;
        // will get an id of buy-sell operation if succeeds (if owns all blocks)&#13;
        uint id = market.sellBlocks(&#13;
            msg.sender, &#13;
            priceForEachBlockWei, &#13;
            blocksList(fromX, fromY, toX, toY)&#13;
        );&#13;
        emit LogSells(id, fromX, fromY, toX, toY, priceForEachBlockWei);&#13;
    }&#13;
&#13;
    /// @notice get area price in wei&#13;
    function areaPrice(uint8 fromX, uint8 fromY, uint8 toX, uint8 toY) &#13;
        public &#13;
        view &#13;
        returns (uint) &#13;
    {   &#13;
        // check input&#13;
        require(isLegalCoordinates(fromX, fromY, toX, toY));&#13;
&#13;
        // querry areaPrice in wei at market contract&#13;
        return market.areaPrice(blocksList(fromX, fromY, toX, toY));&#13;
    }&#13;
&#13;
// ** RENT OUT AND RENT BLOCKS ** //&#13;
        &#13;
    /// @notice Rent out an area of blocks at coordinates [fromX, fromY, toX, toY] at a price for &#13;
    ///  each block in wei&#13;
    /// @dev if rentPricePerPeriodWei = 0 then makes area not available for rent&#13;
    function rentOutArea(uint8 fromX, uint8 fromY, uint8 toX, uint8 toY, uint rentPricePerPeriodWei)&#13;
        external&#13;
        whenNotPaused&#13;
    {   &#13;
        // check input&#13;
        require(isLegalCoordinates(fromX, fromY, toX, toY));&#13;
&#13;
        // try to mark blocks as rented out through rentals contract&#13;
        // will get an id of rent-rentout operation if succeeds (if message sender owns blocks)&#13;
        uint id = rentals.rentOutBlocks(&#13;
            msg.sender, &#13;
            rentPricePerPeriodWei, &#13;
            blocksList(fromX, fromY, toX, toY)&#13;
        );&#13;
        emit LogRentsOut(id, fromX, fromY, toX, toY, rentPricePerPeriodWei);&#13;
    }&#13;
    &#13;
    /// @notice Rent an area of blocks at coordinates [fromX, fromY, toX, toY] for a number of &#13;
    ///  periods specified&#13;
    ///  (period length is specified in rentals contract)&#13;
    function rentArea(uint8 fromX, uint8 fromY, uint8 toX, uint8 toY, uint numberOfPeriods)&#13;
        external&#13;
        payable&#13;
        whenNotPaused&#13;
    {   &#13;
        // check input parameters and eth deposited&#13;
        // checks number of periods &gt; 0 in rentals contract&#13;
        require(isLegalCoordinates(fromX, fromY, toX, toY));&#13;
        require(canPay(areaRentPrice(fromX, fromY, toX, toY, numberOfPeriods)));&#13;
        depositFunds();&#13;
&#13;
        // try to rent blocks through rentals contract&#13;
        // will get an id of rent-rentout operation if succeeds (if all blocks available for rent)&#13;
        uint id = rentals.rentBlocks(&#13;
            msg.sender, &#13;
            numberOfPeriods, &#13;
            blocksList(fromX, fromY, toX, toY)&#13;
        );&#13;
        emit LogRents(id, fromX, fromY, toX, toY, numberOfPeriods, 0);&#13;
    }&#13;
&#13;
    /// @notice get area rent price in wei for number of periods specified &#13;
    ///  (period length is specified in rentals contract) &#13;
    function areaRentPrice(uint8 fromX, uint8 fromY, uint8 toX, uint8 toY, uint numberOfPeriods)&#13;
        public &#13;
        view &#13;
        returns (uint) &#13;
    {   &#13;
        // check input &#13;
        require(isLegalCoordinates(fromX, fromY, toX, toY));&#13;
&#13;
        // querry areaPrice in wei at rentals contract&#13;
        return rentals.blocksRentPrice (numberOfPeriods, blocksList(fromX, fromY, toX, toY));&#13;
    }&#13;
&#13;
// ** PLACE ADS ** //&#13;
    &#13;
    /// @notice places ads (image, caption and link to a website) into desired coordinates&#13;
    /// @dev nothing is stored in any of the contracts except an image id. All other data is &#13;
    ///  only emitted in event. Basicaly this function just verifies if an event is allowed &#13;
    ///  to be emitted.&#13;
    function placeAds( &#13;
        uint8 fromX, &#13;
        uint8 fromY, &#13;
        uint8 toX, &#13;
        uint8 toY, &#13;
        string imageSource, &#13;
        string link, &#13;
        string text&#13;
    ) &#13;
        external&#13;
        whenNotPaused&#13;
    {   &#13;
        // check input&#13;
        require(isLegalCoordinates(fromX, fromY, toX, toY));&#13;
&#13;
        // try to place ads through ads contract&#13;
        // will get an image id if succeeds (if advertiser owns or rents all blocks within area)&#13;
        uint AdsId = ads.advertiseOnBlocks(&#13;
            msg.sender, &#13;
            blocksList(fromX, fromY, toX, toY), &#13;
            imageSource, &#13;
            link, &#13;
            text&#13;
        );&#13;
        emit LogAds(AdsId, fromX, fromY, toX, toY, imageSource, link, text, msg.sender);&#13;
    }&#13;
&#13;
    /// @notice check if an advertiser is allowed to put ads within area (i.e. owns or rents all &#13;
    ///  blocks)&#13;
    function canAdvertise(&#13;
        address advertiser,&#13;
        uint8 fromX, &#13;
        uint8 fromY, &#13;
        uint8 toX, &#13;
        uint8 toY&#13;
    ) &#13;
        external&#13;
        view&#13;
        returns (bool)&#13;
    {   &#13;
        // check user input&#13;
        require(isLegalCoordinates(fromX, fromY, toX, toY));&#13;
&#13;
        // querry permission at ads contract&#13;
        return ads.canAdvertiseOnBlocks(advertiser, blocksList(fromX, fromY, toX, toY));&#13;
    }&#13;
&#13;
// ** IMPORT BLOCKS ** //&#13;
&#13;
    /// @notice import blocks from previous version Million Ether Homepage&#13;
    function adminImportOldMEBlock(uint8 x, uint8 y) external onlyOwner {&#13;
        (uint id, address newLandlord) = market.importOldMEBlock(x, y);&#13;
        emit LogBuys(id, x, y, x, y, newLandlord);&#13;
    }&#13;
&#13;
// ** INFO GETTERS ** //&#13;
    &#13;
    /// @notice get an owner(address) of block at a specified coordinates&#13;
    function getBlockOwner(uint8 x, uint8 y) external view returns (address) {&#13;
        return ownerOf(blockID(x, y));&#13;
    }&#13;
&#13;
// ** UTILS ** //&#13;
    &#13;
    /// @notice get ERC721 token id corresponding to xy coordinates&#13;
    function blockID(uint8 x, uint8 y) public pure returns (uint16) {&#13;
        return (uint16(y) - 1) * 100 + uint16(x);&#13;
    }&#13;
&#13;
    /// @notice get a number of blocks within area&#13;
    function countBlocks(&#13;
        uint8 fromX, &#13;
        uint8 fromY, &#13;
        uint8 toX, &#13;
        uint8 toY&#13;
    ) &#13;
        internal &#13;
        pure &#13;
        returns (uint16)&#13;
    {&#13;
        return (toX - fromX + 1) * (toY - fromY + 1);&#13;
    }&#13;
&#13;
    /// @notice get an array of all block ids (i.e. ERC721 token ids) within area&#13;
    function blocksList(&#13;
        uint8 fromX, &#13;
        uint8 fromY, &#13;
        uint8 toX, &#13;
        uint8 toY&#13;
    ) &#13;
        internal &#13;
        pure &#13;
        returns (uint16[] memory r) &#13;
    {&#13;
        uint i = 0;&#13;
        r = new uint16[](countBlocks(fromX, fromY, toX, toY));&#13;
        for (uint8 ix=fromX; ix&lt;=toX; ix++) {&#13;
            for (uint8 iy=fromY; iy&lt;=toY; iy++) {&#13;
                r[i] = blockID(ix, iy);&#13;
                i++;&#13;
            }&#13;
        }&#13;
    }&#13;
    &#13;
    /// @notice insures that area coordinates are within 100x100 field and &#13;
    ///  from-coordinates &gt;= to-coordinates&#13;
    /// @dev function is used instead of modifier as modifier &#13;
    ///  required too much stack for placeImage and rentBlocks&#13;
    function isLegalCoordinates(&#13;
        uint8 _fromX, &#13;
        uint8 _fromY, &#13;
        uint8 _toX, &#13;
        uint8 _toY&#13;
    )    &#13;
        private &#13;
        pure &#13;
        returns (bool) &#13;
    {&#13;
        return ((_fromX &gt;= 1) &amp;&amp; (_fromY &gt;=1)  &amp;&amp; (_toX &lt;= 100) &amp;&amp; (_toY &lt;= 100) &#13;
            &amp;&amp; (_fromX &lt;= _toX) &amp;&amp; (_fromY &lt;= _toY));&#13;
    }&#13;
}&#13;
&#13;
// File: contracts/MehModule.sol&#13;
&#13;
/// @title MehModule: Base contract for MEH modules (Market, Rentals and Ads contracts). Provides&#13;
///  communication with MEH contract. &#13;
contract MehModule is Ownable, Pausable, Destructible, HasNoEther {&#13;
    using SafeMath for uint256;&#13;
&#13;
    // Main MEH contract&#13;
    MEH public meh;&#13;
&#13;
    /// @dev Initializes a module, pairs with MEH contract.&#13;
    /// @param _mehAddress address of the main Million Ether Homepage contract&#13;
    constructor(address _mehAddress) public {&#13;
        adminSetMeh(_mehAddress);&#13;
    }&#13;
    &#13;
    /// @dev Throws if called by any address other than the MEH contract.&#13;
    modifier onlyMeh() {&#13;
        require(msg.sender == address(meh));&#13;
        _;&#13;
    }&#13;
&#13;
    /// @dev Pairs a module with MEH main contract.&#13;
    function adminSetMeh(address _address) internal onlyOwner {&#13;
        MEH candidateContract = MEH(_address);&#13;
        require(candidateContract.isMEH());&#13;
        meh = candidateContract;&#13;
    }&#13;
&#13;
    /// @dev Makes an internal transaction in the MEH contract.&#13;
    function transferFunds(address _payer, address _recipient, uint _amount) internal {&#13;
        return meh.operatorTransferFunds(_payer, _recipient, _amount);&#13;
    }&#13;
&#13;
    /// @dev Check if a token exists.&#13;
    function exists(uint16 _blockId) internal view  returns (bool) {&#13;
        return meh.exists(_blockId);&#13;
    }&#13;
&#13;
    /// @dev Querries an owner of a block id (ERC721 token).&#13;
    function ownerOf(uint16 _blockId) internal view returns (address) {&#13;
        return meh.ownerOf(_blockId);&#13;
    }&#13;
}&#13;
&#13;
// File: contracts/Rentals.sol&#13;
&#13;
// @title Rentals: Pluggable module for MEH contract responsible for rentout-rent operations.&#13;
// @dev this contract is unaware of xy block coordinates - ids only (ids are ERC721 tokens)&#13;
contract Rentals is MehModule {&#13;
    &#13;
    // For MEH contract to be sure it plugged the right module in&#13;
    bool public isRentals = true;&#13;
&#13;
    // Minimum rent period and a unit to measure rent lenght&#13;
    uint public rentPeriod = 1 days;&#13;
    // Maximum rent period (can be adjusted by admin)&#13;
    uint public maxRentPeriod = 90;  // can be changed in settings &#13;
&#13;
    // Rent deal struct. A 10x10 pixel block can have only one rent deal.&#13;
    struct RentDeal {&#13;
        address renter;  // block renter&#13;
        uint rentedFrom;  // time when rent started&#13;
        uint numberOfPeriods;  //periods available&#13;
    }&#13;
    mapping(uint16 =&gt; RentDeal) public blockIdToRentDeal;&#13;
&#13;
    // Rent is allowed if price is &gt; 0&#13;
    mapping(uint16 =&gt; uint) public blockIdToRentPrice;&#13;
&#13;
    // Keeps track of rentout-rent operations&#13;
    uint public numRentStatuses = 0;&#13;
&#13;
// ** INITIALIZE ** //&#13;
&#13;
    /// @dev Initialize Rentals contract.&#13;
    /// @param _mehAddress address of the main Million Ether Homepage contract&#13;
    constructor(address _mehAddress) MehModule(_mehAddress) public {}&#13;
&#13;
// ** RENT AOUT BLOCKS ** //&#13;
    &#13;
    /// @dev Rent out a list of blocks referenced by block ids. Set rent price per period in wei.&#13;
    function rentOutBlocks(address _landlord, uint _rentPricePerPeriodWei, uint16[] _blockList) &#13;
        external&#13;
        onlyMeh&#13;
        whenNotPaused&#13;
        returns (uint)&#13;
    {   &#13;
        for (uint i = 0; i &lt; _blockList.length; i++) {&#13;
            require(_landlord == ownerOf(_blockList[i]));&#13;
            rentOutBlock(_blockList[i], _rentPricePerPeriodWei);&#13;
        }&#13;
        numRentStatuses++;&#13;
        return numRentStatuses;&#13;
    }&#13;
&#13;
    /// @dev Set rent price for a block. Independent on rent deal. Does not affect current &#13;
    ///  rent deal.&#13;
    function rentOutBlock(uint16 _blockId, uint _rentPricePerPeriodWei) &#13;
        internal&#13;
    {   &#13;
        blockIdToRentPrice[_blockId] = _rentPricePerPeriodWei;&#13;
    }&#13;
&#13;
// ** RENT BLOCKS ** //&#13;
    &#13;
    /// @dev Rent a list of blocks referenced by block ids for a number of periods.&#13;
    function rentBlocks(address _renter, uint _numberOfPeriods, uint16[] _blockList) &#13;
        external&#13;
        onlyMeh&#13;
        whenNotPaused&#13;
        returns (uint)&#13;
    {   &#13;
        /// check user input (not in the MEH contract to add future flexibility)&#13;
        require(_numberOfPeriods &gt; 0);&#13;
&#13;
        for (uint i = 0; i &lt; _blockList.length; i++) {&#13;
            rentBlock(_renter, _blockList[i], _numberOfPeriods);&#13;
        }&#13;
        numRentStatuses++;&#13;
        return numRentStatuses;&#13;
    }&#13;
&#13;
    /// @dev Rent a block by id for a number of periods. &#13;
    function rentBlock (address _renter, uint16 _blockId, uint _numberOfPeriods)&#13;
        internal&#13;
    {   &#13;
        // check input&#13;
        require(maxRentPeriod &gt;= _numberOfPeriods);&#13;
        address landlord = ownerOf(_blockId);&#13;
        require(_renter != landlord);&#13;
&#13;
        // throws if not for rent (if rent price == 0)&#13;
        require(isForRent(_blockId));&#13;
        // get price&#13;
        uint totalRent = getRentPrice(_blockId).mul(_numberOfPeriods);  // overflow safe&#13;
        &#13;
        transferFunds(_renter, landlord, totalRent);&#13;
        createRentDeal(_blockId, _renter, now, _numberOfPeriods);&#13;
    }&#13;
&#13;
    /// @dev Checks if block is for rent.&#13;
    function isForRent(uint16 _blockId) public view returns (bool) {&#13;
        return (blockIdToRentPrice[_blockId] &gt; 0);&#13;
    }&#13;
&#13;
    /// @dev Checks if block rented and the rent hasn't expired.&#13;
    function isRented(uint16 _blockId) public view returns (bool) {&#13;
        RentDeal memory deal = blockIdToRentDeal[_blockId];&#13;
        // prevents overflow if unlimited num of periods is set &#13;
        uint rentedTill = &#13;
            deal.numberOfPeriods.mul(rentPeriod).add(deal.rentedFrom);&#13;
        return (rentedTill &gt; now);&#13;
    }&#13;
&#13;
    /// @dev Gets rent price for block. Throws if not for rent or if &#13;
    ///  current rent is active.&#13;
    function getRentPrice(uint16 _blockId) internal view returns (uint) {&#13;
        require(!(isRented(_blockId)));&#13;
        return blockIdToRentPrice[_blockId];&#13;
    }&#13;
&#13;
    /// @dev Gets renter of a block. Throws if not rented.&#13;
    function renterOf(uint16 _blockId) public view returns (address) {&#13;
        require(isRented(_blockId));&#13;
        return blockIdToRentDeal[_blockId].renter;&#13;
    }&#13;
&#13;
    /// @dev Creates new rent deal.&#13;
    function createRentDeal(&#13;
        uint16 _blockId, &#13;
        address _renter, &#13;
        uint _rentedFrom, &#13;
        uint _numberOfPeriods&#13;
    ) &#13;
        private &#13;
    {&#13;
        blockIdToRentDeal[_blockId].renter = _renter;&#13;
        blockIdToRentDeal[_blockId].rentedFrom = _rentedFrom;&#13;
        blockIdToRentDeal[_blockId].numberOfPeriods = _numberOfPeriods;&#13;
    }&#13;
&#13;
// ** RENT PRICE ** //&#13;
    &#13;
    /// @dev Calculates rent price for a list of blocks. Throws if at least one block&#13;
    ///  is not available for rent.&#13;
    function blocksRentPrice(uint _numberOfPeriods, uint16[] _blockList) &#13;
        external&#13;
        view&#13;
        returns (uint)&#13;
    {   &#13;
        uint totalPrice = 0;&#13;
        for (uint i = 0; i &lt; _blockList.length; i++) {&#13;
            // overflow safe (rentPrice is arbitary)&#13;
            totalPrice = getRentPrice(_blockList[i]).mul(_numberOfPeriods).add(totalPrice);&#13;
        }&#13;
        return totalPrice;&#13;
    }&#13;
&#13;
// ** ADMIN ** //&#13;
    &#13;
    /// @dev Adjusts max rent period (only contract owner)&#13;
    function adminSetMaxRentPeriod(uint newMaxRentPeriod) external onlyOwner {&#13;
        require (newMaxRentPeriod &gt; 0);&#13;
        maxRentPeriod = newMaxRentPeriod;&#13;
    }&#13;
}&#13;
&#13;
// File: contracts/Ads.sol&#13;
&#13;
// @title Ads: Pluggable module for MEH contract responsible publishing ads.&#13;
contract Ads is MehModule {&#13;
    &#13;
    // For MEH contract to be sure it plugged the right module in&#13;
    bool public isAds = true;&#13;
&#13;
    // Keeps track of ads ids. Initial state represents the last image id of the previous &#13;
    // version of the million ether homepage. See Market contract for more details. &#13;
    uint public numImages = 69;&#13;
&#13;
    // Needs rentals contract to get block rent status&#13;
    RentalsInterface public rentalsContract;&#13;
   &#13;
// ** INITIALIZE ** //&#13;
    &#13;
    /// @dev Initialize Ads contract.&#13;
    /// @param _mehAddress address of the main Million Ether Homepage contract&#13;
    constructor(address _mehAddress) MehModule(_mehAddress) public {}&#13;
&#13;
// ** PLACE IMAGES ** //&#13;
&#13;
    /// @dev Places new ad to user owned or rented list of blocks. Returns new image id on success,&#13;
    ///  throws if user is not authorized to advertise (neither an owner nor renter). &#13;
    function advertiseOnBlocks(&#13;
        address _advertiser, &#13;
        uint16[] _blockList,&#13;
        string, &#13;
        string,&#13;
        string&#13;
    ) &#13;
        external&#13;
        onlyMeh&#13;
        whenNotPaused&#13;
        returns (uint)&#13;
    {   &#13;
        require(canAdvertiseOnBlocks(_advertiser, _blockList));&#13;
        numImages++;&#13;
        return numImages;&#13;
    }&#13;
&#13;
    /// @dev Checks if user is authorized to advertise on all blocks in list (is an owner or renter).&#13;
    function canAdvertiseOnBlocks(&#13;
        address _advertiser, &#13;
        uint16[] _blockList&#13;
    ) &#13;
        public&#13;
        view&#13;
        returns (bool)&#13;
    {   &#13;
        for (uint i = 0; i &lt; _blockList.length; i++) {&#13;
            require(canAdvertiseOnBlock(_advertiser, _blockList[i]));&#13;
        }&#13;
        return true;&#13;
    }&#13;
&#13;
    /// @dev Checks if user is authorized to advertise on a block (rents or owns a block).&#13;
    function canAdvertiseOnBlock(address _advertiser, uint16 blockId) &#13;
        internal &#13;
        view&#13;
        returns (bool)&#13;
    {&#13;
        if (meh.rentals().isRented(blockId)) {&#13;
            return(isRenter(_advertiser, blockId));&#13;
        } else {&#13;
            return(isBlockOwner(_advertiser, blockId));&#13;
        }&#13;
    }&#13;
&#13;
    /// @dev Checks if user owns a block (through main MEH contract)&#13;
    function isBlockOwner(address _advertiser, uint16 _blockId)&#13;
        private &#13;
        view &#13;
        returns (bool) &#13;
    {&#13;
        return (_advertiser == ownerOf(_blockId));&#13;
    }&#13;
&#13;
    /// @dev Checks if user rents a block (through Rentals contract)&#13;
    function isRenter(address _advertiser, uint16 _blockId)&#13;
        private &#13;
        view &#13;
        returns (bool) &#13;
    {&#13;
        return (_advertiser == meh.rentals().renterOf(_blockId));&#13;
    }&#13;
}