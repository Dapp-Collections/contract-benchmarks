/**
******************************************************************************************************************************************************************************************

                    $$$$$$$\                                                                    $$\     $$\                 $$\                           $$\       
                    $$  __$$\                                                                   $$ |    \__|                $$ |                          $$ |      
                    $$ |  $$ | $$$$$$\  $$$$$$\$$$$\   $$$$$$\   $$$$$$$\  $$$$$$\   $$$$$$\  $$$$$$\   $$\  $$$$$$$\       $$ |      $$\   $$\  $$$$$$$\ $$ |  $$\ 
                    $$ |  $$ |$$  __$$\ $$  _$$  _$$\ $$  __$$\ $$  _____|$$  __$$\  \____$$\ \_$$  _|  $$ |$$  _____|      $$ |      $$ |  $$ |$$  _____|$$ | $$  |
                    $$ |  $$ |$$$$$$$$ |$$ / $$ / $$ |$$ /  $$ |$$ /      $$ |  \__| $$$$$$$ |  $$ |    $$ |$$ /            $$ |      $$ |  $$ |$$ /      $$$$$$  / 
                    $$ |  $$ |$$   ____|$$ | $$ | $$ |$$ |  $$ |$$ |      $$ |      $$  __$$ |  $$ |$$\ $$ |$$ |            $$ |      $$ |  $$ |$$ |      $$  _$$<  
                    $$$$$$$  |\$$$$$$$\ $$ | $$ | $$ |\$$$$$$  |\$$$$$$$\ $$ |      \$$$$$$$ |  \$$$$  |$$ |\$$$$$$$\       $$$$$$$$\ \$$$$$$  |\$$$$$$$\ $$ | \$$\ 
                    \_______/  \_______|\__| \__| \__| \______/  \_______|\__|       \_______|   \____/ \__| \_______|      \________| \______/  \_______|\__|  \__|
                            
                          
                                                                                _    _                                        _  _              
                                                                              | |  | |                                      | |(_)             
                                        __      ____      ____      __     ___ | |_ | |__    __ _   __ _  _ __ ___    ___    | | _ __   __  ___ 
                                        \ \ /\ / /\ \ /\ / /\ \ /\ / /    / _ \| __|| '_ \  / _` | / _` || '_ ` _ \  / _ \   | || |\ \ / / / _ \
                                        \ V  V /  \ V  V /  \ V  V /  _ |  __/| |_ | | | || (_| || (_| || | | | | ||  __/ _ | || | \ V / |  __/
                                          \_/\_/    \_/\_/    \_/\_/  (_) \___| \__||_| |_| \__, | \__,_||_| |_| |_| \___|(_)|_||_|  \_/   \___|
                                                                                            __/ |                                              
                                                                                            |___/                                               

******************************************************************************************************************************************************************************************                                                                                                                                          

Contract Name: Democratic Luck
Contract Symbol: DemoLuck
Version: 1.0
Author: Alan Yan
Author Email: <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="88c9e4e9e6d1e9e6b1b1c8e7fdfce4e7e7e3a6ebe7e5">[emailÂ protected]</a>&#13;
Publish Date: 2018/11&#13;
Official Website: www.ethgame.live&#13;
Copyright: All rights reserved&#13;
Contract Describe: &#13;
    A game that include investment, math strategy, luck and democratic mechanism for game equilibrium. It based on eth blockchain network. &#13;
    Let's hope the whole world's people can enjoy this new revolutionary game and have fun!&#13;
    Game Rules:&#13;
    1. This game use ether cryptocurrency. To participate in the game, user need to use a browser such as chrome/Firefox with the metamask plugin installed.&#13;
    2. User can directly participate in the game without registration first. If user buy share or buy ticket, then will be automatically registered. User also &#13;
      can manually register for free. The process of manual registration is very simple, just click the 'Register' button on the website, and then click 'Confirm' &#13;
      in the pop-up metamask window. Registration will complete.&#13;
    3. Each user will have an account with a purse and a dedicated promotion url link. User can send this link to others and invite others to participate in the game, &#13;
      if the others join the game and get prize, user will always receive 5% of the others' prize as reward.&#13;
    4. After each round of the game begins, user can buy shares of the game and become the shareholder. The price of the shares is 1eth/share, and 70% of the cost &#13;
      ether will put into the jackpot prize pool, 20% will be constantly distributed to all earlier shares (including itself), and 10% will be given to the last &#13;
      share buyer at the end of game round as a special prize.&#13;
    5. When there is a jackpot prize pool, then anyone can buy luck tickets at any time to win the jackpot prize pool. The price of the luck ticket is 0.01 eth, &#13;
      and 50% of the cost ether will instantly distribute to all current shares, and 50% of the cost ether will instantly distribute to all earlier luck tickets (including itself).&#13;
    6. When a luck ticket was been bought, a 48-hour countdown will auto start. If a new luck ticket was been bought during the countdown, then 48-hour countdown&#13;
      will restart again. If when the 48-hour countdown is over, there is still no new ticket was been bought. Then the game will enter the vote period. The vote&#13;
      period is 24 hours. Every shareholder can participate in vote. Shareholder's share amount is votes amount. Shareholders can choose to continue wait or end &#13;
      the game round. If the shareholder didn't not manually vote, the default option is continue wait, if votes amount of end game round is more than 50% of the &#13;
      total votes amount, then game round will auto end. During the voting period, if a new luck ticket was been bought, then vote will be cancelled and restart &#13;
      the 48-hour countdown again. After vote period over and shareholders didn't vote to end game round, then game will continue wait and restart the 48-hour countdown again.&#13;
    7. During the game, shareholders or luck ticket buyers can view their own prize at any time. The prize is dynamic estimation and change with the game progress.&#13;
    8. When the game is over, the prize will be automatically distributed. The prize distribution rules are: the instantly prize obtained by shareholders and luck &#13;
      ticket buyers during the game will be their prize too, also the total share capital's 10% will reward to the last share buyer at the end of the game as a &#13;
      special prize, the last luck ticket buyer will win the jackpot prize pool.&#13;
    9. After the game is over, The prize that each player received, the platform will charge 5% as a service fee, and the remaining 95% will automatically deposited&#13;
      into the purse of user's account. User can withdraw the prize to own personal ether account at any time.&#13;
    10. If player (shareholder or luck ticket buyer) wins the prize in the game round, and player has a referrer, the referrer will receive 5% of the prize as a reward. &#13;
      When player withdraw the prize from purse, the reward will be sent to referer's purse.&#13;
    11. After each game round ended and distributed prize, the next round will automatically restart.&#13;
&#13;
**/&#13;
&#13;
pragma solidity ^0.4.24;&#13;
&#13;
&#13;
/** @title Democratic Luck */&#13;
contract DemocraticLuck {&#13;
  &#13;
  using SafeMath for uint256;&#13;
  &#13;
  //event when shareholder buy share &#13;
  event event_buyShare(address indexed _addr, uint256 indexed _indexNo, uint256 _num);&#13;
  //event when player buy luck ticket &#13;
  event event_buyTicket(address indexed _addr, uint256 indexed _indexNo, uint256 _num);&#13;
  //event when shareholder vote&#13;
  event event_shareholderVote(address indexed _addr, uint256 indexed _indexNo, uint256 _vote);  &#13;
  //event when round end and jackpot winner&#13;
  event event_endRound(uint256 indexed _indexNo, address indexed _addr, uint256 _prize);&#13;
  &#13;
  address private Owner; &#13;
  uint256 private rdSharePrice = 1 ether;  //share's price&#13;
  uint256 private rdTicketPrice = 0.01 ether; //luck ticket's price&#13;
  uint256 private rdIndexNo = 0; //game round's index No  counter&#13;
  uint256 private userIDCnt = 0;  //user's id counter&#13;
  uint256 private rdStateActive = 1;  //game round's active state &#13;
  uint256 private rdStateEnd = 2;   //game round's end state&#13;
  uint256 private rdTicketTime = 48 hours; //countdown time since a ticket was been bought&#13;
  uint256 private rdVoteTime = 24 hours; //vote time since countdown time over&#13;
  uint256 private serviceFee = 5; //system charge service fee rate&#13;
  uint256 private refererFee = 5; //referer user's prize percent 5%&#13;
  uint256 private sharePotRate = 70; //share price's percent into jackpot   &#13;
  uint256 private shrPrizeRate = 20; //share price's percent to distribute to current shares&#13;
  uint256 private shrLastBuyerRate = 10; //share price's percent to last share buyer&#13;
  uint256 private ticketPotRate = 50; //ticket price's percent to distribute to current shares&#13;
  uint256 private serviceFeeCnt; //owner service fee count&#13;
   &#13;
  //user's account information&#13;
  struct userAcc{  &#13;
        uint256 purse; //user's purse&#13;
        uint256 refCode; //user's unique referrer code&#13;
        uint256 frefCode; //user from referrer code &#13;
  }&#13;
  &#13;
  //game shareholder's information&#13;
  struct rdShareholder{&#13;
        uint256 cost;  //shareholder cost to buy share&#13;
        uint256 shareNum;  //shareholder's shares amount  &#13;
        uint256 shrAvgBonus;  //shareholder's shares average value to calculate bonus from later shares  &#13;
        uint256 shrTckAvgBonus;  //shareholder's shares average value to calculate bonus from tickets sale  &#13;
        uint256 vote; //shareholder's vote to coutinue or end game round&#13;
        uint256 lastShrVoteTime; //shareholder's last vote time       &#13;
  }  &#13;
  &#13;
  //luck ticket buyer's information&#13;
  struct rdTckBuyer{ &#13;
        uint256 cost;   //ticket buyer cost to buy ticket&#13;
        uint256 ticketNum; //ticket's amount&#13;
        uint256 tckAvgBonus; //ticket buyer's average value to calculate bonus from later tickets&#13;
  }&#13;
  &#13;
  //game round's information&#13;
  struct rdInfo{ &#13;
        uint256 state;   //round's state: 1,active 2,end&#13;
        uint256 sharePot;    //all share's capital pot&#13;
        uint256 shrJackpot;    //round's jackpot&#13;
        uint256 shareholderNum; //shareholders amount        &#13;
        uint256 shareNum;  //shares amount&#13;
        uint256 shrAvgBonus;  //round's shares average value to calculate bonus from later shares&#13;
        uint256 shrTckAvgBonus; //round's shares average value to calculate bonus from tickets sale&#13;
        uint256 ticketPot; //luck ticket sales amount &#13;
        uint256 tckBuyerNum; //luck ticket buyers amount      &#13;
        uint256 ticketNum; //luck ticket's saled amount &#13;
        uint256 tckAvgBonus; //round's ticket buyer's average value to calculate bonus from later tickets&#13;
        uint256 lastTckBuyTime; //time of last ticket was been bought &#13;
        uint256 lastShrVoteTime;  //last time of shareholders vote&#13;
        uint256 shrVotesEnd;   //count of votes to end    &#13;
        address lastShareBuyer; //who bought the last share &#13;
        address lastTckBuyer; //who bought the last luck ticket&#13;
   }&#13;
&#13;
 &#13;
  mapping(uint256 =&gt; address) private userIDAddr; //user'id =&gt; user's account&#13;
  mapping(address =&gt; userAcc) private userAccs;  //user's account =&gt; user's account information&#13;
  mapping(address =&gt; uint256[]) private userUnWithdrawRound; //round list that user didn't withdraw yet  &#13;
  mapping(uint256 =&gt; mapping(address =&gt; rdShareholder)) private rdShareholders;  //round's index No =&gt; shareholder's account =&gt;  shareholder's information  &#13;
  mapping(uint256 =&gt; rdInfo) private rdInfos;  //round's index No =&gt; round's information&#13;
  mapping(uint256 =&gt; mapping(address =&gt; rdTckBuyer)) private rdTckBuyers;  //round's index No =&gt; luck ticket buyer's account =&gt; ticket buyer's information  &#13;
 &#13;
  &#13;
  /* Modifiers */&#13;
&#13;
  /** @dev check caller is owner    &#13;
  */&#13;
  modifier onlyOwner()&#13;
  {&#13;
    require(Owner == msg.sender);&#13;
    _;&#13;
  }   &#13;
  &#13;
  /** @dev check caller is person     &#13;
  */&#13;
  modifier isPerson()&#13;
  {        &#13;
    address addr = msg.sender;&#13;
    uint256 size;&#13;
    &#13;
    assembly {size := extcodesize(addr)}&#13;
    require(size == 0);&#13;
&#13;
    require(tx.origin == msg.sender);&#13;
    _;&#13;
  }&#13;
  &#13;
  /** @dev create contract     &#13;
  */&#13;
  constructor()&#13;
  public&#13;
  {&#13;
    Owner = msg.sender;   &#13;
    startNewRound();&#13;
  }&#13;
  &#13;
  /** @dev tarnsfer ownership to new account&#13;
    * @param _owner  new owner account &#13;
  */&#13;
  function transferOwnership(address _owner)&#13;
  onlyOwner()&#13;
  public &#13;
  { &#13;
    Owner = _owner;&#13;
  }  &#13;
  &#13;
  /** @dev get contract owner account&#13;
    * @return _addr owner account &#13;
  */&#13;
  function owner()&#13;
  public &#13;
  view &#13;
  returns (address _addr) &#13;
  {&#13;
    return Owner;&#13;
  } &#13;
  &#13;
  /** @dev start new game round   &#13;
  */&#13;
  function startNewRound()&#13;
  internal&#13;
  {      &#13;
    rdIndexNo++;&#13;
    rdInfo memory rdInf = rdInfo(rdStateActive, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, address(0), address(0));&#13;
    rdInfos[rdIndexNo] = rdInf;&#13;
  } &#13;
 &#13;
  /** @dev new user register &#13;
    * @param _frefCode  referer id  &#13;
  */&#13;
  function userRegister(uint256 _frefCode)&#13;
  isPerson() &#13;
  public &#13;
  {  &#13;
    require(msg.sender != address(0));&#13;
    require(!checkUserExist(msg.sender)); &#13;
    &#13;
    addNewUser(msg.sender, _frefCode);        &#13;
  }    &#13;
&#13;
  /** @dev add new user&#13;
    * @param _addr  user account&#13;
    * @param _frefCode  referer id  &#13;
  */&#13;
  function addNewUser(address _addr, uint256 _frefCode)  &#13;
  internal &#13;
  {  &#13;
    if(getAddrOfRefCode(_frefCode) == address(0))&#13;
          _frefCode = 0;          &#13;
    &#13;
    userIDCnt++;       &#13;
    userAcc memory uAcc = userAcc(0, userIDCnt, _frefCode);&#13;
    userAccs[_addr] = uAcc;      &#13;
    userIDAddr[userIDCnt] = _addr;                &#13;
  }    &#13;
&#13;
  /** @dev add new shareholder into game round&#13;
     * @param _indexNo  round's index No&#13;
     * @param _addr  shareholder account     &#13;
  */&#13;
  function addRdShareholder(uint256 _indexNo, address _addr)&#13;
  internal &#13;
  {&#13;
    rdShareholder memory rdPly = rdShareholder(0, 0, 0, 0, 0, 0);&#13;
    rdShareholders[_indexNo][_addr] = rdPly;    &#13;
    rdInfos[_indexNo].shareholderNum++;&#13;
    if(!checkUserInUnWithdrawRd(_indexNo, _addr))&#13;
      userUnWithdrawRound[_addr].push(_indexNo);&#13;
  }  &#13;
&#13;
  /** @dev add new ticket buyer into game round&#13;
     * @param _indexNo  round's index No&#13;
     * @param _addr  ticket buyer account     &#13;
  */&#13;
  function addRdTicketBuyer(uint256 _indexNo, address _addr)&#13;
  internal &#13;
  {&#13;
    rdTckBuyer memory rdPly = rdTckBuyer(0, 0, 0);&#13;
    rdTckBuyers[_indexNo][_addr] = rdPly;    &#13;
    rdInfos[_indexNo].tckBuyerNum++;&#13;
    if(!checkUserInUnWithdrawRd(_indexNo, _addr))&#13;
      userUnWithdrawRound[_addr].push(_indexNo);&#13;
  }  &#13;
  &#13;
  /** @dev shareholder buy shares&#13;
    * @param _indexNo  round's index No    &#13;
    * @param _frefCode  referer id    &#13;
  */&#13;
  function buyShare(uint256 _indexNo, uint256 _frefCode)&#13;
  isPerson() &#13;
  public &#13;
  payable &#13;
  {&#13;
    require(msg.sender != address(0)); &#13;
    require(checkRdActive(_indexNo));    &#13;
    require(msg.value.sub(rdSharePrice) &gt;= 0);&#13;
    &#13;
    uint256 _num = msg.value.div(rdSharePrice);&#13;
    uint256 cost = rdSharePrice.mul(_num);   &#13;
&#13;
    if(!checkUserExist(msg.sender))&#13;
      addNewUser(msg.sender, _frefCode); &#13;
&#13;
    if(!checkShareholderInRd(_indexNo, msg.sender))&#13;
      addRdShareholder(_indexNo, msg.sender); &#13;
&#13;
    addRoundShare(_indexNo, msg.sender, cost, _num); &#13;
    calcServiceFee(cost);   &#13;
&#13;
    if(msg.value.sub(cost) &gt; 0)&#13;
       userAccs[msg.sender].purse += msg.value.sub(cost);&#13;
    &#13;
    emit event_buyShare(msg.sender, _indexNo, _num);&#13;
  }  &#13;
&#13;
  /** @dev add shares info when shareholder bought&#13;
    * @param _indexNo  round's index No   &#13;
    * @param _addr shareholder's account&#13;
    * @param _cost cost amount   &#13;
    * @param _num shares amount    &#13;
  */&#13;
  function addRoundShare(uint256 _indexNo, address _addr, uint256 _cost, uint256 _num)&#13;
  internal &#13;
  {    &#13;
    rdInfos[_indexNo].lastShareBuyer = _addr;       &#13;
    rdInfos[_indexNo].shareNum += _num;&#13;
    rdInfos[_indexNo].sharePot = rdInfos[_indexNo].sharePot + _cost; &#13;
    rdInfos[_indexNo].shrJackpot = rdInfos[_indexNo].shrJackpot + (_cost * sharePotRate / 100); &#13;
    rdInfos[_indexNo].shrAvgBonus = rdInfos[_indexNo].shrAvgBonus + (_cost * shrPrizeRate / 100) / rdInfos[_indexNo].shareNum;&#13;
       &#13;
    rdShareholders[_indexNo][_addr].cost += _cost;         &#13;
    rdShareholders[_indexNo][_addr].shareNum += _num;  &#13;
    rdShareholders[_indexNo][_addr].shrAvgBonus = (rdInfos[_indexNo].shrAvgBonus * rdShareholders[_indexNo][_addr].shareNum - (rdInfos[_indexNo].shrAvgBonus - (_cost * shrPrizeRate / 100) / rdInfos[_indexNo].shareNum - rdShareholders[_indexNo][_addr].shrAvgBonus) * (rdShareholders[_indexNo][_addr].shareNum - _num) - (_cost * shrPrizeRate / 100) * rdShareholders[_indexNo][_addr].shareNum / rdInfos[_indexNo].shareNum) / rdShareholders[_indexNo][_addr].shareNum;     &#13;
    rdShareholders[_indexNo][_addr].shrTckAvgBonus = (rdInfos[_indexNo].shrTckAvgBonus * rdShareholders[_indexNo][_addr].shareNum - (rdInfos[_indexNo].shrTckAvgBonus - rdShareholders[_indexNo][_addr].shrTckAvgBonus) * (rdShareholders[_indexNo][_addr].shareNum - _num)) / rdShareholders[_indexNo][_addr].shareNum;       &#13;
  } &#13;
&#13;
  /** @dev buy luck ticket&#13;
    * @param _indexNo  round's index No  &#13;
    * @param _frefCode  referer id&#13;
  */&#13;
  function buyTicket(uint256 _indexNo, uint256 _frefCode)&#13;
  isPerson() &#13;
  public &#13;
  payable &#13;
  { &#13;
    require(msg.sender != address(0)); &#13;
    require(checkRdActive(_indexNo));   &#13;
    require(rdInfos[_indexNo].shrJackpot &gt; 0); &#13;
    require(msg.value.sub(rdTicketPrice) &gt;= 0);&#13;
    &#13;
    uint256 _num = msg.value.div(rdTicketPrice);&#13;
    uint256 cost = rdTicketPrice.mul(_num);&#13;
&#13;
    if(!checkUserExist(msg.sender))&#13;
      addNewUser(msg.sender, _frefCode); &#13;
    if(!checkTicketBuyerInRd(_indexNo, msg.sender))&#13;
      addRdTicketBuyer(_indexNo, msg.sender); &#13;
&#13;
    addRoundTicket(_indexNo, msg.sender, cost, _num);    &#13;
    calcServiceFee(cost); &#13;
&#13;
    if(msg.value.sub(cost) &gt; 0)&#13;
       userAccs[msg.sender].purse += msg.value.sub(cost);&#13;
&#13;
    emit event_buyTicket(msg.sender, _indexNo, _num);&#13;
  } &#13;
&#13;
  /** @dev add ticket info&#13;
    * @param _indexNo  round's index No   &#13;
    * @param _addr buyer's account&#13;
    * @param _cost cost amount   &#13;
    * @param _num tickets amount    &#13;
  */&#13;
  function addRoundTicket(uint256 _indexNo, address _addr, uint256 _cost, uint256 _num)&#13;
  internal &#13;
  { &#13;
    rdInfos[_indexNo].lastTckBuyTime = now;&#13;
    rdInfos[_indexNo].lastTckBuyer = _addr; &#13;
    rdInfos[_indexNo].ticketNum += _num;&#13;
    rdInfos[_indexNo].ticketPot = rdInfos[_indexNo].ticketPot + _cost;        &#13;
    rdInfos[_indexNo].shrTckAvgBonus = rdInfos[_indexNo].shrTckAvgBonus + (_cost * ticketPotRate / 100) / rdInfos[_indexNo].shareNum; &#13;
    rdInfos[_indexNo].tckAvgBonus = rdInfos[_indexNo].tckAvgBonus + (_cost * (100 - ticketPotRate) / 100) / rdInfos[_indexNo].ticketNum;     &#13;
&#13;
    rdTckBuyers[_indexNo][_addr].cost += _cost;&#13;
    rdTckBuyers[_indexNo][_addr].ticketNum += _num;&#13;
    rdTckBuyers[_indexNo][_addr].tckAvgBonus = (rdInfos[_indexNo].tckAvgBonus * rdTckBuyers[_indexNo][_addr].ticketNum - (rdInfos[_indexNo].tckAvgBonus - (_cost * (100 - ticketPotRate) / 100) / rdInfos[_indexNo].ticketNum - rdTckBuyers[_indexNo][_addr].tckAvgBonus) * (rdTckBuyers[_indexNo][_addr].ticketNum - _num) - (_cost * (100 - ticketPotRate) / 100) * rdTckBuyers[_indexNo][_addr].ticketNum / rdInfos[_indexNo].ticketNum) / rdTckBuyers[_indexNo][_addr].ticketNum;   &#13;
  }  &#13;
  &#13;
  /**&#13;
  * @dev get user amount &#13;
  * @return _num user amount &#13;
  */&#13;
  function getUserCount()&#13;
  public &#13;
  view &#13;
  returns(uint256 _num) &#13;
  {    &#13;
    return userIDCnt;    &#13;
  }&#13;
  &#13;
  /**&#13;
  * @dev get user's information &#13;
  * @param _addr  user's account &#13;
  * @return user's information &#13;
  */&#13;
  function getUserInfo(address _addr)&#13;
  public &#13;
  view &#13;
  returns(uint256, uint256, uint256) &#13;
  {   &#13;
    require(_addr != address(0));&#13;
    require(checkUserExist(_addr));&#13;
      &#13;
    uint256 prize = 0;  &#13;
&#13;
    for(uint256 i = 0; i &lt; userUnWithdrawRound[_addr].length; i++)&#13;
    {&#13;
      uint256 indexNo = userUnWithdrawRound[_addr][i];&#13;
       &#13;
      if(rdInfos[indexNo].state == rdStateEnd)      &#13;
        prize += calcRdPlayerPrize(indexNo, _addr); &#13;
    }&#13;
&#13;
    prize = userAccs[_addr].purse + prize * (100 - serviceFee) / 100; &#13;
&#13;
    return (prize, userAccs[_addr].refCode, userAccs[_addr].frefCode);    &#13;
  }&#13;
&#13;
  /** @dev user withdraw eth from purse, withdraw all every time   &#13;
  */&#13;
  function userWithdraw()&#13;
  isPerson() &#13;
  public &#13;
  {          &#13;
    require(msg.sender != address(0));&#13;
    require(checkUserExist(msg.sender));&#13;
    &#13;
    address addr = msg.sender;&#13;
    uint256 prize = 0;&#13;
    uint256 unEndRd = 0;&#13;
&#13;
    for(uint256 i = 0; i &lt; userUnWithdrawRound[addr].length; i++)&#13;
    {&#13;
      uint256 indexNo = userUnWithdrawRound[addr][i];&#13;
       &#13;
      if(rdInfos[indexNo].state == rdStateEnd)      &#13;
        prize += calcRdPlayerPrize(indexNo, addr); &#13;
      else&#13;
        unEndRd = indexNo;&#13;
    }&#13;
    &#13;
    require(prize &gt; 0); &#13;
    userUnWithdrawRound[addr].length = 0;   &#13;
    if(unEndRd &gt; 0)&#13;
      userUnWithdrawRound[addr].push(unEndRd);    &#13;
    prize = prize * (100 - serviceFee) / 100;&#13;
&#13;
    if(userAccs[addr].frefCode != 0)&#13;
    {&#13;
      address frefAddr = getAddrOfRefCode(userAccs[addr].frefCode);&#13;
      if(frefAddr != address(0))&#13;
      {&#13;
          uint256 refPrize = (prize * refererFee) / 100;&#13;
          userAccs[frefAddr].purse += refPrize;&#13;
          prize -= refPrize;&#13;
      }    &#13;
    }          &#13;
&#13;
    prize += userAccs[addr].purse;&#13;
    userAccs[addr].purse = 0;&#13;
    addr.transfer(prize);            &#13;
  }   &#13;
  &#13;
  /**&#13;
  * @dev calculate player's prize&#13;
  * @param _indexNo  round's index No&#13;
  * @param _addr  player's account&#13;
  * @return _prize player's prize &#13;
  */&#13;
  function calcRdPlayerPrize(uint256 _indexNo, address _addr)&#13;
  internal &#13;
  view &#13;
  returns(uint256 _prize)&#13;
  { &#13;
    uint256 prize = 0;&#13;
    &#13;
    if(rdShareholders[_indexNo][_addr].shareNum &gt; 0)    &#13;
      prize += calcShrPrize(_indexNo, _addr); &#13;
     &#13;
    if(rdTckBuyers[_indexNo][_addr].ticketNum &gt; 0)&#13;
      prize += calcTckPrize(_indexNo, _addr);&#13;
&#13;
    return prize;&#13;
  }&#13;
&#13;
  /**&#13;
  * @dev calculate shareholder's share prize&#13;
  * @param _indexNo  round's index No&#13;
  * @param _addr  shareholder account&#13;
  * @return _prize shareholder's prize &#13;
  */  &#13;
  function calcShrPrize(uint256 _indexNo, address _addr)&#13;
  internal &#13;
  view &#13;
  returns(uint256 _prize)&#13;
  { &#13;
    uint256 prize = 0;&#13;
&#13;
    prize += (rdInfos[_indexNo].shrAvgBonus - rdShareholders[_indexNo][_addr].shrAvgBonus) * rdShareholders[_indexNo][_addr].shareNum;&#13;
    prize += (rdInfos[_indexNo].shrTckAvgBonus - rdShareholders[_indexNo][_addr].shrTckAvgBonus) * rdShareholders[_indexNo][_addr].shareNum;  &#13;
    &#13;
    if(rdInfos[_indexNo].lastShareBuyer == _addr) &#13;
      prize += (rdInfos[_indexNo].sharePot * shrLastBuyerRate) / 100;  &#13;
       &#13;
    return prize;&#13;
  }&#13;
&#13;
  /**&#13;
  * @dev calculate ticket buyer's ticket prize&#13;
  * @param _indexNo  round's index No&#13;
  * @param _addr  buyer account&#13;
  * @return _prize buyer's prize &#13;
  */  &#13;
  function calcTckPrize(uint256 _indexNo, address _addr)&#13;
  internal &#13;
  view &#13;
  returns(uint256 _prize)&#13;
  { &#13;
    uint256 prize = 0;&#13;
   &#13;
    prize += (rdInfos[_indexNo].tckAvgBonus - rdTckBuyers[_indexNo][_addr].tckAvgBonus) * rdTckBuyers[_indexNo][_addr].ticketNum; &#13;
    &#13;
    if(rdInfos[_indexNo].lastTckBuyer == _addr) &#13;
      prize += rdInfos[_indexNo].shrJackpot;  &#13;
    &#13;
    return prize;&#13;
  }  &#13;
 &#13;
  /** @dev get active round's index No&#13;
    * @return _rdIndexNo active round's index No&#13;
  */&#13;
  function getRoundActive()&#13;
  public &#13;
  view &#13;
  returns(uint256 _rdIndexNo) &#13;
  {   &#13;
     return rdIndexNo; &#13;
  }&#13;
      &#13;
  /** @dev get round's information&#13;
    * @param _indexNo  round's index No &#13;
    * @return _rdIn rounds's information&#13;
    * @return _addrs rounds's information&#13;
  */&#13;
  function getRdInfo(uint256 _indexNo)  &#13;
  public &#13;
  view &#13;
  returns(uint256[] _rdIn, address[] _addrs)&#13;
  {    &#13;
    require(checkRdExist(_indexNo));&#13;
    &#13;
    uint256[] memory rdIn = new uint256[](16);    &#13;
    address[] memory addrs = new address[](2);    &#13;
    &#13;
    rdIn[0] = rdSharePrice;    &#13;
    rdIn[1] = rdTicketPrice;&#13;
    rdIn[2] = rdInfos[_indexNo].state;&#13;
    rdIn[3] = rdInfos[_indexNo].sharePot;&#13;
    rdIn[4] = rdInfos[_indexNo].shrJackpot;&#13;
    rdIn[5] = rdInfos[_indexNo].shareholderNum;&#13;
    rdIn[6] = rdInfos[_indexNo].shareNum;     &#13;
    rdIn[7] = rdInfos[_indexNo].shrAvgBonus; &#13;
    rdIn[8] = rdInfos[_indexNo].shrTckAvgBonus;    &#13;
    rdIn[9] = rdInfos[_indexNo].ticketPot; &#13;
    rdIn[10] = rdInfos[_indexNo].tckBuyerNum;&#13;
    rdIn[11] = rdInfos[_indexNo].ticketNum; &#13;
    rdIn[12] = rdInfos[_indexNo].tckAvgBonus;&#13;
    rdIn[13] = rdInfos[_indexNo].lastTckBuyTime;&#13;
    rdIn[14] = rdInfos[_indexNo].lastShrVoteTime;&#13;
    rdIn[15] = rdInfos[_indexNo].shrVotesEnd;   &#13;
&#13;
    addrs[0] =  rdInfos[_indexNo].lastShareBuyer;&#13;
    addrs[1] =  rdInfos[_indexNo].lastTckBuyer; &#13;
  &#13;
    return (rdIn,  addrs);  &#13;
  }&#13;
  &#13;
 &#13;
  /** @dev get round's countdown time or vote time state&#13;
    * @param _indexNo  round's index No &#13;
    * @return _timeState countdown time or vote time&#13;
    * @return _timeLeft  left time   &#13;
  */  &#13;
  function getRdTimeState(uint256 _indexNo)  &#13;
  public &#13;
  view &#13;
  returns(uint256 _timeState, uint256 _timeLeft) &#13;
  {  &#13;
    require(checkRdActive(_indexNo));&#13;
    &#13;
    uint256 nowTime = now;&#13;
    uint256 timeState = 0;&#13;
    uint256 timeLeft = 0;        &#13;
    &#13;
    uint256 timeStart = getRdLastCntDownStart(_indexNo, nowTime); &#13;
    &#13;
    if(timeStart &gt; 0)&#13;
    { &#13;
      if(nowTime &lt; (timeStart + rdTicketTime))&#13;
      {&#13;
        timeState = 1;&#13;
        timeLeft = (timeStart + rdTicketTime) - nowTime;&#13;
      }      &#13;
      else&#13;
      {&#13;
        timeState = 2;&#13;
        timeLeft = (timeStart + rdTicketTime + rdVoteTime) - nowTime; &#13;
      }&#13;
      &#13;
    }   &#13;
  &#13;
    return (timeState, timeLeft);  &#13;
  }&#13;
&#13;
  /** @dev get round's last countdown start time&#13;
    * @param _indexNo  round's index No&#13;
    * @param _nowTime  now time &#13;
    * @return _timeStart last countdown start time&#13;
  */  &#13;
  function getRdLastCntDownStart(uint256 _indexNo, uint256 _nowTime)  &#13;
  internal &#13;
  view &#13;
  returns(uint256 _timeStart) &#13;
  {  &#13;
    require(checkRdActive(_indexNo));&#13;
   &#13;
    uint256 timeStart = 0;   &#13;
    &#13;
    if(rdInfos[_indexNo].lastTckBuyTime &gt; 0)&#13;
    { &#13;
      uint256 timeSpan = _nowTime - rdInfos[_indexNo].lastTckBuyTime;&#13;
      uint256 num = timeSpan / (rdTicketTime + rdVoteTime);&#13;
      timeStart = rdInfos[_indexNo].lastTckBuyTime + num * (rdTicketTime + rdVoteTime);&#13;
    }   &#13;
  &#13;
    return timeStart;  &#13;
  }&#13;
 &#13;
  /** @dev get round's player's information&#13;
    * @param _indexNo  round's index No &#13;
    * @param _addr player's account   &#13;
    * @return _rdPly1  shareholder's information &#13;
    * @return _rdPly2  ticket buyer's information &#13;
  */&#13;
  function getRdPlayerInfo(uint256 _indexNo, address _addr)&#13;
  public &#13;
  view &#13;
  returns(uint256[] _rdPly1, uint256[] _rdPly2) &#13;
  { &#13;
    require(checkShareholderInRd(_indexNo, _addr) || checkTicketBuyerInRd(_indexNo, _addr));&#13;
    &#13;
    uint256[] memory rdPly1 = new uint256[](6);&#13;
    uint256[] memory rdPly2 = new uint256[](3);&#13;
&#13;
    if(checkShareholderInRd(_indexNo, _addr))&#13;
    {&#13;
      rdPly1[0] = rdShareholders[_indexNo][_addr].cost;    &#13;
      rdPly1[1] = rdShareholders[_indexNo][_addr].shareNum; &#13;
      rdPly1[2] = rdShareholders[_indexNo][_addr].shrAvgBonus;&#13;
      rdPly1[3] = rdShareholders[_indexNo][_addr].shrTckAvgBonus;  &#13;
      rdPly1[4] = calcShrPrize(_indexNo, _addr);  &#13;
      rdPly1[5] = 0;  &#13;
&#13;
      if(checkRdInVoteState(_indexNo))         &#13;
        rdPly1[5] = getRdshareholderVoteVal(_indexNo, _addr, now);&#13;
    }&#13;
    &#13;
    if(checkTicketBuyerInRd(_indexNo, _addr))&#13;
    {&#13;
      rdPly2[0] = rdTckBuyers[_indexNo][_addr].cost;&#13;
      rdPly2[1] = rdTckBuyers[_indexNo][_addr].ticketNum;&#13;
      rdPly2[2] = calcTckPrize(_indexNo, _addr);   &#13;
    }&#13;
&#13;
    return (rdPly1, rdPly2);  &#13;
  }  &#13;
  &#13;
  /** @dev shareholder vote to coutinue or end round&#13;
    * @param _indexNo  round's index No &#13;
    * @param _vote coutinue or end round&#13;
  */&#13;
  function shareholderVote(uint256 _indexNo, uint256 _vote)&#13;
  isPerson()&#13;
  public &#13;
  { &#13;
    require(checkRdInVoteState(_indexNo));&#13;
    require(checkShareholderInRd(_indexNo, msg.sender));    &#13;
    require(_vote == 0 || _vote == 1);&#13;
    &#13;
    address addr = msg.sender;&#13;
    uint256 nowTime = now;&#13;
    uint256 timeStart = getRdLastCntDownStart(_indexNo, nowTime); &#13;
&#13;
    if(rdInfos[_indexNo].lastShrVoteTime &lt; (timeStart + rdTicketTime))&#13;
    {   &#13;
        rdShareholders[_indexNo][addr].vote = 0;        &#13;
        rdInfos[_indexNo].shrVotesEnd = 0;&#13;
    } &#13;
&#13;
    if(rdShareholders[_indexNo][addr].lastShrVoteTime &gt; (timeStart + rdTicketTime))&#13;
    {&#13;
      if(_vote == 1 &amp;&amp; _vote != rdShareholders[_indexNo][addr].vote)&#13;
        rdInfos[_indexNo].shrVotesEnd += rdShareholders[_indexNo][addr].shareNum;&#13;
      else if(_vote == 0 &amp;&amp; _vote != rdShareholders[_indexNo][addr].vote)&#13;
        rdInfos[_indexNo].shrVotesEnd -= rdShareholders[_indexNo][addr].shareNum;&#13;
    }&#13;
    else if(_vote == 1)&#13;
        rdInfos[_indexNo].shrVotesEnd += rdShareholders[_indexNo][addr].shareNum;      &#13;
    &#13;
    rdShareholders[_indexNo][addr].vote = _vote;&#13;
    rdShareholders[_indexNo][addr].lastShrVoteTime = nowTime;&#13;
    rdInfos[_indexNo].lastShrVoteTime = nowTime;&#13;
    emit event_shareholderVote(addr, _indexNo, _vote); &#13;
&#13;
    if((rdInfos[_indexNo].shrVotesEnd * 2) &gt; rdInfos[_indexNo].shareNum)&#13;
       endRound(_indexNo);      &#13;
  }   &#13;
 &#13;
  /** @dev get round's shareholder vote result&#13;
    * @param _indexNo  round's index No &#13;
    * @return _votesEnd  votes amount to end round&#13;
    * @return _voteAll  all votes amount&#13;
  */ &#13;
  function getRdVotesCount(uint256 _indexNo)&#13;
  public &#13;
  view &#13;
  returns(uint256 _votesEnd, uint256 _voteAll)&#13;
  { &#13;
    require(checkRdInVoteState(_indexNo));&#13;
&#13;
    uint256 nowTime = now;&#13;
    uint256 shrVotesEnd = 0;    &#13;
    uint256 timeStart = getRdLastCntDownStart(_indexNo, nowTime);&#13;
    &#13;
    if(timeStart &gt; 0 &amp;&amp; rdInfos[_indexNo].lastShrVoteTime &gt; (timeStart + rdTicketTime))   &#13;
      shrVotesEnd = rdInfos[_indexNo].shrVotesEnd;    &#13;
          &#13;
    return (shrVotesEnd, rdInfos[_indexNo].shareNum);&#13;
  } &#13;
&#13;
  /**&#13;
  * @dev end game round,then start new round&#13;
  * @param _indexNo  round's index No  &#13;
  */&#13;
  function endRound(uint256 _indexNo)&#13;
  internal &#13;
  {   &#13;
    rdInfos[_indexNo].state = rdStateEnd;&#13;
&#13;
    owner().transfer(serviceFeeCnt);   &#13;
    serviceFeeCnt = 0; &#13;
&#13;
    emit event_endRound(_indexNo, rdInfos[_indexNo].lastTckBuyer, rdInfos[_indexNo].shrJackpot);&#13;
&#13;
    startNewRound();   &#13;
  }  &#13;
  &#13;
  /** @dev get user from referer id&#13;
    * @param _refCode  referer id &#13;
    * @return _addr  user account&#13;
  */&#13;
  function getAddrOfRefCode(uint256 _refCode) &#13;
  internal &#13;
  view &#13;
  returns(address _addr) &#13;
  {  &#13;
    if(userIDAddr[_refCode] != address(0))&#13;
      return userIDAddr[_refCode];&#13;
    return address(0);&#13;
  } &#13;
&#13;
  /** @dev check user registered?  &#13;
    * @param _addr  user account&#13;
    * @return _result exist or not&#13;
  */&#13;
  function checkUserExist(address _addr)&#13;
  internal &#13;
  view &#13;
  returns(bool _result) &#13;
  {&#13;
    if(userAccs[_addr].refCode != 0)&#13;
      return true;&#13;
    return false;&#13;
  }&#13;
  &#13;
  /** @dev check round exist?  &#13;
    * @param _indexNo  round's index no&#13;
    * @return _result  exist or not&#13;
  */&#13;
  function checkRdExist(uint256 _indexNo) &#13;
  internal &#13;
  view &#13;
  returns(bool _result) &#13;
  {&#13;
    if(rdInfos[_indexNo].state &gt; 0)&#13;
      return true;&#13;
    return false;&#13;
  }&#13;
  &#13;
  /** @dev check round is active?  &#13;
    * @param _indexNo  round's index no&#13;
    * @return _result  active or not&#13;
  */&#13;
  function checkRdActive(uint256 _indexNo) &#13;
  internal &#13;
  view &#13;
  returns(bool _result) &#13;
  {&#13;
    require(checkRdExist(_indexNo));&#13;
    &#13;
    if(rdInfos[_indexNo].state == rdStateActive)&#13;
        return true;&#13;
    return false;&#13;
  }&#13;
 &#13;
  /** @dev check round is in vote state?  &#13;
    * @param _indexNo  round's index no&#13;
    * @return _result  in vote state or not&#13;
  */&#13;
  function checkRdInVoteState(uint256 _indexNo)&#13;
  internal &#13;
  view &#13;
  returns(bool _result) &#13;
  {&#13;
    require(checkRdActive(_indexNo));&#13;
&#13;
    uint256 timeState = 0;&#13;
  &#13;
    (timeState,) = getRdTimeState(_indexNo);&#13;
    if(timeState == 2)&#13;
        return true;&#13;
&#13;
    return false;&#13;
  }&#13;
  &#13;
  /** @dev check user is shareholder in a round?  &#13;
    * @param _indexNo  round's index no&#13;
    * @param _addr  shareholder account&#13;
    * @return _result  is shareholder or not&#13;
  */&#13;
  function checkShareholderInRd(uint256 _indexNo, address _addr) &#13;
  public &#13;
  view &#13;
  returns(bool _result) &#13;
  {&#13;
    require(checkRdExist(_indexNo));&#13;
&#13;
    if(rdShareholders[_indexNo][_addr].shareNum &gt; 0)&#13;
      return true;&#13;
    return false;&#13;
  }&#13;
&#13;
  /** @dev check user is ticket buyer in a round?  &#13;
    * @param _indexNo  round's index no&#13;
    * @param _addr  ticket buyer account&#13;
    * @return _result  is ticket buyer or not&#13;
  */&#13;
  function checkTicketBuyerInRd(uint256 _indexNo, address _addr) &#13;
  public &#13;
  view &#13;
  returns(bool _result) &#13;
  {&#13;
    require(checkRdExist(_indexNo));&#13;
&#13;
    if(rdTckBuyers[_indexNo][_addr].ticketNum &gt; 0)&#13;
      return true;&#13;
    return false;&#13;
  }&#13;
  &#13;
  /** @dev check user in a round and didn't withdraw yet?  &#13;
    * @param _indexNo  round's index no&#13;
    * @param _addr  user account&#13;
    * @return _result  in or not&#13;
  */&#13;
  function checkUserInUnWithdrawRd(uint256 _indexNo, address _addr) &#13;
  internal &#13;
  view &#13;
  returns(bool _result) &#13;
  {&#13;
    require(checkUserExist(_addr));&#13;
    require(checkRdExist(_indexNo));&#13;
    &#13;
    for(uint256 i = 0; i &lt; userUnWithdrawRound[_addr].length; i++)&#13;
    {&#13;
      if(userUnWithdrawRound[_addr][i] == _indexNo)&#13;
        return true;&#13;
    }&#13;
&#13;
    return false;&#13;
  }&#13;
&#13;
  /** @dev get shareholder's vote  &#13;
    * @param _indexNo  round's index no&#13;
    * @param _addr  shareholder account&#13;
    * @param _nowTime  current time&#13;
    * @return _result  shareholder's vote &#13;
  */&#13;
  function getRdshareholderVoteVal(uint256 _indexNo, address _addr, uint256 _nowTime) &#13;
  internal &#13;
  view &#13;
  returns(uint256 _result) &#13;
  {&#13;
    uint256 timeStart = getRdLastCntDownStart(_indexNo, _nowTime);&#13;
    if(rdShareholders[_indexNo][_addr].vote == 1 &amp;&amp; rdShareholders[_indexNo][_addr].lastShrVoteTime &gt; (timeStart + rdTicketTime))                  &#13;
      return 1;&#13;
&#13;
    return 0;&#13;
  }&#13;
&#13;
  /** @dev calculate service fee&#13;
    * @param _cost  buyer's cost   &#13;
  */&#13;
  function calcServiceFee(uint256 _cost) &#13;
  internal&#13;
  {    &#13;
    serviceFeeCnt += (_cost * serviceFee) / 100;&#13;
    if(serviceFeeCnt &gt;= 1 ether)&#13;
    { &#13;
      owner().transfer(serviceFeeCnt);   &#13;
      serviceFeeCnt = 0; &#13;
    }  &#13;
  }  &#13;
  &#13;
&#13;
}&#13;
&#13;
&#13;
library SafeMath {&#13;
  function mul(uint256 a, uint256 b) &#13;
  internal &#13;
  pure &#13;
  returns(uint256) &#13;
  {&#13;
    if(a == 0) {&#13;
      return 0;&#13;
    }&#13;
    uint256 c = a * b;&#13;
    assert(c / a == b);&#13;
    return c;&#13;
  }&#13;
&#13;
  function div(uint256 a, uint256 b) &#13;
  internal &#13;
  pure &#13;
  returns(uint256) &#13;
  {    &#13;
    uint256 c = a / b;    &#13;
    return c;&#13;
  }&#13;
&#13;
  function sub(uint256 a, uint256 b) &#13;
  internal &#13;
  pure &#13;
  returns(uint256) &#13;
  {&#13;
    assert(b &lt;= a);&#13;
    return a - b;&#13;
  }&#13;
&#13;
  function add(uint256 a, uint256 b) &#13;
  internal &#13;
  pure &#13;
  returns(uint256) &#13;
  {&#13;
    uint256 c = a + b;&#13;
    assert(c &gt;= a);&#13;
    return c;&#13;
  }&#13;
}