// File: contracts/GodMode.sol

/****************************************************
 *
 * Copyright 2018 BurzNest LLC. All rights reserved.
 *
 * The contents of this file are provided for review
 * and educational purposes ONLY. You MAY NOT use,
 * copy, distribute, or modify this software without
 * explicit written permission from BurzNest LLC.
 *
 ****************************************************/

pragma solidity ^0.4.24;

/// @title God Mode
/// @author Anthony Burzillo <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="f09285828ab09285828a9e958384de939f9d">[email protected]</a>&gt;&#13;
/// @dev This contract provides a basic interface for God&#13;
///  in a contract as well as the ability for God to pause&#13;
///  the contract&#13;
contract GodMode {&#13;
    /// @dev Is the contract paused?&#13;
    bool public isPaused;&#13;
&#13;
    /// @dev God's address&#13;
    address public god;&#13;
&#13;
    /// @dev Only God can run this function&#13;
    modifier onlyGod()&#13;
    {&#13;
        require(god == msg.sender);&#13;
        _;&#13;
    }&#13;
&#13;
    /// @dev This function can only be run while the contract&#13;
    ///  is not paused&#13;
    modifier notPaused()&#13;
    {&#13;
        require(!isPaused);&#13;
        _;&#13;
    }&#13;
&#13;
    /// @dev This event is fired when the contract is paused&#13;
    event GodPaused();&#13;
&#13;
    /// @dev This event is fired when the contract is unpaused&#13;
    event GodUnpaused();&#13;
&#13;
    constructor() public&#13;
    {&#13;
        // Make the creator of the contract God&#13;
        god = msg.sender;&#13;
    }&#13;
&#13;
    /// @dev God can change the address of God&#13;
    /// @param _newGod The new address for God&#13;
    function godChangeGod(address _newGod) public onlyGod&#13;
    {&#13;
        god = _newGod;&#13;
    }&#13;
&#13;
    /// @dev God can pause the game&#13;
    function godPause() public onlyGod&#13;
    {&#13;
        isPaused = true;&#13;
&#13;
        emit GodPaused();&#13;
    }&#13;
&#13;
    /// @dev God can unpause the game&#13;
    function godUnpause() public onlyGod&#13;
    {&#13;
        isPaused = false;&#13;
&#13;
        emit GodUnpaused();&#13;
    }&#13;
}&#13;
&#13;
// File: contracts/KingOfEthEthExchangeReferencer.sol&#13;
&#13;
/****************************************************&#13;
 *&#13;
 * Copyright 2018 BurzNest LLC. All rights reserved.&#13;
 *&#13;
 * The contents of this file are provided for review&#13;
 * and educational purposes ONLY. You MAY NOT use,&#13;
 * copy, distribute, or modify this software without&#13;
 * explicit written permission from BurzNest LLC.&#13;
 *&#13;
 ****************************************************/&#13;
&#13;
pragma solidity ^0.4.24;&#13;
&#13;
&#13;
/// @title King of Eth: Resource-to-ETH Exchange Referencer&#13;
/// @author Anthony Burzillo &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="d4b6a1a6ae94b6a1a6aebab1a7a0fab7bbb9">[email protected]</a>&gt;&#13;
/// @dev Provides functionality to interface with the&#13;
///  ETH exchange contract&#13;
contract KingOfEthEthExchangeReferencer is GodMode {&#13;
    /// @dev Address of the ETH exchange contract&#13;
    address public ethExchangeContract;&#13;
&#13;
    /// @dev Only the ETH exchange contract may run this function&#13;
    modifier onlyEthExchangeContract()&#13;
    {&#13;
        require(ethExchangeContract == msg.sender);&#13;
        _;&#13;
    }&#13;
&#13;
    /// @dev God may set the ETH exchange contract's address&#13;
    /// @dev _ethExchangeContract The new address&#13;
    function godSetEthExchangeContract(address _ethExchangeContract)&#13;
        public&#13;
        onlyGod&#13;
    {&#13;
        ethExchangeContract = _ethExchangeContract;&#13;
    }&#13;
}&#13;
&#13;
// File: contracts/KingOfEthResourceExchangeReferencer.sol&#13;
&#13;
/****************************************************&#13;
 *&#13;
 * Copyright 2018 BurzNest LLC. All rights reserved.&#13;
 *&#13;
 * The contents of this file are provided for review&#13;
 * and educational purposes ONLY. You MAY NOT use,&#13;
 * copy, distribute, or modify this software without&#13;
 * explicit written permission from BurzNest LLC.&#13;
 *&#13;
 ****************************************************/&#13;
&#13;
pragma solidity ^0.4.24;&#13;
&#13;
&#13;
/// @title King of Eth: Resource-to-Resource Exchange Referencer&#13;
/// @author Anthony Burzillo &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="d3b1a6a1a993b1a6a1a9bdb6a0a7fdb0bcbe">[email protected]</a>&gt;&#13;
/// @dev Provides functionality to interface with the&#13;
///  resource-to-resource contract&#13;
contract KingOfEthResourceExchangeReferencer is GodMode {&#13;
    /// @dev Address of the resource-to-resource contract&#13;
    address public resourceExchangeContract;&#13;
&#13;
    /// @dev Only the resource-to-resource contract may run this function&#13;
    modifier onlyResourceExchangeContract()&#13;
    {&#13;
        require(resourceExchangeContract == msg.sender);&#13;
        _;&#13;
    }&#13;
&#13;
    /// @dev God may set the resource-to-resource contract's address&#13;
    /// @dev _resourceExchangeContract The new address&#13;
    function godSetResourceExchangeContract(address _resourceExchangeContract)&#13;
        public&#13;
        onlyGod&#13;
    {&#13;
        resourceExchangeContract = _resourceExchangeContract;&#13;
    }&#13;
}&#13;
&#13;
// File: contracts/KingOfEthExchangeReferencer.sol&#13;
&#13;
/****************************************************&#13;
 *&#13;
 * Copyright 2018 BurzNest LLC. All rights reserved.&#13;
 *&#13;
 * The contents of this file are provided for review&#13;
 * and educational purposes ONLY. You MAY NOT use,&#13;
 * copy, distribute, or modify this software without&#13;
 * explicit written permission from BurzNest LLC.&#13;
 *&#13;
 ****************************************************/&#13;
&#13;
pragma solidity ^0.4.24;&#13;
&#13;
&#13;
&#13;
&#13;
/// @title King of Eth: Exchange Referencer&#13;
/// @author Anthony Burzillo &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="f19384838bb19384838b9f948285df929e9c">[email protected]</a>&gt;&#13;
/// @dev Provides functionality to interface with the exchange contract&#13;
contract KingOfEthExchangeReferencer is&#13;
      GodMode&#13;
    , KingOfEthEthExchangeReferencer&#13;
    , KingOfEthResourceExchangeReferencer&#13;
{&#13;
    /// @dev Only one of the exchange contracts may&#13;
    ///  run this function&#13;
    modifier onlyExchangeContract()&#13;
    {&#13;
        require(&#13;
               ethExchangeContract == msg.sender&#13;
            || resourceExchangeContract == msg.sender&#13;
        );&#13;
        _;&#13;
    }&#13;
}&#13;
&#13;
// File: contracts/KingOfEthHousesReferencer.sol&#13;
&#13;
/****************************************************&#13;
 *&#13;
 * Copyright 2018 BurzNest LLC. All rights reserved.&#13;
 *&#13;
 * The contents of this file are provided for review&#13;
 * and educational purposes ONLY. You MAY NOT use,&#13;
 * copy, distribute, or modify this software without&#13;
 * explicit written permission from BurzNest LLC.&#13;
 *&#13;
 ****************************************************/&#13;
&#13;
pragma solidity ^0.4.24;&#13;
&#13;
&#13;
/// @title King of Eth: Houses Referencer&#13;
/// @author Anthony Burzillo &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="bddfc8cfc7fddfc8cfc7d3d8cec993ded2d0">[email protected]</a>&gt;&#13;
/// @dev Provides functionality to reference the houses contract&#13;
contract KingOfEthHousesReferencer is GodMode {&#13;
    /// @dev The houses contract's address&#13;
    address public housesContract;&#13;
&#13;
    /// @dev Only the houses contract can run this function&#13;
    modifier onlyHousesContract()&#13;
    {&#13;
        require(housesContract == msg.sender);&#13;
        _;&#13;
    }&#13;
&#13;
    /// @dev God can set the realty contract&#13;
    /// @param _housesContract The new address&#13;
    function godSetHousesContract(address _housesContract)&#13;
        public&#13;
        onlyGod&#13;
    {&#13;
        housesContract = _housesContract;&#13;
    }&#13;
}&#13;
&#13;
// File: contracts/KingOfEthResourcesInterfaceReferencer.sol&#13;
&#13;
/****************************************************&#13;
 *&#13;
 * Copyright 2018 BurzNest LLC. All rights reserved.&#13;
 *&#13;
 * The contents of this file are provided for review&#13;
 * and educational purposes ONLY. You MAY NOT use,&#13;
 * copy, distribute, or modify this software without&#13;
 * explicit written permission from BurzNest LLC.&#13;
 *&#13;
 ****************************************************/&#13;
&#13;
pragma solidity ^0.4.24;&#13;
&#13;
&#13;
/// @title King of Eth: Resources Interface Referencer&#13;
/// @author Anthony Burzillo &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="670512151d270512151d090214134904080a">[email protected]</a>&gt;&#13;
/// @dev Provides functionality to reference the resource interface contract&#13;
contract KingOfEthResourcesInterfaceReferencer is GodMode {&#13;
    /// @dev The interface contract's address&#13;
    address public interfaceContract;&#13;
&#13;
    /// @dev Only the interface contract can run this function&#13;
    modifier onlyInterfaceContract()&#13;
    {&#13;
        require(interfaceContract == msg.sender);&#13;
        _;&#13;
    }&#13;
&#13;
    /// @dev God can set the realty contract&#13;
    /// @param _interfaceContract The new address&#13;
    function godSetInterfaceContract(address _interfaceContract)&#13;
        public&#13;
        onlyGod&#13;
    {&#13;
        interfaceContract = _interfaceContract;&#13;
    }&#13;
}&#13;
&#13;
// File: contracts/KingOfEthResource.sol&#13;
&#13;
/****************************************************&#13;
 *&#13;
 * Copyright 2018 BurzNest LLC. All rights reserved.&#13;
 *&#13;
 * The contents of this file are provided for review&#13;
 * and educational purposes ONLY. You MAY NOT use,&#13;
 * copy, distribute, or modify this software without&#13;
 * explicit written permission from BurzNest LLC.&#13;
 *&#13;
 ****************************************************/&#13;
&#13;
pragma solidity ^0.4.24;&#13;
&#13;
&#13;
&#13;
/// @title ERC20Interface&#13;
/// @dev ERC20 token interface contract&#13;
contract ERC20Interface {&#13;
    function totalSupply() public constant returns(uint);&#13;
    function balanceOf(address _tokenOwner) public constant returns(uint balance);&#13;
    function allowance(address _tokenOwner, address _spender) public constant returns(uint remaining);&#13;
    function transfer(address _to, uint _tokens) public returns(bool success);&#13;
    function approve(address _spender, uint _tokens) public returns(bool success);&#13;
    function transferFrom(address _from, address _to, uint _tokens) public returns(bool success);&#13;
&#13;
    event Transfer(address indexed from, address indexed to, uint tokens);&#13;
    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);&#13;
}&#13;
&#13;
/// @title King of Eth: Resource&#13;
/// @author Anthony Burzillo &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="721007000832100700081c1701065c111d1f">[email protected]</a>&gt;&#13;
/// @dev Common contract implementation for resources&#13;
contract KingOfEthResource is&#13;
      ERC20Interface&#13;
    , GodMode&#13;
    , KingOfEthResourcesInterfaceReferencer&#13;
{&#13;
    /// @dev Current resource supply&#13;
    uint public resourceSupply;&#13;
&#13;
    /// @dev ERC20 token's decimals&#13;
    uint8 public constant decimals = 0;&#13;
&#13;
    /// @dev mapping of addresses to holdings&#13;
    mapping (address =&gt; uint) holdings;&#13;
&#13;
    /// @dev mapping of addresses to amount of tokens frozen&#13;
    mapping (address =&gt; uint) frozenHoldings;&#13;
&#13;
    /// @dev mapping of addresses to mapping of allowances for an address&#13;
    mapping (address =&gt; mapping (address =&gt; uint)) allowances;&#13;
&#13;
    /// @dev ERC20 total supply&#13;
    /// @return The current total supply of the resource&#13;
    function totalSupply()&#13;
        public&#13;
        constant&#13;
        returns(uint)&#13;
    {&#13;
        return resourceSupply;&#13;
    }&#13;
&#13;
    /// @dev ERC20 balance of address&#13;
    /// @param _tokenOwner The address to look up&#13;
    /// @return The balance of the address&#13;
    function balanceOf(address _tokenOwner)&#13;
        public&#13;
        constant&#13;
        returns(uint balance)&#13;
    {&#13;
        return holdings[_tokenOwner];&#13;
    }&#13;
&#13;
    /// @dev Total resources frozen for an address&#13;
    /// @param _tokenOwner The address to look up&#13;
    /// @return The frozen balance of the address&#13;
    function frozenTokens(address _tokenOwner)&#13;
        public&#13;
        constant&#13;
        returns(uint balance)&#13;
    {&#13;
        return frozenHoldings[_tokenOwner];&#13;
    }&#13;
&#13;
    /// @dev The allowance for a spender on an account&#13;
    /// @param _tokenOwner The account that allows withdrawels&#13;
    /// @param _spender The account that is allowed to withdraw&#13;
    /// @return The amount remaining in the allowance&#13;
    function allowance(address _tokenOwner, address _spender)&#13;
        public&#13;
        constant&#13;
        returns(uint remaining)&#13;
    {&#13;
        return allowances[_tokenOwner][_spender];&#13;
    }&#13;
&#13;
    /// @dev Only run if player has at least some amount of tokens&#13;
    /// @param _owner The owner of the tokens&#13;
    /// @param _tokens The amount of tokens required&#13;
    modifier hasAvailableTokens(address _owner, uint _tokens)&#13;
    {&#13;
        require(holdings[_owner] - frozenHoldings[_owner] &gt;= _tokens);&#13;
        _;&#13;
    }&#13;
&#13;
    /// @dev Only run if player has at least some amount of tokens frozen&#13;
    /// @param _owner The owner of the tokens&#13;
    /// @param _tokens The amount of frozen tokens required&#13;
    modifier hasFrozenTokens(address _owner, uint _tokens)&#13;
    {&#13;
        require(frozenHoldings[_owner] &gt;= _tokens);&#13;
        _;&#13;
    }&#13;
&#13;
    /// @dev Set up the exact same state in each resource&#13;
    constructor() public&#13;
    {&#13;
        // God gets 200 to put on exchange&#13;
        holdings[msg.sender] = 200;&#13;
&#13;
        resourceSupply = 200;&#13;
    }&#13;
&#13;
    /// @dev The resources interface can burn tokens for building&#13;
    ///  roads or houses&#13;
    /// @param _owner The owner of the tokens&#13;
    /// @param _tokens The amount of tokens to burn&#13;
    function interfaceBurnTokens(address _owner, uint _tokens)&#13;
        public&#13;
        onlyInterfaceContract&#13;
        hasAvailableTokens(_owner, _tokens)&#13;
    {&#13;
        holdings[_owner] -= _tokens;&#13;
&#13;
        resourceSupply -= _tokens;&#13;
&#13;
        // Pretend the tokens were sent to 0x0&#13;
        emit Transfer(_owner, 0x0, _tokens);&#13;
    }&#13;
&#13;
    /// @dev The resources interface contract can mint tokens for houses&#13;
    /// @param _owner The owner of the tokens&#13;
    /// @param _tokens The amount of tokens to burn&#13;
    function interfaceMintTokens(address _owner, uint _tokens)&#13;
        public&#13;
        onlyInterfaceContract&#13;
    {&#13;
        holdings[_owner] += _tokens;&#13;
&#13;
        resourceSupply += _tokens;&#13;
&#13;
        // Pretend the tokens were sent from the interface contract&#13;
        emit Transfer(interfaceContract, _owner, _tokens);&#13;
    }&#13;
&#13;
    /// @dev The interface can freeze tokens&#13;
    /// @param _owner The owner of the tokens&#13;
    /// @param _tokens The amount of tokens to freeze&#13;
    function interfaceFreezeTokens(address _owner, uint _tokens)&#13;
        public&#13;
        onlyInterfaceContract&#13;
        hasAvailableTokens(_owner, _tokens)&#13;
    {&#13;
        frozenHoldings[_owner] += _tokens;&#13;
    }&#13;
&#13;
    /// @dev The interface can thaw tokens&#13;
    /// @param _owner The owner of the tokens&#13;
    /// @param _tokens The amount of tokens to thaw&#13;
    function interfaceThawTokens(address _owner, uint _tokens)&#13;
        public&#13;
        onlyInterfaceContract&#13;
        hasFrozenTokens(_owner, _tokens)&#13;
    {&#13;
        frozenHoldings[_owner] -= _tokens;&#13;
    }&#13;
&#13;
    /// @dev The interface can transfer tokens&#13;
    /// @param _from The owner of the tokens&#13;
    /// @param _to The new owner of the tokens&#13;
    /// @param _tokens The amount of tokens to transfer&#13;
    function interfaceTransfer(address _from, address _to, uint _tokens)&#13;
        public&#13;
        onlyInterfaceContract&#13;
    {&#13;
        assert(holdings[_from] &gt;= _tokens);&#13;
&#13;
        holdings[_from] -= _tokens;&#13;
        holdings[_to]   += _tokens;&#13;
&#13;
        emit Transfer(_from, _to, _tokens);&#13;
    }&#13;
&#13;
    /// @dev The interface can transfer frozend tokens&#13;
    /// @param _from The owner of the tokens&#13;
    /// @param _to The new owner of the tokens&#13;
    /// @param _tokens The amount of frozen tokens to transfer&#13;
    function interfaceFrozenTransfer(address _from, address _to, uint _tokens)&#13;
        public&#13;
        onlyInterfaceContract&#13;
        hasFrozenTokens(_from, _tokens)&#13;
    {&#13;
        // Make sure to deduct the tokens from both the total and frozen amounts&#13;
        holdings[_from]       -= _tokens;&#13;
        frozenHoldings[_from] -= _tokens;&#13;
        holdings[_to]         += _tokens;&#13;
&#13;
        emit Transfer(_from, _to, _tokens);&#13;
    }&#13;
&#13;
    /// @dev ERC20 transfer&#13;
    /// @param _to The address to transfer to&#13;
    /// @param _tokens The amount of tokens to transfer&#13;
    function transfer(address _to, uint _tokens)&#13;
        public&#13;
        hasAvailableTokens(msg.sender, _tokens)&#13;
        returns(bool success)&#13;
    {&#13;
        holdings[_to]        += _tokens;&#13;
        holdings[msg.sender] -= _tokens;&#13;
&#13;
        emit Transfer(msg.sender, _to, _tokens);&#13;
&#13;
        return true;&#13;
    }&#13;
&#13;
    /// @dev ERC20 approve&#13;
    /// @param _spender The address to approve&#13;
    /// @param _tokens The amount of tokens to approve&#13;
    function approve(address _spender, uint _tokens)&#13;
        public&#13;
        returns(bool success)&#13;
    {&#13;
        allowances[msg.sender][_spender] = _tokens;&#13;
&#13;
        emit Approval(msg.sender, _spender, _tokens);&#13;
&#13;
        return true;&#13;
    }&#13;
&#13;
    /// @dev ERC20 transfer from&#13;
    /// @param _from The address providing the allowance&#13;
    /// @param _to The address using the allowance&#13;
    /// @param _tokens The amount of tokens to transfer&#13;
    function transferFrom(address _from, address _to, uint _tokens)&#13;
        public&#13;
        hasAvailableTokens(_from, _tokens)&#13;
        returns(bool success)&#13;
    {&#13;
        require(allowances[_from][_to] &gt;= _tokens);&#13;
&#13;
        holdings[_to]          += _tokens;&#13;
        holdings[_from]        -= _tokens;&#13;
        allowances[_from][_to] -= _tokens;&#13;
&#13;
        emit Transfer(_from, _to, _tokens);&#13;
&#13;
        return true;&#13;
    }&#13;
}&#13;
&#13;
// File: contracts/KingOfEthResourceType.sol&#13;
&#13;
/****************************************************&#13;
 *&#13;
 * Copyright 2018 BurzNest LLC. All rights reserved.&#13;
 *&#13;
 * The contents of this file are provided for review&#13;
 * and educational purposes ONLY. You MAY NOT use,&#13;
 * copy, distribute, or modify this software without&#13;
 * explicit written permission from BurzNest LLC.&#13;
 *&#13;
 ****************************************************/&#13;
&#13;
pragma solidity ^0.4.24;&#13;
&#13;
/// @title King of Eth: Resource Type&#13;
/// @author Anthony Burzillo &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="1a786f68605a786f6860747f696e34797577">[email protected]</a>&gt;&#13;
/// @dev Provides enum to choose resource types&#13;
contract KingOfEthResourceType {&#13;
    /// @dev Enum describing a choice of a resource&#13;
    enum ResourceType {&#13;
          ETH&#13;
        , BRONZE&#13;
        , CORN&#13;
        , GOLD&#13;
        , OIL&#13;
        , ORE&#13;
        , STEEL&#13;
        , URANIUM&#13;
        , WOOD&#13;
    }&#13;
}&#13;
&#13;
// File: contracts/KingOfEthRoadsReferencer.sol&#13;
&#13;
/****************************************************&#13;
 *&#13;
 * Copyright 2018 BurzNest LLC. All rights reserved.&#13;
 *&#13;
 * The contents of this file are provided for review&#13;
 * and educational purposes ONLY. You MAY NOT use,&#13;
 * copy, distribute, or modify this software without&#13;
 * explicit written permission from BurzNest LLC.&#13;
 *&#13;
 ****************************************************/&#13;
&#13;
pragma solidity ^0.4.24;&#13;
&#13;
&#13;
/// @title King of Eth: Roads Referencer&#13;
/// @author Anthony Burzillo &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="84e6f1f6fec4e6f1f6feeae1f7f0aae7ebe9">[email protected]</a>&gt;&#13;
/// @dev Provides functionality to reference the roads contract&#13;
contract KingOfEthRoadsReferencer is GodMode {&#13;
    /// @dev The roads contract's address&#13;
    address public roadsContract;&#13;
&#13;
    /// @dev Only the roads contract can run this function&#13;
    modifier onlyRoadsContract()&#13;
    {&#13;
        require(roadsContract == msg.sender);&#13;
        _;&#13;
    }&#13;
&#13;
    /// @dev God can set the realty contract&#13;
    /// @param _roadsContract The new address&#13;
    function godSetRoadsContract(address _roadsContract)&#13;
        public&#13;
        onlyGod&#13;
    {&#13;
        roadsContract = _roadsContract;&#13;
    }&#13;
}&#13;
&#13;
// File: contracts/KingOfEthResourcesInterface.sol&#13;
&#13;
/****************************************************&#13;
 *&#13;
 * Copyright 2018 BurzNest LLC. All rights reserved.&#13;
 *&#13;
 * The contents of this file are provided for review&#13;
 * and educational purposes ONLY. You MAY NOT use,&#13;
 * copy, distribute, or modify this software without&#13;
 * explicit written permission from BurzNest LLC.&#13;
 *&#13;
 ****************************************************/&#13;
&#13;
pragma solidity ^0.4.24;&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
/// @title King of Eth: Resources Interface&#13;
/// @author Anthony Burzillo &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="791b0c0b03391b0c0b03171c0a0d571a1614">[email protected]</a>&gt;&#13;
/// @dev Contract for interacting with resources&#13;
contract KingOfEthResourcesInterface is&#13;
      GodMode&#13;
    , KingOfEthExchangeReferencer&#13;
    , KingOfEthHousesReferencer&#13;
    , KingOfEthResourceType&#13;
    , KingOfEthRoadsReferencer&#13;
{&#13;
    /// @dev Amount of resources a user gets for building a house&#13;
    uint public constant resourcesPerHouse = 3;&#13;
&#13;
    /// @dev Address for the bronze contract&#13;
    address public bronzeContract;&#13;
&#13;
    /// @dev Address for the corn contract&#13;
    address public cornContract;&#13;
&#13;
    /// @dev Address for the gold contract&#13;
    address public goldContract;&#13;
&#13;
    /// @dev Address for the oil contract&#13;
    address public oilContract;&#13;
&#13;
    /// @dev Address for the ore contract&#13;
    address public oreContract;&#13;
&#13;
    /// @dev Address for the steel contract&#13;
    address public steelContract;&#13;
&#13;
    /// @dev Address for the uranium contract&#13;
    address public uraniumContract;&#13;
&#13;
    /// @dev Address for the wood contract&#13;
    address public woodContract;&#13;
&#13;
    /// @param _bronzeContract The address of the bronze contract&#13;
    /// @param _cornContract The address of the corn contract&#13;
    /// @param _goldContract The address of the gold contract&#13;
    /// @param _oilContract The address of the oil contract&#13;
    /// @param _oreContract The address of the ore contract&#13;
    /// @param _steelContract The address of the steel contract&#13;
    /// @param _uraniumContract The address of the uranium contract&#13;
    /// @param _woodContract The address of the wood contract&#13;
    constructor(&#13;
          address _bronzeContract&#13;
        , address _cornContract&#13;
        , address _goldContract&#13;
        , address _oilContract&#13;
        , address _oreContract&#13;
        , address _steelContract&#13;
        , address _uraniumContract&#13;
        , address _woodContract&#13;
    )&#13;
        public&#13;
    {&#13;
        bronzeContract  = _bronzeContract;&#13;
        cornContract    = _cornContract;&#13;
        goldContract    = _goldContract;&#13;
        oilContract     = _oilContract;&#13;
        oreContract     = _oreContract;&#13;
        steelContract   = _steelContract;&#13;
        uraniumContract = _uraniumContract;&#13;
        woodContract    = _woodContract;&#13;
    }&#13;
&#13;
    /// @dev Return the particular address for a certain resource type&#13;
    /// @param _type The resource type&#13;
    /// @return The address for that resource&#13;
    function contractFor(ResourceType _type)&#13;
        public&#13;
        view&#13;
        returns(address)&#13;
    {&#13;
        // ETH does not have a contract&#13;
        require(ResourceType.ETH != _type);&#13;
&#13;
        if(ResourceType.BRONZE == _type)&#13;
        {&#13;
            return bronzeContract;&#13;
        }&#13;
        else if(ResourceType.CORN == _type)&#13;
        {&#13;
            return cornContract;&#13;
        }&#13;
        else if(ResourceType.GOLD == _type)&#13;
        {&#13;
            return goldContract;&#13;
        }&#13;
        else if(ResourceType.OIL == _type)&#13;
        {&#13;
            return oilContract;&#13;
        }&#13;
        else if(ResourceType.ORE == _type)&#13;
        {&#13;
            return oreContract;&#13;
        }&#13;
        else if(ResourceType.STEEL == _type)&#13;
        {&#13;
            return steelContract;&#13;
        }&#13;
        else if(ResourceType.URANIUM == _type)&#13;
        {&#13;
            return uraniumContract;&#13;
        }&#13;
        else if(ResourceType.WOOD == _type)&#13;
        {&#13;
            return woodContract;&#13;
        }&#13;
    }&#13;
&#13;
    /// @dev Determine the resource type of a tile&#13;
    /// @param _x The x coordinate of the top left corner of the tile&#13;
    /// @param _y The y coordinate of the top left corner of the tile&#13;
    function resourceType(uint _x, uint _y)&#13;
        public&#13;
        pure&#13;
        returns(ResourceType resource)&#13;
    {&#13;
        uint _seed = (_x + 7777777) ^  _y;&#13;
&#13;
        if(0 == _seed % 97)&#13;
        {&#13;
          return ResourceType.URANIUM;&#13;
        }&#13;
        else if(0 == _seed % 29)&#13;
        {&#13;
          return ResourceType.OIL;&#13;
        }&#13;
        else if(0 == _seed % 23)&#13;
        {&#13;
          return ResourceType.STEEL;&#13;
        }&#13;
        else if(0 == _seed % 17)&#13;
        {&#13;
          return ResourceType.GOLD;&#13;
        }&#13;
        else if(0 == _seed % 11)&#13;
        {&#13;
          return ResourceType.BRONZE;&#13;
        }&#13;
        else if(0 == _seed % 5)&#13;
        {&#13;
          return ResourceType.WOOD;&#13;
        }&#13;
        else if(0 == _seed % 2)&#13;
        {&#13;
          return ResourceType.CORN;&#13;
        }&#13;
        else&#13;
        {&#13;
          return ResourceType.ORE;&#13;
        }&#13;
    }&#13;
&#13;
    /// @dev Lookup the number of resource points for a certain&#13;
    ///  player&#13;
    /// @param _player The player in question&#13;
    function lookupResourcePoints(address _player)&#13;
        public&#13;
        view&#13;
        returns(uint)&#13;
    {&#13;
        uint result = 0;&#13;
&#13;
        result += KingOfEthResource(bronzeContract).balanceOf(_player);&#13;
        result += KingOfEthResource(goldContract).balanceOf(_player)    * 3;&#13;
        result += KingOfEthResource(steelContract).balanceOf(_player)   * 6;&#13;
        result += KingOfEthResource(oilContract).balanceOf(_player)     * 10;&#13;
        result += KingOfEthResource(uraniumContract).balanceOf(_player) * 44;&#13;
&#13;
        return result;&#13;
    }&#13;
&#13;
    /// @dev Burn the resources necessary to build a house&#13;
    /// @param _count the number of houses being built&#13;
    /// @param _player The player who is building the house&#13;
    function burnHouseCosts(uint _count, address _player)&#13;
        public&#13;
        onlyHousesContract&#13;
    {&#13;
        // Costs 2 corn per house&#13;
        KingOfEthResource(contractFor(ResourceType.CORN)).interfaceBurnTokens(&#13;
              _player&#13;
            , 2 * _count&#13;
        );&#13;
&#13;
        // Costs 2 ore per house&#13;
        KingOfEthResource(contractFor(ResourceType.ORE)).interfaceBurnTokens(&#13;
              _player&#13;
            , 2 * _count&#13;
        );&#13;
&#13;
        // Costs 1 wood per house&#13;
        KingOfEthResource(contractFor(ResourceType.WOOD)).interfaceBurnTokens(&#13;
              _player&#13;
            , _count&#13;
        );&#13;
    }&#13;
&#13;
    /// @dev Burn the costs of upgrading a house&#13;
    /// @param _currentLevel The level of the house before the upgrade&#13;
    /// @param _player The player who is upgrading the house&#13;
    function burnUpgradeCosts(uint8 _currentLevel, address _player)&#13;
        public&#13;
        onlyHousesContract&#13;
    {&#13;
        // Do not allow upgrades after level 4&#13;
        require(5 &gt; _currentLevel);&#13;
&#13;
        // Burn the base house cost&#13;
        burnHouseCosts(1, _player);&#13;
&#13;
        if(0 == _currentLevel)&#13;
        {&#13;
            // Level 1 costs bronze&#13;
            KingOfEthResource(contractFor(ResourceType.BRONZE)).interfaceBurnTokens(&#13;
                  _player&#13;
                , 1&#13;
            );&#13;
        }&#13;
        else if(1 == _currentLevel)&#13;
        {&#13;
            // Level 2 costs gold&#13;
            KingOfEthResource(contractFor(ResourceType.GOLD)).interfaceBurnTokens(&#13;
                  _player&#13;
                , 1&#13;
            );&#13;
        }&#13;
        else if(2 == _currentLevel)&#13;
        {&#13;
            // Level 3 costs steel&#13;
            KingOfEthResource(contractFor(ResourceType.STEEL)).interfaceBurnTokens(&#13;
                  _player&#13;
                , 1&#13;
            );&#13;
        }&#13;
        else if(3 == _currentLevel)&#13;
        {&#13;
            // Level 4 costs oil&#13;
            KingOfEthResource(contractFor(ResourceType.OIL)).interfaceBurnTokens(&#13;
                  _player&#13;
                , 1&#13;
            );&#13;
        }&#13;
        else if(4 == _currentLevel)&#13;
        {&#13;
            // Level 5 costs uranium&#13;
            KingOfEthResource(contractFor(ResourceType.URANIUM)).interfaceBurnTokens(&#13;
                  _player&#13;
                , 1&#13;
            );&#13;
        }&#13;
    }&#13;
&#13;
    /// @dev Mint resources for a house and distribute all to its owner&#13;
    /// @param _owner The owner of the house&#13;
    /// @param _x The x coordinate of the house&#13;
    /// @param _y The y coordinate of the house&#13;
    /// @param _y The y coordinate of the house&#13;
    /// @param _level The new level of the house&#13;
    function distributeResources(address _owner, uint _x, uint _y, uint8 _level)&#13;
        public&#13;
        onlyHousesContract&#13;
    {&#13;
        // Calculate the count of resources for this level&#13;
        uint _count = resourcesPerHouse * uint(_level + 1);&#13;
&#13;
        // Distribute the top left resource&#13;
        KingOfEthResource(contractFor(resourceType(_x - 1, _y - 1))).interfaceMintTokens(&#13;
            _owner&#13;
          , _count&#13;
        );&#13;
&#13;
        // Distribute the top right resource&#13;
        KingOfEthResource(contractFor(resourceType(_x, _y - 1))).interfaceMintTokens(&#13;
            _owner&#13;
          , _count&#13;
        );&#13;
&#13;
        // Distribute the bottom right resource&#13;
        KingOfEthResource(contractFor(resourceType(_x, _y))).interfaceMintTokens(&#13;
            _owner&#13;
          , _count&#13;
        );&#13;
&#13;
        // Distribute the bottom left resource&#13;
        KingOfEthResource(contractFor(resourceType(_x - 1, _y))).interfaceMintTokens(&#13;
            _owner&#13;
          , _count&#13;
        );&#13;
    }&#13;
&#13;
    /// @dev Burn the costs necessary to build a road&#13;
    /// @param _length The length of the road&#13;
    /// @param _player The player who is building the house&#13;
    function burnRoadCosts(uint _length, address _player)&#13;
        public&#13;
        onlyRoadsContract&#13;
    {&#13;
        // Burn corn&#13;
        KingOfEthResource(cornContract).interfaceBurnTokens(&#13;
              _player&#13;
            , _length&#13;
        );&#13;
&#13;
        // Burn ore&#13;
        KingOfEthResource(oreContract).interfaceBurnTokens(&#13;
              _player&#13;
            , _length&#13;
        );&#13;
    }&#13;
&#13;
    /// @dev The exchange can freeze tokens&#13;
    /// @param _type The type of resource&#13;
    /// @param _owner The owner of the tokens&#13;
    /// @param _tokens The amount of tokens to freeze&#13;
    function exchangeFreezeTokens(ResourceType _type, address _owner, uint _tokens)&#13;
        public&#13;
        onlyExchangeContract&#13;
    {&#13;
        KingOfEthResource(contractFor(_type)).interfaceFreezeTokens(_owner, _tokens);&#13;
    }&#13;
&#13;
    /// @dev The exchange can thaw tokens&#13;
    /// @param _type The type of resource&#13;
    /// @param _owner The owner of the tokens&#13;
    /// @param _tokens The amount of tokens to thaw&#13;
    function exchangeThawTokens(ResourceType _type, address _owner, uint _tokens)&#13;
        public&#13;
        onlyExchangeContract&#13;
    {&#13;
        KingOfEthResource(contractFor(_type)).interfaceThawTokens(_owner, _tokens);&#13;
    }&#13;
&#13;
    /// @dev The exchange can transfer tokens&#13;
    /// @param _type The type of resource&#13;
    /// @param _from The owner of the tokens&#13;
    /// @param _to The new owner of the tokens&#13;
    /// @param _tokens The amount of tokens to transfer&#13;
    function exchangeTransfer(ResourceType _type, address _from, address _to, uint _tokens)&#13;
        public&#13;
        onlyExchangeContract&#13;
    {&#13;
        KingOfEthResource(contractFor(_type)).interfaceTransfer(_from, _to, _tokens);&#13;
    }&#13;
&#13;
    /// @dev The exchange can transfer frozend tokens&#13;
    /// @param _type The type of resource&#13;
    /// @param _from The owner of the tokens&#13;
    /// @param _to The new owner of the tokens&#13;
    /// @param _tokens The amount of frozen tokens to transfer&#13;
    function exchangeFrozenTransfer(ResourceType _type, address _from, address _to, uint _tokens)&#13;
        public&#13;
        onlyExchangeContract&#13;
    {&#13;
        KingOfEthResource(contractFor(_type)).interfaceFrozenTransfer(_from, _to, _tokens);&#13;
    }&#13;
}