//File: contracts/ILiquidPledgingPlugin.sol
pragma solidity ^0.4.11;

/*
    Copyright 2017, Jordi Baylina
    Contributors: Adrià Massanet <<span class="__cf_email__" data-cfemail="19787d6b7078597a767d7c7a76776d7c616d377076">[email protected]</span>&gt;, RJ Ewing, Griff&#13;
    Green, Arthur Lunn&#13;
&#13;
    This program is free software: you can redistribute it and/or modify&#13;
    it under the terms of the GNU General Public License as published by&#13;
    the Free Software Foundation, either version 3 of the License, or&#13;
    (at your option) any later version.&#13;
&#13;
    This program is distributed in the hope that it will be useful,&#13;
    but WITHOUT ANY WARRANTY; without even the implied warranty of&#13;
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&#13;
    GNU General Public License for more details.&#13;
&#13;
    You should have received a copy of the GNU General Public License&#13;
    along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.&#13;
*/&#13;
&#13;
&#13;
/// @dev `ILiquidPledgingPlugin` is the basic interface for any&#13;
///  liquid pledging plugin&#13;
contract ILiquidPledgingPlugin {&#13;
&#13;
    /// @notice Plugins are used (much like web hooks) to initiate an action&#13;
    ///  upon any donation, delegation, or transfer; this is an optional feature&#13;
    ///  and allows for extreme customization of the contract. This function&#13;
    ///  implements any action that should be initiated before a transfer.&#13;
    /// @param pledgeManager The admin or current manager of the pledge&#13;
    /// @param pledgeFrom This is the Id from which value will be transfered.&#13;
    /// @param pledgeTo This is the Id that value will be transfered to.    &#13;
    /// @param context The situation that is triggering the plugin:&#13;
    ///  0 -&gt; Plugin for the owner transferring pledge to another party&#13;
    ///  1 -&gt; Plugin for the first delegate transferring pledge to another party&#13;
    ///  2 -&gt; Plugin for the second delegate transferring pledge to another party&#13;
    ///  ...&#13;
    ///  255 -&gt; Plugin for the intendedProject transferring pledge to another party&#13;
    ///&#13;
    ///  256 -&gt; Plugin for the owner receiving pledge to another party&#13;
    ///  257 -&gt; Plugin for the first delegate receiving pledge to another party&#13;
    ///  258 -&gt; Plugin for the second delegate receiving pledge to another party&#13;
    ///  ...&#13;
    ///  511 -&gt; Plugin for the intendedProject receiving pledge to another party&#13;
    /// @param amount The amount of value that will be transfered.&#13;
    function beforeTransfer(&#13;
        uint64 pledgeManager,&#13;
        uint64 pledgeFrom,&#13;
        uint64 pledgeTo,&#13;
        uint64 context,&#13;
        uint amount ) returns (uint maxAllowed);&#13;
&#13;
    /// @notice Plugins are used (much like web hooks) to initiate an action&#13;
    ///  upon any donation, delegation, or transfer; this is an optional feature&#13;
    ///  and allows for extreme customization of the contract. This function&#13;
    ///  implements any action that should be initiated after a transfer.&#13;
    /// @param pledgeManager The admin or current manager of the pledge&#13;
    /// @param pledgeFrom This is the Id from which value will be transfered.&#13;
    /// @param pledgeTo This is the Id that value will be transfered to.    &#13;
    /// @param context The situation that is triggering the plugin:&#13;
    ///  0 -&gt; Plugin for the owner transferring pledge to another party&#13;
    ///  1 -&gt; Plugin for the first delegate transferring pledge to another party&#13;
    ///  2 -&gt; Plugin for the second delegate transferring pledge to another party&#13;
    ///  ...&#13;
    ///  255 -&gt; Plugin for the intendedProject transferring pledge to another party&#13;
    ///&#13;
    ///  256 -&gt; Plugin for the owner receiving pledge to another party&#13;
    ///  257 -&gt; Plugin for the first delegate receiving pledge to another party&#13;
    ///  258 -&gt; Plugin for the second delegate receiving pledge to another party&#13;
    ///  ...&#13;
    ///  511 -&gt; Plugin for the intendedProject receiving pledge to another party&#13;
    ///  @param amount The amount of value that will be transfered.&#13;
    function afterTransfer(&#13;
        uint64 pledgeManager,&#13;
        uint64 pledgeFrom,&#13;
        uint64 pledgeTo,&#13;
        uint64 context,&#13;
        uint amount&#13;
    );&#13;
}&#13;
&#13;
//File: node_modules/giveth-common-contracts/contracts/Owned.sol&#13;
pragma solidity ^0.4.15;&#13;
&#13;
&#13;
/// @title Owned&#13;
/// @author Adrià Massanet &lt;<span class="__cf_email__" data-cfemail="7e1f1a0c171f3e1d111a1b1d11100a1b060a501711">[email protected]</span>&gt;&#13;
/// @notice The Owned contract has an owner address, and provides basic &#13;
///  authorization control functions, this simplifies &amp; the implementation of&#13;
///  user permissions; this contract has three work flows for a change in&#13;
///  ownership, the first requires the new owner to validate that they have the&#13;
///  ability to accept ownership, the second allows the ownership to be&#13;
///  directly transfered without requiring acceptance, and the third allows for&#13;
///  the ownership to be removed to allow for decentralization &#13;
contract Owned {&#13;
&#13;
    address public owner;&#13;
    address public newOwnerCandidate;&#13;
&#13;
    event OwnershipRequested(address indexed by, address indexed to);&#13;
    event OwnershipTransferred(address indexed from, address indexed to);&#13;
    event OwnershipRemoved();&#13;
&#13;
    /// @dev The constructor sets the `msg.sender` as the`owner` of the contract&#13;
    function Owned() public {&#13;
        owner = msg.sender;&#13;
    }&#13;
&#13;
    /// @dev `owner` is the only address that can call a function with this&#13;
    /// modifier&#13;
    modifier onlyOwner() {&#13;
        require (msg.sender == owner);&#13;
        _;&#13;
    }&#13;
    &#13;
    /// @dev In this 1st option for ownership transfer `proposeOwnership()` must&#13;
    ///  be called first by the current `owner` then `acceptOwnership()` must be&#13;
    ///  called by the `newOwnerCandidate`&#13;
    /// @notice `onlyOwner` Proposes to transfer control of the contract to a&#13;
    ///  new owner&#13;
    /// @param _newOwnerCandidate The address being proposed as the new owner&#13;
    function proposeOwnership(address _newOwnerCandidate) public onlyOwner {&#13;
        newOwnerCandidate = _newOwnerCandidate;&#13;
        OwnershipRequested(msg.sender, newOwnerCandidate);&#13;
    }&#13;
&#13;
    /// @notice Can only be called by the `newOwnerCandidate`, accepts the&#13;
    ///  transfer of ownership&#13;
    function acceptOwnership() public {&#13;
        require(msg.sender == newOwnerCandidate);&#13;
&#13;
        address oldOwner = owner;&#13;
        owner = newOwnerCandidate;&#13;
        newOwnerCandidate = 0x0;&#13;
&#13;
        OwnershipTransferred(oldOwner, owner);&#13;
    }&#13;
&#13;
    /// @dev In this 2nd option for ownership transfer `changeOwnership()` can&#13;
    ///  be called and it will immediately assign ownership to the `newOwner`&#13;
    /// @notice `owner` can step down and assign some other address to this role&#13;
    /// @param _newOwner The address of the new owner&#13;
    function changeOwnership(address _newOwner) public onlyOwner {&#13;
        require(_newOwner != 0x0);&#13;
&#13;
        address oldOwner = owner;&#13;
        owner = _newOwner;&#13;
        newOwnerCandidate = 0x0;&#13;
&#13;
        OwnershipTransferred(oldOwner, owner);&#13;
    }&#13;
&#13;
    /// @dev In this 3rd option for ownership transfer `removeOwnership()` can&#13;
    ///  be called and it will immediately assign ownership to the 0x0 address;&#13;
    ///  it requires a 0xdece be input as a parameter to prevent accidental use&#13;
    /// @notice Decentralizes the contract, this operation cannot be undone &#13;
    /// @param _dac `0xdac` has to be entered for this function to work&#13;
    function removeOwnership(address _dac) public onlyOwner {&#13;
        require(_dac == 0xdac);&#13;
        owner = 0x0;&#13;
        newOwnerCandidate = 0x0;&#13;
        OwnershipRemoved();     &#13;
    }&#13;
} &#13;
&#13;
//File: node_modules/giveth-common-contracts/contracts/ERC20.sol&#13;
pragma solidity ^0.4.15;&#13;
&#13;
&#13;
/**&#13;
 * @title ERC20&#13;
 * @dev A standard interface for tokens.&#13;
 * @dev https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md&#13;
 */&#13;
contract ERC20 {&#13;
  &#13;
    /// @dev Returns the total token supply&#13;
    function totalSupply() public constant returns (uint256 supply);&#13;
&#13;
    /// @dev Returns the account balance of the account with address _owner&#13;
    function balanceOf(address _owner) public constant returns (uint256 balance);&#13;
&#13;
    /// @dev Transfers _value number of tokens to address _to&#13;
    function transfer(address _to, uint256 _value) public returns (bool success);&#13;
&#13;
    /// @dev Transfers _value number of tokens from address _from to address _to&#13;
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);&#13;
&#13;
    /// @dev Allows _spender to withdraw from the msg.sender's account up to the _value amount&#13;
    function approve(address _spender, uint256 _value) public returns (bool success);&#13;
&#13;
    /// @dev Returns the amount which _spender is still allowed to withdraw from _owner&#13;
    function allowance(address _owner, address _spender) public constant returns (uint256 remaining);&#13;
&#13;
    event Transfer(address indexed _from, address indexed _to, uint256 _value);&#13;
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);&#13;
&#13;
}&#13;
&#13;
//File: node_modules/giveth-common-contracts/contracts/Escapable.sol&#13;
pragma solidity ^0.4.15;&#13;
/*&#13;
    Copyright 2016, Jordi Baylina&#13;
    Contributor: Adrià Massanet &lt;<span class="__cf_email__" data-cfemail="5b3a3f29323a1b38343f3e3834352f3e232f753234">[email protected]</span>&gt;&#13;
&#13;
    This program is free software: you can redistribute it and/or modify&#13;
    it under the terms of the GNU General Public License as published by&#13;
    the Free Software Foundation, either version 3 of the License, or&#13;
    (at your option) any later version.&#13;
&#13;
    This program is distributed in the hope that it will be useful,&#13;
    but WITHOUT ANY WARRANTY; without even the implied warranty of&#13;
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&#13;
    GNU General Public License for more details.&#13;
&#13;
    You should have received a copy of the GNU General Public License&#13;
    along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.&#13;
*/&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
/// @dev `Escapable` is a base level contract built off of the `Owned`&#13;
///  contract; it creates an escape hatch function that can be called in an&#13;
///  emergency that will allow designated addresses to send any ether or tokens&#13;
///  held in the contract to an `escapeHatchDestination` as long as they were&#13;
///  not blacklisted&#13;
contract Escapable is Owned {&#13;
    address public escapeHatchCaller;&#13;
    address public escapeHatchDestination;&#13;
    mapping (address=&gt;bool) private escapeBlacklist; // Token contract addresses&#13;
&#13;
    /// @notice The Constructor assigns the `escapeHatchDestination` and the&#13;
    ///  `escapeHatchCaller`&#13;
    /// @param _escapeHatchCaller The address of a trusted account or contract&#13;
    ///  to call `escapeHatch()` to send the ether in this contract to the&#13;
    ///  `escapeHatchDestination` it would be ideal that `escapeHatchCaller`&#13;
    ///  cannot move funds out of `escapeHatchDestination`&#13;
    /// @param _escapeHatchDestination The address of a safe location (usu a&#13;
    ///  Multisig) to send the ether held in this contract; if a neutral address&#13;
    ///  is required, the WHG Multisig is an option:&#13;
    ///  0x8Ff920020c8AD673661c8117f2855C384758C572 &#13;
    function Escapable(address _escapeHatchCaller, address _escapeHatchDestination) public {&#13;
        escapeHatchCaller = _escapeHatchCaller;&#13;
        escapeHatchDestination = _escapeHatchDestination;&#13;
    }&#13;
&#13;
    /// @dev The addresses preassigned as `escapeHatchCaller` or `owner`&#13;
    ///  are the only addresses that can call a function with this modifier&#13;
    modifier onlyEscapeHatchCallerOrOwner {&#13;
        require ((msg.sender == escapeHatchCaller)||(msg.sender == owner));&#13;
        _;&#13;
    }&#13;
&#13;
    /// @notice Creates the blacklist of tokens that are not able to be taken&#13;
    ///  out of the contract; can only be done at the deployment, and the logic&#13;
    ///  to add to the blacklist will be in the constructor of a child contract&#13;
    /// @param _token the token contract address that is to be blacklisted &#13;
    function blacklistEscapeToken(address _token) internal {&#13;
        escapeBlacklist[_token] = true;&#13;
        EscapeHatchBlackistedToken(_token);&#13;
    }&#13;
&#13;
    /// @notice Checks to see if `_token` is in the blacklist of tokens&#13;
    /// @param _token the token address being queried&#13;
    /// @return False if `_token` is in the blacklist and can't be taken out of&#13;
    ///  the contract via the `escapeHatch()`&#13;
    function isTokenEscapable(address _token) constant public returns (bool) {&#13;
        return !escapeBlacklist[_token];&#13;
    }&#13;
&#13;
    /// @notice The `escapeHatch()` should only be called as a last resort if a&#13;
    /// security issue is uncovered or something unexpected happened&#13;
    /// @param _token to transfer, use 0x0 for ether&#13;
    function escapeHatch(address _token) public onlyEscapeHatchCallerOrOwner {   &#13;
        require(escapeBlacklist[_token]==false);&#13;
&#13;
        uint256 balance;&#13;
&#13;
        /// @dev Logic for ether&#13;
        if (_token == 0x0) {&#13;
            balance = this.balance;&#13;
            escapeHatchDestination.transfer(balance);&#13;
            EscapeHatchCalled(_token, balance);&#13;
            return;&#13;
        }&#13;
        /// @dev Logic for tokens&#13;
        ERC20 token = ERC20(_token);&#13;
        balance = token.balanceOf(this);&#13;
        require(token.transfer(escapeHatchDestination, balance));&#13;
        EscapeHatchCalled(_token, balance);&#13;
    }&#13;
&#13;
    /// @notice Changes the address assigned to call `escapeHatch()`&#13;
    /// @param _newEscapeHatchCaller The address of a trusted account or&#13;
    ///  contract to call `escapeHatch()` to send the value in this contract to&#13;
    ///  the `escapeHatchDestination`; it would be ideal that `escapeHatchCaller`&#13;
    ///  cannot move funds out of `escapeHatchDestination`&#13;
    function changeHatchEscapeCaller(address _newEscapeHatchCaller) public onlyEscapeHatchCallerOrOwner {&#13;
        escapeHatchCaller = _newEscapeHatchCaller;&#13;
    }&#13;
&#13;
    event EscapeHatchBlackistedToken(address token);&#13;
    event EscapeHatchCalled(address token, uint amount);&#13;
}&#13;
&#13;
//File: contracts/LiquidPledgingBase.sol&#13;
pragma solidity ^0.4.11;&#13;
/*&#13;
    Copyright 2017, Jordi Baylina&#13;
    Contributors: Adrià Massanet &lt;<span class="__cf_email__" data-cfemail="3a5b5e48535b7a59555e5f5955544e5f424e145355">[email protected]</span>&gt;, RJ Ewing, Griff&#13;
    Green, Arthur Lunn&#13;
&#13;
    This program is free software: you can redistribute it and/or modify&#13;
    it under the terms of the GNU General Public License as published by&#13;
    the Free Software Foundation, either version 3 of the License, or&#13;
    (at your option) any later version.&#13;
&#13;
    This program is distributed in the hope that it will be useful,&#13;
    but WITHOUT ANY WARRANTY; without even the implied warranty of&#13;
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&#13;
    GNU General Public License for more details.&#13;
&#13;
    You should have received a copy of the GNU General Public License&#13;
    along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.&#13;
*/&#13;
&#13;
&#13;
&#13;
&#13;
/// @dev This is an interface for `LPVault` which serves as a secure storage for&#13;
///  the ETH that backs the Pledges, only after `LiquidPledging` authorizes&#13;
///  payments can Pledges be converted for ETH&#13;
interface LPVault {&#13;
    function authorizePayment(bytes32 _ref, address _dest, uint _amount);&#13;
    function () payable;&#13;
}&#13;
&#13;
/// @dev `LiquidPledgingBase` is the base level contract used to carry out&#13;
///  liquidPledging's most basic functions, mostly handling and searching the&#13;
///  data structures&#13;
contract LiquidPledgingBase is Escapable {&#13;
&#13;
    // Limits inserted to prevent large loops that could prevent canceling&#13;
    uint constant MAX_DELEGATES = 10;&#13;
    uint constant MAX_SUBPROJECT_LEVEL = 20;&#13;
    uint constant MAX_INTERPROJECT_LEVEL = 20;&#13;
&#13;
    enum PledgeAdminType { Giver, Delegate, Project }&#13;
    enum PledgeState { Pledged, Paying, Paid }&#13;
&#13;
    /// @dev This struct defines the details of a `PledgeAdmin` which are &#13;
    ///  commonly referenced by their index in the `admins` array&#13;
    ///  and can own pledges and act as delegates&#13;
    struct PledgeAdmin { &#13;
        PledgeAdminType adminType; // Giver, Delegate or Project&#13;
        address addr; // Account or contract address for admin&#13;
        string name;&#13;
        string url;  // Can be IPFS hash&#13;
        uint64 commitTime;  // In seconds, used for Givers' &amp; Delegates' vetos&#13;
        uint64 parentProject;  // Only for projects&#13;
        bool canceled;      //Always false except for canceled projects&#13;
&#13;
        /// @dev if the plugin is 0x0 then nothing happens, if its an address&#13;
        // than that smart contract is called when appropriate&#13;
        ILiquidPledgingPlugin plugin; &#13;
    }&#13;
&#13;
    struct Pledge {&#13;
        uint amount;&#13;
        uint64 owner; // PledgeAdmin&#13;
        uint64[] delegationChain; // List of delegates in order of authority&#13;
        uint64 intendedProject; // Used when delegates are sending to projects&#13;
        uint64 commitTime;  // When the intendedProject will become the owner  &#13;
        uint64 oldPledge; // Points to the id that this Pledge was derived from&#13;
        PledgeState pledgeState; //  Pledged, Paying, Paid&#13;
    }&#13;
&#13;
    Pledge[] pledges;&#13;
    PledgeAdmin[] admins; //The list of pledgeAdmins 0 means there is no admin&#13;
    LPVault public vault;&#13;
&#13;
    /// @dev this mapping allows you to search for a specific pledge's &#13;
    ///  index number by the hash of that pledge&#13;
    mapping (bytes32 =&gt; uint64) hPledge2idx;&#13;
    mapping (bytes32 =&gt; bool) pluginWhitelist;&#13;
    &#13;
    bool public usePluginWhitelist = true;&#13;
&#13;
/////////////&#13;
// Modifiers&#13;
/////////////&#13;
&#13;
&#13;
    /// @dev The `vault`is the only addresses that can call a function with this&#13;
    ///  modifier&#13;
    modifier onlyVault() {&#13;
        require(msg.sender == address(vault));&#13;
        _;&#13;
    }&#13;
&#13;
&#13;
///////////////&#13;
// Constructor&#13;
///////////////&#13;
&#13;
    /// @notice The Constructor creates `LiquidPledgingBase` on the blockchain&#13;
    /// @param _vault The vault where the ETH backing the pledges is stored&#13;
    function LiquidPledgingBase(&#13;
        address _vault,&#13;
        address _escapeHatchCaller,&#13;
        address _escapeHatchDestination&#13;
    ) Escapable(_escapeHatchCaller, _escapeHatchDestination) public {&#13;
        admins.length = 1; // we reserve the 0 admin&#13;
        pledges.length = 1; // we reserve the 0 pledge&#13;
        vault = LPVault(_vault); // Assigns the specified vault&#13;
    }&#13;
&#13;
&#13;
/////////////////////////&#13;
// PledgeAdmin functions&#13;
/////////////////////////&#13;
&#13;
    /// @notice Creates a Giver Admin with the `msg.sender` as the Admin address&#13;
    /// @param name The name used to identify the Giver&#13;
    /// @param url The link to the Giver's profile often an IPFS hash&#13;
    /// @param commitTime The length of time in seconds the Giver has to&#13;
    ///   veto when the Giver's delegates Pledge funds to a project&#13;
    /// @param plugin This is Giver's liquid pledge plugin allowing for &#13;
    ///  extended functionality&#13;
    /// @return idGiver The id number used to reference this Admin&#13;
    function addGiver(&#13;
        string name,&#13;
        string url,&#13;
        uint64 commitTime,&#13;
        ILiquidPledgingPlugin plugin&#13;
    ) returns (uint64 idGiver) {&#13;
&#13;
        require(isValidPlugin(plugin)); // Plugin check&#13;
&#13;
        idGiver = uint64(admins.length);&#13;
&#13;
        admins.push(PledgeAdmin(&#13;
            PledgeAdminType.Giver,&#13;
            msg.sender,&#13;
            name,&#13;
            url,&#13;
            commitTime,&#13;
            0,&#13;
            false,&#13;
            plugin));&#13;
&#13;
        GiverAdded(idGiver);&#13;
    }&#13;
&#13;
    event GiverAdded(uint64 indexed idGiver);&#13;
&#13;
    /// @notice Updates a Giver's info to change the address, name, url, or &#13;
    ///  commitTime, it cannot be used to change a plugin, and it must be called&#13;
    ///  by the current address of the Giver&#13;
    /// @param idGiver This is the Admin id number used to specify the Giver&#13;
    /// @param newAddr The new address that represents this Giver&#13;
    /// @param newName The new name used to identify the Giver&#13;
    /// @param newUrl The new link to the Giver's profile often an IPFS hash&#13;
    /// @param newCommitTime Sets the length of time in seconds the Giver has to&#13;
    ///   veto when the Giver's delegates Pledge funds to a project&#13;
    function updateGiver(&#13;
        uint64 idGiver,&#13;
        address newAddr,&#13;
        string newName,&#13;
        string newUrl,&#13;
        uint64 newCommitTime)&#13;
    {&#13;
        PledgeAdmin storage giver = findAdmin(idGiver);&#13;
        require(giver.adminType == PledgeAdminType.Giver); // Must be a Giver&#13;
        require(giver.addr == msg.sender); // Current addr had to send this tx&#13;
        giver.addr = newAddr;&#13;
        giver.name = newName;&#13;
        giver.url = newUrl;&#13;
        giver.commitTime = newCommitTime;&#13;
        GiverUpdated(idGiver);&#13;
    }&#13;
&#13;
    event GiverUpdated(uint64 indexed idGiver);&#13;
&#13;
    /// @notice Creates a Delegate Admin with the `msg.sender` as the Admin addr&#13;
    /// @param name The name used to identify the Delegate&#13;
    /// @param url The link to the Delegate's profile often an IPFS hash&#13;
    /// @param commitTime Sets the length of time in seconds that this delegate&#13;
    ///  can be vetoed. Whenever this delegate is in a delegate chain the time&#13;
    ///  allowed to veto any event must be greater than or equal to this time.&#13;
    /// @param plugin This is Delegate's liquid pledge plugin allowing for &#13;
    ///  extended functionality&#13;
    /// @return idxDelegate The id number used to reference this Delegate within&#13;
    ///  the admins array&#13;
    function addDelegate(&#13;
        string name,&#13;
        string url,&#13;
        uint64 commitTime,&#13;
        ILiquidPledgingPlugin plugin&#13;
    ) returns (uint64 idDelegate) { &#13;
&#13;
        require(isValidPlugin(plugin)); // Plugin check&#13;
&#13;
        idDelegate = uint64(admins.length);&#13;
&#13;
        admins.push(PledgeAdmin(&#13;
            PledgeAdminType.Delegate,&#13;
            msg.sender,&#13;
            name,&#13;
            url,&#13;
            commitTime,&#13;
            0,&#13;
            false,&#13;
            plugin));&#13;
&#13;
        DelegateAdded(idDelegate);&#13;
    }&#13;
&#13;
    event DelegateAdded(uint64 indexed idDelegate);&#13;
&#13;
    /// @notice Updates a Delegate's info to change the address, name, url, or &#13;
    ///  commitTime, it cannot be used to change a plugin, and it must be called&#13;
    ///  by the current address of the Delegate&#13;
    /// @param idDelegate The Admin id number used to specify the Delegate&#13;
    /// @param newAddr The new address that represents this Delegate&#13;
    /// @param newName The new name used to identify the Delegate&#13;
    /// @param newUrl The new link to the Delegate's profile often an IPFS hash&#13;
    /// @param newCommitTime Sets the length of time in seconds that this &#13;
    ///  delegate can be vetoed. Whenever this delegate is in a delegate chain &#13;
    ///  the time allowed to veto any event must be greater than or equal to&#13;
    ///  this time.&#13;
    function updateDelegate(&#13;
        uint64 idDelegate,&#13;
        address newAddr,&#13;
        string newName,&#13;
        string newUrl,&#13;
        uint64 newCommitTime) {&#13;
        PledgeAdmin storage delegate = findAdmin(idDelegate);&#13;
        require(delegate.adminType == PledgeAdminType.Delegate);&#13;
        require(delegate.addr == msg.sender);// Current addr had to send this tx&#13;
        delegate.addr = newAddr;&#13;
        delegate.name = newName;&#13;
        delegate.url = newUrl;&#13;
        delegate.commitTime = newCommitTime;&#13;
        DelegateUpdated(idDelegate);&#13;
    }&#13;
&#13;
    event DelegateUpdated(uint64 indexed idDelegate);&#13;
&#13;
    /// @notice Creates a Project Admin with the `msg.sender` as the Admin addr&#13;
    /// @param name The name used to identify the Project&#13;
    /// @param url The link to the Project's profile often an IPFS hash&#13;
    /// @param projectAdmin The address for the trusted project manager &#13;
    /// @param parentProject The Admin id number for the parent project or 0 if&#13;
    ///  there is no parentProject&#13;
    /// @param commitTime Sets the length of time in seconds the Project has to&#13;
    ///   veto when the Project delegates to another Delegate and they pledge &#13;
    ///   those funds to a project&#13;
    /// @param plugin This is Project's liquid pledge plugin allowing for &#13;
    ///  extended functionality&#13;
    /// @return idProject The id number used to reference this Admin&#13;
    function addProject(&#13;
        string name,&#13;
        string url,&#13;
        address projectAdmin,&#13;
        uint64 parentProject,&#13;
        uint64 commitTime,&#13;
        ILiquidPledgingPlugin plugin&#13;
    ) returns (uint64 idProject) {&#13;
        require(isValidPlugin(plugin));&#13;
&#13;
        if (parentProject != 0) {&#13;
            PledgeAdmin storage pa = findAdmin(parentProject);&#13;
            require(pa.adminType == PledgeAdminType.Project);&#13;
            require(getProjectLevel(pa) &lt; MAX_SUBPROJECT_LEVEL);&#13;
        }&#13;
&#13;
        idProject = uint64(admins.length);&#13;
&#13;
        admins.push(PledgeAdmin(&#13;
            PledgeAdminType.Project,&#13;
            projectAdmin,&#13;
            name,&#13;
            url,&#13;
            commitTime,&#13;
            parentProject,&#13;
            false,&#13;
            plugin));&#13;
&#13;
&#13;
        ProjectAdded(idProject);&#13;
    }&#13;
&#13;
    event ProjectAdded(uint64 indexed idProject);&#13;
&#13;
&#13;
    /// @notice Updates a Project's info to change the address, name, url, or &#13;
    ///  commitTime, it cannot be used to change a plugin or a parentProject,&#13;
    ///  and it must be called by the current address of the Project&#13;
    /// @param idProject The Admin id number used to specify the Project&#13;
    /// @param newAddr The new address that represents this Project&#13;
    /// @param newName The new name used to identify the Project&#13;
    /// @param newUrl The new link to the Project's profile often an IPFS hash&#13;
    /// @param newCommitTime Sets the length of time in seconds the Project has&#13;
    ///  to veto when the Project delegates to a Delegate and they pledge those&#13;
    ///  funds to a project&#13;
    function updateProject(&#13;
        uint64 idProject,&#13;
        address newAddr,&#13;
        string newName,&#13;
        string newUrl,&#13;
        uint64 newCommitTime)&#13;
    {&#13;
        PledgeAdmin storage project = findAdmin(idProject);&#13;
        require(project.adminType == PledgeAdminType.Project);&#13;
        require(project.addr == msg.sender);&#13;
        project.addr = newAddr;&#13;
        project.name = newName;&#13;
        project.url = newUrl;&#13;
        project.commitTime = newCommitTime;&#13;
        ProjectUpdated(idProject);&#13;
    }&#13;
&#13;
    event ProjectUpdated(uint64 indexed idAdmin);&#13;
&#13;
&#13;
//////////&#13;
// Public constant functions&#13;
//////////&#13;
&#13;
    /// @notice A constant getter that returns the total number of pledges&#13;
    /// @return The total number of Pledges in the system&#13;
    function numberOfPledges() constant returns (uint) {&#13;
        return pledges.length - 1;&#13;
    }&#13;
&#13;
    /// @notice A getter that returns the details of the specified pledge&#13;
    /// @param idPledge the id number of the pledge being queried&#13;
    /// @return the amount, owner, the number of delegates (but not the actual&#13;
    ///  delegates, the intendedProject (if any), the current commit time and&#13;
    ///  the previous pledge this pledge was derived from&#13;
    function getPledge(uint64 idPledge) constant returns(&#13;
        uint amount,&#13;
        uint64 owner,&#13;
        uint64 nDelegates,&#13;
        uint64 intendedProject,&#13;
        uint64 commitTime,&#13;
        uint64 oldPledge,&#13;
        PledgeState pledgeState&#13;
    ) {&#13;
        Pledge storage p = findPledge(idPledge);&#13;
        amount = p.amount;&#13;
        owner = p.owner;&#13;
        nDelegates = uint64(p.delegationChain.length);&#13;
        intendedProject = p.intendedProject;&#13;
        commitTime = p.commitTime;&#13;
        oldPledge = p.oldPledge;&#13;
        pledgeState = p.pledgeState;&#13;
    }&#13;
&#13;
    /// @notice Getter to find Delegate w/ the Pledge ID &amp; the Delegate index&#13;
    /// @param idPledge The id number representing the pledge being queried&#13;
    /// @param idxDelegate The index number for the delegate in this Pledge &#13;
    function getPledgeDelegate(uint64 idPledge, uint idxDelegate) constant returns(&#13;
        uint64 idDelegate,&#13;
        address addr,&#13;
        string name&#13;
    ) {&#13;
        Pledge storage p = findPledge(idPledge);&#13;
        idDelegate = p.delegationChain[idxDelegate - 1];&#13;
        PledgeAdmin storage delegate = findAdmin(idDelegate);&#13;
        addr = delegate.addr;&#13;
        name = delegate.name;&#13;
    }&#13;
&#13;
    /// @notice A constant getter used to check how many total Admins exist&#13;
    /// @return The total number of admins (Givers, Delegates and Projects) .&#13;
    function numberOfPledgeAdmins() constant returns(uint) {&#13;
        return admins.length - 1;&#13;
    }&#13;
&#13;
    /// @notice A constant getter to check the details of a specified Admin  &#13;
    /// @return addr Account or contract address for admin&#13;
    /// @return name Name of the pledgeAdmin&#13;
    /// @return url The link to the Project's profile often an IPFS hash&#13;
    /// @return commitTime The length of time in seconds the Admin has to veto&#13;
    ///   when the Admin delegates to a Delegate and that Delegate pledges those&#13;
    ///   funds to a project&#13;
    /// @return parentProject The Admin id number for the parent project or 0&#13;
    ///  if there is no parentProject&#13;
    /// @return canceled 0 for Delegates &amp; Givers, true if a Project has been &#13;
    ///  canceled&#13;
    /// @return plugin This is Project's liquidPledging plugin allowing for &#13;
    ///  extended functionality&#13;
    function getPledgeAdmin(uint64 idAdmin) constant returns (&#13;
        PledgeAdminType adminType,&#13;
        address addr,&#13;
        string name,&#13;
        string url,&#13;
        uint64 commitTime,&#13;
        uint64 parentProject,&#13;
        bool canceled,&#13;
        address plugin)&#13;
    {&#13;
        PledgeAdmin storage m = findAdmin(idAdmin);&#13;
        adminType = m.adminType;&#13;
        addr = m.addr;&#13;
        name = m.name;&#13;
        url = m.url;&#13;
        commitTime = m.commitTime;&#13;
        parentProject = m.parentProject;&#13;
        canceled = m.canceled;&#13;
        plugin = address(m.plugin);&#13;
    }&#13;
&#13;
////////&#13;
// Private methods&#13;
///////&#13;
&#13;
    /// @notice This creates a Pledge with an initial amount of 0 if one is not&#13;
    ///  created already; otherwise it finds the pledge with the specified&#13;
    ///  attributes; all pledges technically exist, if the pledge hasn't been&#13;
    ///  created in this system yet it simply isn't in the hash array&#13;
    ///  hPledge2idx[] yet&#13;
    /// @param owner The owner of the pledge being looked up&#13;
    /// @param delegationChain The list of delegates in order of authority&#13;
    /// @param intendedProject The project this pledge will Fund after the&#13;
    ///  commitTime has passed&#13;
    /// @param commitTime The length of time in seconds the Giver has to&#13;
    ///   veto when the Giver's delegates Pledge funds to a project&#13;
    /// @param oldPledge This value is used to store the pledge the current&#13;
    ///  pledge was came from, and in the case a Project is canceled, the Pledge&#13;
    ///  will revert back to it's previous state&#13;
    /// @param state The pledge state: Pledged, Paying, or state&#13;
    /// @return The hPledge2idx index number&#13;
    function findOrCreatePledge(&#13;
        uint64 owner,&#13;
        uint64[] delegationChain,&#13;
        uint64 intendedProject,&#13;
        uint64 commitTime,&#13;
        uint64 oldPledge,&#13;
        PledgeState state&#13;
        ) internal returns (uint64)&#13;
    {&#13;
        bytes32 hPledge = sha3(&#13;
            owner, delegationChain, intendedProject, commitTime, oldPledge, state);&#13;
        uint64 idx = hPledge2idx[hPledge];&#13;
        if (idx &gt; 0) return idx;&#13;
        idx = uint64(pledges.length);&#13;
        hPledge2idx[hPledge] = idx;&#13;
        pledges.push(Pledge(&#13;
            0, owner, delegationChain, intendedProject, commitTime, oldPledge, state));&#13;
        return idx;&#13;
    }&#13;
&#13;
    /// @notice A getter to look up a Admin's details&#13;
    /// @param idAdmin The id for the Admin to lookup&#13;
    /// @return The PledgeAdmin struct for the specified Admin&#13;
    function findAdmin(uint64 idAdmin) internal returns (PledgeAdmin storage) {&#13;
        require(idAdmin &lt; admins.length);&#13;
        return admins[idAdmin];&#13;
    }&#13;
&#13;
    /// @notice A getter to look up a Pledge's details&#13;
    /// @param idPledge The id for the Pledge to lookup&#13;
    /// @return The PledgeA struct for the specified Pledge&#13;
    function findPledge(uint64 idPledge) internal returns (Pledge storage) {&#13;
        require(idPledge &lt; pledges.length);&#13;
        return pledges[idPledge];&#13;
    }&#13;
&#13;
    // a constant for when a delegate is requested that is not in the system&#13;
    uint64 constant  NOTFOUND = 0xFFFFFFFFFFFFFFFF;&#13;
&#13;
    /// @notice A getter that searches the delegationChain for the level of&#13;
    ///  authority a specific delegate has within a Pledge&#13;
    /// @param p The Pledge that will be searched&#13;
    /// @param idDelegate The specified delegate that's searched for&#13;
    /// @return If the delegate chain contains the delegate with the&#13;
    ///  `admins` array index `idDelegate` this returns that delegates&#13;
    ///  corresponding index in the delegationChain. Otherwise it returns&#13;
    ///  the NOTFOUND constant&#13;
    function getDelegateIdx(Pledge p, uint64 idDelegate) internal returns(uint64) {&#13;
        for (uint i=0; i &lt; p.delegationChain.length; i++) {&#13;
            if (p.delegationChain[i] == idDelegate) return uint64(i);&#13;
        }&#13;
        return NOTFOUND;&#13;
    }&#13;
&#13;
    /// @notice A getter to find how many old "parent" pledges a specific Pledge&#13;
    ///  had using a self-referential loop&#13;
    /// @param p The Pledge being queried&#13;
    /// @return The number of old "parent" pledges a specific Pledge had&#13;
    function getPledgeLevel(Pledge p) internal returns(uint) {&#13;
        if (p.oldPledge == 0) return 0;&#13;
        Pledge storage oldN = findPledge(p.oldPledge);&#13;
        return getPledgeLevel(oldN) + 1; // a loop lookup&#13;
    }&#13;
&#13;
    /// @notice A getter to find the longest commitTime out of the owner and all&#13;
    ///  the delegates for a specified pledge&#13;
    /// @param p The Pledge being queried&#13;
    /// @return The maximum commitTime out of the owner and all the delegates&#13;
    function maxCommitTime(Pledge p) internal returns(uint commitTime) {&#13;
        PledgeAdmin storage m = findAdmin(p.owner);&#13;
        commitTime = m.commitTime; // start with the owner's commitTime&#13;
&#13;
        for (uint i=0; i&lt;p.delegationChain.length; i++) {&#13;
            m = findAdmin(p.delegationChain[i]);&#13;
&#13;
            // If a delegate's commitTime is longer, make it the new commitTime&#13;
            if (m.commitTime &gt; commitTime) commitTime = m.commitTime;&#13;
        }&#13;
    }&#13;
&#13;
    /// @notice A getter to find the level of authority a specific Project has&#13;
    ///  using a self-referential loop&#13;
    /// @param m The Project being queried&#13;
    /// @return The level of authority a specific Project has&#13;
    function getProjectLevel(PledgeAdmin m) internal returns(uint) {&#13;
        assert(m.adminType == PledgeAdminType.Project);&#13;
        if (m.parentProject == 0) return(1);&#13;
        PledgeAdmin storage parentNM = findAdmin(m.parentProject);&#13;
        return getProjectLevel(parentNM) + 1;&#13;
    }&#13;
&#13;
    /// @notice A getter to find if a specified Project has been canceled&#13;
    /// @param projectId The Admin id number used to specify the Project&#13;
    /// @return True if the Project has been canceled&#13;
    function isProjectCanceled(uint64 projectId) constant returns (bool) {&#13;
        PledgeAdmin storage m = findAdmin(projectId);&#13;
        if (m.adminType == PledgeAdminType.Giver) return false;&#13;
        assert(m.adminType == PledgeAdminType.Project);&#13;
        if (m.canceled) return true;&#13;
        if (m.parentProject == 0) return false;&#13;
        return isProjectCanceled(m.parentProject);&#13;
    }&#13;
&#13;
    /// @notice A getter to find the oldest pledge that hasn't been canceled&#13;
    /// @param idPledge The starting place to lookup the pledges &#13;
    /// @return The oldest idPledge that hasn't been canceled (DUH!)&#13;
    function getOldestPledgeNotCanceled(uint64 idPledge&#13;
        ) internal constant returns(uint64) {&#13;
        if (idPledge == 0) return 0;&#13;
        Pledge storage p = findPledge(idPledge);&#13;
        PledgeAdmin storage admin = findAdmin(p.owner);&#13;
        if (admin.adminType == PledgeAdminType.Giver) return idPledge;&#13;
&#13;
        assert(admin.adminType == PledgeAdminType.Project);&#13;
&#13;
        if (!isProjectCanceled(p.owner)) return idPledge;&#13;
&#13;
        return getOldestPledgeNotCanceled(p.oldPledge);&#13;
    }&#13;
&#13;
    /// @notice A check to see if the msg.sender is the owner or the&#13;
    ///  plugin contract for a specific Admin&#13;
    /// @param m The Admin being checked&#13;
    function checkAdminOwner(PledgeAdmin m) internal constant {&#13;
        require((msg.sender == m.addr) || (msg.sender == address(m.plugin)));&#13;
    }&#13;
///////////////////////////&#13;
// Plugin Whitelist Methods&#13;
///////////////////////////&#13;
&#13;
    function addValidPlugin(bytes32 contractHash) external onlyOwner {&#13;
        pluginWhitelist[contractHash] = true;&#13;
    }&#13;
&#13;
    function removeValidPlugin(bytes32 contractHash) external onlyOwner {&#13;
        pluginWhitelist[contractHash] = false;&#13;
    }&#13;
&#13;
    function useWhitelist(bool useWhitelist) external onlyOwner {&#13;
        usePluginWhitelist = useWhitelist;&#13;
    }&#13;
&#13;
    function isValidPlugin(address addr) public returns(bool) {&#13;
        if (!usePluginWhitelist || addr == 0x0) return true;&#13;
&#13;
        bytes32 contractHash = getCodeHash(addr);&#13;
&#13;
        return pluginWhitelist[contractHash];&#13;
    }&#13;
&#13;
    function getCodeHash(address addr) public returns(bytes32) {&#13;
        bytes memory o_code;&#13;
        assembly {&#13;
            // retrieve the size of the code, this needs assembly&#13;
            let size := extcodesize(addr)&#13;
            // allocate output byte array - this could also be done without assembly&#13;
            // by using o_code = new bytes(size)&#13;
            o_code := mload(0x40)&#13;
            // new "memory end" including padding&#13;
            mstore(0x40, add(o_code, and(add(add(size, 0x20), 0x1f), not(0x1f))))&#13;
            // store length in memory&#13;
            mstore(o_code, size)&#13;
            // actually retrieve the code, this needs assembly&#13;
            extcodecopy(addr, add(o_code, 0x20), 0, size)&#13;
        }&#13;
        return keccak256(o_code);&#13;
    }&#13;
}&#13;
&#13;
//File: contracts/LiquidPledging.sol&#13;
pragma solidity ^0.4.11;&#13;
&#13;
/*&#13;
    Copyright 2017, Jordi Baylina&#13;
    Contributors: Adrià Massanet &lt;<span class="__cf_email__" data-cfemail="9dfcf9eff4fcddfef2f9f8fef2f3e9f8e5e9b3f4f2">[email protected]</span>&gt;, RJ Ewing, Griff&#13;
    Green, Arthur Lunn&#13;
&#13;
    This program is free software: you can redistribute it and/or modify&#13;
    it under the terms of the GNU General Public License as published by&#13;
    the Free Software Foundation, either version 3 of the License, or&#13;
    (at your option) any later version.&#13;
&#13;
    This program is distributed in the hope that it will be useful,&#13;
    but WITHOUT ANY WARRANTY; without even the implied warranty of&#13;
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&#13;
    GNU General Public License for more details.&#13;
&#13;
    You should have received a copy of the GNU General Public License&#13;
    along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.&#13;
*/&#13;
&#13;
&#13;
&#13;
/// @dev `LiquidPleding` allows for liquid pledging through the use of&#13;
///  internal id structures and delegate chaining. All basic operations for&#13;
///  handling liquid pledging are supplied as well as plugin features&#13;
///  to allow for expanded functionality.&#13;
contract LiquidPledging is LiquidPledgingBase {&#13;
&#13;
&#13;
//////&#13;
// Constructor&#13;
//////&#13;
&#13;
    /// @notice Basic constructor for LiquidPleding, also calls the&#13;
    ///  LiquidPledgingBase contract&#13;
    /// @dev This constructor  also calls the constructor &#13;
    ///  for `LiquidPledgingBase`&#13;
    /// @param _vault The vault where ETH backing this pledge is stored&#13;
    function LiquidPledging(&#13;
        address _vault,&#13;
        address _escapeHatchCaller,&#13;
        address _escapeHatchDestination&#13;
    ) LiquidPledgingBase(_vault, _escapeHatchCaller, _escapeHatchDestination) {&#13;
&#13;
    }&#13;
&#13;
    /// @notice This is how value enters the system and how pledges are created;&#13;
    ///  the ether is sent to the vault, an pledge for the Giver is created (or&#13;
    ///  found), the amount of ETH donated in wei is added to the `amount` in&#13;
    ///  the Giver's Pledge, and an LP transfer is done to the idReceiver for&#13;
    ///  the full amount&#13;
    /// @param idGiver The id of the Giver donating; if 0, a new id is created&#13;
    /// @param idReceiver The Admin receiving the donation; can be any Admin:&#13;
    ///  the Giver themselves, another Giver, a Delegate or a Project&#13;
    function donate(uint64 idGiver, uint64 idReceiver) payable {&#13;
        if (idGiver == 0) {&#13;
&#13;
            // default to a 3 day (259200 seconds) commitTime&#13;
            idGiver = addGiver("", "", 259200, ILiquidPledgingPlugin(0x0));&#13;
        }&#13;
&#13;
        PledgeAdmin storage sender = findAdmin(idGiver);&#13;
        checkAdminOwner(sender);&#13;
        require(sender.adminType == PledgeAdminType.Giver);&#13;
        uint amount = msg.value;&#13;
        require(amount &gt; 0);&#13;
        vault.transfer(amount); // Sends the `msg.value` (in wei) to the `vault`&#13;
        uint64 idPledge = findOrCreatePledge(&#13;
            idGiver,&#13;
            new uint64[](0), // Creates empty array for delegationChain&#13;
            0,&#13;
            0,&#13;
            0,&#13;
            PledgeState.Pledged&#13;
        );&#13;
&#13;
&#13;
        Pledge storage nTo = findPledge(idPledge);&#13;
        nTo.amount += amount;&#13;
&#13;
        Transfer(0, idPledge, amount); // An event&#13;
&#13;
        transfer(idGiver, idPledge, amount, idReceiver); // LP accounting&#13;
    }&#13;
&#13;
    /// @notice Transfers amounts between pledges for internal accounting &#13;
    /// @param idSender Id of the Admin that is transferring the amount from&#13;
    ///  Pledge to Pledge; this admin must have permissions to move the value&#13;
    /// @param idPledge Id of the pledge that's moving the value&#13;
    /// @param amount Quantity of ETH (in wei) that this pledge is transferring &#13;
    ///  the authority to withdraw from the vault&#13;
    /// @param idReceiver Destination of the `amount`, can be a Giver/Project sending&#13;
    ///  to a Giver, a Delegate or a Project; a Delegate sending to another&#13;
    ///  Delegate, or a Delegate pre-commiting it to a Project &#13;
    function transfer( &#13;
        uint64 idSender,&#13;
        uint64 idPledge,&#13;
        uint amount,&#13;
        uint64 idReceiver&#13;
    ){&#13;
&#13;
        idPledge = normalizePledge(idPledge);&#13;
&#13;
        Pledge storage p = findPledge(idPledge);&#13;
        PledgeAdmin storage receiver = findAdmin(idReceiver);&#13;
        PledgeAdmin storage sender = findAdmin(idSender);&#13;
&#13;
        checkAdminOwner(sender);&#13;
        require(p.pledgeState == PledgeState.Pledged);&#13;
&#13;
        // If the sender is the owner of the Pledge&#13;
        if (p.owner == idSender) {&#13;
&#13;
            if (receiver.adminType == PledgeAdminType.Giver) {&#13;
                transferOwnershipToGiver(idPledge, amount, idReceiver);&#13;
            } else if (receiver.adminType == PledgeAdminType.Project) {&#13;
                transferOwnershipToProject(idPledge, amount, idReceiver);&#13;
            } else if (receiver.adminType == PledgeAdminType.Delegate) {&#13;
&#13;
                uint recieverDIdx = getDelegateIdx(p, idReceiver);&#13;
                if (p.intendedProject &gt; 0 &amp;&amp; recieverDIdx != NOTFOUND) {&#13;
                    // if there is an intendedProject and the receiver is in the delegationChain,&#13;
                    // then we want to preserve the delegationChain as this is a veto of the&#13;
                    // intendedProject by the owner&#13;
&#13;
                    if (recieverDIdx == p.delegationChain.length - 1) {&#13;
                        uint64 toPledge = findOrCreatePledge(&#13;
                            p.owner,&#13;
                            p.delegationChain,&#13;
                            0,&#13;
                            0,&#13;
                            p.oldPledge,&#13;
                            PledgeState.Pledged);&#13;
                        doTransfer(idPledge, toPledge, amount);&#13;
                    } else {&#13;
                        undelegate(idPledge, amount, p.delegationChain.length - receiverDIdx - 1);&#13;
                    }&#13;
                } else {&#13;
                    // owner is not vetoing an intendedProject and is transferring the pledge to a delegate,&#13;
                    // so we want to reset the delegationChain&#13;
                    idPledge = undelegate(&#13;
                        idPledge,&#13;
                        amount,&#13;
                        p.delegationChain.length&#13;
                    );&#13;
                    appendDelegate(idPledge, amount, idReceiver);&#13;
                }&#13;
                &#13;
            } else {&#13;
                // This should never be reached as the reciever.adminType&#13;
                // should always be either a Giver, Project, or Delegate&#13;
                assert(false);&#13;
            }&#13;
            return;&#13;
        }&#13;
&#13;
        // If the sender is a Delegate&#13;
        uint senderDIdx = getDelegateIdx(p, idSender);&#13;
        if (senderDIdx != NOTFOUND) {&#13;
&#13;
            // And the receiver is another Giver&#13;
            if (receiver.adminType == PledgeAdminType.Giver) {&#13;
                // Only transfer to the Giver who owns the pldege&#13;
                assert(p.owner == idReceiver);&#13;
                undelegate(idPledge, amount, p.delegationChain.length);&#13;
                return;&#13;
            }&#13;
&#13;
            // And the receiver is another Delegate&#13;
            if (receiver.adminType == PledgeAdminType.Delegate) {&#13;
                uint receiverDIdx = getDelegateIdx(p, idReceiver);&#13;
&#13;
                // And not in the delegationChain&#13;
                if (receiverDIdx == NOTFOUND) {&#13;
                    idPledge = undelegate(&#13;
                        idPledge,&#13;
                        amount,&#13;
                        p.delegationChain.length - senderDIdx - 1&#13;
                    );&#13;
                    appendDelegate(idPledge, amount, idReceiver);&#13;
&#13;
                // And part of the delegationChain and is after the sender, then&#13;
                //  all of the other delegates after the sender are removed and&#13;
                //  the receiver is appended at the end of the delegationChain&#13;
                } else if (receiverDIdx &gt; senderDIdx) {&#13;
                    idPledge = undelegate(&#13;
                        idPledge,&#13;
                        amount,&#13;
                        p.delegationChain.length - senderDIdx - 1&#13;
                    );&#13;
                    appendDelegate(idPledge, amount, idReceiver);&#13;
&#13;
                // And is already part of the delegate chain but is before the&#13;
                //  sender, then the sender and all of the other delegates after&#13;
                //  the RECEIVER are removed from the delegationChain &#13;
                } else if (receiverDIdx &lt;= senderDIdx) {//TODO Check for Game Theory issues (from Arthur) this allows the sender to sort of go komakosi and remove himself and the delegates between himself and the receiver... should this authority be allowed? &#13;
                    undelegate(&#13;
                        idPledge,&#13;
                        amount,&#13;
                        p.delegationChain.length - receiverDIdx - 1&#13;
                    );&#13;
                }&#13;
                return;&#13;
            }&#13;
&#13;
            // And the receiver is a Project, all the delegates after the sender&#13;
            //  are removed and the amount is pre-committed to the project&#13;
            if (receiver.adminType == PledgeAdminType.Project) {&#13;
                idPledge = undelegate(&#13;
                    idPledge,&#13;
                    amount,&#13;
                    p.delegationChain.length - senderDIdx - 1&#13;
                );&#13;
                proposeAssignProject(idPledge, amount, idReceiver);&#13;
                return;&#13;
            }&#13;
        }&#13;
        assert(false);  // When the sender is not an owner or a delegate &#13;
    }&#13;
&#13;
    /// @notice Authorizes a payment be made from the `vault` can be used by the&#13;
    ///  Giver to veto a pre-committed donation from a Delegate to an&#13;
    ///  intendedProject&#13;
    /// @param idPledge Id of the pledge that is to be redeemed into ether&#13;
    /// @param amount Quantity of ether (in wei) to be authorized&#13;
    function withdraw(uint64 idPledge, uint amount) {&#13;
        idPledge = normalizePledge(idPledge); // Updates pledge info &#13;
        Pledge storage p = findPledge(idPledge);&#13;
        require(p.pledgeState == PledgeState.Pledged);&#13;
        PledgeAdmin storage owner = findAdmin(p.owner);&#13;
        checkAdminOwner(owner);&#13;
&#13;
        uint64 idNewPledge = findOrCreatePledge(&#13;
            p.owner,&#13;
            p.delegationChain,&#13;
            0,&#13;
            0,&#13;
            p.oldPledge,&#13;
            PledgeState.Paying&#13;
        );&#13;
&#13;
        doTransfer(idPledge, idNewPledge, amount);&#13;
&#13;
        vault.authorizePayment(bytes32(idNewPledge), owner.addr, amount);&#13;
    }&#13;
&#13;
    /// @notice `onlyVault` Confirms a withdraw request changing the PledgeState&#13;
    ///  from Paying to Paid&#13;
    /// @param idPledge Id of the pledge that is to be withdrawn&#13;
    /// @param amount Quantity of ether (in wei) to be withdrawn&#13;
    function confirmPayment(uint64 idPledge, uint amount) onlyVault {&#13;
        Pledge storage p = findPledge(idPledge);&#13;
&#13;
        require(p.pledgeState == PledgeState.Paying);&#13;
&#13;
        uint64 idNewPledge = findOrCreatePledge(&#13;
            p.owner,&#13;
            p.delegationChain,&#13;
            0,&#13;
            0,&#13;
            p.oldPledge,&#13;
            PledgeState.Paid&#13;
        );&#13;
&#13;
        doTransfer(idPledge, idNewPledge, amount);&#13;
    }&#13;
&#13;
    /// @notice `onlyVault` Cancels a withdraw request, changing the PledgeState &#13;
    ///  from Paying back to Pledged&#13;
    /// @param idPledge Id of the pledge that's withdraw is to be canceled&#13;
    /// @param amount Quantity of ether (in wei) to be canceled&#13;
    function cancelPayment(uint64 idPledge, uint amount) onlyVault {&#13;
        Pledge storage p = findPledge(idPledge);&#13;
&#13;
        require(p.pledgeState == PledgeState.Paying); //TODO change to revert????????????????????????????&#13;
&#13;
        // When a payment is canceled, never is assigned to a project.&#13;
        uint64 oldPledge = findOrCreatePledge(&#13;
            p.owner,&#13;
            p.delegationChain,&#13;
            0,&#13;
            0,&#13;
            p.oldPledge,&#13;
            PledgeState.Pledged&#13;
        );&#13;
&#13;
        oldPledge = normalizePledge(oldPledge);&#13;
&#13;
        doTransfer(idPledge, oldPledge, amount);&#13;
    }&#13;
&#13;
    /// @notice Changes the `project.canceled` flag to `true`; cannot be undone&#13;
    /// @param idProject Id of the project that is to be canceled&#13;
    function cancelProject(uint64 idProject) { &#13;
        PledgeAdmin storage project = findAdmin(idProject);&#13;
        checkAdminOwner(project);&#13;
        project.canceled = true;&#13;
&#13;
        CancelProject(idProject);&#13;
    }&#13;
&#13;
    /// @notice Transfers `amount` in `idPledge` back to the `oldPledge` that&#13;
    ///  that sent it there in the first place, a Ctrl-z &#13;
    /// @param idPledge Id of the pledge that is to be canceled&#13;
    /// @param amount Quantity of ether (in wei) to be transfered to the &#13;
    ///  `oldPledge`&#13;
    function cancelPledge(uint64 idPledge, uint amount) { &#13;
        idPledge = normalizePledge(idPledge);&#13;
&#13;
        Pledge storage p = findPledge(idPledge);&#13;
        require(p.oldPledge != 0);&#13;
&#13;
        PledgeAdmin storage m = findAdmin(p.owner);&#13;
        checkAdminOwner(m);&#13;
&#13;
        uint64 oldPledge = getOldestPledgeNotCanceled(p.oldPledge);&#13;
        doTransfer(idPledge, oldPledge, amount);&#13;
    }&#13;
&#13;
&#13;
////////&#13;
// Multi pledge methods&#13;
////////&#13;
&#13;
    // @dev This set of functions makes moving a lot of pledges around much more&#13;
    // efficient (saves gas) than calling these functions in series&#13;
    &#13;
    &#13;
    /// @dev Bitmask used for dividing pledge amounts in Multi pledge methods&#13;
    uint constant D64 = 0x10000000000000000;&#13;
&#13;
    /// @notice Transfers multiple amounts within multiple Pledges in an&#13;
    ///  efficient single call &#13;
    /// @param idSender Id of the Admin that is transferring the amounts from&#13;
    ///  all the Pledges; this admin must have permissions to move the value&#13;
    /// @param pledgesAmounts An array of Pledge amounts and the idPledges with &#13;
    ///  which the amounts are associated; these are extrapolated using the D64&#13;
    ///  bitmask&#13;
    /// @param idReceiver Destination of the `pledesAmounts`, can be a Giver or &#13;
    ///  Project sending to a Giver, a Delegate or a Project; a Delegate sending&#13;
    ///  to another Delegate, or a Delegate pre-commiting it to a Project &#13;
    function mTransfer(&#13;
        uint64 idSender,&#13;
        uint[] pledgesAmounts,&#13;
        uint64 idReceiver&#13;
    ) {&#13;
        for (uint i = 0; i &lt; pledgesAmounts.length; i++ ) {&#13;
            uint64 idPledge = uint64( pledgesAmounts[i] &amp; (D64-1) );&#13;
            uint amount = pledgesAmounts[i] / D64;&#13;
&#13;
            transfer(idSender, idPledge, amount, idReceiver);&#13;
        }&#13;
    }&#13;
&#13;
    /// @notice Authorizes multiple amounts within multiple Pledges to be&#13;
    ///  withdrawn from the `vault` in an efficient single call &#13;
    /// @param pledgesAmounts An array of Pledge amounts and the idPledges with &#13;
    ///  which the amounts are associated; these are extrapolated using the D64&#13;
    ///  bitmask&#13;
    function mWithdraw(uint[] pledgesAmounts) {&#13;
        for (uint i = 0; i &lt; pledgesAmounts.length; i++ ) {&#13;
            uint64 idPledge = uint64( pledgesAmounts[i] &amp; (D64-1) );&#13;
            uint amount = pledgesAmounts[i] / D64;&#13;
&#13;
            withdraw(idPledge, amount);&#13;
        }&#13;
    }&#13;
&#13;
    /// @notice `mConfirmPayment` allows for multiple pledges to be confirmed&#13;
    ///  efficiently&#13;
    /// @param pledgesAmounts An array of pledge amounts and IDs which are extrapolated&#13;
    ///  using the D64 bitmask&#13;
    function mConfirmPayment(uint[] pledgesAmounts) {&#13;
        for (uint i = 0; i &lt; pledgesAmounts.length; i++ ) {&#13;
            uint64 idPledge = uint64( pledgesAmounts[i] &amp; (D64-1) );&#13;
            uint amount = pledgesAmounts[i] / D64;&#13;
&#13;
            confirmPayment(idPledge, amount);&#13;
        }&#13;
    }&#13;
&#13;
    /// @notice `mCancelPayment` allows for multiple pledges to be canceled&#13;
    ///  efficiently&#13;
    /// @param pledgesAmounts An array of pledge amounts and IDs which are extrapolated&#13;
    ///  using the D64 bitmask&#13;
    function mCancelPayment(uint[] pledgesAmounts) {&#13;
        for (uint i = 0; i &lt; pledgesAmounts.length; i++ ) {&#13;
            uint64 idPledge = uint64( pledgesAmounts[i] &amp; (D64-1) );&#13;
            uint amount = pledgesAmounts[i] / D64;&#13;
&#13;
            cancelPayment(idPledge, amount);&#13;
        }&#13;
    }&#13;
&#13;
    /// @notice `mNormalizePledge` allows for multiple pledges to be&#13;
    ///  normalized efficiently&#13;
    /// @param pledges An array of pledge IDs&#13;
    function mNormalizePledge(uint64[] pledges) {&#13;
        for (uint i = 0; i &lt; pledges.length; i++ ) {&#13;
            normalizePledge( pledges[i] );&#13;
        }&#13;
    }&#13;
&#13;
////////&#13;
// Private methods&#13;
///////&#13;
&#13;
    /// @notice `transferOwnershipToProject` allows for the transfer of&#13;
    ///  ownership to the project, but it can also be called by a project&#13;
    ///  to un-delegate everyone by setting one's own id for the idReceiver&#13;
    /// @param idPledge Id of the pledge to be transfered.&#13;
    /// @param amount Quantity of value that's being transfered&#13;
    /// @param idReceiver The new owner of the project (or self to un-delegate)&#13;
    function transferOwnershipToProject(&#13;
        uint64 idPledge,&#13;
        uint amount,&#13;
        uint64 idReceiver&#13;
    ) internal {&#13;
        Pledge storage p = findPledge(idPledge);&#13;
&#13;
        // Ensure that the pledge is not already at max pledge depth&#13;
        // and the project has not been canceled&#13;
        require(getPledgeLevel(p) &lt; MAX_INTERPROJECT_LEVEL);&#13;
        require(!isProjectCanceled(idReceiver));&#13;
&#13;
        uint64 oldPledge = findOrCreatePledge(&#13;
            p.owner,&#13;
            p.delegationChain,&#13;
            0,&#13;
            0,&#13;
            p.oldPledge,&#13;
            PledgeState.Pledged&#13;
        );&#13;
        uint64 toPledge = findOrCreatePledge(&#13;
            idReceiver,                     // Set the new owner&#13;
            new uint64[](0),                // clear the delegation chain&#13;
            0,&#13;
            0,&#13;
            oldPledge,&#13;
            PledgeState.Pledged&#13;
        );&#13;
        doTransfer(idPledge, toPledge, amount);&#13;
    }   &#13;
&#13;
&#13;
    /// @notice `transferOwnershipToGiver` allows for the transfer of&#13;
    ///  value back to the Giver, value is placed in a pledged state&#13;
    ///  without being attached to a project, delegation chain, or time line.&#13;
    /// @param idPledge Id of the pledge to be transfered.&#13;
    /// @param amount Quantity of value that's being transfered&#13;
    /// @param idReceiver The new owner of the pledge&#13;
    function transferOwnershipToGiver(&#13;
        uint64 idPledge,&#13;
        uint amount,&#13;
        uint64 idReceiver&#13;
    ) internal {&#13;
        uint64 toPledge = findOrCreatePledge(&#13;
            idReceiver,&#13;
            new uint64[](0),&#13;
            0,&#13;
            0,&#13;
            0,&#13;
            PledgeState.Pledged&#13;
        );&#13;
        doTransfer(idPledge, toPledge, amount);&#13;
    }&#13;
&#13;
    /// @notice `appendDelegate` allows for a delegate to be added onto the&#13;
    ///  end of the delegate chain for a given Pledge.&#13;
    /// @param idPledge Id of the pledge thats delegate chain will be modified.&#13;
    /// @param amount Quantity of value that's being chained.&#13;
    /// @param idReceiver The delegate to be added at the end of the chain&#13;
    function appendDelegate(&#13;
        uint64 idPledge,&#13;
        uint amount,&#13;
        uint64 idReceiver&#13;
    ) internal {&#13;
        Pledge storage p = findPledge(idPledge);&#13;
&#13;
        require(p.delegationChain.length &lt; MAX_DELEGATES);&#13;
        uint64[] memory newDelegationChain = new uint64[](&#13;
            p.delegationChain.length + 1&#13;
        );&#13;
        for (uint i = 0; i&lt;p.delegationChain.length; i++) {&#13;
            newDelegationChain[i] = p.delegationChain[i];&#13;
        }&#13;
&#13;
        // Make the last item in the array the idReceiver&#13;
        newDelegationChain[p.delegationChain.length] = idReceiver;&#13;
&#13;
        uint64 toPledge = findOrCreatePledge(&#13;
            p.owner,&#13;
            newDelegationChain,&#13;
            0,&#13;
            0,&#13;
            p.oldPledge,&#13;
            PledgeState.Pledged&#13;
        );&#13;
        doTransfer(idPledge, toPledge, amount);&#13;
    }&#13;
&#13;
    /// @notice `appendDelegate` allows for a delegate to be added onto the&#13;
    ///  end of the delegate chain for a given Pledge.&#13;
    /// @param idPledge Id of the pledge thats delegate chain will be modified.&#13;
    /// @param amount Quantity of value that's shifted from delegates.&#13;
    /// @param q Number (or depth) of delegates to remove&#13;
    /// @return toPledge The id for the pledge being adjusted or created&#13;
    function undelegate(&#13;
        uint64 idPledge,&#13;
        uint amount,&#13;
        uint q&#13;
    ) internal returns (uint64)&#13;
    {&#13;
        Pledge storage p = findPledge(idPledge);&#13;
        uint64[] memory newDelegationChain = new uint64[](&#13;
            p.delegationChain.length - q&#13;
        );&#13;
&#13;
        for (uint i=0; i&lt;p.delegationChain.length - q; i++) {&#13;
            newDelegationChain[i] = p.delegationChain[i];&#13;
        }&#13;
        uint64 toPledge = findOrCreatePledge(&#13;
            p.owner,&#13;
            newDelegationChain,&#13;
            0,&#13;
            0,&#13;
            p.oldPledge,&#13;
            PledgeState.Pledged&#13;
        );&#13;
        doTransfer(idPledge, toPledge, amount);&#13;
&#13;
        return toPledge;&#13;
    }&#13;
&#13;
    /// @notice `proposeAssignProject` proposes the assignment of a pledge&#13;
    ///  to a specific project.&#13;
    /// @dev This function should potentially be named more specifically.&#13;
    /// @param idPledge Id of the pledge that will be assigned.&#13;
    /// @param amount Quantity of value this pledge leader would be assigned.&#13;
    /// @param idReceiver The project this pledge will potentially &#13;
    ///  be assigned to.&#13;
    function proposeAssignProject(&#13;
        uint64 idPledge,&#13;
        uint amount,&#13;
        uint64 idReceiver&#13;
    ) internal {&#13;
        Pledge storage p = findPledge(idPledge);&#13;
&#13;
        require(getPledgeLevel(p) &lt; MAX_INTERPROJECT_LEVEL);&#13;
        require(!isProjectCanceled(idReceiver));&#13;
&#13;
        uint64 toPledge = findOrCreatePledge(&#13;
            p.owner,&#13;
            p.delegationChain,&#13;
            idReceiver,&#13;
            uint64(getTime() + maxCommitTime(p)),&#13;
            p.oldPledge,&#13;
            PledgeState.Pledged&#13;
        );&#13;
        doTransfer(idPledge, toPledge, amount);&#13;
    }&#13;
&#13;
    /// @notice `doTransfer` is designed to allow for pledge amounts to be &#13;
    ///  shifted around internally.&#13;
    /// @param from This is the Id from which value will be transfered.&#13;
    /// @param to This is the Id that value will be transfered to.&#13;
    /// @param _amount The amount of value that will be transfered.&#13;
    function doTransfer(uint64 from, uint64 to, uint _amount) internal {&#13;
        uint amount = callPlugins(true, from, to, _amount);&#13;
        if (from == to) { &#13;
            return;&#13;
        }&#13;
        if (amount == 0) {&#13;
            return;&#13;
        }&#13;
        Pledge storage nFrom = findPledge(from);&#13;
        Pledge storage nTo = findPledge(to);&#13;
        require(nFrom.amount &gt;= amount);&#13;
        nFrom.amount -= amount;&#13;
        nTo.amount += amount;&#13;
&#13;
        Transfer(from, to, amount);&#13;
        callPlugins(false, from, to, amount);&#13;
    }&#13;
&#13;
    /// @notice Only affects pledges with the Pledged PledgeState for 2 things:&#13;
    ///   #1: Checks if the pledge should be committed. This means that&#13;
    ///       if the pledge has an intendedProject and it is past the&#13;
    ///       commitTime, it changes the owner to be the proposed project&#13;
    ///       (The UI will have to read the commit time and manually do what&#13;
    ///       this function does to the pledge for the end user&#13;
    ///       at the expiration of the commitTime)&#13;
    ///&#13;
    ///   #2: Checks to make sure that if there has been a cancellation in the&#13;
    ///       chain of projects, the pledge's owner has been changed&#13;
    ///       appropriately.&#13;
    ///&#13;
    /// This function can be called by anybody at anytime on any pledge.&#13;
    ///  In general it can be called to force the calls of the affected &#13;
    ///  plugins, which also need to be predicted by the UI&#13;
    /// @param idPledge This is the id of the pledge that will be normalized&#13;
    /// @return The normalized Pledge!&#13;
    function normalizePledge(uint64 idPledge) returns(uint64) {&#13;
&#13;
        Pledge storage p = findPledge(idPledge);&#13;
&#13;
        // Check to make sure this pledge hasn't already been used &#13;
        // or is in the process of being used&#13;
        if (p.pledgeState != PledgeState.Pledged) {&#13;
            return idPledge;&#13;
        }&#13;
&#13;
        // First send to a project if it's proposed and committed&#13;
        if ((p.intendedProject &gt; 0) &amp;&amp; ( getTime() &gt; p.commitTime)) {&#13;
            uint64 oldPledge = findOrCreatePledge(&#13;
                p.owner,&#13;
                p.delegationChain,&#13;
                0,&#13;
                0,&#13;
                p.oldPledge,&#13;
                PledgeState.Pledged&#13;
            );&#13;
            uint64 toPledge = findOrCreatePledge(&#13;
                p.intendedProject,&#13;
                new uint64[](0),&#13;
                0,&#13;
                0,&#13;
                oldPledge,&#13;
                PledgeState.Pledged&#13;
            );&#13;
            doTransfer(idPledge, toPledge, p.amount);&#13;
            idPledge = toPledge;&#13;
            p = findPledge(idPledge);&#13;
        }&#13;
&#13;
        toPledge = getOldestPledgeNotCanceled(idPledge);&#13;
        if (toPledge != idPledge) {&#13;
            doTransfer(idPledge, toPledge, p.amount);&#13;
        }&#13;
&#13;
        return toPledge;&#13;
    }&#13;
&#13;
/////////////&#13;
// Plugins&#13;
/////////////&#13;
&#13;
    /// @notice `callPlugin` is used to trigger the general functions in the&#13;
    ///  plugin for any actions needed before and after a transfer happens.&#13;
    ///  Specifically what this does in relation to the plugin is something&#13;
    ///  that largely depends on the functions of that plugin. This function&#13;
    ///  is generally called in pairs, once before, and once after a transfer.&#13;
    /// @param before This toggle determines whether the plugin call is occurring&#13;
    ///  before or after a transfer.&#13;
    /// @param adminId This should be the Id of the *trusted* individual&#13;
    ///  who has control over this plugin.&#13;
    /// @param fromPledge This is the Id from which value is being transfered.&#13;
    /// @param toPledge This is the Id that value is being transfered to.&#13;
    /// @param context The situation that is triggering the plugin. See plugin&#13;
    ///  for a full description of contexts.&#13;
    /// @param amount The amount of value that is being transfered.&#13;
    function callPlugin(&#13;
        bool before,&#13;
        uint64 adminId,&#13;
        uint64 fromPledge,&#13;
        uint64 toPledge,&#13;
        uint64 context,&#13;
        uint amount&#13;
    ) internal returns (uint allowedAmount) {&#13;
&#13;
        uint newAmount;&#13;
        allowedAmount = amount;&#13;
        PledgeAdmin storage admin = findAdmin(adminId);&#13;
        // Checks admin has a plugin assigned and a non-zero amount is requested&#13;
        if ((address(admin.plugin) != 0) &amp;&amp; (allowedAmount &gt; 0)) {&#13;
            // There are two seperate functions called in the plugin.&#13;
            // One is called before the transfer and one after&#13;
            if (before) {&#13;
                newAmount = admin.plugin.beforeTransfer(&#13;
                    adminId,&#13;
                    fromPledge,&#13;
                    toPledge,&#13;
                    context,&#13;
                    amount&#13;
                );&#13;
                require(newAmount &lt;= allowedAmount);&#13;
                allowedAmount = newAmount;&#13;
            } else {&#13;
                admin.plugin.afterTransfer(&#13;
                    adminId,&#13;
                    fromPledge,&#13;
                    toPledge,&#13;
                    context,&#13;
                    amount&#13;
                );&#13;
            }&#13;
        }&#13;
    }&#13;
&#13;
    /// @notice `callPluginsPledge` is used to apply plugin calls to&#13;
    ///  the delegate chain and the intended project if there is one.&#13;
    ///  It does so in either a transferring or receiving context based&#13;
    ///  on the `idPledge` and  `fromPledge` parameters.&#13;
    /// @param before This toggle determines whether the plugin call is occuring&#13;
    ///  before or after a transfer.&#13;
    /// @param idPledge This is the Id of the pledge on which this plugin&#13;
    ///  is being called.&#13;
    /// @param fromPledge This is the Id from which value is being transfered.&#13;
    /// @param toPledge This is the Id that value is being transfered to.&#13;
    /// @param amount The amount of value that is being transfered.&#13;
    function callPluginsPledge(&#13;
        bool before,&#13;
        uint64 idPledge,&#13;
        uint64 fromPledge,&#13;
        uint64 toPledge,&#13;
        uint amount&#13;
    ) internal returns (uint allowedAmount) {&#13;
        // Determine if callPlugin is being applied in a receiving&#13;
        // or transferring context&#13;
        uint64 offset = idPledge == fromPledge ? 0 : 256;&#13;
        allowedAmount = amount;&#13;
        Pledge storage p = findPledge(idPledge);&#13;
&#13;
        // Always call the plugin on the owner&#13;
        allowedAmount = callPlugin(&#13;
            before,&#13;
            p.owner,&#13;
            fromPledge,&#13;
            toPledge,&#13;
            offset,&#13;
            allowedAmount&#13;
        );&#13;
&#13;
        // Apply call plugin to all delegates&#13;
        for (uint64 i=0; i&lt;p.delegationChain.length; i++) {&#13;
            allowedAmount = callPlugin(&#13;
                before,&#13;
                p.delegationChain[i],&#13;
                fromPledge,&#13;
                toPledge,&#13;
                offset + i+1,&#13;
                allowedAmount&#13;
            );&#13;
        }&#13;
&#13;
        // If there is an intended project also call the plugin in&#13;
        // either a transferring or receiving context based on offset&#13;
        // on the intended project&#13;
        if (p.intendedProject &gt; 0) {&#13;
            allowedAmount = callPlugin(&#13;
                before,&#13;
                p.intendedProject,&#13;
                fromPledge,&#13;
                toPledge,&#13;
                offset + 255,&#13;
                allowedAmount&#13;
            );&#13;
        }&#13;
    }&#13;
&#13;
&#13;
    /// @notice `callPlugins` calls `callPluginsPledge` once for the transfer&#13;
    ///  context and once for the receiving context. The aggregated &#13;
    ///  allowed amount is then returned.&#13;
    /// @param before This toggle determines whether the plugin call is occurring&#13;
    ///  before or after a transfer.&#13;
    /// @param fromPledge This is the Id from which value is being transferred.&#13;
    /// @param toPledge This is the Id that value is being transferred to.&#13;
    /// @param amount The amount of value that is being transferred.&#13;
    function callPlugins(&#13;
        bool before,&#13;
        uint64 fromPledge,&#13;
        uint64 toPledge,&#13;
        uint amount&#13;
    ) internal returns (uint allowedAmount) {&#13;
        allowedAmount = amount;&#13;
&#13;
        // Call the pledges plugins in the transfer context&#13;
        allowedAmount = callPluginsPledge(&#13;
            before,&#13;
            fromPledge,&#13;
            fromPledge,&#13;
            toPledge,&#13;
            allowedAmount&#13;
        );&#13;
&#13;
        // Call the pledges plugins in the receive context&#13;
        allowedAmount = callPluginsPledge(&#13;
            before,&#13;
            toPledge,&#13;
            fromPledge,&#13;
            toPledge,&#13;
            allowedAmount&#13;
        );&#13;
    }&#13;
&#13;
/////////////&#13;
// Test functions&#13;
/////////////&#13;
&#13;
    /// @notice Basic helper function to return the current time&#13;
    function getTime() internal returns (uint) {&#13;
        return now;&#13;
    }&#13;
&#13;
    // Event Delcerations&#13;
    event Transfer(uint64 indexed from, uint64 indexed to, uint amount);&#13;
    event CancelProject(uint64 indexed idProject);&#13;
&#13;
}