pragma solidity ^0.4.24;

// _____.___.              __   .__.__     _____             .___.__  _____.__           .___
// \__  |   | ____   ____ |  | _|__|__|   /     \   ____   __| _/|__|/ ____\__| ____   __| _/
//  /   |   |/  _ \_/ ___\|  |/ /  |  |  /  \ /  \ /  _ \ / __ | |  \   __\|  |/ __ \ / __ | 
//  \____   (  <_> )  \___|    <|  |  | /    Y    (  <_> ) /_/ | |  ||  |  |  \  ___// /_/ | 
//  / ______|\____/ \___  >__|_ \__|__| \____|__  /\____/\____ | |__||__|  |__|\___  >____ | 
//  \/                  \/     \/               \/            \/                   \/     \/ 
// Team Just Copyright Received.
// <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="e891878b8381d9dfa88f85898184c68b8785">[emailÂ protected]</a> modified&#13;
//==============================================================================&#13;
//     _    _  _ _|_ _  .&#13;
//    (/_\/(/_| | | _\  .&#13;
//==============================================================================&#13;
contract F3Devents {&#13;
    // fired whenever a player registers a name&#13;
    event onNewName&#13;
    (&#13;
        uint256 indexed playerID,&#13;
        address indexed playerAddress,&#13;
        bytes32 indexed playerName,&#13;
        bool isNewPlayer,&#13;
        uint256 affiliateID,&#13;
        address affiliateAddress,&#13;
        bytes32 affiliateName,&#13;
        uint256 amountPaid,&#13;
        uint256 timeStamp&#13;
    );&#13;
    &#13;
    // fired at end of buy or reload&#13;
    event onEndTx&#13;
    (&#13;
        uint256 compressedData,     &#13;
        uint256 compressedIDs,      &#13;
        bytes32 playerName,&#13;
        address playerAddress,&#13;
        uint256 ethIn,&#13;
        uint256 keysBought,&#13;
        address winnerAddr,&#13;
        bytes32 winnerName,&#13;
        uint256 amountWon,&#13;
        uint256 newPot,&#13;
        uint256 P3DAmount,&#13;
        uint256 genAmount,&#13;
        uint256 potAmount,&#13;
        uint256 airDropPot&#13;
    );&#13;
    &#13;
	// fired whenever theres a withdraw&#13;
    event onWithdraw&#13;
    (&#13;
        uint256 indexed playerID,&#13;
        address playerAddress,&#13;
        bytes32 playerName,&#13;
        uint256 ethOut,&#13;
        uint256 timeStamp&#13;
    );&#13;
    &#13;
    // fired whenever a withdraw forces end round to be ran&#13;
    event onWithdrawAndDistribute&#13;
    (&#13;
        address playerAddress,&#13;
        bytes32 playerName,&#13;
        uint256 ethOut,&#13;
        uint256 compressedData,&#13;
        uint256 compressedIDs,&#13;
        address winnerAddr,&#13;
        bytes32 winnerName,&#13;
        uint256 amountWon,&#13;
        uint256 newPot,&#13;
        uint256 P3DAmount,&#13;
        uint256 genAmount&#13;
    );&#13;
    &#13;
    // (fomo3d long only) fired whenever a player tries a buy after round timer &#13;
    // hit zero, and causes end round to be ran.&#13;
    event onBuyAndDistribute&#13;
    (&#13;
        address playerAddress,&#13;
        bytes32 playerName,&#13;
        uint256 ethIn,&#13;
        uint256 compressedData,&#13;
        uint256 compressedIDs,&#13;
        address winnerAddr,&#13;
        bytes32 winnerName,&#13;
        uint256 amountWon,&#13;
        uint256 newPot,&#13;
        uint256 P3DAmount,&#13;
        uint256 genAmount&#13;
    );&#13;
    &#13;
    // (fomo3d long only) fired whenever a player tries a reload after round timer &#13;
    // hit zero, and causes end round to be ran.&#13;
    event onReLoadAndDistribute&#13;
    (&#13;
        address playerAddress,&#13;
        bytes32 playerName,&#13;
        uint256 compressedData,&#13;
        uint256 compressedIDs,&#13;
        address winnerAddr,&#13;
        bytes32 winnerName,&#13;
        uint256 amountWon,&#13;
        uint256 newPot,&#13;
        uint256 P3DAmount,&#13;
        uint256 genAmount&#13;
    );&#13;
    &#13;
    // fired whenever an affiliate is paid&#13;
    event onAffiliatePayout&#13;
    (&#13;
        uint256 indexed affiliateID,&#13;
        address affiliateAddress,&#13;
        bytes32 affiliateName,&#13;
        uint256 indexed roundID,&#13;
        uint256 indexed buyerID,&#13;
        uint256 amount,&#13;
        uint256 timeStamp&#13;
    );&#13;
    &#13;
    // received pot swap deposit&#13;
    event onPotSwapDeposit&#13;
    (&#13;
        uint256 roundID,&#13;
        uint256 amountAddedToPot&#13;
    );&#13;
}&#13;
&#13;
//==============================================================================&#13;
//   _ _  _ _|_ _ _  __|_   _ _ _|_    _   .&#13;
//  (_(_)| | | | (_|(_ |   _\(/_ | |_||_)  .&#13;
//====================================|=========================================&#13;
&#13;
contract modularLong is F3Devents {}&#13;
&#13;
contract EthKillerLong is modularLong {&#13;
    using SafeMath for *;&#13;
    using NameFilter for string;&#13;
    using F3DKeysCalcLong for uint256;&#13;
&#13;
    address public teamAddress = 0xc2daaf4e63af76b394dea9a98a1fa650fc626b91;&#13;
&#13;
    function setTeamAddress(address addr) isOwner() public {&#13;
        teamAddress = addr;&#13;
    }&#13;
    function gameSettings(uint256 rndExtra, uint256 rndGap) isOwner() public {&#13;
        rndExtra_ = rndExtra;&#13;
        rndGap_ = rndGap;&#13;
    }&#13;
//==============================================================================&#13;
//     _ _  _  |`. _     _ _ |_ | _  _  .&#13;
//    (_(_)| |~|~|(_||_|| (_||_)|(/__\  .  (game settings)&#13;
//=================_|===========================================================&#13;
    string constant public name = "Eth Killer Long Official";&#13;
    string constant public symbol = "EKL";&#13;
    uint256 private rndExtra_ = 0;     // length of the very first ICO &#13;
    uint256 private rndGap_ = 0;         // length of ICO phase, set to 1 year for EOS.&#13;
    uint256 constant private rndInit_ = 12 hours;                // round timer starts at this&#13;
    uint256 constant private rndInc_ = 30 seconds;              // every full key purchased adds this much to the timer&#13;
    uint256 constant private rndMax_ = 24 hours;                // max length a round timer can be&#13;
//==============================================================================&#13;
//     _| _ _|_ _    _ _ _|_    _   .&#13;
//    (_|(_| | (_|  _\(/_ | |_||_)  .  (data used to store game info that changes)&#13;
//=============================|================================================&#13;
    uint256 public airDropPot_;             // person who gets the airdrop wins part of this pot&#13;
    uint256 public airDropTracker_ = 0;     // incremented each time a "qualified" tx occurs.  used to determine winning air drop&#13;
    uint256 public rID_;    // round id number / total rounds that have happened&#13;
    uint256 public registrationFee_ = 10 finney;            // price to register a name&#13;
//****************&#13;
// PLAYER DATA &#13;
//****************&#13;
    mapping (address =&gt; uint256) public pIDxAddr_;          // (addr =&gt; pID) returns player id by address&#13;
    mapping (bytes32 =&gt; uint256) public pIDxName_;          // (name =&gt; pID) returns player id by name&#13;
    mapping (uint256 =&gt; F3Ddatasets.Player) public plyr_;   // (pID =&gt; data) player data&#13;
    mapping (uint256 =&gt; mapping (uint256 =&gt; F3Ddatasets.PlayerRounds)) public plyrRnds_;    // (pID =&gt; rID =&gt; data) player round data by player id &amp; round id&#13;
    // mapping (uint256 =&gt; mapping (bytes32 =&gt; bool)) public plyrNames_; // (pID =&gt; name =&gt; bool) list of names a player owns.  (used so you can change your display name amongst any name you own)&#13;
    uint256 private playerCount = 0;&#13;
    uint256 private totalWinnersKeys_;&#13;
    uint256 constant private winnerNum_ = 5; // sync change in structure Round.plyrs&#13;
&#13;
    ///////////// playerbook  ///////////&#13;
    function registerName(address _addr, bytes32 _name, uint256 _affCode) private returns(bool, uint256) {&#13;
        require (msg.value &gt;= registrationFee_, "umm.....  you have to pay the name fee");&#13;
        require(pIDxName_[_name] == 0, "sorry that names already taken");&#13;
&#13;
        uint256 _pID = pIDxAddr_[_addr];&#13;
        bool isNew = false;&#13;
        if (_pID == 0) {&#13;
            isNew = true;&#13;
            playerCount++;&#13;
            _pID = playerCount;&#13;
            pIDxAddr_[_addr] = _pID;&#13;
            plyr_[_pID].name = _name;&#13;
            pIDxName_[_name] = _pID;&#13;
        }&#13;
        if (_affCode != 0 &amp;&amp; _affCode != plyr_[_pID].laff &amp;&amp; _affCode != _pID) {&#13;
            plyr_[_pID].laff = _affCode;&#13;
        } else if (_affCode == _pID) {&#13;
            _affCode = 0;&#13;
        }&#13;
        return (isNew, _affCode);&#13;
    }&#13;
    function registerNameXaddrFromDapp(address _addr, bytes32 _name, address _affCode) private returns(bool, uint256) {&#13;
        uint256 _affID = 0;&#13;
        if (_affCode != address(0) &amp;&amp; _affCode != _addr) {&#13;
            _affID = pIDxAddr_[_affCode];&#13;
        }&#13;
        return registerName(_addr, _name, _affID);&#13;
    }&#13;
    function registerNameXnameFromDapp(address _addr, bytes32 _name, bytes32 _affCode) private returns(bool, uint256) {&#13;
        uint256 _affID = 0;&#13;
        if (_affCode != "" &amp;&amp; _affCode != _name) {&#13;
            _affID = pIDxName_[_affCode];&#13;
        }&#13;
        return registerName(_addr, _name, _affID);&#13;
    }&#13;
//****************&#13;
// ROUND DATA &#13;
//****************&#13;
    mapping (uint256 =&gt; F3Ddatasets.Round) public round_;   // (rID =&gt; data) round data&#13;
    mapping (uint256 =&gt; mapping(uint256 =&gt; uint256)) public rndTmEth_;      // (rID =&gt; tID =&gt; data) eth in per team, by round id and team id&#13;
//****************&#13;
// TEAM FEE DATA &#13;
//****************&#13;
    mapping (uint256 =&gt; F3Ddatasets.TeamFee) public fees_;          // (team =&gt; fees) fee distribution by team&#13;
    mapping (uint256 =&gt; F3Ddatasets.PotSplit) public potSplit_;     // (team =&gt; fees) pot split distribution by team&#13;
//==============================================================================&#13;
//     _ _  _  __|_ _    __|_ _  _  .&#13;
//    (_(_)| |_\ | | |_|(_ | (_)|   .  (initial data setup upon contract deploy)&#13;
//==============================================================================&#13;
    address owner;&#13;
    constructor()&#13;
        public&#13;
    {&#13;
        owner = msg.sender;&#13;
		// Team allocation structures&#13;
        // 0 = whales&#13;
        // 1 = bears&#13;
        // 2 = sneks&#13;
        // 3 = bulls&#13;
&#13;
		// Team allocation percentages&#13;
        fees_[0] = F3Ddatasets.TeamFee(30,12);&#13;
        fees_[1] = F3Ddatasets.TeamFee(43,7);&#13;
        fees_[2] = F3Ddatasets.TeamFee(52,16);&#13;
        fees_[3] = F3Ddatasets.TeamFee(43,15);&#13;
        &#13;
        // how to split up the final pot based on which team was picked&#13;
        potSplit_[0] = F3Ddatasets.PotSplit(15,15);&#13;
        potSplit_[1] = F3Ddatasets.PotSplit(25,10);&#13;
        potSplit_[2] = F3Ddatasets.PotSplit(20,24);&#13;
        potSplit_[3] = F3Ddatasets.PotSplit(30,14);&#13;
    }&#13;
//==============================================================================&#13;
//     _ _  _  _|. |`. _  _ _  .&#13;
//    | | |(_)(_||~|~|(/_| _\  .  (these are safety checks)&#13;
//==============================================================================&#13;
    /**&#13;
     * @dev used to make sure no one can interact with contract until it has &#13;
     * been activated. &#13;
     */&#13;
    modifier isActivated() {&#13;
        require(activated_ == true, "its not ready yet.  check ?eta in discord"); &#13;
        _;&#13;
    }&#13;
    &#13;
    modifier isOwner() {&#13;
        require(owner == msg.sender, "sorry owner only");&#13;
        _;&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev prevents contracts from interacting with fomo3d &#13;
     */&#13;
    modifier isHuman() {&#13;
        address _addr = msg.sender;&#13;
        uint256 _codeLength;&#13;
        &#13;
        assembly {_codeLength := extcodesize(_addr)}&#13;
        require(_codeLength == 0, "sorry humans only");&#13;
        _;&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev sets boundaries for incoming tx &#13;
     */&#13;
    modifier isWithinLimits(uint256 _eth) {&#13;
        require(_eth &gt;= 1000000000, "pocket lint: not a valid currency");&#13;
        require(_eth &lt;= 100000000000000000000000, "no vitalik, no");&#13;
        _;    &#13;
    }&#13;
    &#13;
//==============================================================================&#13;
//     _    |_ |. _   |`    _  __|_. _  _  _  .&#13;
//    |_)|_||_)||(_  ~|~|_|| |(_ | |(_)| |_\  .  (use these to interact with contract)&#13;
//====|=========================================================================&#13;
    /**&#13;
     * @dev emergency buy uses last stored affiliate ID and team snek&#13;
     */&#13;
    function()&#13;
        isActivated()&#13;
        isHuman()&#13;
        isWithinLimits(msg.value)&#13;
        public&#13;
        payable&#13;
    {&#13;
        // set up our tx event data and determine if player is new or not&#13;
        F3Ddatasets.EventReturns memory _eventData_ = determinePID(_eventData_);&#13;
            &#13;
        // fetch player id&#13;
        uint256 _pID = pIDxAddr_[msg.sender];&#13;
        &#13;
        // buy core &#13;
        buyCore(_pID, plyr_[_pID].laff, 2, _eventData_);&#13;
    }&#13;
&#13;
    function updateContract(address newContract) isOwner() public returns (bool) {&#13;
        if (round_[rID_].end &lt; now) {&#13;
            Fomo3dContract nc = Fomo3dContract(newContract);&#13;
            newContract.transfer(address(this).balance);&#13;
            nc.setOldContractData(address(this));&#13;
            return (true);&#13;
        }&#13;
        return (false);&#13;
    }&#13;
    &#13;
    /**&#13;
     * @dev converts all incoming ethereum to keys.&#13;
     * -functionhash- 0x8f38f309 (using ID for affiliate)&#13;
     * -functionhash- 0x98a0871d (using address for affiliate)&#13;
     * -functionhash- 0xa65b37a1 (using name for affiliate)&#13;
     * @param _affCode the ID/address/name of the player who gets the affiliate fee&#13;
     * @param _team what team is the player playing for?&#13;
     */&#13;
    function buyXid(uint256 _affCode, uint256 _team)&#13;
        isActivated()&#13;
        isHuman()&#13;
        isWithinLimits(msg.value)&#13;
        public&#13;
        payable&#13;
    {&#13;
        // set up our tx event data and determine if player is new or not&#13;
        F3Ddatasets.EventReturns memory _eventData_ = determinePID(_eventData_);&#13;
        &#13;
        // fetch player id&#13;
        uint256 _pID = pIDxAddr_[msg.sender];&#13;
        &#13;
        // manage affiliate residuals&#13;
        // if no affiliate code was given or player tried to use their own, lolz&#13;
        if (_affCode == 0 || _affCode == _pID)&#13;
        {&#13;
            // use last stored affiliate code &#13;
            _affCode = plyr_[_pID].laff;&#13;
            &#13;
        // if affiliate code was given &amp; its not the same as previously stored &#13;
        } else if (_affCode != plyr_[_pID].laff) {&#13;
            // update last affiliate &#13;
            plyr_[_pID].laff = _affCode;&#13;
        }&#13;
        &#13;
        // verify a valid team was selected&#13;
        _team = verifyTeam(_team);&#13;
        &#13;
        // buy core &#13;
        buyCore(_pID, _affCode, _team, _eventData_);&#13;
    }&#13;
    &#13;
    function buyXaddr(address _affCode, uint256 _team)&#13;
        isActivated()&#13;
        isHuman()&#13;
        isWithinLimits(msg.value)&#13;
        public&#13;
        payable&#13;
    {&#13;
        // set up our tx event data and determine if player is new or not&#13;
        F3Ddatasets.EventReturns memory _eventData_ = determinePID(_eventData_);&#13;
        &#13;
        // fetch player id&#13;
        uint256 _pID = pIDxAddr_[msg.sender];&#13;
        &#13;
        // manage affiliate residuals&#13;
        uint256 _affID;&#13;
        // if no affiliate code was given or player tried to use their own, lolz&#13;
        if (_affCode == address(0) || _affCode == msg.sender)&#13;
        {&#13;
            // use last stored affiliate code&#13;
            _affID = plyr_[_pID].laff;&#13;
        &#13;
        // if affiliate code was given    &#13;
        } else {&#13;
            // get affiliate ID from aff Code &#13;
            _affID = pIDxAddr_[_affCode];&#13;
            &#13;
            // if affID is not the same as previously stored &#13;
            if (_affID != plyr_[_pID].laff)&#13;
            {&#13;
                // update last affiliate&#13;
                plyr_[_pID].laff = _affID;&#13;
            }&#13;
        }&#13;
        &#13;
        // verify a valid team was selected&#13;
        _team = verifyTeam(_team);&#13;
        &#13;
        // buy core &#13;
        buyCore(_pID, _affID, _team, _eventData_);&#13;
    }&#13;
    &#13;
    function buyXname(bytes32 _affCode, uint256 _team)&#13;
        isActivated()&#13;
        isHuman()&#13;
        isWithinLimits(msg.value)&#13;
        public&#13;
        payable&#13;
    {&#13;
        // set up our tx event data and determine if player is new or not&#13;
        F3Ddatasets.EventReturns memory _eventData_ = determinePID(_eventData_);&#13;
        &#13;
        // fetch player id&#13;
        uint256 _pID = pIDxAddr_[msg.sender];&#13;
        &#13;
        // manage affiliate residuals&#13;
        uint256 _affID;&#13;
        // if no affiliate code was given or player tried to use their own, lolz&#13;
        if (_affCode == "" || _affCode == plyr_[_pID].name)&#13;
        {&#13;
            // use last stored affiliate code&#13;
            _affID = plyr_[_pID].laff;&#13;
        &#13;
        // if affiliate code was given&#13;
        } else {&#13;
            // get affiliate ID from aff Code&#13;
            _affID = pIDxName_[_affCode];&#13;
            &#13;
            // if affID is not the same as previously stored&#13;
            if (_affID != plyr_[_pID].laff)&#13;
            {&#13;
                // update last affiliate&#13;
                plyr_[_pID].laff = _affID;&#13;
            }&#13;
        }&#13;
        &#13;
        // verify a valid team was selected&#13;
        _team = verifyTeam(_team);&#13;
        &#13;
        // buy core &#13;
        buyCore(_pID, _affID, _team, _eventData_);&#13;
    }&#13;
    &#13;
    /**&#13;
     * @dev essentially the same as buy, but instead of you sending ether &#13;
     * from your wallet, it uses your unwithdrawn earnings.&#13;
     * -functionhash- 0x349cdcac (using ID for affiliate)&#13;
     * -functionhash- 0x82bfc739 (using address for affiliate)&#13;
     * -functionhash- 0x079ce327 (using name for affiliate)&#13;
     * @param _affCode the ID/address/name of the player who gets the affiliate fee&#13;
     * @param _team what team is the player playing for?&#13;
     * @param _eth amount of earnings to use (remainder returned to gen vault)&#13;
     */&#13;
    function reLoadXid(uint256 _affCode, uint256 _team, uint256 _eth)&#13;
        isActivated()&#13;
        isHuman()&#13;
        isWithinLimits(_eth)&#13;
        public&#13;
    {&#13;
        // set up our tx event data&#13;
        F3Ddatasets.EventReturns memory _eventData_;&#13;
        &#13;
        // fetch player ID&#13;
        uint256 _pID = pIDxAddr_[msg.sender];&#13;
        &#13;
        // manage affiliate residuals&#13;
        // if no affiliate code was given or player tried to use their own, lolz&#13;
        if (_affCode == 0 || _affCode == _pID)&#13;
        {&#13;
            // use last stored affiliate code &#13;
            _affCode = plyr_[_pID].laff;&#13;
            &#13;
        // if affiliate code was given &amp; its not the same as previously stored &#13;
        } else if (_affCode != plyr_[_pID].laff) {&#13;
            // update last affiliate &#13;
            plyr_[_pID].laff = _affCode;&#13;
        }&#13;
&#13;
        // verify a valid team was selected&#13;
        _team = verifyTeam(_team);&#13;
&#13;
        // reload core&#13;
        reLoadCore(_pID, _affCode, _team, _eth, _eventData_);&#13;
    }&#13;
    &#13;
    function reLoadXaddr(address _affCode, uint256 _team, uint256 _eth)&#13;
        isActivated()&#13;
        isHuman()&#13;
        isWithinLimits(_eth)&#13;
        public&#13;
    {&#13;
        // set up our tx event data&#13;
        F3Ddatasets.EventReturns memory _eventData_;&#13;
        &#13;
        // fetch player ID&#13;
        uint256 _pID = pIDxAddr_[msg.sender];&#13;
        &#13;
        // manage affiliate residuals&#13;
        uint256 _affID;&#13;
        // if no affiliate code was given or player tried to use their own, lolz&#13;
        if (_affCode == address(0) || _affCode == msg.sender)&#13;
        {&#13;
            // use last stored affiliate code&#13;
            _affID = plyr_[_pID].laff;&#13;
        &#13;
        // if affiliate code was given    &#13;
        } else {&#13;
            // get affiliate ID from aff Code &#13;
            _affID = pIDxAddr_[_affCode];&#13;
            &#13;
            // if affID is not the same as previously stored &#13;
            if (_affID != plyr_[_pID].laff)&#13;
            {&#13;
                // update last affiliate&#13;
                plyr_[_pID].laff = _affID;&#13;
            }&#13;
        }&#13;
        &#13;
        // verify a valid team was selected&#13;
        _team = verifyTeam(_team);&#13;
        &#13;
        // reload core&#13;
        reLoadCore(_pID, _affID, _team, _eth, _eventData_);&#13;
    }&#13;
    &#13;
    function reLoadXname(bytes32 _affCode, uint256 _team, uint256 _eth)&#13;
        isActivated()&#13;
        isHuman()&#13;
        isWithinLimits(_eth)&#13;
        public&#13;
    {&#13;
        // set up our tx event data&#13;
        F3Ddatasets.EventReturns memory _eventData_;&#13;
        &#13;
        // fetch player ID&#13;
        uint256 _pID = pIDxAddr_[msg.sender];&#13;
        &#13;
        // manage affiliate residuals&#13;
        uint256 _affID;&#13;
        // if no affiliate code was given or player tried to use their own, lolz&#13;
        if (_affCode == "" || _affCode == plyr_[_pID].name)&#13;
        {&#13;
            // use last stored affiliate code&#13;
            _affID = plyr_[_pID].laff;&#13;
        &#13;
        // if affiliate code was given&#13;
        } else {&#13;
            // get affiliate ID from aff Code&#13;
            _affID = pIDxName_[_affCode];&#13;
            &#13;
            // if affID is not the same as previously stored&#13;
            if (_affID != plyr_[_pID].laff)&#13;
            {&#13;
                // update last affiliate&#13;
                plyr_[_pID].laff = _affID;&#13;
            }&#13;
        }&#13;
        &#13;
        // verify a valid team was selected&#13;
        _team = verifyTeam(_team);&#13;
        &#13;
        // reload core&#13;
        reLoadCore(_pID, _affID, _team, _eth, _eventData_);&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev withdraws all of your earnings.&#13;
     * -functionhash- 0x3ccfd60b&#13;
     */&#13;
    function withdraw()&#13;
        isActivated()&#13;
        isHuman()&#13;
        public&#13;
    {&#13;
        // setup local rID &#13;
        uint256 _rID = rID_;&#13;
        &#13;
        // grab time&#13;
        uint256 _now = now;&#13;
        &#13;
        // fetch player ID&#13;
        uint256 _pID = pIDxAddr_[msg.sender];&#13;
        &#13;
        // setup temp var for player eth&#13;
        uint256 _eth;&#13;
        &#13;
        // check to see if round has ended and no one has run round end yet&#13;
        if (_now &gt; round_[_rID].end &amp;&amp; round_[_rID].ended == false &amp;&amp; hasPlayersInRound(_rID) == true)&#13;
        {&#13;
            // set up our tx event data&#13;
            F3Ddatasets.EventReturns memory _eventData_;&#13;
            &#13;
            // end the round (distributes pot)&#13;
            round_[_rID].ended = true;&#13;
            _eventData_ = endRound(_eventData_);&#13;
            &#13;
			// get their earnings&#13;
            _eth = withdrawEarnings(_pID);&#13;
            &#13;
            // gib moni&#13;
            if (_eth &gt; 0)&#13;
                plyr_[_pID].addr.transfer(_eth);    &#13;
            &#13;
            // build event data&#13;
            _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000);&#13;
            _eventData_.compressedIDs = _eventData_.compressedIDs + _pID;&#13;
            &#13;
            // fire withdraw and distribute event&#13;
            emit F3Devents.onWithdrawAndDistribute&#13;
            (&#13;
                msg.sender, &#13;
                plyr_[_pID].name, &#13;
                _eth, &#13;
                _eventData_.compressedData, &#13;
                _eventData_.compressedIDs, &#13;
                _eventData_.winnerAddr, &#13;
                _eventData_.winnerName, &#13;
                _eventData_.amountWon, &#13;
                _eventData_.newPot, &#13;
                _eventData_.P3DAmount, &#13;
                _eventData_.genAmount&#13;
            );&#13;
            &#13;
        // in any other situation&#13;
        } else {&#13;
            // get their earnings&#13;
            _eth = withdrawEarnings(_pID);&#13;
            &#13;
            // gib moni&#13;
            if (_eth &gt; 0)&#13;
                plyr_[_pID].addr.transfer(_eth);&#13;
            &#13;
            // fire withdraw event&#13;
            emit F3Devents.onWithdraw(_pID, msg.sender, plyr_[_pID].name, _eth, _now);&#13;
        }&#13;
    }&#13;
    &#13;
    /**&#13;
     * @dev use these to register names.  they are just wrappers that will send the&#13;
     * registration requests to the PlayerBook contract.  So registering here is the &#13;
     * same as registering there.  UI will always display the last name you registered.&#13;
     * but you will still own all previously registered names to use as affiliate &#13;
     * links.&#13;
     * - must pay a registration fee.&#13;
     * - name must be unique&#13;
     * - names will be converted to lowercase&#13;
     * - name cannot start or end with a space &#13;
     * - cannot have more than 1 space in a row&#13;
     * - cannot be only numbers&#13;
     * - cannot start with 0x &#13;
     * - name must be at least 1 char&#13;
     * - max length of 32 characters long&#13;
     * - allowed characters: a-z, 0-9, and space&#13;
     * -functionhash- 0x921dec21 (using ID for affiliate)&#13;
     * -functionhash- 0x3ddd4698 (using address for affiliate)&#13;
     * -functionhash- 0x685ffd83 (using name for affiliate)&#13;
     * @param _nameString players desired name&#13;
     * @param _affCode affiliate ID, address, or name of who referred you&#13;
     * (this might cost a lot of gas)&#13;
     */&#13;
    function registerNameXID(string _nameString, uint256 _affCode)&#13;
        isHuman()&#13;
        public&#13;
        payable&#13;
    {&#13;
        bytes32 _name = _nameString.nameFilter();&#13;
        address _addr = msg.sender;&#13;
        uint256 _paid = msg.value;&#13;
        (bool _isNewPlayer, uint256 _affID) = registerName(_addr, _name, _affCode);&#13;
        &#13;
        uint256 _pID = pIDxAddr_[_addr];&#13;
        &#13;
        // fire event&#13;
        emit F3Devents.onNewName(_pID, _addr, _name, _isNewPlayer, _affID, plyr_[_affID].addr, plyr_[_affID].name, _paid, now);&#13;
    }&#13;
    &#13;
    function registerNameXaddr(string _nameString, address _affCode)&#13;
        isHuman()&#13;
        public&#13;
        payable&#13;
    {&#13;
        bytes32 _name = _nameString.nameFilter();&#13;
        address _addr = msg.sender;&#13;
        uint256 _paid = msg.value;&#13;
        (bool _isNewPlayer, uint256 _affID) = registerNameXaddrFromDapp(msg.sender, _name, _affCode);&#13;
        &#13;
        uint256 _pID = pIDxAddr_[_addr];&#13;
        &#13;
        // fire event&#13;
        emit F3Devents.onNewName(_pID, _addr, _name, _isNewPlayer, _affID, plyr_[_affID].addr, plyr_[_affID].name, _paid, now);&#13;
    }&#13;
    &#13;
    function registerNameXname(string _nameString, bytes32 _affCode)&#13;
        isHuman()&#13;
        public&#13;
        payable&#13;
    {&#13;
        bytes32 _name = _nameString.nameFilter();&#13;
        address _addr = msg.sender;&#13;
        uint256 _paid = msg.value;&#13;
        (bool _isNewPlayer, uint256 _affID) = registerNameXnameFromDapp(msg.sender, _name, _affCode);&#13;
        &#13;
        uint256 _pID = pIDxAddr_[_addr];&#13;
        &#13;
        // fire event&#13;
        emit F3Devents.onNewName(_pID, _addr, _name, _isNewPlayer, _affID, plyr_[_affID].addr, plyr_[_affID].name, _paid, now);&#13;
    }&#13;
//==============================================================================&#13;
//     _  _ _|__|_ _  _ _  .&#13;
//    (_|(/_ |  | (/_| _\  . (for UI &amp; viewing things on etherscan)&#13;
//=====_|=======================================================================&#13;
    /**&#13;
     * @dev return the price buyer will pay for next 1 individual key.&#13;
     * -functionhash- 0x018a25e8&#13;
     * @return price for next key bought (in wei format)&#13;
     */&#13;
    function getBuyPrice()&#13;
        public &#13;
        view &#13;
        returns(uint256)&#13;
    {  &#13;
        // setup local rID&#13;
        uint256 _rID = rID_;&#13;
        &#13;
        // grab time&#13;
        uint256 _now = now;&#13;
        &#13;
        // are we in a round?&#13;
        if (_now &gt; round_[_rID].strt + rndGap_ &amp;&amp; (_now &lt;= round_[_rID].end || (_now &gt; round_[_rID].end &amp;&amp; hasPlayersInRound(_rID) == false)))&#13;
            return ( (round_[_rID].keys.add(1000000000000000000)).ethRec(1000000000000000000) );&#13;
        else // rounds over.  need price for new round&#13;
            return ( 75000000000000 ); // init&#13;
    }&#13;
    &#13;
    /**&#13;
     * @dev returns time left.  dont spam this, you'll ddos yourself from your node &#13;
     * provider&#13;
     * -functionhash- 0xc7e284b8&#13;
     * @return time left in seconds&#13;
     */&#13;
    function getTimeLeft()&#13;
        public&#13;
        view&#13;
        returns(uint256)&#13;
    {&#13;
        // setup local rID&#13;
        uint256 _rID = rID_;&#13;
        &#13;
        // grab time&#13;
        uint256 _now = now;&#13;
        &#13;
        if (_now &lt; round_[_rID].end)&#13;
            if (_now &gt; round_[_rID].strt + rndGap_)&#13;
                return( (round_[_rID].end).sub(_now) );&#13;
            else&#13;
                return( (round_[_rID].strt + rndGap_).sub(_now) );&#13;
        else&#13;
            return(0);&#13;
    }&#13;
    &#13;
    function isWinner(uint256 _pID, uint256 _rID) private view returns (bool) {&#13;
        for (uint8 i = 0; i &lt; winnerNum_; i++) {&#13;
            if (round_[_rID].plyrs[i] == _pID) {&#13;
                return (true);&#13;
            }&#13;
        }&#13;
        return (false);&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev returns player earnings per vaults &#13;
     * -functionhash- 0x63066434&#13;
     * @return winnings vault&#13;
     * @return general vault&#13;
     * @return affiliate vault&#13;
     */&#13;
    function getPlayerVaults(uint256 _pID)&#13;
        public&#13;
        view&#13;
        returns(uint256 ,uint256, uint256)&#13;
    {&#13;
        // setup local rID&#13;
        uint256 _rID = rID_;&#13;
        &#13;
        // if round has ended.  but round end has not been run (so contract has not distributed winnings)&#13;
        if (now &gt; round_[_rID].end &amp;&amp; round_[_rID].ended == false &amp;&amp; hasPlayersInRound(_rID) == true)&#13;
        {&#13;
            // if player is winner &#13;
            if (isWinner(_pID, _rID))&#13;
            {&#13;
                calcTotalWinnerKeys(_rID);&#13;
                return&#13;
                (&#13;
                    (plyr_[_pID].win).add( (((round_[_rID].pot).mul(48)) / 100).mul(plyrRnds_[_pID][_rID].keys) / totalWinnersKeys_ ),&#13;
                    (plyr_[_pID].gen).add(  getPlayerVaultsHelper(_pID, _rID).sub(plyrRnds_[_pID][_rID].mask)   ),&#13;
                    plyr_[_pID].aff&#13;
                );&#13;
            // if player is not the winner&#13;
            } else {&#13;
                return&#13;
                (&#13;
                    plyr_[_pID].win,&#13;
                    (plyr_[_pID].gen).add(  getPlayerVaultsHelper(_pID, _rID).sub(plyrRnds_[_pID][_rID].mask)  ),&#13;
                    plyr_[_pID].aff&#13;
                );&#13;
            }&#13;
            &#13;
        // if round is still going on, or round has ended and round end has been ran&#13;
        } else {&#13;
            return&#13;
            (&#13;
                plyr_[_pID].win,&#13;
                (plyr_[_pID].gen).add(calcUnMaskedEarnings(_pID, plyr_[_pID].lrnd)),&#13;
                plyr_[_pID].aff&#13;
            );&#13;
        }&#13;
    }&#13;
    &#13;
    /**&#13;
     * solidity hates stack limits.  this lets us avoid that hate &#13;
     */&#13;
    function getPlayerVaultsHelper(uint256 _pID, uint256 _rID)&#13;
        private&#13;
        view&#13;
        returns(uint256)&#13;
    {&#13;
        return(  ((((round_[_rID].mask).add(((((round_[_rID].pot).mul(potSplit_[round_[_rID].team].gen)) / 100).mul(1000000000000000000)) / (round_[_rID].keys))).mul(plyrRnds_[_pID][_rID].keys)) / 1000000000000000000)  );&#13;
    }&#13;
    &#13;
    /**&#13;
     * @dev returns all current round info needed for front end&#13;
     * -functionhash- 0x747dff42&#13;
     * @return eth invested during ICO phase&#13;
     * @return round id &#13;
     * @return total keys for round &#13;
     * @return time round ends&#13;
     * @return time round started&#13;
     * @return current pot &#13;
     * @return current team ID &amp; player ID in lead &#13;
     * @return current player in leads address &#13;
     * @return current player in leads name&#13;
     * @return whales eth in for round&#13;
     * @return bears eth in for round&#13;
     * @return sneks eth in for round&#13;
     * @return bulls eth in for round&#13;
     * @return airdrop tracker # &amp; airdrop pot&#13;
     */&#13;
    function getCurrentRoundInfo()&#13;
        public&#13;
        view&#13;
        returns(uint256, uint256, uint256, uint256, uint256, uint256, uint256, address, bytes32, uint256, uint256, uint256, uint256, uint256)&#13;
    {&#13;
        // setup local rID&#13;
        // uint256 _rID = rID_;&#13;
        return&#13;
        (&#13;
            round_[rID_].ico,               //0&#13;
            rID_,                           //1&#13;
            round_[rID_].keys,              //2&#13;
            round_[rID_].end,               //3&#13;
            round_[rID_].strt,              //4&#13;
            round_[rID_].pot,               //5&#13;
            (round_[rID_].team + (round_[rID_].plyrs[winnerNum_ - 1] * 10)),     //6&#13;
            plyr_[round_[rID_].plyrs[winnerNum_ - 1]].addr,  //7&#13;
            plyr_[round_[rID_].plyrs[winnerNum_ - 1]].name,  //8&#13;
            rndTmEth_[rID_][0],             //9&#13;
            rndTmEth_[rID_][1],             //10&#13;
            rndTmEth_[rID_][2],             //11&#13;
            rndTmEth_[rID_][3],             //12&#13;
            airDropTracker_ + (airDropPot_ * 1000)              //13&#13;
        );&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev returns player info based on address.  if no address is given, it will &#13;
     * use msg.sender &#13;
     * -functionhash- 0xee0b5d8b&#13;
     * @param _addr address of the player you want to lookup &#13;
     * @return player ID &#13;
     * @return player name&#13;
     * @return keys owned (current round)&#13;
     * @return winnings vault&#13;
     * @return general vault &#13;
     * @return affiliate vault &#13;
	 * @return player round eth&#13;
     */&#13;
    function getPlayerInfoByAddress(address _addr)&#13;
        public &#13;
        view &#13;
        returns(uint256, bytes32, uint256, uint256, uint256, uint256, uint256)&#13;
    {&#13;
        // setup local rID&#13;
        uint256 _rID = rID_;&#13;
        &#13;
        if (_addr == address(0))&#13;
        {&#13;
            _addr == msg.sender;&#13;
        }&#13;
        uint256 _pID = pIDxAddr_[_addr];&#13;
        &#13;
        return&#13;
        (&#13;
            _pID,                               //0&#13;
            plyr_[_pID].name,                   //1&#13;
            plyrRnds_[_pID][_rID].keys,         //2&#13;
            plyr_[_pID].win,                    //3&#13;
            (plyr_[_pID].gen).add(calcUnMaskedEarnings(_pID, plyr_[_pID].lrnd)),       //4&#13;
            plyr_[_pID].aff,                    //5&#13;
            plyrRnds_[_pID][_rID].eth           //6&#13;
        );&#13;
    }&#13;
&#13;
//==============================================================================&#13;
//     _ _  _ _   | _  _ . _  .&#13;
//    (_(_)| (/_  |(_)(_||(_  . (this + tools + calcs + modules = our softwares engine)&#13;
//=====================_|=======================================================&#13;
    function hasPlayersInRound(uint256 _rID) private view returns (bool){&#13;
        for (uint8 i = 0; i &lt; round_[_rID].plyrs.length; i++) {&#13;
            if (round_[_rID].plyrs[i] != 0) {&#13;
                return (true);&#13;
            }&#13;
        }&#13;
        return (false);&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev logic runs whenever a buy order is executed.  determines how to handle &#13;
     * incoming eth depending on if we are in an active round or not&#13;
     */&#13;
    function buyCore(uint256 _pID, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_)&#13;
        private&#13;
    {&#13;
        // setup local rID&#13;
        uint256 _rID = rID_;&#13;
        &#13;
        // grab time&#13;
        uint256 _now = now;&#13;
        &#13;
        // if round is active&#13;
        if (_now &gt; round_[_rID].strt + rndGap_ &amp;&amp; (_now &lt;= round_[_rID].end || (_now &gt; round_[_rID].end &amp;&amp; hasPlayersInRound(_rID) == false))) &#13;
        {&#13;
            // call core &#13;
            core(_rID, _pID, msg.value, _affID, _team, _eventData_);&#13;
        &#13;
        // if round is not active&#13;
        } else {&#13;
            // check to see if end round needs to be ran&#13;
            if (_now &gt; round_[_rID].end &amp;&amp; round_[_rID].ended == false) &#13;
            {&#13;
                // end the round (distributes pot) &amp; start new round&#13;
                round_[_rID].ended = true;&#13;
                _eventData_ = endRound(_eventData_);&#13;
                &#13;
                // build event data&#13;
                _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000);&#13;
                _eventData_.compressedIDs = _eventData_.compressedIDs + _pID;&#13;
                &#13;
                // fire buy and distribute event &#13;
                emit F3Devents.onBuyAndDistribute&#13;
                (&#13;
                    msg.sender, &#13;
                    plyr_[_pID].name, &#13;
                    msg.value, &#13;
                    _eventData_.compressedData, &#13;
                    _eventData_.compressedIDs, &#13;
                    _eventData_.winnerAddr, &#13;
                    _eventData_.winnerName, &#13;
                    _eventData_.amountWon, &#13;
                    _eventData_.newPot, &#13;
                    _eventData_.P3DAmount, &#13;
                    _eventData_.genAmount&#13;
                );&#13;
            }&#13;
            &#13;
            // put eth in players vault &#13;
            plyr_[_pID].gen = plyr_[_pID].gen.add(msg.value);&#13;
        }&#13;
    }&#13;
    &#13;
    /**&#13;
     * @dev logic runs whenever a reload order is executed.  determines how to handle &#13;
     * incoming eth depending on if we are in an active round or not &#13;
     */&#13;
    function reLoadCore(uint256 _pID, uint256 _affID, uint256 _team, uint256 _eth, F3Ddatasets.EventReturns memory _eventData_)&#13;
        private&#13;
    {&#13;
        // setup local rID&#13;
        uint256 _rID = rID_;&#13;
        &#13;
        // grab time&#13;
        uint256 _now = now;&#13;
        &#13;
        // if round is active&#13;
        if (_now &gt; round_[_rID].strt + rndGap_ &amp;&amp; (_now &lt;= round_[_rID].end || (_now &gt; round_[_rID].end &amp;&amp; hasPlayersInRound(_rID) == false))) &#13;
        {&#13;
            // get earnings from all vaults and return unused to gen vault&#13;
            // because we use a custom safemath library.  this will throw if player &#13;
            // tried to spend more eth than they have.&#13;
            plyr_[_pID].gen = withdrawEarnings(_pID).sub(_eth);&#13;
            &#13;
            // call core &#13;
            core(_rID, _pID, _eth, _affID, _team, _eventData_);&#13;
        &#13;
        // if round is not active and end round needs to be ran   &#13;
        } else if (_now &gt; round_[_rID].end &amp;&amp; round_[_rID].ended == false) {&#13;
            // end the round (distributes pot) &amp; start new round&#13;
            round_[_rID].ended = true;&#13;
            _eventData_ = endRound(_eventData_);&#13;
                &#13;
            // build event data&#13;
            _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000);&#13;
            _eventData_.compressedIDs = _eventData_.compressedIDs + _pID;&#13;
                &#13;
            // fire buy and distribute event &#13;
            emit F3Devents.onReLoadAndDistribute&#13;
            (&#13;
                msg.sender, &#13;
                plyr_[_pID].name, &#13;
                _eventData_.compressedData, &#13;
                _eventData_.compressedIDs, &#13;
                _eventData_.winnerAddr, &#13;
                _eventData_.winnerName, &#13;
                _eventData_.amountWon, &#13;
                _eventData_.newPot, &#13;
                _eventData_.P3DAmount, &#13;
                _eventData_.genAmount&#13;
            );&#13;
        }&#13;
    }&#13;
    &#13;
    function contains(uint256 _pID, uint256[winnerNum_] memory array) private pure returns (bool) {&#13;
        for (uint8 i = 0; i &lt; array.length; i++) {&#13;
            if (array[i] == _pID) {&#13;
                return (true);&#13;
            }&#13;
        }&#13;
        return (false);&#13;
    }&#13;
&#13;
    function calcTotalWinnerKeys(uint256 _rID) private {&#13;
        uint256[winnerNum_] memory winnerPIDs;&#13;
        totalWinnersKeys_ = 0;&#13;
        for (uint8 i = 0; i &lt; winnerNum_; i++) {&#13;
            if (!contains(round_[_rID].plyrs[i], winnerPIDs)) {&#13;
                winnerPIDs[i] = round_[_rID].plyrs[i];&#13;
                totalWinnersKeys_ = totalWinnersKeys_.add(plyrRnds_[round_[_rID].plyrs[i]][_rID].keys);&#13;
            }&#13;
        }&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev this is the core logic for any buy/reload that happens while a round &#13;
     * is live.&#13;
     */&#13;
    function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_)&#13;
        private&#13;
    {&#13;
        // if player is new to round&#13;
        if (plyrRnds_[_pID][_rID].keys == 0)&#13;
            _eventData_ = managePlayer(_pID, _eventData_);&#13;
        &#13;
        // early round eth limiter &#13;
        if (round_[_rID].eth &lt; (100 ether) &amp;&amp; plyrRnds_[_pID][_rID].eth.add(_eth) &gt; (1 ether))&#13;
        {&#13;
            uint256 _availableLimit = (1 ether).sub(plyrRnds_[_pID][_rID].eth);&#13;
            uint256 _refund = _eth.sub(_availableLimit);&#13;
            plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);&#13;
            _eth = _availableLimit;&#13;
        }&#13;
        &#13;
        // if eth left is greater than min eth allowed (sorry no pocket lint)&#13;
        if (_eth &gt; 1000000000) &#13;
        {&#13;
            &#13;
            // mint the new keys&#13;
            uint256 _keys = (round_[_rID].eth).keysRec(_eth);&#13;
            &#13;
            // if they bought at least 1 whole key&#13;
            if (_keys &gt;= 1000000000000000000)&#13;
            {&#13;
                updateTimer(_keys, _rID);&#13;
&#13;
                // set new leaders&#13;
                round_[_rID].plyrs[0] = round_[_rID].plyrs[1];&#13;
                round_[_rID].plyrs[1] = round_[_rID].plyrs[2];&#13;
                round_[_rID].plyrs[2] = round_[_rID].plyrs[3];&#13;
                round_[_rID].plyrs[3] = round_[_rID].plyrs[4];&#13;
                round_[_rID].plyrs[4] = _pID;&#13;
                if (round_[_rID].team != _team) {&#13;
                    round_[_rID].team = _team; &#13;
                }&#13;
                &#13;
                // set the new leader bool to true&#13;
                _eventData_.compressedData = _eventData_.compressedData + 100;&#13;
            }&#13;
            &#13;
            // manage airdrops&#13;
            if (_eth &gt;= 100000000000000000)&#13;
            {&#13;
                airDropTracker_++;&#13;
                if (airdrop() == true)&#13;
                {&#13;
                    // gib muni&#13;
                    uint256 _prize;&#13;
                    if (_eth &gt;= 10000000000000000000)&#13;
                    {&#13;
                        // calculate prize and give it to winner&#13;
                        _prize = ((airDropPot_).mul(75)) / 100;&#13;
                        plyr_[_pID].win = (plyr_[_pID].win).add(_prize);&#13;
                        &#13;
                        // adjust airDropPot &#13;
                        airDropPot_ = (airDropPot_).sub(_prize);&#13;
                        &#13;
                        // let event know a tier 3 prize was won &#13;
                        _eventData_.compressedData += 300000000000000000000000000000000;&#13;
                    } else if (_eth &gt;= 1000000000000000000 &amp;&amp; _eth &lt; 10000000000000000000) {&#13;
                        // calculate prize and give it to winner&#13;
                        _prize = ((airDropPot_).mul(50)) / 100;&#13;
                        plyr_[_pID].win = (plyr_[_pID].win).add(_prize);&#13;
                        &#13;
                        // adjust airDropPot &#13;
                        airDropPot_ = (airDropPot_).sub(_prize);&#13;
                        &#13;
                        // let event know a tier 2 prize was won &#13;
                        _eventData_.compressedData += 200000000000000000000000000000000;&#13;
                    } else if (_eth &gt;= 100000000000000000 &amp;&amp; _eth &lt; 1000000000000000000) {&#13;
                        // calculate prize and give it to winner&#13;
                        _prize = ((airDropPot_).mul(25)) / 100;&#13;
                        plyr_[_pID].win = (plyr_[_pID].win).add(_prize);&#13;
                        &#13;
                        // adjust airDropPot &#13;
                        airDropPot_ = (airDropPot_).sub(_prize);&#13;
                        &#13;
                        // let event know a tier 3 prize was won &#13;
                        _eventData_.compressedData += 300000000000000000000000000000000;&#13;
                    }&#13;
                    // set airdrop happened bool to true&#13;
                    _eventData_.compressedData += 10000000000000000000000000000000;&#13;
                    // let event know how much was won &#13;
                    _eventData_.compressedData += _prize * 1000000000000000000000000000000000;&#13;
                    &#13;
                    // reset air drop tracker&#13;
                    airDropTracker_ = 0;&#13;
                }&#13;
            }&#13;
    &#13;
            // store the air drop tracker number (number of buys since last airdrop)&#13;
            _eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);&#13;
            &#13;
            // update player &#13;
            plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys);&#13;
            plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth);&#13;
            &#13;
            // update round&#13;
            round_[_rID].keys = _keys.add(round_[_rID].keys);&#13;
            round_[_rID].eth = _eth.add(round_[_rID].eth);&#13;
            rndTmEth_[_rID][_team] = _eth.add(rndTmEth_[_rID][_team]);&#13;
    &#13;
            // distribute eth&#13;
            _eventData_ = distributeExternal(_rID, _pID, _eth, _affID, _team, _eventData_);&#13;
            _eventData_ = distributeInternal(_rID, _pID, _eth, _team, _keys, _eventData_);&#13;
            &#13;
            // call end tx function to fire end tx event.&#13;
            endTx(_pID, _team, _eth, _keys, _eventData_);&#13;
        }&#13;
    }&#13;
//==============================================================================&#13;
//     _ _ | _   | _ _|_ _  _ _  .&#13;
//    (_(_||(_|_||(_| | (_)| _\  .&#13;
//==============================================================================&#13;
    /**&#13;
     * @dev calculates unmasked earnings (just calculates, does not update mask)&#13;
     * @return earnings in wei format&#13;
     */&#13;
    function calcUnMaskedEarnings(uint256 _pID, uint256 _rIDlast)&#13;
        private&#13;
        view&#13;
        returns(uint256)&#13;
    {&#13;
        return(  (((round_[_rIDlast].mask).mul(plyrRnds_[_pID][_rIDlast].keys)) / (1000000000000000000)).sub(plyrRnds_[_pID][_rIDlast].mask)  );&#13;
    }&#13;
    &#13;
    /** &#13;
     * @dev returns the amount of keys you would get given an amount of eth. &#13;
     * -functionhash- 0xce89c80c&#13;
     * @param _rID round ID you want price for&#13;
     * @param _eth amount of eth sent in &#13;
     * @return keys received &#13;
     */&#13;
    function calcKeysReceived(uint256 _rID, uint256 _eth)&#13;
        public&#13;
        view&#13;
        returns(uint256)&#13;
    {&#13;
        // grab time&#13;
        uint256 _now = now;&#13;
        &#13;
        // are we in a round?&#13;
        if (_now &gt; round_[_rID].strt + rndGap_ &amp;&amp; (_now &lt;= round_[_rID].end || (_now &gt; round_[_rID].end &amp;&amp; hasPlayersInRound(_rID) == false)))&#13;
            return ( (round_[_rID].eth).keysRec(_eth) );&#13;
        else // rounds over.  need keys for new round&#13;
            return ( (_eth).keys() );&#13;
    }&#13;
    &#13;
    /** &#13;
     * @dev returns current eth price for X keys.  &#13;
     * -functionhash- 0xcf808000&#13;
     * @param _keys number of keys desired (in 18 decimal format)&#13;
     * @return amount of eth needed to send&#13;
     */&#13;
    function iWantXKeys(uint256 _keys)&#13;
        public&#13;
        view&#13;
        returns(uint256)&#13;
    {&#13;
        // setup local rID&#13;
        uint256 _rID = rID_;&#13;
        &#13;
        // grab time&#13;
        uint256 _now = now;&#13;
        &#13;
        // are we in a round?&#13;
        if (_now &gt; round_[_rID].strt + rndGap_ &amp;&amp; (_now &lt;= round_[_rID].end || (_now &gt; round_[_rID].end &amp;&amp; hasPlayersInRound(_rID) == false)))&#13;
            return ( (round_[_rID].keys.add(_keys)).ethRec(_keys) );&#13;
        else // rounds over.  need price for new round&#13;
            return ( (_keys).eth() );&#13;
    }&#13;
//==============================================================================&#13;
//    _|_ _  _ | _  .&#13;
//     | (_)(_)|_\  .&#13;
//==============================================================================&#13;
    /**&#13;
     * @dev gets existing or registers new pID.  use this when a player may be new&#13;
     * @return pID &#13;
     */&#13;
    function determinePID(F3Ddatasets.EventReturns memory _eventData_)&#13;
        private&#13;
        returns (F3Ddatasets.EventReturns)&#13;
    {&#13;
        uint256 _pID = pIDxAddr_[msg.sender];&#13;
        // if player is new to this version of fomo3d&#13;
        if (_pID == 0)&#13;
        {&#13;
            // grab their player ID, name and last aff ID, from player names contract &#13;
            playerCount++;&#13;
            _pID = playerCount;&#13;
            bytes32 _name = plyr_[_pID].name;&#13;
            uint256 _laff = plyr_[_pID].laff;&#13;
            &#13;
            // set up player account &#13;
            pIDxAddr_[msg.sender] = _pID;&#13;
            plyr_[_pID].addr = msg.sender;&#13;
            &#13;
            if (_name != "")&#13;
            {&#13;
                pIDxName_[_name] = _pID;&#13;
                plyr_[_pID].name = _name;&#13;
            }&#13;
            &#13;
            if (_laff != 0 &amp;&amp; _laff != _pID)&#13;
                plyr_[_pID].laff = _laff;&#13;
            &#13;
            // set the new player bool to true&#13;
            _eventData_.compressedData = _eventData_.compressedData + 1;&#13;
        } &#13;
        return (_eventData_);&#13;
    }&#13;
    &#13;
    /**&#13;
     * @dev checks to make sure user picked a valid team.  if not sets team &#13;
     * to default (sneks)&#13;
     */&#13;
    function verifyTeam(uint256 _team)&#13;
        private&#13;
        pure&#13;
        returns (uint256)&#13;
    {&#13;
        if (_team &lt; 0 || _team &gt; 3)&#13;
            return(2);&#13;
        else&#13;
            return(_team);&#13;
    }&#13;
    &#13;
    /**&#13;
     * @dev decides if round end needs to be run &amp; new round started.  and if &#13;
     * player unmasked earnings from previously played rounds need to be moved.&#13;
     */&#13;
    function managePlayer(uint256 _pID, F3Ddatasets.EventReturns memory _eventData_)&#13;
        private&#13;
        returns (F3Ddatasets.EventReturns)&#13;
    {&#13;
        // if player has played a previous round, move their unmasked earnings&#13;
        // from that round to gen vault.&#13;
        if (plyr_[_pID].lrnd != 0)&#13;
            updateGenVault(_pID, plyr_[_pID].lrnd);&#13;
            &#13;
        // update player's last round played&#13;
        plyr_[_pID].lrnd = rID_;&#13;
            &#13;
        // set the joined round bool to true&#13;
        _eventData_.compressedData = _eventData_.compressedData + 10;&#13;
        &#13;
        return(_eventData_);&#13;
    }&#13;
    &#13;
    /**&#13;
     * @dev ends the round. manages paying out winner/splitting up pot&#13;
     */&#13;
    function endRound(F3Ddatasets.EventReturns memory _eventData_)&#13;
        private&#13;
        returns (F3Ddatasets.EventReturns)&#13;
    {&#13;
        // setup local rID&#13;
        uint256 _rID = rID_;&#13;
        &#13;
        // grab our winning player and team id's&#13;
        // uint256 _winPID = round_[_rID].plyrs[winnerNum_ - 1];&#13;
        // uint256 _winTID = round_[_rID].team;&#13;
        &#13;
        // grab our pot amount&#13;
        // uint256 _pot = round_[_rID].pot;&#13;
        &#13;
        // calculate our winner share, community rewards, gen share, &#13;
        // p3d share, and amount reserved for next pot &#13;
        uint256 _win = ((round_[_rID].pot).mul(48)) / 100;&#13;
        // uint256 _com = (_pot / 50);&#13;
        uint256 _gen = ((round_[_rID].pot).mul(potSplit_[round_[_rID].team].gen)) / 100;&#13;
        // uint256 _p3d = (_pot.mul(potSplit_[_winTID].p3d)) / 100;&#13;
        uint256 _fee = ((round_[_rID].pot) / 50).add(((round_[_rID].pot).mul(potSplit_[round_[_rID].team].p3d)) / 100);&#13;
        uint256 _res = ((((round_[_rID].pot).sub(_win)).sub(_fee)).sub(_gen));&#13;
        &#13;
        // calculate ppt for round mask&#13;
        uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_[_rID].keys);&#13;
        uint256 _dust = _gen.sub((_ppt.mul(round_[_rID].keys)) / 1000000000000000000);&#13;
        if (_dust &gt; 0)&#13;
        {&#13;
            _gen = _gen.sub(_dust);&#13;
            _res = _res.add(_dust);&#13;
        }&#13;
        &#13;
        calcTotalWinnerKeys(_rID);&#13;
        // pay our winner&#13;
        plyr_[round_[_rID].plyrs[winnerNum_ - 1]].win = (_win.mul(plyrRnds_[round_[_rID].plyrs[winnerNum_ - 1]][_rID].keys) / totalWinnersKeys_).add(plyr_[round_[_rID].plyrs[winnerNum_ - 1]].win);&#13;
        for (uint8 i = 0; i &lt; winnerNum_ - 1; i++) {&#13;
            plyr_[round_[_rID].plyrs[i]].win = (_win.mul(plyrRnds_[round_[_rID].plyrs[i]][_rID].keys) / totalWinnersKeys_).add(plyr_[round_[_rID].plyrs[i]].win);&#13;
        }&#13;
        &#13;
        // distribute gen portion to key holders&#13;
        round_[_rID].mask = _ppt.add(round_[_rID].mask);&#13;
        &#13;
        // send share for p3d to divies&#13;
        if (!teamAddress.send(_fee)) {&#13;
            // Nothing&#13;
        }&#13;
            &#13;
        // prepare event data&#13;
        _eventData_.compressedData = _eventData_.compressedData + (round_[_rID].end * 1000000);&#13;
        _eventData_.compressedIDs = _eventData_.compressedIDs + (round_[_rID].plyrs[winnerNum_ - 1] * 100000000000000000000000000) + (round_[_rID].team * 100000000000000000);&#13;
        _eventData_.winnerAddr = plyr_[round_[_rID].plyrs[winnerNum_ - 1]].addr;&#13;
        _eventData_.winnerName = plyr_[round_[_rID].plyrs[winnerNum_ - 1]].name;&#13;
        _eventData_.amountWon = _win;&#13;
        _eventData_.genAmount = _gen;&#13;
        _eventData_.P3DAmount = ((round_[_rID].pot).mul(potSplit_[round_[_rID].team].p3d)) / 100;&#13;
        _eventData_.newPot = _res;&#13;
        &#13;
        // start next round&#13;
        rID_++;&#13;
        _rID++;&#13;
        round_[_rID].strt = now;&#13;
        round_[_rID].end = now.add(rndInit_).add(rndGap_);&#13;
        round_[_rID].pot = _res;&#13;
        &#13;
        return(_eventData_);&#13;
    }&#13;
    &#13;
    /**&#13;
     * @dev moves any unmasked earnings to gen vault.  updates earnings mask&#13;
     */&#13;
    function updateGenVault(uint256 _pID, uint256 _rIDlast)&#13;
        private &#13;
    {&#13;
        uint256 _earnings = calcUnMaskedEarnings(_pID, _rIDlast);&#13;
        if (_earnings &gt; 0)&#13;
        {&#13;
            // put in gen vault&#13;
            plyr_[_pID].gen = _earnings.add(plyr_[_pID].gen);&#13;
            // zero out their earnings by updating mask&#13;
            plyrRnds_[_pID][_rIDlast].mask = _earnings.add(plyrRnds_[_pID][_rIDlast].mask);&#13;
        }&#13;
    }&#13;
    &#13;
    /**&#13;
     * @dev updates round timer based on number of whole keys bought.&#13;
     */&#13;
    function updateTimer(uint256 _keys, uint256 _rID)&#13;
        private&#13;
    {&#13;
        // grab time&#13;
        uint256 _now = now;&#13;
        // if (round_[_rID].end.sub(_now) &lt;= (60 seconds) &amp;&amp; hasPlayersInRound(_rID) == true) {&#13;
        //     return;&#13;
        // }&#13;
        &#13;
        // calculate time based on number of keys bought&#13;
        uint256 _newTime;&#13;
        if (_now &gt; round_[_rID].end &amp;&amp; hasPlayersInRound(_rID) == false)&#13;
            _newTime = (((_keys) / (1000000000000000000)).mul(rndInc_)).add(_now);&#13;
        else&#13;
            _newTime = (((_keys) / (1000000000000000000)).mul(rndInc_)).add(round_[_rID].end);&#13;
        &#13;
        // rndSubed_ æ ¹æ®èµééæ£åæ¶é´&#13;
        uint256 _rndEth = round_[_rID].eth; // æ¬è½®ethæ»é&#13;
        uint256 _rndNeedSub = 0; // æ¬è½®æå¤§æ¶é´éåå°çæ¶é´&#13;
        if (_rndEth &gt;= (2000 ether)) {&#13;
            if (_rndEth &lt;= (46000 ether)) { // sub hours&#13;
                _rndNeedSub = (1 hours).mul(_rndEth / (2000 ether));&#13;
            } else {&#13;
                _rndNeedSub = (1 hours).mul(23);&#13;
                uint256 _ethLeft = _rndEth.sub(46000 ether);&#13;
                if (_ethLeft &lt;= (12000 ether)) {&#13;
                    _rndNeedSub = _rndNeedSub.add((590 seconds).mul(_ethLeft / (2000 ether)));&#13;
                } else { // æåä¸åé&#13;
                    _rndNeedSub = 999;&#13;
                }&#13;
            }&#13;
        }&#13;
&#13;
        if (_rndNeedSub != 999) {&#13;
            uint256 _rndMax = rndMax_.sub(_rndNeedSub);&#13;
            // compare to max and set new end time&#13;
            if (_newTime &lt; (_rndMax).add(_now))&#13;
                round_[_rID].end = _newTime;&#13;
            else&#13;
                round_[_rID].end = _rndMax.add(_now);&#13;
        }&#13;
    }&#13;
    &#13;
    /**&#13;
     * @dev generates a random number between 0-99 and checks to see if thats&#13;
     * resulted in an airdrop win&#13;
     * @return do we have a winner?&#13;
     */&#13;
    function airdrop()&#13;
        private &#13;
        view &#13;
        returns(bool)&#13;
    {&#13;
        uint256 seed = uint256(keccak256(abi.encodePacked(&#13;
            &#13;
            (block.timestamp).add&#13;
            (block.difficulty).add&#13;
            ((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (now)).add&#13;
            (block.gaslimit).add&#13;
            ((uint256(keccak256(abi.encodePacked(msg.sender)))) / (now)).add&#13;
            (block.number)&#13;
            &#13;
        )));&#13;
        if((seed - ((seed / 1000) * 1000)) &lt; airDropTracker_)&#13;
            return(true);&#13;
        else&#13;
            return(false);&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev distributes eth based on fees to com, aff, and p3d&#13;
     */&#13;
    function distributeExternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_)&#13;
        private&#13;
        returns(F3Ddatasets.EventReturns)&#13;
    {&#13;
        // pay 2% out to community rewards&#13;
        uint256 _com = _eth / 50;&#13;
        uint256 _p3d;&#13;
        uint256 _long = _eth / 100;&#13;
        &#13;
        // distribute share to affiliate&#13;
        uint256 _aff = _eth / 10;&#13;
        &#13;
        // decide what to do with affiliate share of fees&#13;
        // affiliate must not be self, and must have a name registered&#13;
        if (_affID != _pID &amp;&amp; plyr_[_affID].name != "") {&#13;
            plyr_[_affID].aff = _aff.add(plyr_[_affID].aff);&#13;
            emit F3Devents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _rID, _pID, _aff, now);&#13;
        } else {&#13;
            _p3d = _aff;&#13;
        }&#13;
        &#13;
        _p3d = _p3d.add((_eth.mul(fees_[_team].p3d)) / (100));&#13;
        if (_p3d &gt; 0)&#13;
        {   &#13;
            // set up event data&#13;
            _eventData_.P3DAmount = _p3d.add(_eventData_.P3DAmount);&#13;
        }&#13;
&#13;
&#13;
        // deposit to divies contract&#13;
        // Divies.deposit.value(_p3d)();&#13;
        if (!teamAddress.send(_p3d.add(_com).add(_long))) {&#13;
            // Nothing&#13;
        }&#13;
        &#13;
        return(_eventData_);&#13;
    }&#13;
    &#13;
    function potSwap()&#13;
        external&#13;
        payable&#13;
    {&#13;
        // setup local rID&#13;
        uint256 _rID = rID_ + 1;&#13;
        &#13;
        round_[_rID].pot = round_[_rID].pot.add(msg.value);&#13;
        emit F3Devents.onPotSwapDeposit(_rID, msg.value);&#13;
    }&#13;
    &#13;
    /**&#13;
     * @dev distributes eth based on fees to gen and pot&#13;
     */&#13;
    function distributeInternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _team, uint256 _keys, F3Ddatasets.EventReturns memory _eventData_)&#13;
        private&#13;
        returns(F3Ddatasets.EventReturns)&#13;
    {&#13;
        // calculate gen share&#13;
        uint256 _gen = (_eth.mul(fees_[_team].gen)) / 100;&#13;
        &#13;
        // toss 1% into airdrop pot &#13;
        uint256 _air = (_eth / 100);&#13;
        airDropPot_ = airDropPot_.add(_air);&#13;
        &#13;
        // update eth balance (eth = eth - (com share + pot swap share + aff share + p3d share + airdrop pot share))&#13;
        _eth = _eth.sub(((_eth.mul(14)) / 100).add((_eth.mul(fees_[_team].p3d)) / 100));&#13;
        &#13;
        // calculate pot &#13;
        uint256 _pot = _eth.sub(_gen);&#13;
        &#13;
        // distribute gen share (thats what updateMasks() does) and adjust&#13;
        // balances for dust.&#13;
        uint256 _dust = updateMasks(_rID, _pID, _gen, _keys);&#13;
        if (_dust &gt; 0)&#13;
            _gen = _gen.sub(_dust);&#13;
        &#13;
        // add eth to pot&#13;
        round_[_rID].pot = _pot.add(_dust).add(round_[_rID].pot);&#13;
        &#13;
        // set up event data&#13;
        _eventData_.genAmount = _gen.add(_eventData_.genAmount);&#13;
        _eventData_.potAmount = _pot;&#13;
        &#13;
        return(_eventData_);&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev updates masks for round and player when keys are bought&#13;
     * @return dust left over &#13;
     */&#13;
    function updateMasks(uint256 _rID, uint256 _pID, uint256 _gen, uint256 _keys)&#13;
        private&#13;
        returns(uint256)&#13;
    {&#13;
        /* MASKING NOTES&#13;
            earnings masks are a tricky thing for people to wrap their minds around.&#13;
            the basic thing to understand here.  is were going to have a global&#13;
            tracker based on profit per share for each round, that increases in&#13;
            relevant proportion to the increase in share supply.&#13;
            &#13;
            the player will have an additional mask that basically says "based&#13;
            on the rounds mask, my shares, and how much i've already withdrawn,&#13;
            how much is still owed to me?"&#13;
        */&#13;
        &#13;
        // calc profit per key &amp; round mask based on this buy:  (dust goes to pot)&#13;
        uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_[_rID].keys);&#13;
        round_[_rID].mask = _ppt.add(round_[_rID].mask);&#13;
            &#13;
        // calculate player earning from their own buy (only based on the keys&#13;
        // they just bought).  &amp; update player earnings mask&#13;
        uint256 _pearn = (_ppt.mul(_keys)) / (1000000000000000000);&#13;
        plyrRnds_[_pID][_rID].mask = (((round_[_rID].mask.mul(_keys)) / (1000000000000000000)).sub(_pearn)).add(plyrRnds_[_pID][_rID].mask);&#13;
        &#13;
        // calculate &amp; return dust&#13;
        return(_gen.sub((_ppt.mul(round_[_rID].keys)) / (1000000000000000000)));&#13;
    }&#13;
    &#13;
    /**&#13;
     * @dev adds up unmasked earnings, &amp; vault earnings, sets them all to 0&#13;
     * @return earnings in wei format&#13;
     */&#13;
    function withdrawEarnings(uint256 _pID)&#13;
        private&#13;
        returns(uint256)&#13;
    {&#13;
        // update gen vault&#13;
        updateGenVault(_pID, plyr_[_pID].lrnd);&#13;
        &#13;
        // from vaults &#13;
        uint256 _earnings = (plyr_[_pID].win).add(plyr_[_pID].gen).add(plyr_[_pID].aff);&#13;
        if (_earnings &gt; 0)&#13;
        {&#13;
            plyr_[_pID].win = 0;&#13;
            plyr_[_pID].gen = 0;&#13;
            plyr_[_pID].aff = 0;&#13;
        }&#13;
&#13;
        return(_earnings);&#13;
    }&#13;
    &#13;
    /**&#13;
     * @dev prepares compression data and fires event for buy or reload tx's&#13;
     */&#13;
    function endTx(uint256 _pID, uint256 _team, uint256 _eth, uint256 _keys, F3Ddatasets.EventReturns memory _eventData_)&#13;
        private&#13;
    {&#13;
        _eventData_.compressedData = _eventData_.compressedData + (now * 1000000000000000000) + (_team * 100000000000000000000000000000);&#13;
        _eventData_.compressedIDs = _eventData_.compressedIDs + _pID + (rID_ * 10000000000000000000000000000000000000000000000000000);&#13;
        &#13;
        emit F3Devents.onEndTx&#13;
        (&#13;
            _eventData_.compressedData,&#13;
            _eventData_.compressedIDs,&#13;
            plyr_[_pID].name,&#13;
            msg.sender,&#13;
            _eth,&#13;
            _keys,&#13;
            _eventData_.winnerAddr,&#13;
            _eventData_.winnerName,&#13;
            _eventData_.amountWon,&#13;
            _eventData_.newPot,&#13;
            _eventData_.P3DAmount,&#13;
            _eventData_.genAmount,&#13;
            _eventData_.potAmount,&#13;
            airDropPot_&#13;
        );&#13;
    }&#13;
//==============================================================================&#13;
//    (~ _  _    _._|_    .&#13;
//    _)(/_(_|_|| | | \/  .&#13;
//====================/=========================================================&#13;
    /** upon contract deploy, it will be deactivated.  this is a one time&#13;
     * use function that will activate the contract.  we do this so devs &#13;
     * have time to set things up on the web end                            **/&#13;
    bool public activated_ = false;&#13;
    function activate()&#13;
        isOwner()&#13;
        public&#13;
    {&#13;
		// make sure that its been linked.&#13;
        // require(address(otherF3D_) != address(0), "must link to other FoMo3D first");&#13;
        &#13;
        // can only be ran once&#13;
        require(activated_ == false, "fomo3d already activated");&#13;
        &#13;
        // activate the contract &#13;
        activated_ = true;&#13;
        &#13;
        // lets start first round&#13;
        rID_ = 1;&#13;
        round_[1].strt = now + rndExtra_ - rndGap_;&#13;
        round_[1].end = now + rndInit_ + rndExtra_;&#13;
    }&#13;
}&#13;
&#13;
//==============================================================================&#13;
//   __|_ _    __|_ _  .&#13;
//  _\ | | |_|(_ | _\  .&#13;
//==============================================================================&#13;
library F3Ddatasets {&#13;
    //compressedData key&#13;
    // [76-33][32][31][30][29][28-18][17][16-6][5-3][2][1][0]&#13;
        // 0 - new player (bool)&#13;
        // 1 - joined round (bool)&#13;
        // 2 - new  leader (bool)&#13;
        // 3-5 - air drop tracker (uint 0-999)&#13;
        // 6-16 - round end time&#13;
        // 17 - winnerTeam&#13;
        // 18 - 28 timestamp &#13;
        // 29 - team&#13;
        // 30 - 0 = reinvest (round), 1 = buy (round), 2 = buy (ico), 3 = reinvest (ico)&#13;
        // 31 - airdrop happened bool&#13;
        // 32 - airdrop tier &#13;
        // 33 - airdrop amount won&#13;
    //compressedIDs key&#13;
    // [77-52][51-26][25-0]&#13;
        // 0-25 - pID &#13;
        // 26-51 - winPID&#13;
        // 52-77 - rID&#13;
    struct EventReturns {&#13;
        uint256 compressedData;&#13;
        uint256 compressedIDs;&#13;
        address winnerAddr;         // winner address&#13;
        bytes32 winnerName;         // winner name&#13;
        uint256 amountWon;          // amount won&#13;
        uint256 newPot;             // amount in new pot&#13;
        uint256 P3DAmount;          // amount distributed to p3d&#13;
        uint256 genAmount;          // amount distributed to gen&#13;
        uint256 potAmount;          // amount added to pot&#13;
    }&#13;
    struct Player {&#13;
        address addr;   // player address&#13;
        bytes32 name;   // player name&#13;
        uint256 win;    // winnings vault&#13;
        uint256 gen;    // general vault&#13;
        uint256 aff;    // affiliate vault&#13;
        uint256 lrnd;   // last round played&#13;
        uint256 laff;   // last affiliate id used&#13;
    }&#13;
    struct PlayerRounds {&#13;
        uint256 eth;    // eth player has added to round (used for eth limiter)&#13;
        uint256 keys;   // keys&#13;
        uint256 mask;   // player mask &#13;
        uint256 ico;    // ICO phase investment&#13;
    }&#13;
    struct Round {&#13;
        uint256[5] plyrs;   // pID of player in lead&#13;
        uint256 team;   // tID of team in lead&#13;
        uint256 end;    // time ends/ended&#13;
        bool ended;     // has round end function been ran&#13;
        uint256 strt;   // time round started&#13;
        uint256 keys;   // keys&#13;
        uint256 eth;    // total eth in&#13;
        uint256 pot;    // eth to pot (during round) / final amount paid to winner (after round ends)&#13;
        uint256 mask;   // global mask&#13;
        uint256 ico;    // total eth sent in during ICO phase&#13;
        uint256 icoGen; // total eth for gen during ICO phase&#13;
        uint256 icoAvg; // average key price for ICO phase&#13;
    }&#13;
    struct TeamFee {&#13;
        uint256 gen;    // % of buy in thats paid to key holders of current round&#13;
        uint256 p3d;    // % of buy in thats paid to p3d holders&#13;
    }&#13;
    struct PotSplit {&#13;
        uint256 gen;    // % of pot thats paid to key holders of current round&#13;
        uint256 p3d;    // % of pot thats paid to p3d holders&#13;
    }&#13;
}&#13;
&#13;
//==============================================================================&#13;
//  |  _      _ _ | _  .&#13;
//  |&lt;(/_\/  (_(_||(_  .&#13;
//=======/======================================================================&#13;
library F3DKeysCalcLong {&#13;
    using SafeMath for *;&#13;
    /**&#13;
     * @dev calculates number of keys received given X eth &#13;
     * @param _curEth current amount of eth in contract &#13;
     * @param _newEth eth being spent&#13;
     * @return amount of ticket purchased&#13;
     */&#13;
    function keysRec(uint256 _curEth, uint256 _newEth)&#13;
        internal&#13;
        pure&#13;
        returns (uint256)&#13;
    {&#13;
        return(keys((_curEth).add(_newEth)).sub(keys(_curEth)));&#13;
    }&#13;
    &#13;
    /**&#13;
     * @dev calculates amount of eth received if you sold X keys &#13;
     * @param _curKeys current amount of keys that exist &#13;
     * @param _sellKeys amount of keys you wish to sell&#13;
     * @return amount of eth received&#13;
     */&#13;
    function ethRec(uint256 _curKeys, uint256 _sellKeys)&#13;
        internal&#13;
        pure&#13;
        returns (uint256)&#13;
    {&#13;
        return((eth(_curKeys)).sub(eth(_curKeys.sub(_sellKeys))));&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev calculates how many keys would exist with given an amount of eth&#13;
     * @param _eth eth "in contract"&#13;
     * @return number of keys that would exist&#13;
     */&#13;
    function keys(uint256 _eth) &#13;
        internal&#13;
        pure&#13;
        returns(uint256)&#13;
    {&#13;
        return ((((((_eth).mul(1000000000000000000)).mul(312500000000000000000000000)).add(5624988281256103515625000000000000000000000000000000000000000000)).sqrt()).sub(74999921875000000000000000000000)) / (156250000);&#13;
    }&#13;
    &#13;
    /**&#13;
     * @dev calculates how much eth would be in contract given a number of keys&#13;
     * @param _keys number of keys "in contract" &#13;
     * @return eth that would exists&#13;
     */&#13;
    function eth(uint256 _keys) &#13;
        internal&#13;
        pure&#13;
        returns(uint256)  &#13;
    {&#13;
        return ((78125000).mul(_keys.sq()).add(((149999843750000).mul(_keys.mul(1000000000000000000))) / (2))) / ((1000000000000000000).sq());&#13;
    }&#13;
}&#13;
&#13;
//==============================================================================&#13;
//  . _ _|_ _  _ |` _  _ _  _  .&#13;
//  || | | (/_| ~|~(_|(_(/__\  .&#13;
//==============================================================================&#13;
&#13;
interface Fomo3dContract {&#13;
    function setOldContractData(address oldContract) external payable;&#13;
}&#13;
&#13;
/**&#13;
* @title -Name Filter- v0.1.9&#13;
* ââ¬âââââââââ¬â   â¦â¦ â¦âââââ¦â  ââââ¬ââââââââââââââââ¬ââââ&#13;
*  â ââ¤ âââ¤âââ   ââ ââââ â   âââââ¬âââ¤ âââââ¤ âââ â âââ&#13;
*  â´ ââââ´ â´â´ â´  ââââââââ â©   â´  â´ââââââââââââââ â´ âââ&#13;
*                                  _____                      _____&#13;
*                                 (, /     /)       /) /)    (, /      /)          /)&#13;
*          âââ                      /   _ (/_      // //       /  _   // _   __  _(/&#13;
*          âââ¤                  ___/___(/_/(__(_/_(/_(/_   ___/__/_)_(/_(_(_/ (_(_(_&#13;
*          â´ â´                /   /          .-/ _____   (__ /                               &#13;
*                            (__ /          (_/ (, /                                      /)â¢ &#13;
*                                                 /  __  __ __ __  _   __ __  _  _/_ _  _(/&#13;
* ââââ¬âââââââ¬ââ¬ â¬âââââ¬â                          /__/ (_(__(_)/ (_/_)_(_)/ (_(_(_(__(/_(_(_&#13;
* âââââ¬ââ â âââ ââ   â                      (__ /              .-/  Â© Jekyll Island Inc. 2018&#13;
* â´  â´âââââââ´âââââââ â´                                        (_/&#13;
*              _       __    _      ____      ____  _   _    _____  ____  ___  &#13;
*=============| |\ |  / /\  | |\/| | |_ =====| |_  | | | |    | |  | |_  | |_)==============*&#13;
*=============|_| \| /_/--\ |_|  | |_|__=====|_|   |_| |_|__  |_|  |_|__ |_| \==============*&#13;
*&#13;
* âââââââââââ¬ââ¬ââââââââââ¬â  ââââââââ¬ââââ ââââââââââââ&#13;
* â  â ââââ â ââ¬ââââ¤â   â   â  â â ââââ¤  â Inventor â&#13;
* âââââââââ â´ â´âââ´ â´âââ â´   ââââââââ´ââââ ââââââââââââ&#13;
*/&#13;
&#13;
library NameFilter {&#13;
    /**&#13;
     * @dev filters name strings&#13;
     * -converts uppercase to lower case.  &#13;
     * -makes sure it does not start/end with a space&#13;
     * -makes sure it does not contain multiple spaces in a row&#13;
     * -cannot be only numbers&#13;
     * -cannot start with 0x &#13;
     * -restricts characters to A-Z, a-z, 0-9, and space.&#13;
     * @return reprocessed string in bytes32 format&#13;
     */&#13;
    function nameFilter(string _input)&#13;
        internal&#13;
        pure&#13;
        returns(bytes32)&#13;
    {&#13;
        bytes memory _temp = bytes(_input);&#13;
        uint256 _length = _temp.length;&#13;
        &#13;
        //sorry limited to 32 characters&#13;
        require (_length &lt;= 32 &amp;&amp; _length &gt; 0, "string must be between 1 and 32 characters");&#13;
        // make sure it doesnt start with or end with space&#13;
        require(_temp[0] != 0x20 &amp;&amp; _temp[_length-1] != 0x20, "string cannot start or end with space");&#13;
        // make sure first two characters are not 0x&#13;
        if (_temp[0] == 0x30)&#13;
        {&#13;
            require(_temp[1] != 0x78, "string cannot start with 0x");&#13;
            require(_temp[1] != 0x58, "string cannot start with 0X");&#13;
        }&#13;
        &#13;
        // create a bool to track if we have a non number character&#13;
        bool _hasNonNumber;&#13;
        &#13;
        // convert &amp; check&#13;
        for (uint256 i = 0; i &lt; _length; i++)&#13;
        {&#13;
            // if its uppercase A-Z&#13;
            if (_temp[i] &gt; 0x40 &amp;&amp; _temp[i] &lt; 0x5b)&#13;
            {&#13;
                // convert to lower case a-z&#13;
                _temp[i] = byte(uint(_temp[i]) + 32);&#13;
                &#13;
                // we have a non number&#13;
                if (_hasNonNumber == false)&#13;
                    _hasNonNumber = true;&#13;
            } else {&#13;
                require&#13;
                (&#13;
                    // require character is a space&#13;
                    _temp[i] == 0x20 || &#13;
                    // OR lowercase a-z&#13;
                    (_temp[i] &gt; 0x60 &amp;&amp; _temp[i] &lt; 0x7b) ||&#13;
                    // or 0-9&#13;
                    (_temp[i] &gt; 0x2f &amp;&amp; _temp[i] &lt; 0x3a),&#13;
                    "string contains invalid characters"&#13;
                );&#13;
                // make sure theres not 2x spaces in a row&#13;
                if (_temp[i] == 0x20)&#13;
                    require( _temp[i+1] != 0x20, "string cannot contain consecutive spaces");&#13;
                &#13;
                // see if we have a character other than a number&#13;
                if (_hasNonNumber == false &amp;&amp; (_temp[i] &lt; 0x30 || _temp[i] &gt; 0x39))&#13;
                    _hasNonNumber = true;    &#13;
            }&#13;
        }&#13;
        &#13;
        require(_hasNonNumber == true, "string cannot be only numbers");&#13;
        &#13;
        bytes32 _ret;&#13;
        assembly {&#13;
            _ret := mload(add(_temp, 32))&#13;
        }&#13;
        return (_ret);&#13;
    }&#13;
}&#13;
&#13;
/**&#13;
 * @title SafeMath v0.1.9&#13;
 * @dev Math operations with safety checks that throw on error&#13;
 * change notes:  original SafeMath library from OpenZeppelin modified by Inventor&#13;
 * - added sqrt&#13;
 * - added sq&#13;
 * - added pwr &#13;
 * - changed asserts to requires with error log outputs&#13;
 * - removed div, its useless&#13;
 */&#13;
library SafeMath {&#13;
    &#13;
    /**&#13;
    * @dev Multiplies two numbers, throws on overflow.&#13;
    */&#13;
    function mul(uint256 a, uint256 b) &#13;
        internal &#13;
        pure &#13;
        returns (uint256 c) &#13;
    {&#13;
        if (a == 0) {&#13;
            return 0;&#13;
        }&#13;
        c = a * b;&#13;
        require(c / a == b, "SafeMath mul failed");&#13;
        return c;&#13;
    }&#13;
&#13;
    /**&#13;
    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).&#13;
    */&#13;
    function sub(uint256 a, uint256 b)&#13;
        internal&#13;
        pure&#13;
        returns (uint256) &#13;
    {&#13;
        require(b &lt;= a, "SafeMath sub failed");&#13;
        return a - b;&#13;
    }&#13;
&#13;
    /**&#13;
    * @dev Adds two numbers, throws on overflow.&#13;
    */&#13;
    function add(uint256 a, uint256 b)&#13;
        internal&#13;
        pure&#13;
        returns (uint256 c) &#13;
    {&#13;
        c = a + b;&#13;
        require(c &gt;= a, "SafeMath add failed");&#13;
        return c;&#13;
    }&#13;
    &#13;
    /**&#13;
     * @dev gives square root of given x.&#13;
     */&#13;
    function sqrt(uint256 x)&#13;
        internal&#13;
        pure&#13;
        returns (uint256 y) &#13;
    {&#13;
        uint256 z = ((add(x,1)) / 2);&#13;
        y = x;&#13;
        while (z &lt; y) &#13;
        {&#13;
            y = z;&#13;
            z = ((add((x / z),z)) / 2);&#13;
        }&#13;
    }&#13;
    &#13;
    /**&#13;
     * @dev gives square. multiplies x by x&#13;
     */&#13;
    function sq(uint256 x)&#13;
        internal&#13;
        pure&#13;
        returns (uint256)&#13;
    {&#13;
        return (mul(x,x));&#13;
    }&#13;
    &#13;
    /**&#13;
     * @dev x to the power of y &#13;
     */&#13;
    function pwr(uint256 x, uint256 y)&#13;
        internal &#13;
        pure &#13;
        returns (uint256)&#13;
    {&#13;
        if (x==0)&#13;
            return (0);&#13;
        else if (y==0)&#13;
            return (1);&#13;
        else &#13;
        {&#13;
            uint256 z = x;&#13;
            for (uint256 i=1; i &lt; y; i++)&#13;
                z = mul(z,x);&#13;
            return (z);&#13;
        }&#13;
    }&#13;
}