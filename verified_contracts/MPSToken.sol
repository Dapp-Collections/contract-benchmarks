/**
 * MPSToken.sol
 * MPS Token (Mt Pelerin Share)

 * More info about MPS : https://github.com/MtPelerin/MtPelerin-share-MPS

 * The unflattened code is available through this github tag:
 * https://github.com/MtPelerin/MtPelerin-protocol/tree/etherscan-verify-batch-1

 * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved

 * @notice All matters regarding the intellectual property of this code 
 * @notice or software are subject to Swiss Law without reference to its 
 * @notice conflicts of law rules.

 * @notice License for each contract is available in the respective file
 * @notice or in the LICENSE.md file.
 * @notice https://github.com/MtPelerin/

 * @notice Code by OpenZeppelin is copyrighted and licensed on their repository:
 * @notice https://github.com/OpenZeppelin/openzeppelin-solidity
 */

pragma solidity ^0.4.24;

// File: contracts/zeppelin/token/ERC20/ERC20Basic.sol

/**
 * @title ERC20Basic
 * @dev Simpler version of ERC20 interface
 * @dev see https://github.com/ethereum/EIPs/issues/179
 */
contract ERC20Basic {
  function totalSupply() public view returns (uint256);
  function balanceOf(address who) public view returns (uint256);
  function transfer(address to, uint256 value) public returns (bool);
  event Transfer(address indexed from, address indexed to, uint256 value);
}

// File: contracts/zeppelin/math/SafeMath.sol

/**
 * @title SafeMath
 * @dev Math operations with safety checks that throw on error
 */
library SafeMath {

  /**
  * @dev Multiplies two numbers, throws on overflow.
  */
  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {
    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the
    // benefit is lost if 'b' is also tested.
    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
    if (a == 0) {
      return 0;
    }

    c = a * b;
    assert(c / a == b);
    return c;
  }

  /**
  * @dev Integer division of two numbers, truncating the quotient.
  */
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    // assert(b > 0); // Solidity automatically throws when dividing by 0
    // uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return a / b;
  }

  /**
  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).
  */
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  /**
  * @dev Adds two numbers, throws on overflow.
  */
  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
    c = a + b;
    assert(c >= a);
    return c;
  }
}

// File: contracts/zeppelin/token/ERC20/BasicToken.sol

/**
 * @title Basic token
 * @dev Basic version of StandardToken, with no allowances.
 */
contract BasicToken is ERC20Basic {
  using SafeMath for uint256;

  mapping(address => uint256) balances;

  uint256 totalSupply_;

  /**
  * @dev total number of tokens in existence
  */
  function totalSupply() public view returns (uint256) {
    return totalSupply_;
  }

  /**
  * @dev transfer token for a specified address
  * @param _to The address to transfer to.
  * @param _value The amount to be transferred.
  */
  function transfer(address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    require(_value <= balances[msg.sender]);

    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    emit Transfer(msg.sender, _to, _value);
    return true;
  }

  /**
  * @dev Gets the balance of the specified address.
  * @param _owner The address to query the the balance of.
  * @return An uint256 representing the amount owned by the passed address.
  */
  function balanceOf(address _owner) public view returns (uint256) {
    return balances[_owner];
  }

}

// File: contracts/interface/ISeizable.sol

/**
 * @title ISeizable
 * @dev ISeizable interface
 * @author Cyril Lapinte - <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="14776d667d783a7875647d7a607154796064717871667d7a3a777b79">[email protected]</a>&gt;&#13;
 *&#13;
 * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved&#13;
 * @notice Please refer to the top of this file for the license.&#13;
 **/&#13;
contract ISeizable {&#13;
  function seize(address _account, uint256 _value) public;&#13;
  event Seize(address account, uint256 amount);&#13;
}&#13;
&#13;
// File: contracts/zeppelin/ownership/Ownable.sol&#13;
&#13;
/**&#13;
 * @title Ownable&#13;
 * @dev The Ownable contract has an owner address, and provides basic authorization control&#13;
 * functions, this simplifies the implementation of "user permissions".&#13;
 */&#13;
contract Ownable {&#13;
  address public owner;&#13;
&#13;
&#13;
  event OwnershipRenounced(address indexed previousOwner);&#13;
  event OwnershipTransferred(&#13;
    address indexed previousOwner,&#13;
    address indexed newOwner&#13;
  );&#13;
&#13;
&#13;
  /**&#13;
   * @dev The Ownable constructor sets the original `owner` of the contract to the sender&#13;
   * account.&#13;
   */&#13;
  constructor() public {&#13;
    owner = msg.sender;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Throws if called by any account other than the owner.&#13;
   */&#13;
  modifier onlyOwner() {&#13;
    require(msg.sender == owner);&#13;
    _;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Allows the current owner to relinquish control of the contract.&#13;
   */&#13;
  function renounceOwnership() public onlyOwner {&#13;
    emit OwnershipRenounced(owner);&#13;
    owner = address(0);&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Allows the current owner to transfer control of the contract to a newOwner.&#13;
   * @param _newOwner The address to transfer ownership to.&#13;
   */&#13;
  function transferOwnership(address _newOwner) public onlyOwner {&#13;
    _transferOwnership(_newOwner);&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Transfers control of the contract to a newOwner.&#13;
   * @param _newOwner The address to transfer ownership to.&#13;
   */&#13;
  function _transferOwnership(address _newOwner) internal {&#13;
    require(_newOwner != address(0));&#13;
    emit OwnershipTransferred(owner, _newOwner);&#13;
    owner = _newOwner;&#13;
  }&#13;
}&#13;
&#13;
// File: contracts/Authority.sol&#13;
&#13;
/**&#13;
 * @title Authority&#13;
 * @dev The Authority contract has an authority address, and provides basic authorization control&#13;
 * functions, this simplifies the implementation of "user permissions".&#13;
 * Authority means to represent a legal entity that is entitled to specific rights&#13;
 *&#13;
 * @author Cyril Lapinte - &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="ef8c969d8683c1838e9f86819b8aaf829b9f8a838a9d8681c18c8082">[email protected]</a>&gt;&#13;
 *&#13;
 * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved&#13;
 * @notice Please refer to the top of this file for the license.&#13;
 *&#13;
 * Error messages&#13;
 * AU01: Message sender must be an authority&#13;
 */&#13;
contract Authority is Ownable {&#13;
&#13;
  address authority;&#13;
&#13;
  /**&#13;
   * @dev Throws if called by any account other than the authority.&#13;
   */&#13;
  modifier onlyAuthority {&#13;
    require(msg.sender == authority, "AU01");&#13;
    _;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev return the address associated to the authority&#13;
   */&#13;
  function authorityAddress() public view returns (address) {&#13;
    return authority;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev rdefines an authority&#13;
   * @param _name the authority name&#13;
   * @param _address the authority address.&#13;
   */&#13;
  function defineAuthority(string _name, address _address) public onlyOwner {&#13;
    emit AuthorityDefined(_name, _address);&#13;
    authority = _address;&#13;
  }&#13;
&#13;
  event AuthorityDefined(&#13;
    string name,&#13;
    address _address&#13;
  );&#13;
}&#13;
&#13;
// File: contracts/token/component/SeizableToken.sol&#13;
&#13;
/**&#13;
 * @title SeizableToken&#13;
 * @dev BasicToken contract which allows owner to seize accounts&#13;
 * @author Cyril Lapinte - &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="82e1fbf0ebeeaceee3f2ebecf6e7c2eff6f2e7eee7f0ebecace1edef">[email protected]</a>&gt;&#13;
 *&#13;
 * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved&#13;
 * @notice Please refer to the top of this file for the license.&#13;
 *&#13;
 * Error messages&#13;
 * ST01: Owner cannot seize itself&#13;
*/&#13;
contract SeizableToken is BasicToken, Authority, ISeizable {&#13;
  using SafeMath for uint256;&#13;
&#13;
  // Although very unlikely, the value below may overflow.&#13;
  // This contract and its children should expect it to happened and consider&#13;
  // this value as only the first 256 bits of the complete value.&#13;
  uint256 public allTimeSeized = 0; // overflow may happend&#13;
&#13;
  /**&#13;
   * @dev called by the owner to seize value from the account&#13;
   */&#13;
  function seize(address _account, uint256 _value)&#13;
    public onlyAuthority&#13;
  {&#13;
    require(_account != owner, "ST01");&#13;
&#13;
    balances[_account] = balances[_account].sub(_value);&#13;
    balances[authority] = balances[authority].add(_value);&#13;
&#13;
    allTimeSeized += _value;&#13;
    emit Seize(_account, _value);&#13;
  }&#13;
}&#13;
&#13;
// File: contracts/zeppelin/token/ERC20/ERC20.sol&#13;
&#13;
/**&#13;
 * @title ERC20 interface&#13;
 * @dev see https://github.com/ethereum/EIPs/issues/20&#13;
 */&#13;
contract ERC20 is ERC20Basic {&#13;
  function allowance(address owner, address spender)&#13;
    public view returns (uint256);&#13;
&#13;
  function transferFrom(address from, address to, uint256 value)&#13;
    public returns (bool);&#13;
&#13;
  function approve(address spender, uint256 value) public returns (bool);&#13;
  event Approval(&#13;
    address indexed owner,&#13;
    address indexed spender,&#13;
    uint256 value&#13;
  );&#13;
}&#13;
&#13;
// File: contracts/zeppelin/token/ERC20/StandardToken.sol&#13;
&#13;
/**&#13;
 * @title Standard ERC20 token&#13;
 *&#13;
 * @dev Implementation of the basic standard token.&#13;
 * @dev https://github.com/ethereum/EIPs/issues/20&#13;
 * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol&#13;
 */&#13;
contract StandardToken is ERC20, BasicToken {&#13;
&#13;
  mapping (address =&gt; mapping (address =&gt; uint256)) internal allowed;&#13;
&#13;
&#13;
  /**&#13;
   * @dev Transfer tokens from one address to another&#13;
   * @param _from address The address which you want to send tokens from&#13;
   * @param _to address The address which you want to transfer to&#13;
   * @param _value uint256 the amount of tokens to be transferred&#13;
   */&#13;
  function transferFrom(&#13;
    address _from,&#13;
    address _to,&#13;
    uint256 _value&#13;
  )&#13;
    public&#13;
    returns (bool)&#13;
  {&#13;
    require(_to != address(0));&#13;
    require(_value &lt;= balances[_from]);&#13;
    require(_value &lt;= allowed[_from][msg.sender]);&#13;
&#13;
    balances[_from] = balances[_from].sub(_value);&#13;
    balances[_to] = balances[_to].add(_value);&#13;
    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);&#13;
    emit Transfer(_from, _to, _value);&#13;
    return true;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.&#13;
   *&#13;
   * Beware that changing an allowance with this method brings the risk that someone may use both the old&#13;
   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this&#13;
   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:&#13;
   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729&#13;
   * @param _spender The address which will spend the funds.&#13;
   * @param _value The amount of tokens to be spent.&#13;
   */&#13;
  function approve(address _spender, uint256 _value) public returns (bool) {&#13;
    allowed[msg.sender][_spender] = _value;&#13;
    emit Approval(msg.sender, _spender, _value);&#13;
    return true;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Function to check the amount of tokens that an owner allowed to a spender.&#13;
   * @param _owner address The address which owns the funds.&#13;
   * @param _spender address The address which will spend the funds.&#13;
   * @return A uint256 specifying the amount of tokens still available for the spender.&#13;
   */&#13;
  function allowance(&#13;
    address _owner,&#13;
    address _spender&#13;
   )&#13;
    public&#13;
    view&#13;
    returns (uint256)&#13;
  {&#13;
    return allowed[_owner][_spender];&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Increase the amount of tokens that an owner allowed to a spender.&#13;
   *&#13;
   * approve should be called when allowed[_spender] == 0. To increment&#13;
   * allowed value is better to use this function to avoid 2 calls (and wait until&#13;
   * the first transaction is mined)&#13;
   * From MonolithDAO Token.sol&#13;
   * @param _spender The address which will spend the funds.&#13;
   * @param _addedValue The amount of tokens to increase the allowance by.&#13;
   */&#13;
  function increaseApproval(&#13;
    address _spender,&#13;
    uint _addedValue&#13;
  )&#13;
    public&#13;
    returns (bool)&#13;
  {&#13;
    allowed[msg.sender][_spender] = (&#13;
      allowed[msg.sender][_spender].add(_addedValue));&#13;
    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);&#13;
    return true;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Decrease the amount of tokens that an owner allowed to a spender.&#13;
   *&#13;
   * approve should be called when allowed[_spender] == 0. To decrement&#13;
   * allowed value is better to use this function to avoid 2 calls (and wait until&#13;
   * the first transaction is mined)&#13;
   * From MonolithDAO Token.sol&#13;
   * @param _spender The address which will spend the funds.&#13;
   * @param _subtractedValue The amount of tokens to decrease the allowance by.&#13;
   */&#13;
  function decreaseApproval(&#13;
    address _spender,&#13;
    uint _subtractedValue&#13;
  )&#13;
    public&#13;
    returns (bool)&#13;
  {&#13;
    uint oldValue = allowed[msg.sender][_spender];&#13;
    if (_subtractedValue &gt; oldValue) {&#13;
      allowed[msg.sender][_spender] = 0;&#13;
    } else {&#13;
      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);&#13;
    }&#13;
    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);&#13;
    return true;&#13;
  }&#13;
&#13;
}&#13;
&#13;
// File: contracts/interface/IProvableOwnership.sol&#13;
&#13;
/**&#13;
 * @title IProvableOwnership&#13;
 * @dev IProvableOwnership interface which describe proof of ownership.&#13;
 * @author Cyril Lapinte - &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="1c7f656e757032707d6c757268795c71686c7970796e7572327f7371">[email protected]</a>&gt;&#13;
 *&#13;
 * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved&#13;
 * @notice Please refer to the top of this file for the license.&#13;
 **/&#13;
contract IProvableOwnership {&#13;
  function proofLength(address _holder) public view returns (uint256);&#13;
  function proofAmount(address _holder, uint256 _proofId)&#13;
    public view returns (uint256);&#13;
&#13;
  function proofDateFrom(address _holder, uint256 _proofId)&#13;
    public view returns (uint256);&#13;
&#13;
  function proofDateTo(address _holder, uint256 _proofId)&#13;
    public view returns (uint256);&#13;
&#13;
  function createProof(address _holder) public;&#13;
  function checkProof(address _holder, uint256 _proofId, uint256 _at)&#13;
    public view returns (uint256);&#13;
&#13;
  function transferWithProofs(&#13;
    address _to,&#13;
    uint256 _value,&#13;
    bool _proofFrom,&#13;
    bool _proofTo&#13;
    ) public returns (bool);&#13;
&#13;
  function transferFromWithProofs(&#13;
    address _from,&#13;
    address _to,&#13;
    uint256 _value,&#13;
    bool _proofFrom,&#13;
    bool _proofTo&#13;
    ) public returns (bool);&#13;
&#13;
  event ProofOfOwnership(address indexed holder, uint256 proofId);&#13;
}&#13;
&#13;
// File: contracts/interface/IAuditableToken.sol&#13;
&#13;
/**&#13;
 * @title IAuditableToken&#13;
 * @dev IAuditableToken interface describing the audited data&#13;
 * @author Cyril Lapinte - &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="ea8993988386c4868b9a83849e8faa879e9a8f868f988384c4898587">[email protected]</a>&gt;&#13;
 *&#13;
 * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved&#13;
 * @notice Please refer to the top of this file for the license.&#13;
 **/&#13;
contract IAuditableToken {&#13;
  function lastTransactionAt(address _address) public view returns (uint256);&#13;
  function lastReceivedAt(address _address) public view returns (uint256);&#13;
  function lastSentAt(address _address) public view returns (uint256);&#13;
  function transactionCount(address _address) public view returns (uint256);&#13;
  function receivedCount(address _address) public view returns (uint256);&#13;
  function sentCount(address _address) public view returns (uint256);&#13;
  function totalReceivedAmount(address _address) public view returns (uint256);&#13;
  function totalSentAmount(address _address) public view returns (uint256);&#13;
}&#13;
&#13;
// File: contracts/token/component/AuditableToken.sol&#13;
&#13;
/**&#13;
 * @title AuditableToken&#13;
 * @dev AuditableToken contract&#13;
 * AuditableToken provides transaction data which can be used&#13;
 * in other smart contracts&#13;
 *&#13;
 * @author Cyril Lapinte - &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="bcdfc5ced5d092d0ddccd5d2c8d9fcd1c8ccd9d0d9ced5d292dfd3d1">[email protected]</a>&gt;&#13;
 *&#13;
 * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved&#13;
 * @notice Please refer to the top of this file for the license.&#13;
 **/&#13;
contract AuditableToken is IAuditableToken, StandardToken {&#13;
&#13;
   // Although very unlikely, the following values below may overflow:&#13;
   //   receivedCount, sentCount, totalReceivedAmount, totalSentAmount&#13;
   // This contract and its children should expect it to happen and consider&#13;
   // these values as only the first 256 bits of the complete value.&#13;
  struct Audit {&#13;
    uint256 createdAt;&#13;
    uint256 lastReceivedAt;&#13;
    uint256 lastSentAt;&#13;
    uint256 receivedCount; // potential overflow&#13;
    uint256 sentCount; // poential overflow&#13;
    uint256 totalReceivedAmount; // potential overflow&#13;
    uint256 totalSentAmount; // potential overflow&#13;
  }&#13;
  mapping(address =&gt; Audit) internal audits;&#13;
&#13;
  /**&#13;
   * @dev Time of the creation of the audit struct&#13;
   */&#13;
  function auditCreatedAt(address _address) public view returns (uint256) {&#13;
    return audits[_address].createdAt;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Time of the last transaction&#13;
   */&#13;
  function lastTransactionAt(address _address) public view returns (uint256) {&#13;
    return ( audits[_address].lastReceivedAt &gt; audits[_address].lastSentAt ) ?&#13;
      audits[_address].lastReceivedAt : audits[_address].lastSentAt;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Time of the last received transaction&#13;
   */&#13;
  function lastReceivedAt(address _address) public view returns (uint256) {&#13;
    return audits[_address].lastReceivedAt;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Time of the last sent transaction&#13;
   */&#13;
  function lastSentAt(address _address) public view returns (uint256) {&#13;
    return audits[_address].lastSentAt;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Count of transactions&#13;
   */&#13;
  function transactionCount(address _address) public view returns (uint256) {&#13;
    return audits[_address].receivedCount + audits[_address].sentCount;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Count of received transactions&#13;
   */&#13;
  function receivedCount(address _address) public view returns (uint256) {&#13;
    return audits[_address].receivedCount;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Count of sent transactions&#13;
   */&#13;
  function sentCount(address _address) public view returns (uint256) {&#13;
    return audits[_address].sentCount;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev All time received&#13;
   */&#13;
  function totalReceivedAmount(address _address)&#13;
    public view returns (uint256)&#13;
  {&#13;
    return audits[_address].totalReceivedAmount;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev All time sent&#13;
   */&#13;
  function totalSentAmount(address _address) public view returns (uint256) {&#13;
    return audits[_address].totalSentAmount;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Overriden transfer function&#13;
   */&#13;
  function transfer(address _to, uint256 _value) public returns (bool) {&#13;
    if (!super.transfer(_to, _value)) {&#13;
      return false;&#13;
    }&#13;
    updateAudit(msg.sender, _to, _value);&#13;
    return true;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Overriden transferFrom function&#13;
   */&#13;
  function transferFrom(address _from, address _to, uint256 _value)&#13;
    public returns (bool)&#13;
  {&#13;
    if (!super.transferFrom(_from, _to, _value)) {&#13;
      return false;&#13;
    }&#13;
&#13;
    updateAudit(_from, _to, _value);&#13;
    return true;&#13;
  }&#13;
&#13;
 /**&#13;
   * @dev currentTime()&#13;
   */&#13;
  function currentTime() internal view returns (uint256) {&#13;
    // solium-disable-next-line security/no-block-members&#13;
    return now;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Update audit data&#13;
   */&#13;
  function updateAudit(address _sender, address _receiver, uint256 _value)&#13;
    private returns (uint256)&#13;
  {&#13;
    Audit storage senderAudit = audits[_sender];&#13;
    senderAudit.lastSentAt = currentTime();&#13;
    senderAudit.sentCount++;&#13;
    senderAudit.totalSentAmount += _value;&#13;
    if (senderAudit.createdAt == 0) {&#13;
      senderAudit.createdAt = currentTime();&#13;
    }&#13;
&#13;
    Audit storage receiverAudit = audits[_receiver];&#13;
    receiverAudit.lastReceivedAt = currentTime();&#13;
    receiverAudit.receivedCount++;&#13;
    receiverAudit.totalReceivedAmount += _value;&#13;
    if (receiverAudit.createdAt == 0) {&#13;
      receiverAudit.createdAt = currentTime();&#13;
    }&#13;
  }&#13;
}&#13;
&#13;
// File: contracts/token/component/ProvableOwnershipToken.sol&#13;
&#13;
/**&#13;
 * @title ProvableOwnershipToken&#13;
 * @dev ProvableOwnershipToken is a StandardToken&#13;
 * with ability to record a proof of ownership&#13;
 *&#13;
 * When desired a proof of ownership can be generated.&#13;
 * The proof is stored within the contract.&#13;
 * A proofId is then returned.&#13;
 * The proof can later be used to retrieve the amount needed.&#13;
 *&#13;
 * @author Cyril Lapinte - &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="1f7c666d767331737e6f76716b7a5f726b6f7a737a6d7671317c7072">[email protected]</a>&gt;&#13;
 *&#13;
 * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved&#13;
 * @notice Please refer to the top of this file for the license.&#13;
 **/&#13;
contract ProvableOwnershipToken is IProvableOwnership, AuditableToken, Ownable {&#13;
  struct Proof {&#13;
    uint256 amount;&#13;
    uint256 dateFrom;&#13;
    uint256 dateTo;&#13;
  }&#13;
  mapping(address =&gt; mapping(uint256 =&gt; Proof)) internal proofs;&#13;
  mapping(address =&gt; uint256) internal proofLengths;&#13;
&#13;
  /**&#13;
   * @dev number of proof stored in the contract&#13;
   */&#13;
  function proofLength(address _holder) public view returns (uint256) {&#13;
    return proofLengths[_holder];&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev amount contains for the proofId reccord&#13;
   */&#13;
  function proofAmount(address _holder, uint256 _proofId)&#13;
    public view returns (uint256)&#13;
  {&#13;
    return proofs[_holder][_proofId].amount;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev date from which the proof is valid&#13;
   */&#13;
  function proofDateFrom(address _holder, uint256 _proofId)&#13;
    public view returns (uint256)&#13;
  {&#13;
    return proofs[_holder][_proofId].dateFrom;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev date until the proof is valid&#13;
   */&#13;
  function proofDateTo(address _holder, uint256 _proofId)&#13;
    public view returns (uint256)&#13;
  {&#13;
    return proofs[_holder][_proofId].dateTo;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev called to challenge a proof at a point in the past&#13;
   * Return the amount tokens owned by the proof owner at that time&#13;
   */&#13;
  function checkProof(address _holder, uint256 _proofId, uint256 _at)&#13;
    public view returns (uint256)&#13;
  {&#13;
    if (_proofId &lt; proofLengths[_holder]) {&#13;
      Proof storage proof = proofs[_holder][_proofId];&#13;
&#13;
      if (proof.dateFrom &lt;= _at &amp;&amp; _at &lt;= proof.dateTo) {&#13;
        return proof.amount;&#13;
      }&#13;
    }&#13;
    return 0;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev called to create a proof of token ownership&#13;
   */&#13;
  function createProof(address _holder) public {&#13;
    createProofInternal(&#13;
      _holder,&#13;
      balanceOf(_holder),&#13;
      lastTransactionAt(_holder)&#13;
    );&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev transfer function with also create a proof of ownership to any of the participants&#13;
   * @param _proofSender if true a proof will be created for the sender&#13;
   * @param _proofReceiver if true a proof will be created for the receiver&#13;
   */&#13;
  function transferWithProofs(&#13;
    address _to,&#13;
    uint256 _value,&#13;
    bool _proofSender,&#13;
    bool _proofReceiver&#13;
  ) public returns (bool)&#13;
  {&#13;
    uint256 balanceBeforeFrom = balanceOf(msg.sender);&#13;
    uint256 beforeFrom = lastTransactionAt(msg.sender);&#13;
    uint256 balanceBeforeTo = balanceOf(_to);&#13;
    uint256 beforeTo = lastTransactionAt(_to);&#13;
&#13;
    if (!super.transfer(_to, _value)) {&#13;
      return false;&#13;
    }&#13;
&#13;
    transferPostProcessing(&#13;
      msg.sender,&#13;
      balanceBeforeFrom,&#13;
      beforeFrom,&#13;
      _proofSender&#13;
    );&#13;
    transferPostProcessing(&#13;
      _to,&#13;
      balanceBeforeTo,&#13;
      beforeTo,&#13;
      _proofReceiver&#13;
    );&#13;
    return true;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev transfer function with also create a proof of ownership to any of the participants&#13;
   * @param _proofSender if true a proof will be created for the sender&#13;
   * @param _proofReceiver if true a proof will be created for the receiver&#13;
   */&#13;
  function transferFromWithProofs(&#13;
    address _from,&#13;
    address _to, &#13;
    uint256 _value,&#13;
    bool _proofSender, bool _proofReceiver)&#13;
    public returns (bool)&#13;
  {&#13;
    uint256 balanceBeforeFrom = balanceOf(_from);&#13;
    uint256 beforeFrom = lastTransactionAt(_from);&#13;
    uint256 balanceBeforeTo = balanceOf(_to);&#13;
    uint256 beforeTo = lastTransactionAt(_to);&#13;
&#13;
    if (!super.transferFrom(_from, _to, _value)) {&#13;
      return false;&#13;
    }&#13;
&#13;
    transferPostProcessing(&#13;
      _from,&#13;
      balanceBeforeFrom,&#13;
      beforeFrom,&#13;
      _proofSender&#13;
    );&#13;
    transferPostProcessing(&#13;
      _to,&#13;
      balanceBeforeTo,&#13;
      beforeTo,&#13;
      _proofReceiver&#13;
    );&#13;
    return true;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev can be used to force create a proof (with a fake amount potentially !)&#13;
   * Only usable by child contract internaly&#13;
   */&#13;
  function createProofInternal(&#13;
    address _holder, uint256 _amount, uint256 _from) internal&#13;
  {&#13;
    uint proofId = proofLengths[_holder];&#13;
    // solium-disable-next-line security/no-block-members&#13;
    proofs[_holder][proofId] = Proof(_amount, _from, currentTime());&#13;
    proofLengths[_holder] = proofId+1;&#13;
    emit ProofOfOwnership(_holder, proofId);&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev private function updating contract state after a transfer operation&#13;
   */&#13;
  function transferPostProcessing(&#13;
    address _holder,&#13;
    uint256 _balanceBefore,&#13;
    uint256 _before,&#13;
    bool _proof) private&#13;
  {&#13;
    if (_proof) {&#13;
      createProofInternal(_holder, _balanceBefore, _before);&#13;
    }&#13;
  }&#13;
&#13;
  event ProofOfOwnership(address indexed holder, uint256 proofId);&#13;
}&#13;
&#13;
// File: contracts/interface/IClaimable.sol&#13;
&#13;
/**&#13;
 * @title IClaimable&#13;
 * @dev IClaimable interface&#13;
 * @author Cyril Lapinte - &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="54372d263d387a3835243d3a203114392024313831263d3a7a373b39">[email protected]</a>&gt;&#13;
 *&#13;
 * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved&#13;
 * @notice Please refer to the top of this file for the license.&#13;
 **/&#13;
interface IClaimable {&#13;
  function hasClaimsSince(address _address, uint256 at)&#13;
    external view returns (bool);&#13;
}&#13;
&#13;
// File: contracts/interface/IWithClaims.sol&#13;
&#13;
/**&#13;
 * @title IWithClaims&#13;
 * @dev IWithClaims interface&#13;
 * @author Cyril Lapinte - &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="6d0e141f040143010c1d040319082d00191d0801081f0403430e0200">[email protected]</a>&gt;&#13;
 *&#13;
 * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved&#13;
 * @notice Please refer to the top of this file for the license.&#13;
 **/&#13;
contract IWithClaims {&#13;
  function claimableLength() public view returns (uint256);&#13;
  function claimable(uint256 _claimableId) public view returns (IClaimable);&#13;
  function hasClaims(address _holder) public view returns (bool);&#13;
  function defineClaimables(IClaimable[] _claimables) public;&#13;
&#13;
  event ClaimablesDefined(uint256 count);&#13;
}&#13;
&#13;
// File: contracts/token/component/TokenWithClaims.sol&#13;
&#13;
/**&#13;
 * @title TokenWithClaims&#13;
 * @dev TokenWithClaims contract&#13;
 * TokenWithClaims is a token that will create a&#13;
 * proofOfOwnership during transfers if a claim can be made.&#13;
 * Holder may ask for the claim later using the proofOfOwnership&#13;
 * @author Cyril Lapinte - &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="4e2d373c272260222f3e27203a2b0e233a3e2b222b3c2720602d2123">[email protected]</a>&gt;&#13;
 *&#13;
 * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved&#13;
 * @notice Please refer to the top of this file for the license.&#13;
 *&#13;
 * Error messages&#13;
 * E01: Claimable address must be defined&#13;
 * E02: Claimables parameter must not be empty&#13;
 * E03: Claimable does not exist&#13;
**/&#13;
contract TokenWithClaims is IWithClaims, ProvableOwnershipToken {&#13;
&#13;
  IClaimable[] claimables;&#13;
&#13;
  /**&#13;
   * @dev Constructor&#13;
   */&#13;
  constructor(IClaimable[] _claimables) public {&#13;
    claimables = _claimables;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Returns the number of claimables&#13;
   */&#13;
  function claimableLength() public view returns (uint256) {&#13;
    return claimables.length;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Returns the Claimable associated to the specified claimableId&#13;
   */&#13;
  function claimable(uint256 _claimableId) public view returns (IClaimable) {&#13;
    return claimables[_claimableId];&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Returns true if there are any claims associated to this token&#13;
   * to be made at this time for the _holder&#13;
   */&#13;
  function hasClaims(address _holder) public view returns (bool) {&#13;
    uint256 lastTransaction = lastTransactionAt(_holder);&#13;
    for (uint256 i = 0; i &lt; claimables.length; i++) {&#13;
      if (claimables[i].hasClaimsSince(_holder, lastTransaction)) {&#13;
        return true;&#13;
      }&#13;
    }&#13;
    return false;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Override the transfer function with transferWithProofs&#13;
   * A proof of ownership will be made if any claims can be made by the participants&#13;
   */&#13;
  function transfer(address _to, uint256 _value) public returns (bool) {&#13;
    bool proofFrom = hasClaims(msg.sender);&#13;
    bool proofTo = hasClaims(_to);&#13;
&#13;
    return super.transferWithProofs(&#13;
      _to,&#13;
      _value,&#13;
      proofFrom,&#13;
      proofTo&#13;
    );&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Override the transfer function with transferWithProofs&#13;
   * A proof of ownership will be made if any claims can be made by the participants&#13;
   */&#13;
  function transferFrom(address _from, address _to, uint256 _value)&#13;
    public returns (bool)&#13;
  {&#13;
    bool proofFrom = hasClaims(_from);&#13;
    bool proofTo = hasClaims(_to);&#13;
&#13;
    return super.transferFromWithProofs(&#13;
      _from,&#13;
      _to,&#13;
      _value,&#13;
      proofFrom,&#13;
      proofTo&#13;
    );&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev transfer with proofs&#13;
   */&#13;
  function transferWithProofs(&#13;
    address _to,&#13;
    uint256 _value,&#13;
    bool _proofFrom,&#13;
    bool _proofTo&#13;
  ) public returns (bool)&#13;
  {&#13;
    bool proofFrom = _proofFrom || hasClaims(msg.sender);&#13;
    bool proofTo = _proofTo || hasClaims(_to);&#13;
&#13;
    return super.transferWithProofs(&#13;
      _to,&#13;
      _value,&#13;
      proofFrom,&#13;
      proofTo&#13;
    );&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev transfer from with proofs&#13;
   */&#13;
  function transferFromWithProofs(&#13;
    address _from,&#13;
    address _to,&#13;
    uint256 _value,&#13;
    bool _proofFrom,&#13;
    bool _proofTo&#13;
  ) public returns (bool)&#13;
  {&#13;
    bool proofFrom = _proofFrom || hasClaims(_from);&#13;
    bool proofTo = _proofTo || hasClaims(_to);&#13;
&#13;
    return super.transferFromWithProofs(&#13;
      _from,&#13;
      _to,&#13;
      _value,&#13;
      proofFrom,&#13;
      proofTo&#13;
    );&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev define claimables contract to this token&#13;
   */&#13;
  function defineClaimables(IClaimable[] _claimables) public onlyOwner {&#13;
    claimables = _claimables;&#13;
    emit ClaimablesDefined(claimables.length);&#13;
  }&#13;
}&#13;
&#13;
// File: contracts/interface/IRule.sol&#13;
&#13;
/**&#13;
 * @title IRule&#13;
 * @dev IRule interface&#13;
 * @author Cyril Lapinte - &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="afccd6ddc6c381c3cedfc6c1dbcaefc2dbdfcac3caddc6c181ccc0c2">[email protected]</a>&gt;&#13;
 *&#13;
 * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved&#13;
 * @notice Please refer to the top of this file for the license.&#13;
 **/&#13;
interface IRule {&#13;
  function isAddressValid(address _address) external view returns (bool);&#13;
  function isTransferValid(address _from, address _to, uint256 _amount)&#13;
    external view returns (bool);&#13;
}&#13;
&#13;
// File: contracts/interface/IWithRules.sol&#13;
&#13;
/**&#13;
 * @title IWithRules&#13;
 * @dev IWithRules interface&#13;
 * @author Cyril Lapinte - &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="b6d5cfc4dfda98dad7c6dfd8c2d3f6dbc2c6d3dad3c4dfd898d5d9db">[email protected]</a>&gt;&#13;
 *&#13;
 * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved&#13;
 * @notice Please refer to the top of this file for the license.&#13;
 **/&#13;
contract IWithRules {&#13;
  function ruleLength() public view returns (uint256);&#13;
  function rule(uint256 _ruleId) public view returns (IRule);&#13;
  function validateAddress(address _address) public view returns (bool);&#13;
  function validateTransfer(address _from, address _to, uint256 _amount)&#13;
    public view returns (bool);&#13;
&#13;
  function defineRules(IRule[] _rules) public;&#13;
&#13;
  event RulesDefined(uint256 count);&#13;
}&#13;
&#13;
// File: contracts/rule/WithRules.sol&#13;
&#13;
/**&#13;
 * @title WithRules&#13;
 * @dev WithRules contract allows inheriting contract to use a set of validation rules&#13;
 * @dev contract owner may add or remove rules&#13;
 *&#13;
 * @author Cyril Lapinte - &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="67041e150e0b490b06170e091302270a1317020b02150e094904080a">[email protected]</a>&gt;&#13;
 *&#13;
 * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved&#13;
 * @notice Please refer to the top of this file for the license.&#13;
 *&#13;
 * Error messages&#13;
 * WR01: The rules rejected this address&#13;
 * WR02: The rules rejected the transfer&#13;
 **/&#13;
contract WithRules is IWithRules, Ownable {&#13;
&#13;
  IRule[] internal rules;&#13;
&#13;
  /**&#13;
   * @dev Constructor&#13;
   */&#13;
  constructor(IRule[] _rules) public {&#13;
    rules = _rules;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Returns the number of rules&#13;
   */&#13;
  function ruleLength() public view returns (uint256) {&#13;
    return rules.length;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Returns the Rule associated to the specified ruleId&#13;
   */&#13;
  function rule(uint256 _ruleId) public view returns (IRule) {&#13;
    return rules[_ruleId];&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Check if the rules are valid for an address&#13;
   */&#13;
  function validateAddress(address _address) public view returns (bool) {&#13;
    for (uint256 i = 0; i &lt; rules.length; i++) {&#13;
      if (!rules[i].isAddressValid(_address)) {&#13;
        return false;&#13;
      }&#13;
    }&#13;
    return true;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Check if the rules are valid&#13;
   */&#13;
  function validateTransfer(address _from, address _to, uint256 _amount)&#13;
    public view returns (bool)&#13;
  {&#13;
    for (uint256 i = 0; i &lt; rules.length; i++) {&#13;
      if (!rules[i].isTransferValid(_from, _to, _amount)) {&#13;
        return false;&#13;
      }&#13;
    }&#13;
    return true;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Modifier to make functions callable&#13;
   * only when participants follow rules&#13;
   */&#13;
  modifier whenAddressRulesAreValid(address _address) {&#13;
    require(validateAddress(_address), "WR01");&#13;
    _;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Modifier to make transfer functions callable&#13;
   * only when participants follow rules&#13;
   */&#13;
  modifier whenTransferRulesAreValid(&#13;
    address _from,&#13;
    address _to,&#13;
    uint256 _amount)&#13;
  {&#13;
    require(validateTransfer(_from, _to, _amount), "WR02");&#13;
    _;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Define rules to the token&#13;
   */&#13;
  function defineRules(IRule[] _rules) public onlyOwner {&#13;
    rules = _rules;&#13;
    emit RulesDefined(rules.length);&#13;
  }&#13;
}&#13;
&#13;
// File: contracts/token/component/TokenWithRules.sol&#13;
&#13;
/**&#13;
 * @title TokenWithRules&#13;
 * @dev TokenWithRules contract&#13;
 * TokenWithRules is a token that will apply&#13;
 * rules restricting transferability&#13;
 *&#13;
 * @author Cyril Lapinte - &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="74170d061d185a1815041d1a001134190004111811061d1a5a171b19">[email protected]</a>&gt;&#13;
 *&#13;
 * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved&#13;
 * @notice Please refer to the top of this file for the license.&#13;
 *&#13;
 **/&#13;
contract TokenWithRules is StandardToken, WithRules {&#13;
&#13;
  /**&#13;
   * @dev Constructor&#13;
   */&#13;
  constructor(IRule[] _rules) public WithRules(_rules) { }&#13;
&#13;
  /**&#13;
   * @dev Overriden transfer function&#13;
   */&#13;
  function transfer(address _to, uint256 _value)&#13;
    public whenTransferRulesAreValid(msg.sender, _to, _value)&#13;
    returns (bool)&#13;
  {&#13;
    return super.transfer(_to, _value);&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Overriden transferFrom function&#13;
   */&#13;
  function transferFrom(address _from, address _to, uint256 _value)&#13;
    public whenTransferRulesAreValid(_from, _to, _value)&#13;
    whenAddressRulesAreValid(msg.sender)&#13;
    returns (bool)&#13;
  {&#13;
    return super.transferFrom(_from, _to, _value);&#13;
  }&#13;
}&#13;
&#13;
// File: contracts/token/BridgeToken.sol&#13;
&#13;
/**&#13;
 * @title BridgeToken&#13;
 * @dev BridgeToken contract&#13;
 * @author Cyril Lapinte - &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="96f5efe4fffab8faf7e6fff8e2f3d6fbe2e6f3faf3e4fff8b8f5f9fb">[email protected]</a>&gt;&#13;
 *&#13;
 * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved&#13;
 * @notice Please refer to the top of this file for the license.&#13;
 */&#13;
contract BridgeToken is TokenWithRules, TokenWithClaims, SeizableToken {&#13;
  string public name;&#13;
  string public symbol;&#13;
&#13;
  /**&#13;
   * @dev constructor&#13;
   */&#13;
  constructor(string _name, string _symbol) &#13;
    TokenWithRules(new IRule[](0))&#13;
    TokenWithClaims(new IClaimable[](0)) public&#13;
  {&#13;
    name = _name;&#13;
    symbol = _symbol;&#13;
  }&#13;
}&#13;
&#13;
// File: contracts/interface/IMintable.sol&#13;
&#13;
/**&#13;
 * @title Mintable interface&#13;
 *&#13;
 * @author Cyril Lapinte - &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="ccafb5bea5a0e2a0adbca5a2b8a98ca1b8bca9a0a9bea5a2e2afa3a1">[email protected]</a>&gt;&#13;
 *&#13;
 * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved&#13;
 * @notice Please refer to the top of this file for the license.&#13;
 */&#13;
contract IMintable {&#13;
  function mintingFinished() public view returns (bool);&#13;
&#13;
  function mint(address _to, uint256 _amount) public returns (bool);&#13;
  function finishMinting() public returns (bool);&#13;
 &#13;
  event Mint(address indexed to, uint256 amount);&#13;
  event MintFinished();&#13;
}&#13;
&#13;
// File: contracts/token/component/MintableToken.sol&#13;
&#13;
/**&#13;
 * @title MintableToken&#13;
 * @dev MintableToken contract&#13;
 * @author Cyril Lapinte - &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="c9aab0bba0a5e7a5a8b9a0a7bdac89a4bdb9aca5acbba0a7e7aaa6a4">[email protected]</a>&gt;&#13;
 *&#13;
 * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved&#13;
 * @notice Please refer to the top of this file for the license.&#13;
 *&#13;
 * Error messages&#13;
 * MT01: Minting is already finished.&#13;
*/&#13;
contract MintableToken is StandardToken, Ownable, IMintable {&#13;
&#13;
  bool public mintingFinished = false;&#13;
&#13;
  function mintingFinished() public view returns (bool) {&#13;
    return mintingFinished;&#13;
  }&#13;
&#13;
  modifier canMint() {&#13;
    require(!mintingFinished, "MT01");&#13;
    _;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Function to mint tokens&#13;
   * @param _to The address that will receive the minted tokens.&#13;
   * @param _amount The amount of tokens to mint.&#13;
   * @return A boolean that indicates if the operation was successful.&#13;
   */&#13;
  function mint(&#13;
    address _to,&#13;
    uint256 _amount&#13;
  ) public canMint onlyOwner returns (bool)&#13;
  {&#13;
    totalSupply_ = totalSupply_.add(_amount);&#13;
    balances[_to] = balances[_to].add(_amount);&#13;
    emit Mint(_to, _amount);&#13;
    emit Transfer(address(0), _to, _amount);&#13;
    return true;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Function to stop minting new tokens.&#13;
   * @return True if the operation was successful.&#13;
   */&#13;
  function finishMinting() public canMint onlyOwner returns (bool) {&#13;
    mintingFinished = true;&#13;
    emit MintFinished();&#13;
    return true;&#13;
  }&#13;
&#13;
  event Mint(address indexed to, uint256 amount);&#13;
  event MintFinished();&#13;
}&#13;
&#13;
// File: contracts/token/MintableBridgeToken.sol&#13;
&#13;
/**&#13;
 * @title MintableBridgeToken&#13;
 * @dev MintableBridgeToken contract&#13;
 * @author Cyril Lapinte - &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="bbd8c2c9d2d795d7dacbd2d5cfdefbd6cfcbded7dec9d2d595d8d4d6">[email protected]</a>&gt;&#13;
 *&#13;
 * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved&#13;
 * @notice Please refer to the top of this file for the license.&#13;
 */&#13;
contract MintableBridgeToken is BridgeToken, MintableToken {&#13;
&#13;
  string public name;&#13;
  string public symbol;&#13;
&#13;
  /**&#13;
   * @dev constructor&#13;
   */&#13;
  constructor(string _name, string _symbol)&#13;
    BridgeToken(_name, _symbol) public&#13;
  {&#13;
    name = _name;&#13;
    symbol = _symbol;&#13;
  }&#13;
}&#13;
&#13;
// File: contracts/token/ShareBridgeToken.sol&#13;
&#13;
/**&#13;
 * @title ShareBridgeToken&#13;
 * @dev ShareBridgeToken contract&#13;
 * @author Cyril Lapinte - &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="f0938982999cde9c9180999e8495b09d8480959c9582999ede939f9d">[email protected]</a>&gt;&#13;
 *&#13;
 * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved&#13;
 * @notice Please refer to the top of this file for the license.&#13;
 */&#13;
contract ShareBridgeToken is MintableBridgeToken {&#13;
&#13;
  // Shares are non divisible assets&#13;
  uint256 public decimals = 0;&#13;
&#13;
  /**&#13;
   * @dev constructor&#13;
   */&#13;
  constructor(string _name, string _symbol) public&#13;
    MintableBridgeToken(_name, _symbol)&#13;
  {&#13;
  }&#13;
}&#13;
&#13;
// File: contracts/mps/MPSToken.sol&#13;
&#13;
/**&#13;
 * @title MPSToken&#13;
 * @dev MPSToken contract&#13;
 * @author Cyril Lapinte - &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="197a606b70753775786970776d7c59746d697c757c6b7077377a7674">[email protected]</a>&gt;&#13;
 *&#13;
 * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved&#13;
 * @notice Please refer to the top of this file for the license.&#13;
 */&#13;
contract MPSToken is ShareBridgeToken {&#13;
&#13;
  /**&#13;
   * @dev constructor&#13;
   */&#13;
  constructor() public&#13;
    ShareBridgeToken("MtPelerin Shares", "MPS")&#13;
  {&#13;
  }&#13;
}