// PixelCoins Source code
pragma solidity ^0.4.11;

/// @title Interface for contracts conforming to ERC-721: Non-Fungible Tokens
/// @author Dieter Shirley <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="224647564762435a4b4d4f58474c0c414d">[email protected]</a>&gt; (https://github.com/dete)&#13;
contract ERC721 {&#13;
    // Required methods&#13;
    function totalSupply() public view returns (uint256 total);&#13;
    function balanceOf(address _owner) public view returns (uint256 balance);&#13;
    function ownerOf(uint256 _tokenId) external view returns (address owner);&#13;
    function approve(address _to, uint256 _tokenId) external;&#13;
    function transfer(address _to, uint256 _tokenId) external;&#13;
    function transferFrom(address _from, address _to, uint256 _tokenId) external;&#13;
&#13;
    // Events&#13;
    event Transfer(address from, address to, uint256 tokenId);&#13;
    event Approval(address owner, address approved, uint256 tokenId);&#13;
&#13;
    // Optional&#13;
    // function name() public view returns (string name);&#13;
    // function symbol() public view returns (string symbol);&#13;
    // function tokensOfOwner(address _owner) external view returns (uint256[] tokenIds);&#13;
    // function tokenMetadata(uint256 _tokenId, string _preferredTransport) public view returns (string infoUrl);&#13;
&#13;
    // ERC-165 Compatibility (https://github.com/ethereum/EIPs/issues/165)&#13;
    function supportsInterface(bytes4 _interfaceID) external view returns (bool);&#13;
}&#13;
&#13;
&#13;
/// @title A facet of PixelCore that manages special access privileges.&#13;
/// @author Oliver Schneider &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="84edeae2ebc4f4edfce1e8e7ebedeaf7aaedeb">[email protected]</a>&gt; (https://pixelcoins.io)&#13;
contract PixelAuthority {&#13;
&#13;
    /// @dev Emited when contract is upgraded&#13;
    event ContractUpgrade(address newContract);&#13;
&#13;
    address public authorityAddress;&#13;
    uint public authorityBalance = 0;&#13;
&#13;
    /// @dev Access modifier for authority-only functionality&#13;
    modifier onlyAuthority() {&#13;
        require(msg.sender == authorityAddress);&#13;
        _;&#13;
    }&#13;
&#13;
    /// @dev Assigns a new address to act as the authority. Only available to the current authority.&#13;
    /// @param _newAuthority The address of the new authority&#13;
    function setAuthority(address _newAuthority) external onlyAuthority {&#13;
        require(_newAuthority != address(0));&#13;
        authorityAddress = _newAuthority;&#13;
    }&#13;
&#13;
}&#13;
&#13;
&#13;
/// @title Base contract for PixelCoins. Holds all common structs, events and base variables.&#13;
/// @author Oliver Schneider &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="80e9eee6efc0f0e9f8e5ece3efe9eef3aee9ef">[email protected]</a>&gt; (https://pixelcoins.io)&#13;
/// @dev See the PixelCore contract documentation to understand how the various contract facets are arranged.&#13;
contract PixelBase is PixelAuthority {&#13;
    /*** EVENTS ***/&#13;
&#13;
    /// @dev Transfer event as defined in current draft of ERC721. Emitted every time a Pixel&#13;
    ///  ownership is assigned.&#13;
    event Transfer(address from, address to, uint256 tokenId);&#13;
&#13;
    /*** CONSTANTS ***/&#13;
    uint32 public WIDTH = 1000;&#13;
    uint32 public HEIGHT = 1000;&#13;
&#13;
    /*** STORAGE ***/&#13;
    /// @dev A mapping from pixel ids to the address that owns them. A pixel address of 0 means,&#13;
    /// that the pixel can still be bought.&#13;
    mapping (uint256 =&gt; address) public pixelIndexToOwner;&#13;
    /// Address that is approved to change ownship&#13;
    mapping (uint256 =&gt; address) public pixelIndexToApproved;&#13;
    /// Stores the color of an pixel, indexed by pixelid&#13;
    mapping (uint256 =&gt; uint32) public colors;&#13;
    // @dev A mapping from owner address to count of tokens that address owns.&#13;
    //  Used internally inside balanceOf() to resolve ownership count.&#13;
    mapping (address =&gt; uint256) ownershipTokenCount;&#13;
&#13;
    // Internal utility functions: These functions all assume that their input arguments&#13;
    // are valid. We leave it to public methods to sanitize their inputs and follow&#13;
    // the required logic.&#13;
&#13;
    /// @dev Assigns ownership of a specific Pixel to an address.&#13;
    function _transfer(address _from, address _to, uint256 _tokenId) internal {&#13;
        // Can no overflowe since the number of Pixels is capped.&#13;
        // transfer ownership&#13;
        ownershipTokenCount[_to]++;&#13;
        pixelIndexToOwner[_tokenId] = _to;&#13;
        if (_from != address(0)) {&#13;
            ownershipTokenCount[_from]--;&#13;
            delete pixelIndexToApproved[_tokenId];&#13;
        }&#13;
        // Emit the transfer event.&#13;
        Transfer(_from, _to, _tokenId);&#13;
    }&#13;
&#13;
    /// @dev Checks if a given address is the current owner of a particular Pixel.&#13;
    /// @param _claimant the address we are validating against.&#13;
    /// @param _tokenId Pixel id&#13;
    function _owns(address _claimant, uint256 _tokenId) internal view returns (bool) {&#13;
        return pixelIndexToOwner[_tokenId] == _claimant;&#13;
    }&#13;
&#13;
    /// @dev Checks if a given address currently has transferApproval for a particular Pixel.&#13;
    /// @param _claimant the address we are confirming pixel is approved for.&#13;
    /// @param _tokenId pixel id, only valid when &gt; 0&#13;
    function _approvedFor(address _claimant, uint256 _tokenId) internal view returns (bool) {&#13;
        return pixelIndexToApproved[_tokenId] == _claimant;&#13;
    }&#13;
}&#13;
&#13;
&#13;
/// @title The facet of the PixelCoins core contract that manages ownership, ERC-721 (draft) compliant.&#13;
/// @author Oliver Schneider &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="acc5c2cac3ecdcc5d4c9c0cfc3c5c2df82c5c3">[email protected]</a>&gt; (https://pixelcoins.io), based on Axiom Zen (https://www.axiomzen.co)&#13;
/// @dev Ref: https://github.com/ethereum/EIPs/issues/721&#13;
///  See the PixelCore contract documentation to understand how the various contract facets are arranged.&#13;
contract PixelOwnership is PixelBase, ERC721 {&#13;
&#13;
    /// @notice Name and symbol of the non fungible token, as defined in ERC721.&#13;
    string public constant name = "PixelCoins";&#13;
    string public constant symbol = "PXL";&#13;
&#13;
&#13;
    bytes4 constant InterfaceSignature_ERC165 =&#13;
        bytes4(keccak256('supportsInterface(bytes4)'));&#13;
&#13;
    bytes4 constant InterfaceSignature_ERC721 =&#13;
        bytes4(keccak256('name()')) ^&#13;
        bytes4(keccak256('symbol()')) ^&#13;
        bytes4(keccak256('totalSupply()')) ^&#13;
        bytes4(keccak256('balanceOf(address)')) ^&#13;
        bytes4(keccak256('ownerOf(uint256)')) ^&#13;
        bytes4(keccak256('approve(address,uint256)')) ^&#13;
        bytes4(keccak256('transfer(address,uint256)')) ^&#13;
        bytes4(keccak256('transferFrom(address,address,uint256)')) ^&#13;
        bytes4(keccak256('tokensOfOwner(address)')) ^&#13;
        bytes4(keccak256('tokenMetadata(uint256,string)'));&#13;
&#13;
&#13;
    string public metaBaseUrl = "https://pixelcoins.io/meta/";&#13;
&#13;
&#13;
    /// @notice Introspection interface as per ERC-165 (https://github.com/ethereum/EIPs/issues/165).&#13;
    ///  Returns true for any standardized interfaces implemented by this contract. We implement&#13;
    ///  ERC-165 (obviously!) and ERC-721.&#13;
    function supportsInterface(bytes4 _interfaceID) external view returns (bool) {&#13;
        return ((_interfaceID == InterfaceSignature_ERC165) || (_interfaceID == InterfaceSignature_ERC721));&#13;
    }&#13;
&#13;
    /// @notice Returns the number ofd Pixels owned by a specific address.&#13;
    /// @param _owner The owner address to check.&#13;
    /// @dev Required for ERC-721 compliance&#13;
    function balanceOf(address _owner) public view returns (uint256 count) {&#13;
        return ownershipTokenCount[_owner];&#13;
    }&#13;
&#13;
    /// @notice Transfers a Pixel to another address. If transferring to a smart&#13;
    ///  contract be VERY CAREFUL to ensure that it is aware of ERC-721 (or&#13;
    ///  PixelCoins specifically) or your Pixel may be lost forever. Seriously.&#13;
    /// @param _to The address of the recipient, can be a user or contract.&#13;
    /// @param _tokenId The ID of the Pixel to transfer.&#13;
    /// @dev Required for ERC-721 compliance.&#13;
    function transfer(&#13;
        address _to,&#13;
        uint256 _tokenId&#13;
    )&#13;
        external&#13;
    {&#13;
        // Safety check to prevent against an unexpected 0x0 default.&#13;
        require(_to != address(0));&#13;
        // Disallow transfers to this contract to prevent accidental misuse.&#13;
        // The contract should never own any pixel (except very briefly&#13;
        // after a gen0 cat is created and before it goes on auction).&#13;
        require(_to != address(this));&#13;
&#13;
        // You can only send your own pixel.&#13;
        require(_owns(msg.sender, _tokenId));&#13;
        // address is not currently managed by the contract (it is in an auction)&#13;
        require(pixelIndexToApproved[_tokenId] != address(this));&#13;
&#13;
        // Reassign ownership, clear pending approvals, emit Transfer event.&#13;
        _transfer(msg.sender, _to, _tokenId);&#13;
    }&#13;
&#13;
    /// @notice Grant another address the right to transfer a specific pixel via&#13;
    ///  transferFrom(). This is the preferred flow for transfering NFTs to contracts.&#13;
    /// @param _to The address to be granted transfer approval. Pass address(0) to&#13;
    ///  clear all approvals.&#13;
    /// @param _tokenId The ID of the pixel that can be transferred if this call succeeds.&#13;
    /// @dev Required for ERC-721 compliance.&#13;
    function approve(&#13;
        address _to,&#13;
        uint256 _tokenId&#13;
    )&#13;
        external&#13;
    {&#13;
        // Only an owner can grant transfer approval.&#13;
        require(_owns(msg.sender, _tokenId));&#13;
        // address is not currently managed by the contract (it is in an auction)&#13;
        require(pixelIndexToApproved[_tokenId] != address(this));&#13;
&#13;
        // Register the approval (replacing any previous approval).&#13;
        pixelIndexToApproved[_tokenId] = _to;&#13;
&#13;
        // Emit approval event.&#13;
        Approval(msg.sender, _to, _tokenId);&#13;
    }&#13;
&#13;
    /// @notice Transfer a Pixel owned by another address, for which the calling address&#13;
    ///  has previously been granted transfer approval by the owner.&#13;
    /// @param _from The address that owns the pixel to be transfered.&#13;
    /// @param _to The address that should take ownership of the Pixel. Can be any address,&#13;
    ///  including the caller.&#13;
    /// @param _tokenId The ID of the Pixel to be transferred.&#13;
    /// @dev Required for ERC-721 compliance.&#13;
    function transferFrom(&#13;
        address _from,&#13;
        address _to,&#13;
        uint256 _tokenId&#13;
    )&#13;
        external&#13;
    {&#13;
        // Safety check to prevent against an unexpected 0x0 default.&#13;
        require(_to != address(0));&#13;
        // Disallow transfers to this contract to prevent accidental misuse.&#13;
        // The contract should never own anyd Pixels (except very briefly&#13;
        // after a gen0 cat is created and before it goes on auction).&#13;
        require(_to != address(this));&#13;
        // Check for approval and valid ownership&#13;
        require(_approvedFor(msg.sender, _tokenId));&#13;
        require(_owns(_from, _tokenId));&#13;
&#13;
        // Reassign ownership (also clears pending approvals and emits Transfer event).&#13;
        _transfer(_from, _to, _tokenId);&#13;
    }&#13;
&#13;
    /// @notice Returns the total number of pixels currently in existence.&#13;
    /// @dev Required for ERC-721 compliance.&#13;
    function totalSupply() public view returns (uint) {&#13;
        return WIDTH * HEIGHT;&#13;
    }&#13;
&#13;
    /// @notice Returns the address currently assigned ownership of a given Pixel.&#13;
    /// @dev Required for ERC-721 compliance.&#13;
    function ownerOf(uint256 _tokenId)&#13;
        external&#13;
        view&#13;
        returns (address owner)&#13;
    {&#13;
        owner = pixelIndexToOwner[_tokenId];&#13;
        require(owner != address(0));&#13;
    }&#13;
&#13;
    /// @notice Returns the addresses currently assigned ownership of the given pixel area.&#13;
    function ownersOfArea(uint256 x, uint256 y, uint256 x2, uint256 y2) external view returns (address[] result) {&#13;
        require(x2 &gt; x &amp;&amp; y2 &gt; y);&#13;
        require(x2 &lt;= WIDTH &amp;&amp; y2 &lt;= HEIGHT);&#13;
        result = new address[]((y2 - y) * (x2 - x));&#13;
&#13;
        uint256 r = 0;&#13;
        for (uint256 i = y; i &lt; y2; i++) {&#13;
            uint256 tokenId = i * WIDTH;&#13;
            for (uint256 j = x; j &lt; x2; j++) {&#13;
                result[r] = pixelIndexToOwner[tokenId + j];&#13;
                r++;&#13;
            }&#13;
        }&#13;
    }&#13;
&#13;
    /// @notice Returns a list of all Pixel IDs assigned to an address.&#13;
    /// @param _owner The owner whosed Pixels we are interested in.&#13;
    /// @dev This method MUST NEVER be called by smart contract code. First, it's fairly&#13;
    ///  expensive (it walks the entire Pixel array looking for pixels belonging to owner),&#13;
    ///  but it also returns a dynamic array, which is only supported for web3 calls, and&#13;
    ///  not contract-to-contract calls.&#13;
    function tokensOfOwner(address _owner) external view returns(uint256[] ownerTokens) {&#13;
        uint256 tokenCount = balanceOf(_owner);&#13;
&#13;
        if (tokenCount == 0) {&#13;
            // Return an empty array&#13;
            return new uint256[](0);&#13;
        } else {&#13;
            uint256[] memory result = new uint256[](tokenCount);&#13;
            uint256 totalPixels = totalSupply();&#13;
            uint256 resultIndex = 0;&#13;
&#13;
            // We count on the fact that all pixels have IDs starting at 0 and increasing&#13;
            // sequentially up to the totalCat count.&#13;
            uint256 pixelId;&#13;
&#13;
            for (pixelId = 0; pixelId &lt;= totalPixels; pixelId++) {&#13;
                if (pixelIndexToOwner[pixelId] == _owner) {&#13;
                    result[resultIndex] = pixelId;&#13;
                    resultIndex++;&#13;
                }&#13;
            }&#13;
&#13;
            return result;&#13;
        }&#13;
    }&#13;
&#13;
    // Taken from https://ethereum.stackexchange.com/a/10929&#13;
    function uintToString(uint v) constant returns (string str) {&#13;
        uint maxlength = 100;&#13;
        bytes memory reversed = new bytes(maxlength);&#13;
        uint i = 0;&#13;
        while (v != 0) {&#13;
            uint remainder = v % 10;&#13;
            v = v / 10;&#13;
            reversed[i++] = byte(48 + remainder);&#13;
        }&#13;
        bytes memory s = new bytes(i);&#13;
        for (uint j = 0; j &lt; i; j++) {&#13;
            s[j] = reversed[i - 1 - j];&#13;
        }&#13;
        str = string(s);&#13;
    }&#13;
&#13;
    // Taken from https://ethereum.stackexchange.com/a/10929&#13;
    function appendUintToString(string inStr, uint v) constant returns (string str) {&#13;
        uint maxlength = 100;&#13;
        bytes memory reversed = new bytes(maxlength);&#13;
        uint i = 0;&#13;
        while (v != 0) {&#13;
            uint remainder = v % 10;&#13;
            v = v / 10;&#13;
            reversed[i++] = byte(48 + remainder);&#13;
        }&#13;
        bytes memory inStrb = bytes(inStr);&#13;
        bytes memory s = new bytes(inStrb.length + i);&#13;
        uint j;&#13;
        for (j = 0; j &lt; inStrb.length; j++) {&#13;
            s[j] = inStrb[j];&#13;
        }&#13;
        for (j = 0; j &lt; i; j++) {&#13;
            s[j + inStrb.length] = reversed[i - 1 - j];&#13;
        }&#13;
        str = string(s);&#13;
    }&#13;
&#13;
    function setMetaBaseUrl(string _metaBaseUrl) external onlyAuthority {&#13;
        metaBaseUrl = _metaBaseUrl;&#13;
    }&#13;
&#13;
    /// @notice Returns a URI pointing to a metadata package for this token conforming to&#13;
    ///  ERC-721 (https://github.com/ethereum/EIPs/issues/721)&#13;
    /// @param _tokenId The ID number of the Pixel whose metadata should be returned.&#13;
    function tokenMetadata(uint256 _tokenId) external view returns (string infoUrl) {&#13;
        return appendUintToString(metaBaseUrl, _tokenId);&#13;
    }&#13;
}&#13;
&#13;
contract PixelPainting is PixelOwnership {&#13;
&#13;
    event Paint(uint256 tokenId, uint32 color);&#13;
&#13;
    // Sets the color of an individual pixel&#13;
    function setPixelColor(uint256 _tokenId, uint32 _color) external {&#13;
        // check that the token id is in the range&#13;
        require(_tokenId &lt; HEIGHT * WIDTH);&#13;
        // check that the sender is owner of the pixel&#13;
        require(_owns(msg.sender, _tokenId));&#13;
        colors[_tokenId] = _color;&#13;
    }&#13;
&#13;
    // Sets the color of the pixels in an area, left to right and then top to bottom&#13;
    function setPixelAreaColor(uint256 x, uint256 y, uint256 x2, uint256 y2, uint32[] _colors) external {&#13;
        require(x2 &gt; x &amp;&amp; y2 &gt; y);&#13;
        require(x2 &lt;= WIDTH &amp;&amp; y2 &lt;= HEIGHT);&#13;
        require(_colors.length == (y2 - y) * (x2 - x));&#13;
        uint256 r = 0;&#13;
        for (uint256 i = y; i &lt; y2; i++) {&#13;
            uint256 tokenId = i * WIDTH;&#13;
            for (uint256 j = x; j &lt; x2; j++) {&#13;
                if (_owns(msg.sender, tokenId + j)) {&#13;
                    uint32 color = _colors[r];&#13;
                    colors[tokenId + j] = color;&#13;
                    Paint(tokenId + j, color);&#13;
                }&#13;
                r++;&#13;
            }&#13;
        }&#13;
    }&#13;
&#13;
    // Returns the color of a given pixel&#13;
    function getPixelColor(uint256 _tokenId) external view returns (uint32 color) {&#13;
        require(_tokenId &lt; HEIGHT * WIDTH);&#13;
        color = colors[_tokenId];&#13;
    }&#13;
&#13;
    // Returns the colors of the pixels in an area, left to right and then top to bottom&#13;
    function getPixelAreaColor(uint256 x, uint256 y, uint256 x2, uint256 y2) external view returns (uint32[] result) {&#13;
        require(x2 &gt; x &amp;&amp; y2 &gt; y);&#13;
        require(x2 &lt;= WIDTH &amp;&amp; y2 &lt;= HEIGHT);&#13;
        result = new uint32[]((y2 - y) * (x2 - x));&#13;
        uint256 r = 0;&#13;
        for (uint256 i = y; i &lt; y2; i++) {&#13;
            uint256 tokenId = i * WIDTH;&#13;
            for (uint256 j = x; j &lt; x2; j++) {&#13;
                result[r] = colors[tokenId + j];&#13;
                r++;&#13;
            }&#13;
        }&#13;
    }&#13;
}&#13;
&#13;
&#13;
/// @title all functions for buying empty pixels&#13;
contract PixelMinting is PixelPainting {&#13;
&#13;
    uint public pixelPrice = 3030 szabo;&#13;
&#13;
    // Set the price for a pixel&#13;
    function setNewPixelPrice(uint _pixelPrice) external onlyAuthority {&#13;
        pixelPrice = _pixelPrice;&#13;
    }&#13;
    &#13;
    // buy en empty pixel&#13;
    function buyEmptyPixel(uint256 _tokenId) external payable {&#13;
        require(msg.value == pixelPrice);&#13;
        require(_tokenId &lt; HEIGHT * WIDTH);&#13;
        require(pixelIndexToOwner[_tokenId] == address(0));&#13;
        // increase authority balance&#13;
        authorityBalance += msg.value;&#13;
        // This will assign ownership, and also emit the Transfer event as&#13;
        // per ERC721 draft&#13;
        _transfer(0, msg.sender, _tokenId);&#13;
    }&#13;
&#13;
    // buy an area of pixels, left to right, top to bottom&#13;
    function buyEmptyPixelArea(uint256 x, uint256 y, uint256 x2, uint256 y2) external payable {&#13;
        require(x2 &gt; x &amp;&amp; y2 &gt; y);&#13;
        require(x2 &lt;= WIDTH &amp;&amp; y2 &lt;= HEIGHT);&#13;
        require(msg.value == pixelPrice * (x2-x) * (y2-y));&#13;
        &#13;
        uint256 i;&#13;
        uint256 tokenId;&#13;
        uint256 j;&#13;
        // check that all pixels to buy are available&#13;
        for (i = y; i &lt; y2; i++) {&#13;
            tokenId = i * WIDTH;&#13;
            for (j = x; j &lt; x2; j++) {&#13;
                require(pixelIndexToOwner[tokenId + j] == address(0));&#13;
            }&#13;
        }&#13;
&#13;
        authorityBalance += msg.value;&#13;
&#13;
        // Do the actual transfer&#13;
        for (i = y; i &lt; y2; i++) {&#13;
            tokenId = i * WIDTH;&#13;
            for (j = x; j &lt; x2; j++) {&#13;
                _transfer(0, msg.sender, tokenId + j);&#13;
            }&#13;
        }&#13;
    }&#13;
&#13;
}&#13;
&#13;
/// @title all functions for managing pixel auctions&#13;
contract PixelAuction is PixelMinting {&#13;
&#13;
    // Represents an auction on an NFT&#13;
    struct Auction {&#13;
         // Current state of the auction.&#13;
        address highestBidder;&#13;
        uint highestBid;&#13;
        uint256 endTime;&#13;
        bool live;&#13;
    }&#13;
&#13;
    // Map from token ID to their corresponding auction.&#13;
    mapping (uint256 =&gt; Auction) tokenIdToAuction;&#13;
    // Allowed withdrawals of previous bids&#13;
    mapping (address =&gt; uint) pendingReturns;&#13;
&#13;
    // Duration of an auction&#13;
    uint256 public duration = 60 * 60 * 24 * 4;&#13;
    // Auctions will be enabled later&#13;
    bool public auctionsEnabled = false;&#13;
&#13;
    // Change the duration for new auctions&#13;
    function setDuration(uint _duration) external onlyAuthority {&#13;
        duration = _duration;&#13;
    }&#13;
&#13;
    // Enable or disable auctions&#13;
    function setAuctionsEnabled(bool _auctionsEnabled) external onlyAuthority {&#13;
        auctionsEnabled = _auctionsEnabled;&#13;
    }&#13;
&#13;
    // create a new auctions for a given pixel, only owner or authority can do this&#13;
    // The authority will only do this if pixels are misused or lost&#13;
    function createAuction(&#13;
        uint256 _tokenId&#13;
    )&#13;
        external payable&#13;
    {&#13;
        // only authority or owner can start auction&#13;
        require(auctionsEnabled);&#13;
        require(_owns(msg.sender, _tokenId) || msg.sender == authorityAddress);&#13;
        // No auction is currently running&#13;
        require(!tokenIdToAuction[_tokenId].live);&#13;
&#13;
        uint startPrice = pixelPrice;&#13;
        if (msg.sender == authorityAddress) {&#13;
            startPrice = 0;&#13;
        }&#13;
&#13;
        require(msg.value == startPrice);&#13;
        // this prevents transfers during the auction&#13;
        pixelIndexToApproved[_tokenId] = address(this);&#13;
&#13;
        tokenIdToAuction[_tokenId] = Auction(&#13;
            msg.sender,&#13;
            startPrice,&#13;
            block.timestamp + duration,&#13;
            true&#13;
        );&#13;
        AuctionStarted(_tokenId);&#13;
    }&#13;
&#13;
    // bid for an pixel auction&#13;
    function bid(uint256 _tokenId) external payable {&#13;
        // No arguments are necessary, all&#13;
        // information is already part of&#13;
        // the transaction. The keyword payable&#13;
        // is required for the function to&#13;
        // be able to receive Ether.&#13;
        Auction storage auction = tokenIdToAuction[_tokenId];&#13;
&#13;
        // Revert the call if the bidding&#13;
        // period is over.&#13;
        require(auction.live);&#13;
        require(auction.endTime &gt; block.timestamp);&#13;
&#13;
        // If the bid is not higher, send the&#13;
        // money back.&#13;
        require(msg.value &gt; auction.highestBid);&#13;
&#13;
        if (auction.highestBidder != 0) {&#13;
            // Sending back the money by simply using&#13;
            // highestBidder.send(highestBid) is a security risk&#13;
            // because it could execute an untrusted contract.&#13;
            // It is always safer to let the recipients&#13;
            // withdraw their money themselves.&#13;
            pendingReturns[auction.highestBidder] += auction.highestBid;&#13;
        }&#13;
        &#13;
        auction.highestBidder = msg.sender;&#13;
        auction.highestBid = msg.value;&#13;
&#13;
        HighestBidIncreased(_tokenId, msg.sender, msg.value);&#13;
    }&#13;
&#13;
    /// Withdraw a bid that was overbid.&#13;
    function withdraw() external returns (bool) {&#13;
        uint amount = pendingReturns[msg.sender];&#13;
        if (amount &gt; 0) {&#13;
            // It is important to set this to zero because the recipient&#13;
            // can call this function again as part of the receiving call&#13;
            // before `send` returns.&#13;
            pendingReturns[msg.sender] = 0;&#13;
&#13;
            if (!msg.sender.send(amount)) {&#13;
                // No need to call throw here, just reset the amount owing&#13;
                pendingReturns[msg.sender] = amount;&#13;
                return false;&#13;
            }&#13;
        }&#13;
        return true;&#13;
    }&#13;
&#13;
    // /// End the auction and send the highest bid&#13;
    // /// to the beneficiary.&#13;
    function endAuction(uint256 _tokenId) external {&#13;
        // It is a good guideline to structure functions that interact&#13;
        // with other contracts (i.e. they call functions or send Ether)&#13;
        // into three phases:&#13;
        // 1. checking conditions&#13;
        // 2. performing actions (potentially changing conditions)&#13;
        // 3. interacting with other contracts&#13;
        // If these phases are mixed up, the other contract could call&#13;
        // back into the current contract and modify the state or cause&#13;
        // effects (ether payout) to be performed multiple times.&#13;
        // If functions called internally include interaction with external&#13;
        // contracts, they also have to be considered interaction with&#13;
        // external contracts.&#13;
&#13;
        Auction storage auction = tokenIdToAuction[_tokenId];&#13;
&#13;
        // 1. Conditions&#13;
        require(auction.endTime &lt; block.timestamp);&#13;
        require(auction.live); // this function has already been called&#13;
&#13;
        // 2. Effects&#13;
        auction.live = false;&#13;
        AuctionEnded(_tokenId, auction.highestBidder, auction.highestBid);&#13;
&#13;
        // 3. Interaction&#13;
        address owner = pixelIndexToOwner[_tokenId];&#13;
        // transfer money without &#13;
        uint amount = auction.highestBid * 9 / 10;&#13;
        pendingReturns[owner] += amount;&#13;
        authorityBalance += (auction.highestBid - amount);&#13;
        // transfer token&#13;
        _transfer(owner, auction.highestBidder, _tokenId);&#13;
&#13;
       &#13;
    }&#13;
&#13;
    // // Events that will be fired on changes.&#13;
    event AuctionStarted(uint256 _tokenId);&#13;
    event HighestBidIncreased(uint256 _tokenId, address bidder, uint amount);&#13;
    event AuctionEnded(uint256 _tokenId, address winner, uint amount);&#13;
&#13;
&#13;
    /// @dev Returns auction info for an NFT on auction.&#13;
    /// @param _tokenId - ID of NFT on auction.&#13;
    function getAuction(uint256 _tokenId)&#13;
        external&#13;
        view&#13;
        returns&#13;
    (&#13;
        address highestBidder,&#13;
        uint highestBid,&#13;
        uint endTime,&#13;
        bool live&#13;
    ) {&#13;
        Auction storage auction = tokenIdToAuction[_tokenId];&#13;
        return (&#13;
            auction.highestBidder,&#13;
            auction.highestBid,&#13;
            auction.endTime,&#13;
            auction.live&#13;
        );&#13;
    }&#13;
&#13;
    /// @dev Returns the current price of an auction.&#13;
    /// @param _tokenId - ID of the token price we are checking.&#13;
    function getHighestBid(uint256 _tokenId)&#13;
        external&#13;
        view&#13;
        returns (uint256)&#13;
    {&#13;
        Auction storage auction = tokenIdToAuction[_tokenId];&#13;
        return auction.highestBid;&#13;
    }&#13;
}&#13;
&#13;
&#13;
/// @title PixelCore: Pixels in the blockchain&#13;
/// @author Oliver Schneider &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="335a5d555c73435a4b565f505c5a5d401d5a5c">[email protected]</a>&gt; (https://pixelcoins.io), based on Axiom Zen (https://www.axiomzen.co)&#13;
/// @dev The main PixelCoins contract&#13;
contract PixelCore is PixelAuction {&#13;
&#13;
    // Set in case the core contract is broken and an upgrade is required&#13;
    address public newContractAddress;&#13;
&#13;
    /// @notice Creates the main PixelCore smart contract instance.&#13;
    function PixelCore() public {&#13;
        // the creator of the contract is the initial authority&#13;
        authorityAddress = msg.sender;&#13;
    }&#13;
&#13;
    /// @dev Used to mark the smart contract as upgraded, in case there is a serious&#13;
    ///  breaking bug. This method does nothing but keep track of the new contract and&#13;
    ///  emit a message indicating that the new address is set. It's up to clients of this&#13;
    ///  contract to update to the new contract address in that case. (This contract will&#13;
    ///  be paused indefinitely if such an upgrade takes place.)&#13;
    /// @param _v2Address new address&#13;
    function setNewAddress(address _v2Address) external onlyAuthority {&#13;
        newContractAddress = _v2Address;&#13;
        ContractUpgrade(_v2Address);&#13;
    }&#13;
&#13;
    // @dev Allows the authority to capture the balance available to the contract.&#13;
    function withdrawBalance() external onlyAuthority returns (bool) {&#13;
        uint amount = authorityBalance;&#13;
        if (amount &gt; 0) {&#13;
            authorityBalance = 0;&#13;
            if (!authorityAddress.send(amount)) {&#13;
                authorityBalance = amount;&#13;
                return false;&#13;
            }&#13;
        }&#13;
        return true;&#13;
    }&#13;
}