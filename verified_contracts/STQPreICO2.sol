/*************************************************************************
 * This contract has been merged with solidify
 * https://github.com/tiesnetwork/solidify
 *************************************************************************/
 
 pragma solidity 0.4.15;

/*************************************************************************
 * import "./STQPreICOBase.sol" : start
 *************************************************************************/

/*************************************************************************
 * import "./crowdsale/SimpleCrowdsaleBase.sol" : start
 *************************************************************************/

/*************************************************************************
 * import "../security/ArgumentsChecker.sol" : start
 *************************************************************************/


/// @title utility methods and modifiers of arguments validation
contract ArgumentsChecker {

    /// @dev check which prevents short address attack
    modifier payloadSizeIs(uint size) {
       require(msg.data.length == size + 4 /* function selector */);
       _;
    }

    /// @dev check that address is valid
    modifier validAddress(address addr) {
        require(addr != address(0));
        _;
    }
}
/*************************************************************************
 * import "../security/ArgumentsChecker.sol" : end
 *************************************************************************/
/*************************************************************************
 * import "../token/MintableMultiownedToken.sol" : start
 *************************************************************************/

/*************************************************************************
 * import "../ownership/MultiownedControlled.sol" : start
 *************************************************************************/

/*************************************************************************
 * import "./multiowned.sol" : start
 *************************************************************************/// Code taken from https://github.com/ethereum/dapp-bin/blob/master/wallet/wallet.sol
// Audit, refactoring and improvements by github.com/Eenae

// @authors:
// Gav Wood <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="caad8aafbea2aeafbce4a9a5a7">[emailÂ protected]</a>&gt;&#13;
// inheritable "property" contract that enables methods to be protected by requiring the acquiescence of either a&#13;
// single, or, crucially, each of a number of, designated owners.&#13;
// usage:&#13;
// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by&#13;
// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the&#13;
// interior is executed.&#13;
&#13;
&#13;
&#13;
&#13;
/// note: during any ownership changes all pending operations (waiting for more signatures) are cancelled&#13;
// TODO acceptOwnership&#13;
contract multiowned {&#13;
&#13;
	// TYPES&#13;
&#13;
    // struct for the status of a pending operation.&#13;
    struct MultiOwnedOperationPendingState {&#13;
        // count of confirmations needed&#13;
        uint yetNeeded;&#13;
&#13;
        // bitmap of confirmations where owner #ownerIndex's decision corresponds to 2**ownerIndex bit&#13;
        uint ownersDone;&#13;
&#13;
        // position of this operation key in m_multiOwnedPendingIndex&#13;
        uint index;&#13;
    }&#13;
&#13;
	// EVENTS&#13;
&#13;
    event Confirmation(address owner, bytes32 operation);&#13;
    event Revoke(address owner, bytes32 operation);&#13;
    event FinalConfirmation(address owner, bytes32 operation);&#13;
&#13;
    // some others are in the case of an owner changing.&#13;
    event OwnerChanged(address oldOwner, address newOwner);&#13;
    event OwnerAdded(address newOwner);&#13;
    event OwnerRemoved(address oldOwner);&#13;
&#13;
    // the last one is emitted if the required signatures change&#13;
    event RequirementChanged(uint newRequirement);&#13;
&#13;
	// MODIFIERS&#13;
&#13;
    // simple single-sig function modifier.&#13;
    modifier onlyowner {&#13;
        require(isOwner(msg.sender));&#13;
        _;&#13;
    }&#13;
    // multi-sig function modifier: the operation must have an intrinsic hash in order&#13;
    // that later attempts can be realised as the same underlying operation and&#13;
    // thus count as confirmations.&#13;
    modifier onlymanyowners(bytes32 _operation) {&#13;
        if (confirmAndCheck(_operation)) {&#13;
            _;&#13;
        }&#13;
        // Even if required number of confirmations has't been collected yet,&#13;
        // we can't throw here - because changes to the state have to be preserved.&#13;
        // But, confirmAndCheck itself will throw in case sender is not an owner.&#13;
    }&#13;
&#13;
    modifier validNumOwners(uint _numOwners) {&#13;
        require(_numOwners &gt; 0 &amp;&amp; _numOwners &lt;= c_maxOwners);&#13;
        _;&#13;
    }&#13;
&#13;
    modifier multiOwnedValidRequirement(uint _required, uint _numOwners) {&#13;
        require(_required &gt; 0 &amp;&amp; _required &lt;= _numOwners);&#13;
        _;&#13;
    }&#13;
&#13;
    modifier ownerExists(address _address) {&#13;
        require(isOwner(_address));&#13;
        _;&#13;
    }&#13;
&#13;
    modifier ownerDoesNotExist(address _address) {&#13;
        require(!isOwner(_address));&#13;
        _;&#13;
    }&#13;
&#13;
    modifier multiOwnedOperationIsActive(bytes32 _operation) {&#13;
        require(isOperationActive(_operation));&#13;
        _;&#13;
    }&#13;
&#13;
	// METHODS&#13;
&#13;
    // constructor is given number of sigs required to do protected "onlymanyowners" transactions&#13;
    // as well as the selection of addresses capable of confirming them (msg.sender is not added to the owners!).&#13;
    function multiowned(address[] _owners, uint _required)&#13;
        validNumOwners(_owners.length)&#13;
        multiOwnedValidRequirement(_required, _owners.length)&#13;
    {&#13;
        assert(c_maxOwners &lt;= 255);&#13;
&#13;
        m_numOwners = _owners.length;&#13;
        m_multiOwnedRequired = _required;&#13;
&#13;
        for (uint i = 0; i &lt; _owners.length; ++i)&#13;
        {&#13;
            address owner = _owners[i];&#13;
            // invalid and duplicate addresses are not allowed&#13;
            require(0 != owner &amp;&amp; !isOwner(owner) /* not isOwner yet! */);&#13;
&#13;
            uint currentOwnerIndex = checkOwnerIndex(i + 1 /* first slot is unused */);&#13;
            m_owners[currentOwnerIndex] = owner;&#13;
            m_ownerIndex[owner] = currentOwnerIndex;&#13;
        }&#13;
&#13;
        assertOwnersAreConsistent();&#13;
    }&#13;
&#13;
    /// @notice replaces an owner `_from` with another `_to`.&#13;
    /// @param _from address of owner to replace&#13;
    /// @param _to address of new owner&#13;
    // All pending operations will be canceled!&#13;
    function changeOwner(address _from, address _to)&#13;
        external&#13;
        ownerExists(_from)&#13;
        ownerDoesNotExist(_to)&#13;
        onlymanyowners(sha3(msg.data))&#13;
    {&#13;
        assertOwnersAreConsistent();&#13;
&#13;
        clearPending();&#13;
        uint ownerIndex = checkOwnerIndex(m_ownerIndex[_from]);&#13;
        m_owners[ownerIndex] = _to;&#13;
        m_ownerIndex[_from] = 0;&#13;
        m_ownerIndex[_to] = ownerIndex;&#13;
&#13;
        assertOwnersAreConsistent();&#13;
        OwnerChanged(_from, _to);&#13;
    }&#13;
&#13;
    /// @notice adds an owner&#13;
    /// @param _owner address of new owner&#13;
    // All pending operations will be canceled!&#13;
    function addOwner(address _owner)&#13;
        external&#13;
        ownerDoesNotExist(_owner)&#13;
        validNumOwners(m_numOwners + 1)&#13;
        onlymanyowners(sha3(msg.data))&#13;
    {&#13;
        assertOwnersAreConsistent();&#13;
&#13;
        clearPending();&#13;
        m_numOwners++;&#13;
        m_owners[m_numOwners] = _owner;&#13;
        m_ownerIndex[_owner] = checkOwnerIndex(m_numOwners);&#13;
&#13;
        assertOwnersAreConsistent();&#13;
        OwnerAdded(_owner);&#13;
    }&#13;
&#13;
    /// @notice removes an owner&#13;
    /// @param _owner address of owner to remove&#13;
    // All pending operations will be canceled!&#13;
    function removeOwner(address _owner)&#13;
        external&#13;
        ownerExists(_owner)&#13;
        validNumOwners(m_numOwners - 1)&#13;
        multiOwnedValidRequirement(m_multiOwnedRequired, m_numOwners - 1)&#13;
        onlymanyowners(sha3(msg.data))&#13;
    {&#13;
        assertOwnersAreConsistent();&#13;
&#13;
        clearPending();&#13;
        uint ownerIndex = checkOwnerIndex(m_ownerIndex[_owner]);&#13;
        m_owners[ownerIndex] = 0;&#13;
        m_ownerIndex[_owner] = 0;&#13;
        //make sure m_numOwners is equal to the number of owners and always points to the last owner&#13;
        reorganizeOwners();&#13;
&#13;
        assertOwnersAreConsistent();&#13;
        OwnerRemoved(_owner);&#13;
    }&#13;
&#13;
    /// @notice changes the required number of owner signatures&#13;
    /// @param _newRequired new number of signatures required&#13;
    // All pending operations will be canceled!&#13;
    function changeRequirement(uint _newRequired)&#13;
        external&#13;
        multiOwnedValidRequirement(_newRequired, m_numOwners)&#13;
        onlymanyowners(sha3(msg.data))&#13;
    {&#13;
        m_multiOwnedRequired = _newRequired;&#13;
        clearPending();&#13;
        RequirementChanged(_newRequired);&#13;
    }&#13;
&#13;
    /// @notice Gets an owner by 0-indexed position&#13;
    /// @param ownerIndex 0-indexed owner position&#13;
    function getOwner(uint ownerIndex) public constant returns (address) {&#13;
        return m_owners[ownerIndex + 1];&#13;
    }&#13;
&#13;
    /// @notice Gets owners&#13;
    /// @return memory array of owners&#13;
    function getOwners() public constant returns (address[]) {&#13;
        address[] memory result = new address[](m_numOwners);&#13;
        for (uint i = 0; i &lt; m_numOwners; i++)&#13;
            result[i] = getOwner(i);&#13;
&#13;
        return result;&#13;
    }&#13;
&#13;
    /// @notice checks if provided address is an owner address&#13;
    /// @param _addr address to check&#13;
    /// @return true if it's an owner&#13;
    function isOwner(address _addr) public constant returns (bool) {&#13;
        return m_ownerIndex[_addr] &gt; 0;&#13;
    }&#13;
&#13;
    /// @notice Tests ownership of the current caller.&#13;
    /// @return true if it's an owner&#13;
    // It's advisable to call it by new owner to make sure that the same erroneous address is not copy-pasted to&#13;
    // addOwner/changeOwner and to isOwner.&#13;
    function amIOwner() external constant onlyowner returns (bool) {&#13;
        return true;&#13;
    }&#13;
&#13;
    /// @notice Revokes a prior confirmation of the given operation&#13;
    /// @param _operation operation value, typically sha3(msg.data)&#13;
    function revoke(bytes32 _operation)&#13;
        external&#13;
        multiOwnedOperationIsActive(_operation)&#13;
        onlyowner&#13;
    {&#13;
        uint ownerIndexBit = makeOwnerBitmapBit(msg.sender);&#13;
        var pending = m_multiOwnedPending[_operation];&#13;
        require(pending.ownersDone &amp; ownerIndexBit &gt; 0);&#13;
&#13;
        assertOperationIsConsistent(_operation);&#13;
&#13;
        pending.yetNeeded++;&#13;
        pending.ownersDone -= ownerIndexBit;&#13;
&#13;
        assertOperationIsConsistent(_operation);&#13;
        Revoke(msg.sender, _operation);&#13;
    }&#13;
&#13;
    /// @notice Checks if owner confirmed given operation&#13;
    /// @param _operation operation value, typically sha3(msg.data)&#13;
    /// @param _owner an owner address&#13;
    function hasConfirmed(bytes32 _operation, address _owner)&#13;
        external&#13;
        constant&#13;
        multiOwnedOperationIsActive(_operation)&#13;
        ownerExists(_owner)&#13;
        returns (bool)&#13;
    {&#13;
        return !(m_multiOwnedPending[_operation].ownersDone &amp; makeOwnerBitmapBit(_owner) == 0);&#13;
    }&#13;
&#13;
    // INTERNAL METHODS&#13;
&#13;
    function confirmAndCheck(bytes32 _operation)&#13;
        private&#13;
        onlyowner&#13;
        returns (bool)&#13;
    {&#13;
        if (512 == m_multiOwnedPendingIndex.length)&#13;
            // In case m_multiOwnedPendingIndex grows too much we have to shrink it: otherwise at some point&#13;
            // we won't be able to do it because of block gas limit.&#13;
            // Yes, pending confirmations will be lost. Dont see any security or stability implications.&#13;
            // TODO use more graceful approach like compact or removal of clearPending completely&#13;
            clearPending();&#13;
&#13;
        var pending = m_multiOwnedPending[_operation];&#13;
&#13;
        // if we're not yet working on this operation, switch over and reset the confirmation status.&#13;
        if (! isOperationActive(_operation)) {&#13;
            // reset count of confirmations needed.&#13;
            pending.yetNeeded = m_multiOwnedRequired;&#13;
            // reset which owners have confirmed (none) - set our bitmap to 0.&#13;
            pending.ownersDone = 0;&#13;
            pending.index = m_multiOwnedPendingIndex.length++;&#13;
            m_multiOwnedPendingIndex[pending.index] = _operation;&#13;
            assertOperationIsConsistent(_operation);&#13;
        }&#13;
&#13;
        // determine the bit to set for this owner.&#13;
        uint ownerIndexBit = makeOwnerBitmapBit(msg.sender);&#13;
        // make sure we (the message sender) haven't confirmed this operation previously.&#13;
        if (pending.ownersDone &amp; ownerIndexBit == 0) {&#13;
            // ok - check if count is enough to go ahead.&#13;
            assert(pending.yetNeeded &gt; 0);&#13;
            if (pending.yetNeeded == 1) {&#13;
                // enough confirmations: reset and run interior.&#13;
                delete m_multiOwnedPendingIndex[m_multiOwnedPending[_operation].index];&#13;
                delete m_multiOwnedPending[_operation];&#13;
                FinalConfirmation(msg.sender, _operation);&#13;
                return true;&#13;
            }&#13;
            else&#13;
            {&#13;
                // not enough: record that this owner in particular confirmed.&#13;
                pending.yetNeeded--;&#13;
                pending.ownersDone |= ownerIndexBit;&#13;
                assertOperationIsConsistent(_operation);&#13;
                Confirmation(msg.sender, _operation);&#13;
            }&#13;
        }&#13;
    }&#13;
&#13;
    // Reclaims free slots between valid owners in m_owners.&#13;
    // TODO given that its called after each removal, it could be simplified.&#13;
    function reorganizeOwners() private {&#13;
        uint free = 1;&#13;
        while (free &lt; m_numOwners)&#13;
        {&#13;
            // iterating to the first free slot from the beginning&#13;
            while (free &lt; m_numOwners &amp;&amp; m_owners[free] != 0) free++;&#13;
&#13;
            // iterating to the first occupied slot from the end&#13;
            while (m_numOwners &gt; 1 &amp;&amp; m_owners[m_numOwners] == 0) m_numOwners--;&#13;
&#13;
            // swap, if possible, so free slot is located at the end after the swap&#13;
            if (free &lt; m_numOwners &amp;&amp; m_owners[m_numOwners] != 0 &amp;&amp; m_owners[free] == 0)&#13;
            {&#13;
                // owners between swapped slots should't be renumbered - that saves a lot of gas&#13;
                m_owners[free] = m_owners[m_numOwners];&#13;
                m_ownerIndex[m_owners[free]] = free;&#13;
                m_owners[m_numOwners] = 0;&#13;
            }&#13;
        }&#13;
    }&#13;
&#13;
    function clearPending() private onlyowner {&#13;
        uint length = m_multiOwnedPendingIndex.length;&#13;
        // TODO block gas limit&#13;
        for (uint i = 0; i &lt; length; ++i) {&#13;
            if (m_multiOwnedPendingIndex[i] != 0)&#13;
                delete m_multiOwnedPending[m_multiOwnedPendingIndex[i]];&#13;
        }&#13;
        delete m_multiOwnedPendingIndex;&#13;
    }&#13;
&#13;
    function checkOwnerIndex(uint ownerIndex) private constant returns (uint) {&#13;
        assert(0 != ownerIndex &amp;&amp; ownerIndex &lt;= c_maxOwners);&#13;
        return ownerIndex;&#13;
    }&#13;
&#13;
    function makeOwnerBitmapBit(address owner) private constant returns (uint) {&#13;
        uint ownerIndex = checkOwnerIndex(m_ownerIndex[owner]);&#13;
        return 2 ** ownerIndex;&#13;
    }&#13;
&#13;
    function isOperationActive(bytes32 _operation) private constant returns (bool) {&#13;
        return 0 != m_multiOwnedPending[_operation].yetNeeded;&#13;
    }&#13;
&#13;
&#13;
    function assertOwnersAreConsistent() private constant {&#13;
        assert(m_numOwners &gt; 0);&#13;
        assert(m_numOwners &lt;= c_maxOwners);&#13;
        assert(m_owners[0] == 0);&#13;
        assert(0 != m_multiOwnedRequired &amp;&amp; m_multiOwnedRequired &lt;= m_numOwners);&#13;
    }&#13;
&#13;
    function assertOperationIsConsistent(bytes32 _operation) private constant {&#13;
        var pending = m_multiOwnedPending[_operation];&#13;
        assert(0 != pending.yetNeeded);&#13;
        assert(m_multiOwnedPendingIndex[pending.index] == _operation);&#13;
        assert(pending.yetNeeded &lt;= m_multiOwnedRequired);&#13;
    }&#13;
&#13;
&#13;
   	// FIELDS&#13;
&#13;
    uint constant c_maxOwners = 250;&#13;
&#13;
    // the number of owners that must confirm the same operation before it is run.&#13;
    uint public m_multiOwnedRequired;&#13;
&#13;
&#13;
    // pointer used to find a free slot in m_owners&#13;
    uint public m_numOwners;&#13;
&#13;
    // list of owners (addresses),&#13;
    // slot 0 is unused so there are no owner which index is 0.&#13;
    // TODO could we save space at the end of the array for the common case of &lt;10 owners? and should we?&#13;
    address[256] internal m_owners;&#13;
&#13;
    // index on the list of owners to allow reverse lookup: owner address =&gt; index in m_owners&#13;
    mapping(address =&gt; uint) internal m_ownerIndex;&#13;
&#13;
&#13;
    // the ongoing operations.&#13;
    mapping(bytes32 =&gt; MultiOwnedOperationPendingState) internal m_multiOwnedPending;&#13;
    bytes32[] internal m_multiOwnedPendingIndex;&#13;
}&#13;
/*************************************************************************&#13;
 * import "./multiowned.sol" : end&#13;
 *************************************************************************/&#13;
&#13;
&#13;
/**&#13;
 * @title Contract which is owned by owners and operated by controller.&#13;
 *&#13;
 * @notice Provides a way to set up an entity (typically other contract) entitled to control actions of this contract.&#13;
 * Controller is set up by owners or during construction.&#13;
 *&#13;
 * @dev controller check is performed by onlyController modifier.&#13;
 */&#13;
contract MultiownedControlled is multiowned {&#13;
&#13;
    event ControllerSet(address controller);&#13;
    event ControllerRetired(address was);&#13;
&#13;
&#13;
    modifier onlyController {&#13;
        require(msg.sender == m_controller);&#13;
        _;&#13;
    }&#13;
&#13;
&#13;
    // PUBLIC interface&#13;
&#13;
    function MultiownedControlled(address[] _owners, uint _signaturesRequired, address _controller)&#13;
        multiowned(_owners, _signaturesRequired)&#13;
    {&#13;
        m_controller = _controller;&#13;
        ControllerSet(m_controller);&#13;
    }&#13;
&#13;
    /// @dev sets the controller&#13;
    function setController(address _controller) external onlymanyowners(sha3(msg.data)) {&#13;
        m_controller = _controller;&#13;
        ControllerSet(m_controller);&#13;
    }&#13;
&#13;
    /// @dev ability for controller to step down&#13;
    function detachController() external onlyController {&#13;
        address was = m_controller;&#13;
        m_controller = address(0);&#13;
        ControllerRetired(was);&#13;
    }&#13;
&#13;
&#13;
    // FIELDS&#13;
&#13;
    /// @notice address of entity entitled to mint new tokens&#13;
    address public m_controller;&#13;
}&#13;
/*************************************************************************&#13;
 * import "../ownership/MultiownedControlled.sol" : end&#13;
 *************************************************************************/&#13;
/*************************************************************************&#13;
 * import "zeppelin-solidity/contracts/token/StandardToken.sol" : start&#13;
 *************************************************************************/&#13;
&#13;
&#13;
/*************************************************************************&#13;
 * import "./BasicToken.sol" : start&#13;
 *************************************************************************/&#13;
&#13;
&#13;
/*************************************************************************&#13;
 * import "./ERC20Basic.sol" : start&#13;
 *************************************************************************/&#13;
&#13;
&#13;
/**&#13;
 * @title ERC20Basic&#13;
 * @dev Simpler version of ERC20 interface&#13;
 * @dev see https://github.com/ethereum/EIPs/issues/179&#13;
 */&#13;
contract ERC20Basic {&#13;
  uint256 public totalSupply;&#13;
  function balanceOf(address who) constant returns (uint256);&#13;
  function transfer(address to, uint256 value) returns (bool);&#13;
  event Transfer(address indexed from, address indexed to, uint256 value);&#13;
}&#13;
/*************************************************************************&#13;
 * import "./ERC20Basic.sol" : end&#13;
 *************************************************************************/&#13;
/*************************************************************************&#13;
 * import "../math/SafeMath.sol" : start&#13;
 *************************************************************************/&#13;
&#13;
&#13;
/**&#13;
 * @title SafeMath&#13;
 * @dev Math operations with safety checks that throw on error&#13;
 */&#13;
library SafeMath {&#13;
  function mul(uint256 a, uint256 b) internal constant returns (uint256) {&#13;
    uint256 c = a * b;&#13;
    assert(a == 0 || c / a == b);&#13;
    return c;&#13;
  }&#13;
&#13;
  function div(uint256 a, uint256 b) internal constant returns (uint256) {&#13;
    // assert(b &gt; 0); // Solidity automatically throws when dividing by 0&#13;
    uint256 c = a / b;&#13;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold&#13;
    return c;&#13;
  }&#13;
&#13;
  function sub(uint256 a, uint256 b) internal constant returns (uint256) {&#13;
    assert(b &lt;= a);&#13;
    return a - b;&#13;
  }&#13;
&#13;
  function add(uint256 a, uint256 b) internal constant returns (uint256) {&#13;
    uint256 c = a + b;&#13;
    assert(c &gt;= a);&#13;
    return c;&#13;
  }&#13;
}&#13;
/*************************************************************************&#13;
 * import "../math/SafeMath.sol" : end&#13;
 *************************************************************************/&#13;
&#13;
&#13;
/**&#13;
 * @title Basic token&#13;
 * @dev Basic version of StandardToken, with no allowances. &#13;
 */&#13;
contract BasicToken is ERC20Basic {&#13;
  using SafeMath for uint256;&#13;
&#13;
  mapping(address =&gt; uint256) balances;&#13;
&#13;
  /**&#13;
  * @dev transfer token for a specified address&#13;
  * @param _to The address to transfer to.&#13;
  * @param _value The amount to be transferred.&#13;
  */&#13;
  function transfer(address _to, uint256 _value) returns (bool) {&#13;
    balances[msg.sender] = balances[msg.sender].sub(_value);&#13;
    balances[_to] = balances[_to].add(_value);&#13;
    Transfer(msg.sender, _to, _value);&#13;
    return true;&#13;
  }&#13;
&#13;
  /**&#13;
  * @dev Gets the balance of the specified address.&#13;
  * @param _owner The address to query the the balance of. &#13;
  * @return An uint256 representing the amount owned by the passed address.&#13;
  */&#13;
  function balanceOf(address _owner) constant returns (uint256 balance) {&#13;
    return balances[_owner];&#13;
  }&#13;
&#13;
}&#13;
/*************************************************************************&#13;
 * import "./BasicToken.sol" : end&#13;
 *************************************************************************/&#13;
/*************************************************************************&#13;
 * import "./ERC20.sol" : start&#13;
 *************************************************************************/&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
/**&#13;
 * @title ERC20 interface&#13;
 * @dev see https://github.com/ethereum/EIPs/issues/20&#13;
 */&#13;
contract ERC20 is ERC20Basic {&#13;
  function allowance(address owner, address spender) constant returns (uint256);&#13;
  function transferFrom(address from, address to, uint256 value) returns (bool);&#13;
  function approve(address spender, uint256 value) returns (bool);&#13;
  event Approval(address indexed owner, address indexed spender, uint256 value);&#13;
}&#13;
/*************************************************************************&#13;
 * import "./ERC20.sol" : end&#13;
 *************************************************************************/&#13;
&#13;
&#13;
/**&#13;
 * @title Standard ERC20 token&#13;
 *&#13;
 * @dev Implementation of the basic standard token.&#13;
 * @dev https://github.com/ethereum/EIPs/issues/20&#13;
 * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol&#13;
 */&#13;
contract StandardToken is ERC20, BasicToken {&#13;
&#13;
  mapping (address =&gt; mapping (address =&gt; uint256)) allowed;&#13;
&#13;
&#13;
  /**&#13;
   * @dev Transfer tokens from one address to another&#13;
   * @param _from address The address which you want to send tokens from&#13;
   * @param _to address The address which you want to transfer to&#13;
   * @param _value uint256 the amout of tokens to be transfered&#13;
   */&#13;
  function transferFrom(address _from, address _to, uint256 _value) returns (bool) {&#13;
    var _allowance = allowed[_from][msg.sender];&#13;
&#13;
    // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met&#13;
    // require (_value &lt;= _allowance);&#13;
&#13;
    balances[_to] = balances[_to].add(_value);&#13;
    balances[_from] = balances[_from].sub(_value);&#13;
    allowed[_from][msg.sender] = _allowance.sub(_value);&#13;
    Transfer(_from, _to, _value);&#13;
    return true;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Aprove the passed address to spend the specified amount of tokens on behalf of msg.sender.&#13;
   * @param _spender The address which will spend the funds.&#13;
   * @param _value The amount of tokens to be spent.&#13;
   */&#13;
  function approve(address _spender, uint256 _value) returns (bool) {&#13;
&#13;
    // To change the approve amount you first have to reduce the addresses`&#13;
    //  allowance to zero by calling `approve(_spender, 0)` if it is not&#13;
    //  already 0 to mitigate the race condition described here:&#13;
    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729&#13;
    require((_value == 0) || (allowed[msg.sender][_spender] == 0));&#13;
&#13;
    allowed[msg.sender][_spender] = _value;&#13;
    Approval(msg.sender, _spender, _value);&#13;
    return true;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Function to check the amount of tokens that an owner allowed to a spender.&#13;
   * @param _owner address The address which owns the funds.&#13;
   * @param _spender address The address which will spend the funds.&#13;
   * @return A uint256 specifing the amount of tokens still avaible for the spender.&#13;
   */&#13;
  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {&#13;
    return allowed[_owner][_spender];&#13;
  }&#13;
&#13;
}&#13;
/*************************************************************************&#13;
 * import "zeppelin-solidity/contracts/token/StandardToken.sol" : end&#13;
 *************************************************************************/&#13;
&#13;
&#13;
/// @title StandardToken which can be minted by another contract.&#13;
contract MintableMultiownedToken is MultiownedControlled, StandardToken {&#13;
&#13;
    /// @dev parameters of an extra token emission&#13;
    struct EmissionInfo {&#13;
        // tokens created&#13;
        uint256 created;&#13;
&#13;
        // totalSupply at the moment of emission (excluding created tokens)&#13;
        uint256 totalSupplyWas;&#13;
    }&#13;
&#13;
    event Mint(address indexed to, uint256 amount);&#13;
    event Emission(uint256 tokensCreated, uint256 totalSupplyWas, uint256 time);&#13;
    event Dividend(address indexed to, uint256 amount);&#13;
&#13;
&#13;
    // PUBLIC interface&#13;
&#13;
    function MintableMultiownedToken(address[] _owners, uint _signaturesRequired, address _minter)&#13;
        MultiownedControlled(_owners, _signaturesRequired, _minter)&#13;
    {&#13;
        dividendsPool = this;   // or any other special unforgeable value, actually&#13;
&#13;
        // emission #0 is a dummy: because of default value 0 in m_lastAccountEmission&#13;
        m_emissions.push(EmissionInfo({created: 0, totalSupplyWas: 0}));&#13;
    }&#13;
&#13;
    /// @notice Request dividends for current account.&#13;
    function requestDividends() external {&#13;
        payDividendsTo(msg.sender);&#13;
    }&#13;
&#13;
    /// @notice hook on standard ERC20#transfer to pay dividends&#13;
    function transfer(address _to, uint256 _value) returns (bool) {&#13;
        payDividendsTo(msg.sender);&#13;
        payDividendsTo(_to);&#13;
        return super.transfer(_to, _value);&#13;
    }&#13;
&#13;
    /// @notice hook on standard ERC20#transferFrom to pay dividends&#13;
    function transferFrom(address _from, address _to, uint256 _value) returns (bool) {&#13;
        payDividendsTo(_from);&#13;
        payDividendsTo(_to);&#13;
        return super.transferFrom(_from, _to, _value);&#13;
    }&#13;
&#13;
    // Disabled: this could be undesirable because sum of (balanceOf() for each token owner) != totalSupply&#13;
    // (but: sum of (balances[owner] for each token owner) == totalSupply!).&#13;
    //&#13;
    // @notice hook on standard ERC20#balanceOf to take dividends into consideration&#13;
    // function balanceOf(address _owner) constant returns (uint256) {&#13;
    //     var (hasNewDividends, dividends) = calculateDividendsFor(_owner);&#13;
    //     return hasNewDividends ? super.balanceOf(_owner).add(dividends) : super.balanceOf(_owner);&#13;
    // }&#13;
&#13;
&#13;
    /// @dev mints new tokens&#13;
    function mint(address _to, uint256 _amount) external onlyController {&#13;
        require(m_externalMintingEnabled);&#13;
        payDividendsTo(_to);&#13;
        mintInternal(_to, _amount);&#13;
    }&#13;
&#13;
    /// @dev disables mint(), irreversible!&#13;
    function disableMinting() external onlyController {&#13;
        require(m_externalMintingEnabled);&#13;
        m_externalMintingEnabled = false;&#13;
    }&#13;
&#13;
&#13;
    // INTERNAL functions&#13;
&#13;
    /**&#13;
     * @notice Starts new token emission&#13;
     * @param _tokensCreated Amount of tokens to create&#13;
     * @dev Dividends are not distributed immediately as it could require billions of gas,&#13;
     * instead they are `pulled` by a holder from dividends pool account before any update to the holder account occurs.&#13;
     */&#13;
    function emissionInternal(uint256 _tokensCreated) internal {&#13;
        require(0 != _tokensCreated);&#13;
        require(_tokensCreated &lt; totalSupply / 2);  // otherwise it looks like an error&#13;
&#13;
        uint256 totalSupplyWas = totalSupply;&#13;
&#13;
        m_emissions.push(EmissionInfo({created: _tokensCreated, totalSupplyWas: totalSupplyWas}));&#13;
        mintInternal(dividendsPool, _tokensCreated);&#13;
&#13;
        Emission(_tokensCreated, totalSupplyWas, now);&#13;
    }&#13;
&#13;
    function mintInternal(address _to, uint256 _amount) internal {&#13;
        totalSupply = totalSupply.add(_amount);&#13;
        balances[_to] = balances[_to].add(_amount);&#13;
        Transfer(this, _to, _amount);&#13;
        Mint(_to, _amount);&#13;
    }&#13;
&#13;
    /// @dev adds dividends to the account _to&#13;
    function payDividendsTo(address _to) internal {&#13;
        var (hasNewDividends, dividends) = calculateDividendsFor(_to);&#13;
        if (!hasNewDividends)&#13;
            return;&#13;
&#13;
        if (0 != dividends) {&#13;
            balances[dividendsPool] = balances[dividendsPool].sub(dividends);&#13;
            balances[_to] = balances[_to].add(dividends);&#13;
            Transfer(dividendsPool, _to, dividends);&#13;
        }&#13;
        m_lastAccountEmission[_to] = getLastEmissionNum();&#13;
    }&#13;
&#13;
    /// @dev calculates dividends for the account _for&#13;
    /// @return (true if state has to be updated, dividend amount (could be 0!))&#13;
    function calculateDividendsFor(address _for) constant internal returns (bool hasNewDividends, uint dividends) {&#13;
        assert(_for != dividendsPool);  // no dividends for the pool!&#13;
&#13;
        uint256 lastEmissionNum = getLastEmissionNum();&#13;
        uint256 lastAccountEmissionNum = m_lastAccountEmission[_for];&#13;
        assert(lastAccountEmissionNum &lt;= lastEmissionNum);&#13;
        if (lastAccountEmissionNum == lastEmissionNum)&#13;
            return (false, 0);&#13;
&#13;
        uint256 initialBalance = balances[_for];    // beware of recursion!&#13;
        if (0 == initialBalance)&#13;
            return (true, 0);&#13;
&#13;
        uint256 balance = initialBalance;&#13;
        for (uint256 emissionToProcess = lastAccountEmissionNum + 1; emissionToProcess &lt;= lastEmissionNum; emissionToProcess++) {&#13;
            EmissionInfo storage emission = m_emissions[emissionToProcess];&#13;
            assert(0 != emission.created &amp;&amp; 0 != emission.totalSupplyWas);&#13;
&#13;
            uint256 dividend = balance.mul(emission.created).div(emission.totalSupplyWas);&#13;
            Dividend(_for, dividend);&#13;
&#13;
            balance = balance.add(dividend);&#13;
        }&#13;
&#13;
        return (true, balance.sub(initialBalance));&#13;
    }&#13;
&#13;
    function getLastEmissionNum() private constant returns (uint256) {&#13;
        return m_emissions.length - 1;&#13;
    }&#13;
&#13;
&#13;
    // FIELDS&#13;
&#13;
    /// @notice if this true then token is still externally mintable (but this flag does't affect emissions!)&#13;
    bool public m_externalMintingEnabled = true;&#13;
&#13;
    /// @dev internal address of dividends in balances mapping.&#13;
    address dividendsPool;&#13;
&#13;
    /// @notice record of issued dividend emissions&#13;
    EmissionInfo[] public m_emissions;&#13;
&#13;
    /// @dev for each token holder: last emission (index in m_emissions) which was processed for this holder&#13;
    mapping(address =&gt; uint256) m_lastAccountEmission;&#13;
}&#13;
/*************************************************************************&#13;
 * import "../token/MintableMultiownedToken.sol" : end&#13;
 *************************************************************************/&#13;
/*************************************************************************&#13;
 * import "./IInvestmentsWalletConnector.sol" : start&#13;
 *************************************************************************/&#13;
&#13;
/**&#13;
 * @title Interface for code which processes and stores investments.&#13;
 * @author Eenae&#13;
 */&#13;
contract IInvestmentsWalletConnector {&#13;
    /// @dev process and forward investment&#13;
    function storeInvestment(address investor, uint payment) internal;&#13;
&#13;
    /// @dev total investments amount stored using storeInvestment()&#13;
    function getTotalInvestmentsStored() internal constant returns (uint);&#13;
&#13;
    /// @dev called in case crowdsale succeeded&#13;
    function wcOnCrowdsaleSuccess() internal;&#13;
&#13;
    /// @dev called in case crowdsale failed&#13;
    function wcOnCrowdsaleFailure() internal;&#13;
}&#13;
/*************************************************************************&#13;
 * import "./IInvestmentsWalletConnector.sol" : end&#13;
 *************************************************************************/&#13;
/*************************************************************************&#13;
 * import "./ICrowdsaleStat.sol" : start&#13;
 *************************************************************************/&#13;
&#13;
/**&#13;
 * @title Basic crowdsale stat&#13;
 * @author Eenae&#13;
 */&#13;
contract ICrowdsaleStat {&#13;
&#13;
    /// @notice amount of funds collected in wei&#13;
    function getWeiCollected() public constant returns (uint);&#13;
&#13;
    /// @notice amount of tokens minted (NOT equal to totalSupply() in case token is reused!)&#13;
    function getTokenMinted() public constant returns (uint);&#13;
}&#13;
/*************************************************************************&#13;
 * import "./ICrowdsaleStat.sol" : end&#13;
 *************************************************************************/&#13;
/*************************************************************************&#13;
 * import "zeppelin-solidity/contracts/ReentrancyGuard.sol" : start&#13;
 *************************************************************************/&#13;
&#13;
/**&#13;
 * @title Helps contracts guard agains rentrancy attacks.&#13;
 * @author Remco Bloemen &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="3341565e505c7301">[emailÂ protected]</a>Ï.com&gt;&#13;
 * @notice If you mark a function `nonReentrant`, you should also&#13;
 * mark it `external`.&#13;
 */&#13;
contract ReentrancyGuard {&#13;
&#13;
  /**&#13;
   * @dev We use a single lock for the whole contract.&#13;
   */&#13;
  bool private rentrancy_lock = false;&#13;
&#13;
  /**&#13;
   * @dev Prevents a contract from calling itself, directly or indirectly.&#13;
   * @notice If you mark a function `nonReentrant`, you should also&#13;
   * mark it `external`. Calling one nonReentrant function from&#13;
   * another is not supported. Instead, you can implement a&#13;
   * `private` function doing the actual work, and a `external`&#13;
   * wrapper marked as `nonReentrant`.&#13;
   */&#13;
  modifier nonReentrant() {&#13;
    require(!rentrancy_lock);&#13;
    rentrancy_lock = true;&#13;
    _;&#13;
    rentrancy_lock = false;&#13;
  }&#13;
&#13;
}&#13;
/*************************************************************************&#13;
 * import "zeppelin-solidity/contracts/ReentrancyGuard.sol" : end&#13;
 *************************************************************************/&#13;
&#13;
&#13;
&#13;
/// @title Base contract for simple crowdsales&#13;
contract SimpleCrowdsaleBase is ArgumentsChecker, ReentrancyGuard, IInvestmentsWalletConnector, ICrowdsaleStat {&#13;
    using SafeMath for uint256;&#13;
&#13;
    event FundTransfer(address backer, uint amount, bool isContribution);&#13;
&#13;
    function SimpleCrowdsaleBase(address token)&#13;
        validAddress(token)&#13;
    {&#13;
        m_token = MintableMultiownedToken(token);&#13;
    }&#13;
&#13;
&#13;
    // PUBLIC interface: payments&#13;
&#13;
    // fallback function as a shortcut&#13;
    function() payable {&#13;
        require(0 == msg.data.length);&#13;
        buy();  // only internal call here!&#13;
    }&#13;
&#13;
    /// @notice crowdsale participation&#13;
    function buy() public payable {     // dont mark as external!&#13;
        buyInternal(msg.sender, msg.value, 0);&#13;
    }&#13;
&#13;
&#13;
    // INTERNAL&#13;
&#13;
    /// @dev payment processing&#13;
    function buyInternal(address investor, uint payment, uint extraBonuses)&#13;
        internal&#13;
        nonReentrant&#13;
    {&#13;
        require(payment &gt;= getMinInvestment());&#13;
        require(getCurrentTime() &gt;= getStartTime() || ! mustApplyTimeCheck(investor, payment) /* for final check */);&#13;
        if (getCurrentTime() &gt;= getEndTime())&#13;
            finish();&#13;
&#13;
        if (m_finished) {&#13;
            // saving provided gas&#13;
            investor.transfer(payment);&#13;
            return;&#13;
        }&#13;
&#13;
        uint startingWeiCollected = getWeiCollected();&#13;
        uint startingInvariant = this.balance.add(startingWeiCollected);&#13;
&#13;
        // return or update payment if needed&#13;
        uint paymentAllowed = getMaximumFunds().sub(getWeiCollected());&#13;
        assert(0 != paymentAllowed);&#13;
&#13;
        uint change;&#13;
        if (paymentAllowed &lt; payment) {&#13;
            change = payment.sub(paymentAllowed);&#13;
            payment = paymentAllowed;&#13;
        }&#13;
&#13;
        // issue tokens&#13;
        uint tokens = calculateTokens(investor, payment, extraBonuses);&#13;
        m_token.mint(investor, tokens);&#13;
        m_tokensMinted += tokens;&#13;
&#13;
        // record payment&#13;
        storeInvestment(investor, payment);&#13;
        assert(getWeiCollected() &lt;= getMaximumFunds() &amp;&amp; getWeiCollected() &gt; startingWeiCollected);&#13;
        FundTransfer(investor, payment, true);&#13;
&#13;
        if (getWeiCollected() == getMaximumFunds())&#13;
            finish();&#13;
&#13;
        if (change &gt; 0)&#13;
            investor.transfer(change);&#13;
&#13;
        assert(startingInvariant == this.balance.add(getWeiCollected()).add(change));&#13;
    }&#13;
&#13;
    function finish() internal {&#13;
        if (m_finished)&#13;
            return;&#13;
&#13;
        if (getWeiCollected() &gt;= getMinimumFunds())&#13;
            wcOnCrowdsaleSuccess();&#13;
        else&#13;
            wcOnCrowdsaleFailure();&#13;
&#13;
        m_finished = true;&#13;
    }&#13;
&#13;
&#13;
    // Other pluggables&#13;
&#13;
    /// @dev says if crowdsale time bounds must be checked&#13;
    function mustApplyTimeCheck(address /*investor*/, uint /*payment*/) constant internal returns (bool) {&#13;
        return true;&#13;
    }&#13;
&#13;
    /// @dev to be overridden in tests&#13;
    function getCurrentTime() internal constant returns (uint) {&#13;
        return now;&#13;
    }&#13;
&#13;
    /// @notice maximum investments to be accepted during pre-ICO&#13;
    function getMaximumFunds() internal constant returns (uint);&#13;
&#13;
    /// @notice minimum amount of funding to consider crowdsale as successful&#13;
    function getMinimumFunds() internal constant returns (uint);&#13;
&#13;
    /// @notice start time of the pre-ICO&#13;
    function getStartTime() internal constant returns (uint);&#13;
&#13;
    /// @notice end time of the pre-ICO&#13;
    function getEndTime() internal constant returns (uint);&#13;
&#13;
    /// @notice minimal amount of investment&#13;
    function getMinInvestment() public constant returns (uint) {&#13;
        return 10 finney;&#13;
    }&#13;
&#13;
    /// @dev calculates token amount for given investment&#13;
    function calculateTokens(address investor, uint payment, uint extraBonuses) internal constant returns (uint);&#13;
&#13;
&#13;
    // ICrowdsaleStat&#13;
&#13;
    function getWeiCollected() public constant returns (uint) {&#13;
        return getTotalInvestmentsStored();&#13;
    }&#13;
&#13;
    /// @notice amount of tokens minted (NOT equal to totalSupply() in case token is reused!)&#13;
    function getTokenMinted() public constant returns (uint) {&#13;
        return m_tokensMinted;&#13;
    }&#13;
&#13;
&#13;
    // FIELDS&#13;
&#13;
    /// @dev contract responsible for token accounting&#13;
    MintableMultiownedToken public m_token;&#13;
&#13;
    uint m_tokensMinted;&#13;
&#13;
    bool m_finished = false;&#13;
}&#13;
/*************************************************************************&#13;
 * import "./crowdsale/SimpleCrowdsaleBase.sol" : end&#13;
 *************************************************************************/&#13;
/*************************************************************************&#13;
 * import "./crowdsale/InvestmentAnalytics.sol" : start&#13;
 *************************************************************************/&#13;
&#13;
&#13;
&#13;
&#13;
/*&#13;
 * @title This is proxy for analytics. Target contract can be found at field m_analytics (see "read contract").&#13;
 * @author Eenae&#13;
&#13;
 * FIXME after fix of truffle issue #560: refactor to a separate contract file which uses InvestmentAnalytics interface&#13;
 */&#13;
contract AnalyticProxy {&#13;
&#13;
    function AnalyticProxy() {&#13;
        m_analytics = InvestmentAnalytics(msg.sender);&#13;
    }&#13;
&#13;
    /// @notice forward payment to analytics-capable contract&#13;
    function() payable {&#13;
        m_analytics.iaInvestedBy.value(msg.value)(msg.sender);&#13;
    }&#13;
&#13;
    InvestmentAnalytics public m_analytics;&#13;
}&#13;
&#13;
&#13;
/*&#13;
 * @title Mixin contract which supports different payment channels and provides analytical per-channel data.&#13;
 * @author Eenae&#13;
 */&#13;
contract InvestmentAnalytics {&#13;
    using SafeMath for uint256;&#13;
&#13;
    function InvestmentAnalytics(){&#13;
    }&#13;
&#13;
    /// @dev creates more payment channels, up to the limit but not exceeding gas stipend&#13;
    function createMorePaymentChannelsInternal(uint limit) internal returns (uint) {&#13;
        uint paymentChannelsCreated;&#13;
        for (uint i = 0; i &lt; limit; i++) {&#13;
            uint startingGas = msg.gas;&#13;
            /*&#13;
             * ~170k of gas per paymentChannel,&#13;
             * using gas price = 4Gwei 2k paymentChannels will cost ~1.4 ETH.&#13;
             */&#13;
&#13;
            address paymentChannel = new AnalyticProxy();&#13;
            m_validPaymentChannels[paymentChannel] = true;&#13;
            m_paymentChannels.push(paymentChannel);&#13;
            paymentChannelsCreated++;&#13;
&#13;
            // cost of creating one channel&#13;
            uint gasPerChannel = startingGas.sub(msg.gas);&#13;
            if (gasPerChannel.add(50000) &gt; msg.gas)&#13;
                break;  // enough proxies for this call&#13;
        }&#13;
        return paymentChannelsCreated;&#13;
    }&#13;
&#13;
&#13;
    /// @dev process payments - record analytics and pass control to iaOnInvested callback&#13;
    function iaInvestedBy(address investor) external payable {&#13;
        address paymentChannel = msg.sender;&#13;
        if (m_validPaymentChannels[paymentChannel]) {&#13;
            // payment received by one of our channels&#13;
            uint value = msg.value;&#13;
            m_investmentsByPaymentChannel[paymentChannel] = m_investmentsByPaymentChannel[paymentChannel].add(value);&#13;
            // We know for sure that investment came from specified investor (see AnalyticProxy).&#13;
            iaOnInvested(investor, value, true);&#13;
        } else {&#13;
            // Looks like some user has paid to this method, this payment is not included in the analytics,&#13;
            // but, of course, processed.&#13;
            iaOnInvested(msg.sender, msg.value, false);&#13;
        }&#13;
    }&#13;
&#13;
    /// @dev callback&#13;
    function iaOnInvested(address /*investor*/, uint /*payment*/, bool /*usingPaymentChannel*/) internal {&#13;
    }&#13;
&#13;
&#13;
    function paymentChannelsCount() external constant returns (uint) {&#13;
        return m_paymentChannels.length;&#13;
    }&#13;
&#13;
    function readAnalyticsMap() external constant returns (address[], uint[]) {&#13;
        address[] memory keys = new address[](m_paymentChannels.length);&#13;
        uint[] memory values = new uint[](m_paymentChannels.length);&#13;
&#13;
        for (uint i = 0; i &lt; m_paymentChannels.length; i++) {&#13;
            address key = m_paymentChannels[i];&#13;
            keys[i] = key;&#13;
            values[i] = m_investmentsByPaymentChannel[key];&#13;
        }&#13;
&#13;
        return (keys, values);&#13;
    }&#13;
&#13;
    function readPaymentChannels() external constant returns (address[]) {&#13;
        return m_paymentChannels;&#13;
    }&#13;
&#13;
&#13;
    mapping(address =&gt; uint256) public m_investmentsByPaymentChannel;&#13;
    mapping(address =&gt; bool) m_validPaymentChannels;&#13;
&#13;
    address[] public m_paymentChannels;&#13;
}&#13;
/*************************************************************************&#13;
 * import "./crowdsale/InvestmentAnalytics.sol" : end&#13;
 *************************************************************************/&#13;
/*************************************************************************&#13;
 * import "zeppelin-solidity/contracts/ownership/Ownable.sol" : start&#13;
 *************************************************************************/&#13;
&#13;
&#13;
/**&#13;
 * @title Ownable&#13;
 * @dev The Ownable contract has an owner address, and provides basic authorization control&#13;
 * functions, this simplifies the implementation of "user permissions".&#13;
 */&#13;
contract Ownable {&#13;
  address public owner;&#13;
&#13;
&#13;
  /**&#13;
   * @dev The Ownable constructor sets the original `owner` of the contract to the sender&#13;
   * account.&#13;
   */&#13;
  function Ownable() {&#13;
    owner = msg.sender;&#13;
  }&#13;
&#13;
&#13;
  /**&#13;
   * @dev Throws if called by any account other than the owner.&#13;
   */&#13;
  modifier onlyOwner() {&#13;
    require(msg.sender == owner);&#13;
    _;&#13;
  }&#13;
&#13;
&#13;
  /**&#13;
   * @dev Allows the current owner to transfer control of the contract to a newOwner.&#13;
   * @param newOwner The address to transfer ownership to.&#13;
   */&#13;
  function transferOwnership(address newOwner) onlyOwner {&#13;
    if (newOwner != address(0)) {&#13;
      owner = newOwner;&#13;
    }&#13;
  }&#13;
&#13;
}&#13;
/*************************************************************************&#13;
 * import "zeppelin-solidity/contracts/ownership/Ownable.sol" : end&#13;
 *************************************************************************/&#13;
&#13;
&#13;
/// @title Base contract for Storiqa pre-ICO&#13;
contract STQPreICOBase is SimpleCrowdsaleBase, Ownable, InvestmentAnalytics {&#13;
&#13;
    function STQPreICOBase(address token)&#13;
        SimpleCrowdsaleBase(token)&#13;
    {&#13;
    }&#13;
&#13;
&#13;
    // PUBLIC interface: maintenance&#13;
&#13;
    function createMorePaymentChannels(uint limit) external onlyOwner returns (uint) {&#13;
        return createMorePaymentChannelsInternal(limit);&#13;
    }&#13;
&#13;
    /// @notice Tests ownership of the current caller.&#13;
    /// @return true if it's an owner&#13;
    // It's advisable to call it by new owner to make sure that the same erroneous address is not copy-pasted to&#13;
    // addOwner/changeOwner and to isOwner.&#13;
    function amIOwner() external constant onlyOwner returns (bool) {&#13;
        return true;&#13;
    }&#13;
&#13;
&#13;
    // INTERNAL&#13;
&#13;
    /// @dev payment callback&#13;
    function iaOnInvested(address investor, uint payment, bool usingPaymentChannel) internal {&#13;
        buyInternal(investor, payment, usingPaymentChannel ? c_paymentChannelBonusPercent : 0);&#13;
    }&#13;
&#13;
    function calculateTokens(address /*investor*/, uint payment, uint extraBonuses) internal constant returns (uint) {&#13;
        uint bonusPercent = getPreICOBonus().add(getLargePaymentBonus(payment)).add(extraBonuses);&#13;
        uint rate = c_STQperETH.mul(bonusPercent.add(100)).div(100);&#13;
&#13;
        return payment.mul(rate);&#13;
    }&#13;
&#13;
    function getLargePaymentBonus(uint payment) private constant returns (uint) {&#13;
        if (payment &gt; 1000 ether) return 10;&#13;
        if (payment &gt; 800 ether) return 8;&#13;
        if (payment &gt; 500 ether) return 5;&#13;
        if (payment &gt; 200 ether) return 2;&#13;
        return 0;&#13;
    }&#13;
&#13;
    function mustApplyTimeCheck(address investor, uint /*payment*/) constant internal returns (bool) {&#13;
        return investor != owner;&#13;
    }&#13;
&#13;
    /// @notice pre-ICO bonus&#13;
    function getPreICOBonus() internal constant returns (uint);&#13;
&#13;
&#13;
    // FIELDS&#13;
&#13;
    /// @notice starting exchange rate of STQ&#13;
    uint public constant c_STQperETH = 100000;&#13;
&#13;
    /// @notice authorised payment bonus&#13;
    uint public constant c_paymentChannelBonusPercent = 2;&#13;
}&#13;
/*************************************************************************&#13;
 * import "./STQPreICOBase.sol" : end&#13;
 *************************************************************************/&#13;
/*************************************************************************&#13;
 * import "./crowdsale/FundsRegistryWalletConnector.sol" : start&#13;
 *************************************************************************/&#13;
&#13;
&#13;
/*************************************************************************&#13;
 * import "./FundsRegistry.sol" : start&#13;
 *************************************************************************/&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
/// @title registry of funds sent by investors&#13;
contract FundsRegistry is ArgumentsChecker, MultiownedControlled, ReentrancyGuard {&#13;
    using SafeMath for uint256;&#13;
&#13;
    enum State {&#13;
        // gathering funds&#13;
        GATHERING,&#13;
        // returning funds to investors&#13;
        REFUNDING,&#13;
        // funds can be pulled by owners&#13;
        SUCCEEDED&#13;
    }&#13;
&#13;
    event StateChanged(State _state);&#13;
    event Invested(address indexed investor, uint256 amount);&#13;
    event EtherSent(address indexed to, uint value);&#13;
    event RefundSent(address indexed to, uint value);&#13;
&#13;
&#13;
    modifier requiresState(State _state) {&#13;
        require(m_state == _state);&#13;
        _;&#13;
    }&#13;
&#13;
&#13;
    // PUBLIC interface&#13;
&#13;
    function FundsRegistry(address[] _owners, uint _signaturesRequired, address _controller)&#13;
        MultiownedControlled(_owners, _signaturesRequired, _controller)&#13;
    {&#13;
    }&#13;
&#13;
    /// @dev performs only allowed state transitions&#13;
    function changeState(State _newState)&#13;
        external&#13;
        onlyController&#13;
    {&#13;
        assert(m_state != _newState);&#13;
&#13;
        if (State.GATHERING == m_state) {   assert(State.REFUNDING == _newState || State.SUCCEEDED == _newState); }&#13;
        else assert(false);&#13;
&#13;
        m_state = _newState;&#13;
        StateChanged(m_state);&#13;
    }&#13;
&#13;
    /// @dev records an investment&#13;
    function invested(address _investor)&#13;
        external&#13;
        payable&#13;
        onlyController&#13;
        requiresState(State.GATHERING)&#13;
    {&#13;
        uint256 amount = msg.value;&#13;
        require(0 != amount);&#13;
        assert(_investor != m_controller);&#13;
&#13;
        // register investor&#13;
        if (0 == m_weiBalances[_investor])&#13;
            m_investors.push(_investor);&#13;
&#13;
        // register payment&#13;
        totalInvested = totalInvested.add(amount);&#13;
        m_weiBalances[_investor] = m_weiBalances[_investor].add(amount);&#13;
&#13;
        Invested(_investor, amount);&#13;
    }&#13;
&#13;
    /// @notice owners: send `value` of ether to address `to`, can be called if crowdsale succeeded&#13;
    /// @param to where to send ether&#13;
    /// @param value amount of wei to send&#13;
    function sendEther(address to, uint value)&#13;
        external&#13;
        validAddress(to)&#13;
        onlymanyowners(sha3(msg.data))&#13;
        requiresState(State.SUCCEEDED)&#13;
    {&#13;
        require(value &gt; 0 &amp;&amp; this.balance &gt;= value);&#13;
        to.transfer(value);&#13;
        EtherSent(to, value);&#13;
    }&#13;
&#13;
    /// @notice withdraw accumulated balance, called by payee in case crowdsale failed&#13;
    function withdrawPayments()&#13;
        external&#13;
        nonReentrant&#13;
        requiresState(State.REFUNDING)&#13;
    {&#13;
        address payee = msg.sender;&#13;
        uint256 payment = m_weiBalances[payee];&#13;
&#13;
        require(payment != 0);&#13;
        require(this.balance &gt;= payment);&#13;
&#13;
        totalInvested = totalInvested.sub(payment);&#13;
        m_weiBalances[payee] = 0;&#13;
&#13;
        payee.transfer(payment);&#13;
        RefundSent(payee, payment);&#13;
    }&#13;
&#13;
    function getInvestorsCount() external constant returns (uint) { return m_investors.length; }&#13;
&#13;
&#13;
    // FIELDS&#13;
&#13;
    /// @notice total amount of investments in wei&#13;
    uint256 public totalInvested;&#13;
&#13;
    /// @notice state of the registry&#13;
    State public m_state = State.GATHERING;&#13;
&#13;
    /// @dev balances of investors in wei&#13;
    mapping(address =&gt; uint256) public m_weiBalances;&#13;
&#13;
    /// @dev list of unique investors&#13;
    address[] public m_investors;&#13;
}&#13;
/*************************************************************************&#13;
 * import "./FundsRegistry.sol" : end&#13;
 *************************************************************************/&#13;
&#13;
&#13;
/**&#13;
 * @title Stores investments in FundsRegistry.&#13;
 * @author Eenae&#13;
 */&#13;
contract FundsRegistryWalletConnector is IInvestmentsWalletConnector {&#13;
&#13;
    function FundsRegistryWalletConnector(address[] fundOwners, uint ownersSignatures)&#13;
    {&#13;
        m_fundsAddress = new FundsRegistry(fundOwners, ownersSignatures, this);&#13;
    }&#13;
&#13;
    /// @dev process and forward investment&#13;
    function storeInvestment(address investor, uint payment) internal&#13;
    {&#13;
        m_fundsAddress.invested.value(payment)(investor);&#13;
    }&#13;
&#13;
    /// @dev total investments amount stored using storeInvestment()&#13;
    function getTotalInvestmentsStored() internal constant returns (uint)&#13;
    {&#13;
        return m_fundsAddress.totalInvested();&#13;
    }&#13;
&#13;
    /// @dev called in case crowdsale succeeded&#13;
    function wcOnCrowdsaleSuccess() internal {&#13;
        m_fundsAddress.changeState(FundsRegistry.State.SUCCEEDED);&#13;
        m_fundsAddress.detachController();&#13;
    }&#13;
&#13;
    /// @dev called in case crowdsale failed&#13;
    function wcOnCrowdsaleFailure() internal {&#13;
        m_fundsAddress.changeState(FundsRegistry.State.REFUNDING);&#13;
        m_fundsAddress.detachController();&#13;
    }&#13;
&#13;
    /// @notice address of wallet which stores funds&#13;
    FundsRegistry public m_fundsAddress;&#13;
}&#13;
/*************************************************************************&#13;
 * import "./crowdsale/FundsRegistryWalletConnector.sol" : end&#13;
 *************************************************************************/&#13;
&#13;
&#13;
/// @title Storiqa pre-ICO contract&#13;
contract STQPreICO2 is STQPreICOBase, FundsRegistryWalletConnector {&#13;
&#13;
    function STQPreICO2(address token, address[] fundOwners)&#13;
        STQPreICOBase(token)&#13;
        FundsRegistryWalletConnector(fundOwners, 2)&#13;
    {&#13;
        require(3 == fundOwners.length);&#13;
    }&#13;
&#13;
&#13;
    // INTERNAL&#13;
&#13;
    function getWeiCollected() public constant returns (uint) {&#13;
        return getTotalInvestmentsStored().add(2401 ether /* previous crowdsales */);&#13;
    }&#13;
&#13;
    /// @notice minimum amount of funding to consider crowdsale as successful&#13;
    function getMinimumFunds() internal constant returns (uint) {&#13;
        return 3500 ether;&#13;
    }&#13;
&#13;
    /// @notice maximum investments to be accepted during pre-ICO&#13;
    function getMaximumFunds() internal constant returns (uint) {&#13;
        return 8500 ether;&#13;
    }&#13;
&#13;
    /// @notice start time of the pre-ICO&#13;
    function getStartTime() internal constant returns (uint) {&#13;
        return 1508346000;&#13;
    }&#13;
&#13;
    /// @notice end time of the pre-ICO&#13;
    function getEndTime() internal constant returns (uint) {&#13;
        return getStartTime() + (5 days);&#13;
    }&#13;
&#13;
    /// @notice pre-ICO bonus&#13;
    function getPreICOBonus() internal constant returns (uint) {&#13;
        return 35;&#13;
    }&#13;
}