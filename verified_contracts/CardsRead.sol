pragma solidity ^0.4.18;
/* ==================================================================== */
/* Copyright (c) 2018 The MagicAcademy Project.  All rights reserved.
/* 
/* https://www.magicacademy.io One of the world's first idle strategy games of blockchain 
/*  
/* authors <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="d2a0b3bbbcab92bebba4b7a1a6b3a0fcb1bdbf">[email protected]</a>/<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="9ff9fef1f1e6b1e5f7faf1f8dff3f6e9faecebfeedb1fcf0f2">[email protected]</a>&#13;
/*                 &#13;
/* ==================================================================== */&#13;
&#13;
interface CardsInterface {&#13;
  function getJadeProduction(address player) external constant returns (uint256);&#13;
  function getOwnedCount(address player, uint256 cardId) external view returns (uint256);&#13;
  function getUintCoinProduction(address _address, uint256 cardId) external view returns (uint256);&#13;
  function getUnitCoinProductionMultiplier(address _address, uint256 cardId) external view returns (uint256);&#13;
  function getUnitCoinProductionIncreases(address _address, uint256 cardId) external view returns (uint256);&#13;
  function getUnitAttackIncreases(address _address, uint256 cardId) external view returns (uint256);&#13;
  function getUnitAttackMultiplier(address _address, uint256 cardId) external view returns (uint256);&#13;
  function getUnitDefenseIncreases(address _address, uint256 cardId) external view returns (uint256);&#13;
  function getUnitDefenseMultiplier(address _address, uint256 cardId) external view returns (uint256);&#13;
  function getUnitJadeStealingIncreases(address _address, uint256 cardId) external view returns (uint256);&#13;
  function getUnitJadeStealingMultiplier(address _address, uint256 cardId) external view returns (uint256);&#13;
  function getUnitsProduction(address player, uint256 cardId, uint256 amount) external constant returns (uint256);&#13;
}&#13;
&#13;
interface GameConfigInterface {&#13;
  function productionCardIdRange() external constant returns (uint256, uint256);&#13;
  function battleCardIdRange() external constant returns (uint256, uint256);&#13;
  function unitCoinProduction(uint256 cardId) external constant returns (uint256);&#13;
  function unitAttack(uint256 cardId) external constant returns (uint256);&#13;
  function unitDefense(uint256 cardId) external constant returns (uint256); &#13;
  function unitStealingCapacity(uint256 cardId) external constant returns (uint256);&#13;
}&#13;
&#13;
contract CardsRead {&#13;
  CardsInterface public cards;&#13;
  GameConfigInterface public schema;&#13;
  address owner;&#13;
&#13;
  modifier onlyOwner() {&#13;
    require(msg.sender == owner);&#13;
    _;&#13;
  }&#13;
&#13;
  function CardsRead() public {&#13;
    owner = msg.sender;&#13;
  }&#13;
    //setting configuration&#13;
  function setConfigAddress(address _address) external onlyOwner {&#13;
    schema = GameConfigInterface(_address);&#13;
  }&#13;
&#13;
     //setting configuration&#13;
  function setCardsAddress(address _address) external onlyOwner {&#13;
    cards = CardsInterface(_address);&#13;
  }&#13;
  function getNormalCard(address _owner) private view returns (uint256) {&#13;
    uint256 startId;&#13;
    uint256 endId;&#13;
    (startId,endId) = schema.productionCardIdRange(); &#13;
    uint256 icount;&#13;
    while (startId &lt;= endId) {&#13;
      if (cards.getOwnedCount(_owner,startId)&gt;=1) {&#13;
        icount++;&#13;
      }&#13;
      startId++;&#13;
    }&#13;
    return icount;&#13;
  }&#13;
&#13;
  function getBattleCard(address _owner) private view returns (uint256) {&#13;
    uint256 startId;&#13;
    uint256 endId;&#13;
    (startId,endId) = schema.battleCardIdRange(); &#13;
    uint256 icount;&#13;
    while (startId &lt;= endId) {&#13;
      if (cards.getOwnedCount(_owner,startId)&gt;=1) {&#13;
        icount++;&#13;
      }&#13;
      startId++;&#13;
    }&#13;
    return icount;&#13;
  }&#13;
  // get normal cardlist;&#13;
  function getNormalCardList(address _owner) external view returns(uint256[],uint256[]){&#13;
    uint256 len = getNormalCard(_owner);&#13;
    uint256[] memory itemId = new uint256[](len);&#13;
    uint256[] memory itemNumber = new uint256[](len);&#13;
    uint256 startId;&#13;
    uint256 endId;&#13;
    (startId,endId) = schema.productionCardIdRange(); &#13;
    uint256 i;&#13;
    while (startId &lt;= endId) {&#13;
      if (cards.getOwnedCount(_owner,startId)&gt;=1) {&#13;
        itemId[i] = startId;&#13;
        itemNumber[i] = cards.getOwnedCount(_owner,startId);&#13;
        i++;&#13;
      }&#13;
      startId++;&#13;
      }   &#13;
    return (itemId, itemNumber);&#13;
  }&#13;
&#13;
  // get normal cardlist;&#13;
  function getBattleCardList(address _owner) external view returns(uint256[],uint256[]){&#13;
    uint256 len = getBattleCard(_owner);&#13;
    uint256[] memory itemId = new uint256[](len);&#13;
    uint256[] memory itemNumber = new uint256[](len);&#13;
&#13;
    uint256 startId;&#13;
    uint256 endId;&#13;
    (startId,endId) = schema.battleCardIdRange(); &#13;
&#13;
    uint256 i;&#13;
    while (startId &lt;= endId) {&#13;
      if (cards.getOwnedCount(_owner,startId)&gt;=1) {&#13;
        itemId[i] = startId;&#13;
        itemNumber[i] = cards.getOwnedCount(_owner,startId);&#13;
        i++;&#13;
      }&#13;
      startId++;&#13;
      }   &#13;
    return (itemId, itemNumber);&#13;
  }&#13;
&#13;
  //get up value&#13;
  function getUpgradeValue(address player, uint256 upgradeClass, uint256 unitId, uint256 upgradeValue) external view returns (uint256) {&#13;
    uint256 icount = cards.getOwnedCount(player,unitId);&#13;
    uint256 unitProduction = cards.getUintCoinProduction(player,unitId);&#13;
    if (upgradeClass == 0) {&#13;
      if (icount!=0) {&#13;
        return (icount * upgradeValue * 10000 * (10 + cards.getUnitCoinProductionMultiplier(player, unitId))/unitProduction);&#13;
      } else {&#13;
        return (upgradeValue * 10000) / schema.unitCoinProduction(unitId);&#13;
      }&#13;
     } else if (upgradeClass == 1) {&#13;
      if (icount!=0) {&#13;
        return (icount * upgradeValue * 10000 * (schema.unitCoinProduction(unitId) + cards.getUnitCoinProductionIncreases(player,unitId))/unitProduction);&#13;
      }else{&#13;
        return (upgradeValue * 10000) / schema.unitCoinProduction(unitId);  &#13;
      }&#13;
    } else if (upgradeClass == 2) {&#13;
      return (upgradeValue  * 10000)/(schema.unitAttack(unitId) + cards.getUnitAttackIncreases(player,unitId));&#13;
    } else if (upgradeClass == 3) {&#13;
      return (upgradeValue  * 10000)/(10 + cards.getUnitAttackMultiplier(player,unitId));&#13;
    } else if (upgradeClass == 4) {&#13;
      return (upgradeValue  * 10000)/(schema.unitDefense(unitId) + cards.getUnitDefenseIncreases(player,unitId));&#13;
    } else if (upgradeClass == 5) {&#13;
      return (upgradeValue  * 10000)/(10 + cards.getUnitDefenseMultiplier(player,unitId));&#13;
    } else if (upgradeClass == 6) {&#13;
      return (upgradeValue  * 10000)/(schema.unitStealingCapacity(unitId) + cards.getUnitJadeStealingIncreases(player,unitId));&#13;
    } else if (upgradeClass == 7) {&#13;
      return (upgradeValue  * 10000)/(10 + cards.getUnitJadeStealingMultiplier(player,unitId));&#13;
      &#13;
    }&#13;
  }&#13;
}