pragma solidity ^0.4.18;

// File: contracts/ERC721.sol

/// @title Interface for contracts conforming to ERC-721: Non-Fungible Tokens
/// @author Dieter Shirley <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="2c484958496c4d54454341564942024f43">[emailÂ protected]</a>&gt; (https://github.com/dete)&#13;
contract ERC721 {&#13;
    // Required methods&#13;
    function totalSupply() public view returns (uint256 total);&#13;
    function balanceOf(address _owner) public view returns (uint256 balance);&#13;
    function ownerOf(uint256 _tokenId) external view returns (address owner);&#13;
    function approve(address _to, uint256 _tokenId) external;&#13;
    function transfer(address _to, uint256 _tokenId) external;&#13;
    function transferFrom(address _from, address _to, uint256 _tokenId) external;&#13;
&#13;
    // Events&#13;
    event Transfer(address from, address to, uint256 tokenId);&#13;
    event Approval(address owner, address approved, uint256 tokenId);&#13;
}&#13;
&#13;
// File: contracts/TulipsSaleInterface.sol&#13;
&#13;
/*&#13;
* @title Crypto Tulips Initial Sale Interface&#13;
* @dev This interface sets the standard for initial sale&#13;
* contract. All future sale contracts should follow this.&#13;
*/&#13;
interface TulipsSaleInterface {&#13;
    function putOnInitialSale(uint256 tulipId) external;&#13;
&#13;
    function createAuction(&#13;
        uint256 _tulipId,&#13;
        uint256 _startingPrice,&#13;
        uint256 _endingPrice,&#13;
        uint256 _duration,&#13;
        address _transferFrom&#13;
    )external;&#13;
}&#13;
&#13;
// File: zeppelin-solidity/contracts/ownership/Ownable.sol&#13;
&#13;
/**&#13;
 * @title Ownable&#13;
 * @dev The Ownable contract has an owner address, and provides basic authorization control&#13;
 * functions, this simplifies the implementation of "user permissions".&#13;
 */&#13;
contract Ownable {&#13;
  address public owner;&#13;
&#13;
&#13;
  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);&#13;
&#13;
&#13;
  /**&#13;
   * @dev The Ownable constructor sets the original `owner` of the contract to the sender&#13;
   * account.&#13;
   */&#13;
  function Ownable() public {&#13;
    owner = msg.sender;&#13;
  }&#13;
&#13;
&#13;
  /**&#13;
   * @dev Throws if called by any account other than the owner.&#13;
   */&#13;
  modifier onlyOwner() {&#13;
    require(msg.sender == owner);&#13;
    _;&#13;
  }&#13;
&#13;
&#13;
  /**&#13;
   * @dev Allows the current owner to transfer control of the contract to a newOwner.&#13;
   * @param newOwner The address to transfer ownership to.&#13;
   */&#13;
  function transferOwnership(address newOwner) public onlyOwner {&#13;
    require(newOwner != address(0));&#13;
    OwnershipTransferred(owner, newOwner);&#13;
    owner = newOwner;&#13;
  }&#13;
&#13;
}&#13;
&#13;
// File: zeppelin-solidity/contracts/lifecycle/Pausable.sol&#13;
&#13;
/**&#13;
 * @title Pausable&#13;
 * @dev Base contract which allows children to implement an emergency stop mechanism.&#13;
 */&#13;
contract Pausable is Ownable {&#13;
  event Pause();&#13;
  event Unpause();&#13;
&#13;
  bool public paused = false;&#13;
&#13;
&#13;
  /**&#13;
   * @dev Modifier to make a function callable only when the contract is not paused.&#13;
   */&#13;
  modifier whenNotPaused() {&#13;
    require(!paused);&#13;
    _;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Modifier to make a function callable only when the contract is paused.&#13;
   */&#13;
  modifier whenPaused() {&#13;
    require(paused);&#13;
    _;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev called by the owner to pause, triggers stopped state&#13;
   */&#13;
  function pause() onlyOwner whenNotPaused public {&#13;
    paused = true;&#13;
    Pause();&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev called by the owner to unpause, returns to normal state&#13;
   */&#13;
  function unpause() onlyOwner whenPaused public {&#13;
    paused = false;&#13;
    Unpause();&#13;
  }&#13;
}&#13;
&#13;
// File: contracts/TulipsRoles.sol&#13;
&#13;
/*&#13;
* @title Crypto Tulips SaleAuction&#13;
* @dev .&#13;
*/&#13;
contract TulipsRoles is Pausable {&#13;
&#13;
    modifier onlyFinancial() {&#13;
        require(msg.sender == address(financialAccount));&#13;
        _;&#13;
    }&#13;
&#13;
    modifier onlyOperations() {&#13;
        require(msg.sender == address(operationsAccount));&#13;
        _;&#13;
    }&#13;
&#13;
    function TulipsRoles() Ownable() public {&#13;
        financialAccount = msg.sender;&#13;
        operationsAccount = msg.sender;&#13;
    }&#13;
&#13;
    address public financialAccount;&#13;
    address public operationsAccount;&#13;
&#13;
    function transferFinancial(address newFinancial) public onlyOwner {&#13;
        require(newFinancial != address(0));&#13;
        financialAccount = newFinancial;&#13;
    }&#13;
&#13;
    function transferOperations(address newOperations) public onlyOwner {&#13;
        require(newOperations != address(0));&#13;
        operationsAccount = newOperations;&#13;
    }&#13;
&#13;
}&#13;
&#13;
// File: contracts/TulipsSaleAuction.sol&#13;
&#13;
/*&#13;
* @title Crypto Tulips SaleAuction&#13;
* @dev .&#13;
*/&#13;
contract TulipsSaleAuction is TulipsRoles, TulipsSaleInterface {&#13;
&#13;
    modifier onlyCoreContract() {&#13;
        require(msg.sender == address(coreContract));&#13;
        _;&#13;
    }&#13;
&#13;
    struct Auction {&#13;
        address seller;&#13;
        uint128 startingPrice;&#13;
        uint128 endingPrice;&#13;
        uint64 duration;&#13;
        uint64 startedAt;&#13;
    }&#13;
&#13;
    // @dev core contract cannot change due to security reasons&#13;
    ERC721 public coreContract;&#13;
&#13;
    // Commission cut&#13;
    uint256 public ownerCut;&#13;
&#13;
    uint256 public initialStartPrice;&#13;
    uint256 public initialEndPrice;&#13;
    uint256 public initialSaleDuration = 1 days;&#13;
&#13;
    // Map from token ID to their corresponding auction.&#13;
    mapping (uint256 =&gt; Auction) public tokenIdToAuction;&#13;
&#13;
    event AuctionCreated(uint256 tokenId, uint256 startingPrice, uint256 endingPrice, uint256 duration);&#13;
    event AuctionSuccessful(uint256 tokenId, uint256 totalPrice, address winner);&#13;
    event AuctionCancelled(uint256 tokenId);&#13;
&#13;
    /*&#13;
    * @dev Constructor initialized with the reference to core Tulips contract&#13;
    * @param _tulipsCoreContract - core contract adress should be fixed&#13;
    * @param _cut - core contract adress should be fixed&#13;
    */&#13;
    function TulipsSaleAuction(address _tulipsCoreContract, uint256 _cut) TulipsRoles() public {&#13;
        require(_cut &lt;= 10000); // cut as percentage between 0.00-100.00%&#13;
        ownerCut = _cut;&#13;
&#13;
        coreContract = ERC721(_tulipsCoreContract);&#13;
    }&#13;
     /*&#13;
    * @dev These are auction prices for initial tulip sales.&#13;
    */&#13;
    function setDefaultAuctionPrices(uint256 _startPrice, uint256 _endPrice) external onlyFinancial {&#13;
        initialStartPrice = _startPrice;&#13;
        initialEndPrice = _endPrice;&#13;
    }&#13;
&#13;
    function recievePayout(uint payoutAmount, address payoutAddress) external onlyFinancial {&#13;
        require(payoutAddress != 0);&#13;
        payoutAddress.transfer(payoutAmount);&#13;
    }&#13;
&#13;
    /*&#13;
    * @dev This function is called from core Contract to put tulip on initial sale.&#13;
    * This is a privilaged version that, recieves request from corecontract.&#13;
    * Core contract ensures that this contract already is the ownerof this tulip&#13;
    */&#13;
    function putOnInitialSale(uint256 _tulipId) external onlyCoreContract {&#13;
        // !! Core contract must ensure the ownership&#13;
        _createAuction(_tulipId, initialStartPrice, initialEndPrice, initialSaleDuration, this);&#13;
    }&#13;
&#13;
    function createAuction(&#13;
        uint256 _tulipId,&#13;
        uint256 _startingPrice,&#13;
        uint256 _endingPrice,&#13;
        uint256 _duration,&#13;
        address _transferFrom&#13;
    )external&#13;
    {&#13;
        // Avoid input overflowing struct memory sizes&#13;
        require(_startingPrice == uint256(uint128(_startingPrice)));&#13;
        require(_endingPrice == uint256(uint128(_endingPrice)));&#13;
        require(_duration == uint256(uint64(_duration)));&#13;
&#13;
        // Make sure we have at least a minute for this auction&#13;
        require(_duration &gt;= 1 minutes);&#13;
&#13;
        require(coreContract.ownerOf(_tulipId) == _transferFrom);&#13;
&#13;
        // Transfer from checks whether the owner approved this transfer so&#13;
        // we can't transfer tulips without permission&#13;
        coreContract.transferFrom(_transferFrom, this, _tulipId);&#13;
&#13;
        _createAuction(_tulipId, _startingPrice, _endingPrice, _duration, _transferFrom);&#13;
    }&#13;
&#13;
&#13;
&#13;
    /// @param _tulipId - Id of the tulip to auction.&#13;
    /// @param _startingPrice - Starting price in wei.&#13;
    /// @param _endingPrice - Ending price in wei.&#13;
    /// @param _duration - Duration in seconds.&#13;
    /// @param _seller - Seller address&#13;
    function _createAuction(&#13;
        uint256 _tulipId,&#13;
        uint256 _startingPrice,&#13;
        uint256 _endingPrice,&#13;
        uint256 _duration,&#13;
        address _seller&#13;
    )&#13;
        internal&#13;
    {&#13;
&#13;
        Auction memory auction = Auction(&#13;
            _seller,&#13;
            uint128(_startingPrice),&#13;
            uint128(_endingPrice),&#13;
            uint64(_duration),&#13;
            uint64(now)&#13;
        );&#13;
&#13;
        tokenIdToAuction[_tulipId] = auction;&#13;
&#13;
        AuctionCreated(&#13;
            uint256(_tulipId),&#13;
            uint256(auction.startingPrice),&#13;
            uint256(auction.endingPrice),&#13;
            uint256(auction.duration)&#13;
        );&#13;
    }&#13;
&#13;
&#13;
    /*&#13;
    * @dev Cancel auction and return tulip to original owner.&#13;
    * @param _tulipId - ID of the tulip on auction&#13;
    */&#13;
    function cancelAuction(uint256 _tulipId)&#13;
        external&#13;
    {&#13;
        Auction storage auction = tokenIdToAuction[_tulipId];&#13;
        require(auction.startedAt &gt; 0);&#13;
&#13;
        // Only seller can call this function&#13;
        address seller = auction.seller;&#13;
        require(msg.sender == seller);&#13;
&#13;
        // Return the tulip to the owner&#13;
        coreContract.transfer(seller, _tulipId);&#13;
&#13;
        // Remove auction from storage&#13;
        delete tokenIdToAuction[_tulipId];&#13;
&#13;
        AuctionCancelled(_tulipId);&#13;
    }&#13;
&#13;
    function buy(uint256 _tulipId)&#13;
        external&#13;
        payable&#13;
        whenNotPaused&#13;
    {&#13;
        Auction storage auction = tokenIdToAuction[_tulipId];&#13;
&#13;
        require(auction.startedAt &gt; 0);&#13;
&#13;
        uint256 price = _currentPrice(auction);&#13;
        require(msg.value &gt;= price);&#13;
&#13;
        address seller = auction.seller;&#13;
&#13;
        delete tokenIdToAuction[_tulipId];&#13;
&#13;
        // We don't calculate auctioneers if the seller is us.&#13;
        if (price &gt; 0 &amp;&amp; seller != address(this)) {&#13;
            // Calculate the auctioneer's cut.&#13;
            uint256 auctioneerCut = _computeCut(price);&#13;
            uint256 sellerGains = price - auctioneerCut;&#13;
&#13;
            seller.transfer(sellerGains);&#13;
        }&#13;
&#13;
        uint256 bidExcess = msg.value - price;&#13;
&#13;
        msg.sender.transfer(bidExcess);&#13;
&#13;
        coreContract.transfer(msg.sender, _tulipId);&#13;
&#13;
        AuctionSuccessful(_tulipId, price, msg.sender);&#13;
    }&#13;
&#13;
    function secondsPassed(uint256 _tulipId )external view&#13;
       returns (uint256)&#13;
    {&#13;
        Auction storage auction = tokenIdToAuction[_tulipId];&#13;
&#13;
        uint256 secondsPassed = 0;&#13;
&#13;
        if (now &gt; auction.startedAt) {&#13;
            secondsPassed = now - auction.startedAt;&#13;
        }&#13;
&#13;
        return secondsPassed;&#13;
    }&#13;
&#13;
    function currentPrice(uint256 _tulipId) external view&#13;
        returns (uint256)&#13;
    {&#13;
        Auction storage auction = tokenIdToAuction[_tulipId];&#13;
&#13;
        require(auction.startedAt &gt; 0);&#13;
&#13;
        return _currentPrice(auction);&#13;
    }&#13;
&#13;
    function _currentPrice(Auction storage _auction)&#13;
        internal&#13;
        view&#13;
        returns (uint256)&#13;
    {&#13;
        uint256 secondsPassed = 0;&#13;
&#13;
        if (now &gt; _auction.startedAt) {&#13;
            secondsPassed = now - _auction.startedAt;&#13;
        }&#13;
&#13;
        return _computeCurrentPrice(&#13;
            _auction.startingPrice,&#13;
            _auction.endingPrice,&#13;
            _auction.duration,&#13;
            secondsPassed&#13;
        );&#13;
    }&#13;
&#13;
    function _computeCurrentPrice(&#13;
        uint256 _startingPrice,&#13;
        uint256 _endingPrice,&#13;
        uint256 _duration,&#13;
        uint256 _secondsPassed&#13;
    )&#13;
        internal&#13;
        pure&#13;
        returns (uint256)&#13;
    {&#13;
        if (_secondsPassed &gt;= _duration) {&#13;
            return _endingPrice;&#13;
        } else {&#13;
            int256 totalPriceChange = int256(_endingPrice) - int256(_startingPrice);&#13;
&#13;
            int256 currentPriceChange = totalPriceChange * int256(_secondsPassed) / int256(_duration);&#13;
&#13;
            int256 currentPrice = int256(_startingPrice) + currentPriceChange;&#13;
&#13;
            return uint256(currentPrice);&#13;
        }&#13;
    }&#13;
&#13;
    function _computeCut(uint256 _price) internal view returns (uint256) {&#13;
        return _price * ownerCut / 10000;&#13;
    }&#13;
&#13;
}