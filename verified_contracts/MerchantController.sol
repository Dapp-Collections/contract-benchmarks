pragma solidity ^0.4.23;

/**
 * @title Helps contracts guard agains reentrancy attacks.
 * @author Remco Bloemen <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="3f4d5a525c507f0d">[email protected]</a>π.com&gt;&#13;
 * @notice If you mark a function `nonReentrant`, you should also&#13;
 * mark it `external`.&#13;
 */&#13;
contract ReentrancyGuard {&#13;
&#13;
  /**&#13;
   * @dev We use a single lock for the whole contract.&#13;
   */&#13;
  bool private reentrancyLock = false;&#13;
&#13;
  /**&#13;
   * @dev Prevents a contract from calling itself, directly or indirectly.&#13;
   * @notice If you mark a function `nonReentrant`, you should also&#13;
   * mark it `external`. Calling one nonReentrant function from&#13;
   * another is not supported. Instead, you can implement a&#13;
   * `private` function doing the actual work, and a `external`&#13;
   * wrapper marked as `nonReentrant`.&#13;
   */&#13;
  modifier nonReentrant() {&#13;
    require(!reentrancyLock);&#13;
    reentrancyLock = true;&#13;
    _;&#13;
    reentrancyLock = false;&#13;
  }&#13;
&#13;
}&#13;
&#13;
/**&#13;
 * @title SafeMath&#13;
 * @dev Math operations with safety checks that throw on error&#13;
 */&#13;
library SafeMath {&#13;
&#13;
  /**&#13;
  * @dev Multiplies two numbers, throws on overflow.&#13;
  */&#13;
  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {&#13;
    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the&#13;
    // benefit is lost if 'b' is also tested.&#13;
    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522&#13;
    if (a == 0) {&#13;
      return 0;&#13;
    }&#13;
&#13;
    c = a * b;&#13;
    assert(c / a == b);&#13;
    return c;&#13;
  }&#13;
&#13;
  /**&#13;
  * @dev Integer division of two numbers, truncating the quotient.&#13;
  */&#13;
  function div(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
    // assert(b &gt; 0); // Solidity automatically throws when dividing by 0&#13;
    // uint256 c = a / b;&#13;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold&#13;
    return a / b;&#13;
  }&#13;
&#13;
  /**&#13;
  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).&#13;
  */&#13;
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
    assert(b &lt;= a);&#13;
    return a - b;&#13;
  }&#13;
&#13;
  /**&#13;
  * @dev Adds two numbers, throws on overflow.&#13;
  */&#13;
  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {&#13;
    c = a + b;&#13;
    assert(c &gt;= a);&#13;
    return c;&#13;
  }&#13;
}&#13;
&#13;
/**&#13;
 * @title Ownable&#13;
 * @dev The Ownable contract has an owner address, and provides basic authorization control&#13;
 * functions, this simplifies the implementation of "user permissions".&#13;
 */&#13;
contract Ownable {&#13;
  address public owner;&#13;
&#13;
&#13;
  event OwnershipRenounced(address indexed previousOwner);&#13;
  event OwnershipTransferred(&#13;
    address indexed previousOwner,&#13;
    address indexed newOwner&#13;
  );&#13;
&#13;
&#13;
  /**&#13;
   * @dev The Ownable constructor sets the original `owner` of the contract to the sender&#13;
   * account.&#13;
   */&#13;
  constructor() public {&#13;
    owner = msg.sender;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Throws if called by any account other than the owner.&#13;
   */&#13;
  modifier onlyOwner() {&#13;
    require(msg.sender == owner);&#13;
    _;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Allows the current owner to relinquish control of the contract.&#13;
   */&#13;
  function renounceOwnership() public onlyOwner {&#13;
    emit OwnershipRenounced(owner);&#13;
    owner = address(0);&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Allows the current owner to transfer control of the contract to a newOwner.&#13;
   * @param _newOwner The address to transfer ownership to.&#13;
   */&#13;
  function transferOwnership(address _newOwner) public onlyOwner {&#13;
    _transferOwnership(_newOwner);&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Transfers control of the contract to a newOwner.&#13;
   * @param _newOwner The address to transfer ownership to.&#13;
   */&#13;
  function _transferOwnership(address _newOwner) internal {&#13;
    require(_newOwner != address(0));&#13;
    emit OwnershipTransferred(owner, _newOwner);&#13;
    owner = _newOwner;&#13;
  }&#13;
}&#13;
&#13;
contract PriceUpdaterInterface {&#13;
  enum Currency { ETH, BTC, WME, WMZ, WMR, WMX }&#13;
&#13;
  uint public decimalPrecision = 3;&#13;
&#13;
  mapping(uint =&gt; uint) public price;&#13;
}&#13;
&#13;
contract CrowdsaleInterface {&#13;
  uint public rate;&#13;
  uint public minimumAmount;&#13;
&#13;
  function externalBuyToken(address _beneficiary, PriceUpdaterInterface.Currency _currency, uint _amount, uint _tokens) external;&#13;
}&#13;
&#13;
contract MerchantControllerInterface {&#13;
  mapping(uint =&gt; uint) public totalInvested;&#13;
  mapping(uint =&gt; bool) public paymentId;&#13;
&#13;
  function calcPrice(PriceUpdaterInterface.Currency _currency, uint _tokens) public view returns(uint);&#13;
  function buyTokens(address _beneficiary, PriceUpdaterInterface.Currency _currency, uint _amount, uint _tokens, uint _paymentId) external;&#13;
}&#13;
&#13;
contract MerchantController is MerchantControllerInterface, ReentrancyGuard, Ownable {&#13;
  using SafeMath for uint;&#13;
&#13;
  PriceUpdaterInterface public priceUpdater;&#13;
  CrowdsaleInterface public crowdsale;&#13;
&#13;
  constructor(PriceUpdaterInterface _priceUpdater, CrowdsaleInterface _crowdsale) public  {&#13;
    priceUpdater = _priceUpdater;&#13;
    crowdsale = _crowdsale;&#13;
  }&#13;
&#13;
  function calcPrice(PriceUpdaterInterface.Currency _currency, uint _tokens) &#13;
      public &#13;
      view &#13;
      returns(uint) &#13;
  {&#13;
    uint priceInWei = _tokens.mul(1 ether).div(crowdsale.rate());&#13;
    if (_currency == PriceUpdaterInterface.Currency.ETH) {&#13;
      return priceInWei;&#13;
    }&#13;
    uint etherPrice = priceUpdater.price(uint(PriceUpdaterInterface.Currency.ETH));&#13;
    uint priceInEur = priceInWei.mul(etherPrice).div(1 ether);&#13;
&#13;
    uint currencyPrice = priceUpdater.price(uint(_currency));&#13;
    uint tokensPrice = priceInEur.mul(currencyPrice);&#13;
    &#13;
    return tokensPrice;&#13;
  }&#13;
&#13;
  function buyTokens(&#13;
    address _beneficiary,&#13;
    PriceUpdaterInterface.Currency _currency,&#13;
    uint _amount,&#13;
    uint _tokens,&#13;
    uint _paymentId)&#13;
      external&#13;
      onlyOwner&#13;
      nonReentrant&#13;
  {&#13;
    require(_beneficiary != address(0));&#13;
    require(_currency != PriceUpdaterInterface.Currency.ETH);&#13;
    require(_amount != 0);&#13;
    require(_tokens &gt;= crowdsale.minimumAmount());&#13;
    require(_paymentId != 0);&#13;
    require(!paymentId[_paymentId]);&#13;
    paymentId[_paymentId] = true;&#13;
    crowdsale.externalBuyToken(_beneficiary, _currency, _amount, _tokens);&#13;
  }&#13;
}