pragma solidity ^0.4.18;

/// @title Interface for contracts conforming to ERC-721: Non-Fungible Tokens
/// @author Dieter Shirley <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="82e6e7f6e7c2e3faebedeff8e7ecace1ed">[email protected]</a>&gt; (https://github.com/dete)&#13;
contract ERC721 {&#13;
    // Required methods&#13;
    function implementsERC721() public pure returns (bool);&#13;
    // ERC20 compatible methods&#13;
    function name() public pure returns (string);&#13;
    function symbol() public pure returns (string);&#13;
    function balanceOf(address _owner) public view returns (uint256 balance);&#13;
    function totalSupply() public view returns (uint256 total);&#13;
    // Methods defining ownership&#13;
    function ownerOf(uint256 _tokenId) public view returns (address addr);&#13;
    function approve(address _to, uint256 _tokenId) public;&#13;
    function takeOwnership(uint256 _tokenId) public;&#13;
    function transferFrom(address _from, address _to, uint256 _tokenId) public;&#13;
    function transfer(address _to, uint256 _tokenId) public;&#13;
    // Events&#13;
    event Transfer(address indexed from, address indexed to, uint256 tokenId);&#13;
    event Approval(address indexed owner, address indexed approved, uint256 tokenId);&#13;
}&#13;
&#13;
contract YTIcons is ERC721 {&#13;
&#13;
    /* CONSTANTS */&#13;
&#13;
    /// Name and symbol of the non-fungible token (ERC721)&#13;
    string public constant NAME = "YTIcons";&#13;
    string public constant SYMBOL = "YTIcon";&#13;
&#13;
    /// The corporation address that will be used for its development (giveaway, game events...)&#13;
    address private _utilityFund = 0x6B06a2a15dCf3AE45b9F133Be6FD0Be5a9FAedC2;&#13;
&#13;
    /// When a card isn't verified, the normal share given to the beneficiary linked&#13;
    /// to the card is given to the charity fund's address instead.&#13;
    address private _charityFund = 0xF9864660c4aa89E241d7D44903D3c8A207644332;&#13;
&#13;
    uint16 public _generation = 0;&#13;
    uint256 private _defaultPrice = 0.001 ether;&#13;
    uint256 private firstLimit =  0.05 ether;&#13;
    uint256 private secondLimit = 0.5 ether;&#13;
    uint256 private thirdLimit = 1 ether;&#13;
&#13;
&#13;
    /* STORAGE */&#13;
&#13;
    /// An array containing all of the owners addresses :&#13;
    /// those addresses are the only ones that can execute actions requiring an admin.&#13;
    address private _owner0x = 0x8E787E0c0B05BE25Ec993C5e109881166b675b31;&#13;
    address private _ownerA =  0x97fEA5464539bfE3810b8185E9Fa9D2D6d68a52c;&#13;
    address private _ownerB =  0x0678Ecc4Db075F89B966DE7Ea945C4A866966b0e;&#13;
    address private _ownerC =  0xC39574B02b76a43B03747641612c3d332Dec679B;&#13;
    address private _ownerD =  0x1282006521647ca094503219A61995C8142a9824;&#13;
&#13;
    Card[] private _cards;&#13;
&#13;
    /// A mapping from cards' IDs to their prices [0], the last investment* [1] and their highest price [2].&#13;
    /// *If someone buys an icon for 0.001 ETH, then the last investment of the card will be 0.001 ETH. If someone else buys it back at 0.002 ETH,&#13;
    /// then the last investment will be 0.002 ETH.&#13;
    mapping (uint256 =&gt; uint256[3]) private _cardsPrices;&#13;
&#13;
    /// A mapping from cards' names to the beneficiary addresses&#13;
    mapping (uint256 =&gt; address) private _beneficiaryAddresses;&#13;
&#13;
    /// A mapping from cards' IDs to their owners&#13;
    mapping (uint256 =&gt; address) private _cardsOwners;&#13;
&#13;
    /// A mapping from owner address to count of tokens that address owns.&#13;
    /// Used for ERC721's method 'balanceOf()' to resolve ownership count.&#13;
    mapping (address =&gt; uint256) private _tokenPerOwners;&#13;
&#13;
    /// A mapping from cards' ids to an address that has been approved to call&#13;
    /// transferFrom(). Each Card can only have one approved address for transfer&#13;
    /// at any time. A zero value means no approval is outstanding.&#13;
    mapping (uint256 =&gt; address) public _allowedAddresses;&#13;
&#13;
&#13;
    /* STRUCTURES */&#13;
&#13;
    struct Card {&#13;
        uint16  generation;&#13;
        string  name;&#13;
        bool    isLocked;&#13;
    }&#13;
&#13;
    /* EVENTS */&#13;
    event YTIconSold(uint256 tokenId, uint256 newPrice, address newOwner);&#13;
    event PriceModified(uint256 tokenId, uint256 newPrice);&#13;
&#13;
&#13;
&#13;
    /* ACCESS MODIFIERS */&#13;
&#13;
    /// Access modifier for owner's functionalities and actions only&#13;
    modifier ownerOnly() {&#13;
        require(msg.sender == _owner0x || msg.sender == _ownerA || msg.sender == _ownerB || msg.sender == _ownerC || msg.sender == _ownerD);&#13;
        _;&#13;
    }&#13;
&#13;
&#13;
    /* PROTOCOL METHODS (ERC721) */&#13;
&#13;
    function implementsERC721() public pure returns (bool) {&#13;
        return true;&#13;
    }&#13;
&#13;
        /**************/&#13;
        /* ERC20 compatible methods */&#13;
        /**************/&#13;
&#13;
    /// This function is used to tell outside contracts and applications the name of this token.&#13;
    function name() public pure returns (string) {&#13;
        return NAME;&#13;
    }&#13;
&#13;
    /// It provides outside programs with the token’s shorthand name, or symbol.&#13;
    function symbol() public pure returns (string) {&#13;
        return SYMBOL;&#13;
    }&#13;
&#13;
    /// This function returns the total number of coins available on the blockchain.&#13;
    /// The supply does not have to be constant.&#13;
    function totalSupply() public view returns (uint256 supply) {&#13;
        return _cards.length;&#13;
    }&#13;
&#13;
    /// This function is used to find the number of tokens that a given address owns.&#13;
    function balanceOf(address _owner) public view returns (uint balance) {&#13;
        return _tokenPerOwners[_owner];&#13;
    }&#13;
&#13;
        /**************/&#13;
        /* Ownership methods */&#13;
        /**************/&#13;
&#13;
    /// This function returns the address of the owner of a token. Because each ERC721 token is non-fungible and,&#13;
    /// therefore, unique, it’s referenced on the blockchain via a unique ID.&#13;
    /// We can determine the owner of a token using its ID.&#13;
    function ownerOf(uint256 _tokenId) public view returns (address owner) {&#13;
        require(_addressNotNull(_cardsOwners[_tokenId]));&#13;
        return _cardsOwners[_tokenId];&#13;
    }&#13;
&#13;
    /// This function approves, or grants, another entity permission to transfer a token on the owner’s behalf.&#13;
    function approve(address _to, uint256 _tokenId) public {&#13;
        require(bytes(_cards[_tokenId].name).length != 0);&#13;
        require(!_cards[_tokenId].isLocked);&#13;
        require(_owns(msg.sender, _tokenId));&#13;
        require(msg.sender != _to);&#13;
        _allowedAddresses[_tokenId] = _to;&#13;
        Approval(msg.sender, _to, _tokenId);&#13;
    }&#13;
&#13;
    /// This function acts like a withdraw function, since an outside party can call it in order&#13;
    /// to take tokens out of another user’s account.&#13;
    /// Therefore, takeOwnership can be used to when a user has been approved to own a certain amount of&#13;
    /// tokens and wishes to withdraw said tokens from another user’s balance.&#13;
    function takeOwnership(uint256 _tokenId) public {&#13;
        require(bytes(_cards[_tokenId].name).length != 0);&#13;
        require(!_cards[_tokenId].isLocked);&#13;
        address newOwner = msg.sender;&#13;
        address oldOwner = _cardsOwners[_tokenId];&#13;
        require(_addressNotNull(newOwner));&#13;
        require(newOwner != oldOwner);&#13;
        require(_isAllowed(newOwner, _tokenId));&#13;
&#13;
        _transfer(oldOwner, newOwner, _tokenId);&#13;
    }&#13;
&#13;
    /// "transfer" lets the owner of a token send it to another user, similar to a standalone cryptocurrency.&#13;
    function transfer(address _to, uint256 _tokenId) public {&#13;
        require(bytes(_cards[_tokenId].name).length != 0);&#13;
        require(!_cards[_tokenId].isLocked);&#13;
        require(_owns(msg.sender, _tokenId));&#13;
        require(msg.sender != _to);&#13;
        require(_addressNotNull(_to));&#13;
&#13;
        _transfer(msg.sender, _to, _tokenId);&#13;
    }&#13;
&#13;
    function _transfer(address from, address to, uint256 tokenId) private {&#13;
        // Transfer ownership to the new owner&#13;
        _cardsOwners[tokenId] = to;&#13;
        // Increase the number of tokens own by the new owner&#13;
        _tokenPerOwners[to] += 1;&#13;
&#13;
        // When creating new cards, from is address(0)&#13;
        if (from != address(0)) {&#13;
            _tokenPerOwners[from] -= 1;&#13;
            // clear any previously approved ownership exchange&#13;
            delete _allowedAddresses[tokenId];&#13;
        }&#13;
&#13;
        // Emit the transfer event.&#13;
        Transfer(from, to, tokenId);&#13;
    }&#13;
&#13;
    /// Third-party initiates transfer of token from address from to address to&#13;
    function transferFrom(address from, address to, uint256 tokenId) public {&#13;
        require(!_cards[tokenId].isLocked);&#13;
        require(_owns(from, tokenId));&#13;
        require(_isAllowed(to, tokenId));&#13;
        require(_addressNotNull(to));&#13;
&#13;
        _transfer(from, to, tokenId);&#13;
    }&#13;
&#13;
&#13;
    /* MANAGEMENT FUNCTIONS -- ONLY USABLE BY ADMINS */&#13;
&#13;
    function createCard(string cardName, uint price, address cardOwner, address beneficiary, bool isLocked) public ownerOnly {&#13;
        require(bytes(cardName).length != 0);&#13;
        price = price == 0 ? _defaultPrice : price;&#13;
        _createCard(cardName, price, cardOwner, beneficiary, isLocked);&#13;
    }&#13;
&#13;
    function createCardFromName(string cardName) public ownerOnly {&#13;
        require(bytes(cardName).length != 0);&#13;
        _createCard(cardName, _defaultPrice, address(0), address(0), false);&#13;
    }&#13;
&#13;
    /// Create card&#13;
    function _createCard(string cardName, uint price, address cardOwner, address beneficiary, bool isLocked) private {&#13;
        require(_cards.length &lt; 2^256 - 1);&#13;
        Card memory card = Card({&#13;
                                    generation: _generation,&#13;
                                    name: cardName,&#13;
                                    isLocked: isLocked&#13;
                                });&#13;
        _cardsPrices[_cards.length][0] = price; // Current price&#13;
        _cardsPrices[_cards.length][1] = price; // Last bought price&#13;
        _cardsPrices[_cards.length][2] = price; // Highest&#13;
        _cardsOwners[_cards.length] = cardOwner;&#13;
        _beneficiaryAddresses[_cards.length] = beneficiary;&#13;
        _tokenPerOwners[cardOwner] += 1;&#13;
        _cards.push(card);&#13;
    }&#13;
&#13;
&#13;
    /// Change the current generation&#13;
    function evolveGeneration(uint16 newGeneration) public ownerOnly {&#13;
        _generation = newGeneration;&#13;
    }&#13;
&#13;
    /// Change the address of one owner.&#13;
    function setOwner(address currentAddress, address newAddress) public ownerOnly {&#13;
        require(_addressNotNull(newAddress));&#13;
&#13;
        if (currentAddress == _ownerA) {&#13;
            _ownerA = newAddress;&#13;
        } else if (currentAddress == _ownerB) {&#13;
            _ownerB = newAddress;&#13;
        } else if (currentAddress == _ownerC) {&#13;
            _ownerC = newAddress;&#13;
        } else if (currentAddress == _ownerD) {&#13;
            _ownerD = newAddress;&#13;
        }&#13;
    }&#13;
&#13;
    /// Set the charity fund.&#13;
    function setCharityFund(address newCharityFund) public ownerOnly {&#13;
        _charityFund = newCharityFund;&#13;
    }&#13;
&#13;
    /// Set the beneficiary ETH address.&#13;
    function setBeneficiaryAddress(uint256 tokenId, address beneficiaryAddress) public ownerOnly {&#13;
        require(bytes(_cards[tokenId].name).length != 0);&#13;
        _beneficiaryAddresses[tokenId] = beneficiaryAddress;&#13;
    }&#13;
&#13;
    /// Lock a card and make it unusable&#13;
    function lock(uint256 tokenId) public ownerOnly {&#13;
        require(!_cards[tokenId].isLocked);&#13;
        _cards[tokenId].isLocked = true;&#13;
    }&#13;
&#13;
    /// Unlock a YTIcon and make it usable&#13;
    function unlock(uint256 tokenId) public ownerOnly {&#13;
        require(_cards[tokenId].isLocked);&#13;
        _cards[tokenId].isLocked = false;&#13;
    }&#13;
&#13;
    /// Get the smart contract's balance out of the contract and transfers it to every related account.&#13;
    function payout() public ownerOnly {&#13;
        _payout();&#13;
    }&#13;
&#13;
    function _payout() private {&#13;
        uint256 balance = this.balance;&#13;
        _ownerA.transfer(SafeMath.div(SafeMath.mul(balance, 20), 100));&#13;
        _ownerB.transfer(SafeMath.div(SafeMath.mul(balance, 20), 100));&#13;
        _ownerC.transfer(SafeMath.div(SafeMath.mul(balance, 20), 100));&#13;
        _ownerD.transfer(SafeMath.div(SafeMath.mul(balance, 20), 100));&#13;
        _utilityFund.transfer(SafeMath.div(SafeMath.mul(balance, 20), 100));&#13;
    }&#13;
&#13;
&#13;
    /* UTILS */&#13;
&#13;
    /// Check if the address is valid by checking if it is not equal to 0x0.&#13;
    function _addressNotNull(address target) private pure returns (bool) {&#13;
        return target != address(0);&#13;
    }&#13;
&#13;
    /// Check for token ownership&#13;
    function _owns(address pretender, uint256 tokenId) private view returns (bool) {&#13;
        return pretender == _cardsOwners[tokenId];&#13;
    }&#13;
&#13;
    function _isAllowed(address claimant, uint256 tokenId) private view returns (bool) {&#13;
        return _allowedAddresses[tokenId] == claimant;&#13;
    }&#13;
&#13;
    /* PUBLIC FUNCTIONS */&#13;
&#13;
    /// Get all of the useful card's informations.&#13;
    function getCard(uint256 tokenId) public view returns (string cardName, uint16 generation, bool isLocked, uint256 price, address owner, address beneficiary, bool isVerified) {&#13;
        Card storage card = _cards[tokenId];&#13;
        cardName = card.name;&#13;
        require(bytes(cardName).length != 0);&#13;
        generation = card.generation;&#13;
        isLocked = card.isLocked;&#13;
        price = _cardsPrices[tokenId][0];&#13;
        owner = _cardsOwners[tokenId];&#13;
        beneficiary = _beneficiaryAddresses[tokenId];&#13;
        isVerified = _addressNotNull(_beneficiaryAddresses[tokenId]) ? true : false;&#13;
    }&#13;
&#13;
    /// Set a lower price if the sender is the card's owner.&#13;
    function setPrice(uint256 tokenId, uint256 newPrice) public {&#13;
        require(!_cards[tokenId].isLocked);&#13;
        // If new price &gt; 0&#13;
        // If the new price is higher or equal to the basic investment of the owner (e.g. if someone buys a card 0.001 ETH, then the default investment will be 0.001)&#13;
        // If the new price is lower or equal than the highest price set by the algorithm.&#13;
        require(newPrice &gt; 0 &amp;&amp; newPrice &gt;= _cardsPrices[tokenId][1] &amp;&amp; newPrice &lt;= _cardsPrices[tokenId][2]);&#13;
        require(msg.sender == _cardsOwners[tokenId]);&#13;
&#13;
        _cardsPrices[tokenId][0] = newPrice;&#13;
        PriceModified(tokenId, newPrice);&#13;
    }&#13;
&#13;
    function purchase(uint256 tokenId) public payable {&#13;
        require(!_cards[tokenId].isLocked);&#13;
        require(_cardsPrices[tokenId][0] &gt; 0);&#13;
&#13;
        address oldOwner = _cardsOwners[tokenId];&#13;
        address newOwner = msg.sender;&#13;
&#13;
        uint256 sellingPrice = _cardsPrices[tokenId][0];&#13;
&#13;
        // Making sure the token owner isn't trying to purchase his/her own token.&#13;
        require(oldOwner != newOwner);&#13;
&#13;
        require(_addressNotNull(newOwner));&#13;
&#13;
        // Making sure the amount sent is greater than or equal to the sellingPrice.&#13;
        require(msg.value &gt;= sellingPrice);&#13;
&#13;
        uint256 payment = uint256(SafeMath.div(SafeMath.mul(sellingPrice, 92), 100));&#13;
        uint256 beneficiaryPayment = uint256(SafeMath.div(SafeMath.mul(sellingPrice, 3), 100));&#13;
        uint256 purchaseExcess = SafeMath.sub(msg.value, sellingPrice);&#13;
        uint256 newPrice = 0;&#13;
&#13;
        // Update prices&#13;
        if (sellingPrice &lt; firstLimit) {&#13;
            newPrice = SafeMath.div(SafeMath.mul(sellingPrice, 200), 92);&#13;
        } else if (sellingPrice &lt; secondLimit) {&#13;
            newPrice = SafeMath.div(SafeMath.mul(sellingPrice, 150), 92);&#13;
        } else if (sellingPrice &lt; thirdLimit) {&#13;
            newPrice = SafeMath.div(SafeMath.mul(sellingPrice, 125), 92);&#13;
        } else {&#13;
            newPrice = SafeMath.div(SafeMath.mul(sellingPrice, 115), 92);&#13;
        }&#13;
&#13;
        _cardsPrices[tokenId][0] = newPrice; // New price&#13;
        _cardsPrices[tokenId][1] = sellingPrice; // Last bought price&#13;
        _cardsPrices[tokenId][2] = newPrice; // New highest price&#13;
&#13;
        _transfer(oldOwner, newOwner, tokenId);&#13;
&#13;
        // Pay previous owner&#13;
        if (oldOwner != address(this) &amp;&amp; oldOwner != address(0)) {&#13;
            oldOwner.transfer(payment);&#13;
        }&#13;
&#13;
        if (_beneficiaryAddresses[tokenId] != address(0)) {&#13;
            _beneficiaryAddresses[tokenId].transfer(beneficiaryPayment);&#13;
        } else {&#13;
            _charityFund.transfer(beneficiaryPayment);&#13;
        }&#13;
&#13;
        YTIconSold(tokenId, newPrice, newOwner);&#13;
&#13;
        msg.sender.transfer(purchaseExcess);&#13;
    }&#13;
&#13;
    function getOwnerCards(address owner) public view returns(uint256[] ownerTokens) {&#13;
        uint256 balance = balanceOf(owner);&#13;
        if (balance == 0) {&#13;
            return new uint256[](0);&#13;
        } else {&#13;
            uint256[] memory result = new uint256[](balance);&#13;
            uint256 total = totalSupply();&#13;
            uint256 resultIndex = 0;&#13;
&#13;
            uint256 cardId;&#13;
            for (cardId = 0; cardId &lt;= total; cardId++) {&#13;
                if (_cardsOwners[cardId] == owner) {&#13;
                    result[resultIndex] = cardId;&#13;
                    resultIndex++;&#13;
                }&#13;
            }&#13;
            return result;&#13;
        }&#13;
    }&#13;
&#13;
    function getHighestPrice(uint256 tokenId) public view returns(uint256 highestPrice) {&#13;
        highestPrice = _cardsPrices[tokenId][1];&#13;
    }&#13;
&#13;
}&#13;
&#13;
&#13;
/**&#13;
 * @title SafeMath&#13;
 * @dev Math operations with safety checks that throw on error&#13;
 */&#13;
library SafeMath {&#13;
&#13;
    /**&#13;
    * @dev Multiplies two numbers, throws on overflow.&#13;
    */&#13;
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
        if (a == 0) {&#13;
            return 0;&#13;
        }&#13;
        uint256 c = a * b;&#13;
        assert(c / a == b);&#13;
        return c;&#13;
    }&#13;
&#13;
    /**&#13;
    * @dev Integer division of two numbers, truncating the quotient.&#13;
    */&#13;
    function div(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
        // assert(b &gt; 0); // Solidity automatically throws when dividing by 0&#13;
        uint256 c = a / b;&#13;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold&#13;
        return c;&#13;
    }&#13;
&#13;
    /**&#13;
    * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).&#13;
    */&#13;
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
        assert(b &lt;= a);&#13;
        return a - b;&#13;
    }&#13;
&#13;
}