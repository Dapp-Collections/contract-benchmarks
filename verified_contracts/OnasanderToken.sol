/** @title Onasander Token Contract
*   
*   @author: Andrzej Wegrzyn
*   Contact: <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="4521203320292a3528202b31052a2b2436242b2120376b262a28">[emailÂ protected]</a>&#13;
*   Date: May 5, 2018&#13;
*   Location: New York, USA&#13;
*   Token: Onasander&#13;
*   Symbol: ONA&#13;
*   &#13;
*   @notice This is a simple contract due to solidity bugs and complications. &#13;
*&#13;
*   @notice Owner has the option to burn all the remaining tokens after the ICO.  That way Owners will not end up with majority of the tokens.&#13;
*   @notice Onasander would love to give every user the option to burn the remaining tokens, but due to Solidity VM bugs and risk, we will process&#13;
*   @notice all coin burns and refunds manually.&#13;
*   &#13;
*   @notice How to run the contract:&#13;
*&#13;
*   Requires:&#13;
*   Wallet Address&#13;
*&#13;
*   Run:&#13;
*   1. Create Contract&#13;
*   2. Set Minimum Goal&#13;
*   3. Set Tokens Per ETH&#13;
*   4. Create PRE ICO Sale (can have multiple PRE-ICOs)&#13;
*   5. End PRE ICO Sale&#13;
*   6. Create ICO Sale&#13;
*   7. End ICO Sale&#13;
*   8. END ICO&#13;
*   9. Burn Remaining Tokens&#13;
*&#13;
*   e18 for every value except tokens per ETH&#13;
*   &#13;
*   @dev This contract allows you to configure as many Pre-ICOs as you need.  It's a very simple contract written to give contract admin lots of dynamic options.&#13;
*   @dev Here, most features except for total supply, max tokens for sale, company reserves, and token standard features, are dynamic.  You can configure your contract&#13;
*   @dev however you want to.  &#13;
*&#13;
*   @dev IDE: Remix with Mist 0.10&#13;
*   @dev Token supply numbers are provided in 0e18 format in MIST in order to bypass MIST number format errors.&#13;
*/&#13;
&#13;
pragma solidity ^0.4.23;&#13;
&#13;
contract OnasanderToken&#13;
{&#13;
    using SafeMath for uint;&#13;
    &#13;
    address private wallet;                                // Address where funds are collected&#13;
    address public owner;                                  // contract owner&#13;
    string constant public name = "Onasander";&#13;
    string constant public symbol = "ONA";&#13;
    uint8 constant public decimals = 18;&#13;
    uint public totalSupply = 88000000e18;                       &#13;
    uint public totalTokensSold = 0e18;                    // total number of tokens sold to date&#13;
    uint public totalTokensSoldInThisSale = 0e18;          // total number of tokens sold in this sale&#13;
    uint public maxTokensForSale = 79200000e18;            // 90%  max tokens we can ever sale  &#13;
    uint public companyReserves = 8800000e18;              // 10%  company reserves. this is what we end up with after eco ends and burns the rest if any  &#13;
    uint public minimumGoal = 0e18;                        // hold minimum goal&#13;
    uint public tokensForSale = 0e18;                      // total number of tokens we are selling in the current sale (ICO, preICO)&#13;
    bool public saleEnabled = false;                       // enables all sales: ICO and tokensPreICO&#13;
    bool public ICOEnded = false;                          // flag checking if the ICO has completed&#13;
    bool public burned = false;                            // Excess tokens burned flag after ICO ends&#13;
    uint public tokensPerETH = 800;                        // amount of Onasander tokens you get for 1 ETH&#13;
    bool public wasGoalReached = false;                    // checks if minimum goal was reached&#13;
    address private lastBuyer;&#13;
    uint private singleToken = 1e18;&#13;
&#13;
    constructor(address icoWallet) public &#13;
    {   &#13;
        require(icoWallet != address(0), "ICO Wallet address is required.");&#13;
&#13;
        owner = msg.sender;&#13;
        wallet = icoWallet;&#13;
        balances[owner] = totalSupply;  // give initial full balance to contract owner&#13;
        emit TokensMinted(owner, totalSupply);        &#13;
    }&#13;
&#13;
    event ICOHasEnded();&#13;
    event SaleEnded();&#13;
    event OneTokenBugFixed();&#13;
    event ICOConfigured(uint minimumGoal);&#13;
    event TokenPerETHReset(uint amount);&#13;
    event ICOCapReached(uint amount);&#13;
    event SaleCapReached(uint amount);&#13;
    event GoalReached(uint amount);&#13;
    event Burned(uint amount);    &#13;
    event BuyTokens(address buyer, uint tokens);&#13;
    event SaleStarted(uint tokensForSale);    &#13;
    event TokensMinted(address targetAddress, uint tokens);&#13;
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner, uint tokens);&#13;
    event Transfer(address indexed from, address indexed to, uint tokens);&#13;
    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);&#13;
&#13;
    mapping(address =&gt; uint) balances;&#13;
    &#13;
    mapping(address =&gt; mapping (address =&gt; uint)) allowances;&#13;
&#13;
    function balanceOf(address accountAddress) public constant returns (uint balance)&#13;
    {&#13;
        return balances[accountAddress];&#13;
    }&#13;
&#13;
    function allowance(address sender, address spender) public constant returns (uint remainingAllowedAmount)&#13;
    {&#13;
        return allowances[sender][spender];&#13;
    }&#13;
&#13;
    function transfer(address to, uint tokens) public returns (bool success)&#13;
    {     &#13;
        require (ICOEnded, "ICO has not ended.  Can not transfer.");&#13;
        require (balances[to] + tokens &gt; balances[to], "Overflow is not allowed.");&#13;
&#13;
        // actual transfer&#13;
        // SafeMath.sub will throw if there is not enough balance.&#13;
        balances[msg.sender] = balances[msg.sender].sub(tokens);&#13;
        balances[to] = balances[to].add(tokens);&#13;
        &#13;
        emit Transfer(msg.sender, to, tokens);&#13;
        return true;&#13;
    }&#13;
&#13;
&#13;
&#13;
    function transferFrom(address from, address to, uint tokens) public returns(bool success) &#13;
    {&#13;
        require (ICOEnded, "ICO has not ended.  Can not transfer.");&#13;
        require (balances[to] + tokens &gt; balances[to], "Overflow is not allowed.");&#13;
&#13;
        // actual transfer&#13;
        balances[from] = balances[from].sub(tokens);&#13;
        allowances[from][msg.sender] = allowances[from][msg.sender].sub(tokens); // lower the allowance by the amount of tokens &#13;
        balances[to] = balances[to].add(tokens);&#13;
        &#13;
        emit Transfer(from, to, tokens);        &#13;
        return true;&#13;
    }&#13;
&#13;
    function approve(address spender, uint tokens) public returns(bool success) &#13;
    {          &#13;
        require (ICOEnded, "ICO has not ended.  Can not transfer.");      &#13;
        allowances[msg.sender][spender] = tokens;                &#13;
        emit Approval(msg.sender, spender, tokens);&#13;
        return true;&#13;
    }&#13;
&#13;
        // in case some investor pays by wire or credit card we will transfer him the tokens manually.&#13;
    function wirePurchase(address to, uint numberOfTokenPurchased) onlyOwner public&#13;
    {     &#13;
        require (saleEnabled, "Sale must be enabled.");&#13;
        require (!ICOEnded, "ICO already ended.");&#13;
        require (numberOfTokenPurchased &gt; 0, "Tokens must be greater than 0.");&#13;
        require (tokensForSale &gt; totalTokensSoldInThisSale, "There is no more tokens for sale in this sale.");&#13;
                        &#13;
        // calculate amount&#13;
        uint buyAmount = numberOfTokenPurchased;&#13;
        uint tokens = 0e18;&#13;
&#13;
        // this check is not perfect as someone may want to buy more than we offer for sale and we lose a sale.&#13;
        // the best would be to calclate and sell you only the amout of tokens that is left and refund the rest of money        &#13;
        if (totalTokensSoldInThisSale.add(buyAmount) &gt;= tokensForSale)&#13;
        {&#13;
            tokens = tokensForSale.sub(totalTokensSoldInThisSale);  // we allow you to buy only up to total tokens for sale, and refund the rest&#13;
            // need to program the refund for the rest,or do it manually.  &#13;
        }&#13;
        else&#13;
        {&#13;
            tokens = buyAmount;&#13;
        }&#13;
&#13;
        // transfer only as we do not need to take the payment since we already did in wire&#13;
        require (balances[to].add(tokens) &gt; balances[to], "Overflow is not allowed.");&#13;
        balances[to] = balances[to].add(tokens);&#13;
        balances[owner] = balances[owner].sub(tokens);&#13;
        lastBuyer = to;&#13;
&#13;
        // update counts&#13;
        totalTokensSold = totalTokensSold.add(tokens);&#13;
        totalTokensSoldInThisSale = totalTokensSoldInThisSale.add(tokens);&#13;
        &#13;
        emit BuyTokens(to, tokens);&#13;
        emit Transfer(owner, to, tokens);&#13;
&#13;
        isGoalReached();&#13;
        isMaxCapReached();&#13;
    }&#13;
&#13;
    function buyTokens() payable public&#13;
    {        &#13;
        require (saleEnabled, "Sale must be enabled.");&#13;
        require (!ICOEnded, "ICO already ended.");&#13;
        require (tokensForSale &gt; totalTokensSoldInThisSale, "There is no more tokens for sale in this sale.");&#13;
        require (msg.value &gt; 0, "Must send ETH");&#13;
&#13;
        // calculate amount&#13;
        uint buyAmount = SafeMath.mul(msg.value, tokensPerETH);&#13;
        uint tokens = 0e18;&#13;
&#13;
        // this check is not perfect as someone may want to buy more than we offer for sale and we lose a sale.&#13;
        // the best would be to calclate and sell you only the amout of tokens that is left and refund the rest of money        &#13;
        if (totalTokensSoldInThisSale.add(buyAmount) &gt;= tokensForSale)&#13;
        {&#13;
            tokens = tokensForSale.sub(totalTokensSoldInThisSale);  // we allow you to buy only up to total tokens for sale, and refund the rest&#13;
&#13;
            // need to program the refund for the rest&#13;
        }&#13;
        else&#13;
        {&#13;
            tokens = buyAmount;&#13;
        }&#13;
&#13;
        // buy&#13;
        require (balances[msg.sender].add(tokens) &gt; balances[msg.sender], "Overflow is not allowed.");&#13;
        balances[msg.sender] = balances[msg.sender].add(tokens);&#13;
        balances[owner] = balances[owner].sub(tokens);&#13;
        lastBuyer = msg.sender;&#13;
&#13;
        // take the money out right away&#13;
        wallet.transfer(msg.value);&#13;
&#13;
        // update counts&#13;
        totalTokensSold = totalTokensSold.add(tokens);&#13;
        totalTokensSoldInThisSale = totalTokensSoldInThisSale.add(tokens);&#13;
        &#13;
        emit BuyTokens(msg.sender, tokens);&#13;
        emit Transfer(owner, msg.sender, tokens);&#13;
&#13;
        isGoalReached();&#13;
        isMaxCapReached();&#13;
    }&#13;
&#13;
    // Fallback function. Used for buying tokens from contract owner by simply&#13;
    // sending Ethers to contract.&#13;
    function() public payable &#13;
    {&#13;
        // we buy tokens using whatever ETH was sent in&#13;
        buyTokens();&#13;
    }&#13;
&#13;
    // Called when ICO is closed. Burns the remaining tokens except the tokens reserved&#13;
    // Must be called by the owner to trigger correct transfer event&#13;
    function burnRemainingTokens() public onlyOwner&#13;
    {&#13;
        require (!burned, "Remaining tokens have been burned already.");&#13;
        require (ICOEnded, "ICO has not ended yet.");&#13;
&#13;
        uint difference = balances[owner].sub(companyReserves); &#13;
&#13;
        if (wasGoalReached)&#13;
        {&#13;
            totalSupply = totalSupply.sub(difference);&#13;
            balances[owner] = companyReserves;&#13;
        }&#13;
        else&#13;
        {&#13;
            // in case we did not reach the goal, we burn all tokens except tokens purchased.&#13;
            totalSupply = totalTokensSold;&#13;
            balances[owner] = 0e18;&#13;
        }&#13;
&#13;
        burned = true;&#13;
&#13;
        emit Transfer(owner, address(0), difference);    // this is run in order to update token holders in the website&#13;
        emit Burned(difference);        &#13;
    }&#13;
&#13;
    modifier onlyOwner() &#13;
    {&#13;
        require(msg.sender == owner);&#13;
        _;&#13;
    }&#13;
&#13;
    function transferOwnership(address newOwner) onlyOwner public&#13;
    {&#13;
        address preOwner = owner;        &#13;
        owner = newOwner;&#13;
&#13;
        uint previousBalance = balances[preOwner];&#13;
&#13;
        // transfer balance &#13;
        balances[newOwner] = balances[newOwner].add(previousBalance);&#13;
        balances[preOwner] = 0;&#13;
&#13;
        //emit Transfer(preOwner, newOwner, previousBalance); // required to update the Token Holders on the network&#13;
        emit OwnershipTransferred(preOwner, newOwner, previousBalance);&#13;
    }&#13;
&#13;
    // Set the number of ONAs sold per ETH &#13;
    function setTokensPerETH(uint newRate) onlyOwner public&#13;
    {&#13;
        require (!ICOEnded, "ICO already ended.");&#13;
        require (newRate &gt; 0, "Rate must be higher than 0.");&#13;
        tokensPerETH = newRate;&#13;
        emit TokenPerETHReset(newRate);&#13;
    }&#13;
&#13;
    // Minimum goal is based on USD, not on ETH. Since we will have different dynamic prices based on the daily pirce of ETH, we&#13;
    // will need to be able to adjust our minimum goal in tokens sold, as our goal is set in tokens, not USD.&#13;
    function setMinimumGoal(uint goal) onlyOwner public&#13;
    {   &#13;
        require(goal &gt; 0e18,"Minimum goal must be greater than 0.");&#13;
        minimumGoal = goal;&#13;
&#13;
        // since we can edit the goal, we want to check if we reached the goal before in case we lowered the goal number.&#13;
        isGoalReached();&#13;
&#13;
        emit ICOConfigured(goal);&#13;
    }&#13;
&#13;
    function createSale(uint numberOfTokens) onlyOwner public&#13;
    {&#13;
        require (!saleEnabled, "Sale is already going on.");&#13;
        require (!ICOEnded, "ICO already ended.");&#13;
        require (totalTokensSold &lt; maxTokensForSale, "We already sold all our tokens.");&#13;
&#13;
        totalTokensSoldInThisSale = 0e18;&#13;
        uint tryingToSell = totalTokensSold.add(numberOfTokens);&#13;
&#13;
        // in case we are trying to create a sale with too many tokens, we subtract and sell only what's left&#13;
        if (tryingToSell &gt; maxTokensForSale)&#13;
        {&#13;
            tokensForSale = maxTokensForSale.sub(totalTokensSold); &#13;
        }&#13;
        else&#13;
        {&#13;
            tokensForSale = numberOfTokens;&#13;
        }&#13;
&#13;
        tryingToSell = 0e18;&#13;
        saleEnabled = true;&#13;
        emit SaleStarted(tokensForSale);&#13;
    }&#13;
&#13;
    function endSale() public&#13;
    {&#13;
        if (saleEnabled)&#13;
        {&#13;
            saleEnabled = false;&#13;
            tokensForSale = 0e18;&#13;
            emit SaleEnded();&#13;
        }&#13;
    }&#13;
&#13;
    function endICO() onlyOwner public&#13;
    {&#13;
        if (!ICOEnded)&#13;
        {&#13;
            // run this before end of ICO and end of last sale            &#13;
            fixTokenCalcBug();&#13;
&#13;
            endSale();&#13;
&#13;
            ICOEnded = true;            &#13;
            lastBuyer = address(0);&#13;
            &#13;
            emit ICOHasEnded();&#13;
        }&#13;
    }&#13;
&#13;
    function isGoalReached() internal&#13;
    {&#13;
        // check if we reached the goal&#13;
        if (!wasGoalReached)&#13;
        {&#13;
            if (totalTokensSold &gt;= minimumGoal)&#13;
            {&#13;
                wasGoalReached = true;&#13;
                emit GoalReached(minimumGoal);&#13;
            }&#13;
        }&#13;
    }&#13;
&#13;
    function isMaxCapReached() internal&#13;
    {&#13;
        if (totalTokensSoldInThisSale &gt;= tokensForSale)&#13;
        {            &#13;
            emit SaleCapReached(totalTokensSoldInThisSale);&#13;
            endSale();&#13;
        }&#13;
&#13;
        if (totalTokensSold &gt;= maxTokensForSale)&#13;
        {            &#13;
            emit ICOCapReached(maxTokensForSale);&#13;
            endICO();&#13;
        }&#13;
    }&#13;
&#13;
    // This is a hack to add the lost token during final full sale. &#13;
    function fixTokenCalcBug() internal&#13;
    {        &#13;
        require(!burned, "Fix lost token can only run before the burning of the tokens.");        &#13;
        &#13;
        if (maxTokensForSale.sub(totalTokensSold) == singleToken)&#13;
        {&#13;
            totalTokensSold = totalTokensSold.add(singleToken);&#13;
            totalTokensSoldInThisSale = totalTokensSoldInThisSale.add(singleToken);&#13;
            &#13;
            balances[lastBuyer] = balances[lastBuyer].add(singleToken);&#13;
            balances[owner] = balances[owner].sub(singleToken);&#13;
&#13;
            emit Transfer(owner, lastBuyer, singleToken);&#13;
            emit OneTokenBugFixed();&#13;
        }&#13;
    }&#13;
}&#13;
&#13;
library SafeMath {&#13;
&#13;
  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {&#13;
    if (a == 0) {&#13;
      return 0;&#13;
    }&#13;
    c = a * b;&#13;
    assert(c / a == b);&#13;
    return c;&#13;
  }&#13;
&#13;
  function div(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
    // assert(b &gt; 0); // Solidity automatically throws when dividing by 0&#13;
    // uint c = a / b;&#13;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold&#13;
    return a / b;&#13;
  }&#13;
&#13;
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
    assert(b &lt;= a);&#13;
    return a - b;&#13;
  }&#13;
&#13;
  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {&#13;
    c = a + b;&#13;
    assert(c &gt;= a);&#13;
    return c;&#13;
  }&#13;
}