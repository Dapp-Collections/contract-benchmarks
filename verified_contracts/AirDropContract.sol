pragma solidity 0.4.18;

/// @title LRC Foundation Icebox Program
/// @author Daniel Wang - <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="482c2926212d2408242727383a21262f66273a2f">[email protected]</a>&gt;.&#13;
/// For more information, please visit https://loopring.org.&#13;
&#13;
/// Loopring Foundation's LRC (20% of total supply) will be locked during the first two years，&#13;
/// two years later, 1/24 of all locked LRC fund can be unlocked every month.&#13;
&#13;
/// @title ERC20 ERC20 Interface&#13;
/// @dev see https://github.com/ethereum/EIPs/issues/20&#13;
/// @author Daniel Wang - &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="5430353a3d313814383b3b24263d3a337a3b2633">[email protected]</a>&gt;&#13;
contract ERC20 {&#13;
    uint public totalSupply;&#13;
&#13;
    event Transfer(address indexed from, address indexed to, uint256 value);&#13;
    event Approval(address indexed owner, address indexed spender, uint256 value);&#13;
&#13;
    function balanceOf(address who) view public returns (uint256);&#13;
    function allowance(address owner, address spender) view public returns (uint256);&#13;
    function transfer(address to, uint256 value) public returns (bool);&#13;
    function transferFrom(address from, address to, uint256 value) public returns (bool);&#13;
    function approve(address spender, uint256 value) public returns (bool);&#13;
}&#13;
&#13;
contract AirDropContract {&#13;
&#13;
    event AirDropped(address addr, uint amount);&#13;
&#13;
    function drop(&#13;
        address tokenAddress,&#13;
        uint amount,&#13;
        uint minTokenBalance,&#13;
        uint maxTokenBalance,&#13;
        uint minEthBalance,&#13;
        uint maxEthBalance,&#13;
        address[] recipients) public {&#13;
&#13;
        require(tokenAddress != 0x0);&#13;
        require(amount &gt; 0);&#13;
        require(maxTokenBalance &gt;= minTokenBalance);&#13;
        require(maxEthBalance &gt;= minEthBalance);&#13;
&#13;
        ERC20 token = ERC20(tokenAddress);&#13;
&#13;
        uint balance = token.balanceOf(msg.sender);&#13;
        uint allowance = token.allowance(msg.sender, address(this));&#13;
        uint available = balance &gt; allowance ? allowance : balance;&#13;
&#13;
        for (uint i = 0; i &lt; recipients.length; i++) {&#13;
            require(available &gt;= amount);&#13;
            address recipient = recipients[i];&#13;
            if (isQualitifiedAddress(&#13;
                token,&#13;
                recipient,&#13;
                minTokenBalance,&#13;
                maxTokenBalance,&#13;
                minEthBalance,&#13;
                maxEthBalance&#13;
            )) {&#13;
                available -= amount;&#13;
                require(token.transferFrom(msg.sender, recipient, amount));&#13;
&#13;
                AirDropped(recipient, amount);&#13;
            }&#13;
        }&#13;
    }&#13;
&#13;
    function isQualitifiedAddress(&#13;
        ERC20 token,&#13;
        address addr,&#13;
        uint minTokenBalance,&#13;
        uint maxTokenBalance,&#13;
        uint minEthBalance,&#13;
        uint maxEthBalance&#13;
        )&#13;
        public&#13;
        view&#13;
        returns (bool result)&#13;
    {&#13;
        result = addr != 0x0 &amp;&amp; addr != msg.sender &amp;&amp; !isContract(addr);&#13;
&#13;
        uint ethBalance = addr.balance;&#13;
        uint tokenBbalance = token.balanceOf(addr);&#13;
&#13;
        result = result &amp;&amp; (ethBalance&gt;= minEthBalance &amp;&amp;&#13;
            ethBalance &lt;= maxEthBalance &amp;&amp;&#13;
            tokenBbalance &gt;= minTokenBalance &amp;&amp;&#13;
            tokenBbalance &lt;= maxTokenBalance);&#13;
    }&#13;
&#13;
    function isContract(address addr) internal view returns (bool) {&#13;
        uint size;&#13;
        assembly { size := extcodesize(addr) }&#13;
        return size &gt; 0;&#13;
    }&#13;
&#13;
    function () payable public {&#13;
        revert();&#13;
    }&#13;
}