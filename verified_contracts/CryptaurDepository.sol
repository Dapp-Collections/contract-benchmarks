/*
This file is part of the Cryptaur Contract.

The CryptaurToken Contract is free software: you can redistribute it and/or
modify it under the terms of the GNU lesser General Public License as published
by the Free Software Foundation, either version 3 of the License, or
(at your option) any later version. See the GNU lesser General Public License
for more details.

You should have received a copy of the GNU lesser General Public License
along with the CryptaurToken Contract. If not, see <http://www.gnu.org/licenses/>.

@author Ilya Svirin <<span class="__cf_email__" data-cfemail="f59cdb86839c879c9bb59b9a879194839c9b91db8780">[emailÂ protected]</span>&gt;&#13;
Donation address 0x3Ad38D1060d1c350aF29685B2b8Ec3eDE527452B&#13;
*/&#13;
&#13;
pragma solidity ^0.4.19;&#13;
&#13;
contract owned {&#13;
&#13;
    address public owner;&#13;
    address public candidate;&#13;
&#13;
    function owned() payable public {&#13;
        owner = msg.sender;&#13;
    }&#13;
    &#13;
    modifier onlyOwner {&#13;
        require(owner == msg.sender);&#13;
        _;&#13;
    }&#13;
&#13;
    function changeOwner(address _owner) onlyOwner public {&#13;
        candidate = _owner;&#13;
    }&#13;
    &#13;
    function confirmOwner() public {&#13;
        require(candidate == msg.sender);&#13;
        owner = candidate;&#13;
        delete candidate;&#13;
    }&#13;
}&#13;
&#13;
/**&#13;
 * @title Part of ERC20 interface&#13;
 * @dev see https://github.com/ethereum/EIPs/issues/20&#13;
 */&#13;
contract ERC20Base {&#13;
    uint public totalSupply;&#13;
    function balanceOf(address who) public constant returns (uint);&#13;
    function transfer(address to, uint value) public;&#13;
}&#13;
&#13;
contract CryptaurRewards {&#13;
    function payment(address _buyer, address _seller, uint _amount, address _opinionLeader) public returns(uint fee);&#13;
}&#13;
&#13;
contract CryputarReserveFund {&#13;
    function depositNotification(uint _amount) public;&#13;
    function withdrawNotification(uint _amount) public;&#13;
}&#13;
&#13;
/**&#13;
 * @title Allows to store liked adsress(slave address) connected to the main address (master address)&#13;
 */&#13;
contract AddressBook {&#13;
&#13;
    struct AddressRelations {&#13;
        SlaveDictionary slaves;&#13;
        bool hasValue;&#13;
    }&#13;
&#13;
    struct SlaveDictionary&#13;
    {&#13;
        address[] values;&#13;
        mapping(address =&gt; uint) keys;&#13;
    }&#13;
&#13;
    event WalletLinked(address indexed _master, address indexed _slave);&#13;
    event WalletUnlinked(address indexed _master, address indexed _slave);&#13;
    event AddressChanged(address indexed _old, address indexed _new);&#13;
&#13;
    mapping(address =&gt; AddressRelations) private masterToSlaves;&#13;
    mapping(address =&gt; address) private slaveToMasterAddress;&#13;
    uint8 public maxLinkedWalletCount = 5;&#13;
&#13;
    /**&#13;
     * Only owner of master wallet can add additional wallet.&#13;
     */&#13;
    function linkToMasterWalletInternal(address _masterWallet, address _linkedWallet) internal {&#13;
        require(_masterWallet != _linkedWallet &amp;&amp; _linkedWallet != address(0));&#13;
        require(isMasterWallet(_masterWallet));&#13;
        require(!isLinkedWallet(_linkedWallet) &amp;&amp; !isMasterWallet(_linkedWallet));&#13;
        AddressRelations storage rel = masterToSlaves[_masterWallet];&#13;
        require(rel.slaves.values.length &lt; maxLinkedWalletCount);    &#13;
        rel.slaves.values.push(_linkedWallet);&#13;
        rel.slaves.keys[_linkedWallet] = rel.slaves.values.length - 1;&#13;
        slaveToMasterAddress[_linkedWallet] = _masterWallet;&#13;
        WalletLinked(_masterWallet, _linkedWallet);&#13;
    }&#13;
 &#13;
    function unLinkFromMasterWalletInternal(address _masterWallet, address _linkedWallet) internal {&#13;
        require(_masterWallet != _linkedWallet &amp;&amp; _linkedWallet != address(0));&#13;
        require(_masterWallet == getMasterWallet(_linkedWallet));&#13;
        SlaveDictionary storage slaves = masterToSlaves[_masterWallet].slaves;&#13;
        uint indexToDelete = slaves.keys[_linkedWallet];&#13;
        address keyToMove = slaves.values[slaves.values.length - 1];&#13;
        slaves.values[indexToDelete] = keyToMove;&#13;
        slaves.keys[keyToMove] = indexToDelete;&#13;
        slaves.values.length--;&#13;
        delete slaves.keys[_linkedWallet];&#13;
        delete slaveToMasterAddress[_linkedWallet];&#13;
        WalletUnlinked(_masterWallet, _linkedWallet);&#13;
    }&#13;
&#13;
    function getLinkedWallets(address _wallet) public view returns (address[]) {&#13;
        return masterToSlaves[_wallet].slaves.values;&#13;
    }&#13;
&#13;
    function isMasterWallet(address _addr) internal constant returns (bool) {&#13;
        return masterToSlaves[_addr].hasValue;&#13;
    }&#13;
&#13;
    function isLinkedWallet(address _addr) internal constant returns (bool) {&#13;
        return slaveToMasterAddress[_addr] != address(0);&#13;
    }&#13;
&#13;
    /**&#13;
     * Guess that address book already had changing address.&#13;
     */ &#13;
    function applyChangeWalletAddress(address _old, address _new) internal {&#13;
        require(isMasterWallet(_old) || isLinkedWallet(_old));&#13;
        require(_new != address(0));&#13;
        if (isMasterWallet(_old)) {&#13;
            // Cannt change master address with existed linked&#13;
            require(!isLinkedWallet(_new));&#13;
            require(masterToSlaves[_new].slaves.values.length == 0);&#13;
            changeMasterAddress(_old, _new);&#13;
        }&#13;
        else {&#13;
            // Cannt change linked address with existed master and linked to another master&#13;
            require(!isMasterWallet(_new) &amp;&amp; !isLinkedWallet(_new));&#13;
            changeLinkedAddress(_old, _new);&#13;
        }&#13;
    }&#13;
&#13;
    function changeLinkedAddress(address _old, address _new) private {&#13;
        slaveToMasterAddress[_new] = slaveToMasterAddress[_old];     &#13;
        SlaveDictionary storage slaves = masterToSlaves[slaveToMasterAddress[_new]].slaves;&#13;
        uint index = slaves.keys[_old];&#13;
        slaves.values[index] = _new;&#13;
        delete slaveToMasterAddress[_old];&#13;
    }&#13;
    &#13;
    function changeMasterAddress(address _old, address _new) private {    &#13;
        masterToSlaves[_new] = masterToSlaves[_old];  &#13;
        SlaveDictionary storage slaves = masterToSlaves[_new].slaves;&#13;
        for (uint8 i = 0; i &lt; slaves.values.length; ++i)&#13;
            slaveToMasterAddress[slaves.values[i]] = _new;&#13;
        delete masterToSlaves[_old];&#13;
    }&#13;
&#13;
    function addMasterWallet(address _master) internal {&#13;
        require(_master != address(0));&#13;
        masterToSlaves[_master].hasValue = true;&#13;
    }&#13;
&#13;
    function getMasterWallet(address _wallet) internal constant returns(address) {&#13;
        if(isMasterWallet(_wallet))&#13;
            return _wallet;&#13;
        return slaveToMasterAddress[_wallet];  &#13;
    }&#13;
&#13;
    /**&#13;
     * Try to find master address by any other; otherwise add to address book as master.&#13;
     */&#13;
    function getOrAddMasterWallet(address _wallet) internal returns (address) {&#13;
        address masterWallet = getMasterWallet(_wallet);&#13;
        if (masterWallet == address(0))&#13;
            addMasterWallet(_wallet);&#13;
        return _wallet;&#13;
    }&#13;
}&#13;
&#13;
contract CryptaurDepository is owned, AddressBook {&#13;
    enum UnlimitedMode {UNLIMITED,LIMITED}&#13;
&#13;
    event Deposit(address indexed _who, uint _amount, bytes32 _txHash);&#13;
    event Withdraw(address indexed _who, uint _amount);&#13;
    event Payment(address indexed _buyer, address indexed _seller, uint _amount, address indexed _opinionLeader, bool _dapp);&#13;
    event Freeze(address indexed _who, bool _freeze);&#13;
    event Share(address indexed _who, address indexed _dapp, uint _amount);&#13;
&#13;
    ERC20Base cryptaurToken = ERC20Base(0x88d50B466BE55222019D71F9E8fAe17f5f45FCA1);&#13;
    address cryptaurRecovery;&#13;
    address cryptaurRewards;&#13;
    address cryptaurReserveFund;&#13;
    address backend;&#13;
    modifier onlyBackend {&#13;
        require(backend == msg.sender);&#13;
        _;&#13;
    }&#13;
&#13;
    modifier onlyOwnerOrBackend {&#13;
        require(owner == msg.sender || backend == msg.sender);&#13;
        _;&#13;
    }&#13;
&#13;
    modifier notFreezed {&#13;
        require(freezedAll != true);&#13;
        _;&#13;
    }&#13;
&#13;
    mapping(address =&gt; uint) internal balances;&#13;
    mapping(address =&gt; mapping (address =&gt; uint256)) public available;&#13;
    mapping(address =&gt; bool) public freezed;&#13;
    mapping(address =&gt; mapping(address =&gt; UnlimitedMode)) public unlimitedMode;&#13;
    bool freezedAll;&#13;
  &#13;
    function CryptaurDepository() owned() public {}&#13;
&#13;
    function balanceOf(address _who) constant public returns (uint) {&#13;
        return balances[getMasterWallet(_who)];&#13;
    }&#13;
&#13;
    function setUnlimitedMode(bool _unlimited, address _dapp) public {&#13;
        address masterWallet = getOrAddMasterWallet(msg.sender);&#13;
        unlimitedMode[masterWallet][_dapp] = _unlimited ? UnlimitedMode.UNLIMITED : UnlimitedMode.LIMITED;&#13;
    }&#13;
&#13;
    function transferToToken(address[] _addresses) public onlyOwnerOrBackend {&#13;
        for (uint index = 0; index &lt; _addresses.length; index++) {&#13;
            address addr = _addresses[index];&#13;
            uint amount = balances[addr];&#13;
            if (amount &gt; 0) {&#13;
                balances[addr] = 0;&#13;
                cryptaurToken.transfer(addr, amount);&#13;
                Withdraw(addr, amount);&#13;
            }        &#13;
        }&#13;
    }&#13;
&#13;
    function setBackend(address _backend) onlyOwner public {&#13;
        backend = _backend;&#13;
    }&#13;
&#13;
    function setCryptaurRecovery(address _cryptaurRecovery) onlyOwner public {&#13;
        cryptaurRecovery = _cryptaurRecovery;&#13;
    }&#13;
&#13;
    function setCryptaurToken(address _cryptaurToken) onlyOwner public {&#13;
        cryptaurToken = ERC20Base(_cryptaurToken);&#13;
    }&#13;
&#13;
    function setCryptaurRewards(address _cryptaurRewards) onlyOwner public {&#13;
        cryptaurRewards = _cryptaurRewards;&#13;
    }&#13;
&#13;
    function setCryptaurReserveFund(address _cryptaurReserveFund) onlyOwner public {&#13;
        cryptaurReserveFund = _cryptaurReserveFund;&#13;
    }&#13;
    &#13;
    function changeAddress(address _old, address _new) public {&#13;
        require(msg.sender == cryptaurRecovery);&#13;
        applyChangeWalletAddress(_old, _new);&#13;
&#13;
        balances[_new] += balances[_old];&#13;
        balances[_old] = 0;&#13;
        AddressChanged(_old, _new);&#13;
    }&#13;
&#13;
    function linkToMasterWallet(address _masterWaller, address _linkedWaller) public {&#13;
        require(msg.sender == owner || msg.sender == backend || msg.sender == cryptaurRecovery);&#13;
        linkToMasterWalletInternal(_masterWaller, _linkedWaller);&#13;
    }&#13;
&#13;
    function unLinkFromMasterWallet(address _masterWaller, address _linkedWaller) public {&#13;
        require(msg.sender == owner || msg.sender == backend || msg.sender == cryptaurRecovery);&#13;
        unLinkFromMasterWalletInternal(_masterWaller, _linkedWaller);&#13;
    }&#13;
&#13;
    function setMaxLinkedWalletCount(uint8 _newMaxCount) public onlyOwnerOrBackend {&#13;
        maxLinkedWalletCount = _newMaxCount;&#13;
    }&#13;
    &#13;
    function freeze(address _who, bool _freeze) onlyOwner public {&#13;
        address masterWallet = getMasterWallet(_who);&#13;
        if (masterWallet == address(0))&#13;
            masterWallet = _who;&#13;
        freezed[masterWallet] = _freeze;&#13;
        Freeze(masterWallet, _freeze);&#13;
    }&#13;
&#13;
    function freeze(bool _freeze) public onlyOwnerOrBackend {&#13;
        freezedAll = _freeze;&#13;
    }&#13;
    &#13;
    function deposit(address _who, uint _amount, bytes32 _txHash) onlyBackend public {&#13;
        address masterWallet = getOrAddMasterWallet(_who);&#13;
        balances[masterWallet] += _amount;&#13;
        Deposit(masterWallet, _amount, _txHash);&#13;
    }&#13;
    &#13;
    function withdraw(uint _amount) public notFreezed {&#13;
        address masterWallet = getMasterWallet(msg.sender);   &#13;
        require(balances[masterWallet] &gt;= _amount);&#13;
        require(!freezed[masterWallet]);&#13;
        balances[masterWallet] -= _amount;&#13;
        cryptaurToken.transfer(masterWallet, _amount);&#13;
        Withdraw(masterWallet, _amount);&#13;
    }&#13;
&#13;
    function balanceOf2(address _who, address _dapp) constant public returns (uint) { &#13;
        return balanceOf2Internal(getMasterWallet(_who), _dapp);&#13;
    }&#13;
    &#13;
    function balanceOf2Internal(address _who, address _dapp) constant internal returns (uint) {&#13;
        uint avail;&#13;
        if (!freezed[_who]) {&#13;
            if (unlimitedMode[_who][_dapp] == UnlimitedMode.UNLIMITED) {&#13;
                avail = balances[_who];&#13;
            } &#13;
            else {&#13;
                avail = available[_who][_dapp];&#13;
                if (avail &gt; balances[_who])&#13;
                    avail = balances[_who];&#13;
            }&#13;
        }&#13;
        return avail;&#13;
    }&#13;
    /**&#13;
     * @dev Function pay wrapper. Using only for dapp.&#13;
     */&#13;
    function pay2(address _seller, uint _amount, address _opinionLeader) public notFreezed {&#13;
        address dapp = getOrAddMasterWallet(msg.sender);&#13;
        address seller = getOrAddMasterWallet(_seller);&#13;
        payInternal(dapp, seller, _amount, _opinionLeader);&#13;
        available[seller][dapp] += _amount;&#13;
    }&#13;
&#13;
    function pay(address _seller, uint _amount, address _opinionLeader) public notFreezed {&#13;
        address buyer = getOrAddMasterWallet(msg.sender);&#13;
        address seller = getOrAddMasterWallet(_seller);&#13;
        payInternal(buyer, seller, _amount, _opinionLeader);&#13;
    }&#13;
    &#13;
    /**&#13;
     * @dev Common internal pay function.&#13;
     * OpinionLeader is optional, can be zero.&#13;
     */&#13;
    function payInternal(address _buyer, address _seller, uint _amount, address _opinionLeader) internal {    &#13;
        require(balances[_buyer] &gt;= _amount);&#13;
        uint fee;&#13;
        if (cryptaurRewards != 0 &amp;&amp; cryptaurReserveFund != 0) {&#13;
            fee = CryptaurRewards(cryptaurRewards).payment(_buyer, _seller, _amount, _opinionLeader);&#13;
        }&#13;
        balances[_buyer] -= _amount;&#13;
        balances[_seller] += _amount - fee;&#13;
        if (fee != 0) {&#13;
            balances[cryptaurReserveFund] += fee;&#13;
            CryputarReserveFund(cryptaurReserveFund).depositNotification(_amount);&#13;
        }&#13;
        Payment(_buyer, _seller, _amount, _opinionLeader, false);&#13;
    }&#13;
    &#13;
    function payDAPP(address _buyer, uint _amount, address _opinionLeader) public notFreezed {&#13;
        address buyerMasterWallet = getOrAddMasterWallet(_buyer);&#13;
        require(balanceOf2Internal(buyerMasterWallet, msg.sender) &gt;= _amount);&#13;
        uint fee;&#13;
        if (cryptaurRewards != 0 &amp;&amp; cryptaurReserveFund != 0) {&#13;
            fee = CryptaurRewards(cryptaurRewards).payment(buyerMasterWallet, msg.sender, _amount, _opinionLeader);&#13;
        }&#13;
        balances[buyerMasterWallet] -= _amount;&#13;
        balances[msg.sender] += _amount - fee; &#13;
        if (unlimitedMode[buyerMasterWallet][msg.sender] == UnlimitedMode.LIMITED)&#13;
            available[buyerMasterWallet][msg.sender] -= _amount;&#13;
        if (fee != 0) {&#13;
            balances[cryptaurReserveFund] += fee;&#13;
            CryputarReserveFund(cryptaurReserveFund).depositNotification(_amount);&#13;
        }&#13;
        Payment(buyerMasterWallet, msg.sender, _amount, _opinionLeader, true);&#13;
    }&#13;
&#13;
    function shareBalance(address _dapp, uint _amount) public notFreezed {&#13;
        address masterWallet = getMasterWallet(msg.sender);&#13;
        require(masterWallet != address(0));&#13;
        available[masterWallet][_dapp] = _amount;&#13;
        Share(masterWallet, _dapp, _amount);&#13;
    }&#13;
    &#13;
    function transferFromFund(address _to, uint _amount) public {&#13;
        require(msg.sender == owner || msg.sender == cryptaurRewards || msg.sender == backend);&#13;
        require(cryptaurReserveFund != address(0));&#13;
        require(balances[cryptaurReserveFund] &gt;= _amount);&#13;
        address masterWallet = getOrAddMasterWallet(_to);&#13;
        balances[masterWallet] += _amount;&#13;
        balances[cryptaurReserveFund] -= _amount;&#13;
        CryputarReserveFund(cryptaurReserveFund).withdrawNotification(_amount);&#13;
    }&#13;
}&#13;
&#13;
// test only&#13;
contract CryptaurDepositoryTest is CryptaurDepository {&#13;
    function CryptaurDepositoryTest() CryptaurDepository() {}&#13;
&#13;
    // test only&#13;
    function testDrip(address _who, address _dapp, uint _amount) public {&#13;
        require(msg.sender == owner || msg.sender == backend);&#13;
        address masterWallet = getOrAddMasterWallet(_who);&#13;
        balances[masterWallet] = _amount;&#13;
        available[masterWallet][_dapp] = _amount;&#13;
    }&#13;
}