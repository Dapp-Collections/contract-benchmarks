/* ==================================================================== */
/* Copyright (c) 2018 The TokenTycoon Project.  All rights reserved.
/* 
/* https://tokentycoon.io
/*  
/* authors <span class="__cf_email__" data-cfemail="a2d0cbc1c9cad7ccd6c7d08cd1cac7cce2c5cfc3cbce8cc1cdcf">[email protected]</span>   &#13;
/*         <span class="__cf_email__" data-cfemail="6516160016100b010c0b02250208040c094b060a08">[email protected]</span>            &#13;
/* ==================================================================== */&#13;
&#13;
pragma solidity ^0.4.23;&#13;
&#13;
contract AccessAdmin {&#13;
    bool public isPaused = false;&#13;
    address public addrAdmin;  &#13;
&#13;
    event AdminTransferred(address indexed preAdmin, address indexed newAdmin);&#13;
&#13;
    constructor() public {&#13;
        addrAdmin = msg.sender;&#13;
    }  &#13;
&#13;
&#13;
    modifier onlyAdmin() {&#13;
        require(msg.sender == addrAdmin);&#13;
        _;&#13;
    }&#13;
&#13;
    modifier whenNotPaused() {&#13;
        require(!isPaused);&#13;
        _;&#13;
    }&#13;
&#13;
    modifier whenPaused {&#13;
        require(isPaused);&#13;
        _;&#13;
    }&#13;
&#13;
    function setAdmin(address _newAdmin) external onlyAdmin {&#13;
        require(_newAdmin != address(0));&#13;
        emit AdminTransferred(addrAdmin, _newAdmin);&#13;
        addrAdmin = _newAdmin;&#13;
    }&#13;
&#13;
    function doPause() external onlyAdmin whenNotPaused {&#13;
        isPaused = true;&#13;
    }&#13;
&#13;
    function doUnpause() external onlyAdmin whenPaused {&#13;
        isPaused = false;&#13;
    }&#13;
}&#13;
&#13;
interface TokenRecipient { &#13;
    function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external;&#13;
}&#13;
&#13;
contract TalentCard is AccessAdmin {&#13;
    uint8 public decimals = 0;&#13;
    uint256 public totalSupply = 1000000000;&#13;
    string public name = "Token Tycoon Talent Card";&#13;
    string public symbol = "TTTC";&#13;
&#13;
    mapping (address =&gt; uint256) balances;&#13;
    mapping (address =&gt; mapping(address =&gt; uint256)) allowed;&#13;
    /// @dev Trust contract&#13;
    mapping (address =&gt; bool) safeContracts;&#13;
    &#13;
    event Transfer(address indexed _from, address indexed _to, uint256 _value);&#13;
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);&#13;
&#13;
    constructor() public {&#13;
        addrAdmin = msg.sender;&#13;
&#13;
        balances[this] = totalSupply;&#13;
    }&#13;
&#13;
    function balanceOf(address _owner) external view returns (uint256) {&#13;
        return balances[_owner];&#13;
    }&#13;
&#13;
    function approve(address _spender, uint256 _value) public returns (bool) {&#13;
        allowed[msg.sender][_spender] = _value;&#13;
        emit Approval(msg.sender, _spender, _value);&#13;
        return true;&#13;
    }&#13;
&#13;
    function allowance(address _owner, address _spender) external view returns (uint256) {&#13;
        return allowed[_owner][_spender];&#13;
    }&#13;
&#13;
    function transferFrom(address _from, address _to, uint256 _value) external returns (bool) {&#13;
        require(_value &lt;= allowed[_from][msg.sender]);&#13;
        allowed[_from][msg.sender] -= _value;&#13;
        return _transfer(_from, _to, _value);&#13;
    }&#13;
&#13;
    function transfer(address _to, uint256 _value) external returns (bool) {&#13;
        return _transfer(msg.sender, _to, _value);     &#13;
    }&#13;
&#13;
    function _transfer(address _from, address _to, uint256 _value) internal returns (bool) {&#13;
        require(_to != address(0));&#13;
        uint256 oldFromVal = balances[_from];&#13;
        require(_value &gt; 0 &amp;&amp; oldFromVal &gt;= _value);&#13;
        uint256 oldToVal = balances[_to];&#13;
        uint256 newToVal = oldToVal + _value;&#13;
        require(newToVal &gt; oldToVal);&#13;
        uint256 newFromVal = oldFromVal - _value;&#13;
        balances[_from] = newFromVal;&#13;
        balances[_to] = newToVal;&#13;
&#13;
        assert((oldFromVal + oldToVal) == (newFromVal + newToVal));&#13;
        emit Transfer(_from, _to, _value);&#13;
&#13;
        return true;&#13;
    }&#13;
&#13;
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)&#13;
        external&#13;
        returns (bool success) {&#13;
        TokenRecipient spender = TokenRecipient(_spender);&#13;
        if (approve(_spender, _value)) {&#13;
            spender.receiveApproval(msg.sender, _value, this, _extraData);&#13;
            return true;&#13;
        }&#13;
    }&#13;
&#13;
    function setSafeContract(address _actionAddr, bool _useful) external onlyAdmin {&#13;
        safeContracts[_actionAddr] = _useful;&#13;
    }&#13;
&#13;
    function getSafeContract(address _actionAddr) external view onlyAdmin returns(bool) {&#13;
        return safeContracts[_actionAddr];&#13;
    }&#13;
&#13;
    function safeSendCard(uint256 _amount, address _to) external {&#13;
        require(safeContracts[msg.sender]);&#13;
        require(balances[address(this)] &gt;= _amount);&#13;
        require(_to != address(0));&#13;
&#13;
        _transfer(address(this), _to, _amount);&#13;
    }&#13;
}