/* ==================================================================== */
/* Copyright (c) 2018 The ether.online Project.  All rights reserved.
/* 
/* https://ether.online  The first RPG game of blockchain 
/*  
/* authors <span class="__cf_email__" data-cfemail="22504b41494a574c5647500c514a474c62454f434b4e0c414d4f">[email protected]</span>   &#13;
/*         <span class="__cf_email__" data-cfemail="d7a4a4b2a4a2b9b3beb9b097b0bab6bebbf9b4b8ba">[email protected]</span>            &#13;
/* ==================================================================== */&#13;
&#13;
pragma solidity ^0.4.20;&#13;
&#13;
contract AccessAdmin {&#13;
    bool public isPaused = false;&#13;
    address public addrAdmin;  &#13;
&#13;
    event AdminTransferred(address indexed preAdmin, address indexed newAdmin);&#13;
&#13;
    function AccessAdmin() public {&#13;
        addrAdmin = msg.sender;&#13;
    }  &#13;
&#13;
&#13;
    modifier onlyAdmin() {&#13;
        require(msg.sender == addrAdmin);&#13;
        _;&#13;
    }&#13;
&#13;
    modifier whenNotPaused() {&#13;
        require(!isPaused);&#13;
        _;&#13;
    }&#13;
&#13;
    modifier whenPaused {&#13;
        require(isPaused);&#13;
        _;&#13;
    }&#13;
&#13;
    function setAdmin(address _newAdmin) external onlyAdmin {&#13;
        require(_newAdmin != address(0));&#13;
        AdminTransferred(addrAdmin, _newAdmin);&#13;
        addrAdmin = _newAdmin;&#13;
    }&#13;
&#13;
    function doPause() external onlyAdmin whenNotPaused {&#13;
        isPaused = true;&#13;
    }&#13;
&#13;
    function doUnpause() external onlyAdmin whenPaused {&#13;
        isPaused = false;&#13;
    }&#13;
}&#13;
&#13;
contract AccessService is AccessAdmin {&#13;
    address public addrService;&#13;
    address public addrFinance;&#13;
&#13;
    modifier onlyService() {&#13;
        require(msg.sender == addrService);&#13;
        _;&#13;
    }&#13;
&#13;
    modifier onlyFinance() {&#13;
        require(msg.sender == addrFinance);&#13;
        _;&#13;
    }&#13;
&#13;
    function setService(address _newService) external {&#13;
        require(msg.sender == addrService || msg.sender == addrAdmin);&#13;
        require(_newService != address(0));&#13;
        addrService = _newService;&#13;
    }&#13;
&#13;
    function setFinance(address _newFinance) external {&#13;
        require(msg.sender == addrFinance || msg.sender == addrAdmin);&#13;
        require(_newFinance != address(0));&#13;
        addrFinance = _newFinance;&#13;
    }&#13;
&#13;
    function withdraw(address _target, uint256 _amount) &#13;
        external &#13;
    {&#13;
        require(msg.sender == addrFinance || msg.sender == addrAdmin);&#13;
        require(_amount &gt; 0);&#13;
        address receiver = _target == address(0) ? addrFinance : _target;&#13;
        uint256 balance = this.balance;&#13;
        if (_amount &lt; balance) {&#13;
            receiver.transfer(_amount);&#13;
        } else {&#13;
            receiver.transfer(this.balance);&#13;
        }      &#13;
    }&#13;
}&#13;
&#13;
interface shareRecipient { &#13;
    function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external;&#13;
}&#13;
&#13;
contract EOMarketToken is AccessService {&#13;
    uint8 public decimals = 0;&#13;
    uint256 public totalSupply = 100;&#13;
    uint256 public totalSold = 0;&#13;
    string public name = " Ether Online Shares Token";&#13;
    string public symbol = "EOST";&#13;
&#13;
    mapping (address =&gt; uint256) balances;&#13;
    mapping (address =&gt; mapping(address =&gt; uint256)) allowed;&#13;
    address[] shareholders;&#13;
    mapping (address =&gt; uint256) addressToIndex;&#13;
&#13;
    event Transfer(address indexed _from, address indexed _to, uint256 _value);&#13;
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);&#13;
&#13;
    function EOMarketToken() public {&#13;
        addrAdmin = msg.sender;&#13;
        addrService = msg.sender;&#13;
        addrFinance = msg.sender;&#13;
&#13;
        balances[this] = totalSupply;&#13;
    }&#13;
&#13;
    function() external payable {&#13;
&#13;
    }&#13;
&#13;
    function balanceOf(address _owner) external view returns (uint256) {&#13;
        return balances[_owner];&#13;
    }&#13;
&#13;
    function approve(address _spender, uint256 _value) public returns (bool) {&#13;
        allowed[msg.sender][_spender] = _value;&#13;
        Approval(msg.sender, _spender, _value);&#13;
        return true;&#13;
    }&#13;
&#13;
    function allowance(address _owner, address _spender) external view returns (uint256) {&#13;
        return allowed[_owner][_spender];&#13;
    }&#13;
&#13;
    function transferFrom(address _from, address _to, uint256 _value) external returns (bool) {&#13;
        require(_value &lt;= allowed[_from][msg.sender]);&#13;
        allowed[_from][msg.sender] -= _value;&#13;
        return _transfer(_from, _to, _value);&#13;
    }&#13;
&#13;
    function transfer(address _to, uint256 _value) external returns (bool) {&#13;
        return _transfer(msg.sender, _to, _value);     &#13;
    }&#13;
&#13;
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)&#13;
        external&#13;
        returns (bool success) &#13;
    {&#13;
        shareRecipient spender = shareRecipient(_spender);&#13;
        if (approve(_spender, _value)) {&#13;
            spender.receiveApproval(msg.sender, _value, this, _extraData);&#13;
            return true;&#13;
        }&#13;
    }&#13;
&#13;
    function _transfer(address _from, address _to, uint256 _value) internal returns (bool) {&#13;
        require(_to != address(0));&#13;
        uint256 oldToVal = balances[_to];&#13;
        uint256 oldFromVal = balances[_from];&#13;
        require(_value &gt; 0 &amp;&amp; _value &lt;= oldFromVal);&#13;
        uint256 newToVal = oldToVal + _value;&#13;
        assert(newToVal &gt;= oldToVal);&#13;
        require(newToVal &lt;= 10);&#13;
        uint256 newFromVal = oldFromVal - _value;&#13;
        balances[_from] = newFromVal;&#13;
        balances[_to] = newToVal;&#13;
&#13;
        if (newFromVal == 0 &amp;&amp; _from != address(this)) {&#13;
            uint256 index = addressToIndex[_from];&#13;
            uint256 lastIndex = shareholders.length - 1;&#13;
            if (index != lastIndex) {&#13;
                shareholders[index] = shareholders[lastIndex];&#13;
                addressToIndex[shareholders[index]] = index;&#13;
                delete addressToIndex[_from];&#13;
            }&#13;
            shareholders.length -= 1; &#13;
        }&#13;
&#13;
        if (oldToVal == 0) {&#13;
            addressToIndex[_to] = shareholders.length;&#13;
            shareholders.push(_to);&#13;
        }&#13;
&#13;
        Transfer(_from, _to, _value);&#13;
        return true;&#13;
    }&#13;
&#13;
    function buy(uint256 _amount) &#13;
        external &#13;
        payable&#13;
        whenNotPaused&#13;
    {    &#13;
        require(_amount &gt; 0 &amp;&amp; _amount &lt;= 10);&#13;
        uint256 price = (1 ether) * _amount;&#13;
        require(msg.value == price);&#13;
        require(balances[this] &gt; _amount);&#13;
        uint256 newBanlance = balances[msg.sender] + _amount;&#13;
        assert(newBanlance &gt;= _amount);&#13;
        require(newBanlance &lt;= 10);&#13;
        _transfer(this, msg.sender, _amount);&#13;
        totalSold += _amount;&#13;
        addrFinance.transfer(price);&#13;
    }&#13;
&#13;
    function getShareholders() external view returns(address[100] addrArray, uint256[100] amountArray, uint256 soldAmount) {&#13;
        uint256 length = shareholders.length;&#13;
        for (uint256 i = 0; i &lt; length; ++i) {&#13;
            addrArray[i] = shareholders[i];&#13;
            amountArray[i] = balances[shareholders[i]];&#13;
        } &#13;
        soldAmount = totalSold;&#13;
    }&#13;
}