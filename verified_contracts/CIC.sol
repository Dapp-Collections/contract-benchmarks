pragma solidity ^0.4.18;

// sol to CIC Coin
// 
// Senior Development Engineer  CHIEH-HSUAN WANG of Lucas. 
// Jason Wang  <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="781100100008160b381f15191114561b1715">[email protected]</a>&gt;&#13;
// reference https://ethereum.org/token&#13;
&#13;
interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; }&#13;
contract owned {&#13;
    address public owner;&#13;
    &#13;
&#13;
    constructor()public{&#13;
       owner = msg.sender; &#13;
    }&#13;
    &#13;
    modifier onlyOwner {&#13;
        require(msg.sender == owner);&#13;
        _;&#13;
    }&#13;
    &#13;
    // 实现所有权转移&#13;
    function transferOwnership(address newOwner) public onlyOwner {&#13;
        owner = newOwner;&#13;
    }&#13;
}&#13;
&#13;
//Only owner can use&#13;
contract CIC is owned {&#13;
    address public deployer;&#13;
    &#13;
    string public name;&#13;
    &#13;
    string public symbol;&#13;
    &#13;
    uint8 public decimals = 4; &#13;
    &#13;
    uint256 public totalSupply;&#13;
    &#13;
    mapping (address =&gt; uint256) public balanceOf; &#13;
    &#13;
    mapping (address =&gt; mapping (address =&gt; uint256)) public allowance;&#13;
&#13;
    event Transfer(address indexed from, address indexed to, uint256 value);&#13;
&#13;
    event Burn(address indexed from, uint256 value);&#13;
&#13;
    constructor(uint256 initialSupply, string tokenName, string tokenSymbol, address centralMinter) public {&#13;
        if(centralMinter != 0 ) owner = centralMinter;&#13;
        totalSupply = initialSupply * 10 ** uint256(decimals);&#13;
        balanceOf[msg.sender] = totalSupply;&#13;
        name = tokenName;&#13;
        symbol = tokenSymbol;&#13;
        deployer = msg.sender;&#13;
    }&#13;
    &#13;
    function mintToken(address target, uint256 mintedAmount) public onlyOwner {&#13;
        balanceOf[target] += mintedAmount;&#13;
        totalSupply += mintedAmount;&#13;
        emit Transfer(0, owner, mintedAmount);&#13;
        emit Transfer(owner, target, mintedAmount);&#13;
    }&#13;
&#13;
    /*uint minBalanceForAccounts;&#13;
&#13;
    function setMinBalance(uint minimumBalanceInFinney) public onlyOwner {&#13;
         minBalanceForAccounts = minimumBalanceInFinney * 1 finney;&#13;
    }*/&#13;
    &#13;
    function _transfer(address _from, address _to, uint _value) internal {&#13;
        require(_to != 0x0);&#13;
        require(balanceOf[_from] &gt;= _value);&#13;
        require(balanceOf[_to] + _value &gt; balanceOf[_to]);&#13;
        uint previousBalances = balanceOf[_from] + balanceOf[_to];&#13;
        balanceOf[_from] -= _value;&#13;
        balanceOf[_to] += _value;&#13;
        emit Transfer(_from, _to, _value);&#13;
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);&#13;
    }&#13;
&#13;
    function transfer(address _to, uint256 _value) public {&#13;
        if (_to == 0x0) revert();&#13;
		if (_value &lt;= 0) revert();&#13;
        if (balanceOf[msg.sender] &lt; _value) revert();&#13;
        if (balanceOf[_to] + _value &lt; balanceOf[_to]) revert();&#13;
        emit Transfer(msg.sender, _to, _value);                  &#13;
&#13;
    }&#13;
&#13;
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {&#13;
        require(_value &lt;= allowance[_from][msg.sender]);     &#13;
        allowance[_from][msg.sender] -= _value;&#13;
        _transfer(_from, _to, _value);&#13;
        return true;&#13;
    }&#13;
&#13;
    function approve(address _spender, uint256 _value) public&#13;
        returns (bool success) {&#13;
        allowance[msg.sender][_spender] = _value;&#13;
        return true;&#13;
    }&#13;
&#13;
    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {&#13;
        tokenRecipient spender = tokenRecipient(_spender);&#13;
        if (approve(_spender, _value)) {&#13;
            spender.receiveApproval(msg.sender, _value, this, _extraData);&#13;
            return true;&#13;
        }&#13;
    }&#13;
&#13;
    function burn(uint256 _value) public returns (bool success) {&#13;
        require(balanceOf[msg.sender] &gt;= _value);&#13;
        balanceOf[msg.sender] -= _value;&#13;
        totalSupply -= _value;&#13;
        emit Burn(msg.sender, _value);&#13;
        return true;&#13;
    }&#13;
&#13;
    function burnFrom(address _from, uint256 _value) public returns (bool success) {&#13;
        require(balanceOf[_from] &gt;= _value);&#13;
        require(_value &lt;= allowance[_from][msg.sender]);&#13;
        balanceOf[_from] -= _value;&#13;
        allowance[_from][msg.sender] -= _value;&#13;
        totalSupply -= _value;&#13;
        emit Burn(_from, _value);&#13;
        return true;&#13;
    }&#13;
}