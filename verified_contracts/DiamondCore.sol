pragma solidity ^0.4.25;

  /**
    * @title SafeMath
    * @dev Math operations with safety checks that throw on error
    */
    library SafeMath {
    
    /**
    * @dev Multiplies two numbers, throws on overflow.
    */
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
      if (a == 0) {
        return 0;
      }
      uint256 c = a * b;
      assert(c / a == b);
      return c;
    }
    
    /**
    * @dev Integer division of two numbers, truncating the quotient.
    */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
      // assert(b > 0); // Solidity automatically throws when dividing by 0
      uint256 c = a / b;
      // assert(a == b * c + a % b); // There is no case in which this doesn't hold
      return c;
    }
    
    /**
    * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).
    */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
      assert(b <= a);
      return a - b;
    }
    
    /**
    * @dev Adds two numbers, throws on overflow.
    */
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
      uint256 c = a + b;
      assert(c >= a);
      return c;
    }
}
    
    
    /// @title Interface for contracts conforming to ERC-721: Non-Fungible Tokens
    /// @author Dieter Shirley <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="bbdfdecfdefbdac3d2d4d6c1ded595d8d4">[emailÂ protected]</a>&gt; (https://github.com/dete)&#13;
    contract ERC721 {&#13;
    function totalSupply() external view returns (uint256 total);&#13;
    function balanceOf(address _owner) external view returns (uint256 balance);&#13;
    function ownerOf(string _diamondId) public view returns (address owner);&#13;
    function approve(address _to, string _diamondId) external;&#13;
    function transfer(address _to, string _diamondId) external;&#13;
    function transferFrom(address _from, address _to, string _diamondId) external;&#13;
    &#13;
    // Events&#13;
    event Transfer(address indexed from, address indexed to, string indexed diamondId);&#13;
    event Approval(address indexed owner, address indexed approved, string indexed diamondId);&#13;
    }&#13;
    &#13;
    contract DiamondAccessControl {&#13;
    &#13;
    address public CEO;&#13;
    &#13;
    mapping (address =&gt; bool) public admins;&#13;
    &#13;
    bool public paused = false;&#13;
    &#13;
    modifier onlyCEO() {&#13;
      require(msg.sender == CEO);&#13;
      _;&#13;
    }&#13;
    &#13;
    modifier onlyAdmin() {&#13;
      require(admins[msg.sender]);&#13;
      _;&#13;
    }&#13;
    &#13;
    /*** Pausable functionality adapted from OpenZeppelin ***/&#13;
    &#13;
    /// @dev Modifier to allow actions only when the contract IS NOT paused&#13;
    modifier whenNotPaused() {&#13;
      require(!paused);&#13;
      _;&#13;
    }&#13;
    &#13;
    modifier onlyAdminOrCEO() &#13;
{      require(admins[msg.sender] || msg.sender == CEO);&#13;
      _;&#13;
    }&#13;
    &#13;
    /// @dev Modifier to allow actions only when the contract IS paused&#13;
    modifier whenPaused {&#13;
      require(paused);&#13;
      _;&#13;
    }&#13;
    &#13;
    function setCEO(address _newCEO) external onlyCEO {&#13;
      require(_newCEO != address(0));&#13;
      CEO = _newCEO;&#13;
    }&#13;
    &#13;
    function setAdmin(address _newAdmin, bool isAdmin) external onlyCEO {&#13;
      require(_newAdmin != address(0));&#13;
      admins[_newAdmin] = isAdmin;&#13;
    }&#13;
    &#13;
    /// @dev Called by any "C-level" role to pause the contract. Used only when&#13;
    ///  a bug or exploit is detected and we need to limit damage.&#13;
    function pause() external onlyAdminOrCEO whenNotPaused {&#13;
      paused = true;&#13;
    }&#13;
    &#13;
    /// @dev Unpauses the smart contract. Can only be called by the CEO, since&#13;
    ///  one reason we may pause the contract is when admin account are&#13;
    ///  compromised.&#13;
    /// @notice This is public rather than external so it can be called by&#13;
    ///  derived contracts.&#13;
    function unpause() external onlyCEO whenPaused {&#13;
      // can't unpause if contract was upgraded&#13;
      paused = false;&#13;
    }&#13;
}&#13;
    &#13;
/// @title Base contract for CryptoKitties. Holds all common structs, events and base variables.&#13;
/// @author Axiom Zen (https://www.axiomzen.co)&#13;
/// @dev See the KittyCore contract documentation to understand how the various contract facets are arranged.&#13;
contract DiamondBase is DiamondAccessControl {&#13;
    &#13;
    using SafeMath for uint256;&#13;
&#13;
    event Transfer(address indexed from, address indexed to, string indexed diamondId);&#13;
    event TransactionHistory(  &#13;
      string indexed _diamondId, &#13;
      address indexed _seller, &#13;
      string _sellerId, &#13;
      address indexed _buyer, &#13;
      string _buyerId, &#13;
      uint256 _usdPrice, &#13;
      uint256 _cedexPrice,&#13;
      uint256 timestamp&#13;
    );&#13;
    &#13;
    /*** DATA TYPE ***/&#13;
    /// @dev The main Kitty struct. Every dimond is represented by a copy of this structure&#13;
    struct Diamond {&#13;
      string ownerId;&#13;
      string status;&#13;
      string gemCompositeScore;&#13;
      string gemSubcategory;&#13;
      string media;&#13;
      string custodian;&#13;
      uint256 arrivalTime;&#13;
    }&#13;
    &#13;
    // variable to store total amount of diamonds&#13;
    uint256 internal total;&#13;
    &#13;
    // Mapping for checking the existence of token with such diamond ID&#13;
    mapping(string =&gt; bool) internal diamondExists;&#13;
    &#13;
    // Mapping from adress to number of diamonds owned by this address&#13;
    mapping(address =&gt; uint) internal balances;&#13;
    &#13;
    // Mapping from diamond ID to owner address&#13;
    mapping (string =&gt; address) internal diamondIdToOwner;&#13;
    &#13;
    // Mapping from diamond ID to metadata&#13;
    mapping(string =&gt; Diamond) internal diamondIdToMetadata;&#13;
    &#13;
    // Mapping from diamond ID to an address that has been approved to call transferFrom()&#13;
    mapping(string =&gt; address) internal diamondIdToApproved;&#13;
    &#13;
    //Status Constants&#13;
    string constant STATUS_PENDING = "Pending";&#13;
    string constant STATUS_VERIFIED = "Verified";&#13;
    string constant STATUS_OUTSIDE  = "Outside";&#13;
&#13;
    function _createDiamond(&#13;
      string _diamondId, &#13;
      address _owner, &#13;
      string _ownerId, &#13;
      string _gemCompositeScore, &#13;
      string _gemSubcategory, &#13;
      string _media&#13;
    )  &#13;
      internal &#13;
    {&#13;
      Diamond memory diamond;&#13;
      &#13;
      diamond.status = "Pending";&#13;
      diamond.ownerId = _ownerId;&#13;
      diamond.gemCompositeScore = _gemCompositeScore;&#13;
      diamond.gemSubcategory = _gemSubcategory;&#13;
      diamond.media = _media;&#13;
      &#13;
      diamondIdToMetadata[_diamondId] = diamond;&#13;
    &#13;
      _transfer(address(0), _owner, _diamondId);&#13;
      total = total.add(1);&#13;
      diamondExists[_diamondId] = true; &#13;
    }&#13;
    &#13;
    function _transferInternal(&#13;
      string _diamondId, &#13;
      address _seller, &#13;
      string _sellerId, &#13;
      address _buyer, &#13;
      string _buyerId, &#13;
      uint256 _usdPrice, &#13;
      uint256 _cedexPrice&#13;
    )   &#13;
      internal &#13;
    {&#13;
      Diamond storage diamond = diamondIdToMetadata[_diamondId];&#13;
      diamond.ownerId = _buyerId;&#13;
      _transfer(_seller, _buyer, _diamondId);   &#13;
      emit TransactionHistory(_diamondId, _seller, _sellerId, _buyer, _buyerId, _usdPrice, _cedexPrice, now);&#13;
    &#13;
    }&#13;
    &#13;
    function _transfer(address _from, address _to, string _diamondId) internal {&#13;
      if (_from != address(0)) {&#13;
          balances[_from] = balances[_from].sub(1);&#13;
      }&#13;
      balances[_to] = balances[_to].add(1);&#13;
      diamondIdToOwner[_diamondId] = _to;&#13;
      delete diamondIdToApproved[_diamondId];&#13;
      emit Transfer(_from, _to, _diamondId);&#13;
    }&#13;
    &#13;
    function _burn(string _diamondId) internal {&#13;
      address _from = diamondIdToOwner[_diamondId];&#13;
      balances[_from] = balances[_from].sub(1);&#13;
      total = total.sub(1);&#13;
      delete diamondIdToOwner[_diamondId];&#13;
      delete diamondIdToMetadata[_diamondId];&#13;
      delete diamondExists[_diamondId];&#13;
      delete diamondIdToApproved[_diamondId];&#13;
      emit Transfer(_from, address(0), _diamondId);&#13;
    }&#13;
    &#13;
    function _isDiamondOutside(string _diamondId) internal view returns (bool) {&#13;
      require(diamondExists[_diamondId]);&#13;
      return keccak256(diamondIdToMetadata[_diamondId].status) == keccak256(STATUS_OUTSIDE);&#13;
    }&#13;
    &#13;
    function _isDiamondVerified(string _diamondId) internal view returns (bool) {&#13;
      require(diamondExists[_diamondId]);&#13;
      return keccak256(diamondIdToMetadata[_diamondId].status) == keccak256(STATUS_VERIFIED);&#13;
    }&#13;
}&#13;
    &#13;
/// @title The ontract that manages ownership, ERC-721 (draft) compliant.&#13;
contract DiamondBase721 is DiamondBase, ERC721 {&#13;
    &#13;
    function totalSupply() external view returns (uint256) {&#13;
      return total;&#13;
    }&#13;
    &#13;
    /**&#13;
    * @dev Gets the balance of the specified address&#13;
    * @param _owner address to query the balance of&#13;
    * @return uint256 representing the amount owned by the passed address&#13;
    */&#13;
    function balanceOf(address _owner) external view returns (uint256) {&#13;
      return balances[_owner];&#13;
    &#13;
    }&#13;
    &#13;
    /**&#13;
    * @dev Gets the owner of the specified diamond ID&#13;
    * @param _diamondId string ID of the diamond to query the owner of&#13;
    * @return owner address currently marked as the owner of the given diamond ID&#13;
    */&#13;
    function ownerOf(string _diamondId) public view returns (address) {&#13;
      require(diamondExists[_diamondId]);&#13;
      return diamondIdToOwner[_diamondId];&#13;
    }&#13;
    &#13;
    function approve(address _to, string _diamondId) external whenNotPaused {&#13;
      require(_isDiamondOutside(_diamondId));&#13;
      require(msg.sender == ownerOf(_diamondId));&#13;
      diamondIdToApproved[_diamondId] = _to;&#13;
      emit Approval(msg.sender, _to, _diamondId);&#13;
    }&#13;
    &#13;
    /**&#13;
    * @dev Transfers the ownership of a given diamond ID to another address&#13;
    * @param _to address to receive the ownership of the given diamond ID&#13;
    * @param _diamondId uint256 ID of the diamond to be transferred&#13;
    */&#13;
    function transfer(address _to, string _diamondId) external whenNotPaused {&#13;
      require(_isDiamondOutside(_diamondId));&#13;
      require(msg.sender == ownerOf(_diamondId));&#13;
      require(_to != address(0));&#13;
      require(_to != address(this));&#13;
      require(_to != ownerOf(_diamondId));&#13;
      _transfer(msg.sender, _to, _diamondId);&#13;
    }&#13;
    &#13;
    function transferFrom(address _from, address _to,  string _diamondId)&#13;
      external &#13;
      whenNotPaused &#13;
    {&#13;
      require(_isDiamondOutside(_diamondId));&#13;
      require(_from == ownerOf(_diamondId));&#13;
      require(_to != address(0));&#13;
      require(_to != address(this));&#13;
      require(_to != ownerOf(_diamondId));&#13;
      require(diamondIdToApproved[_diamondId] == msg.sender);&#13;
      _transfer(_from, _to, _diamondId);&#13;
    }&#13;
    &#13;
}&#13;
    &#13;
/// @dev The main contract, keeps track of diamonds.&#13;
contract DiamondCore is DiamondBase721 {&#13;
&#13;
    /// @notice Creates the main Diamond smart contract instance.&#13;
    constructor() public {&#13;
      // the creator of the contract is the initial CEO&#13;
      CEO = msg.sender;&#13;
    }&#13;
    &#13;
    function createDiamond(&#13;
      string _diamondId, &#13;
      address _owner, &#13;
      string _ownerId, &#13;
      string _gemCompositeScore, &#13;
      string _gemSubcategory, &#13;
      string _media&#13;
    ) &#13;
      external &#13;
      onlyAdminOrCEO &#13;
      whenNotPaused &#13;
    {&#13;
      require(!diamondExists[_diamondId]);&#13;
      require(_owner != address(0));&#13;
      require(_owner != address(this));&#13;
      _createDiamond( &#13;
          _diamondId, &#13;
          _owner, &#13;
          _ownerId, &#13;
          _gemCompositeScore, &#13;
          _gemSubcategory, &#13;
          _media&#13;
      );&#13;
    }&#13;
    &#13;
    function updateDiamond(&#13;
      string _diamondId, &#13;
      string _custodian, &#13;
      uint256 _arrivalTime&#13;
    ) &#13;
      external &#13;
      onlyAdminOrCEO &#13;
      whenNotPaused &#13;
    {&#13;
      require(!_isDiamondOutside(_diamondId));&#13;
      &#13;
      Diamond storage diamond = diamondIdToMetadata[_diamondId];&#13;
      &#13;
      diamond.status = "Verified";&#13;
      diamond.custodian = _custodian;&#13;
      diamond.arrivalTime = _arrivalTime;&#13;
    }&#13;
    &#13;
    function transferInternal(&#13;
      string _diamondId, &#13;
      address _seller, &#13;
      string _sellerId, &#13;
      address _buyer, &#13;
      string _buyerId, &#13;
      uint256 _usdPrice, &#13;
      uint256 _cedexPrice&#13;
    ) &#13;
      external &#13;
      onlyAdminOrCEO                                                                                                                                                                                                                                              &#13;
      whenNotPaused &#13;
    {&#13;
      require(_isDiamondVerified(_diamondId));&#13;
      require(_seller == ownerOf(_diamondId));&#13;
      require(_buyer != address(0));&#13;
      require(_buyer != address(this));&#13;
      require(_buyer != ownerOf(_diamondId));&#13;
      _transferInternal(_diamondId, _seller, _sellerId, _buyer, _buyerId, _usdPrice, _cedexPrice);&#13;
    }&#13;
    &#13;
    function burn(string _diamondId) external onlyAdminOrCEO whenNotPaused {&#13;
      require(!_isDiamondOutside(_diamondId));&#13;
      _burn(_diamondId);&#13;
    }&#13;
    &#13;
    function getDiamond(string _diamondId) &#13;
        external&#13;
        view&#13;
        returns(&#13;
            string ownerId,&#13;
            string status,&#13;
            string gemCompositeScore,&#13;
            string gemSubcategory,&#13;
            string media,&#13;
            string custodian,&#13;
            uint256 arrivalTime&#13;
        )&#13;
    {&#13;
        require(diamondExists[_diamondId]);&#13;
        &#13;
         ownerId = diamondIdToMetadata[_diamondId].ownerId;&#13;
         status = diamondIdToMetadata[_diamondId].status;&#13;
         gemCompositeScore = diamondIdToMetadata[_diamondId].gemCompositeScore;&#13;
         gemSubcategory = diamondIdToMetadata[_diamondId].gemSubcategory;&#13;
         media = diamondIdToMetadata[_diamondId].media;&#13;
         custodian = diamondIdToMetadata[_diamondId].custodian;&#13;
         arrivalTime = diamondIdToMetadata[_diamondId].arrivalTime;&#13;
    }&#13;
}