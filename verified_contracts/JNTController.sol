/* Author: Victor Mezrin  <span class="__cf_email__" data-cfemail="196f707a6d766b59747c636b7077377a7674">[emailÂ protected]</span> */&#13;
&#13;
&#13;
pragma solidity ^0.4.18;&#13;
&#13;
&#13;
&#13;
/**&#13;
 * @title SafeMathInterface&#13;
 * @dev Math operations with safety checks that throw on error&#13;
 */&#13;
contract SafeMathInterface {&#13;
  function safeMul(uint256 a, uint256 b) internal pure returns (uint256);&#13;
  function safeDiv(uint256 a, uint256 b) internal pure returns (uint256);&#13;
  function safeSub(uint256 a, uint256 b) internal pure returns (uint256);&#13;
  function safeAdd(uint256 a, uint256 b) internal pure returns (uint256);&#13;
}&#13;
&#13;
&#13;
&#13;
/**&#13;
 * @title SafeMath&#13;
 * @dev Math operations with safety checks that throw on error&#13;
 */&#13;
contract SafeMath is SafeMathInterface {&#13;
  function safeMul(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
    uint256 c = a * b;&#13;
    assert(a == 0 || c / a == b);&#13;
    return c;&#13;
  }&#13;
&#13;
  function safeDiv(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
    // assert(b &gt; 0); // Solidity automatically throws when dividing by 0&#13;
    uint256 c = a / b;&#13;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold&#13;
    return c;&#13;
  }&#13;
&#13;
  function safeSub(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
    assert(b &lt;= a);&#13;
    return a - b;&#13;
  }&#13;
&#13;
  function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
    uint256 c = a + b;&#13;
    assert(c &gt;= a);&#13;
    return c;&#13;
  }&#13;
}&#13;
&#13;
&#13;
&#13;
/**&#13;
 * @title CommonModifiersInterface&#13;
 * @dev Base contract which contains common checks.&#13;
 */&#13;
contract CommonModifiersInterface {&#13;
&#13;
  /**&#13;
   * @dev Assemble the given address bytecode. If bytecode exists then the _addr is a contract.&#13;
   */&#13;
  function isContract(address _targetAddress) internal constant returns (bool);&#13;
&#13;
  /**&#13;
   * @dev modifier to allow actions only when the _targetAddress is a contract.&#13;
   */&#13;
  modifier onlyContractAddress(address _targetAddress) {&#13;
    require(isContract(_targetAddress) == true);&#13;
    _;&#13;
  }&#13;
}&#13;
&#13;
&#13;
&#13;
/**&#13;
 * @title CommonModifiers&#13;
 * @dev Base contract which contains common checks.&#13;
 */&#13;
contract CommonModifiers is CommonModifiersInterface {&#13;
&#13;
  /**&#13;
   * @dev Assemble the given address bytecode. If bytecode exists then the _addr is a contract.&#13;
   */&#13;
  function isContract(address _targetAddress) internal constant returns (bool) {&#13;
    require (_targetAddress != address(0x0));&#13;
&#13;
    uint256 length;&#13;
    assembly {&#13;
      //retrieve the size of the code on target address, this needs assembly&#13;
      length := extcodesize(_targetAddress)&#13;
    }&#13;
    return (length &gt; 0);&#13;
  }&#13;
}&#13;
&#13;
&#13;
&#13;
/**&#13;
 * @title AssetIDInterface&#13;
 * @dev Interface of a contract that assigned to an asset (JNT, jUSD etc.)&#13;
 * @dev Contracts for the same asset (like JNT, jUSD etc.) will have the same AssetID.&#13;
 * @dev This will help to avoid misconfiguration of contracts&#13;
 */&#13;
contract AssetIDInterface {&#13;
  function getAssetID() public constant returns (string);&#13;
  function getAssetIDHash() public constant returns (bytes32);&#13;
}&#13;
&#13;
&#13;
&#13;
/**&#13;
 * @title AssetID&#13;
 * @dev Base contract implementing AssetIDInterface&#13;
 */&#13;
contract AssetID is AssetIDInterface {&#13;
&#13;
  /* Storage */&#13;
&#13;
  string assetID;&#13;
&#13;
&#13;
  /* Constructor */&#13;
&#13;
  function AssetID(string _assetID) public {&#13;
    require(bytes(_assetID).length &gt; 0);&#13;
&#13;
    assetID = _assetID;&#13;
  }&#13;
&#13;
&#13;
  /* Getters */&#13;
&#13;
  function getAssetID() public constant returns (string) {&#13;
    return assetID;&#13;
  }&#13;
&#13;
  function getAssetIDHash() public constant returns (bytes32) {&#13;
    return keccak256(assetID);&#13;
  }&#13;
}&#13;
&#13;
&#13;
/**&#13;
 * @title OwnableInterface&#13;
 * @dev The Ownable contract has an owner address, and provides basic authorization control&#13;
 * functions, this simplifies the implementation of "user permissions".&#13;
 */&#13;
contract OwnableInterface {&#13;
&#13;
  /**&#13;
   * @dev The getter for "owner" contract variable&#13;
   */&#13;
  function getOwner() public constant returns (address);&#13;
&#13;
  /**&#13;
   * @dev Throws if called by any account other than the current owner.&#13;
   */&#13;
  modifier onlyOwner() {&#13;
    require (msg.sender == getOwner());&#13;
    _;&#13;
  }&#13;
}&#13;
&#13;
&#13;
&#13;
/**&#13;
 * @title Ownable&#13;
 * @dev The Ownable contract has an owner address, and provides basic authorization control&#13;
 * functions, this simplifies the implementation of "user permissions".&#13;
 */&#13;
contract Ownable is OwnableInterface {&#13;
&#13;
  /* Storage */&#13;
&#13;
  address owner = address(0x0);&#13;
  address proposedOwner = address(0x0);&#13;
&#13;
&#13;
  /* Events */&#13;
&#13;
  event OwnerAssignedEvent(address indexed newowner);&#13;
  event OwnershipOfferCreatedEvent(address indexed currentowner, address indexed proposedowner);&#13;
  event OwnershipOfferAcceptedEvent(address indexed currentowner, address indexed proposedowner);&#13;
  event OwnershipOfferCancelledEvent(address indexed currentowner, address indexed proposedowner);&#13;
&#13;
&#13;
  /**&#13;
   * @dev The constructor sets the initial `owner` to the passed account.&#13;
   */&#13;
  function Ownable() public {&#13;
    owner = msg.sender;&#13;
&#13;
    OwnerAssignedEvent(owner);&#13;
  }&#13;
&#13;
&#13;
  /**&#13;
   * @dev Old owner requests transfer ownership to the new owner.&#13;
   * @param _proposedOwner The address to transfer ownership to.&#13;
   */&#13;
  function createOwnershipOffer(address _proposedOwner) external onlyOwner {&#13;
    require (proposedOwner == address(0x0));&#13;
    require (_proposedOwner != address(0x0));&#13;
    require (_proposedOwner != address(this));&#13;
&#13;
    proposedOwner = _proposedOwner;&#13;
&#13;
    OwnershipOfferCreatedEvent(owner, _proposedOwner);&#13;
  }&#13;
&#13;
&#13;
  /**&#13;
   * @dev Allows the new owner to accept an ownership offer to contract control.&#13;
   */&#13;
  //noinspection UnprotectedFunction&#13;
  function acceptOwnershipOffer() external {&#13;
    require (proposedOwner != address(0x0));&#13;
    require (msg.sender == proposedOwner);&#13;
&#13;
    address _oldOwner = owner;&#13;
    owner = proposedOwner;&#13;
    proposedOwner = address(0x0);&#13;
&#13;
    OwnerAssignedEvent(owner);&#13;
    OwnershipOfferAcceptedEvent(_oldOwner, owner);&#13;
  }&#13;
&#13;
&#13;
  /**&#13;
   * @dev Old owner cancels transfer ownership to the new owner.&#13;
   */&#13;
  function cancelOwnershipOffer() external {&#13;
    require (proposedOwner != address(0x0));&#13;
    require (msg.sender == owner || msg.sender == proposedOwner);&#13;
&#13;
    address _oldProposedOwner = proposedOwner;&#13;
    proposedOwner = address(0x0);&#13;
&#13;
    OwnershipOfferCancelledEvent(owner, _oldProposedOwner);&#13;
  }&#13;
&#13;
&#13;
  /**&#13;
   * @dev The getter for "owner" contract variable&#13;
   */&#13;
  function getOwner() public constant returns (address) {&#13;
    return owner;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev The getter for "proposedOwner" contract variable&#13;
   */&#13;
  function getProposedOwner() public constant returns (address) {&#13;
    return proposedOwner;&#13;
  }&#13;
}&#13;
&#13;
&#13;
&#13;
/**&#13;
 * @title ManageableInterface&#13;
 * @dev Contract that allows to grant permissions to any address&#13;
 * @dev In real life we are no able to perform all actions with just one Ethereum address&#13;
 * @dev because risks are too high.&#13;
 * @dev Instead owner delegates rights to manage an contract to the different addresses and&#13;
 * @dev stay able to revoke permissions at any time.&#13;
 */&#13;
contract ManageableInterface {&#13;
&#13;
  /**&#13;
   * @dev Function to check if the manager can perform the action or not&#13;
   * @param _manager        address Manager`s address&#13;
   * @param _permissionName string  Permission name&#13;
   * @return True if manager is enabled and has been granted needed permission&#13;
   */&#13;
  function isManagerAllowed(address _manager, string _permissionName) public constant returns (bool);&#13;
&#13;
  /**&#13;
   * @dev Modifier to use in derived contracts&#13;
   */&#13;
  modifier onlyAllowedManager(string _permissionName) {&#13;
    require(isManagerAllowed(msg.sender, _permissionName) == true);&#13;
    _;&#13;
  }&#13;
}&#13;
&#13;
&#13;
&#13;
contract Manageable is OwnableInterface,&#13;
                       ManageableInterface {&#13;
&#13;
  /* Storage */&#13;
&#13;
  mapping (address =&gt; bool) managerEnabled;  // hard switch for a manager - on/off&#13;
  mapping (address =&gt; mapping (string =&gt; bool)) managerPermissions;  // detailed info about manager`s permissions&#13;
&#13;
&#13;
  /* Events */&#13;
&#13;
  event ManagerEnabledEvent(address indexed manager);&#13;
  event ManagerDisabledEvent(address indexed manager);&#13;
  event ManagerPermissionGrantedEvent(address indexed manager, string permission);&#13;
  event ManagerPermissionRevokedEvent(address indexed manager, string permission);&#13;
&#13;
&#13;
  /* Configure contract */&#13;
&#13;
  /**&#13;
   * @dev Function to add new manager&#13;
   * @param _manager address New manager&#13;
   */&#13;
  function enableManager(address _manager) external onlyOwner onlyValidManagerAddress(_manager) {&#13;
    require(managerEnabled[_manager] == false);&#13;
&#13;
    managerEnabled[_manager] = true;&#13;
    ManagerEnabledEvent(_manager);&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Function to remove existing manager&#13;
   * @param _manager address Existing manager&#13;
   */&#13;
  function disableManager(address _manager) external onlyOwner onlyValidManagerAddress(_manager) {&#13;
    require(managerEnabled[_manager] == true);&#13;
&#13;
    managerEnabled[_manager] = false;&#13;
    ManagerDisabledEvent(_manager);&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Function to grant new permission to the manager&#13;
   * @param _manager        address Existing manager&#13;
   * @param _permissionName string  Granted permission name&#13;
   */&#13;
  function grantManagerPermission(&#13;
    address _manager, string _permissionName&#13;
  )&#13;
    external&#13;
    onlyOwner&#13;
    onlyValidManagerAddress(_manager)&#13;
    onlyValidPermissionName(_permissionName)&#13;
  {&#13;
    require(managerPermissions[_manager][_permissionName] == false);&#13;
&#13;
    managerPermissions[_manager][_permissionName] = true;&#13;
    ManagerPermissionGrantedEvent(_manager, _permissionName);&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Function to revoke permission of the manager&#13;
   * @param _manager        address Existing manager&#13;
   * @param _permissionName string  Revoked permission name&#13;
   */&#13;
  function revokeManagerPermission(&#13;
    address _manager, string _permissionName&#13;
  )&#13;
    external&#13;
    onlyOwner&#13;
    onlyValidManagerAddress(_manager)&#13;
    onlyValidPermissionName(_permissionName)&#13;
  {&#13;
    require(managerPermissions[_manager][_permissionName] == true);&#13;
&#13;
    managerPermissions[_manager][_permissionName] = false;&#13;
    ManagerPermissionRevokedEvent(_manager, _permissionName);&#13;
  }&#13;
&#13;
&#13;
  /* Getters */&#13;
&#13;
  /**&#13;
   * @dev Function to check manager status&#13;
   * @param _manager address Manager`s address&#13;
   * @return True if manager is enabled&#13;
   */&#13;
  function isManagerEnabled(&#13;
    address _manager&#13;
  )&#13;
    public&#13;
    constant&#13;
    onlyValidManagerAddress(_manager)&#13;
    returns (bool)&#13;
  {&#13;
    return managerEnabled[_manager];&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Function to check permissions of a manager&#13;
   * @param _manager        address Manager`s address&#13;
   * @param _permissionName string  Permission name&#13;
   * @return True if manager has been granted needed permission&#13;
   */&#13;
  function isPermissionGranted(&#13;
    address _manager, string _permissionName&#13;
  )&#13;
    public&#13;
    constant&#13;
    onlyValidManagerAddress(_manager)&#13;
    onlyValidPermissionName(_permissionName)&#13;
    returns (bool)&#13;
  {&#13;
    return managerPermissions[_manager][_permissionName];&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Function to check if the manager can perform the action or not&#13;
   * @param _manager        address Manager`s address&#13;
   * @param _permissionName string  Permission name&#13;
   * @return True if manager is enabled and has been granted needed permission&#13;
   */&#13;
  function isManagerAllowed(&#13;
    address _manager, string _permissionName&#13;
  )&#13;
    public&#13;
    constant&#13;
    onlyValidManagerAddress(_manager)&#13;
    onlyValidPermissionName(_permissionName)&#13;
    returns (bool)&#13;
  {&#13;
    return (managerEnabled[_manager] &amp;&amp; managerPermissions[_manager][_permissionName]);&#13;
  }&#13;
&#13;
&#13;
  /* Helpers */&#13;
&#13;
  /**&#13;
   * @dev Modifier to check manager address&#13;
   */&#13;
  modifier onlyValidManagerAddress(address _manager) {&#13;
    require(_manager != address(0x0));&#13;
    _;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Modifier to check name of manager permission&#13;
   */&#13;
  modifier onlyValidPermissionName(string _permissionName) {&#13;
    require(bytes(_permissionName).length != 0);&#13;
    _;&#13;
  }&#13;
}&#13;
&#13;
&#13;
&#13;
/**&#13;
 * @title PausableInterface&#13;
 * @dev Base contract which allows children to implement an emergency stop mechanism.&#13;
 * @dev Based on zeppelin's Pausable, but integrated with Manageable&#13;
 * @dev Contract is in paused state by default and should be explicitly unlocked&#13;
 */&#13;
contract PausableInterface {&#13;
&#13;
  /**&#13;
   * Events&#13;
   */&#13;
&#13;
  event PauseEvent();&#13;
  event UnpauseEvent();&#13;
&#13;
&#13;
  /**&#13;
   * @dev called by the manager to pause, triggers stopped state&#13;
   */&#13;
  function pauseContract() public;&#13;
&#13;
  /**&#13;
   * @dev called by the manager to unpause, returns to normal state&#13;
   */&#13;
  function unpauseContract() public;&#13;
&#13;
  /**&#13;
   * @dev The getter for "paused" contract variable&#13;
   */&#13;
  function getPaused() public constant returns (bool);&#13;
&#13;
&#13;
  /**&#13;
   * @dev modifier to allow actions only when the contract IS paused&#13;
   */&#13;
  modifier whenContractNotPaused() {&#13;
    require(getPaused() == false);&#13;
    _;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev modifier to allow actions only when the contract IS NOT paused&#13;
   */&#13;
  modifier whenContractPaused {&#13;
    require(getPaused() == true);&#13;
    _;&#13;
  }&#13;
}&#13;
&#13;
&#13;
&#13;
/**&#13;
 * @title Pausable&#13;
 * @dev Base contract which allows children to implement an emergency stop mechanism.&#13;
 * @dev Based on zeppelin's Pausable, but integrated with Manageable&#13;
 * @dev Contract is in paused state by default and should be explicitly unlocked&#13;
 */&#13;
contract Pausable is ManageableInterface,&#13;
                     PausableInterface {&#13;
&#13;
  /**&#13;
   * Storage&#13;
   */&#13;
&#13;
  bool paused = true;&#13;
&#13;
&#13;
  /**&#13;
   * @dev called by the manager to pause, triggers stopped state&#13;
   */&#13;
  function pauseContract() public onlyAllowedManager('pause_contract') whenContractNotPaused {&#13;
    paused = true;&#13;
    PauseEvent();&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev called by the manager to unpause, returns to normal state&#13;
   */&#13;
  function unpauseContract() public onlyAllowedManager('unpause_contract') whenContractPaused {&#13;
    paused = false;&#13;
    UnpauseEvent();&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev The getter for "paused" contract variable&#13;
   */&#13;
  function getPaused() public constant returns (bool) {&#13;
    return paused;&#13;
  }&#13;
}&#13;
&#13;
&#13;
&#13;
/**&#13;
 * @title BytecodeExecutorInterface interface&#13;
 * @dev Implementation of a contract that execute any bytecode on behalf of the contract&#13;
 * @dev Last resort for the immutable and not-replaceable contract :)&#13;
 */&#13;
contract BytecodeExecutorInterface {&#13;
&#13;
  /* Events */&#13;
&#13;
  event CallExecutedEvent(address indexed target,&#13;
                          uint256 suppliedGas,&#13;
                          uint256 ethValue,&#13;
                          bytes32 transactionBytecodeHash);&#13;
  event DelegatecallExecutedEvent(address indexed target,&#13;
                                  uint256 suppliedGas,&#13;
                                  bytes32 transactionBytecodeHash);&#13;
&#13;
&#13;
  /* Functions */&#13;
&#13;
  function executeCall(address _target, uint256 _suppliedGas, uint256 _ethValue, bytes _transactionBytecode) external;&#13;
  function executeDelegatecall(address _target, uint256 _suppliedGas, bytes _transactionBytecode) external;&#13;
}&#13;
&#13;
&#13;
&#13;
/**&#13;
 * @title BytecodeExecutor&#13;
 * @dev Implementation of a contract that execute any bytecode on behalf of the contract&#13;
 * @dev Last resort for the immutable and not-replaceable contract :)&#13;
 */&#13;
contract BytecodeExecutor is ManageableInterface,&#13;
                             BytecodeExecutorInterface {&#13;
&#13;
  /* Storage */&#13;
&#13;
  bool underExecution = false;&#13;
&#13;
&#13;
  /* BytecodeExecutorInterface */&#13;
&#13;
  function executeCall(&#13;
    address _target,&#13;
    uint256 _suppliedGas,&#13;
    uint256 _ethValue,&#13;
    bytes _transactionBytecode&#13;
  )&#13;
    external&#13;
    onlyAllowedManager('execute_call')&#13;
  {&#13;
    require(underExecution == false);&#13;
&#13;
    underExecution = true; // Avoid recursive calling&#13;
    _target.call.gas(_suppliedGas).value(_ethValue)(_transactionBytecode);&#13;
    underExecution = false;&#13;
&#13;
    CallExecutedEvent(_target, _suppliedGas, _ethValue, keccak256(_transactionBytecode));&#13;
  }&#13;
&#13;
  function executeDelegatecall(&#13;
    address _target,&#13;
    uint256 _suppliedGas,&#13;
    bytes _transactionBytecode&#13;
  )&#13;
    external&#13;
    onlyAllowedManager('execute_delegatecall')&#13;
  {&#13;
    require(underExecution == false);&#13;
&#13;
    underExecution = true; // Avoid recursive calling&#13;
    _target.delegatecall.gas(_suppliedGas)(_transactionBytecode);&#13;
    underExecution = false;&#13;
&#13;
    DelegatecallExecutedEvent(_target, _suppliedGas, keccak256(_transactionBytecode));&#13;
  }&#13;
}&#13;
&#13;
&#13;
&#13;
contract CrydrViewBaseInterface {&#13;
&#13;
  /* Events */&#13;
&#13;
  event CrydrControllerChangedEvent(address indexed crydrcontroller);&#13;
&#13;
&#13;
  /* Configuration */&#13;
&#13;
  function setCrydrController(address _crydrController) external;&#13;
  function getCrydrController() public constant returns (address);&#13;
&#13;
  function getCrydrViewStandardName() public constant returns (string);&#13;
  function getCrydrViewStandardNameHash() public constant returns (bytes32);&#13;
}&#13;
&#13;
&#13;
&#13;
/**&#13;
 * @title CrydrStorageBalanceInterface interface&#13;
 * @dev Interface of a contract that manages balance of an CryDR&#13;
 */&#13;
contract CrydrStorageBalanceInterface {&#13;
&#13;
  /* Events */&#13;
&#13;
  event AccountBalanceIncreasedEvent(address indexed account, uint256 value);&#13;
  event AccountBalanceDecreasedEvent(address indexed account, uint256 value);&#13;
&#13;
&#13;
  /* Low-level change of balance. Implied that totalSupply kept in sync. */&#13;
&#13;
  function increaseBalance(address _account, uint256 _value) public;&#13;
  function decreaseBalance(address _account, uint256 _value) public;&#13;
  function getBalance(address _account) public constant returns (uint256);&#13;
  function getTotalSupply() public constant returns (uint256);&#13;
}&#13;
&#13;
&#13;
&#13;
/**&#13;
 * @title CrydrStorageAllowanceInterface interface&#13;
 * @dev Interface of a contract that manages balance of an CryDR&#13;
 */&#13;
contract CrydrStorageAllowanceInterface {&#13;
&#13;
  /* Events */&#13;
&#13;
  event AccountAllowanceIncreasedEvent(address indexed owner, address indexed spender, uint256 value);&#13;
  event AccountAllowanceDecreasedEvent(address indexed owner, address indexed spender, uint256 value);&#13;
&#13;
&#13;
  /* Low-level change of allowance */&#13;
&#13;
  function increaseAllowance(address _owner, address _spender, uint256 _value) public;&#13;
  function decreaseAllowance(address _owner, address _spender, uint256 _value) public;&#13;
  function getAllowance(address _owner, address _spender) public constant returns (uint256);&#13;
}&#13;
&#13;
&#13;
&#13;
/**&#13;
 * @title CrydrStorageERC20Interface interface&#13;
 * @dev Interface of a contract that manages balance of an CryDR and have optimization for ERC20 controllers&#13;
 */&#13;
contract CrydrStorageERC20Interface {&#13;
&#13;
  /* Events */&#13;
&#13;
  event CrydrTransferredEvent(address indexed from, address indexed to, uint256 value);&#13;
  event CrydrTransferredFromEvent(address indexed spender, address indexed from, address indexed to, uint256 value);&#13;
  event CrydrSpendingApprovedEvent(address indexed owner, address indexed spender, uint256 value);&#13;
&#13;
&#13;
  /* ERC20 optimization. _msgsender - account that invoked CrydrView */&#13;
&#13;
  function transfer(address _msgsender, address _to, uint256 _value) public;&#13;
  function transferFrom(address _msgsender, address _from, address _to, uint256 _value) public;&#13;
  function approve(address _msgsender, address _spender, uint256 _value) public;&#13;
}&#13;
&#13;
&#13;
&#13;
/**&#13;
 * @title CrydrStorageBlocksInterface interface&#13;
 * @dev Interface of a contract that manages balance of an CryDR&#13;
 */&#13;
contract CrydrStorageBlocksInterface {&#13;
&#13;
  /* Events */&#13;
&#13;
  event AccountBlockedEvent(address indexed account);&#13;
  event AccountUnblockedEvent(address indexed account);&#13;
  event AccountFundsBlockedEvent(address indexed account, uint256 value);&#13;
  event AccountFundsUnblockedEvent(address indexed account, uint256 value);&#13;
&#13;
&#13;
  /* Low-level change of blocks and getters */&#13;
&#13;
  function blockAccount(address _account) public;&#13;
  function unblockAccount(address _account) public;&#13;
  function getAccountBlocks(address _account) public constant returns (uint256);&#13;
&#13;
  function blockAccountFunds(address _account, uint256 _value) public;&#13;
  function unblockAccountFunds(address _account, uint256 _value) public;&#13;
  function getAccountBlockedFunds(address _account) public constant returns (uint256);&#13;
}&#13;
&#13;
&#13;
&#13;
/**&#13;
 * @title CrydrViewERC20LoggableInterface&#13;
 * @dev Contract is able to create Transfer/Approval events with the cal from controller&#13;
 */&#13;
contract CrydrViewERC20LoggableInterface {&#13;
&#13;
  function emitTransferEvent(address _from, address _to, uint256 _value) external;&#13;
  function emitApprovalEvent(address _owner, address _spender, uint256 _value) external;&#13;
}&#13;
&#13;
&#13;
&#13;
/**&#13;
 * @title CrydrViewERC20MintableInterface&#13;
 * @dev Contract is able to create Mint/Burn events with the cal from controller&#13;
 */&#13;
contract CrydrViewERC20MintableInterface {&#13;
  event MintEvent(address indexed owner, uint256 value);&#13;
  event BurnEvent(address indexed owner, uint256 value);&#13;
&#13;
  function emitMintEvent(address _owner, uint256 _value) external;&#13;
  function emitBurnEvent(address _owner, uint256 _value) external;&#13;
}&#13;
&#13;
&#13;
&#13;
/**&#13;
 * @title CrydrControllerBaseInterface interface&#13;
 * @dev Interface of a contract that implement business-logic of an CryDR, mediates CryDR views and storage&#13;
 */&#13;
contract CrydrControllerBaseInterface {&#13;
&#13;
  /* Events */&#13;
&#13;
  event CrydrStorageChangedEvent(address indexed crydrstorage);&#13;
  event CrydrViewAddedEvent(address indexed crydrview, string standardname);&#13;
  event CrydrViewRemovedEvent(address indexed crydrview, string standardname);&#13;
&#13;
&#13;
  /* Configuration */&#13;
&#13;
  function setCrydrStorage(address _newStorage) external;&#13;
  function getCrydrStorageAddress() public constant returns (address);&#13;
&#13;
  function setCrydrView(address _newCrydrView, string _viewApiStandardName) external;&#13;
  function removeCrydrView(string _viewApiStandardName) external;&#13;
  function getCrydrViewAddress(string _viewApiStandardName) public constant returns (address);&#13;
&#13;
  function isCrydrViewAddress(address _crydrViewAddress) public constant returns (bool);&#13;
  function isCrydrViewRegistered(string _viewApiStandardName) public constant returns (bool);&#13;
&#13;
&#13;
  /* Helpers */&#13;
&#13;
  modifier onlyValidCrydrViewStandardName(string _viewApiStandard) {&#13;
    require(bytes(_viewApiStandard).length &gt; 0);&#13;
    _;&#13;
  }&#13;
&#13;
  modifier onlyCrydrView() {&#13;
    require(isCrydrViewAddress(msg.sender) == true);&#13;
    _;&#13;
  }&#13;
}&#13;
&#13;
&#13;
&#13;
/**&#13;
 * @title CrydrControllerBase&#13;
 * @dev Implementation of a contract with business-logic of an CryDR, mediates CryDR views and storage&#13;
 */&#13;
contract CrydrControllerBase is CommonModifiersInterface,&#13;
                                ManageableInterface,&#13;
                                PausableInterface,&#13;
                                CrydrControllerBaseInterface {&#13;
&#13;
  /* Storage */&#13;
&#13;
  address crydrStorage = address(0x0);&#13;
  mapping (string =&gt; address) crydrViewsAddresses;&#13;
  mapping (address =&gt; bool) isRegisteredView;&#13;
&#13;
&#13;
  /* CrydrControllerBaseInterface */&#13;
&#13;
  function setCrydrStorage(&#13;
    address _crydrStorage&#13;
  )&#13;
    external&#13;
    onlyContractAddress(_crydrStorage)&#13;
    onlyAllowedManager('set_crydr_storage')&#13;
    whenContractPaused&#13;
  {&#13;
    require(_crydrStorage != address(this));&#13;
    require(_crydrStorage != address(crydrStorage));&#13;
&#13;
    crydrStorage = _crydrStorage;&#13;
    CrydrStorageChangedEvent(_crydrStorage);&#13;
  }&#13;
&#13;
  function getCrydrStorageAddress() public constant returns (address) {&#13;
    return address(crydrStorage);&#13;
  }&#13;
&#13;
&#13;
  function setCrydrView(&#13;
    address _newCrydrView, string _viewApiStandardName&#13;
  )&#13;
    external&#13;
    onlyContractAddress(_newCrydrView)&#13;
    onlyValidCrydrViewStandardName(_viewApiStandardName)&#13;
    onlyAllowedManager('set_crydr_view')&#13;
    whenContractPaused&#13;
  {&#13;
    require(_newCrydrView != address(this));&#13;
    require(crydrViewsAddresses[_viewApiStandardName] == address(0x0));&#13;
&#13;
    var crydrViewInstance = CrydrViewBaseInterface(_newCrydrView);&#13;
    var standardNameHash = crydrViewInstance.getCrydrViewStandardNameHash();&#13;
    require(standardNameHash == keccak256(_viewApiStandardName));&#13;
&#13;
    crydrViewsAddresses[_viewApiStandardName] = _newCrydrView;&#13;
    isRegisteredView[_newCrydrView] = true;&#13;
&#13;
    CrydrViewAddedEvent(_newCrydrView, _viewApiStandardName);&#13;
  }&#13;
&#13;
  function removeCrydrView(&#13;
    string _viewApiStandardName&#13;
  )&#13;
    external&#13;
    onlyValidCrydrViewStandardName(_viewApiStandardName)&#13;
    onlyAllowedManager('remove_crydr_view')&#13;
    whenContractPaused&#13;
  {&#13;
    require(crydrViewsAddresses[_viewApiStandardName] != address(0x0));&#13;
&#13;
    address removedView = crydrViewsAddresses[_viewApiStandardName];&#13;
&#13;
    // make changes to the storage&#13;
    crydrViewsAddresses[_viewApiStandardName] == address(0x0);&#13;
    isRegisteredView[removedView] = false;&#13;
&#13;
    CrydrViewRemovedEvent(removedView, _viewApiStandardName);&#13;
  }&#13;
&#13;
  function getCrydrViewAddress(&#13;
    string _viewApiStandardName&#13;
  )&#13;
    public&#13;
    constant&#13;
    onlyValidCrydrViewStandardName(_viewApiStandardName)&#13;
    returns (address)&#13;
  {&#13;
    require(crydrViewsAddresses[_viewApiStandardName] != address(0x0));&#13;
&#13;
    return crydrViewsAddresses[_viewApiStandardName];&#13;
  }&#13;
&#13;
  function isCrydrViewAddress(&#13;
    address _crydrViewAddress&#13;
  )&#13;
    public&#13;
    constant&#13;
    returns (bool)&#13;
  {&#13;
    require(_crydrViewAddress != address(0x0));&#13;
&#13;
    return isRegisteredView[_crydrViewAddress];&#13;
  }&#13;
&#13;
  function isCrydrViewRegistered(&#13;
    string _viewApiStandardName&#13;
  )&#13;
    public&#13;
    constant&#13;
    onlyValidCrydrViewStandardName(_viewApiStandardName)&#13;
    returns (bool)&#13;
  {&#13;
    return (crydrViewsAddresses[_viewApiStandardName] != address(0x0));&#13;
  }&#13;
}&#13;
&#13;
&#13;
&#13;
/**&#13;
 * @title CrydrControllerBlockableInterface interface&#13;
 * @dev Interface of a contract that allows block/unlock accounts&#13;
 */&#13;
contract CrydrControllerBlockableInterface {&#13;
&#13;
  /* blocking/unlocking */&#13;
&#13;
  function blockAccount(address _account) public;&#13;
  function unblockAccount(address _account) public;&#13;
&#13;
  function blockAccountFunds(address _account, uint256 _value) public;&#13;
  function unblockAccountFunds(address _account, uint256 _value) public;&#13;
}&#13;
&#13;
&#13;
&#13;
/**&#13;
 * @title CrydrControllerBlockable interface&#13;
 * @dev Implementation of a contract that allows blocking/unlocking accounts&#13;
 */&#13;
contract CrydrControllerBlockable is ManageableInterface,&#13;
                                     CrydrControllerBaseInterface,&#13;
                                     CrydrControllerBlockableInterface {&#13;
&#13;
&#13;
  /* blocking/unlocking */&#13;
&#13;
  function blockAccount(&#13;
    address _account&#13;
  )&#13;
    public&#13;
    onlyAllowedManager('block_account')&#13;
  {&#13;
    CrydrStorageBlocksInterface(getCrydrStorageAddress()).blockAccount(_account);&#13;
  }&#13;
&#13;
  function unblockAccount(&#13;
    address _account&#13;
  )&#13;
    public&#13;
    onlyAllowedManager('unblock_account')&#13;
  {&#13;
    CrydrStorageBlocksInterface(getCrydrStorageAddress()).unblockAccount(_account);&#13;
  }&#13;
&#13;
  function blockAccountFunds(&#13;
    address _account,&#13;
    uint256 _value&#13;
  )&#13;
    public&#13;
    onlyAllowedManager('block_account_funds')&#13;
  {&#13;
    CrydrStorageBlocksInterface(getCrydrStorageAddress()).blockAccountFunds(_account, _value);&#13;
  }&#13;
&#13;
  function unblockAccountFunds(&#13;
    address _account,&#13;
    uint256 _value&#13;
  )&#13;
    public&#13;
    onlyAllowedManager('unblock_account_funds')&#13;
  {&#13;
    CrydrStorageBlocksInterface(getCrydrStorageAddress()).unblockAccountFunds(_account, _value);&#13;
  }&#13;
}&#13;
&#13;
&#13;
&#13;
/**&#13;
 * @title CrydrControllerMintableInterface interface&#13;
 * @dev Interface of a contract that allows minting/burning of tokens&#13;
 */&#13;
contract CrydrControllerMintableInterface {&#13;
&#13;
  /* minting/burning */&#13;
&#13;
  function mint(address _account, uint256 _value) public;&#13;
  function burn(address _account, uint256 _value) public;&#13;
}&#13;
&#13;
&#13;
&#13;
/**&#13;
 * @title CrydrControllerMintable interface&#13;
 * @dev Implementation of a contract that allows minting/burning of tokens&#13;
 * @dev We do not use events Transfer(0x0, owner, amount) for minting as described in the EIP20&#13;
 * @dev because that are not transfers&#13;
 */&#13;
contract CrydrControllerMintable is ManageableInterface,&#13;
                                    PausableInterface,&#13;
                                    CrydrControllerBaseInterface,&#13;
                                    CrydrControllerMintableInterface {&#13;
&#13;
  /* minting/burning */&#13;
&#13;
  function mint(&#13;
    address _account, uint256 _value&#13;
  )&#13;
    public&#13;
    whenContractNotPaused&#13;
    onlyAllowedManager('mint_crydr')&#13;
  {&#13;
    // input parameters checked by the storage&#13;
&#13;
    CrydrStorageBalanceInterface(getCrydrStorageAddress()).increaseBalance(_account, _value);&#13;
&#13;
    if (isCrydrViewRegistered('erc20') == true) {&#13;
      CrydrViewERC20MintableInterface(getCrydrViewAddress('erc20')).emitMintEvent(_account, _value);&#13;
    }&#13;
  }&#13;
&#13;
  function burn(&#13;
    address _account, uint256 _value&#13;
  )&#13;
    public&#13;
    whenContractNotPaused&#13;
    onlyAllowedManager('burn_crydr')&#13;
  {&#13;
    // input parameters checked by the storage&#13;
&#13;
    CrydrStorageBalanceInterface(getCrydrStorageAddress()).decreaseBalance(_account, _value);&#13;
&#13;
    if (isCrydrViewRegistered('erc20') == true) {&#13;
      CrydrViewERC20MintableInterface(getCrydrViewAddress('erc20')).emitBurnEvent(_account, _value);&#13;
    }&#13;
  }&#13;
}&#13;
&#13;
&#13;
&#13;
/**&#13;
 * @title CrydrControllerERC20Interface interface&#13;
 * @dev Interface of a contract that implement business-logic of an ERC20 CryDR&#13;
 */&#13;
contract CrydrControllerERC20Interface {&#13;
&#13;
  /* ERC20 support. _msgsender - account that invoked CrydrView */&#13;
&#13;
  function transfer(address _msgsender, address _to, uint256 _value) public;&#13;
  function getTotalSupply() public constant returns (uint256);&#13;
  function getBalance(address _owner) public constant returns (uint256);&#13;
&#13;
  function approve(address _msgsender, address _spender, uint256 _value) public;&#13;
  function transferFrom(address _msgsender, address _from, address _to, uint256 _value) public;&#13;
  function getAllowance(address _owner, address _spender) public constant returns (uint256);&#13;
}&#13;
&#13;
&#13;
&#13;
/**&#13;
 * @title CrydrControllerERC20Interface interface&#13;
 * @dev Interface of a contract that implement business-logic of an ERC20 CryDR&#13;
 */&#13;
contract CrydrControllerERC20 is PausableInterface,&#13;
                                 CrydrControllerBaseInterface,&#13;
                                 CrydrControllerERC20Interface {&#13;
&#13;
  /* ERC20 support. _msgsender - account that invoked CrydrView */&#13;
&#13;
  function transfer(&#13;
    address _msgsender,&#13;
    address _to,&#13;
    uint256 _value&#13;
  )&#13;
    public&#13;
    onlyCrydrView&#13;
    whenContractNotPaused&#13;
  {&#13;
    CrydrStorageERC20Interface(address(getCrydrStorageAddress())).transfer(_msgsender, _to, _value);&#13;
&#13;
    if (isCrydrViewRegistered('erc20') == true) {&#13;
      CrydrViewERC20LoggableInterface(getCrydrViewAddress('erc20')).emitTransferEvent(_msgsender, _to, _value);&#13;
    }&#13;
  }&#13;
&#13;
  function getTotalSupply() public constant returns (uint256) {&#13;
    return CrydrStorageBalanceInterface(address(getCrydrStorageAddress())).getTotalSupply();&#13;
  }&#13;
&#13;
  function getBalance(address _owner) public constant returns (uint256) {&#13;
    return CrydrStorageBalanceInterface(address(getCrydrStorageAddress())).getBalance(_owner);&#13;
  }&#13;
&#13;
  function approve(&#13;
    address _msgsender,&#13;
    address _spender,&#13;
    uint256 _value&#13;
  )&#13;
    public&#13;
    onlyCrydrView&#13;
    whenContractNotPaused&#13;
  {&#13;
    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md&#13;
    // https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729&#13;
    // We decided to enforce users to set 0 before set new value&#13;
    var allowance = CrydrStorageAllowanceInterface(getCrydrStorageAddress()).getAllowance(_msgsender, _spender);&#13;
    require((allowance &gt; 0 &amp;&amp; _value == 0) || (allowance == 0 &amp;&amp; _value &gt; 0));&#13;
&#13;
    CrydrStorageERC20Interface(address(getCrydrStorageAddress())).approve(_msgsender, _spender, _value);&#13;
&#13;
    if (isCrydrViewRegistered('erc20') == true) {&#13;
      CrydrViewERC20LoggableInterface(getCrydrViewAddress('erc20')).emitApprovalEvent(_msgsender, _spender, _value);&#13;
    }&#13;
  }&#13;
&#13;
  function transferFrom(&#13;
    address _msgsender,&#13;
    address _from,&#13;
    address _to,&#13;
    uint256 _value&#13;
  )&#13;
    public&#13;
    onlyCrydrView&#13;
    whenContractNotPaused&#13;
  {&#13;
    CrydrStorageERC20Interface(address(getCrydrStorageAddress())).transferFrom(_msgsender, _from, _to, _value);&#13;
&#13;
    if (isCrydrViewRegistered('erc20') == true) {&#13;
      CrydrViewERC20LoggableInterface(getCrydrViewAddress('erc20')).emitTransferEvent(_from, _to, _value);&#13;
    }&#13;
  }&#13;
&#13;
  function getAllowance(address _owner, address _spender) public constant returns (uint256 ) {&#13;
    return CrydrStorageAllowanceInterface(address(getCrydrStorageAddress())).getAllowance(_owner, _spender);&#13;
  }&#13;
}&#13;
&#13;
&#13;
&#13;
/**&#13;
 * @title JNTController interface&#13;
 * @dev Contains helper methods of JNT controller that needed by other Jibrel contracts&#13;
 */&#13;
contract JNTControllerInterface {&#13;
&#13;
  /* Events */&#13;
&#13;
  event JNTChargedEvent(address indexed payableservice, address indexed from, address indexed to, uint256 value);&#13;
&#13;
&#13;
  /* Actions */&#13;
&#13;
  function chargeJNT(address _from, address _to, uint256 _value) public;&#13;
}&#13;
&#13;
&#13;
&#13;
/**&#13;
 * @title JNTPayableService interface&#13;
 * @dev Interface of a contract that charge JNT for actions&#13;
 */&#13;
contract JNTPayableServiceInterface {&#13;
&#13;
  /* Events */&#13;
&#13;
  event JNTControllerChangedEvent(address jntcontroller);&#13;
  event JNTBeneficiaryChangedEvent(address jntbeneficiary);&#13;
  event JNTChargedEvent(address indexed from, address indexed to, uint256 value);&#13;
&#13;
&#13;
  /* Configuration */&#13;
&#13;
  function setJntController(address _jntController) external;&#13;
  function getJntController() public constant returns (address);&#13;
&#13;
  function setJntBeneficiary(address _jntBeneficiary) external;&#13;
  function getJntBeneficiary() public constant returns (address);&#13;
&#13;
&#13;
  /* Actions */&#13;
&#13;
  function chargeJNTForService(address _from, uint256 _value) internal;&#13;
}&#13;
&#13;
&#13;
&#13;
contract JNTPayableService is CommonModifiersInterface,&#13;
                              ManageableInterface,&#13;
                              PausableInterface,&#13;
                              JNTPayableServiceInterface {&#13;
&#13;
  /* Storage */&#13;
&#13;
  JNTControllerInterface jntController;&#13;
  address jntBeneficiary;&#13;
&#13;
&#13;
  /* JNTPayableServiceInterface */&#13;
&#13;
  /* Configuration */&#13;
&#13;
  function setJntController(&#13;
    address _jntController&#13;
  )&#13;
    external&#13;
    onlyContractAddress(_jntController)&#13;
    onlyAllowedManager('set_jnt_controller')&#13;
    whenContractPaused&#13;
  {&#13;
    require(_jntController != address(jntController));&#13;
&#13;
    jntController = JNTControllerInterface(_jntController);&#13;
    JNTControllerChangedEvent(_jntController);&#13;
  }&#13;
&#13;
  function getJntController() public constant returns (address) {&#13;
    return address(jntController);&#13;
  }&#13;
&#13;
&#13;
  function setJntBeneficiary(&#13;
    address _jntBeneficiary&#13;
  )&#13;
    external&#13;
    onlyValidJntBeneficiary(_jntBeneficiary)&#13;
    onlyAllowedManager('set_jnt_beneficiary')&#13;
    whenContractPaused&#13;
  {&#13;
    require(_jntBeneficiary != jntBeneficiary);&#13;
    require(_jntBeneficiary != address(this));&#13;
&#13;
    jntBeneficiary = _jntBeneficiary;&#13;
    JNTBeneficiaryChangedEvent(jntBeneficiary);&#13;
  }&#13;
&#13;
  function getJntBeneficiary() public constant returns (address) {&#13;
    return jntBeneficiary;&#13;
  }&#13;
&#13;
&#13;
  /* Actions */&#13;
&#13;
  function chargeJNTForService(address _from, uint256 _value) internal whenContractNotPaused {&#13;
    require(_from != address(0x0));&#13;
    require(_from != jntBeneficiary);&#13;
    require(_value &gt; 0);&#13;
&#13;
    jntController.chargeJNT(_from, jntBeneficiary, _value);&#13;
    JNTChargedEvent(_from, jntBeneficiary, _value);&#13;
  }&#13;
&#13;
&#13;
  /* Pausable */&#13;
&#13;
  /**&#13;
   * @dev Override method to ensure that contract properly configured before it is unpaused&#13;
   */&#13;
  function unpauseContract()&#13;
    public&#13;
    onlyContractAddress(jntController)&#13;
    onlyValidJntBeneficiary(jntBeneficiary)&#13;
  {&#13;
    super.unpauseContract();&#13;
  }&#13;
&#13;
&#13;
  /* Helpers */&#13;
&#13;
  modifier onlyValidJntBeneficiary(address _jntBeneficiary) {&#13;
    require(_jntBeneficiary != address(0x0));&#13;
    _;&#13;
  }&#13;
}&#13;
&#13;
&#13;
&#13;
/**&#13;
 * @title JNTPayableServiceERC20Fees interface&#13;
 * @dev Interface of a CryDR controller that charge JNT for actions&#13;
 * @dev Price for actions has a flat value and do not depend on amount of transferred CryDRs&#13;
 */&#13;
contract JNTPayableServiceERC20FeesInterface {&#13;
&#13;
  /* Events */&#13;
&#13;
  event JNTPriceTransferChangedEvent(uint256 value);&#13;
  event JNTPriceTransferFromChangedEvent(uint256 value);&#13;
  event JNTPriceApproveChangedEvent(uint256 value);&#13;
&#13;
&#13;
  /* Configuration */&#13;
&#13;
  function setJntPrice(uint256 _jntPriceTransfer, uint256 _jntPriceTransferFrom, uint256 _jntPriceApprove) external;&#13;
  function getJntPriceForTransfer() public constant returns (uint256);&#13;
  function getJntPriceForTransferFrom() public constant returns (uint256);&#13;
  function getJntPriceForApprove() public constant returns (uint256);&#13;
}&#13;
&#13;
&#13;
&#13;
contract JNTPayableServiceERC20Fees is ManageableInterface,&#13;
                                       PausableInterface,&#13;
                                       JNTPayableServiceERC20FeesInterface {&#13;
&#13;
  /* Storage */&#13;
&#13;
  uint256 jntPriceTransfer;&#13;
  uint256 jntPriceTransferFrom;&#13;
  uint256 jntPriceApprove;&#13;
&#13;
&#13;
  /* Constructor */&#13;
&#13;
  function JNTPayableServiceERC20Fees(&#13;
    uint256 _jntPriceTransfer,&#13;
    uint256 _jntPriceTransferFrom,&#13;
    uint256 _jntPriceApprove&#13;
  )&#13;
    public&#13;
  {&#13;
    jntPriceTransfer = _jntPriceTransfer;&#13;
    jntPriceTransferFrom = _jntPriceTransferFrom;&#13;
    jntPriceApprove = _jntPriceApprove;&#13;
  }&#13;
&#13;
&#13;
  /* JNTPayableServiceERC20FeesInterface */&#13;
&#13;
  /* Configuration */&#13;
&#13;
  function setJntPrice(&#13;
    uint256 _jntPriceTransfer, uint256 _jntPriceTransferFrom, uint256 _jntPriceApprove&#13;
  )&#13;
    external&#13;
    onlyAllowedManager('set_jnt_price')&#13;
    whenContractPaused&#13;
  {&#13;
    require(_jntPriceTransfer != jntPriceTransfer ||&#13;
            _jntPriceTransferFrom != jntPriceTransferFrom ||&#13;
            _jntPriceApprove != jntPriceApprove);&#13;
&#13;
    if (jntPriceTransfer != _jntPriceTransfer) {&#13;
      jntPriceTransfer = _jntPriceTransfer;&#13;
      JNTPriceTransferChangedEvent(_jntPriceTransfer);&#13;
    }&#13;
    if (jntPriceTransferFrom != _jntPriceTransferFrom) {&#13;
      jntPriceTransferFrom = _jntPriceTransferFrom;&#13;
      JNTPriceTransferFromChangedEvent(_jntPriceTransferFrom);&#13;
    }&#13;
    if (jntPriceApprove != _jntPriceApprove) {&#13;
      jntPriceApprove = _jntPriceApprove;&#13;
      JNTPriceApproveChangedEvent(_jntPriceApprove);&#13;
    }&#13;
  }&#13;
&#13;
  function getJntPriceForTransfer() public constant returns (uint256) {&#13;
    return jntPriceTransfer;&#13;
  }&#13;
&#13;
  function getJntPriceForTransferFrom() public constant returns (uint256) {&#13;
    return jntPriceTransferFrom;&#13;
  }&#13;
&#13;
  function getJntPriceForApprove() public constant returns (uint256) {&#13;
    return jntPriceApprove;&#13;
  }&#13;
}&#13;
&#13;
&#13;
&#13;
contract JCashCrydrController is CommonModifiers,&#13;
                                 AssetID,&#13;
                                 Ownable,&#13;
                                 Manageable,&#13;
                                 Pausable,&#13;
                                 BytecodeExecutor,&#13;
                                 CrydrControllerBase,&#13;
                                 CrydrControllerBlockable,&#13;
                                 CrydrControllerMintable,&#13;
                                 CrydrControllerERC20,&#13;
                                 JNTPayableService,&#13;
                                 JNTPayableServiceERC20Fees {&#13;
&#13;
  /* Constructor */&#13;
  // 10^18 - assumes that JNT has decimals==18, 1JNT per operation&#13;
&#13;
  function JCashCrydrController(string _assetID)&#13;
    public&#13;
    AssetID(_assetID)&#13;
    JNTPayableServiceERC20Fees(10^18, 10^18, 10^18)&#13;
  {}&#13;
&#13;
&#13;
  /* CrydrControllerERC20 */&#13;
&#13;
  /* ERC20 support. _msgsender - account that invoked CrydrView */&#13;
&#13;
  function transfer(&#13;
    address _msgsender,&#13;
    address _to,&#13;
    uint256 _value&#13;
  )&#13;
    public&#13;
  {&#13;
    CrydrControllerERC20.transfer(_msgsender, _to, _value);&#13;
    chargeJNTForService(_msgsender, getJntPriceForTransfer());&#13;
  }&#13;
&#13;
  function approve(&#13;
    address _msgsender,&#13;
    address _spender,&#13;
    uint256 _value&#13;
  )&#13;
    public&#13;
  {&#13;
    CrydrControllerERC20.approve(_msgsender, _spender, _value);&#13;
    chargeJNTForService(_msgsender, getJntPriceForApprove());&#13;
  }&#13;
&#13;
  function transferFrom(&#13;
    address _msgsender,&#13;
    address _from,&#13;
    address _to,&#13;
    uint256 _value&#13;
  )&#13;
    public&#13;
  {&#13;
    CrydrControllerERC20.transferFrom(_msgsender, _from, _to, _value);&#13;
    chargeJNTForService(_msgsender, getJntPriceForTransferFrom());&#13;
  }&#13;
}&#13;
&#13;
&#13;
&#13;
/**&#13;
 * @title JNTController&#13;
 * @dev Mediates views and storage of JNT, provides additional methods for Jibrel contracts&#13;
 */&#13;
contract JNTController is CommonModifiers,&#13;
                          AssetID,&#13;
                          Ownable,&#13;
                          Manageable,&#13;
                          Pausable,&#13;
                          BytecodeExecutor,&#13;
                          CrydrControllerBase,&#13;
                          CrydrControllerBlockable,&#13;
                          CrydrControllerMintable,&#13;
                          CrydrControllerERC20,&#13;
                          JNTControllerInterface {&#13;
&#13;
  /* Constructor */&#13;
&#13;
  function JNTController() AssetID('JNT') public {}&#13;
&#13;
&#13;
  /* JNTControllerInterface */&#13;
&#13;
  function chargeJNT(&#13;
    address _from,&#13;
    address _to,&#13;
    uint256 _value&#13;
  )&#13;
    public&#13;
    onlyAllowedManager('jnt_payable_service') {&#13;
    CrydrStorageERC20Interface(address(crydrStorage)).transfer(_from, _to, _value);&#13;
    JNTChargedEvent(msg.sender, _from, _to, _value);&#13;
  }&#13;
}