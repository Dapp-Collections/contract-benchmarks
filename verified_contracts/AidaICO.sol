// AID tokensale smart contract.
// Developed by Phenom.Team <<span class="__cf_email__" data-cfemail="caa3a4aca58abaa2afa4a5a7e4beafaba7">[emailÂ protected]</span>&gt;&#13;
&#13;
pragma solidity ^ 0.4.15;&#13;
&#13;
/**&#13;
 *   @title SafeMath&#13;
 *   @dev Math operations with safety checks that throw on error&#13;
 */&#13;
library SafeMath {&#13;
    function mul(uint256 a, uint256 b) internal constant returns (uint256) {&#13;
        uint256 c = a * b;&#13;
        assert(a == 0 || c / a == b);&#13;
        return c;&#13;
    }&#13;
&#13;
    function div(uint256 a, uint256 b) internal constant returns(uint256) {&#13;
        assert(b &gt; 0);&#13;
        uint256 c = a / b;&#13;
        assert(a == b * c + a % b);&#13;
        return c;&#13;
    }&#13;
&#13;
    function sub(uint256 a, uint256 b) internal constant returns(uint256) {&#13;
        assert(b &lt;= a);&#13;
        return a - b;&#13;
    }&#13;
&#13;
    function add(uint256 a, uint256 b) internal constant returns(uint256) {&#13;
        uint256 c = a + b;&#13;
        assert(c &gt;= a);&#13;
        return c;&#13;
    }&#13;
}&#13;
&#13;
&#13;
/**&#13;
 *   @title ERC20&#13;
 *   @dev Standart ERC20 token interface&#13;
 */&#13;
contract ERC20 {&#13;
    uint256 public totalSupply = 0;&#13;
    mapping(address =&gt; uint256) balances;&#13;
    mapping(address =&gt; mapping(address =&gt; uint256)) allowed;&#13;
    function balanceOf(address _owner) public constant returns(uint256);&#13;
    function transfer(address _to, uint256 _value) public returns(bool);&#13;
    function transferFrom(address _from, address _to, uint256 _value) public returns(bool);&#13;
    function approve(address _spender, uint256 _value) public returns(bool);&#13;
    function allowance(address _owner, address _spender) public constant returns(uint256);&#13;
    event Transfer(address indexed _from, address indexed _to, uint256 _value);&#13;
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);&#13;
}&#13;
&#13;
/**&#13;
 *   @title AidaICO contract  - takes funds from users and issues tokens&#13;
 *   @dev AidaICO - it's the first ever contract for ICO which allows users to&#13;
 *                  return their investments.&#13;
 */&#13;
contract AidaICO {&#13;
    // AID - Aida token contract&#13;
    AidaToken public AID = new AidaToken(this);&#13;
    using SafeMath for uint256;&#13;
&#13;
    // Token price parameters&#13;
    // These parameters can be changed only by oracle of contract&#13;
    uint256 public Rate_Eth = 920; // Rate USD per ETH&#13;
    uint256 public Tokens_Per_Dollar = 4; // Aida token per dollar&#13;
    uint256 public Token_Price = Tokens_Per_Dollar.mul(Rate_Eth); // Aida token per ETH&#13;
&#13;
    uint256 constant bountyPart = 10; // 1% of TotalSupply for BountyFund&#13;
    uint256 constant partnersPart = 30; //3% f TotalSupply for PartnersFund&#13;
    uint256 constant teamPart = 200; //20% of TotalSupply for TeamFund&#13;
    uint256 constant icoAndPOfPart = 760; // 76% of TotalSupply for PublicICO and PrivateOffer&#13;
    bool public returnPeriodExpired = false;&#13;
    uint256 finishTime = 0;&#13;
&#13;
    // Output ethereum addresses&#13;
    address public Company;&#13;
    address public BountyFund;&#13;
    address public PartnersFund;&#13;
    address public TeamFund;&#13;
    address public Manager; // Manager controls contract&#13;
    address public Controller_Address1; // First address that is used to buy tokens for other cryptos&#13;
    address public Controller_Address2; // Second address that is used to buy tokens for other cryptos&#13;
    address public Controller_Address3; // Third address that is used to buy tokens for other cryptos&#13;
    address public Oracle; // Oracle address&#13;
    address public RefundManager; // Refund manager address&#13;
&#13;
    // Possible ICO statuses&#13;
    enum StatusICO {&#13;
        Created,&#13;
        PreIcoStarted,&#13;
        PreIcoPaused,&#13;
        PreIcoFinished,&#13;
        IcoStarted,&#13;
        IcoPaused,&#13;
        IcoFinished&#13;
    }&#13;
&#13;
    StatusICO statusICO = StatusICO.Created;&#13;
&#13;
    // Mappings&#13;
    mapping(address =&gt; uint256) public ethPreIco; // Mapping for remembering eth of investors who paid at PreICO&#13;
    mapping(address =&gt; uint256) public ethIco; // Mapping for remembering eth of investors who paid at ICO&#13;
    mapping(address =&gt; bool) public used; // Users can return their funds one time&#13;
    mapping(address =&gt; uint256) public tokensPreIco; // Mapping for remembering tokens of investors who paid at preICO in ether&#13;
    mapping(address =&gt; uint256) public tokensIco; // Mapping for remembering tokens of investors who paid at ICO in ethre&#13;
    mapping(address =&gt; uint256) public tokensPreIcoInOtherCrypto; // Mapping for remembering tokens of investors who paid at preICO in other crypto currencies&#13;
    mapping(address =&gt; uint256) public tokensIcoInOtherCrypto; // Mapping for remembering tokens of investors who paid at ICO in other crypto currencies&#13;
&#13;
    // Events Log&#13;
    event LogStartPreICO();&#13;
    event LogPausePreICO();&#13;
    event LogFinishPreICO();&#13;
    event LogStartICO();&#13;
    event LogPauseICO();&#13;
    event LogFinishICO(address bountyFund, address partnersFund, address teamFund);&#13;
    event LogBuyForInvestor(address investor, uint256 aidValue, string txHash);&#13;
    event LogReturnEth(address investor, uint256 eth);&#13;
    event LogReturnOtherCrypto(address investor, string logString);&#13;
&#13;
    // Modifiers&#13;
    // Allows execution by the refund manager only&#13;
    modifier refundManagerOnly {&#13;
        require(msg.sender == RefundManager);&#13;
        _;&#13;
    }&#13;
    // Allows execution by the oracle only&#13;
    modifier oracleOnly {&#13;
        require(msg.sender == Oracle);&#13;
        _;&#13;
    }&#13;
    // Allows execution by the contract manager only&#13;
    modifier managerOnly {&#13;
        require(msg.sender == Manager);&#13;
        _;&#13;
    }&#13;
    // Allows execution by the one of controllers only&#13;
    modifier controllersOnly {&#13;
      require((msg.sender == Controller_Address1)&#13;
           || (msg.sender == Controller_Address2)&#13;
           || (msg.sender == Controller_Address3));&#13;
      _;&#13;
    }&#13;
&#13;
&#13;
   /**&#13;
    *   @dev Contract constructor function&#13;
    */&#13;
    function AidaICO(&#13;
        address _Company,&#13;
        address _BountyFund,&#13;
        address _PartnersFund,&#13;
        address _TeamFund,&#13;
        address _Manager,&#13;
        address _Controller_Address1,&#13;
        address _Controller_Address2,&#13;
        address _Controller_Address3,&#13;
        address _Oracle,&#13;
        address _RefundManager&#13;
    )&#13;
        public {&#13;
        Company = _Company;&#13;
        BountyFund = _BountyFund;&#13;
        PartnersFund = _PartnersFund;&#13;
        TeamFund = _TeamFund;&#13;
        Manager = _Manager;&#13;
        Controller_Address1 = _Controller_Address1;&#13;
        Controller_Address2 = _Controller_Address2;&#13;
        Controller_Address3 = _Controller_Address3;&#13;
        Oracle = _Oracle;&#13;
        RefundManager = _RefundManager;&#13;
    }&#13;
&#13;
   /**&#13;
    *   @dev Set rate of ETH and update token price&#13;
    *   @param _RateEth       current ETH rate&#13;
    */&#13;
    function setRate(uint256 _RateEth) external oracleOnly {&#13;
        Rate_Eth = _RateEth;&#13;
        Token_Price = Tokens_Per_Dollar.mul(Rate_Eth);&#13;
    }&#13;
&#13;
   /**&#13;
    *   @dev Start PreIco&#13;
    *   Set ICO status to PreIcoStarted&#13;
    */&#13;
    function startPreIco() external managerOnly {&#13;
        require(statusICO == StatusICO.Created || statusICO == StatusICO.PreIcoPaused);&#13;
        statusICO = StatusICO.PreIcoStarted;&#13;
        LogStartPreICO();&#13;
    }&#13;
&#13;
   /**&#13;
    *   @dev Pause PreIco&#13;
    *   Set Ico status to PreIcoPaused&#13;
    */&#13;
    function pausePreIco() external managerOnly {&#13;
        require(statusICO == StatusICO.PreIcoStarted);&#13;
        statusICO = StatusICO.PreIcoPaused;&#13;
        LogPausePreICO();&#13;
    }&#13;
   /**&#13;
    *   @dev Finish PreIco&#13;
    *   Set Ico status to PreIcoFinished&#13;
    */&#13;
    function finishPreIco() external managerOnly {&#13;
        require(statusICO == StatusICO.PreIcoStarted || statusICO == StatusICO.PreIcoPaused);&#13;
        statusICO = StatusICO.PreIcoFinished;&#13;
        LogFinishPreICO();&#13;
    }&#13;
&#13;
   /**&#13;
    *   @dev Start ICO&#13;
    *   Set ICO status to IcoStarted&#13;
    */&#13;
    function startIco() external managerOnly {&#13;
        require(statusICO == StatusICO.PreIcoFinished || statusICO == StatusICO.IcoPaused);&#13;
        statusICO = StatusICO.IcoStarted;&#13;
        LogStartICO();&#13;
    }&#13;
&#13;
   /**&#13;
    *   @dev Pause Ico&#13;
    *   Set Ico status to IcoPaused&#13;
    */&#13;
    function pauseIco() external managerOnly {&#13;
        require(statusICO == StatusICO.IcoStarted);&#13;
        statusICO = StatusICO.IcoPaused;&#13;
        LogPauseICO();&#13;
    }&#13;
&#13;
   /**&#13;
    *   @dev Finish ICO and emit tokens for bounty company, partners and team&#13;
    */&#13;
    function finishIco() external managerOnly {&#13;
        require(statusICO == StatusICO.IcoStarted || statusICO == StatusICO.IcoPaused);&#13;
        uint256 alreadyMinted = AID.totalSupply(); // = PublicICO&#13;
        uint256 totalAmount = alreadyMinted.mul(1000).div(icoAndPOfPart);&#13;
        AID.mintTokens(BountyFund, bountyPart.mul(totalAmount).div(1000));&#13;
        AID.mintTokens(PartnersFund, partnersPart.mul(totalAmount).div(1000));&#13;
        AID.mintTokens(TeamFund, teamPart.mul(totalAmount).div(1000));&#13;
        statusICO = StatusICO.IcoFinished;&#13;
        finishTime = now;&#13;
        LogFinishICO(BountyFund, PartnersFund, TeamFund);&#13;
    }&#13;
&#13;
&#13;
   /**&#13;
    *   @dev Unfreeze tokens(enable token transfers)&#13;
    */&#13;
    function enableTokensTransfer() external managerOnly {&#13;
        AID.defrostTokens();&#13;
    }&#13;
&#13;
    /**&#13;
    *   @dev Freeze tokens(disable token transfers)&#13;
    */&#13;
    function disableTokensTransfer() external managerOnly {&#13;
        require((statusICO != StatusICO.IcoFinished) || (now &lt;= finishTime + 21 days));&#13;
        AID.frostTokens();&#13;
    }&#13;
&#13;
   /**&#13;
    *   @dev Fallback function calls createTokensForEth() function to create tokens&#13;
    *        when investor sends ETH to address of ICO contract&#13;
    */&#13;
    function() external payable {&#13;
        require(statusICO == StatusICO.PreIcoStarted || statusICO == StatusICO.IcoStarted);&#13;
        createTokensForEth(msg.sender, msg.value.mul(Token_Price));&#13;
        rememberEther(msg.value, msg.sender);&#13;
    }&#13;
&#13;
   /**&#13;
    *   @dev Store how many eth were invested by investor&#13;
    *   @param _value        amount of invested ether in Wei&#13;
    *   @param _investor     address of investor&#13;
    */&#13;
    function rememberEther(uint256 _value, address _investor) internal {&#13;
        if (statusICO == StatusICO.PreIcoStarted) {&#13;
            ethPreIco[_investor] = ethPreIco[_investor].add(_value);&#13;
        }&#13;
        if (statusICO == StatusICO.IcoStarted) {&#13;
            ethIco[_investor] = ethIco[_investor].add(_value);&#13;
        }&#13;
    }&#13;
&#13;
   /**&#13;
    *   @dev Writes how many tokens investor received(for payments in ETH)&#13;
    *   @param _value        amount of tokens&#13;
    *   @param _investor     address of investor&#13;
    */&#13;
    function rememberTokensEth(uint256 _value, address _investor) internal {&#13;
        if (statusICO == StatusICO.PreIcoStarted) {&#13;
            tokensPreIco[_investor] = tokensPreIco[_investor].add(_value);&#13;
        }&#13;
        if (statusICO == StatusICO.IcoStarted) {&#13;
            tokensIco[_investor] = tokensIco[_investor].add(_value);&#13;
        }&#13;
    }&#13;
&#13;
   /**&#13;
    *   @dev Writes how many tokens investor received(for payments in other cryptocurrencies)&#13;
    *   @param _value        amount of tokens&#13;
    *   @param _investor     address of investor&#13;
    */&#13;
    function rememberTokensOtherCrypto(uint256 _value, address _investor) internal {&#13;
        if (statusICO == StatusICO.PreIcoStarted) {&#13;
            tokensPreIcoInOtherCrypto[_investor] = tokensPreIcoInOtherCrypto[_investor].add(_value);&#13;
        }&#13;
        if (statusICO == StatusICO.IcoStarted) {&#13;
            tokensIcoInOtherCrypto[_investor] = tokensIcoInOtherCrypto[_investor].add(_value);&#13;
        }&#13;
    }&#13;
&#13;
   /**&#13;
    *   @dev Issues tokens for users who made purchases in other cryptocurrencies&#13;
    *   @param _investor     address the tokens will be issued to&#13;
    *   @param _txHash       transaction hash of investor's payment&#13;
    *   @param _aidValue     number of Aida tokens&#13;
    */&#13;
    function buyForInvestor(&#13;
        address _investor,&#13;
        uint256 _aidValue,&#13;
        string _txHash&#13;
    )&#13;
        external&#13;
        controllersOnly {&#13;
        require(statusICO == StatusICO.PreIcoStarted || statusICO == StatusICO.IcoStarted);&#13;
        createTokensForOtherCrypto(_investor, _aidValue);&#13;
        LogBuyForInvestor(_investor, _aidValue, _txHash);&#13;
    }&#13;
&#13;
   /**&#13;
    *   @dev Issue tokens for investors who paid in other cryptocurrencies&#13;
    *   @param _investor     address which the tokens will be issued to&#13;
    *   @param _aidValue     number of Aida tokens&#13;
    */&#13;
    function createTokensForOtherCrypto(address _investor, uint256 _aidValue) internal {&#13;
        require(_aidValue &gt; 0);&#13;
        uint256 bonus = getBonus(_aidValue);&#13;
        uint256 total = _aidValue.add(bonus);&#13;
        rememberTokensOtherCrypto(total, _investor);&#13;
        AID.mintTokens(_investor, total);&#13;
    }&#13;
&#13;
   /**&#13;
    *   @dev Issue tokens for investors who paid in ether&#13;
    *   @param _investor     address which the tokens will be issued to&#13;
    *   @param _aidValue     number of Aida tokens&#13;
    */&#13;
    function createTokensForEth(address _investor, uint256 _aidValue) internal {&#13;
        require(_aidValue &gt; 0);&#13;
        uint256 bonus = getBonus(_aidValue);&#13;
        uint256 total = _aidValue.add(bonus);&#13;
        rememberTokensEth(total, _investor);&#13;
        AID.mintTokens(_investor, total);&#13;
    }&#13;
&#13;
   /**&#13;
    *   @dev Calculates bonus if PreIco sales still not over&#13;
    *   @param _value        amount of tokens&#13;
    *   @return              bonus value&#13;
    */&#13;
    function getBonus(uint256 _value)&#13;
        public&#13;
        constant&#13;
        returns(uint256)&#13;
    {&#13;
        uint256 bonus = 0;&#13;
        if (statusICO == StatusICO.PreIcoStarted) {&#13;
            bonus = _value.mul(15).div(100);&#13;
        }&#13;
        return bonus;&#13;
    }&#13;
&#13;
&#13;
  /**&#13;
   *   @dev Enable returns of investments&#13;
   */&#13;
   function startRefunds() external managerOnly {&#13;
        returnPeriodExpired = false;&#13;
   }&#13;
&#13;
  /**&#13;
   *   @dev Disable returns of investments&#13;
   */&#13;
   function stopRefunds() external managerOnly {&#13;
        returnPeriodExpired = true;&#13;
   }&#13;
&#13;
&#13;
   /**&#13;
    *   @dev Allows investors to return their investments(in ETH)&#13;
    *   if preICO or ICO return duration is not over yet&#13;
    *   and burns tokens&#13;
    */&#13;
    function returnEther() public {&#13;
        require(!used[msg.sender]);&#13;
        require(!returnPeriodExpired);&#13;
        uint256 eth = 0;&#13;
        uint256 tokens = 0;&#13;
        if (statusICO == StatusICO.PreIcoStarted) {&#13;
            require(ethPreIco[msg.sender] &gt; 0);&#13;
            eth = ethPreIco[msg.sender];&#13;
            tokens = tokensPreIco[msg.sender];&#13;
            ethPreIco[msg.sender] = 0;&#13;
            tokensPreIco[msg.sender] = 0;&#13;
        }&#13;
        if (statusICO == StatusICO.IcoStarted) {&#13;
            require(ethIco[msg.sender] &gt; 0);&#13;
            eth = ethIco[msg.sender];&#13;
            tokens = tokensIco[msg.sender];&#13;
            ethIco[msg.sender] = 0;&#13;
            tokensIco[msg.sender] = 0;&#13;
        }&#13;
        used[msg.sender] = true;&#13;
        msg.sender.transfer(eth);&#13;
        AID.burnTokens(msg.sender, tokens);&#13;
        LogReturnEth(msg.sender, eth);&#13;
    }&#13;
&#13;
   /**&#13;
    *   @dev Burn tokens of investors who paid in other cryptocurrencies&#13;
    *   if preICO or ICO return duration is not over yet&#13;
    *   @param _investor     address which tokens will be burnt&#13;
    *   @param _logString    string which contains payment information&#13;
    */&#13;
    function returnOtherCrypto(&#13;
        address _investor,&#13;
        string _logString&#13;
    )&#13;
        external&#13;
        refundManagerOnly {&#13;
        uint256 tokens = 0;&#13;
        require(!returnPeriodExpired);&#13;
        if (statusICO == StatusICO.PreIcoStarted) {&#13;
            tokens = tokensPreIcoInOtherCrypto[_investor];&#13;
            tokensPreIcoInOtherCrypto[_investor] = 0;&#13;
        }&#13;
        if (statusICO == StatusICO.IcoStarted) {&#13;
            tokens = tokensIcoInOtherCrypto[_investor];&#13;
            tokensIcoInOtherCrypto[_investor] = 0;&#13;
        }&#13;
        AID.burnTokens(_investor, tokens);&#13;
        LogReturnOtherCrypto(_investor, _logString);&#13;
    }&#13;
&#13;
   /**&#13;
    *   @dev Allows Company withdraw investments&#13;
    */&#13;
    function withdrawEther() external managerOnly {&#13;
        require(statusICO == StatusICO.PreIcoFinished || statusICO == StatusICO.IcoFinished);&#13;
        Company.transfer(this.balance);&#13;
    }&#13;
&#13;
}&#13;
&#13;
&#13;
/**&#13;
 *   @title AidaToken&#13;
 *   @dev Aida token contract&#13;
 */&#13;
contract AidaToken is ERC20 {&#13;
    using SafeMath for uint256;&#13;
    string public name = "Aida TOKEN";&#13;
    string public symbol = "AID";&#13;
    uint256 public decimals = 18;&#13;
&#13;
    // Ico contract address&#13;
    address public ico;&#13;
    event Burn(address indexed from, uint256 value);&#13;
&#13;
    // Disables/enables token transfers&#13;
    bool public tokensAreFrozen = true;&#13;
&#13;
    // Allows execution by the owner only&#13;
    modifier icoOnly {&#13;
        require(msg.sender == ico);&#13;
        _;&#13;
    }&#13;
&#13;
   /**&#13;
    *   @dev Contract constructor function sets Ico address&#13;
    *   @param _ico          ico address&#13;
    */&#13;
    function AidaToken(address _ico) public {&#13;
        ico = _ico;&#13;
    }&#13;
&#13;
   /**&#13;
    *   @dev Mint tokens&#13;
    *   @param _holder       beneficiary address the tokens will be issued to&#13;
    *   @param _value        number of tokens to issue&#13;
    */&#13;
    function mintTokens(address _holder, uint256 _value) external icoOnly {&#13;
        require(_value &gt; 0);&#13;
        balances[_holder] = balances[_holder].add(_value);&#13;
        totalSupply = totalSupply.add(_value);&#13;
        Transfer(0x0, _holder, _value);&#13;
    }&#13;
&#13;
   /**&#13;
    *   @dev Enables token transfers&#13;
    */&#13;
    function defrostTokens() external icoOnly {&#13;
      tokensAreFrozen = false;&#13;
    }&#13;
&#13;
   /**&#13;
    *   @dev Disables token transfers&#13;
    */&#13;
    function frostTokens() external icoOnly {&#13;
      tokensAreFrozen = true;&#13;
    }&#13;
&#13;
   /**&#13;
    *   @dev Burn Tokens&#13;
    *   @param _investor     token holder address which the tokens will be burnt&#13;
    *   @param _value        number of tokens to burn&#13;
    */&#13;
    function burnTokens(address _investor, uint256 _value) external icoOnly {&#13;
        require(balances[_investor] &gt; 0);&#13;
        totalSupply = totalSupply.sub(_value);&#13;
        balances[_investor] = balances[_investor].sub(_value);&#13;
        Burn(_investor, _value);&#13;
    }&#13;
&#13;
   /**&#13;
    *   @dev Get balance of investor&#13;
    *   @param _owner        investor's address&#13;
    *   @return              balance of investor&#13;
    */&#13;
    function balanceOf(address _owner) public constant returns(uint256) {&#13;
      return balances[_owner];&#13;
    }&#13;
&#13;
   /**&#13;
    *   @dev Send coins&#13;
    *   throws on any error rather then return a false flag to minimize&#13;
    *   user errors&#13;
    *   @param _to           target address&#13;
    *   @param _amount       transfer amount&#13;
    *&#13;
    *   @return true if the transfer was successful&#13;
    */&#13;
    function transfer(address _to, uint256 _amount) public returns(bool) {&#13;
        require(!tokensAreFrozen);&#13;
        balances[msg.sender] = balances[msg.sender].sub(_amount);&#13;
        balances[_to] = balances[_to].add(_amount);&#13;
        Transfer(msg.sender, _to, _amount);&#13;
        return true;&#13;
    }&#13;
&#13;
   /**&#13;
    *   @dev An account/contract attempts to get the coins&#13;
    *   throws on any error rather then return a false flag to minimize user errors&#13;
    *&#13;
    *   @param _from         source address&#13;
    *   @param _to           target address&#13;
    *   @param _amount       transfer amount&#13;
    *&#13;
    *   @return true if the transfer was successful&#13;
    */&#13;
    function transferFrom(address _from, address _to, uint256 _amount) public returns(bool) {&#13;
        require(!tokensAreFrozen);&#13;
        balances[_from] = balances[_from].sub(_amount);&#13;
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);&#13;
        balances[_to] = balances[_to].add(_amount);&#13;
        Transfer(_from, _to, _amount);&#13;
        return true;&#13;
    }&#13;
&#13;
   /**&#13;
    *   @dev Allows another account/contract to spend some tokens on its behalf&#13;
    *   throws on any error rather then return a false flag to minimize user errors&#13;
    *&#13;
    *   also, to minimize the risk of the approve/transferFrom attack vector&#13;
    *   approve has to be called twice in 2 separate transactions - once to&#13;
    *   change the allowance to 0 and secondly to change it to the new allowance&#13;
    *   value&#13;
    *&#13;
    *   @param _spender      approved address&#13;
    *   @param _amount       allowance amount&#13;
    *&#13;
    *   @return true if the approval was successful&#13;
    */&#13;
    function approve(address _spender, uint256 _amount) public returns(bool) {&#13;
        require((_amount == 0) || (allowed[msg.sender][_spender] == 0));&#13;
        allowed[msg.sender][_spender] = _amount;&#13;
        Approval(msg.sender, _spender, _amount);&#13;
        return true;&#13;
    }&#13;
&#13;
   /**&#13;
    *   @dev Function to check the amount of tokens that an owner allowed to a spender.&#13;
    *&#13;
    *   @param _owner        the address which owns the funds&#13;
    *   @param _spender      the address which will spend the funds&#13;
    *&#13;
    *   @return              the amount of tokens still avaible for the spender&#13;
    */&#13;
    function allowance(address _owner, address _spender) public constant returns(uint256) {&#13;
        return allowed[_owner][_spender];&#13;
    }&#13;
}