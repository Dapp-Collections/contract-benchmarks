pragma solidity ^0.4.19;

/* Adapted from strings.sol created by Nick Johnson <<span class="__cf_email__" data-cfemail="badbc8dbd9d2d4d3defad4d5ceded5ce94d4dfce">[email protected]</span>&gt;&#13;
 * Ref: https://github.com/Arachnid/solidity-stringutils/blob/2f6ca9accb48ae14c66f1437ec50ed19a0616f78/strings.sol&#13;
 * @title String &amp; slice utility library for Solidity contracts.&#13;
 * @author Nick Johnson &lt;<span class="__cf_email__" data-cfemail="e8899a898b8086818ca886879c8c879cc6868d9c">[email protected]</span>&gt;&#13;
 */&#13;
library strings {&#13;
    &#13;
    struct slice {&#13;
        uint _len;&#13;
        uint _ptr;&#13;
    }&#13;
&#13;
    /*&#13;
     * @dev Returns a slice containing the entire string.&#13;
     * @param self The string to make a slice from.&#13;
     * @return A newly allocated slice containing the entire string.&#13;
     */&#13;
    function toSlice(string self) internal pure returns (slice) {&#13;
        uint ptr;&#13;
        assembly {&#13;
            ptr := add(self, 0x20)&#13;
        }&#13;
        return slice(bytes(self).length, ptr);&#13;
    }&#13;
&#13;
    function memcpy(uint dest, uint src, uint len) private pure {&#13;
        // Copy word-length chunks while possible&#13;
        for(; len &gt;= 32; len -= 32) {&#13;
            assembly {&#13;
                mstore(dest, mload(src))&#13;
            }&#13;
            dest += 32;&#13;
            src += 32;&#13;
        }&#13;
&#13;
        // Copy remaining bytes&#13;
        uint mask = 256 ** (32 - len) - 1;&#13;
        assembly {&#13;
            let srcpart := and(mload(src), not(mask))&#13;
            let destpart := and(mload(dest), mask)&#13;
            mstore(dest, or(destpart, srcpart))&#13;
        }&#13;
    }&#13;
&#13;
    &#13;
    function concat(slice self, slice other) internal returns (string) {&#13;
        var ret = new string(self._len + other._len);&#13;
        uint retptr;&#13;
        assembly { retptr := add(ret, 32) }&#13;
        memcpy(retptr, self._ptr, self._len);&#13;
        memcpy(retptr + self._len, other._ptr, other._len);&#13;
        return ret;&#13;
    }&#13;
&#13;
    /*&#13;
     * @dev Counts the number of nonoverlapping occurrences of `needle` in `self`.&#13;
     * @param self The slice to search.&#13;
     * @param needle The text to search for in `self`.&#13;
     * @return The number of occurrences of `needle` found in `self`.&#13;
     */&#13;
    function count(slice self, slice needle) internal returns (uint cnt) {&#13;
        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr) + needle._len;&#13;
        while (ptr &lt;= self._ptr + self._len) {&#13;
            cnt++;&#13;
            ptr = findPtr(self._len - (ptr - self._ptr), ptr, needle._len, needle._ptr) + needle._len;&#13;
        }&#13;
    }&#13;
&#13;
    // Returns the memory address of the first byte of the first occurrence of&#13;
    // `needle` in `self`, or the first byte after `self` if not found.&#13;
    function findPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private returns (uint) {&#13;
        uint ptr;&#13;
        uint idx;&#13;
&#13;
        if (needlelen &lt;= selflen) {&#13;
            if (needlelen &lt;= 32) {&#13;
                // Optimized assembly for 68 gas per byte on short strings&#13;
                assembly {&#13;
                    let mask := not(sub(exp(2, mul(8, sub(32, needlelen))), 1))&#13;
                    let needledata := and(mload(needleptr), mask)&#13;
                    let end := add(selfptr, sub(selflen, needlelen))&#13;
                    ptr := selfptr&#13;
                    loop:&#13;
                    jumpi(exit, eq(and(mload(ptr), mask), needledata))&#13;
                    ptr := add(ptr, 1)&#13;
                    jumpi(loop, lt(sub(ptr, 1), end))&#13;
                    ptr := add(selfptr, selflen)&#13;
                    exit:&#13;
                }&#13;
                return ptr;&#13;
            } else {&#13;
                // For long needles, use hashing&#13;
                bytes32 hash;&#13;
                assembly { hash := sha3(needleptr, needlelen) }&#13;
                ptr = selfptr;&#13;
                for (idx = 0; idx &lt;= selflen - needlelen; idx++) {&#13;
                    bytes32 testHash;&#13;
                    assembly { testHash := sha3(ptr, needlelen) }&#13;
                    if (hash == testHash)&#13;
                        return ptr;&#13;
                    ptr += 1;&#13;
                }&#13;
            }&#13;
        }&#13;
        return selfptr + selflen;&#13;
    }&#13;
&#13;
    /*&#13;
     * @dev Splits the slice, setting `self` to everything after the first&#13;
     *      occurrence of `needle`, and `token` to everything before it. If&#13;
     *      `needle` does not occur in `self`, `self` is set to the empty slice,&#13;
     *      and `token` is set to the entirety of `self`.&#13;
     * @param self The slice to split.&#13;
     * @param needle The text to search for in `self`.&#13;
     * @param token An output parameter to which the first token is written.&#13;
     * @return `token`.&#13;
     */&#13;
    function split(slice self, slice needle, slice token) internal returns (slice) {&#13;
        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr);&#13;
        token._ptr = self._ptr;&#13;
        token._len = ptr - self._ptr;&#13;
        if (ptr == self._ptr + self._len) {&#13;
            // Not found&#13;
            self._len = 0;&#13;
        } else {&#13;
            self._len -= token._len + needle._len;&#13;
            self._ptr = ptr + needle._len;&#13;
        }&#13;
        return token;&#13;
    }&#13;
&#13;
     /*&#13;
     * @dev Splits the slice, setting `self` to everything after the first&#13;
     *      occurrence of `needle`, and returning everything before it. If&#13;
     *      `needle` does not occur in `self`, `self` is set to the empty slice,&#13;
     *      and the entirety of `self` is returned.&#13;
     * @param self The slice to split.&#13;
     * @param needle The text to search for in `self`.&#13;
     * @return The part of `self` up to the first occurrence of `delim`.&#13;
     */&#13;
    function split(slice self, slice needle) internal returns (slice token) {&#13;
        split(self, needle, token);&#13;
    }&#13;
&#13;
    /*&#13;
     * @dev Copies a slice to a new string.&#13;
     * @param self The slice to copy.&#13;
     * @return A newly allocated string containing the slice's text.&#13;
     */&#13;
    function toString(slice self) internal pure returns (string) {&#13;
        var ret = new string(self._len);&#13;
        uint retptr;&#13;
        assembly { retptr := add(ret, 32) }&#13;
&#13;
        memcpy(retptr, self._ptr, self._len);&#13;
        return ret;&#13;
    }&#13;
&#13;
}&#13;
&#13;
/* Helper String Functions for Game Manager Contract&#13;
 * @title String Healpers&#13;
 * @author Fazri Zubair &amp; Farhan Khwaja (Lucid Sight, Inc.)&#13;
 */&#13;
contract StringHelpers {&#13;
    using strings for *;&#13;
    &#13;
    function stringToBytes32(string memory source) internal returns (bytes32 result) {&#13;
        bytes memory tempEmptyStringTest = bytes(source);&#13;
        if (tempEmptyStringTest.length == 0) {&#13;
            return 0x0;&#13;
        }&#13;
    &#13;
        assembly {&#13;
            result := mload(add(source, 32))&#13;
        }&#13;
    }&#13;
&#13;
    function bytes32ToString(bytes32 x) constant internal returns (string) {&#13;
        bytes memory bytesString = new bytes(32);&#13;
        uint charCount = 0;&#13;
        for (uint j = 0; j &lt; 32; j++) {&#13;
            byte char = byte(bytes32(uint(x) * 2 ** (8 * j)));&#13;
            if (char != 0) {&#13;
                bytesString[charCount] = char;&#13;
                charCount++;&#13;
            }&#13;
        }&#13;
        bytes memory bytesStringTrimmed = new bytes(charCount);&#13;
        for (j = 0; j &lt; charCount; j++) {&#13;
            bytesStringTrimmed[j] = bytesString[j];&#13;
        }&#13;
        return string(bytesStringTrimmed);&#13;
    }&#13;
}&#13;
&#13;
/// @title Interface for contracts conforming to ERC-721: Non-Fungible Tokens&#13;
/// @author Dieter Shirley &lt;<span class="__cf_email__" data-cfemail="aecacbdacbeecfd6c7c1c3d4cbc080cdc1">[email protected]</span>&gt; (https://github.com/dete)&#13;
contract ERC721 {&#13;
  // Required methods&#13;
  function balanceOf(address _owner) public view returns (uint256 balance);&#13;
  function ownerOf(uint256 _assetId) public view returns (address owner);&#13;
  function approve(address _to, uint256 _assetId) public;&#13;
  function transfer(address _to, uint256 _assetId) public;&#13;
  function transferFrom(address _from, address _to, uint256 _assetId) public;&#13;
  function implementsERC721() public pure returns (bool);&#13;
  function takeOwnership(uint256 _assetId) public;&#13;
  function totalSupply() public view returns (uint256 total);&#13;
&#13;
  event Transfer(address indexed from, address indexed to, uint256 tokenId);&#13;
  event Approval(address indexed owner, address indexed approved, uint256 tokenId);&#13;
&#13;
  // Optional&#13;
  // function name() public view returns (string name);&#13;
  // function symbol() public view returns (string symbol);&#13;
  // function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256 tokenId);&#13;
  // function tokenMetadata(uint256 _tokenId) public view returns (string infoUrl);&#13;
&#13;
  // ERC-165 Compatibility (https://github.com/ethereum/EIPs/issues/165)&#13;
  function supportsInterface(bytes4 _interfaceID) external view returns (bool);&#13;
}&#13;
&#13;
/* Controls game play state and access rights for game functions&#13;
 * @title Operational Control&#13;
 * @author Fazri Zubair &amp; Farhan Khwaja (Lucid Sight, Inc.)&#13;
 * Inspired and adapted from contract created by OpenZeppelin&#13;
 * Ref: https://github.com/OpenZeppelin/zeppelin-solidity/&#13;
 */&#13;
contract OperationalControl {&#13;
    // Facilitates access &amp; control for the game.&#13;
    // Roles:&#13;
    //  -The Game Managers (Primary/Secondary): Has universal control of all game elements (No ability to withdraw)&#13;
    //  -The Banker: The Bank can withdraw funds and adjust fees / prices.&#13;
&#13;
    /// @dev Emited when contract is upgraded&#13;
    event ContractUpgrade(address newContract);&#13;
&#13;
    // The addresses of the accounts (or contracts) that can execute actions within each roles.&#13;
    address public gameManagerPrimary;&#13;
    address public gameManagerSecondary;&#13;
    address public bankManager;&#13;
&#13;
    // @dev Keeps track whether the contract is paused. When that is true, most actions are blocked&#13;
    bool public paused = false;&#13;
&#13;
    // @dev Keeps track whether the contract erroredOut. When that is true, most actions are blocked &amp; refund can be claimed&#13;
    bool public error = false;&#13;
&#13;
    /// @dev Operation modifiers for limiting access&#13;
    modifier onlyGameManager() {&#13;
        require(msg.sender == gameManagerPrimary || msg.sender == gameManagerSecondary);&#13;
        _;&#13;
    }&#13;
&#13;
    modifier onlyBanker() {&#13;
        require(msg.sender == bankManager);&#13;
        _;&#13;
    }&#13;
&#13;
    modifier anyOperator() {&#13;
        require(&#13;
            msg.sender == gameManagerPrimary ||&#13;
            msg.sender == gameManagerSecondary ||&#13;
            msg.sender == bankManager&#13;
        );&#13;
        _;&#13;
    }&#13;
&#13;
    /// @dev Assigns a new address to act as the GM.&#13;
    function setPrimaryGameManager(address _newGM) external onlyGameManager {&#13;
        require(_newGM != address(0));&#13;
&#13;
        gameManagerPrimary = _newGM;&#13;
    }&#13;
&#13;
    /// @dev Assigns a new address to act as the GM.&#13;
    function setSecondaryGameManager(address _newGM) external onlyGameManager {&#13;
        require(_newGM != address(0));&#13;
&#13;
        gameManagerSecondary = _newGM;&#13;
    }&#13;
&#13;
    /// @dev Assigns a new address to act as the Banker.&#13;
    function setBanker(address _newBK) external onlyGameManager {&#13;
        require(_newBK != address(0));&#13;
&#13;
        bankManager = _newBK;&#13;
    }&#13;
&#13;
    /*** Pausable functionality adapted from OpenZeppelin ***/&#13;
&#13;
    /// @dev Modifier to allow actions only when the contract IS NOT paused&#13;
    modifier whenNotPaused() {&#13;
        require(!paused);&#13;
        _;&#13;
    }&#13;
&#13;
    /// @dev Modifier to allow actions only when the contract IS paused&#13;
    modifier whenPaused {&#13;
        require(paused);&#13;
        _;&#13;
    }&#13;
&#13;
    /// @dev Modifier to allow actions only when the contract has Error&#13;
    modifier whenError {&#13;
        require(error);&#13;
        _;&#13;
    }&#13;
&#13;
    /// @dev Called by any Operator role to pause the contract.&#13;
    /// Used only if a bug or exploit is discovered (Here to limit losses / damage)&#13;
    function pause() external onlyGameManager whenNotPaused {&#13;
        paused = true;&#13;
    }&#13;
&#13;
    /// @dev Unpauses the smart contract. Can only be called by the Game Master&#13;
    /// @notice This is public rather than external so it can be called by derived contracts. &#13;
    function unpause() public onlyGameManager whenPaused {&#13;
        // can't unpause if contract was upgraded&#13;
        paused = false;&#13;
    }&#13;
&#13;
    /// @dev Unpauses the smart contract. Can only be called by the Game Master&#13;
    /// @notice This is public rather than external so it can be called by derived contracts. &#13;
    function hasError() public onlyGameManager whenPaused {&#13;
        error = true;&#13;
    }&#13;
&#13;
    /// @dev Unpauses the smart contract. Can only be called by the Game Master&#13;
    /// @notice This is public rather than external so it can be called by derived contracts. &#13;
    function noError() public onlyGameManager whenPaused {&#13;
        error = false;&#13;
    }&#13;
}&#13;
&#13;
contract CSCCollectibleBase is ERC721, OperationalControl, StringHelpers {&#13;
&#13;
  /*** EVENTS ***/&#13;
  /// @dev The Created event is fired whenever a new collectible comes into existence.&#13;
  event CollectibleCreated(address owner, uint256 globalId, uint256 collectibleType, uint256 collectibleClass, uint256 sequenceId, bytes32 collectibleName, bool isRedeemed);&#13;
  event Transfer(address from, address to, uint256 shipId);&#13;
&#13;
  /*** CONSTANTS ***/&#13;
&#13;
  /// @notice Name and symbol of the non fungible token, as defined in ERC721.&#13;
  string public constant NAME = "CSCPreSaleShip";&#13;
  string public constant SYMBOL = "CSC";&#13;
  bytes4 constant InterfaceSignature_ERC165 = bytes4(keccak256('supportsInterface(bytes4)'));&#13;
  bytes4 constant InterfaceSignature_ERC721 =&#13;
        bytes4(keccak256('name()')) ^&#13;
        bytes4(keccak256('symbol()')) ^&#13;
        bytes4(keccak256('totalSupply()')) ^&#13;
        bytes4(keccak256('balanceOf(address)')) ^&#13;
        bytes4(keccak256('ownerOf(uint256)')) ^&#13;
        bytes4(keccak256('approve(address,uint256)')) ^&#13;
        bytes4(keccak256('transfer(address,uint256)')) ^&#13;
        bytes4(keccak256('transferFrom(address,address,uint256)')) ^&#13;
        bytes4(keccak256('tokensOfOwner(address)')) ^&#13;
        bytes4(keccak256('tokenMetadata(uint256,string)'));&#13;
&#13;
  /// @dev CSC Pre Sale Struct, having details of the ship&#13;
  struct CSCPreSaleItem {&#13;
&#13;
    /// @dev asset ID i..e Local Index&#13;
    uint256 assetId;&#13;
&#13;
    /// @dev name of the collectible stored in bytes&#13;
    bytes32 collectibleName;&#13;
&#13;
    /// @dev Timestamp when bought&#13;
    uint256 boughtTimestamp;&#13;
&#13;
    /// @dev Collectible Types (Voucher/Ship)&#13;
    /// can be 0 - Voucher, 1 - Ship&#13;
    uint256 collectibleType;&#13;
&#13;
    /// @dev Collectible Class (1 - Prometheus, 2 - Crosair, 3 - Intrepid)&#13;
    uint256 collectibleClass;&#13;
&#13;
    // @dev owner address&#13;
    address owner;&#13;
&#13;
    // @dev redeeme flag (to help whether it got redeemed or not)&#13;
    bool isRedeemed;&#13;
  }&#13;
  &#13;
  // @dev Mapping containing the reference to all CSC PreSaleItem&#13;
  //mapping (uint256 =&gt; CSCPreSaleItem[]) public indexToPreSaleItem;&#13;
&#13;
  // @dev array of CSCPreSaleItem type holding information on the Ships&#13;
  CSCPreSaleItem[] allPreSaleItems;&#13;
&#13;
  // Max Count for Voucher(s), Prometheus, Crosair &amp; Intrepid Ships&#13;
  uint256 public constant PROMETHEUS_SHIP_LIMIT = 300;&#13;
  uint256 public constant INTREPID_SHIP_LIMIT = 1500;&#13;
  uint256 public constant CROSAIR_SHIP_LIMIT = 600;&#13;
  uint256 public constant PROMETHEUS_VOUCHER_LIMIT = 100;&#13;
  uint256 public constant INTREPID_VOUCHER_LIMIT = 300;&#13;
  uint256 public constant CROSAIR_VOUCHER_LIMIT = 200;&#13;
&#13;
  // Variable to keep a count of Prometheus/Intrepid/Crosair Minted&#13;
  uint256 public prometheusShipMinted;&#13;
  uint256 public intrepidShipMinted;&#13;
  uint256 public crosairShipMinted;&#13;
  uint256 public prometheusVouchersMinted;&#13;
  uint256 public intrepidVouchersMinted;&#13;
  uint256 public crosairVouchersMinted;&#13;
&#13;
  // @dev mapping which holds all the possible addresses which are allowed to interact with the contract&#13;
  mapping (address =&gt; bool) approvedAddressList;&#13;
&#13;
  // @dev mapping holds the preSaleItem -&gt; owner details&#13;
  mapping (uint256 =&gt; address) public preSaleItemIndexToOwner;&#13;
&#13;
  // @dev A mapping from owner address to count of tokens that address owns.&#13;
  //  Used internally inside balanceOf() to resolve ownership count.&#13;
  mapping (address =&gt; uint256) private ownershipTokenCount;&#13;
&#13;
  /// @dev A mapping from preSaleItem to an address that has been approved to call&#13;
  ///  transferFrom(). Each Ship can only have one approved address for transfer&#13;
  ///  at any time. A zero value means no approval is outstanding.&#13;
  mapping (uint256 =&gt; address) public preSaleItemIndexToApproved;&#13;
&#13;
  /// @dev A mapping of preSaleItem Type to Type Sequence Number to Collectible&#13;
  /// 0 - Voucher&#13;
  /// 1 - Prometheus&#13;
  /// 2 - Crosair&#13;
  /// 3 - Intrepid&#13;
  mapping (uint256 =&gt; mapping (uint256 =&gt; mapping ( uint256 =&gt; uint256 ) ) ) public preSaleItemTypeToSequenceIdToCollectible;&#13;
&#13;
  /// @dev A mapping from Pre Sale Item Type IDs to the Sequqence Number .&#13;
  /// 0 - Voucher&#13;
  /// 1 - Prometheus&#13;
  /// 2 - Crosair&#13;
  /// 3 - Intrepid&#13;
  mapping (uint256 =&gt; mapping ( uint256 =&gt; uint256 ) ) public preSaleItemTypeToCollectibleCount;&#13;
&#13;
  /// @notice Introspection interface as per ERC-165 (https://github.com/ethereum/EIPs/issues/165).&#13;
  ///  Returns true for any standardized interfaces implemented by this contract. We implement&#13;
  ///  ERC-165 (obviously!) and ERC-721.&#13;
  function supportsInterface(bytes4 _interfaceID) external view returns (bool)&#13;
  {&#13;
      // DEBUG ONLY&#13;
      //require((InterfaceSignature_ERC165 == 0x01ffc9a7) &amp;&amp; (InterfaceSignature_ERC721 == 0x9a20483d));&#13;
      return ((_interfaceID == InterfaceSignature_ERC165) || (_interfaceID == InterfaceSignature_ERC721));&#13;
  }&#13;
&#13;
  function getCollectibleDetails(uint256 _assetId) external view returns(uint256 assetId, uint256 sequenceId, uint256 collectibleType, uint256 collectibleClass, bool isRedeemed, address owner) {&#13;
    CSCPreSaleItem memory _Obj = allPreSaleItems[_assetId];&#13;
    assetId = _assetId;&#13;
    sequenceId = _Obj.assetId;&#13;
    collectibleType = _Obj.collectibleType;&#13;
    collectibleClass = _Obj.collectibleClass;&#13;
    owner = _Obj.owner;&#13;
    isRedeemed = _Obj.isRedeemed;&#13;
  }&#13;
  &#13;
  /*** PUBLIC FUNCTIONS ***/&#13;
  /// @notice Grant another address the right to transfer token via takeOwnership() and transferFrom().&#13;
  /// @param _to The address to be granted transfer approval. Pass address(0) to&#13;
  ///  clear all approvals.&#13;
  /// @param _assetId The ID of the Token that can be transferred if this call succeeds.&#13;
  /// @dev Required for ERC-721 compliance.&#13;
  function approve(address _to, uint256 _assetId) public {&#13;
    // Caller must own token.&#13;
    require(_owns(msg.sender, _assetId));&#13;
    preSaleItemIndexToApproved[_assetId] = _to;&#13;
&#13;
    Approval(msg.sender, _to, _assetId);&#13;
  }&#13;
&#13;
  /// For querying balance of a particular account&#13;
  /// @param _owner The address for balance query&#13;
  /// @dev Required for ERC-721 compliance.&#13;
  function balanceOf(address _owner) public view returns (uint256 balance) {&#13;
    return ownershipTokenCount[_owner];&#13;
  }&#13;
&#13;
  function implementsERC721() public pure returns (bool) {&#13;
    return true;&#13;
  }&#13;
&#13;
  /// For querying owner of token&#13;
  /// @param _assetId The tokenID for owner inquiry&#13;
  /// @dev Required for ERC-721 compliance.&#13;
  function ownerOf(uint256 _assetId) public view returns (address owner) {&#13;
    owner = preSaleItemIndexToOwner[_assetId];&#13;
    require(owner != address(0));&#13;
  }&#13;
&#13;
  /// @dev Required for ERC-721 compliance.&#13;
  function symbol() public pure returns (string) {&#13;
    return SYMBOL;&#13;
  }&#13;
&#13;
  /// @notice Allow pre-approved user to take ownership of a token&#13;
  /// @param _assetId The ID of the Token that can be transferred if this call succeeds.&#13;
  /// @dev Required for ERC-721 compliance.&#13;
  function takeOwnership(uint256 _assetId) public {&#13;
    address newOwner = msg.sender;&#13;
    address oldOwner = preSaleItemIndexToOwner[_assetId];&#13;
&#13;
    // Safety check to prevent against an unexpected 0x0 default.&#13;
    require(_addressNotNull(newOwner));&#13;
&#13;
    // Making sure transfer is approved&#13;
    require(_approved(newOwner, _assetId));&#13;
&#13;
    _transfer(oldOwner, newOwner, _assetId);&#13;
  }&#13;
&#13;
  /// @param _owner The owner whose ships tokens we are interested in.&#13;
  /// @dev This method MUST NEVER be called by smart contract code. First, it's fairly&#13;
  ///  expensive (it walks the entire CSCShips array looking for emojis belonging to owner),&#13;
  ///  but it also returns a dynamic array, which is only supported for web3 calls, and&#13;
  ///  not contract-to-contract calls.&#13;
  function tokensOfOwner(address _owner) external view returns(uint256[] ownerTokens) {&#13;
    uint256 tokenCount = balanceOf(_owner);&#13;
&#13;
    if (tokenCount == 0) {&#13;
        // Return an empty array&#13;
        return new uint256[](0);&#13;
    } else {&#13;
        uint256[] memory result = new uint256[](tokenCount);&#13;
        uint256 totalShips = totalSupply() + 1;&#13;
        uint256 resultIndex = 0;&#13;
&#13;
        // We count on the fact that all CSC Ship Collectible have IDs starting at 0 and increasing&#13;
        // sequentially up to the total count.&#13;
        uint256 _assetId;&#13;
&#13;
        for (_assetId = 0; _assetId &lt; totalShips; _assetId++) {&#13;
            if (preSaleItemIndexToOwner[_assetId] == _owner) {&#13;
                result[resultIndex] = _assetId;&#13;
                resultIndex++;&#13;
            }&#13;
        }&#13;
&#13;
        return result;&#13;
    }&#13;
  }&#13;
&#13;
  /// For querying totalSupply of token&#13;
  /// @dev Required for ERC-721 compliance.&#13;
  function totalSupply() public view returns (uint256 total) {&#13;
    return allPreSaleItems.length - 1; //Removed 0 index&#13;
  }&#13;
&#13;
  /// Owner initates the transfer of the token to another account&#13;
  /// @param _to The address for the token to be transferred to.&#13;
  /// @param _assetId The ID of the Token that can be transferred if this call succeeds.&#13;
  /// @dev Required for ERC-721 compliance.&#13;
  function transfer(address _to, uint256 _assetId) public {&#13;
    require(_addressNotNull(_to));&#13;
    require(_owns(msg.sender, _assetId));&#13;
&#13;
    _transfer(msg.sender, _to, _assetId);&#13;
  }&#13;
&#13;
  /// Third-party initiates transfer of token from address _from to address _to&#13;
  /// @param _from The address for the token to be transferred from.&#13;
  /// @param _to The address for the token to be transferred to.&#13;
  /// @param _assetId The ID of the Token that can be transferred if this call succeeds.&#13;
  /// @dev Required for ERC-721 compliance.&#13;
  function transferFrom(address _from, address _to, uint256 _assetId) public {&#13;
    require(_owns(_from, _assetId));&#13;
    require(_approved(_to, _assetId));&#13;
    require(_addressNotNull(_to));&#13;
&#13;
    _transfer(_from, _to, _assetId);&#13;
  }&#13;
&#13;
  /*** PRIVATE FUNCTIONS ***/&#13;
  /// @dev  Safety check on _to address to prevent against an unexpected 0x0 default.&#13;
  function _addressNotNull(address _to) internal pure returns (bool) {&#13;
    return _to != address(0);&#13;
  }&#13;
&#13;
  /// @dev  For checking approval of transfer for address _to&#13;
  function _approved(address _to, uint256 _assetId) internal view returns (bool) {&#13;
    return preSaleItemIndexToApproved[_assetId] == _to;&#13;
  }&#13;
&#13;
  /// @dev For creating CSC Collectible&#13;
  function _createCollectible(bytes32 _collectibleName, uint256 _collectibleType, uint256 _collectibleClass) internal returns(uint256) {&#13;
    uint256 _sequenceId = uint256(preSaleItemTypeToCollectibleCount[_collectibleType][_collectibleClass]) + 1;&#13;
&#13;
    // These requires are not strictly necessary, our calling code should make&#13;
    // sure that these conditions are never broken.&#13;
    require(_sequenceId == uint256(uint32(_sequenceId)));&#13;
    &#13;
    CSCPreSaleItem memory _collectibleObj = CSCPreSaleItem(&#13;
      _sequenceId,&#13;
      _collectibleName,&#13;
      0,&#13;
      _collectibleType,&#13;
      _collectibleClass,&#13;
      address(0),&#13;
      false&#13;
    );&#13;
&#13;
    uint256 newCollectibleId = allPreSaleItems.push(_collectibleObj) - 1;&#13;
    &#13;
    preSaleItemTypeToSequenceIdToCollectible[_collectibleType][_collectibleClass][_sequenceId] = newCollectibleId;&#13;
    preSaleItemTypeToCollectibleCount[_collectibleType][_collectibleClass] = _sequenceId;&#13;
&#13;
    // emit Created event&#13;
    // CollectibleCreated(address owner, uint256 globalId, uint256 collectibleType, uint256 collectibleClass, uint256 sequenceId, bytes32[6] attributes, bool isRedeemed);&#13;
    CollectibleCreated(address(this), newCollectibleId, _collectibleType, _collectibleClass, _sequenceId, _collectibleObj.collectibleName, false);&#13;
    &#13;
    // This will assign ownership, and also emit the Transfer event as&#13;
    // per ERC721 draft&#13;
    _transfer(address(0), address(this), newCollectibleId);&#13;
    &#13;
    return newCollectibleId;&#13;
  }&#13;
&#13;
  /// Check for token ownership&#13;
  function _owns(address claimant, uint256 _assetId) internal view returns (bool) {&#13;
    return claimant == preSaleItemIndexToOwner[_assetId];&#13;
  }&#13;
&#13;
  /// @dev Assigns ownership of a specific Emoji to an address.&#13;
  function _transfer(address _from, address _to, uint256 _assetId) internal {&#13;
    // Updating the owner details of the ship&#13;
    CSCPreSaleItem memory _shipObj = allPreSaleItems[_assetId];&#13;
    _shipObj.owner = _to;&#13;
    allPreSaleItems[_assetId] = _shipObj;&#13;
&#13;
    // Since the number of emojis is capped to 2^32 we can't overflow this&#13;
    ownershipTokenCount[_to]++;&#13;
&#13;
    //transfer ownership&#13;
    preSaleItemIndexToOwner[_assetId] = _to;&#13;
&#13;
    // When creating new emojis _from is 0x0, but we can't account that address.&#13;
    if (_from != address(0)) {&#13;
      ownershipTokenCount[_from]--;&#13;
      // clear any previously approved ownership exchange&#13;
      delete preSaleItemIndexToApproved[_assetId];&#13;
    }&#13;
&#13;
    // Emit the transfer event.&#13;
    Transfer(_from, _to, _assetId);&#13;
  }&#13;
&#13;
  /// @dev Checks if a given address currently has transferApproval for a particular CSCPreSaleItem.&#13;
  /// 0 is a valid value as it will be the starter&#13;
  function _approvedFor(address _claimant, uint256 _assetId) internal view returns (bool) {&#13;
      return preSaleItemIndexToApproved[_assetId] == _claimant;&#13;
  }&#13;
&#13;
  function _getCollectibleDetails (uint256 _assetId) internal view returns(CSCPreSaleItem) {&#13;
    CSCPreSaleItem storage _Obj = allPreSaleItems[_assetId];&#13;
    return _Obj;&#13;
  }&#13;
&#13;
  /// @dev Helps in fetching the attributes of the ship depending on the ship&#13;
  /// assetId : The actual ERC721 Asset ID&#13;
  /// sequenceId : Index w.r.t Ship type&#13;
  function getShipDetails(uint256 _sequenceId, uint256 _shipClass) external view returns (&#13;
    uint256 assetId,&#13;
    uint256 sequenceId,&#13;
    string shipName,&#13;
    uint256 collectibleClass,&#13;
    uint256 boughtTimestamp,&#13;
    address owner&#13;
    ) {  &#13;
    uint256 _assetId = preSaleItemTypeToSequenceIdToCollectible[1][_shipClass][_sequenceId];&#13;
&#13;
    CSCPreSaleItem storage _collectibleObj = allPreSaleItems[_assetId];&#13;
    require(_collectibleObj.collectibleType == 1);&#13;
&#13;
    assetId = _assetId;&#13;
    sequenceId = _sequenceId;&#13;
    shipName = bytes32ToString(_collectibleObj.collectibleName);&#13;
    collectibleClass = _collectibleObj.collectibleClass;&#13;
    boughtTimestamp = _collectibleObj.boughtTimestamp;&#13;
    owner = _collectibleObj.owner;&#13;
  }&#13;
&#13;
  /// @dev Helps in fetching information regarding a Voucher&#13;
  /// assetId : The actual ERC721 Asset ID&#13;
  /// sequenceId : Index w.r.t Voucher Type&#13;
  function getVoucherDetails(uint256 _sequenceId, uint256 _voucherClass) external view returns (&#13;
    uint256 assetId,&#13;
    uint256 sequenceId,&#13;
    uint256 boughtTimestamp,&#13;
    uint256 voucherClass,&#13;
    address owner&#13;
    ) {&#13;
    uint256 _assetId = preSaleItemTypeToSequenceIdToCollectible[0][_voucherClass][_sequenceId];&#13;
&#13;
    CSCPreSaleItem storage _collectibleObj = allPreSaleItems[_assetId];&#13;
    require(_collectibleObj.collectibleType == 0);&#13;
&#13;
    assetId = _assetId;&#13;
    sequenceId = _sequenceId;&#13;
    boughtTimestamp = _collectibleObj.boughtTimestamp;&#13;
    voucherClass = _collectibleObj.collectibleClass;&#13;
    owner = _collectibleObj.owner;&#13;
  }&#13;
&#13;
  function _isActive(uint256 _assetId) internal returns(bool) {&#13;
    CSCPreSaleItem memory _Obj = allPreSaleItems[_assetId];&#13;
    return (_Obj.boughtTimestamp == 0);&#13;
  }&#13;
}&#13;
&#13;
/* Lucid Sight, Inc. ERC-721 CSC Collectilbe Sale Contract. &#13;
 * @title CSCCollectibleSale&#13;
 * @author Fazri Zubair &amp; Farhan Khwaja (Lucid Sight, Inc.)&#13;
 */&#13;
contract CSCCollectibleSale is CSCCollectibleBase {&#13;
  event CollectibleBought (uint256 _assetId, address owner);&#13;
  event PriceUpdated (uint256 collectibleClass, uint256 newPrice, uint256 oldPrice);&#13;
&#13;
  //  SHIP DATATYPES &amp; CONSTANTS&#13;
  // @dev ship Prices &amp; price cap&#13;
  uint256 public PROMETHEUS_SHIP_PRICE = 0.25 ether;&#13;
  uint256 public INTREPID_SHIP_PRICE = 0.005 ether;&#13;
  uint256 public CROSAIR_SHIP_PRICE = 0.1 ether;&#13;
&#13;
  uint256 public constant PROMETHEUS_MAX_PRICE = 0.85 ether;&#13;
  uint256 public constant INTREPID_MAX_PRICE = 0.25 ether;&#13;
  uint256 public constant CROSAIR_MAX_PRICE = 0.5 ether;&#13;
&#13;
  uint256 public constant PROMETHEUS_PRICE_INCREMENT = 0.05 ether;&#13;
  uint256 public constant INTREPID_PRICE_INCREMENT = 0.002 ether;&#13;
  uint256 public constant CROSAIR_PRICE_INCREMENT = 0.01 ether;&#13;
&#13;
  uint256 public constant PROMETHEUS_PRICE_THRESHOLD = 0.85 ether;&#13;
  uint256 public constant INTREPID_PRICE_THRESHOLD = 0.25 ether;&#13;
  uint256 public constant CROSAIR_PRICE_THRESHOLD = 0.5 ether;&#13;
&#13;
  uint256 public prometheusSoldCount;&#13;
  uint256 public intrepidSoldCount;&#13;
  uint256 public crosairSoldCount;&#13;
&#13;
  //  VOUCHER DATATYPES &amp; CONSTANTS&#13;
  uint256 public PROMETHEUS_VOUCHER_PRICE = 0.75 ether;&#13;
  uint256 public INTREPID_VOUCHER_PRICE = 0.2 ether;&#13;
  uint256 public CROSAIR_VOUCHER_PRICE = 0.35 ether;&#13;
&#13;
  uint256 public prometheusVoucherSoldCount;&#13;
  uint256 public crosairVoucherSoldCount;&#13;
  uint256 public intrepidVoucherSoldCount;&#13;
  &#13;
  /// @dev Mapping created store the amount of value a wallet address used to buy assets&#13;
  mapping(address =&gt; uint256) addressToValue;&#13;
&#13;
  /// @dev Mapping to holde the balance of each address, i.e. addrs -&gt; collectibleType -&gt; collectibleClass -&gt; balance&#13;
  mapping(address =&gt; mapping(uint256 =&gt; mapping (uint256 =&gt; uint256))) addressToCollectibleTypeBalance;&#13;
&#13;
  function _bid(uint256 _assetId, uint256 _price,uint256 _collectibleType,uint256 _collectibleClass, address _buyer) internal {&#13;
    CSCPreSaleItem memory _Obj = allPreSaleItems[_assetId];&#13;
&#13;
    if(_collectibleType == 1 &amp;&amp; _collectibleClass == 1) {&#13;
      require(_price == PROMETHEUS_SHIP_PRICE);&#13;
      _Obj.owner = _buyer;&#13;
      _Obj.boughtTimestamp = now;&#13;
&#13;
      addressToValue[_buyer] += _price;&#13;
&#13;
      prometheusSoldCount++;&#13;
      if(prometheusSoldCount % 10 == 0){&#13;
        if(PROMETHEUS_SHIP_PRICE &lt; PROMETHEUS_PRICE_THRESHOLD){&#13;
          PROMETHEUS_SHIP_PRICE +=  PROMETHEUS_PRICE_INCREMENT;&#13;
        }&#13;
      }&#13;
    }&#13;
&#13;
    if(_collectibleType == 1 &amp;&amp; _collectibleClass == 2) {&#13;
      require(_price == CROSAIR_SHIP_PRICE);&#13;
      _Obj.owner = _buyer;&#13;
      _Obj.boughtTimestamp = now;&#13;
&#13;
      addressToValue[_buyer] += _price;&#13;
&#13;
      crosairSoldCount++;&#13;
      if(crosairSoldCount % 10 == 0){&#13;
        if(CROSAIR_SHIP_PRICE &lt; CROSAIR_PRICE_THRESHOLD){&#13;
          CROSAIR_SHIP_PRICE += CROSAIR_PRICE_INCREMENT;&#13;
        }&#13;
      }&#13;
    }&#13;
&#13;
    if(_collectibleType == 1 &amp;&amp; _collectibleClass == 3) {&#13;
      require(_price == INTREPID_SHIP_PRICE);&#13;
      _Obj.owner = _buyer;&#13;
      _Obj.boughtTimestamp = now;&#13;
&#13;
      addressToValue[_buyer] += _price;&#13;
&#13;
      intrepidSoldCount++;&#13;
      if(intrepidSoldCount % 10 == 0){&#13;
        if(INTREPID_SHIP_PRICE &lt; INTREPID_PRICE_THRESHOLD){&#13;
          INTREPID_SHIP_PRICE += INTREPID_PRICE_INCREMENT;&#13;
        }&#13;
      }&#13;
    }&#13;
&#13;
    if(_collectibleType == 0 &amp;&amp;_collectibleClass == 1) {&#13;
        require(_price == PROMETHEUS_VOUCHER_PRICE);&#13;
        _Obj.owner = _buyer;&#13;
        _Obj.boughtTimestamp = now;&#13;
&#13;
        addressToValue[_buyer] += _price;&#13;
&#13;
        prometheusVoucherSoldCount++;&#13;
      }&#13;
&#13;
      if(_collectibleType == 0 &amp;&amp; _collectibleClass == 2) {&#13;
        require(_price == CROSAIR_VOUCHER_PRICE);&#13;
        _Obj.owner = _buyer;&#13;
        _Obj.boughtTimestamp = now;&#13;
&#13;
        addressToValue[_buyer] += _price;&#13;
&#13;
        crosairVoucherSoldCount++;&#13;
      }&#13;
      &#13;
      if(_collectibleType == 0 &amp;&amp; _collectibleClass == 3) {&#13;
        require(_price == INTREPID_VOUCHER_PRICE);&#13;
        _Obj.owner = _buyer;&#13;
        _Obj.boughtTimestamp = now;&#13;
&#13;
        addressToValue[_buyer] += _price;&#13;
&#13;
        intrepidVoucherSoldCount++;&#13;
      }&#13;
&#13;
    addressToCollectibleTypeBalance[_buyer][_collectibleType][_collectibleClass]++;&#13;
&#13;
    CollectibleBought(_assetId, _buyer);&#13;
  }&#13;
&#13;
  function getCollectibleTypeBalance(address _owner, uint256 _collectibleType, uint256 _collectibleClass) external view returns(uint256) {&#13;
    require(_owner != address(0));&#13;
    return addressToCollectibleTypeBalance[_owner][_collectibleType][_collectibleClass];&#13;
  }&#13;
&#13;
  function getCollectiblePrice(uint256 _collectibleType, uint256 _collectibleClass) external view returns(uint256 _price){&#13;
&#13;
    // For Ships&#13;
    if(_collectibleType == 1 &amp;&amp; _collectibleClass == 1) {&#13;
      return PROMETHEUS_SHIP_PRICE;&#13;
    }&#13;
&#13;
    if(_collectibleType == 1 &amp;&amp; _collectibleClass == 2) {&#13;
      return CROSAIR_SHIP_PRICE;&#13;
    }&#13;
&#13;
    if(_collectibleType == 1 &amp;&amp; _collectibleClass == 3) {&#13;
      return INTREPID_SHIP_PRICE;&#13;
    }&#13;
&#13;
    // For Vouchers&#13;
    if(_collectibleType == 0 &amp;&amp; _collectibleClass == 1) {&#13;
      return PROMETHEUS_VOUCHER_PRICE;&#13;
    }&#13;
&#13;
    if(_collectibleType == 0 &amp;&amp; _collectibleClass == 2) {&#13;
      return CROSAIR_VOUCHER_PRICE;&#13;
    }&#13;
&#13;
    if(_collectibleType == 0 &amp;&amp; _collectibleClass == 3) {&#13;
      return INTREPID_VOUCHER_PRICE;&#13;
    }&#13;
  }&#13;
}&#13;
&#13;
/* Lucid Sight, Inc. ERC-721 Collectibles. &#13;
 * @title LSNFT - Lucid Sight, Inc. Non-Fungible Token&#13;
 * @author Fazri Zubair &amp; Farhan Khwaja (Lucid Sight, Inc.)&#13;
 */&#13;
contract CSCPreSaleManager is CSCCollectibleSale {&#13;
  event RefundClaimed(address owner, uint256 refundValue);&#13;
&#13;
  // Ship Names&#13;
  string private constant prometheusShipName = "Vulcan Harvester";&#13;
  string private constant crosairShipName = "Phoenix Cruiser";&#13;
  string private constant intrepidShipName = "Reaper Interceptor";&#13;
&#13;
  bool CSCPreSaleInit = false;&#13;
&#13;
  /// @dev Constructor creates a reference to the NFT (ERC721) ownership contract&#13;
  function CSCPreSaleManager() public {&#13;
      require(msg.sender != address(0));&#13;
      paused = true;&#13;
      error = false;&#13;
      gameManagerPrimary = msg.sender;&#13;
  }&#13;
&#13;
  function addToApprovedAddress (address _newAddr) onlyGameManager {&#13;
    require(_newAddr != address(0));&#13;
    require(!approvedAddressList[_newAddr]);&#13;
    approvedAddressList[_newAddr] = true;&#13;
  }&#13;
&#13;
  function removeFromApprovedAddress (address _newAddr) onlyGameManager {&#13;
    require(_newAddr != address(0));&#13;
    require(approvedAddressList[_newAddr]);&#13;
    approvedAddressList[_newAddr] = false;&#13;
  }&#13;
&#13;
  function() external payable {&#13;
  }&#13;
&#13;
  /// @dev Bid Function which call the interncal bid function&#13;
  /// after doing all the pre-checks required to initiate a bid&#13;
  function bid(uint256 _collectibleType, uint256 _collectibleClass) external payable {&#13;
    require(msg.sender != address(0));&#13;
    require(msg.sender != address(this));&#13;
&#13;
    require(_collectibleType &gt;= 0 &amp;&amp; _collectibleType &lt;= 1);&#13;
&#13;
    require(_isActive(_assetId));&#13;
&#13;
    bytes32 collectibleName;&#13;
&#13;
    if(_collectibleType == 0){&#13;
      collectibleName = bytes32("NoNameForVoucher");&#13;
      if(_collectibleClass == 1){&#13;
        require(prometheusVouchersMinted &lt; PROMETHEUS_VOUCHER_LIMIT);&#13;
        collectibleName = stringToBytes32(prometheusShipName);&#13;
        prometheusVouchersMinted++;&#13;
      }&#13;
      &#13;
      if(_collectibleClass == 2){&#13;
        require(crosairVouchersMinted &lt; CROSAIR_VOUCHER_LIMIT);&#13;
        crosairVouchersMinted++;&#13;
      }&#13;
&#13;
      if(_collectibleClass == 3){&#13;
        require(intrepidVoucherSoldCount &lt; INTREPID_VOUCHER_LIMIT);&#13;
        intrepidVouchersMinted++;&#13;
      }&#13;
    }&#13;
&#13;
    if(_collectibleType == 1){&#13;
      if(_collectibleClass == 1){&#13;
        require(prometheusShipMinted &lt; PROMETHEUS_SHIP_LIMIT);&#13;
        collectibleName = stringToBytes32(prometheusShipName);&#13;
        prometheusShipMinted++;&#13;
      }&#13;
      &#13;
      if(_collectibleClass == 2){&#13;
        require(crosairShipMinted &lt; CROSAIR_VOUCHER_LIMIT);&#13;
        collectibleName = stringToBytes32(crosairShipName);&#13;
        crosairShipMinted++;&#13;
      }&#13;
&#13;
      if(_collectibleClass == 3){&#13;
        require(intrepidShipMinted &lt; INTREPID_SHIP_LIMIT);&#13;
        collectibleName = stringToBytes32(intrepidShipName);&#13;
        intrepidShipMinted++;&#13;
      }&#13;
    }&#13;
&#13;
    uint256 _assetId = _createCollectible(collectibleName, _collectibleType, _collectibleClass); &#13;
&#13;
    CSCPreSaleItem memory _Obj = allPreSaleItems[_assetId];&#13;
&#13;
    _bid(_assetId, msg.value, _Obj.collectibleType, _Obj.collectibleClass, msg.sender);&#13;
    &#13;
    _transfer(address(this), msg.sender, _assetId);&#13;
  }&#13;
&#13;
  /// @dev Bid Function which call the interncal bid function&#13;
  /// after doing all the pre-checks required to initiate a bid&#13;
  function createReferralGiveAways(uint256 _collectibleType, uint256 _collectibleClass, address _toAddress) onlyGameManager external {&#13;
    require(msg.sender != address(0));&#13;
    require(msg.sender != address(this));&#13;
&#13;
    require(_collectibleType &gt;= 0 &amp;&amp; _collectibleType &lt;= 1);&#13;
&#13;
    bytes32 collectibleName;&#13;
&#13;
    if(_collectibleType == 0){&#13;
      collectibleName = bytes32("ReferralGiveAwayVoucher");&#13;
      if(_collectibleClass == 1){&#13;
        collectibleName = stringToBytes32(prometheusShipName);&#13;
      }&#13;
      &#13;
      if(_collectibleClass == 2){&#13;
        crosairVouchersMinted++;&#13;
      }&#13;
&#13;
      if(_collectibleClass == 3){&#13;
        intrepidVouchersMinted++;&#13;
      }&#13;
    }&#13;
&#13;
    if(_collectibleType == 1){&#13;
      if(_collectibleClass == 1){&#13;
        collectibleName = stringToBytes32(prometheusShipName);&#13;
      }&#13;
      &#13;
      if(_collectibleClass == 2){&#13;
        collectibleName = stringToBytes32(crosairShipName);&#13;
      }&#13;
&#13;
      if(_collectibleClass == 3){&#13;
        collectibleName = stringToBytes32(intrepidShipName);&#13;
      }&#13;
    }&#13;
&#13;
    uint256 _assetId = _createCollectible(collectibleName, _collectibleType, _collectibleClass); &#13;
&#13;
    CSCPreSaleItem memory _Obj = allPreSaleItems[_assetId];&#13;
    &#13;
    _transfer(address(this), _toAddress, _assetId);&#13;
  }&#13;
&#13;
  /// @dev Override unpause so it requires all external contract addresses&#13;
  ///  to be set before contract can be unpaused. Also, we can't have&#13;
  ///  newContractAddress set either, because then the contract was upgraded.&#13;
  /// @notice This is public rather than external so we can call super.unpause&#13;
  ///  without using an expensive CALL.&#13;
  function unpause() public onlyGameManager whenPaused {&#13;
      // Actually unpause the contract.&#13;
      super.unpause();&#13;
  }&#13;
&#13;
  /// @dev Remove all Ether from the contract, which is the owner's cuts&#13;
  ///  as well as any Ether sent directly to the contract address.&#13;
  ///  Always transfers to the NFT (ERC721) contract, but can be called either by&#13;
  ///  the owner or the NFT (ERC721) contract.&#13;
  function withdrawBalance() onlyBanker {&#13;
      // We are using this boolean method to make sure that even if one fails it will still work&#13;
      bankManager.transfer(this.balance);&#13;
  }&#13;
&#13;
  function claimRefund(address _ownerAddress) whenError {&#13;
    uint256 refundValue = addressToValue[_ownerAddress];&#13;
    addressToValue[_ownerAddress] = 0;&#13;
&#13;
    _ownerAddress.transfer(refundValue);&#13;
    RefundClaimed(_ownerAddress, refundValue);&#13;
  }&#13;
  &#13;
  function preSaleInit() onlyGameManager {&#13;
    require(!CSCPreSaleInit);&#13;
    require(allPreSaleItems.length == 0);&#13;
      &#13;
    CSCPreSaleInit = true;&#13;
&#13;
    //Fill in index 0 to null requests&#13;
    CSCPreSaleItem memory _Obj = CSCPreSaleItem(0, stringToBytes32("DummyAsset"), 0, 0, 0, address(this), true);&#13;
    allPreSaleItems.push(_Obj);&#13;
  }&#13;
&#13;
  function isRedeemed(uint256 _assetId) {&#13;
    require(approvedAddressList[msg.sender]);&#13;
&#13;
    CSCPreSaleItem memory _Obj = allPreSaleItems[_assetId];&#13;
    _Obj.isRedeemed = true;&#13;
&#13;
    allPreSaleItems[_assetId] = _Obj;&#13;
  }&#13;
}