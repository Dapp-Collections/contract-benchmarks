pragma solidity ^0.4.19;

// DELEGATION SC v1.1
// (c) SecureVote 2018
// Author: Max Kaye <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="234e425b635046405651460d554c5746">[emailÂ protected]</a>&gt;&#13;
// Released under MIT licence&#13;
&#13;
// the most up-to-date version of the contract lives at delegate.secvote.eth&#13;
&#13;
&#13;
// Main delegation contract v1.1&#13;
contract SVDelegationV0101 {&#13;
&#13;
    address public owner;&#13;
&#13;
    // in the last version we didn't include enough data - this makes it trivial to traverse off-chain&#13;
    struct Delegation {&#13;
        uint64 thisDelegationId;&#13;
        uint64 prevDelegationId;&#13;
        uint64 setAtBlock;&#13;
        address delegatee;&#13;
        address delegator;&#13;
        address tokenContract;&#13;
    }&#13;
&#13;
    // easy lookups&#13;
    mapping (address =&gt; mapping (address =&gt; Delegation)) tokenDlgts;&#13;
    mapping (address =&gt; Delegation) globalDlgts;&#13;
&#13;
    // track which token contracts we know about for easy traversal + backwards compatibility&#13;
    mapping (address =&gt; bool) knownTokenContracts;&#13;
    address[] logTokenContracts;&#13;
&#13;
    // track all delegations via an indexed map&#13;
    mapping (uint64 =&gt; Delegation) historicalDelegations;&#13;
    uint64 public totalDelegations = 0;&#13;
&#13;
    // reference to v1.0 of contract&#13;
    SVDelegation prevSVDelegation;&#13;
&#13;
    // pretty straight forward - events&#13;
    event SetGlobalDelegation(address voter, address delegate);&#13;
    event SetTokenDelegation(address voter, address tokenContract, address delegate);&#13;
&#13;
    // main constructor - requires the prevDelegationSC address&#13;
    function SVDelegationV0101(address prevDelegationSC) public {&#13;
        owner = msg.sender;&#13;
&#13;
        prevSVDelegation = SVDelegation(prevDelegationSC);&#13;
&#13;
        // commit the genesis historical delegation to history (like genesis block) - somewhere to point back to&#13;
        createDelegation(address(0), 0, address(0));&#13;
    }&#13;
&#13;
    // internal function to handle inserting delegates into state&#13;
    function createDelegation(address dlgtAddress, uint64 prevDelegationId, address tokenContract) internal returns(Delegation) {&#13;
        // use this to log known tokenContracts&#13;
        if (!knownTokenContracts[tokenContract]) {&#13;
            logTokenContracts.push(tokenContract);&#13;
            knownTokenContracts[tokenContract] = true;&#13;
        }&#13;
&#13;
        uint64 myDelegationId = totalDelegations;&#13;
        historicalDelegations[myDelegationId] = Delegation(myDelegationId, prevDelegationId, uint64(block.number), dlgtAddress, msg.sender, tokenContract);&#13;
        totalDelegations += 1;&#13;
&#13;
        return historicalDelegations[myDelegationId];&#13;
    }&#13;
&#13;
    // get previous delegation, create new delegation via function and then commit to globalDlgts&#13;
    function setGlobalDelegation(address dlgtAddress) public {&#13;
        uint64 prevDelegationId = globalDlgts[msg.sender].thisDelegationId;&#13;
        globalDlgts[msg.sender] = createDelegation(dlgtAddress, prevDelegationId, address(0));&#13;
        SetGlobalDelegation(msg.sender, dlgtAddress);&#13;
    }&#13;
&#13;
    // get previous delegation, create new delegation via function and then commit to tokenDlgts&#13;
    function setTokenDelegation(address tokenContract, address dlgtAddress) public {&#13;
        uint64 prevDelegationId = tokenDlgts[tokenContract][msg.sender].thisDelegationId;&#13;
        tokenDlgts[tokenContract][msg.sender] = createDelegation(dlgtAddress, prevDelegationId, tokenContract);&#13;
        SetTokenDelegation(msg.sender, tokenContract, dlgtAddress);&#13;
    }&#13;
&#13;
    // given some voter and token address, get the delegation id - failover to global on 0 address&#13;
    function getDelegationID(address voter, address tokenContract) public constant returns(uint64) {&#13;
        // default to token resolution but use global if no delegation&#13;
        Delegation memory _tokenDlgt = tokenDlgts[tokenContract][voter];&#13;
        if (tokenContract == address(0)) {&#13;
            _tokenDlgt = globalDlgts[voter];&#13;
        }&#13;
&#13;
        // default to 0 if we don't have a valid delegation&#13;
        if (_validDelegation(_tokenDlgt)) {&#13;
            return _tokenDlgt.thisDelegationId;&#13;
        }&#13;
        return 0;&#13;
    }&#13;
&#13;
    function resolveDelegation(address voter, address tokenContract) public constant returns(uint64, uint64, uint64, address, address, address) {&#13;
        Delegation memory _tokenDlgt = tokenDlgts[tokenContract][voter];&#13;
&#13;
        // if we have a delegation in this contract return it&#13;
        if (_validDelegation(_tokenDlgt)) {&#13;
            return _dlgtRet(_tokenDlgt);&#13;
        }&#13;
&#13;
        // otherwise try the global delegation&#13;
        Delegation memory _globalDlgt = globalDlgts[voter];&#13;
        if (_validDelegation(_globalDlgt)) {&#13;
            return _dlgtRet(_globalDlgt);&#13;
        }&#13;
&#13;
        // but if we don't have a delegation in this contract then resolve according the prev contract&#13;
        address _dlgt;&#13;
        uint256 meh;&#13;
        (meh, _dlgt, meh, meh) = prevSVDelegation.resolveDelegation(voter, tokenContract);&#13;
        return (0, 0, 0, _dlgt, voter, tokenContract);&#13;
    }&#13;
&#13;
    // returns 2 lists: first of voter addresses, second of token contracts&#13;
    function findPossibleDelegatorsOf(address delegate) public view returns(address[] memory, address[] memory) {&#13;
        // not meant to be run on-chain, but off-chain via API, mostly convenience&#13;
        address[] memory voters;&#13;
        address[] memory tokenContracts;&#13;
        Delegation memory _delegation;&#13;
&#13;
        // all the senders who participated in v1.0 of the contract prior to block 5203500&#13;
        address[43] memory oldSenders =&#13;
            [ 0xE8193Bc3D5F3F482406706F843A5f161563F37Bf&#13;
            , 0x7A933c8a0Eb99e8Bdb07E1b42Aa10872845394B7&#13;
            , 0x88341191EfA40Cd031F46138817830A5D3545Ba9&#13;
            , 0xB6dc48E8583C8C6e320DaF918CAdef65f2d85B46&#13;
            , 0xF02d417c8c6736Dbc7Eb089DC6738b950c2F444e&#13;
            , 0xF66fE29Ad1E87104A8816AD1A8427976d83CB033&#13;
            , 0xfd5955bf412B7537873CBB77eB1E39871e20e142&#13;
            , 0xe83Efc57d9C487ACc55a7B62896dA43928E64C3E&#13;
            , 0xd0c41588b27E64576ddA4e6a08452c59F5A2B2dD&#13;
            , 0x640370126072f6B890d4Ca2E893103e9363DbE8B&#13;
            , 0x887dbaCD9a0e58B46065F93cc1f82a52DEfDb979&#13;
            , 0xe223771699665bCB0AAf7930277C35d3deC573aF&#13;
            , 0x364B503B0e86b20B7aC1484c247DE50f10DfD8cf&#13;
            , 0x4512F5867d91D6B0131427b89Bdb7b460fF30397&#13;
            , 0xF5fBff477F5Bf5a950F661B70F6b5364875A1bD7&#13;
            , 0x9EbB758483Da174DC3d411386B75afd093CEfCf1&#13;
            , 0x499B36A6B92F91524A6B5b8Ff321740e84a2B57e&#13;
            , 0x05D6e87fd6326F977a2d8c67b9F3EcC030527261&#13;
            , 0x7f679053a1679dE7913885F0Db1278e91e8927Ca&#13;
            , 0xF9CD08d36e972Bb070bBD2C1598D21045259AB0D&#13;
            , 0xa5617800B8FD754fB81F47A65dc49A60acCc3432&#13;
            , 0xa9F6238B83fcb65EcA3c3189a0dce8689e275D57&#13;
            , 0xa30F92F9cc478562e0dde73665f1B7ADddDC2dCd&#13;
            , 0x70278C15A29f0Ef62A845e1ac31AE41988F24C10&#13;
            , 0xd42622471946CCFf9F7b9246e8D786c74410bFcC&#13;
            , 0xd65955EF0f8890D7996f5a7b7b5b05B80605C06a&#13;
            , 0xB46F4eBDD6404686D785EDACE37D66f815ED7cF8&#13;
            , 0xf4d3aa8091D23f97706177CDD94b8dF4c7e4C2FB&#13;
            , 0x4Fe584FFc9C755BF6Aa9354323e97166958475c9&#13;
            , 0xB4802f497Bf6238A29e043103EE6eeae1331BFde&#13;
            , 0x3EeE0f8Fadc1C29bFB782E70067a8D91B4ddeD56&#13;
            , 0x46381F606014C5D68B38aD5C7e8f9401149FAa75&#13;
            , 0xC81Be3496d053364255f9cb052F81Ca9e84A9cF3&#13;
            , 0xa632837B095d8fa2ef46a22099F91Fe10B3F0538&#13;
            , 0x19FA94aEbD4bC694802B566Ae65aEd8F07B992f7&#13;
            , 0xE9Ef7664d36191Ad7aB001b9BB0aAfAcD260277F&#13;
            , 0x17DAB6BB606f32447aff568c1D0eEDC3649C101C&#13;
            , 0xaBA96c77E3dd7EEa16cc5EbdAAA05483CDD0FF89&#13;
            , 0x57d36B0B5f5E333818b1ce072A6D84218E734deC&#13;
            , 0x59E7612706DFB1105220CcB97aaF3cBF304cD608&#13;
            , 0xCf7EC4dcA84b5c8Dc7896c38b4834DC6379BB73D&#13;
            , 0x5Ed1Da246EA52F302FFf9391e56ec64b9c14cce1&#13;
            , 0x4CabFD1796Ec9EAd77457768e5cA782a1A9e576F&#13;
            ];&#13;
&#13;
        // there were no global delegations in v1.0 of contract&#13;
        address oldToken = 0x9e88613418cF03dCa54D6a2cf6Ad934A78C7A17A;&#13;
&#13;
        // first loop through delegations in this contract&#13;
        uint64 i;&#13;
        // start at 1 because the first delegation is a "genesis" delegation in constructor&#13;
        for (i = 1; i &lt; totalDelegations; i++) {&#13;
            _delegation = historicalDelegations[i];&#13;
            if (_delegation.delegatee == delegate) {&#13;
                // since `.push` isn't available on memory arrays, use their length as the next index location&#13;
                voters = _appendMemArray(voters, _delegation.delegator);&#13;
                tokenContracts = _appendMemArray(tokenContracts, _delegation.tokenContract);&#13;
            }&#13;
        }&#13;
&#13;
        // then loop through delegations in the previous contract&#13;
        for (i = 0; i &lt; oldSenders.length; i++) {&#13;
            uint256 _oldId;&#13;
            address _oldDlgt;&#13;
            uint256 _oldSetAtBlock;&#13;
            uint256 _oldPrevId;&#13;
            (_oldId, _oldDlgt, _oldSetAtBlock, _oldPrevId) = prevSVDelegation.resolveDelegation(oldSenders[i], oldToken);&#13;
            if (_oldDlgt == delegate &amp;&amp; _oldSetAtBlock != 0) {&#13;
                voters = _appendMemArray(voters, oldSenders[i]);&#13;
                tokenContracts = _appendMemArray(tokenContracts, oldToken);&#13;
            }&#13;
        }&#13;
&#13;
        return (voters, tokenContracts);&#13;
    }&#13;
&#13;
    // give access to historicalDelegations&#13;
    function getHistoricalDelegation(uint64 delegationId) public constant returns(uint64, uint64, uint64, address, address, address) {&#13;
        return _dlgtRet(historicalDelegations[delegationId]);&#13;
    }&#13;
&#13;
    // access the globalDelegation map&#13;
    function _rawGetGlobalDelegation(address _voter) public constant returns(uint64, uint64, uint64, address, address, address) {&#13;
        return _dlgtRet(globalDlgts[_voter]);&#13;
    }&#13;
&#13;
    // access the tokenDelegation map&#13;
    function _rawGetTokenDelegation(address _voter, address _tokenContract) public constant returns(uint64, uint64, uint64, address, address, address) {&#13;
        return _dlgtRet(tokenDlgts[_tokenContract][_voter]);&#13;
    }&#13;
&#13;
    // access our log list of token contracts&#13;
    function _getLogTokenContract(uint256 i) public constant returns(address) {&#13;
        return logTokenContracts[i];&#13;
    }&#13;
&#13;
    // convenience function to turn Delegations into a returnable structure&#13;
    function _dlgtRet(Delegation d) internal pure returns(uint64, uint64, uint64, address, address, address) {&#13;
        return (d.thisDelegationId, d.prevDelegationId, d.setAtBlock, d.delegatee, d.delegator, d.tokenContract);&#13;
    }&#13;
&#13;
    // internal function to test if a delegation is valid or revoked / nonexistent&#13;
    function _validDelegation(Delegation d) internal pure returns(bool) {&#13;
        // probs simplest test to check if we have a valid delegation - important to check if delegation is set to 0x00&#13;
        // to avoid counting a revocation (which is done by delegating to 0x00)&#13;
        return d.setAtBlock &gt; 0 &amp;&amp; d.delegatee != address(0);&#13;
    }&#13;
&#13;
    function _appendMemArray(address[] memory arr, address toAppend) internal pure returns(address[] memory arr2) {&#13;
        arr2 = new address[](arr.length + 1);&#13;
&#13;
        for (uint k = 0; k &lt; arr.length; k++) {&#13;
            arr2[k] = arr[k];&#13;
        }&#13;
&#13;
        arr2[arr.length] = toAppend;&#13;
    }&#13;
}&#13;
&#13;
&#13;
&#13;
// Minimal interface for delegation needs&#13;
// ERC Token Standard #20 Interface&#13;
// https://github.com/ethereum/EIPs/issues/20&#13;
contract ERC20Interface {&#13;
    // Get the account balance of another account with address _owner&#13;
    function balanceOf(address _owner) constant public returns (uint256 balance);&#13;
}&#13;
&#13;
&#13;
&#13;
// Include previous contract in this one so we can access the various components. Not all things needed are accessible&#13;
// through functions - e.g. `historicalDelegations` mapping.&#13;
contract SVDelegation {&#13;
&#13;
    address public owner;&#13;
&#13;
    struct Delegation {&#13;
        uint256 thisDelegationId;&#13;
        address dlgt;&#13;
        uint256 setAtBlock;&#13;
        uint256 prevDelegation;&#13;
    }&#13;
&#13;
    mapping (address =&gt; mapping (address =&gt; Delegation)) tokenDlgts;&#13;
    mapping (address =&gt; Delegation) globalDlgts;&#13;
&#13;
    mapping (uint256 =&gt; Delegation) public historicalDelegations;&#13;
    uint256 public totalDelegations = 0;&#13;
&#13;
    event SetGlobalDelegation(address voter, address delegate);&#13;
    event SetTokenDelegation(address voter, address tokenContract, address delegate);&#13;
&#13;
    function SVDelegation() public {&#13;
        owner = msg.sender;&#13;
&#13;
        // commit the genesis historical delegation to history (like genesis block)&#13;
        createDelegation(address(0), 0);&#13;
    }&#13;
&#13;
    function createDelegation(address dlgtAddress, uint256 prevDelegationId) internal returns(Delegation) {&#13;
        uint256 myDelegationId = totalDelegations;&#13;
        historicalDelegations[myDelegationId] = Delegation(myDelegationId, dlgtAddress, block.number, prevDelegationId);&#13;
        totalDelegations += 1;&#13;
&#13;
        return historicalDelegations[myDelegationId];&#13;
    }&#13;
&#13;
    // get previous delegation, create new delegation via function and then commit to globalDlgts&#13;
    function setGlobalDelegation(address dlgtAddress) public {&#13;
        uint256 prevDelegationId = globalDlgts[msg.sender].thisDelegationId;&#13;
        globalDlgts[msg.sender] = createDelegation(dlgtAddress, prevDelegationId);&#13;
        SetGlobalDelegation(msg.sender, dlgtAddress);&#13;
    }&#13;
&#13;
    // get previous delegation, create new delegation via function and then commit to tokenDlgts&#13;
    function setTokenDelegation(address tokenContract, address dlgtAddress) public {&#13;
        uint256 prevDelegationId = tokenDlgts[tokenContract][msg.sender].thisDelegationId;&#13;
        tokenDlgts[tokenContract][msg.sender] = createDelegation(dlgtAddress, prevDelegationId);&#13;
        SetTokenDelegation(msg.sender, tokenContract, dlgtAddress);&#13;
    }&#13;
&#13;
    function resolveDelegation(address voter, address tokenContract) public constant returns(uint256, address, uint256, uint256) {&#13;
        Delegation memory _tokenDlgt = tokenDlgts[tokenContract][voter];&#13;
&#13;
        // probs simplest test to check if we have a valid delegation&#13;
        if (_tokenDlgt.setAtBlock &gt; 0) {&#13;
            return _dlgtRet(_tokenDlgt);&#13;
        } else {&#13;
            return _dlgtRet(globalDlgts[voter]);&#13;
        }&#13;
    }&#13;
&#13;
    function _rawGetGlobalDelegation(address _voter) public constant returns(uint256, address, uint256, uint256) {&#13;
        return _dlgtRet(globalDlgts[_voter]);&#13;
    }&#13;
&#13;
    function _rawGetTokenDelegation(address _voter, address _tokenContract) public constant returns(uint256, address, uint256, uint256) {&#13;
        return _dlgtRet(tokenDlgts[_tokenContract][_voter]);&#13;
    }&#13;
&#13;
    function _dlgtRet(Delegation d) internal pure returns(uint256, address, uint256, uint256) {&#13;
        return (d.thisDelegationId, d.dlgt, d.setAtBlock, d.prevDelegation);&#13;
    }&#13;
}