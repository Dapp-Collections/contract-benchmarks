pragma solidity ^0.4.22;
/*
 * The MIT License (MIT)
 *
 * Copyright (c) 2018 Hexlant, Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 *
 *
 * Open Source License Announcement
 * This smart contract code contains copyrighted source code under MIT License.
 *  - Copyright (c) 2016 Smart Contract Solutions, Inc.
 *    https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/LICENSE
 *
 * 
 * Contact Us : <span class="__cf_email__" data-cfemail="6a0905041e0b091e2a020f12060b041e44090507">[emailÂ protected]</span>&#13;
 * Website    : http://hexlant.com&#13;
 * Medium Blog: https://medium.com/hexlant&#13;
 */&#13;
&#13;
library SafeMath {&#13;
&#13;
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
        if (a == 0) {&#13;
            return 0;&#13;
        }&#13;
        uint256 c = a * b;&#13;
        assert(c / a == b);&#13;
        return c;&#13;
    }&#13;
&#13;
    function div(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
        // assert(b &gt; 0); // Solidity automatically throws when dividing by 0&#13;
        uint256 c = a / b;&#13;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold&#13;
        return c;       &#13;
    }       &#13;
&#13;
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
        assert(b &lt;= a);&#13;
        return a - b;&#13;
    }&#13;
&#13;
    function add(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
        uint256 c = a + b;&#13;
        assert(c &gt;= a);&#13;
        return c;&#13;
    }&#13;
}&#13;
&#13;
&#13;
contract Ownable {&#13;
    address public owner;&#13;
    address public newOwner;&#13;
&#13;
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);&#13;
&#13;
    constructor() public {&#13;
        owner = msg.sender;&#13;
        newOwner = address(0);&#13;
    }&#13;
&#13;
    modifier onlyOwner() {&#13;
        require(msg.sender == owner);&#13;
        _;&#13;
    }&#13;
    modifier onlyNewOwner() {&#13;
        require(msg.sender != address(0));&#13;
        require(msg.sender == newOwner);&#13;
        _;&#13;
    }&#13;
&#13;
    function transferOwnership(address _newOwner) public onlyOwner {&#13;
        require(_newOwner != address(0));&#13;
        newOwner = _newOwner;&#13;
    }&#13;
&#13;
    function acceptOwnership() public onlyNewOwner returns(bool) {&#13;
        emit OwnershipTransferred(owner, newOwner);        &#13;
        owner = newOwner;&#13;
        newOwner = 0x0;&#13;
    }&#13;
}&#13;
&#13;
contract Pausable is Ownable {&#13;
    event Pause();&#13;
    event Unpause();&#13;
&#13;
    bool public paused = false;&#13;
&#13;
    modifier whenNotPaused() {&#13;
        require(!paused);&#13;
        _;&#13;
    }&#13;
&#13;
    modifier whenPaused() {&#13;
        require(paused);&#13;
        _;&#13;
    }&#13;
&#13;
    function pause() onlyOwner whenNotPaused public {&#13;
        paused = true;&#13;
        emit Pause();&#13;
    }&#13;
&#13;
    function unpause() onlyOwner whenPaused public {&#13;
        paused = false;&#13;
        emit Unpause();&#13;
    }&#13;
}&#13;
&#13;
contract ERC20 {&#13;
    function totalSupply() public view returns (uint256);&#13;
    function balanceOf(address who) public view returns (uint256);&#13;
    function allowance(address owner, address spender) public view returns (uint256);&#13;
    function transfer(address to, uint256 value) public returns (bool);&#13;
    function transferFrom(address from, address to, uint256 value) public returns (bool);&#13;
    function approve(address spender, uint256 value) public returns (bool);&#13;
&#13;
    event Approval(address indexed owner, address indexed spender, uint256 value);&#13;
    event Transfer(address indexed from, address indexed to, uint256 value);&#13;
}&#13;
&#13;
&#13;
interface TokenRecipient {&#13;
    function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; &#13;
}&#13;
&#13;
&#13;
contract SyncoToken is ERC20, Ownable, Pausable {&#13;
&#13;
    using SafeMath for uint256;&#13;
&#13;
    struct LockupInfo {&#13;
        uint256 releaseTime;&#13;
        uint256 termOfRound;&#13;
        uint256 unlockAmountPerRound;        &#13;
        uint256 lockupBalance;&#13;
    }&#13;
&#13;
    string public name;&#13;
    string public symbol;&#13;
    uint8 constant public decimals =18;&#13;
    uint256 internal initialSupply;&#13;
    uint256 internal totalSupply_;&#13;
&#13;
    mapping(address =&gt; uint256) internal balances;&#13;
    mapping(address =&gt; bool) internal locks;&#13;
    mapping(address =&gt; bool) public frozen;&#13;
    mapping(address =&gt; mapping(address =&gt; uint256)) internal allowed;&#13;
    mapping(address =&gt; LockupInfo[]) internal lockupInfo;&#13;
&#13;
    event Lock(address indexed holder, uint256 value);&#13;
    event Unlock(address indexed holder, uint256 value);&#13;
    event Burn(address indexed owner, uint256 value);&#13;
    event Mint(uint256 value);&#13;
    event Freeze(address indexed holder);&#13;
    event Unfreeze(address indexed holder);&#13;
&#13;
    modifier notFrozen(address _holder) {&#13;
        require(!frozen[_holder]);&#13;
        _;&#13;
    }&#13;
&#13;
    constructor() public {&#13;
        name = "SYNCO Token";&#13;
        symbol = "SYNCO";&#13;
        initialSupply = 13000000000;&#13;
        totalSupply_ = initialSupply * 10 ** uint(decimals);&#13;
        balances[owner] = totalSupply_;&#13;
        emit Transfer(address(0), owner, totalSupply_);&#13;
    }&#13;
&#13;
    function () public payable {&#13;
        revert();&#13;
    }&#13;
&#13;
    function totalSupply() public view returns (uint256) {&#13;
        return totalSupply_;&#13;
    }&#13;
&#13;
    function transfer(address _to, uint256 _value) public whenNotPaused notFrozen(msg.sender) returns (bool) {&#13;
        if (locks[msg.sender]) {&#13;
            autoUnlock(msg.sender);            &#13;
        }&#13;
        require(_to != address(0));&#13;
        require(_value &lt;= balances[msg.sender]);&#13;
        &#13;
&#13;
        // SafeMath.sub will throw if there is not enough balance.&#13;
        balances[msg.sender] = balances[msg.sender].sub(_value);&#13;
        balances[_to] = balances[_to].add(_value);&#13;
        emit Transfer(msg.sender, _to, _value);&#13;
        return true;&#13;
    }&#13;
&#13;
    function balanceOf(address _holder) public view returns (uint256 balance) {&#13;
        uint256 lockedBalance = 0;&#13;
        if(locks[_holder]) {&#13;
            for(uint256 idx = 0; idx &lt; lockupInfo[_holder].length ; idx++ ) {&#13;
                lockedBalance = lockedBalance.add(lockupInfo[_holder][idx].lockupBalance);&#13;
            }&#13;
        }&#13;
        return balances[_holder] + lockedBalance;&#13;
    }&#13;
&#13;
    function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused notFrozen(_from)returns (bool) {&#13;
        if (locks[_from]) {&#13;
            autoUnlock(_from);            &#13;
        }&#13;
        require(_to != address(0));&#13;
        require(_value &lt;= balances[_from]);&#13;
        require(_value &lt;= allowed[_from][msg.sender]);&#13;
        &#13;
&#13;
        balances[_from] = balances[_from].sub(_value);&#13;
        balances[_to] = balances[_to].add(_value);&#13;
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);&#13;
        emit Transfer(_from, _to, _value);&#13;
        return true;&#13;
    }&#13;
&#13;
    function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) {&#13;
        allowed[msg.sender][_spender] = _value;&#13;
        emit Approval(msg.sender, _spender, _value);&#13;
        return true;&#13;
    }&#13;
    &#13;
    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {&#13;
        require(isContract(_spender));&#13;
        TokenRecipient spender = TokenRecipient(_spender);&#13;
        if (approve(_spender, _value)) {&#13;
            spender.receiveApproval(msg.sender, _value, this, _extraData);&#13;
            return true;&#13;
        }&#13;
    }&#13;
&#13;
    function allowance(address _holder, address _spender) public view returns (uint256) {&#13;
        return allowed[_holder][_spender];&#13;
    }&#13;
&#13;
    function lock(address _holder, uint256 _amount, uint256 _releaseStart, uint256 _termOfRound, uint256 _releaseRate) public onlyOwner returns (bool) {&#13;
        require(balances[_holder] &gt;= _amount);&#13;
        if(_termOfRound==0 ) {&#13;
            _termOfRound = 1;&#13;
        }&#13;
        balances[_holder] = balances[_holder].sub(_amount);&#13;
        lockupInfo[_holder].push(&#13;
            LockupInfo(_releaseStart, _termOfRound, _amount.div(100).mul(_releaseRate), _amount)&#13;
        );&#13;
&#13;
        locks[_holder] = true;&#13;
&#13;
        emit Lock(_holder, _amount);&#13;
&#13;
        return true;&#13;
    }&#13;
&#13;
    function unlock(address _holder, uint256 _idx) public onlyOwner returns (bool) {&#13;
        require(locks[_holder]);&#13;
        require(_idx &lt; lockupInfo[_holder].length);&#13;
        LockupInfo storage lockupinfo = lockupInfo[_holder][_idx];&#13;
        uint256 releaseAmount = lockupinfo.lockupBalance;&#13;
&#13;
        delete lockupInfo[_holder][_idx];&#13;
        lockupInfo[_holder][_idx] = lockupInfo[_holder][lockupInfo[_holder].length.sub(1)];&#13;
        lockupInfo[_holder].length -=1;&#13;
        if(lockupInfo[_holder].length == 0) {&#13;
            locks[_holder] = false;&#13;
        }&#13;
&#13;
        emit Unlock(_holder, releaseAmount);&#13;
        balances[_holder] = balances[_holder].add(releaseAmount);&#13;
&#13;
        return true;&#13;
    }&#13;
&#13;
    function freezeAccount(address _holder) public onlyOwner returns (bool) {&#13;
        require(!frozen[_holder]);&#13;
        frozen[_holder] = true;&#13;
        emit Freeze(_holder);&#13;
        return true;&#13;
    }&#13;
&#13;
    function unfreezeAccount(address _holder) public onlyOwner returns (bool) {&#13;
        require(frozen[_holder]);&#13;
        frozen[_holder] = false;&#13;
        emit Unfreeze(_holder);&#13;
        return true;&#13;
    }&#13;
&#13;
    function getNowTime() public view returns(uint256) {&#13;
        return now;&#13;
    }&#13;
&#13;
    function showLockState(address _holder, uint256 _idx) public view returns (bool, uint256, uint256, uint256, uint256, uint256) {&#13;
        if(locks[_holder]) {&#13;
            return (&#13;
                locks[_holder], &#13;
                lockupInfo[_holder].length, &#13;
                lockupInfo[_holder][_idx].lockupBalance, &#13;
                lockupInfo[_holder][_idx].releaseTime, &#13;
                lockupInfo[_holder][_idx].termOfRound, &#13;
                lockupInfo[_holder][_idx].unlockAmountPerRound&#13;
            );&#13;
        } else {&#13;
            return (&#13;
                locks[_holder], &#13;
                lockupInfo[_holder].length, &#13;
                0,0,0,0&#13;
            );&#13;
&#13;
        }        &#13;
    }&#13;
    &#13;
    function distribute(address _to, uint256 _value) public onlyOwner returns (bool) {&#13;
        require(_to != address(0));&#13;
        require(_value &lt;= balances[owner]);&#13;
&#13;
        balances[owner] = balances[owner].sub(_value);&#13;
        balances[_to] = balances[_to].add(_value);&#13;
        emit Transfer(owner, _to, _value);&#13;
        return true;&#13;
    }&#13;
&#13;
    function distributeWithLockup(address _to, uint256 _value, uint256 _releaseStart, uint256 _termOfRound, uint256 _releaseRate) public onlyOwner returns (bool) {&#13;
        distribute(_to, _value);&#13;
        lock(_to, _value, _releaseStart, _termOfRound, _releaseRate);&#13;
        return true;&#13;
    }&#13;
&#13;
    function claimToken(ERC20 token, address _to, uint256 _value) public onlyOwner returns (bool) {&#13;
        token.transfer(_to, _value);&#13;
        return true;&#13;
    }&#13;
&#13;
    function burn(uint256 _value) public onlyOwner returns (bool success) {&#13;
        require(_value &lt;= balances[msg.sender]);&#13;
        address burner = msg.sender;&#13;
        balances[burner] = balances[burner].sub(_value);&#13;
        totalSupply_ = totalSupply_.sub(_value);&#13;
        emit Burn(burner, _value);&#13;
        return true;&#13;
    }&#13;
&#13;
    function mint(address _to, uint256 _amount) onlyOwner public returns (bool) {&#13;
        totalSupply_ = totalSupply_.add(_amount);&#13;
        balances[_to] = balances[_to].add(_amount);&#13;
&#13;
        emit Transfer(address(0), _to, _amount);&#13;
        return true;&#13;
    }&#13;
&#13;
    function isContract(address addr) internal view returns (bool) {&#13;
        uint size;&#13;
        assembly{size := extcodesize(addr)}&#13;
        return size &gt; 0;&#13;
    }&#13;
&#13;
    function autoUnlock(address _holder) internal returns (bool) {&#13;
&#13;
        for(uint256 idx =0; idx &lt; lockupInfo[_holder].length ; idx++ ) {&#13;
            if(locks[_holder]==false) {&#13;
                return true;&#13;
            }&#13;
            if (lockupInfo[_holder][idx].releaseTime &lt;= now) {&#13;
                // If lockupinfo was deleted, loop restart at same position.&#13;
                if( releaseTimeLock(_holder, idx) ) {&#13;
                    idx -=1;&#13;
                }&#13;
            }&#13;
        }&#13;
        return true;&#13;
    }&#13;
&#13;
    function releaseTimeLock(address _holder, uint256 _idx) internal returns(bool) {&#13;
        require(locks[_holder]);&#13;
        require(_idx &lt; lockupInfo[_holder].length);&#13;
&#13;
        // If lock status of holder is finished, delete lockup info. &#13;
        LockupInfo storage info = lockupInfo[_holder][_idx];&#13;
        uint256 releaseAmount = info.unlockAmountPerRound;&#13;
        uint256 sinceFrom = now.sub(info.releaseTime);&#13;
        uint256 sinceRound = sinceFrom.div(info.termOfRound);&#13;
        releaseAmount = releaseAmount.add( sinceRound.mul(info.unlockAmountPerRound) );&#13;
&#13;
        if(releaseAmount &gt;= info.lockupBalance) {            &#13;
            releaseAmount = info.lockupBalance;&#13;
&#13;
            delete lockupInfo[_holder][_idx];&#13;
            lockupInfo[_holder][_idx] = lockupInfo[_holder][lockupInfo[_holder].length.sub(1)];&#13;
            lockupInfo[_holder].length -=1;&#13;
&#13;
            if(lockupInfo[_holder].length == 0) {&#13;
                locks[_holder] = false;&#13;
            }&#13;
            emit Unlock(_holder, releaseAmount);&#13;
            balances[_holder] = balances[_holder].add(releaseAmount);&#13;
            return true;&#13;
        } else {&#13;
            lockupInfo[_holder][_idx].releaseTime = lockupInfo[_holder][_idx].releaseTime.add( sinceRound.add(1).mul(info.termOfRound) );&#13;
            lockupInfo[_holder][_idx].lockupBalance = lockupInfo[_holder][_idx].lockupBalance.sub(releaseAmount);&#13;
            emit Unlock(_holder, releaseAmount);&#13;
            balances[_holder] = balances[_holder].add(releaseAmount);&#13;
            return false;&#13;
        }&#13;
    }&#13;
&#13;
&#13;
}