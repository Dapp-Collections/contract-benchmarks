/* This source code is part of CACIB DocChain registered trademark
*  It is provided becaused published in the public blockchain of Ethereum.
*  Reusing this code is forbidden without approbation of CACIB first (<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="59303d3c38193a38743a303b773a3634">[emailÂ protected]</a>)&#13;
*  Providing this code in public repository is meant to provide clarity to the mechanism by which the DocChain product works&#13;
*/&#13;
pragma solidity ^0.4.11;&#13;
&#13;
/**&#13;
 * The IEthIdentity interface defines fundamental functionnalities&#13;
 * that every Ethereum identity in this framework must implement to be &#13;
 * usable with DocChain principles.&#13;
 * &#13;
 * The purpose of implementing IEthIdentity interface is to prove its own identity&#13;
 * and let others checking whether any proof has been made by its identity.&#13;
 */&#13;
interface IEthIdentity {&#13;
    &#13;
    /**&#13;
     * Add proof if it does not exist yet&#13;
     *  - address: the smart contract address where the identity proof has been stored (see eSignature contract)&#13;
     *  - bytes32: the attribute id or proof id for which the identity owner has made a proof&#13;
     */&#13;
    function addProof(address, bytes32) public returns(bool);&#13;
    &#13;
    /**&#13;
     * Remove proof of a source if existed&#13;
     *  - address: the smart contract address where the identity proof has been stored (see eSignature contract)&#13;
     *  - bytes32: the attribute id or proof id to be removed&#13;
     */&#13;
    function removeProof(address, bytes32) public returns(bool);&#13;
&#13;
    /**&#13;
     * Check whether the provided address is the controlling wallet (owner) of the identity&#13;
     */&#13;
    function checkOwner(address) public constant returns(bool);&#13;
    &#13;
    /**&#13;
     * Get the identity owner name&#13;
     */&#13;
    function getIdentityName() public constant returns(bytes32);&#13;
    &#13;
}&#13;
&#13;
/**&#13;
 * The implementation of IEthIdentity interface.&#13;
 * &#13;
 * This is just an implementation of IEthIdentity interface, other implementation&#13;
 * may be different. However, the fundamental functionnalities defined in IEthIdentity&#13;
 * interface must be fully implemented to be compatible with the framework.&#13;
 */&#13;
contract EthIdentity is IEthIdentity {&#13;
    &#13;
    /**&#13;
     * The EthIdentity contract is a prudent identity proof of its owner&#13;
     * When contract is created, it assigns the sender of creating contract&#13;
     * transaction as its owner. &#13;
     * The contract owner can only be changed by the override owner.&#13;
     * The override owner can only be changed by the override owner.&#13;
     * Although set as private but they can always be read via the getStorageAt. It saves bytecode in the final structure&#13;
     */&#13;
    address public owner;&#13;
    address private override;&#13;
    &#13;
    /**&#13;
     * The identity name is a string for human readability and visibility&#13;
     * but is stored as 32 bytes in order to be used between contract calls.&#13;
     */&#13;
    bytes32 private identityName;&#13;
    &#13;
    /**&#13;
     * Constructor of EthIdentity contract&#13;
     * Only execute once.&#13;
     * receives the Name of the identity&#13;
     */&#13;
    function EthIdentity(bytes32 _name) public {&#13;
        owner = msg.sender;&#13;
        override = msg.sender;&#13;
        identityName = _name;&#13;
    }&#13;
    &#13;
    /**&#13;
     * Constants for event type &amp; notifications&#13;
     */&#13;
    uint constant ERROR_EVENT = 119;&#13;
    uint constant INFO_EVENT = 115;&#13;
    &#13;
    /**&#13;
     * This event is used for change notification and outputs the following:&#13;
     * - event sender (indexed for filter)&#13;
     * - event status (indexed for filter)&#13;
     * - event message&#13;
     */&#13;
    event EventNotification(address indexed sender, uint indexed status, bytes32 message);&#13;
    &#13;
    /**&#13;
     * The list of proofs stored by this identity owner&#13;
     * The identity owner can store several proofs for a particular source, hence&#13;
     * is defined as a mapping list that use the proof value (attribute) as key&#13;
     * Hence the attribute value must be unique accross all sources.&#13;
     * &#13;
     * For the eSignature contract, the proof is defined as the document id&#13;
     * generated by this contract when the document hash is added/signed by an identity owner.&#13;
     * For a wider use, it can be any attribute that is stored by this identity owner, but must be a bytes32 for optimisation.&#13;
     */&#13;
    mapping(bytes32 =&gt; address) proofList;&#13;
    &#13;
    /**&#13;
     * Add a proof ONLY if not already present and ONLY by the identity owner&#13;
     * &#13;
     * _source: address of the source (e.g. eSignature contract) where the proof has been stored&#13;
     * _attribute: a bytes32 representing the attribute at the source identifying the proof&#13;
     * &#13;
     * For eSignature case, _attribute is the document id generated when the identity adds/signs the document&#13;
     */&#13;
    function addProof(address _source, bytes32 _attribute) public onlyBy(owner) returns(bool) {&#13;
        // Check input&#13;
        require(_source != address(0x0));&#13;
        &#13;
        // Check proof existence&#13;
        bool existed = checkProof(_attribute);&#13;
        &#13;
        // Returns and do nothing except emitting event if the proof already exists&#13;
        if (existed == true) {&#13;
            EventNotification(msg.sender, ERROR_EVENT, "Proof already exist");&#13;
            return false;&#13;
        }&#13;
        &#13;
        // Add new proof&#13;
        proofList[_attribute] = _source;&#13;
        &#13;
        EventNotification(msg.sender, INFO_EVENT, "New proof added");&#13;
        return true;&#13;
    }&#13;
    &#13;
    /**&#13;
     * Remove proof of a source ONLY if present and ONLY by the identity owner&#13;
     * &#13;
     * _source: address of the source (e.g. eSignature contract) where the proof has been stored&#13;
     * _attribute: a bytes32 representing the attribute at the source identifying the proof&#13;
     * &#13;
     * For eSignature case, _attribute is the document id generated when the identity adds/signs the document&#13;
     */&#13;
    function removeProof(address _source, bytes32 _attribute) public onlyBy(owner) returns(bool) {&#13;
        // Check proof existence&#13;
        bool existed = checkProof(_attribute);&#13;
        &#13;
        // Return and do nothing except emitting event if the proof does not exist&#13;
        if (existed == false) {&#13;
            EventNotification(msg.sender, ERROR_EVENT, "Proof not found");&#13;
            return false;&#13;
        }&#13;
        &#13;
        // Return and do nothing except emitting event if the source is not correct&#13;
        if (proofList[_attribute] != _source) {&#13;
            EventNotification(msg.sender, ERROR_EVENT, "Incorrect source");&#13;
            return false;&#13;
        }&#13;
        &#13;
        // Delete existing proof&#13;
        delete proofList[_attribute];&#13;
        &#13;
        EventNotification(msg.sender, INFO_EVENT, "Proof removed");&#13;
        return true;&#13;
    }&#13;
    &#13;
    /**&#13;
     * Check whether the identity owner has stored a proof with a  source&#13;
     * Return true if proof is found&#13;
     * &#13;
     * _attribute: a string representing the attribute of the source for which the proof has been made&#13;
     * &#13;
     * For eSignature case, _attribute is the document id generated when the identity create/sign the document&#13;
     */&#13;
    function checkProof(bytes32 _attribute) public constant returns(bool) {&#13;
        var source = proofList[_attribute];&#13;
        // Check if proof source is assigned &amp; matched&#13;
        if (source != address(0x0))&#13;
            return true;&#13;
        // Proof not exists since its source is not matched    &#13;
        return false;&#13;
    }&#13;
    &#13;
    /**&#13;
     * Check whether the provided address is the controlling wallet of the identity&#13;
     * Return true if yes&#13;
     */&#13;
    function checkOwner(address _check) public constant returns(bool) {&#13;
        return _check == owner;&#13;
    }&#13;
    &#13;
    /**&#13;
     * Get the identity owner name, usable inside contract call&#13;
     */&#13;
    function getIdentityName() public constant returns(bytes32) {&#13;
        return identityName;&#13;
    }&#13;
    &#13;
    /**&#13;
     * Show the name of the identity in string &#13;
     * (for Etherscan read-only function)&#13;
     */&#13;
    function nameOfIdentity() public constant returns(string) {&#13;
        return bytes32ToString(identityName);&#13;
    }&#13;
    &#13;
    /**&#13;
     * Get the identity detail information&#13;
     */&#13;
    function getIdentityInfo() public constant returns(address, address, string) {&#13;
        return (override, owner, bytes32ToString(identityName));&#13;
    }&#13;
    &#13;
     /**&#13;
     * Only the identity owner can set its name&#13;
     */&#13;
    function setIdentityName(bytes32 _newName) public onlyBy(owner) returns(bool) {&#13;
        identityName = _newName;&#13;
        EventNotification(msg.sender, INFO_EVENT, "Set owner name");&#13;
        return true;&#13;
    }&#13;
    &#13;
    /**&#13;
     * Only the override address is allowed to change the owner address.&#13;
     */&#13;
    function setOwner(address _newOwner) public onlyBy(override) returns(bool) {&#13;
        owner = _newOwner;&#13;
        EventNotification(msg.sender, INFO_EVENT, "Set new owner");&#13;
        return true;&#13;
    }&#13;
&#13;
    /**&#13;
     * Only the override address is allowed to change the override address.&#13;
     */&#13;
    function setOverride(address _newOverride) public onlyBy(override) returns(bool) {&#13;
        override = _newOverride;&#13;
        EventNotification(msg.sender, INFO_EVENT, "Set new override");&#13;
        return true;&#13;
    }&#13;
    &#13;
    /**&#13;
     * Convert bytes32 to string. Set modifier pure which means cannot&#13;
     * access the contract storage.&#13;
     */&#13;
    function bytes32ToString(bytes32 data) internal pure returns (string) {&#13;
        bytes memory bytesString = new bytes(32);&#13;
        for (uint j=0; j&lt;32; j++){&#13;
            if (data[j] != 0) {&#13;
                bytesString[j] = data[j];&#13;
            }&#13;
        }&#13;
        return string(bytesString);&#13;
    }&#13;
    &#13;
    /**&#13;
     * Modifier to make a constraint on who is permitted&#13;
     * to execute a function&#13;
     */&#13;
    modifier onlyBy(address _authorized) {&#13;
        assert(msg.sender == _authorized);&#13;
        _;&#13;
    }&#13;
}