// []Fuction Double ETH
// []=> Send 1 Ether to this Contract address and you will get 2 Ether from balance
// []=> SEND 1 ETHER TO 0x9cfed76501ac8cf181a9d9fead5af25e2c901959
// [Balance]=> 0x0000000000000000000000000000000000000000

// *Listing coinmarketcap & coingecko if the address contract storage reaches 5 ether*

// Send 0 ETH to this contract address 
// you will get a free MobileAppCoin
// every wallet address can only claim 1x
// Balance MobileAppCoin => 0x0000000000000000000000000000000000000000

// MobileAppCoin
// website: http://mobileapp.tours
// Twitter: https://twitter.com/mobileappcoin
// contact: <span class="__cf_email__" data-cfemail="92e1e7e2e2fde0e6d2fffdf0fbfef7f3e2e2bce6fde7e0e1">[emailÂ protected]</span>&#13;
// Telegram: https://t.me/mobileapptours&#13;
// Linkedin: https://www.linkedin.com/in/mobile-app-285211163/&#13;
// Medium: https://medium.com/@mobileappcoin&#13;
// Comingsoon : https://coinmarketcap.com/currencies/MAC/&#13;
//              https://www.coingecko.com/en/coins/MAC/            &#13;
&#13;
&#13;
// SEND 1 GWEI TO THIS ADDRESS AND SET GAS LIMIT 100,000 FOR GET BITRON&#13;
&#13;
// MORE FREE COIN AND TOKEN https://goo.gl/forms/Mclc69Zc2WFXKEby1&#13;
&#13;
// Token creation service, the cost of 1 ether already includes verification&#13;
// contact : https://www.instagram.com/haritssulaiman/?hl=en&#13;
// Join Channel: t.me/coinmarketcapinfo&#13;
&#13;
pragma solidity ^0.4.19;&#13;
&#13;
// ZeroXEth the Uprising Token powered by giants&#13;
// Token name: ZeroXEth&#13;
// Symbol: 0XETH&#13;
// Decimals: 8&#13;
// Telegram channel: https://t.me/oxeth&#13;
&#13;
&#13;
library SafeMath {&#13;
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
    uint256 c = a * b;&#13;
    assert(a == 0 || c / a == b);&#13;
    return c;&#13;
  }&#13;
&#13;
  function div(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
    uint256 c = a / b;&#13;
    return c;&#13;
  }&#13;
&#13;
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
    assert(b &lt;= a);&#13;
    return a - b;&#13;
  }&#13;
&#13;
  function add(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
    uint256 c = a + b;&#13;
    assert(c &gt;= a);&#13;
    return c;&#13;
  }&#13;
}&#13;
&#13;
contract ForeignToken {&#13;
    function balanceOf(address _owner) constant public returns (uint256);&#13;
    function transfer(address _to, uint256 _value) public returns (bool);&#13;
}&#13;
&#13;
contract ERC20Basic {&#13;
    uint256 public totalSupply;&#13;
    function balanceOf(address who) public constant returns (uint256);&#13;
    function transfer(address to, uint256 value) public returns (bool);&#13;
    event Transfer(address indexed from, address indexed to, uint256 value);&#13;
}&#13;
&#13;
contract ERC20 is ERC20Basic {&#13;
    function allowance(address owner, address spender) public constant returns (uint256);&#13;
    function transferFrom(address from, address to, uint256 value) public returns (bool);&#13;
    function approve(address spender, uint256 value) public returns (bool);&#13;
    event Approval(address indexed owner, address indexed spender, uint256 value);&#13;
}&#13;
&#13;
interface Token { &#13;
    function distr(address _to, uint256 _value) public returns (bool);&#13;
    function totalSupply() constant public returns (uint256 supply);&#13;
    function balanceOf(address _owner) constant public returns (uint256 balance);&#13;
}&#13;
&#13;
contract MAC is ERC20 {&#13;
    &#13;
    using SafeMath for uint256;&#13;
    address owner = msg.sender;&#13;
&#13;
    mapping (address =&gt; uint256) balances;&#13;
    mapping (address =&gt; mapping (address =&gt; uint256)) allowed;&#13;
    mapping (address =&gt; bool) public blacklist;&#13;
&#13;
    string public constant name = "MobileAppCoin";&#13;
    string public constant symbol = "MAC";&#13;
    uint public constant decimals = 8;&#13;
    &#13;
    uint256 public totalSupply = 1000000000e8;&#13;
    uint256 public totalDistributed = 100000000e8;&#13;
    uint256 public totalRemaining = totalSupply.sub(totalDistributed);&#13;
    uint256 public value;&#13;
&#13;
    event Transfer(address indexed _from, address indexed _to, uint256 _value);&#13;
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);&#13;
    &#13;
    event Distr(address indexed to, uint256 amount);&#13;
    event DistrFinished();&#13;
    &#13;
    event Burn(address indexed burner, uint256 value);&#13;
&#13;
    bool public distributionFinished = false;&#13;
    &#13;
    modifier canDistr() {&#13;
        require(!distributionFinished);&#13;
        _;&#13;
    }&#13;
    &#13;
    modifier onlyOwner() {&#13;
        require(msg.sender == owner);&#13;
        _;&#13;
    }&#13;
    &#13;
    modifier onlyWhitelist() {&#13;
        require(blacklist[msg.sender] == false);&#13;
        _;&#13;
    }&#13;
    &#13;
    function MAC () public {&#13;
        owner = msg.sender;&#13;
        value = 4000e8;&#13;
        distr(owner, totalDistributed);&#13;
    }&#13;
    &#13;
    function transferOwnership(address newOwner) onlyOwner public {&#13;
        if (newOwner != address(0)) {&#13;
            owner = newOwner;&#13;
        }&#13;
    }&#13;
    &#13;
    function enableWhitelist(address[] addresses) onlyOwner public {&#13;
        for (uint i = 0; i &lt; addresses.length; i++) {&#13;
            blacklist[addresses[i]] = false;&#13;
        }&#13;
    }&#13;
&#13;
    function disableWhitelist(address[] addresses) onlyOwner public {&#13;
        for (uint i = 0; i &lt; addresses.length; i++) {&#13;
            blacklist[addresses[i]] = true;&#13;
        }&#13;
    }&#13;
&#13;
    function finishDistribution() onlyOwner canDistr public returns (bool) {&#13;
        distributionFinished = true;&#13;
        DistrFinished();&#13;
        return true;&#13;
    }&#13;
    &#13;
    function distr(address _to, uint256 _amount) canDistr private returns (bool) {&#13;
        totalDistributed = totalDistributed.add(_amount);&#13;
        totalRemaining = totalRemaining.sub(_amount);&#13;
        balances[_to] = balances[_to].add(_amount);&#13;
        Distr(_to, _amount);&#13;
        Transfer(address(0), _to, _amount);&#13;
        return true;&#13;
        &#13;
        if (totalDistributed &gt;= totalSupply) {&#13;
            distributionFinished = true;&#13;
        }&#13;
    }&#13;
    &#13;
    function airdrop(address[] addresses) onlyOwner canDistr public {&#13;
        &#13;
        require(addresses.length &lt;= 255);&#13;
        require(value &lt;= totalRemaining);&#13;
        &#13;
        for (uint i = 0; i &lt; addresses.length; i++) {&#13;
            require(value &lt;= totalRemaining);&#13;
            distr(addresses[i], value);&#13;
        }&#13;
	&#13;
        if (totalDistributed &gt;= totalSupply) {&#13;
            distributionFinished = true;&#13;
        }&#13;
    }&#13;
    &#13;
    function distribution(address[] addresses, uint256 amount) onlyOwner canDistr public {&#13;
        &#13;
        require(addresses.length &lt;= 255);&#13;
        require(amount &lt;= totalRemaining);&#13;
        &#13;
        for (uint i = 0; i &lt; addresses.length; i++) {&#13;
            require(amount &lt;= totalRemaining);&#13;
            distr(addresses[i], amount);&#13;
        }&#13;
	&#13;
        if (totalDistributed &gt;= totalSupply) {&#13;
            distributionFinished = true;&#13;
        }&#13;
    }&#13;
    &#13;
    function distributeAmounts(address[] addresses, uint256[] amounts) onlyOwner canDistr public {&#13;
&#13;
        require(addresses.length &lt;= 255);&#13;
        require(addresses.length == amounts.length);&#13;
        &#13;
        for (uint8 i = 0; i &lt; addresses.length; i++) {&#13;
            require(amounts[i] &lt;= totalRemaining);&#13;
            distr(addresses[i], amounts[i]);&#13;
            &#13;
            if (totalDistributed &gt;= totalSupply) {&#13;
                distributionFinished = true;&#13;
            }&#13;
        }&#13;
    }&#13;
    &#13;
    function () external payable {&#13;
            getTokens();&#13;
     }&#13;
    &#13;
    function getTokens() payable canDistr onlyWhitelist public {&#13;
        &#13;
        if (value &gt; totalRemaining) {&#13;
            value = totalRemaining;&#13;
        }&#13;
        &#13;
        require(value &lt;= totalRemaining);&#13;
        &#13;
        address investor = msg.sender;&#13;
        uint256 toGive = value;&#13;
        &#13;
        distr(investor, toGive);&#13;
        &#13;
        if (toGive &gt; 0) {&#13;
            blacklist[investor] = true;&#13;
        }&#13;
&#13;
        if (totalDistributed &gt;= totalSupply) {&#13;
            distributionFinished = true;&#13;
        }&#13;
        &#13;
        value = value.div(100000).mul(99999);&#13;
    }&#13;
&#13;
    function balanceOf(address _owner) constant public returns (uint256) {&#13;
	    return balances[_owner];&#13;
    }&#13;
&#13;
    // mitigates the ERC20 short address attack&#13;
    modifier onlyPayloadSize(uint size) {&#13;
        assert(msg.data.length &gt;= size + 4);&#13;
        _;&#13;
    }&#13;
    &#13;
    function transfer(address _to, uint256 _amount) onlyPayloadSize(2 * 32) public returns (bool success) {&#13;
&#13;
        require(_to != address(0));&#13;
        require(_amount &lt;= balances[msg.sender]);&#13;
        &#13;
        balances[msg.sender] = balances[msg.sender].sub(_amount);&#13;
        balances[_to] = balances[_to].add(_amount);&#13;
        Transfer(msg.sender, _to, _amount);&#13;
        return true;&#13;
    }&#13;
    &#13;
    function transferFrom(address _from, address _to, uint256 _amount) onlyPayloadSize(3 * 32) public returns (bool success) {&#13;
&#13;
        require(_to != address(0));&#13;
        require(_amount &lt;= balances[_from]);&#13;
        require(_amount &lt;= allowed[_from][msg.sender]);&#13;
        &#13;
        balances[_from] = balances[_from].sub(_amount);&#13;
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);&#13;
        balances[_to] = balances[_to].add(_amount);&#13;
        Transfer(_from, _to, _amount);&#13;
        return true;&#13;
    }&#13;
    &#13;
    function approve(address _spender, uint256 _value) public returns (bool success) {&#13;
        // mitigates the ERC20 spend/approval race condition&#13;
        if (_value != 0 &amp;&amp; allowed[msg.sender][_spender] != 0) { return false; }&#13;
        allowed[msg.sender][_spender] = _value;&#13;
        Approval(msg.sender, _spender, _value);&#13;
        return true;&#13;
    }&#13;
    &#13;
    function allowance(address _owner, address _spender) constant public returns (uint256) {&#13;
        return allowed[_owner][_spender];&#13;
    }&#13;
    &#13;
    function getTokenBalance(address tokenAddress, address who) constant public returns (uint){&#13;
        ForeignToken t = ForeignToken(tokenAddress);&#13;
        uint bal = t.balanceOf(who);&#13;
        return bal;&#13;
    }&#13;
    &#13;
    function withdraw() onlyOwner public {&#13;
        uint256 etherBalance = this.balance;&#13;
        owner.transfer(etherBalance);&#13;
    }&#13;
    &#13;
    function burn(uint256 _value) onlyOwner public {&#13;
        require(_value &lt;= balances[msg.sender]);&#13;
        // no need to require value &lt;= totalSupply, since that would imply the&#13;
        // sender's balance is greater than the totalSupply, which *should* be an assertion failure&#13;
&#13;
        address burner = msg.sender;&#13;
        balances[burner] = balances[burner].sub(_value);&#13;
        totalSupply = totalSupply.sub(_value);&#13;
        totalDistributed = totalDistributed.sub(_value);&#13;
        Burn(burner, _value);&#13;
    }&#13;
    &#13;
    function withdrawForeignTokens(address _tokenContract) onlyOwner public returns (bool) {&#13;
        ForeignToken token = ForeignToken(_tokenContract);&#13;
        uint256 amount = token.balanceOf(address(this));&#13;
        return token.transfer(owner, amount);&#13;
    }&#13;
&#13;
&#13;
}