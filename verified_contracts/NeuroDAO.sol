/*
This file is part of the NeuroDAO Contract.

The NeuroDAO Contract is free software: you can redistribute it and/or
modify it under the terms of the GNU lesser General Public License as published
by the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

The NeuroDAO Contract is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU lesser General Public License for more details.

You should have received a copy of the GNU lesser General Public License
along with the NeuroDAO Contract. If not, see <http://www.gnu.org/licenses/>.

@author Ilya Svirin <<span class="__cf_email__" data-cfemail="7d14530e0b140f14133d13120f191c0b141319530f08">[emailÂ protected]</span>&gt;&#13;
&#13;
IF YOU ARE ENJOYED IT DONATE TO 0x3Ad38D1060d1c350aF29685B2b8Ec3eDE527452B ! :)&#13;
*/&#13;
&#13;
&#13;
pragma solidity ^0.4.0;&#13;
&#13;
contract owned {&#13;
&#13;
    address public owner;&#13;
    address public newOwner;&#13;
&#13;
    function owned() payable {&#13;
        owner = msg.sender;&#13;
    }&#13;
    &#13;
    modifier onlyOwner {&#13;
        require(owner == msg.sender);&#13;
        _;&#13;
    }&#13;
&#13;
    function changeOwner(address _owner) onlyOwner public {&#13;
        require(_owner != 0);&#13;
        newOwner = _owner;&#13;
    }&#13;
    &#13;
    function confirmOwner() public {&#13;
        require(newOwner == msg.sender);&#13;
        owner = newOwner;&#13;
        delete newOwner;&#13;
    }&#13;
}&#13;
&#13;
/**&#13;
 * @title ERC20 interface&#13;
 * @dev see https://github.com/ethereum/EIPs/issues/20&#13;
 */&#13;
contract ERC20 {&#13;
    uint public totalSupply;&#13;
    function balanceOf(address who) constant returns (uint);&#13;
    function transfer(address to, uint value);&#13;
    function allowance(address owner, address spender) constant returns (uint);&#13;
    function transferFrom(address from, address to, uint value);&#13;
    function approve(address spender, uint value);&#13;
    event Approval(address indexed owner, address indexed spender, uint value);&#13;
    event Transfer(address indexed from, address indexed to, uint value);&#13;
}&#13;
&#13;
contract ManualMigration is owned, ERC20 {&#13;
&#13;
    uint    public freezedMoment;&#13;
    address public original;&#13;
&#13;
    modifier enabled {&#13;
        require(original == 0);&#13;
        _;&#13;
    }&#13;
    &#13;
    struct SpecialTokenHolder {&#13;
        uint limit;&#13;
        bool isTeam;&#13;
    }&#13;
    mapping (address =&gt; SpecialTokenHolder) public specials;&#13;
&#13;
    struct TokenHolder {&#13;
        uint balance;&#13;
        uint balanceBeforeUpdate;&#13;
        uint balanceUpdateTime;&#13;
    }&#13;
    mapping (address =&gt; TokenHolder) public holders;&#13;
&#13;
    function ManualMigration(address _original) payable owned() {&#13;
        original = _original;&#13;
        totalSupply = ERC20(original).totalSupply();&#13;
        holders[this].balance = ERC20(original).balanceOf(original);&#13;
        holders[original].balance = totalSupply - holders[this].balance;&#13;
        Transfer(this, original, holders[original].balance);&#13;
    }&#13;
&#13;
    function migrateManual(address _who, bool _isTeam) onlyOwner {&#13;
        require(original != 0);&#13;
        require(holders[_who].balance == 0);&#13;
        uint balance = ERC20(original).balanceOf(_who);&#13;
        holders[_who].balance = balance;&#13;
        specials[_who] = SpecialTokenHolder({limit: balance, isTeam:_isTeam});&#13;
        holders[original].balance -= balance;&#13;
        Transfer(original, _who, balance);&#13;
    }&#13;
    &#13;
    function sealManualMigration(bool force) onlyOwner {&#13;
        require(force || holders[original].balance == 0);&#13;
        delete original;&#13;
    }&#13;
&#13;
    function beforeBalanceChanges(address _who) internal {&#13;
        if (holders[_who].balanceUpdateTime &lt;= freezedMoment) {&#13;
            holders[_who].balanceUpdateTime = now;&#13;
            holders[_who].balanceBeforeUpdate = holders[_who].balance;&#13;
        }&#13;
    }&#13;
}&#13;
&#13;
contract Crowdsale is ManualMigration {&#13;
    &#13;
    function Crowdsale(address _original) payable ManualMigration(_original) {}&#13;
&#13;
    function () payable enabled {&#13;
        require(holders[this].balance &gt; 0);&#13;
        uint256 tokens = 5000 * msg.value / 1000000000000000000;&#13;
        if (tokens &gt; holders[this].balance) {&#13;
            tokens = holders[this].balance;&#13;
            uint valueWei = tokens * 1000000000000000000 / 5000;&#13;
            msg.sender.transfer(msg.value - valueWei);&#13;
        }&#13;
        require(holders[msg.sender].balance + tokens &gt; holders[msg.sender].balance); // overflow&#13;
        require(tokens &gt; 0);&#13;
        beforeBalanceChanges(msg.sender);&#13;
        beforeBalanceChanges(this);&#13;
        holders[msg.sender].balance += tokens;&#13;
        specials[msg.sender].limit += tokens;&#13;
        holders[this].balance -= tokens;&#13;
        Transfer(this, msg.sender, tokens);&#13;
    }&#13;
}&#13;
&#13;
contract Token is Crowdsale {&#13;
&#13;
    string  public standard    = 'Token 0.1';&#13;
    string  public name        = 'NeuroDAO';&#13;
    string  public symbol      = "NDAO";&#13;
    uint8   public decimals    = 0;&#13;
&#13;
    uint    public startTime;&#13;
&#13;
    mapping (address =&gt; mapping (address =&gt; uint256)) public allowed;&#13;
&#13;
    event Burned(address indexed owner, uint256 value);&#13;
&#13;
    function Token(address _original, uint _startTime)&#13;
        payable Crowdsale(_original) {&#13;
        startTime = _startTime;    &#13;
    }&#13;
&#13;
    function availableTokens(address _who) public constant returns (uint _avail) {&#13;
        _avail = holders[_who].balance;&#13;
        uint limit = specials[_who].limit;&#13;
        if (limit != 0) {&#13;
            uint blocked;&#13;
            uint periods = firstYearPeriods();&#13;
            if (specials[_who].isTeam) {&#13;
                if (periods != 0) {&#13;
                    blocked = limit * (500 - periods) / 500;&#13;
                } else {&#13;
                    periods = (now - startTime) / 1 years;&#13;
                    ++periods;&#13;
                    if (periods &lt; 5) {&#13;
                        blocked = limit * (100 - periods * 20) / 100;&#13;
                    }&#13;
                }&#13;
            } else {&#13;
                if (periods != 0) {&#13;
                    blocked = limit * (100 - periods) / 100;&#13;
                }&#13;
            }&#13;
            _avail -= blocked;&#13;
        }&#13;
    }&#13;
    &#13;
    function firstYearPeriods() internal constant returns (uint _periods) {&#13;
        _periods = 0;&#13;
        if (now &lt; startTime + 1 years) {&#13;
            uint8[12] memory logic = [1, 2, 3, 4, 4, 4, 5, 6, 7, 8, 9, 10];&#13;
            _periods = logic[(now - startTime) / 28 days];&#13;
        }&#13;
    }&#13;
&#13;
    function balanceOf(address _who) constant public returns (uint) {&#13;
        return holders[_who].balance;&#13;
    }&#13;
&#13;
    function transfer(address _to, uint256 _value) public enabled {&#13;
        require(availableTokens(msg.sender) &gt;= _value);&#13;
        require(holders[_to].balance + _value &gt;= holders[_to].balance); // overflow&#13;
        beforeBalanceChanges(msg.sender);&#13;
        beforeBalanceChanges(_to);&#13;
        holders[msg.sender].balance -= _value;&#13;
        holders[_to].balance += _value;&#13;
        Transfer(msg.sender, _to, _value);&#13;
    }&#13;
    &#13;
    function transferFrom(address _from, address _to, uint256 _value) public enabled {&#13;
        require(availableTokens(_from) &gt;= _value);&#13;
        require(holders[_to].balance + _value &gt;= holders[_to].balance); // overflow&#13;
        require(allowed[_from][msg.sender] &gt;= _value);&#13;
        beforeBalanceChanges(_from);&#13;
        beforeBalanceChanges(_to);&#13;
        holders[_from].balance -= _value;&#13;
        holders[_to].balance += _value;&#13;
        allowed[_from][msg.sender] -= _value;&#13;
        Transfer(_from, _to, _value);&#13;
    }&#13;
&#13;
    function approve(address _spender, uint256 _value) public {&#13;
        allowed[msg.sender][_spender] = _value;&#13;
        Approval(msg.sender, _spender, _value);&#13;
    }&#13;
&#13;
    function allowance(address _owner, address _spender) public constant&#13;
        returns (uint256 remaining) {&#13;
        return allowed[_owner][_spender];&#13;
    }&#13;
    &#13;
    function burn(uint256 _value) public enabled {&#13;
        require(holders[msg.sender].balance &gt;= _value);&#13;
        beforeBalanceChanges(msg.sender);&#13;
        holders[msg.sender].balance -= _value;&#13;
        totalSupply -= _value;&#13;
        Burned(msg.sender, _value);&#13;
    }&#13;
}&#13;
&#13;
contract MigrationAgent {&#13;
    function migrateFrom(address _from, uint256 _value);&#13;
}&#13;
&#13;
contract TokenMigration is Token {&#13;
    &#13;
    address public migrationAgent;&#13;
    uint256 public totalMigrated;&#13;
&#13;
    event Migrate(address indexed from, address indexed to, uint256 value);&#13;
&#13;
    function TokenMigration(address _original, uint _startTime)&#13;
        payable Token(_original, _startTime) {}&#13;
&#13;
    // Migrate _value of tokens to the new token contract&#13;
    function migrate() external {&#13;
        require(migrationAgent != 0);&#13;
        uint value = holders[msg.sender].balance;&#13;
        require(value != 0);&#13;
        beforeBalanceChanges(msg.sender);&#13;
        beforeBalanceChanges(this);&#13;
        holders[msg.sender].balance -= value;&#13;
        holders[this].balance += value;&#13;
        totalMigrated += value;&#13;
        MigrationAgent(migrationAgent).migrateFrom(msg.sender, value);&#13;
        Transfer(msg.sender, this, value);&#13;
        Migrate(msg.sender, migrationAgent, value);&#13;
    }&#13;
&#13;
    function setMigrationAgent(address _agent) external onlyOwner enabled {&#13;
        require(migrationAgent == 0);&#13;
        migrationAgent = _agent;&#13;
    }&#13;
}&#13;
&#13;
contract NeuroDAO is TokenMigration {&#13;
&#13;
    function NeuroDAO(address _original, uint _startTime)&#13;
        payable TokenMigration(_original, _startTime) {}&#13;
    &#13;
    function withdraw() public onlyOwner {&#13;
        owner.transfer(this.balance);&#13;
    }&#13;
    &#13;
    function freezeTheMoment() public onlyOwner {&#13;
        freezedMoment = now;&#13;
    }&#13;
&#13;
    /** Get balance of _who for freezed moment&#13;
     *  freezeTheMoment()&#13;
     */&#13;
    function freezedBalanceOf(address _who) constant public returns(uint) {&#13;
        if (holders[_who].balanceUpdateTime &lt;= freezedMoment) {&#13;
            return holders[_who].balance;&#13;
        } else {&#13;
            return holders[_who].balanceBeforeUpdate;&#13;
        }&#13;
    }&#13;
    &#13;
    function killMe() public onlyOwner {&#13;
        require(totalSupply == 0);&#13;
        selfdestruct(owner);&#13;
    }&#13;
}&#13;
&#13;
contract Adapter is owned {&#13;
    &#13;
    address public neuroDAO;&#13;
    address public erc20contract;&#13;
    address public masterHolder;&#13;
    &#13;
    mapping (address =&gt; bool) public alreadyUsed;&#13;
    &#13;
    function Adapter(address _neuroDAO, address _erc20contract, address _masterHolder)&#13;
        payable owned() {&#13;
        neuroDAO = _neuroDAO;&#13;
        erc20contract = _erc20contract;&#13;
        masterHolder = _masterHolder;&#13;
    }&#13;
    &#13;
    function killMe() public onlyOwner {&#13;
        selfdestruct(owner);&#13;
    }&#13;
 &#13;
    /**&#13;
     * Move tokens int erc20contract to NDAO tokens holder&#13;
     * &#13;
     * # Freeze balances in NeuroDAO smartcontract by calling freezeTheMoment() function.&#13;
     * # Allow transferFrom masterHolder in ERC20 smartcontract by calling approve() function&#13;
     *   from masterHolder address, gives this contract address as spender parameter.&#13;
     * # ERC20 smartcontract must have enougth tokens on masterHolder balance.&#13;
     */&#13;
    function giveMeTokens() public {&#13;
        require(!alreadyUsed[msg.sender]);&#13;
        uint balance = NeuroDAO(neuroDAO).freezedBalanceOf(msg.sender);&#13;
        ERC20(erc20contract).transferFrom(masterHolder, msg.sender, balance);&#13;
        alreadyUsed[msg.sender] = true;&#13;
    }&#13;
}