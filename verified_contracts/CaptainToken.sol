pragma solidity ^0.4.18;
/* ==================================================================== */
/* Copyright (c) 2018 The Priate Conquest Project.  All rights reserved.
/* 
/* https://www.pirateconquest.com One of the world's slg games of blockchain 
/*  
/* authors <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="ff8d9e969186bf9396899a8c8b9e8dd19c9092">[email protected]</a>/<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="6b2104050512452d1e2b07021d0e181f0a1945080406">[email protected]</a>&#13;
/*                 &#13;
/* ==================================================================== */&#13;
/// @title ERC-721 Non-Fungible Token Standard&#13;
/// @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md&#13;
///  Note: the ERC-165 identifier for this interface is 0x80ac58cd&#13;
contract ERC721 /* is ERC165 */ {&#13;
  event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);&#13;
  event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);&#13;
  event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);&#13;
&#13;
  function balanceOf(address _owner) external view returns (uint256);&#13;
  function ownerOf(uint256 _tokenId) external view returns (address);&#13;
  function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data) external payable;&#13;
  function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable;&#13;
  function transferFrom(address _from, address _to, uint256 _tokenId) external payable;&#13;
  function approve(address _approved, uint256 _tokenId) external payable;&#13;
  function setApprovalForAll(address _operator, bool _approved) external;&#13;
  function getApproved(uint256 _tokenId) external view returns (address);&#13;
  function isApprovedForAll(address _owner, address _operator) external view returns (bool);&#13;
}&#13;
&#13;
interface ERC165 {&#13;
     function supportsInterface(bytes4 interfaceID) external view returns (bool);&#13;
}&#13;
&#13;
/// @title ERC-721 Non-Fungible Token Standard&#13;
interface ERC721TokenReceiver {&#13;
	function onERC721Received(address _from, uint256 _tokenId, bytes data) external returns(bytes4);&#13;
}&#13;
&#13;
/// @title ERC-721 Non-Fungible Token Standard, optional metadata extension&#13;
/// @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md&#13;
///  Note: the ERC-165 identifier for this interface is 0x5b5e139f&#13;
interface ERC721Metadata /* is ERC721 */ {&#13;
    function name() external view returns (string _name);&#13;
    function symbol() external view returns (string _symbol);&#13;
    function tokenURI(uint256 _tokenId) external view returns (string);&#13;
}&#13;
&#13;
/// @title ERC-721 Non-Fungible Token Standard, optional enumeration extension&#13;
/// @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md&#13;
///  Note: the ERC-165 identifier for this interface is 0x780e9d63&#13;
interface ERC721Enumerable /* is ERC721 */ {&#13;
    function totalSupply() external view returns (uint256);&#13;
    function tokenByIndex(uint256 _index) external view returns (uint256);&#13;
    function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256);&#13;
}&#13;
&#13;
/**&#13;
 * @title Ownable&#13;
 * @dev The Ownable contract has an owner address, and provides basic authorization control&#13;
 * functions, this simplifies the implementation of "user permissions".&#13;
 */&#13;
contract Ownable {&#13;
  address public owner;&#13;
&#13;
  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);&#13;
&#13;
  /*&#13;
   * @dev The Ownable constructor sets the original `owner` of the contract to the sender&#13;
   * account.&#13;
   */&#13;
  function Ownable() public {&#13;
    owner = msg.sender;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Throws if called by any account other than the owner.&#13;
   */&#13;
  modifier onlyOwner() {&#13;
    require(msg.sender == owner);&#13;
    _;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Allows the current owner to transfer control of the contract to a newOwner.&#13;
   * @param newOwner The address to transfer ownership to.&#13;
   */&#13;
  function transferOwnership(address newOwner) public onlyOwner {&#13;
    require(newOwner != address(0));&#13;
    OwnershipTransferred(owner, newOwner);&#13;
    owner = newOwner;&#13;
  }&#13;
}&#13;
&#13;
&#13;
/**&#13;
 * @title Pausable&#13;
 * @dev Base contract which allows children to implement an emergency stop mechanism.&#13;
 */&#13;
contract Pausable is Ownable {&#13;
  event Pause();&#13;
  event Unpause();&#13;
&#13;
  bool public paused = false;&#13;
&#13;
&#13;
  /**&#13;
   * @dev modifier to allow actions only when the contract IS paused&#13;
   */&#13;
  modifier whenNotPaused() {&#13;
    require(!paused);&#13;
    _;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev modifier to allow actions only when the contract IS NOT paused&#13;
   */&#13;
  modifier whenPaused {&#13;
    require(paused);&#13;
    _;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev called by the owner to pause, triggers stopped state&#13;
   */&#13;
  function pause() external onlyOwner whenNotPaused returns (bool) {&#13;
    paused = true;&#13;
    Pause();&#13;
    return true;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev called by the owner to unpause, returns to normal state&#13;
   */&#13;
  function unpause() external onlyOwner whenPaused returns (bool) {&#13;
    paused = false;&#13;
    Unpause();&#13;
    return true;&#13;
  }&#13;
}&#13;
&#13;
library SafeMath {&#13;
&#13;
  /**&#13;
  * @dev Multiplies two numbers, throws on overflow.&#13;
  */&#13;
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
    if (a == 0) {&#13;
      return 0;&#13;
    }&#13;
    uint256 c = a * b;&#13;
    assert(c / a == b);&#13;
    return c;&#13;
  }&#13;
&#13;
  function mul32(uint32 a, uint32 b) internal pure returns (uint32) {&#13;
    if (a == 0) {&#13;
      return 0;&#13;
    }&#13;
    uint32 c = a * b;&#13;
    assert(c / a == b);&#13;
    return c;&#13;
  }&#13;
&#13;
  /**&#13;
  * @dev Integer division of two numbers, truncating the quotient.&#13;
  */&#13;
  function div(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
    // assert(b &gt; 0); // Solidity automatically throws when dividing by 0&#13;
    uint256 c = a / b;&#13;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold&#13;
    return c;&#13;
  }&#13;
&#13;
  function div32(uint32 a, uint32 b) internal pure returns (uint32) {&#13;
    // assert(b &gt; 0); // Solidity automatically throws when dividing by 0&#13;
    uint32 c = a / b;&#13;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold&#13;
    return c;&#13;
  }&#13;
&#13;
  /**&#13;
  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).&#13;
  */&#13;
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
    assert(b &lt;= a);&#13;
    return a - b;&#13;
  }&#13;
&#13;
  function sub32(uint32 a, uint32 b) internal pure returns (uint32) {&#13;
    assert(b &lt;= a);&#13;
    return a - b;&#13;
  }&#13;
&#13;
  /**&#13;
  * @dev Adds two numbers, throws on overflow.&#13;
  */&#13;
  function add(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
    uint256 c = a + b;&#13;
    assert(c &gt;= a);&#13;
    return c;&#13;
  }&#13;
&#13;
  function add32(uint32 a, uint32 b) internal pure returns (uint32) {&#13;
    uint32 c = a + b;&#13;
    assert(c &gt;= a);&#13;
    return c;&#13;
  }&#13;
}&#13;
&#13;
contract AccessAdmin is Pausable {&#13;
&#13;
  /// @dev Admin Address&#13;
  mapping (address =&gt; bool) adminContracts;&#13;
&#13;
  /// @dev Trust contract&#13;
  mapping (address =&gt; bool) actionContracts;&#13;
&#13;
  function setAdminContract(address _addr, bool _useful) public onlyOwner {&#13;
    require(_addr != address(0));&#13;
    adminContracts[_addr] = _useful;&#13;
  }&#13;
&#13;
  modifier onlyAdmin {&#13;
    require(adminContracts[msg.sender]); &#13;
    _;&#13;
  }&#13;
&#13;
  function setActionContract(address _actionAddr, bool _useful) public onlyAdmin {&#13;
    actionContracts[_actionAddr] = _useful;&#13;
  }&#13;
&#13;
  modifier onlyAccess() {&#13;
    require(actionContracts[msg.sender]);&#13;
    _;&#13;
  }&#13;
}&#13;
&#13;
interface CaptainGameConfigInterface {&#13;
  function getLevelConfig(uint32 cardId, uint32 level) external view returns (uint32 atk,uint32 defense,uint32 atk_min,uint32 atk_max);&#13;
}&#13;
contract CaptainToken is AccessAdmin, ERC721 {&#13;
  using SafeMath for SafeMath;&#13;
  //event &#13;
  event CreateCaptain(uint tokenId,uint32 captainId, address _owner, uint256 _price);&#13;
  //ERC721&#13;
  event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);&#13;
  event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);&#13;
  event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);&#13;
  event LevelUP(address indexed _owner,uint32 oldLevel, uint32 newLevel);&#13;
&#13;
  struct Captain {&#13;
    uint32 captainId;  &#13;
    uint32 color; // 1,2,3,4  &#13;
    uint32 atk; &#13;
    uint32 defense;&#13;
    uint32 level;&#13;
    uint256 exp;&#13;
  }&#13;
  CaptainGameConfigInterface public config;&#13;
&#13;
  Captain[] public captains; //dynamic Array&#13;
  function CaptainToken() public {&#13;
    captains.length += 1;&#13;
    setAdminContract(msg.sender,true);&#13;
    setActionContract(msg.sender,true);&#13;
  }&#13;
  //setting configuration&#13;
  function setGameConfigContract(address _address) external onlyOwner {&#13;
    config = CaptainGameConfigInterface(_address);&#13;
  }&#13;
&#13;
  /**MAPPING**/&#13;
  /// @dev tokenId to owner  tokenId -&gt; address&#13;
  mapping (uint256 =&gt; address) public captainTokenIdToOwner;&#13;
  /// @dev Equipment token ID search in owner array captainId -&gt; tokenId&#13;
  mapping (uint256 =&gt; uint256) captainIdToOwnerIndex;  &#13;
  /// @dev captains owner by the owner (array)&#13;
  mapping (address =&gt; uint256[]) ownerToCaptainArray;&#13;
  /// @dev price of each token&#13;
  mapping (uint256 =&gt; uint256) captainTokenIdToPrice;&#13;
  /// @dev token count of captain&#13;
  mapping (uint32 =&gt; uint256) tokenCountOfCaptain;&#13;
  /// @dev tokens by the captain&#13;
  mapping (uint256 =&gt; uint32) IndexToCaptain;&#13;
  /// @dev The authorized address for each Captain&#13;
  mapping (uint256 =&gt; address) captainTokenIdToApprovals;&#13;
  /// @dev The authorized operators for each address&#13;
  mapping (address =&gt; mapping (address =&gt; bool)) operatorToApprovals;&#13;
  mapping(uint256 =&gt; bool) tokenToSell;&#13;
  &#13;
&#13;
  /*** CONSTRUCTOR ***/&#13;
  /// @dev Amount of tokens destroyed&#13;
  uint256 destroyCaptainCount;&#13;
  &#13;
  // modifier&#13;
  /// @dev Check if token ID is valid&#13;
  modifier isValidToken(uint256 _tokenId) {&#13;
    require(_tokenId &gt;= 1 &amp;&amp; _tokenId &lt;= captains.length);&#13;
    require(captainTokenIdToOwner[_tokenId] != address(0)); &#13;
    _;&#13;
  }&#13;
  modifier canTransfer(uint256 _tokenId) {&#13;
    require(msg.sender == captainTokenIdToOwner[_tokenId] || msg.sender == captainTokenIdToApprovals[_tokenId]);&#13;
    _;&#13;
  }&#13;
  /// @dev Creates a new Captain with the given name.&#13;
  function CreateCaptainToken(address _owner,uint256 _price, uint32 _captainId, uint32 _color,uint32 _atk,uint32 _defense,uint32 _level,uint256 _exp) public onlyAccess {&#13;
    _createCaptainToken(_owner,_price,_captainId,_color,_atk,_defense,_level,_exp);&#13;
  }&#13;
&#13;
  /// For creating CaptainToken&#13;
  function _createCaptainToken(address _owner, uint256 _price, uint32 _captainId, uint32 _color, uint32 _atk, uint32 _defense,uint32 _level,uint256 _exp) &#13;
  internal {&#13;
    uint256 newTokenId = captains.length;&#13;
    Captain memory _captain = Captain({&#13;
      captainId: _captainId,&#13;
      color: _color,&#13;
      atk: _atk,&#13;
      defense: _defense,&#13;
      level: _level,&#13;
      exp: _exp &#13;
    });&#13;
    captains.push(_captain);&#13;
    //event&#13;
    CreateCaptain(newTokenId, _captainId, _owner, _price);&#13;
    captainTokenIdToPrice[newTokenId] = _price;&#13;
    IndexToCaptain[newTokenId] = _captainId;&#13;
    tokenCountOfCaptain[_captainId] = SafeMath.add(tokenCountOfCaptain[_captainId],1);&#13;
    // This will assign ownership, and also emit the Transfer event as&#13;
    // per ERC721 draft&#13;
    _transfer(address(0), _owner, newTokenId);&#13;
  } &#13;
  /// @dev set the token price&#13;
  function setTokenPrice(uint256 _tokenId, uint256 _price) external onlyAccess {&#13;
    captainTokenIdToPrice[_tokenId] = _price;&#13;
  }&#13;
&#13;
  /// @dev let owner set the token price&#13;
  function setTokenPriceByOwner(uint256 _tokenId, uint256 _price) external {&#13;
    require(captainTokenIdToOwner[_tokenId] == msg.sender);&#13;
    captainTokenIdToPrice[_tokenId] = _price;&#13;
  }&#13;
&#13;
  /// @dev set sellable&#13;
  function setSelled(uint256 _tokenId, bool fsell) external onlyAccess {&#13;
    tokenToSell[_tokenId] = fsell;&#13;
  }&#13;
&#13;
  function getSelled(uint256 _tokenId) external view returns (bool) {&#13;
    return tokenToSell[_tokenId];&#13;
  }&#13;
&#13;
  /// @dev Do the real transfer with out any condition checking&#13;
  /// @param _from The old owner of this Captain(If created: 0x0)&#13;
  /// @param _to The new owner of this Captain &#13;
  /// @param _tokenId The tokenId of the Captain&#13;
  function _transfer(address _from, address _to, uint256 _tokenId) internal {&#13;
    if (_from != address(0)) {&#13;
      uint256 indexFrom = captainIdToOwnerIndex[_tokenId];  // tokenId -&gt; captainId&#13;
      uint256[] storage cpArray = ownerToCaptainArray[_from];&#13;
      require(cpArray[indexFrom] == _tokenId);&#13;
&#13;
      // If the Captain is not the element of array, change it to with the last&#13;
      if (indexFrom != cpArray.length - 1) {&#13;
        uint256 lastTokenId = cpArray[cpArray.length - 1];&#13;
        cpArray[indexFrom] = lastTokenId; &#13;
        captainIdToOwnerIndex[lastTokenId] = indexFrom;&#13;
      }&#13;
      cpArray.length -= 1; &#13;
    &#13;
      if (captainTokenIdToApprovals[_tokenId] != address(0)) {&#13;
        delete captainTokenIdToApprovals[_tokenId];&#13;
      }      &#13;
    }&#13;
&#13;
    // Give the Captain to '_to'&#13;
    captainTokenIdToOwner[_tokenId] = _to;&#13;
    ownerToCaptainArray[_to].push(_tokenId);&#13;
    captainIdToOwnerIndex[_tokenId] = ownerToCaptainArray[_to].length - 1;&#13;
        &#13;
    Transfer(_from != address(0) ? _from : this, _to, _tokenId);&#13;
  }&#13;
&#13;
&#13;
  /// @notice Returns all the relevant information about a specific tokenId.&#13;
  /// @param _tokenId The tokenId of the captain&#13;
  function getCaptainInfo(uint256 _tokenId) external view returns (&#13;
    uint32 captainId,  &#13;
    uint32 color, &#13;
    uint32 atk,&#13;
    uint32 defense,&#13;
    uint32 level,&#13;
    uint256 exp, &#13;
    uint256 price,&#13;
    address owner,&#13;
    bool selled&#13;
  ) {&#13;
    Captain storage captain = captains[_tokenId];&#13;
    captainId = captain.captainId;&#13;
    color = captain.color;&#13;
    atk = captain.atk;&#13;
    defense = captain.defense;&#13;
    level = captain.level;&#13;
    exp = captain.exp;&#13;
    price = captainTokenIdToPrice[_tokenId];&#13;
    owner = captainTokenIdToOwner[_tokenId];&#13;
    selled = tokenToSell[_tokenId];&#13;
  }&#13;
&#13;
  /// @dev levelUp &#13;
  function LevelUp(uint256 _tokenId,uint32 _level) external payable {&#13;
    require(msg.sender == captainTokenIdToOwner[_tokenId]);&#13;
    Captain storage captain = captains[_tokenId];&#13;
    uint32 captainId = captain.captainId;&#13;
    uint32 level = captain.level;&#13;
    uint256 cur_exp = SafeMath.mul(SafeMath.mul(level,SafeMath.sub(level,1)),25); // level*(level-1)*25&#13;
    uint256 req_exp = SafeMath.mul(SafeMath.mul(_level,SafeMath.sub(_level,1)),25);&#13;
    require(captain.exp&gt;=SafeMath.sub(req_exp,cur_exp));&#13;
    uint256 exp = SafeMath.sub(captain.exp,SafeMath.sub(req_exp,cur_exp));&#13;
    if (SafeMath.add32(level,_level)&gt;=99) {&#13;
      captains[_tokenId].level = 99;&#13;
    } else {&#13;
      captains[_tokenId].level = _level;&#13;
    }&#13;
&#13;
    (captains[_tokenId].atk,captains[_tokenId].defense,,) = config.getLevelConfig(captainId,captains[_tokenId].level);&#13;
    captains[_tokenId].exp = exp;&#13;
    //event tell the world&#13;
    LevelUP(msg.sender,level,captain.level);&#13;
  }&#13;
&#13;
  /// ERC721 &#13;
&#13;
  function balanceOf(address _owner) external view returns (uint256) {&#13;
    require(_owner != address(0));&#13;
    return ownerToCaptainArray[_owner].length;&#13;
  }&#13;
&#13;
  function ownerOf(uint256 _tokenId) external view returns (address) {&#13;
    return captainTokenIdToOwner[_tokenId];&#13;
  }&#13;
  function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data) external payable {&#13;
    _safeTransferFrom(_from, _to, _tokenId, data);&#13;
  }&#13;
  function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable {&#13;
    _safeTransferFrom(_from, _to, _tokenId, "");&#13;
  }&#13;
&#13;
  /// @dev Actually perform the safeTransferFrom&#13;
  function _safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data) &#13;
    internal&#13;
    isValidToken(_tokenId) &#13;
    canTransfer(_tokenId)&#13;
    {&#13;
    address owner = captainTokenIdToOwner[_tokenId];&#13;
    require(owner != address(0) &amp;&amp; owner == _from);&#13;
    require(_to != address(0));&#13;
        &#13;
    _transfer(_from, _to, _tokenId);&#13;
&#13;
    // Do the callback after everything is done to avoid reentrancy attack&#13;
    /*uint256 codeSize;&#13;
    assembly { codeSize := extcodesize(_to) }&#13;
    if (codeSize == 0) {&#13;
      return;&#13;
    }*/&#13;
    bytes4 retval = ERC721TokenReceiver(_to).onERC721Received(_from, _tokenId, data);&#13;
    // bytes4(keccak256("onERC721Received(address,uint256,bytes)")) = 0xf0b9e5ba;&#13;
    require(retval == 0xf0b9e5ba);&#13;
  }&#13;
    &#13;
  /// @dev Transfer ownership of an Captain, '_to' must be a vaild address, or the WAR will lost&#13;
  /// @param _from The current owner of the Captain&#13;
  /// @param _to The new owner&#13;
  /// @param _tokenId The Captain to transfer&#13;
  function transferFrom(address _from, address _to, uint256 _tokenId)&#13;
        external&#13;
        whenNotPaused&#13;
        isValidToken(_tokenId)&#13;
        canTransfer(_tokenId)&#13;
        payable&#13;
    {&#13;
    address owner = captainTokenIdToOwner[_tokenId];&#13;
    require(owner != address(0));&#13;
    require(owner == _from);&#13;
    require(_to != address(0));&#13;
        &#13;
    _transfer(_from, _to, _tokenId);&#13;
  }&#13;
&#13;
  /// @dev Safe transfer by trust contracts&#13;
  function safeTransferByContract(address _from,address _to, uint256 _tokenId) &#13;
  external&#13;
  whenNotPaused&#13;
  {&#13;
    require(actionContracts[msg.sender]);&#13;
&#13;
    require(_tokenId &gt;= 1 &amp;&amp; _tokenId &lt;= captains.length);&#13;
    address owner = captainTokenIdToOwner[_tokenId];&#13;
    require(owner != address(0));&#13;
    require(_to != address(0));&#13;
    require(owner != _to);&#13;
    require(_from == owner);&#13;
&#13;
    _transfer(owner, _to, _tokenId);&#13;
  }&#13;
&#13;
  /// @dev Set or reaffirm the approved address for an captain&#13;
  /// @param _approved The new approved captain controller&#13;
  /// @param _tokenId The captain to approve&#13;
  function approve(address _approved, uint256 _tokenId)&#13;
    external&#13;
    whenNotPaused &#13;
    payable&#13;
  {&#13;
    address owner = captainTokenIdToOwner[_tokenId];&#13;
    require(owner != address(0));&#13;
    require(msg.sender == owner || operatorToApprovals[owner][msg.sender]);&#13;
&#13;
    captainTokenIdToApprovals[_tokenId] = _approved;&#13;
    Approval(owner, _approved, _tokenId);&#13;
  }&#13;
&#13;
  /// @dev Enable or disable approval for a third party ("operator") to manage all your asset.&#13;
  /// @param _operator Address to add to the set of authorized operators.&#13;
  /// @param _approved True if the operators is approved, false to revoke approval&#13;
  function setApprovalForAll(address _operator, bool _approved) &#13;
    external &#13;
    whenNotPaused&#13;
  {&#13;
    operatorToApprovals[msg.sender][_operator] = _approved;&#13;
    ApprovalForAll(msg.sender, _operator, _approved);&#13;
  }&#13;
&#13;
  /// @dev Get the approved address for a single Captain&#13;
  /// @param _tokenId The WAR to find the approved address for&#13;
  /// @return The approved address for this WAR, or the zero address if there is none&#13;
  function getApproved(uint256 _tokenId) external view isValidToken(_tokenId) returns (address) {&#13;
    return captainTokenIdToApprovals[_tokenId];&#13;
  }&#13;
  &#13;
  /// @dev Query if an address is an authorized operator for another address&#13;
  /// @param _owner The address that owns the WARs&#13;
  /// @param _operator The address that acts on behalf of the owner&#13;
  /// @return True if `_operator` is an approved operator for `_owner`, false otherwise&#13;
  function isApprovedForAll(address _owner, address _operator) external view returns (bool) {&#13;
    return operatorToApprovals[_owner][_operator];&#13;
  }&#13;
  /// @notice A descriptive name for a collection of NFTs in this contract&#13;
  function name() public pure returns(string) {&#13;
    return "Pirate Conquest Token";&#13;
  }&#13;
  /// @notice An abbreviated name for NFTs in this contract&#13;
  function symbol() public pure returns(string) {&#13;
    return "PCT";&#13;
  }&#13;
  /// @notice A distinct Uniform Resource Identifier (URI) for a given asset.&#13;
  /// @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC&#13;
  ///  3986. The URI may point to a JSON file that conforms to the "ERC721&#13;
  ///  Metadata JSON Schema".&#13;
  //function tokenURI(uint256 _tokenId) external view returns (string);&#13;
&#13;
  /// @notice Count NFTs tracked by this contract&#13;
  /// @return A count of valid NFTs tracked by this contract, where each one of&#13;
  ///  them has an assigned and queryable owner not equal to the zero address&#13;
  function totalSupply() external view returns (uint256) {&#13;
    return captains.length - destroyCaptainCount -1;&#13;
  }&#13;
  /// @notice Enumerate valid NFTs&#13;
  /// @dev Throws if `_index` &gt;= `totalSupply()`.&#13;
  /// @param _index A counter less than `totalSupply()`&#13;
  /// @return The token identifier for the `_index`th NFT,&#13;
  ///  (sort order not specified)&#13;
  function tokenByIndex(uint256 _index) external view returns (uint256) {&#13;
    require(_index&lt;(captains.length - destroyCaptainCount));&#13;
    //return captainIdToOwnerIndex[_index];&#13;
    return _index;&#13;
  }&#13;
  /// @notice Enumerate NFTs assigned to an owner&#13;
  /// @dev Throws if `_index` &gt;= `balanceOf(_owner)` or if&#13;
  ///  `_owner` is the zero address, representing invalid NFTs.&#13;
  /// @param _owner An address where we are interested in NFTs owned by them&#13;
  /// @param _index A counter less than `balanceOf(_owner)`&#13;
  /// @return The token identifier for the `_index`th NFT assigned to `_owner`,&#13;
  ///   (sort order not specified)&#13;
  function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256) {&#13;
    require(_index &lt; ownerToCaptainArray[_owner].length);&#13;
    if (_owner != address(0)) {&#13;
      uint256 tokenId = ownerToCaptainArray[_owner][_index];&#13;
      return tokenId;&#13;
    }&#13;
  }&#13;
&#13;
  /// @param _owner The owner whose celebrity tokens we are interested in.&#13;
  /// @dev This method MUST NEVER be called by smart contract code. First, it's fairly&#13;
  ///  expensive (it walks the entire Persons array looking for persons belonging to owner),&#13;
  ///  but it also returns a dynamic array, which is only supported for web3 calls, and&#13;
  ///  not contract-to-contract calls.&#13;
  function tokensOfOwner(address _owner) external view returns (uint256[],uint32[]) {&#13;
    uint256 len = ownerToCaptainArray[_owner].length;&#13;
    uint256[] memory tokens = new uint256[](len);&#13;
    uint32[] memory captainss = new uint32[](len);&#13;
    uint256 icount;&#13;
    if (_owner != address(0)) {&#13;
      for (uint256 i=0;i&lt;len;i++) {&#13;
        tokens[i] = ownerToCaptainArray[_owner][icount];&#13;
        captainss[i] = IndexToCaptain[ownerToCaptainArray[_owner][icount]];&#13;
        icount++;&#13;
      }&#13;
    }&#13;
    return (tokens,captainss);&#13;
  }&#13;
&#13;
  /// @param _captainId The captain whose celebrity tokens we are interested in.&#13;
  /// @dev This method MUST NEVER be called by smart contract code. First, it's fairly&#13;
  ///  expensive (it walks the entire Persons array looking for persons belonging to owner),&#13;
  ///  but it also returns a dynamic array, which is only supported for web3 calls, and&#13;
  ///  not contract-to-contract calls.&#13;
  function tokensOfCaptain(uint32 _captainId) public view returns(uint256[] captainTokens) {&#13;
    uint256 tokenCount = tokenCountOfCaptain[_captainId];&#13;
    if (tokenCount == 0) {&#13;
        // Return an empty array&#13;
      return new uint256[](0);&#13;
    } else {&#13;
      uint256[] memory result = new uint256[](tokenCount);&#13;
      uint256 totalcaptains = captains.length - destroyCaptainCount - 1;&#13;
      uint256 resultIndex = 0;&#13;
&#13;
      uint256 tokenId;&#13;
      for (tokenId = 0; tokenId &lt;= totalcaptains; tokenId++) {&#13;
        if (IndexToCaptain[tokenId] == _captainId) {&#13;
          result[resultIndex] = tokenId;&#13;
          resultIndex++;&#13;
        }&#13;
      }&#13;
      return result;&#13;
    }&#13;
  } &#13;
}