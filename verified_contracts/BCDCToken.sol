pragma solidity ^0.4.11;

// accepted from zeppelin-solidity https://github.com/OpenZeppelin/zeppelin-solidity
/*
 * ERC20 interface
 * see https://github.com/ethereum/EIPs/issues/20
 */
contract ERC20 {
  uint public totalSupply;
  function balanceOf(address who) constant returns (uint);
  function allowance(address owner, address spender) constant returns (uint);

  function transfer(address to, uint value) returns (bool ok);
  function transferFrom(address from, address to, uint value) returns (bool ok);
  function approve(address spender, uint value) returns (bool ok);
  event Transfer(address indexed from, address indexed to, uint value);
  event Approval(address indexed owner, address indexed spender, uint value);
}

// accepted from zeppelin-solidity https://github.com/OpenZeppelin/zeppelin-solidity

/**
 * Math operations with safety checks
 */
contract SafeMath {
  function safeMul(uint a, uint b) internal returns (uint) {
    uint c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }

  function safeDiv(uint a, uint b) internal returns (uint) {
    assert(b > 0);
    uint c = a / b;
    assert(a == b * c + a % b);
    return c;
  }

  function safeSub(uint a, uint b) internal returns (uint) {
    assert(b <= a);
    return a - b;
  }

  function safeAdd(uint a, uint b) internal returns (uint) {
    uint c = a + b;
    assert(c>=a && c>=b);
    return c;
  }

  function max64(uint64 a, uint64 b) internal constant returns (uint64) {
    return a >= b ? a : b;
  }

  function min64(uint64 a, uint64 b) internal constant returns (uint64) {
    return a < b ? a : b;
  }

  function max256(uint256 a, uint256 b) internal constant returns (uint256) {
    return a >= b ? a : b;
  }

  function min256(uint256 a, uint256 b) internal constant returns (uint256) {
    return a < b ? a : b;
  }

  function assert(bool assertion) internal {
    if (!assertion) {
      throw;
    }
  }
}

/// @title Multisignature wallet - Allows multiple parties to agree on transactions before execution.
/// @author Stefan George - <<span class="__cf_email__" data-cfemail="4330372625222d6d24262c31242603202c2d30262d303a306d2d2637">[emailÂ protected]</span>&gt;&#13;
contract MultiSigWallet {&#13;
&#13;
    // flag to determine if address is for a real contract or not&#13;
    bool public isMultiSigWallet = false;&#13;
&#13;
    uint constant public MAX_OWNER_COUNT = 50;&#13;
&#13;
    event Confirmation(address indexed sender, uint indexed transactionId);&#13;
    event Revocation(address indexed sender, uint indexed transactionId);&#13;
    event Submission(uint indexed transactionId);&#13;
    event Execution(uint indexed transactionId);&#13;
    event ExecutionFailure(uint indexed transactionId);&#13;
    event Deposit(address indexed sender, uint value);&#13;
    event OwnerAddition(address indexed owner);&#13;
    event OwnerRemoval(address indexed owner);&#13;
    event RequirementChange(uint required);&#13;
&#13;
    mapping (uint =&gt; Transaction) public transactions;&#13;
    mapping (uint =&gt; mapping (address =&gt; bool)) public confirmations;&#13;
    mapping (address =&gt; bool) public isOwner;&#13;
    address[] public owners;&#13;
    uint public required;&#13;
    uint public transactionCount;&#13;
&#13;
    struct Transaction {&#13;
        address destination;&#13;
        uint value;&#13;
        bytes data;&#13;
        bool executed;&#13;
    }&#13;
&#13;
    modifier onlyWallet() {&#13;
        if (msg.sender != address(this)) throw;&#13;
        _;&#13;
    }&#13;
&#13;
    modifier ownerDoesNotExist(address owner) {&#13;
        if (isOwner[owner]) throw;&#13;
        _;&#13;
    }&#13;
&#13;
    modifier ownerExists(address owner) {&#13;
        if (!isOwner[owner]) throw;&#13;
        _;&#13;
    }&#13;
&#13;
    modifier transactionExists(uint transactionId) {&#13;
        if (transactions[transactionId].destination == 0) throw;&#13;
        _;&#13;
    }&#13;
&#13;
    modifier confirmed(uint transactionId, address owner) {&#13;
        if (!confirmations[transactionId][owner]) throw;&#13;
        _;&#13;
    }&#13;
&#13;
    modifier notConfirmed(uint transactionId, address owner) {&#13;
        if (confirmations[transactionId][owner]) throw;&#13;
        _;&#13;
    }&#13;
&#13;
    modifier notExecuted(uint transactionId) {&#13;
        if (transactions[transactionId].executed) throw;&#13;
        _;&#13;
    }&#13;
&#13;
    modifier notNull(address _address) {&#13;
        if (_address == 0) throw;&#13;
        _;&#13;
    }&#13;
&#13;
    modifier validRequirement(uint ownerCount, uint _required) {&#13;
        if (ownerCount &gt; MAX_OWNER_COUNT) throw;&#13;
        if (_required &gt; ownerCount) throw;&#13;
        if (_required == 0) throw;&#13;
        if (ownerCount == 0) throw;&#13;
        _;&#13;
    }&#13;
&#13;
    /// @dev Fallback function allows to deposit ether.&#13;
    function()&#13;
        payable&#13;
    {&#13;
        if (msg.value &gt; 0)&#13;
            Deposit(msg.sender, msg.value);&#13;
    }&#13;
&#13;
    /*&#13;
     * Public functions&#13;
     */&#13;
    /// @dev Contract constructor sets initial owners and required number of confirmations.&#13;
    /// @param _owners List of initial owners.&#13;
    /// @param _required Number of required confirmations.&#13;
    function MultiSigWallet(address[] _owners, uint _required)&#13;
        public&#13;
        validRequirement(_owners.length, _required)&#13;
    {&#13;
        for (uint i=0; i&lt;_owners.length; i++) {&#13;
            if (isOwner[_owners[i]] || _owners[i] == 0) throw;&#13;
            isOwner[_owners[i]] = true;&#13;
        }&#13;
        isMultiSigWallet = true;&#13;
        owners = _owners;&#13;
        required = _required;&#13;
    }&#13;
&#13;
    /// @dev Allows to add a new owner. Transaction has to be sent by wallet.&#13;
    /// @param owner Address of new owner.&#13;
    function addOwner(address owner)&#13;
        public&#13;
        onlyWallet&#13;
        ownerDoesNotExist(owner)&#13;
        notNull(owner)&#13;
        validRequirement(owners.length + 1, required)&#13;
    {&#13;
        isOwner[owner] = true;&#13;
        owners.push(owner);&#13;
        OwnerAddition(owner);&#13;
    }&#13;
&#13;
    /// @dev Allows to remove an owner. Transaction has to be sent by wallet.&#13;
    /// @param owner Address of owner.&#13;
    function removeOwner(address owner)&#13;
        public&#13;
        onlyWallet&#13;
        ownerExists(owner)&#13;
    {&#13;
        isOwner[owner] = false;&#13;
        for (uint i=0; i&lt;owners.length - 1; i++)&#13;
            if (owners[i] == owner) {&#13;
                owners[i] = owners[owners.length - 1];&#13;
                break;&#13;
            }&#13;
        owners.length -= 1;&#13;
        if (required &gt; owners.length)&#13;
            changeRequirement(owners.length);&#13;
        OwnerRemoval(owner);&#13;
    }&#13;
&#13;
    /// @dev Allows to replace an owner with a new owner. Transaction has to be sent by wallet.&#13;
    /// @param owner Address of owner to be replaced.&#13;
    /// @param owner Address of new owner.&#13;
    function replaceOwner(address owner, address newOwner)&#13;
        public&#13;
        onlyWallet&#13;
        ownerExists(owner)&#13;
        ownerDoesNotExist(newOwner)&#13;
    {&#13;
        for (uint i=0; i&lt;owners.length; i++)&#13;
            if (owners[i] == owner) {&#13;
                owners[i] = newOwner;&#13;
                break;&#13;
            }&#13;
        isOwner[owner] = false;&#13;
        isOwner[newOwner] = true;&#13;
        OwnerRemoval(owner);&#13;
        OwnerAddition(newOwner);&#13;
    }&#13;
&#13;
    /// @dev Allows to change the number of required confirmations. Transaction has to be sent by wallet.&#13;
    /// @param _required Number of required confirmations.&#13;
    function changeRequirement(uint _required)&#13;
        public&#13;
        onlyWallet&#13;
        validRequirement(owners.length, _required)&#13;
    {&#13;
        required = _required;&#13;
        RequirementChange(_required);&#13;
    }&#13;
&#13;
    /// @dev Allows an owner to submit and confirm a transaction.&#13;
    /// @param destination Transaction target address.&#13;
    /// @param value Transaction ether value.&#13;
    /// @param data Transaction data payload.&#13;
    /// @return Returns transaction ID.&#13;
    function submitTransaction(address destination, uint value, bytes data)&#13;
        public&#13;
        returns (uint transactionId)&#13;
    {&#13;
        transactionId = addTransaction(destination, value, data);&#13;
        confirmTransaction(transactionId);&#13;
    }&#13;
&#13;
    /// @dev Allows an owner to confirm a transaction.&#13;
    /// @param transactionId Transaction ID.&#13;
    function confirmTransaction(uint transactionId)&#13;
        public&#13;
        ownerExists(msg.sender)&#13;
        transactionExists(transactionId)&#13;
        notConfirmed(transactionId, msg.sender)&#13;
    {&#13;
        confirmations[transactionId][msg.sender] = true;&#13;
        Confirmation(msg.sender, transactionId);&#13;
        executeTransaction(transactionId);&#13;
    }&#13;
&#13;
    /// @dev Allows an owner to revoke a confirmation for a transaction.&#13;
    /// @param transactionId Transaction ID.&#13;
    function revokeConfirmation(uint transactionId)&#13;
        public&#13;
        ownerExists(msg.sender)&#13;
        confirmed(transactionId, msg.sender)&#13;
        notExecuted(transactionId)&#13;
    {&#13;
        confirmations[transactionId][msg.sender] = false;&#13;
        Revocation(msg.sender, transactionId);&#13;
    }&#13;
&#13;
    /// @dev Returns the confirmation status of a transaction.&#13;
    /// @param transactionId Transaction ID.&#13;
    /// @return Confirmation status.&#13;
    function isConfirmed(uint transactionId)&#13;
        public&#13;
        constant&#13;
        returns (bool)&#13;
    {&#13;
        uint count = 0;&#13;
        for (uint i=0; i&lt;owners.length; i++) {&#13;
            if (confirmations[transactionId][owners[i]])&#13;
                count += 1;&#13;
            if (count == required)&#13;
                return true;&#13;
        }&#13;
    }&#13;
&#13;
    /*&#13;
     * Internal functions&#13;
     */&#13;
&#13;
    /// @dev Allows anyone to execute a confirmed transaction.&#13;
    /// @param transactionId Transaction ID.&#13;
    function executeTransaction(uint transactionId)&#13;
       internal&#13;
       notExecuted(transactionId)&#13;
    {&#13;
        if (isConfirmed(transactionId)) {&#13;
            Transaction tx = transactions[transactionId];&#13;
            tx.executed = true;&#13;
            if (tx.destination.call.value(tx.value)(tx.data))&#13;
                Execution(transactionId);&#13;
            else {&#13;
                ExecutionFailure(transactionId);&#13;
                tx.executed = false;&#13;
            }&#13;
        }&#13;
    }&#13;
&#13;
    /// @dev Adds a new transaction to the transaction mapping, if transaction does not exist yet.&#13;
    /// @param destination Transaction target address.&#13;
    /// @param value Transaction ether value.&#13;
    /// @param data Transaction data payload.&#13;
    /// @return Returns transaction ID.&#13;
    function addTransaction(address destination, uint value, bytes data)&#13;
        internal&#13;
        notNull(destination)&#13;
        returns (uint transactionId)&#13;
    {&#13;
        transactionId = transactionCount;&#13;
        transactions[transactionId] = Transaction({&#13;
            destination: destination,&#13;
            value: value,&#13;
            data: data,&#13;
            executed: false&#13;
        });&#13;
        transactionCount += 1;&#13;
        Submission(transactionId);&#13;
    }&#13;
&#13;
    /*&#13;
     * Web3 call functions&#13;
     */&#13;
    /// @dev Returns number of confirmations of a transaction.&#13;
    /// @param transactionId Transaction ID.&#13;
    /// @return Number of confirmations.&#13;
    function getConfirmationCount(uint transactionId)&#13;
        public&#13;
        constant&#13;
        returns (uint count)&#13;
    {&#13;
        for (uint i=0; i&lt;owners.length; i++)&#13;
            if (confirmations[transactionId][owners[i]])&#13;
                count += 1;&#13;
    }&#13;
&#13;
    /// @dev Returns total number of transactions after filers are applied.&#13;
    /// @param pending Include pending transactions.&#13;
    /// @param executed Include executed transactions.&#13;
    /// @return Total number of transactions after filters are applied.&#13;
    function getTransactionCount(bool pending, bool executed)&#13;
        public&#13;
        constant&#13;
        returns (uint count)&#13;
    {&#13;
        for (uint i=0; i&lt;transactionCount; i++)&#13;
            if ((pending &amp;&amp; !transactions[i].executed) ||&#13;
                (executed &amp;&amp; transactions[i].executed))&#13;
                count += 1;&#13;
    }&#13;
&#13;
    /// @dev Returns list of owners.&#13;
    /// @return List of owner addresses.&#13;
    function getOwners()&#13;
        public&#13;
        constant&#13;
        returns (address[])&#13;
    {&#13;
        return owners;&#13;
    }&#13;
&#13;
    /// @dev Returns array with owner addresses, which confirmed transaction.&#13;
    /// @param transactionId Transaction ID.&#13;
    /// @return Returns array of owner addresses.&#13;
    function getConfirmations(uint transactionId)&#13;
        public&#13;
        constant&#13;
        returns (address[] _confirmations)&#13;
    {&#13;
        address[] memory confirmationsTemp = new address[](owners.length);&#13;
        uint count = 0;&#13;
        uint i;&#13;
        for (i=0; i&lt;owners.length; i++)&#13;
            if (confirmations[transactionId][owners[i]]) {&#13;
                confirmationsTemp[count] = owners[i];&#13;
                count += 1;&#13;
            }&#13;
        _confirmations = new address[](count);&#13;
        for (i=0; i&lt;count; i++)&#13;
            _confirmations[i] = confirmationsTemp[i];&#13;
    }&#13;
&#13;
    /// @dev Returns list of transaction IDs in defined range.&#13;
    /// @param from Index start position of transaction array.&#13;
    /// @param to Index end position of transaction array.&#13;
    /// @param pending Include pending transactions.&#13;
    /// @param executed Include executed transactions.&#13;
    /// @return Returns array of transaction IDs.&#13;
    function getTransactionIds(uint from, uint to, bool pending, bool executed)&#13;
        public&#13;
        constant&#13;
        returns (uint[] _transactionIds)&#13;
    {&#13;
        uint[] memory transactionIdsTemp = new uint[](transactionCount);&#13;
        uint count = 0;&#13;
        uint i;&#13;
        for (i=0; i&lt;transactionCount; i++)&#13;
          if ((pending &amp;&amp; !transactions[i].executed) ||&#13;
              (executed &amp;&amp; transactions[i].executed))&#13;
            {&#13;
                transactionIdsTemp[count] = i;&#13;
                count += 1;&#13;
            }&#13;
        _transactionIds = new uint[](to - from);&#13;
        for (i=from; i&lt;to; i++)&#13;
            _transactionIds[i - from] = transactionIdsTemp[i];&#13;
    }&#13;
}&#13;
&#13;
contract UpgradeAgent is SafeMath {&#13;
  address public owner;&#13;
  bool public isUpgradeAgent;&#13;
  function upgradeFrom(address _from, uint256 _value) public;&#13;
  function setOriginalSupply() public;&#13;
}&#13;
&#13;
// @title BCDC Token vault, locked tokens for 1 month (Dev Team) and 1 year for Founders&#13;
contract BCDCVault is SafeMath {&#13;
&#13;
    // flag to determine if address is for a real contract or not&#13;
    bool public isBCDCVault = false;&#13;
&#13;
    BCDCToken bcdcToken;&#13;
&#13;
    // address of our private MultiSigWallet contract&#13;
    address bcdcMultisig;&#13;
    // number of block unlock for developers&#13;
    uint256 public unlockedBlockForDev;&#13;
    // number of block unlock for founders&#13;
    uint256 public unlockedBlockForFounders;&#13;
    // It should be 1 * 30 days * 24 hours * 60 minutes * 60 seconds / 17&#13;
    // We can set small for testing purpose&#13;
    uint256 public numBlocksLockedDev;&#13;
    // It should be 12 months * 30 days * 24 hours * 60 minutes * 60 seconds / 17&#13;
    // We can set small for testing purpose&#13;
    uint256 public numBlocksLockedFounders;&#13;
&#13;
    // flag to determine all the token for developers already unlocked or not&#13;
    bool public unlockedAllTokensForDev = false;&#13;
    // flag to determine all the token for founders already unlocked or not&#13;
    bool public unlockedAllTokensForFounders = false;&#13;
&#13;
    // Constructor function sets the BCDC Multisig address and&#13;
    // total number of locked tokens to transfer&#13;
    function BCDCVault(address _bcdcMultisig,uint256 _numBlocksLockedForDev,uint256 _numBlocksLockedForFounders) {&#13;
        // If it's not bcdcMultisig address then throw&#13;
        if (_bcdcMultisig == 0x0) throw;&#13;
        // Initalized bcdcToken&#13;
        bcdcToken = BCDCToken(msg.sender);&#13;
        // Initalized bcdcMultisig address&#13;
        bcdcMultisig = _bcdcMultisig;&#13;
        // Mark it as BCDCVault&#13;
        isBCDCVault = true;&#13;
        //Initalized numBlocksLockedDev and numBlocksLockedFounders with block number&#13;
        numBlocksLockedDev = _numBlocksLockedForDev;&#13;
        numBlocksLockedFounders = _numBlocksLockedForFounders;&#13;
        // Initalized unlockedBlockForDev with block number&#13;
        // according to current block&#13;
        unlockedBlockForDev = safeAdd(block.number, numBlocksLockedDev); // 30 days of blocks later&#13;
        // Initalized unlockedBlockForFounders with block number&#13;
        // according to current block&#13;
        unlockedBlockForFounders = safeAdd(block.number, numBlocksLockedFounders); // 365 days of blocks later&#13;
    }&#13;
&#13;
    // Transfer Development Team Tokens To MultiSigWallet - 30 Days Locked&#13;
    function unlockForDevelopment() external {&#13;
        // If it has not reached 30 days mark do not transfer&#13;
        if (block.number &lt; unlockedBlockForDev) throw;&#13;
        // If it is already unlocked then do not allowed&#13;
        if (unlockedAllTokensForDev) throw;&#13;
        // Mark it as unlocked&#13;
        unlockedAllTokensForDev = true;&#13;
        // Will fail if allocation (and therefore toTransfer) is 0.&#13;
        uint256 totalBalance = bcdcToken.balanceOf(this);&#13;
        // transfer half of token to development team&#13;
        uint256 developmentTokens = safeDiv(safeMul(totalBalance, 50), 100);&#13;
        if (!bcdcToken.transfer(bcdcMultisig, developmentTokens)) throw;&#13;
    }&#13;
&#13;
    //  Transfer Founders Team Tokens To MultiSigWallet - 365 Days Locked&#13;
    function unlockForFounders() external {&#13;
        // If it has not reached 365 days mark do not transfer&#13;
        if (block.number &lt; unlockedBlockForFounders) throw;&#13;
        // If it is already unlocked then do not allowed&#13;
        if (unlockedAllTokensForFounders) throw;&#13;
        // Mark it as unlocked&#13;
        unlockedAllTokensForFounders = true;&#13;
        // Will fail if allocation (and therefore toTransfer) is 0.&#13;
        if (!bcdcToken.transfer(bcdcMultisig, bcdcToken.balanceOf(this))) throw;&#13;
        // So that ether will not be trapped here.&#13;
        if (!bcdcMultisig.send(this.balance)) throw;&#13;
    }&#13;
&#13;
    // disallow payment after unlock block&#13;
    function () payable {&#13;
        if (block.number &gt;= unlockedBlockForFounders) throw;&#13;
    }&#13;
&#13;
}&#13;
&#13;
// @title BCDC Token Contract with Token Sale Functionality as well&#13;
contract BCDCToken is SafeMath, ERC20 {&#13;
&#13;
    // flag to determine if address is for a real contract or not&#13;
    bool public isBCDCToken = false;&#13;
    bool public upgradeAgentStatus = false;&#13;
    // Address of Owner for this Contract&#13;
    address public owner;&#13;
&#13;
    // Define the current state of crowdsale&#13;
    enum State{PreFunding, Funding, Success, Failure}&#13;
&#13;
    // Token related information&#13;
    string public constant name = "BCDC Token";&#13;
    string public constant symbol = "BCDC";&#13;
    uint256 public constant decimals = 18;  // decimal places&#13;
&#13;
    // Mapping of token balance and allowed address for each address with transfer limit&#13;
    mapping (address =&gt; uint256) balances;&#13;
    // This is only for refund purpose, as we have price range during different weeks of Crowdfunding,&#13;
    //  need to maintain total investment done so refund would be exactly same.&#13;
    mapping (address =&gt; uint256) investment;&#13;
    mapping (address =&gt; mapping (address =&gt; uint256)) allowed;&#13;
&#13;
    // Crowdsale information&#13;
    bool public finalizedCrowdfunding = false;&#13;
    // flag to determine is perallocation done or not&#13;
    bool public preallocated = false;&#13;
    uint256 public fundingStartBlock; // crowdsale start block&#13;
    uint256 public fundingEndBlock; // crowdsale end block&#13;
    // change price of token when current block reached&#13;
&#13;
    // Maximum Token Sale (Crowdsale + Early Sale + Supporters)&#13;
    // Approximate 250 millions ITS + 125 millions for early investors + 75 Millions to Supports&#13;
    uint256 public tokenSaleMax;&#13;
    // Min tokens needs to be sold out for success&#13;
    // Approximate 1/4 of 250 millions&#13;
    uint256 public tokenSaleMin;&#13;
    //1 Billion BCDC Tokens&#13;
    uint256 public constant maxTokenSupply = 1000000000 ether;&#13;
    // Team token percentages to store in time vault&#13;
    uint256 public constant vaultPercentOfTotal = 5;&#13;
    // Project Reserved Fund Token %&#13;
    uint256 public constant reservedPercentTotal = 25;&#13;
&#13;
    // Multisig Wallet Address&#13;
    address public bcdcMultisig;&#13;
    // Project Reserve Fund address&#13;
    address bcdcReserveFund;&#13;
    // BCDC's time-locked vault&#13;
    BCDCVault public timeVault;&#13;
&#13;
    // Events for refund process&#13;
    event Refund(address indexed _from, uint256 _value);&#13;
    event Upgrade(address indexed _from, address indexed _to, uint256 _value);&#13;
    event UpgradeFinalized(address sender, address upgradeAgent);&#13;
    event UpgradeAgentSet(address agent);&#13;
    // BCDC:ETH exchange rate&#13;
    uint256 tokensPerEther;&#13;
&#13;
    // @dev To Halt in Emergency Condition&#13;
    bool public halted;&#13;
&#13;
    bool public finalizedUpgrade = false;&#13;
    address public upgradeMaster;&#13;
    UpgradeAgent public upgradeAgent;&#13;
    uint256 public totalUpgraded;&#13;
&#13;
&#13;
    // Constructor function sets following&#13;
    // @param bcdcMultisig address of bcdcMultisigWallet&#13;
    // @param fundingStartBlock block number at which funding will start&#13;
    // @param fundingEndBlock block number at which funding will end&#13;
    // @param tokenSaleMax maximum number of token to sale&#13;
    // @param tokenSaleMin minimum number of token to sale&#13;
    // @param tokensPerEther number of token to sale per ether&#13;
    function BCDCToken(address _bcdcMultiSig,&#13;
                      address _upgradeMaster,&#13;
                      uint256 _fundingStartBlock,&#13;
                      uint256 _fundingEndBlock,&#13;
                      uint256 _tokenSaleMax,&#13;
                      uint256 _tokenSaleMin,&#13;
                      uint256 _tokensPerEther,&#13;
                      uint256 _numBlocksLockedForDev,&#13;
                      uint256 _numBlocksLockedForFounders) {&#13;
        // Is not bcdcMultisig address correct then throw&#13;
        if (_bcdcMultiSig == 0) throw;&#13;
        // Is funding already started then throw&#13;
        if (_upgradeMaster == 0) throw;&#13;
&#13;
        if (_fundingStartBlock &lt;= block.number) throw;&#13;
        // If fundingEndBlock or fundingStartBlock value is not correct then throw&#13;
        if (_fundingEndBlock   &lt;= _fundingStartBlock) throw;&#13;
        // If tokenSaleMax or tokenSaleMin value is not correct then throw&#13;
        if (_tokenSaleMax &lt;= _tokenSaleMin) throw;&#13;
        // If tokensPerEther value is 0 then throw&#13;
        if (_tokensPerEther == 0) throw;&#13;
        // Mark it is BCDCToken&#13;
        isBCDCToken = true;&#13;
        // Initalized all param&#13;
        upgradeMaster = _upgradeMaster;&#13;
        fundingStartBlock = _fundingStartBlock;&#13;
        fundingEndBlock = _fundingEndBlock;&#13;
        tokenSaleMax = _tokenSaleMax;&#13;
        tokenSaleMin = _tokenSaleMin;&#13;
        tokensPerEther = _tokensPerEther;&#13;
        // Initalized timeVault as BCDCVault&#13;
        timeVault = new BCDCVault(_bcdcMultiSig,_numBlocksLockedForDev,_numBlocksLockedForFounders);&#13;
        // If timeVault is not BCDCVault then throw&#13;
        if (!timeVault.isBCDCVault()) throw;&#13;
        // Initalized bcdcMultisig address&#13;
        bcdcMultisig = _bcdcMultiSig;&#13;
        // Initalized owner&#13;
        owner = msg.sender;&#13;
        // MultiSigWallet is not bcdcMultisig then throw&#13;
        if (!MultiSigWallet(bcdcMultisig).isMultiSigWallet()) throw;&#13;
    }&#13;
    // Ownership related modifer and functions&#13;
    // @dev Throws if called by any account other than the owner&#13;
    modifier onlyOwner() {&#13;
      if (msg.sender != owner) {&#13;
        throw;&#13;
      }&#13;
      _;&#13;
    }&#13;
&#13;
    // @dev Allows the current owner to transfer control of the contract to a newOwner.&#13;
    // @param newOwner The address to transfer ownership to.&#13;
    function transferOwnership(address newOwner) onlyOwner {&#13;
      if (newOwner != address(0)) {&#13;
        owner = newOwner;&#13;
      }&#13;
    }&#13;
&#13;
    // @param _bcdcReserveFund Ether Address for Project Reserve Fund&#13;
    // This has to be called before preAllocation&#13;
    // Only to be called by Owner of this contract&#13;
    function setBcdcReserveFund(address _bcdcReserveFund) onlyOwner{&#13;
        if (getState() != State.PreFunding) throw;&#13;
        if (preallocated) throw; // Has to be done before preallocation&#13;
        if (_bcdcReserveFund == 0x0) throw;&#13;
        bcdcReserveFund = _bcdcReserveFund;&#13;
    }&#13;
&#13;
    // @param who The address of the investor to check balance&#13;
    // @return balance tokens of investor address&#13;
    function balanceOf(address who) constant returns (uint) {&#13;
        return balances[who];&#13;
    }&#13;
&#13;
    // @param who The address of the investor to check investment amount&#13;
    // @return total investment done by ethereum address&#13;
    // This method is only usable up to Crowdfunding ends (Success or Fail)&#13;
    // So if tokens are transfered post crowdsale investment will not change.&#13;
    function checkInvestment(address who) constant returns (uint) {&#13;
        return investment[who];&#13;
    }&#13;
&#13;
    // @param owner The address of the account owning tokens&#13;
    // @param spender The address of the account able to transfer the tokens&#13;
    // @return Amount of remaining tokens allowed to spent&#13;
    function allowance(address owner, address spender) constant returns (uint) {&#13;
        return allowed[owner][spender];&#13;
    }&#13;
&#13;
    //  Transfer `value` BCDC tokens from sender's account&#13;
    // `msg.sender` to provided account address `to`.&#13;
    // @dev Required state: Success&#13;
    // @param to The address of the recipient&#13;
    // @param value The number of BCDC tokens to transfer&#13;
    // @return Whether the transfer was successful or not&#13;
    function transfer(address to, uint value) returns (bool ok) {&#13;
        if (getState() != State.Success) throw; // Abort if crowdfunding was not a success.&#13;
        uint256 senderBalance = balances[msg.sender];&#13;
        if ( senderBalance &gt;= value &amp;&amp; value &gt; 0) {&#13;
            senderBalance = safeSub(senderBalance, value);&#13;
            balances[msg.sender] = senderBalance;&#13;
            balances[to] = safeAdd(balances[to], value);&#13;
            Transfer(msg.sender, to, value);&#13;
            return true;&#13;
        }&#13;
        return false;&#13;
    }&#13;
&#13;
    //  Transfer `value` BCDC tokens from sender 'from'&#13;
    // to provided account address `to`.&#13;
    // @dev Required state: Success&#13;
    // @param from The address of the sender&#13;
    // @param to The address of the recipient&#13;
    // @param value The number of BCDC to transfer&#13;
    // @return Whether the transfer was successful or not&#13;
    function transferFrom(address from, address to, uint value) returns (bool ok) {&#13;
        if (getState() != State.Success) throw; // Abort if crowdfunding was not a success.&#13;
        if (balances[from] &gt;= value &amp;&amp;&#13;
            allowed[from][msg.sender] &gt;= value &amp;&amp;&#13;
            value &gt; 0)&#13;
        {&#13;
            balances[to] = safeAdd(balances[to], value);&#13;
            balances[from] = safeSub(balances[from], value);&#13;
            allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], value);&#13;
            Transfer(from, to, value);&#13;
            return true;&#13;
        } else { return false; }&#13;
    }&#13;
&#13;
    //  `msg.sender` approves `spender` to spend `value` tokens&#13;
    // @param spender The address of the account able to transfer the tokens&#13;
    // @param value The amount of wei to be approved for transfer&#13;
    // @return Whether the approval was successful or not&#13;
    function approve(address spender, uint value) returns (bool ok) {&#13;
        if (getState() != State.Success) throw; // Abort if not in Success state.&#13;
        allowed[msg.sender][spender] = value;&#13;
        Approval(msg.sender, spender, value);&#13;
        return true;&#13;
    }&#13;
&#13;
    // Sale of the tokens. Investors can call this method to invest into BCDC Tokens&#13;
    // Only when it's in funding mode. In case of emergecy it will be halted.&#13;
    function() payable stopIfHalted external {&#13;
        // Allow only to invest in funding state&#13;
        if (getState() != State.Funding) throw;&#13;
&#13;
        // Sorry !! We do not allow to invest with 0 as value&#13;
        if (msg.value == 0) throw;&#13;
&#13;
        // multiply by exchange rate to get newly created token amount&#13;
        uint256 createdTokens = safeMul(msg.value, tokensPerEther);&#13;
&#13;
        // Wait we crossed maximum token sale goal. It's successful token sale !!&#13;
        if (safeAdd(createdTokens, totalSupply) &gt; tokenSaleMax) throw;&#13;
&#13;
        // Call to Internal function to assign tokens&#13;
        assignTokens(msg.sender, createdTokens);&#13;
&#13;
        // Track the investment for each address till crowdsale ends&#13;
        investment[msg.sender] = safeAdd(investment[msg.sender], msg.value);&#13;
    }&#13;
&#13;
    // To allocate tokens to Project Fund - eg. RecycleToCoin before Token Sale&#13;
    // Tokens allocated to these will not be count in totalSupply till the Token Sale Success and Finalized in finalizeCrowdfunding()&#13;
    function preAllocation() onlyOwner stopIfHalted external {&#13;
        // Allow only in Pre Funding Mode&#13;
        if (getState() != State.PreFunding) throw;&#13;
        // Check if BCDC Reserve Fund is set or not&#13;
        if (bcdcReserveFund == 0x0) throw;&#13;
        // To prevent multiple call by mistake&#13;
        if (preallocated) throw;&#13;
        preallocated = true;&#13;
        // 25% of overall Token Supply to project reseve fund&#13;
        uint256 projectTokens = safeDiv(safeMul(maxTokenSupply, reservedPercentTotal), 100);&#13;
        // At this time we will not add to totalSupply because these are not part of Sale&#13;
        // It will be added in totalSupply once the Token Sale is Finalized&#13;
        balances[bcdcReserveFund] = projectTokens;&#13;
        // Log the event&#13;
        Transfer(0, bcdcReserveFund, projectTokens);&#13;
    }&#13;
&#13;
    // BCDC accepts Early Investment through manual process in Fiat Currency&#13;
    // BCDC Team will assign the tokens to investors manually through this function&#13;
    function earlyInvestment(address earlyInvestor, uint256 assignedTokens) onlyOwner stopIfHalted external {&#13;
        // Allow only in Pre Funding Mode And Funding Mode&#13;
        if (getState() != State.PreFunding &amp;&amp; getState() != State.Funding) throw;&#13;
        // Check if earlyInvestor address is set or not&#13;
        if (earlyInvestor == 0x0) throw;&#13;
        // By mistake tokens mentioned as 0, save the cost of assigning tokens.&#13;
        if (assignedTokens == 0 ) throw;&#13;
&#13;
        // Call to Internal function to assign tokens&#13;
        assignTokens(earlyInvestor, assignedTokens);&#13;
&#13;
        // Track the investment for each address&#13;
        // Refund for this investor is taken care by out side the contract.because they are investing in their fiat currency&#13;
        //investment[earlyInvestor] = safeAdd(investment[earlyInvestor], etherValue);&#13;
    }&#13;
&#13;
    // Function will transfer the tokens to investor's address&#13;
    // Common function code for Early Investor and Crowdsale Investor&#13;
    function assignTokens(address investor, uint256 tokens) internal {&#13;
        // Creating tokens and  increasing the totalSupply&#13;
        totalSupply = safeAdd(totalSupply, tokens);&#13;
&#13;
        // Assign new tokens to the sender&#13;
        balances[investor] = safeAdd(balances[investor], tokens);&#13;
&#13;
        // Finally token created for sender, log the creation event&#13;
        Transfer(0, investor, tokens);&#13;
    }&#13;
&#13;
    // Finalize crowdfunding&#13;
    // Finally - Transfer the Ether to Multisig Wallet&#13;
    function finalizeCrowdfunding() stopIfHalted external {&#13;
        // Abort if not in Funding Success state.&#13;
        if (getState() != State.Success) throw; // don't finalize unless we won&#13;
        if (finalizedCrowdfunding) throw; // can't finalize twice (so sneaky!)&#13;
&#13;
        // prevent more creation of tokens&#13;
        finalizedCrowdfunding = true;&#13;
&#13;
        // Check if Unsold tokens out 450 millions&#13;
        // 250 Millions Sale + 125 Millions for Early Investors + 75 Millions for Supporters&#13;
        uint256 unsoldTokens = safeSub(tokenSaleMax, totalSupply);&#13;
&#13;
        // Founders and Tech Team Tokens Goes to Vault, Locked for 1 month (Tech) and 1 year(Team)&#13;
        uint256 vaultTokens = safeDiv(safeMul(maxTokenSupply, vaultPercentOfTotal), 100);&#13;
        totalSupply = safeAdd(totalSupply, vaultTokens);&#13;
        balances[timeVault] = safeAdd(balances[timeVault], vaultTokens);&#13;
        Transfer(0, timeVault, vaultTokens);&#13;
&#13;
        // Only transact if there are any unsold tokens&#13;
        if(unsoldTokens &gt; 0) {&#13;
            totalSupply = safeAdd(totalSupply, unsoldTokens);&#13;
            // Remaining unsold tokens assign to multisig wallet&#13;
            balances[bcdcMultisig] = safeAdd(balances[bcdcMultisig], unsoldTokens);// Assign Reward Tokens to Multisig wallet&#13;
            Transfer(0, bcdcMultisig, unsoldTokens);&#13;
        }&#13;
&#13;
        // Add pre allocated tokens to project reserve fund to totalSupply&#13;
        uint256 preallocatedTokens = safeDiv(safeMul(maxTokenSupply, reservedPercentTotal), 100);&#13;
        // project tokens already counted, so only add preallcated tokens&#13;
        totalSupply = safeAdd(totalSupply, preallocatedTokens);&#13;
        // 250 millions reward tokens to multisig (equal to reservefund prellocation).&#13;
        // Reward to token holders on their commitment with BCDC (25 % of 1 billion = 250 millions)&#13;
        uint256 rewardTokens = safeDiv(safeMul(maxTokenSupply, reservedPercentTotal), 100);&#13;
        balances[bcdcMultisig] = safeAdd(balances[bcdcMultisig], rewardTokens);// Assign Reward Tokens to Multisig wallet&#13;
        totalSupply = safeAdd(totalSupply, rewardTokens);&#13;
&#13;
        // Total Supply Should not be greater than 1 Billion&#13;
        if (totalSupply &gt; maxTokenSupply) throw;&#13;
        // Transfer ETH to the BCDC Multisig address.&#13;
        if (!bcdcMultisig.send(this.balance)) throw;&#13;
    }&#13;
&#13;
    // Call this function to get the refund of investment done during Crowdsale&#13;
    // Refund can be done only when Min Goal has not reached and Crowdsale is over&#13;
    function refund() external {&#13;
        // Abort if not in Funding Failure state.&#13;
        if (getState() != State.Failure) throw;&#13;
&#13;
        uint256 bcdcValue = balances[msg.sender];&#13;
        if (bcdcValue == 0) throw;&#13;
        balances[msg.sender] = 0;&#13;
        totalSupply = safeSub(totalSupply, bcdcValue);&#13;
&#13;
        uint256 ethValue = investment[msg.sender];&#13;
        investment[msg.sender] = 0;&#13;
        Refund(msg.sender, ethValue);&#13;
        if (!msg.sender.send(ethValue)) throw;&#13;
    }&#13;
&#13;
    // This will return the current state of Token Sale&#13;
    // Read only method so no transaction fees&#13;
    function getState() public constant returns (State){&#13;
      if (block.number &lt; fundingStartBlock) return State.PreFunding;&#13;
      else if (block.number &lt;= fundingEndBlock &amp;&amp; totalSupply &lt; tokenSaleMax) return State.Funding;&#13;
      else if (totalSupply &gt;= tokenSaleMin || upgradeAgentStatus) return State.Success;&#13;
      else return State.Failure;&#13;
    }&#13;
&#13;
    // Token upgrade functionality&#13;
&#13;
    /// @notice Upgrade tokens to the new token contract.&#13;
    /// @dev Required state: Success&#13;
    /// @param value The number of tokens to upgrade&#13;
    function upgrade(uint256 value) external {&#13;
        if (!upgradeAgentStatus) throw;&#13;
        /*if (getState() != State.Success) throw; // Abort if not in Success state.*/&#13;
        if (upgradeAgent.owner() == 0x0) throw; // need a real upgradeAgent address&#13;
        if (finalizedUpgrade) throw; // cannot upgrade if finalized&#13;
&#13;
        // Validate input value.&#13;
        if (value == 0) throw;&#13;
        if (value &gt; balances[msg.sender]) throw;&#13;
&#13;
        // update the balances here first before calling out (reentrancy)&#13;
        balances[msg.sender] = safeSub(balances[msg.sender], value);&#13;
        totalSupply = safeSub(totalSupply, value);&#13;
        totalUpgraded = safeAdd(totalUpgraded, value);&#13;
        upgradeAgent.upgradeFrom(msg.sender, value);&#13;
        Upgrade(msg.sender, upgradeAgent, value);&#13;
    }&#13;
&#13;
    /// @notice Set address of upgrade target contract and enable upgrade&#13;
    /// process.&#13;
    /// @dev Required state: Success&#13;
    /// @param agent The address of the UpgradeAgent contract&#13;
    function setUpgradeAgent(address agent) external {&#13;
        if (getState() != State.Success) throw; // Abort if not in Success state.&#13;
        if (agent == 0x0) throw; // don't set agent to nothing&#13;
        if (msg.sender != upgradeMaster) throw; // Only a master can designate the next agent&#13;
        upgradeAgent = UpgradeAgent(agent);&#13;
        if (!upgradeAgent.isUpgradeAgent()) throw;&#13;
        // this needs to be called in success condition to guarantee the invariant is true&#13;
        upgradeAgentStatus = true;&#13;
        upgradeAgent.setOriginalSupply();&#13;
        UpgradeAgentSet(upgradeAgent);&#13;
    }&#13;
&#13;
    /// @notice Set address of upgrade target contract and enable upgrade&#13;
    /// process.&#13;
    /// @dev Required state: Success&#13;
    /// @param master The address that will manage upgrades, not the upgradeAgent contract address&#13;
    function setUpgradeMaster(address master) external {&#13;
        if (getState() != State.Success) throw; // Abort if not in Success state.&#13;
        if (master == 0x0) throw;&#13;
        if (msg.sender != upgradeMaster) throw; // Only a master can designate the next master&#13;
        upgradeMaster = master;&#13;
    }&#13;
&#13;
    // These modifier and functions related to halt the sale in case of emergency&#13;
&#13;
    // @dev Use this as function modifier that should not execute if contract state Halted&#13;
    modifier stopIfHalted {&#13;
      if(halted) throw;&#13;
      _;&#13;
    }&#13;
&#13;
    // @dev Use this as function modifier that should execute only if contract state Halted&#13;
    modifier runIfHalted{&#13;
      if(!halted) throw;&#13;
      _;&#13;
    }&#13;
&#13;
    // @dev called by only owner in case of any emergecy situation&#13;
    function halt() external onlyOwner{&#13;
      halted = true;&#13;
    }&#13;
&#13;
    // @dev called by only owner to stop the emergency situation&#13;
    function unhalt() external onlyOwner{&#13;
      halted = false;&#13;
    }&#13;
&#13;
    // This method is only use for transfer bcdctoken from bcdcReserveFund&#13;
    // @dev Required state: is bcdcReserveFund set&#13;
    // @param to The address of the recipient&#13;
    // @param value The number of BCDC tokens to transfer&#13;
    // @return Whether the transfer was successful or not&#13;
    function reserveTokenClaim(address claimAddress,uint256 token) onlyBcdcReserve returns (bool ok){&#13;
      // Check if BCDC Reserve Fund is set or not&#13;
      if ( bcdcReserveFund == 0x0) throw;&#13;
      uint256 senderBalance = balances[msg.sender];&#13;
      if(senderBalance &gt;= token &amp;&amp; token&gt;0){&#13;
        senderBalance = safeSub(senderBalance, token);&#13;
        balances[msg.sender] = senderBalance;&#13;
        balances[claimAddress] = safeAdd(balances[claimAddress], token);&#13;
        Transfer(msg.sender, claimAddress, token);&#13;
        return true;&#13;
      }&#13;
      return false;&#13;
    }&#13;
&#13;
    // This method is for getting bcdctoken as rewards&#13;
	  // @param tokens The number of tokens back for rewards&#13;
  	function backTokenForRewards(uint256 tokens) external{&#13;
  		// Check that token available for transfer&#13;
  		if(balances[msg.sender] &lt; tokens &amp;&amp; tokens &lt;= 0) throw;&#13;
&#13;
  		// Debit tokens from msg.sender&#13;
  		balances[msg.sender] = safeSub(balances[msg.sender], tokens);&#13;
&#13;
  		// Credit tokens into bcdcReserveFund&#13;
  		balances[bcdcReserveFund] = safeAdd(balances[bcdcReserveFund], tokens);&#13;
  		Transfer(msg.sender, bcdcReserveFund, tokens);&#13;
  	}&#13;
&#13;
    // bcdcReserveFund related modifer and functions&#13;
    // @dev Throws if called by any account other than the bcdcReserveFund owner&#13;
    modifier onlyBcdcReserve() {&#13;
      if (msg.sender != bcdcReserveFund) {&#13;
        throw;&#13;
      }&#13;
      _;&#13;
    }&#13;
}