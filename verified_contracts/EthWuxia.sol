pragma solidity ^0.4.21;

/**
* Issued by
*       _                              __ _     _
*      | |                            / _| |   (_)
*    __| | __ _ _ __  _ __  ___  ___ | |_| |_   _  ___
*   / _` |/ _` | '_ \| '_ \/ __|/ _ \|  _| __| | |/ _ \
*  | (_| | (_| | |_) | |_) \__ \ (_) | | | |_ _| | (_) |
*   \__,_|\__,_| .__/| .__/|___/\___/|_|  \__(_)_|\___/
*              | |   | |
*              |_|   |_|
*
* 以太武侠(ethwuxia)
* wangangang1991 @ gmail.com
*/

library SafeMath {

  /**
  * @dev Multiplies two numbers, throws on overflow.
  */
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }

  /**
  * @dev Integer division of two numbers, truncating the quotient.
  */
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    // assert(b > 0); // Solidity automatically throws when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return c;
  }

  /**
  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).
  */
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  /**
  * @dev Adds two numbers, throws on overflow.
  */
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }

  function max(uint a, uint b) internal pure returns (uint) {
    if (a > b) return a;
    else return b;
  }

  function min(uint a, uint b) internal pure returns (uint) {
    if (a < b) return a;
    else return b;
  }
}


/// @title Interface for contracts conforming to ERC-721: Non-Fungible Tokens
/// @author Dieter Shirley <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="0c686978694c6d74656361766962226f63">[email protected]</a>&gt; (https://github.com/dete)&#13;
contract ERC721 {&#13;
    // Required methods&#13;
    function totalSupply() public view returns (uint256 total);&#13;
    function balanceOf(address _owner) public view returns (uint256 balance);&#13;
    function ownerOf(uint256 _tokenId) public view returns (address owner);&#13;
    function approve(address _to, uint256 _tokenId) public;&#13;
    function transfer(address _to, uint256 _tokenId) public;&#13;
    function transferFrom(address _from, address _to, uint256 _tokenId) public;&#13;
&#13;
    // Events&#13;
    event Transfer(address from, address to, uint256 tokenId);&#13;
    event Approval(address owner, address approved, uint256 tokenId);&#13;
&#13;
    // Optional&#13;
    // function name() public view returns (string name);&#13;
    // function symbol() public view returns (string symbol);&#13;
    // function tokensOfOwner(address _owner) external view returns (uint256[] tokenIds);&#13;
    // function tokenMetadata(uint256 _tokenId, string _preferredTransport) public view returns (string infoUrl);&#13;
&#13;
    // ERC-165 Compatibility (https://github.com/ethereum/EIPs/issues/165)&#13;
    // function supportsInterface(bytes4 _interfaceID) external view returns (bool);&#13;
}&#13;
&#13;
contract EthWuxia is ERC721{&#13;
  using SafeMath for uint256;&#13;
&#13;
  event Bought (uint256 indexed _itemId, address indexed _owner, uint256 _price);&#13;
  event Sold (uint256 indexed _itemId, address indexed _owner, uint256 _price);&#13;
  event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);&#13;
  event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);&#13;
&#13;
  uint public produceUnitSeconds = 86400;  // 每1天进行一次高级卡投放&#13;
  uint public freeLotterySeconds = 3600 * 6;  // 每1天有一次免费抽卡的机会&#13;
  uint public unitRareGrowth = 3;  // 每单位时间 稀有卡投放数量&#13;
  uint public unitEpicGrowth = 0;  // 史诗卡投放数量&#13;
  uint public unitMythGrowth = 0;  // 传说卡投放数量&#13;
  uint public initialMartialTimes=1;  // 新的门派会有一定的概率加成 =&gt; 2被&#13;
  uint public stepPrice = 1 finney;&#13;
  uint public lotteryPrice = 10 finney;  // lotteryPrice&#13;
  uint public dragonGirlLotteryPrice = 10 finney;&#13;
  uint public dragonGirlLotteryNumber = 0;&#13;
  address[] public listedDragonGirlLotteryUser = [address(0), address(0), address(0), address(0), address(0)];&#13;
  address public wuxiaMaster = address(0);&#13;
  uint public wuxiaMasterPrice = 100 finney;  // 每次加价100finny;&#13;
  mapping (uint256 =&gt; address) public approvedOfItem;&#13;
  uint public littleMonster = 1 ether; // 游戏收入每到1ether就生成一个以太怪&#13;
&#13;
&#13;
  uint public totalEarning = 0;  // 总收入 =&gt; 总收入的10%用于生成EthMonster&#13;
  uint public totalTrading = 0;  // 总流水  &#13;
  uint public lotteryTotalEarning = 0;  // 抽卡收入 =&gt; 掌门人5%&#13;
  uint public marketTotalEarning = 0;  // 市场交易收入 =&gt; 武林盟主5%&#13;
  uint public smartSpeedEarning = 0;&#13;
  uint public luckyStoneEarning = 0;&#13;
  uint public hunterLicenceEarning = 0;&#13;
  uint public travelTotalEarning = 0;&#13;
  uint public masterTotalEarning = 0;&#13;
  // 开服活动 抽奖10次送狩猎证书&#13;
  bool public lotteryGiveHunt = false;&#13;
  uint public lotteryGiveHuntMinimalNumber = 10;&#13;
  uint public randNonce = 0;&#13;
&#13;
&#13;
  mapping (address =&gt; uint) public mapUserLastFreeLotteryTimestamp;  // 用户上次抽奖的时间&#13;
  mapping (address =&gt; uint) public mapUserPower;  // 实时维护用户的战斗力&#13;
&#13;
  // ability does not support trade&#13;
  mapping (address =&gt; bool) public mapUserHasSmartSpeed;  // 用户是否会凌波微步&#13;
  uint public currentSmartSpeedNumber = 0;&#13;
  // smartSpeedPrice = Min(0.1ether, 0.01ether*currentSmartSpeedNumber)&#13;
&#13;
  mapping (address =&gt; bool) public mapUserHasLuckyStone;  // 用户是否有幸运宝石&#13;
  uint public currentLuckyStoneNumber = 0;&#13;
  // luckyStonePrice = Min(0.1ether, 0.01*ether*currentLuckyStoneNumber)&#13;
&#13;
  mapping (address =&gt; bool) public mapUserHasHunterLicence;&#13;
  uint public currentHunterNumber = 0;&#13;
  // hunterPrice = Min(0.1ether, 0.01ether*currentHunterNumber)&#13;
&#13;
  uint public totalUserNumber = 0;&#13;
  uint public totalLotteryNumber = 0;&#13;
  uint public totalBuyCardNumber = 0;&#13;
  uint public totalSellCardNumber = 0;&#13;
  uint public totalDragonLotteryNumber = 0;&#13;
  mapping (uint =&gt; uint) public mapMartialUserCount;  // martial total user count&#13;
  mapping (uint =&gt; uint) public mapMartialLotteryCount;  // martial total lottery count&#13;
  mapping (address =&gt; uint) public mapUserLotteryNumber;&#13;
&#13;
  // 合约支持动态增加新据点&#13;
  struct Martial {&#13;
      uint x;  // 门派坐标&#13;
      uint y;  // 门派坐标&#13;
      address owner;  // 门派盟主&#13;
      uint lastProduceTime;  // 上一次的极品卡出产时间&#13;
      uint martialId;&#13;
      uint rareNumber;  // 稀有的&#13;
      uint epicNumber;  // 史诗的&#13;
      uint mythNumber;  // 传说的&#13;
      uint enterPrice;  // 入场费 =&gt; 剑冢入场费为1ether&#13;
      uint[] cardTypeList;  // 该门派出产的卡片&#13;
  }&#13;
&#13;
  // 充值额度的20%会被用作奖品&#13;
  // 每1个ether 有一个0.1ether的以太怪 以太怪的血量为2*最高攻击力玩家的战斗力&#13;
  // 每10个ether 有一个1ether的以太怪 以太怪血量为5*最高攻击力玩家的战斗力&#13;
  // 以太怪奖励的10%将发给门派创始人&#13;
  struct EtherMonster {&#13;
      uint monsterId;&#13;
      uint martialId;  // 该怪兽出现在哪个据点&#13;
      uint balance;  // 奖金 =&gt; 奖励点的5%&#13;
      uint blood;  // 血量 对于0.2ether的以太怪是3*最高攻击力玩家的战斗力 对于1ether的以太怪是10*最高攻击力玩家的战斗力&#13;
      uint produceTime;  // 怪兽出现的时间 怪物需要在指定的时间内被击杀 掌门人将获得20%的收益&#13;
      uint currentBlood;  // 当前血量&#13;
      bool defeated;  // 是否已经被消灭&#13;
      address winner;  // 获奖者&#13;
  }&#13;
&#13;
  mapping (address =&gt; uint) public mapUserLastAttackMonsterTimestamp;&#13;
  uint public userAttackMonsterCDSeconds = 600;  // 用户每10分钟可以攻击一次EtherMonster怪&#13;
  uint public maxUserPower = 0;  // 用于etherMonster血量估计&#13;
  address public maxPowerUserAddress = address(0);&#13;
  uint etherMonsterHuntSeconds = 3600;  // etherMonster的狩猎时间&#13;
  uint littleEtherMonsterUnit = 0.5 ether;  // 3倍最高战力&#13;
  uint bigEtherMonsterUnit = 5 ether;  // 10倍最高战力&#13;
&#13;
  struct CardType {&#13;
      uint typeId;&#13;
      uint martialId;  // 卡片从属于那个门派&#13;
      uint initPower;  // 初始战斗力&#13;
      uint growthFactor;  // 成长系数&#13;
      uint category;  // 卡片分类 =&gt; 1表示武侠 2表示武器 3表示武功 4表示阵法&#13;
  }&#13;
&#13;
  // 合成新卡的方式是: 两张旧卡片销毁 生成一张新卡片&#13;
  struct Card {&#13;
      uint cardId;&#13;
      uint typeId;&#13;
      uint level;  // 卡片等级 =&gt; 0表示普通 1表示稀有 2表示史诗 3表示传说&#13;
      bool onSell;&#13;
      uint sellPrice;&#13;
      address owner;&#13;
  }&#13;
&#13;
&#13;
  address private owner;&#13;
  mapping (address =&gt; bool) private admins;&#13;
&#13;
  IItemRegistry private itemRegistry;&#13;
  uint public travelUnitFee = 1 finney; // 0.001ether for each step&#13;
&#13;
  uint256[] private listedItems;&#13;
  Martial[] public listedMartials;  // 门派列表&#13;
  CardType[] public listedCardType;  // 卡牌列表&#13;
  Card[] public listedCard;&#13;
  EtherMonster[] public listedEtherMonster;&#13;
&#13;
  uint smallMonsterPowerFactor = 3;&#13;
  uint bigMonsterPowerFactor = 5;&#13;
&#13;
  mapping (uint256 =&gt; address) public mapOwnerOfCard;&#13;
  mapping (address =&gt; uint) private mapUserCurrentMartialId;  // 用户当前的门派&#13;
  mapping (address =&gt; bool) public mapUesrAlreadyMartialOwner;&#13;
  mapping (address =&gt; bytes32) public mapUserNickname;&#13;
&#13;
  bool public hasInitMartial = false;&#13;
  bool public hasInitCard1 = false;&#13;
  bool public hasInitCard2 = false;&#13;
&#13;
  function EthWuxia () public {&#13;
      owner = msg.sender;&#13;
      admins[owner] = true;&#13;
      lotteryGiveHunt = true;&#13;
  }&#13;
&#13;
  /* Modifiers */&#13;
  modifier onlyOwner() {&#13;
    require(owner == msg.sender);&#13;
    _;&#13;
  }&#13;
&#13;
  modifier onlyAdmins() {&#13;
    require(admins[msg.sender]);&#13;
    _;&#13;
  }&#13;
&#13;
  /* Owner */&#13;
  function setOwner (address _owner) onlyOwner() public {&#13;
    owner = _owner;&#13;
  }&#13;
&#13;
  function getOwner() public view returns(address){&#13;
      return owner;&#13;
  }&#13;
  function setItemRegistry (address _itemRegistry) onlyOwner() public {&#13;
    itemRegistry = IItemRegistry(_itemRegistry);&#13;
  }&#13;
&#13;
  function addAdmin (address _admin) onlyOwner() public {&#13;
    admins[_admin] = true;&#13;
  }&#13;
&#13;
  function removeAdmin (address _admin) onlyOwner() public {&#13;
    delete admins[_admin];&#13;
  }&#13;
  &#13;
  function disableLotteryGiveHunt() onlyOwner() public {&#13;
      lotteryGiveHunt = false;&#13;
  }&#13;
  &#13;
  function enableLotteryGiveHunt() onlyOwner() public {&#13;
      lotteryGiveHunt = true;&#13;
  }&#13;
&#13;
  // 功能列表&#13;
  // 1. 游戏更新 =&gt; 创建门派&#13;
  // 1.1 createNewMartial&#13;
  // 1.2 createNewCardType&#13;
  function createNewMartial (uint x, uint y, uint enterPrice) onlyOwner() public {&#13;
    require(x&gt;=1);&#13;
    require(y&gt;=1);&#13;
    Martial memory martial = Martial(x, y, address(0), now, listedMartials.length, unitRareGrowth * initialMartialTimes, unitEpicGrowth * initialMartialTimes, unitMythGrowth * initialMartialTimes, enterPrice, new uint[](0));&#13;
    listedMartials.push(martial);&#13;
  }&#13;
&#13;
  // 1.2 创建卡片类型&#13;
  function createNewCardType (uint martialId, uint initPower, uint growthFactor, uint category) onlyOwner() public {&#13;
    require(initPower&gt;=1);&#13;
    require(growthFactor&gt;=2);&#13;
    require(category&gt;=1);&#13;
    require(category&lt;=4);  // 武侠, 装备, 武功, 阵法&#13;
    require(martialId &lt; listedMartials.length);&#13;
    listedMartials[martialId].cardTypeList.push(listedCardType.length);&#13;
    CardType memory cardType = CardType(listedCardType.length, martialId, initPower, growthFactor, category);&#13;
    listedCardType.push(cardType);&#13;
  }&#13;
&#13;
  // 2. 用户操作&#13;
  // 2.1 凌波微步&#13;
  // 2.2 幸运宝石&#13;
  // 2.3 猎手&#13;
  // 2.4 旅行location&#13;
  // 2.5 抽奖&#13;
  // 2.6 卡片合成&#13;
  // 2.7 战斗力维护&#13;
  // 2.8 掌门人&#13;
  // 2.9 交易市场&#13;
  // 2.10 武林盟主 =&gt; 10percent of market exchage&#13;
  // 2.11 龙女彩票&#13;
  // 2.12 etherMonster&#13;
&#13;
  // 2.1 凌波微步&#13;
  function userHasSmartSpeed(address userAddress) public view returns(bool) {&#13;
    return mapUserHasSmartSpeed[userAddress];&#13;
  }&#13;
&#13;
  function getCurrentSmartSpeedPrice() public view returns(uint) {&#13;
    // Min(0.1ether, 0.01ether+0.01ether*current)&#13;
    return SafeMath.mul(SafeMath.min(10, currentSmartSpeedNumber), 10 finney);&#13;
  }&#13;
&#13;
  function buySmartSpeed () public payable {&#13;
    uint currentSmartSpeedPrice = SafeMath.mul(SafeMath.min(10, currentSmartSpeedNumber), 10 finney);&#13;
    require(msg.value &gt;= currentSmartSpeedPrice);&#13;
    require(!mapUserHasSmartSpeed[msg.sender]);&#13;
    uint excess = msg.value.sub(currentSmartSpeedPrice);&#13;
    currentSmartSpeedNumber += 1;&#13;
&#13;
    if (excess &gt; 0) {&#13;
      msg.sender.transfer(excess);&#13;
    }&#13;
    mapUserHasSmartSpeed[msg.sender] = true;&#13;
&#13;
    _tryCreateEtherMonster(totalEarning, totalEarning.add(currentSmartSpeedPrice));&#13;
    totalEarning = totalEarning.add(currentSmartSpeedPrice);&#13;
    totalTrading = totalTrading.add(currentSmartSpeedPrice);&#13;
    smartSpeedEarning = smartSpeedEarning.add(currentSmartSpeedPrice);&#13;
  }&#13;
&#13;
  // 2.2 幸运宝石&#13;
  function userHasLuckyStone(address userAddress) public view returns(bool) {&#13;
    return mapUserHasLuckyStone[userAddress];&#13;
  }&#13;
&#13;
  function getCurrentLuckyStonePrice() public view returns(uint) {&#13;
    // Min(0.1ether, 0.01ether+0.01ether*current)&#13;
    return SafeMath.mul(SafeMath.min(10, currentLuckyStoneNumber), 10 finney);&#13;
  }&#13;
&#13;
  function buyLuckyStone() public payable {&#13;
    uint currentLuckyStonePrice = SafeMath.mul(SafeMath.min(10, currentLuckyStoneNumber), 10 finney);&#13;
    require(msg.value &gt;= currentLuckyStonePrice);&#13;
    require(!mapUserHasLuckyStone[msg.sender]);&#13;
    uint excess = msg.value.sub(currentLuckyStonePrice);&#13;
    currentLuckyStoneNumber += 1;&#13;
    if (excess &gt; 0) {&#13;
      msg.sender.transfer(excess);&#13;
    }&#13;
    mapUserHasLuckyStone[msg.sender] = true;&#13;
    _tryCreateEtherMonster(totalEarning, totalEarning.add(currentLuckyStonePrice));&#13;
    totalEarning = totalEarning.add(currentLuckyStonePrice);&#13;
    totalTrading = totalTrading.add(currentLuckyStonePrice);&#13;
    luckyStoneEarning = luckyStoneEarning.add(currentLuckyStonePrice);&#13;
  }&#13;
&#13;
  function createEtherMonster(uint martialId, uint balance, uint blood) public onlyOwner {&#13;
      require(martialId&lt;listedMartials.length);&#13;
      require(balance&gt;0);&#13;
      require(blood&gt;0);&#13;
      require(balance&lt;address(this).balance);&#13;
      EtherMonster memory monster = EtherMonster(listedEtherMonster.length, martialId, balance, blood, now, blood, false, address(0));&#13;
      listedEtherMonster.push(monster);&#13;
  }&#13;
&#13;
&#13;
  // 2.3 狩猎证书&#13;
  function userHasHunterLicence(address userAddress) public view returns(bool) {&#13;
      return mapUserHasHunterLicence[userAddress];&#13;
  }&#13;
&#13;
  function getCurrentHunterLicencePrice() public view returns(uint) {&#13;
    return SafeMath.mul(SafeMath.min(10, currentHunterNumber), 10 finney);&#13;
  }&#13;
&#13;
  function buyHunterLicence() public payable {&#13;
    uint currentHunterLicencePrice = SafeMath.mul(SafeMath.min(10, currentHunterNumber), 10 finney);&#13;
    require(msg.value &gt;= currentHunterNumber);&#13;
    require(!mapUserHasHunterLicence[msg.sender]);&#13;
    uint excess = msg.value.sub(currentHunterLicencePrice);&#13;
    currentHunterNumber += 1;&#13;
    if (excess &gt; 0) {&#13;
      msg.sender.transfer(excess);&#13;
    }&#13;
    mapUserHasHunterLicence[msg.sender] = true;&#13;
&#13;
    _tryCreateEtherMonster(totalEarning, totalEarning.add(currentHunterLicencePrice));&#13;
    totalEarning = totalEarning.add(currentHunterLicencePrice);&#13;
    totalTrading = totalTrading.add(currentHunterLicencePrice);&#13;
    hunterLicenceEarning = hunterLicenceEarning.add(currentHunterLicencePrice);&#13;
  }&#13;
&#13;
  // 2.4 travel&#13;
  // 用户当前的Martial&#13;
  function getUserCurrentMartialId() public view returns(uint) {&#13;
      return mapUserCurrentMartialId[msg.sender];&#13;
  }&#13;
&#13;
  // workaround for struct&#13;
  // https://github.com/ethereum/remix-ide/issues/920#issuecomment-348069589&#13;
  function getMartialInfo(uint martialId) public view returns(uint, uint, address, uint, uint, uint, uint, uint, uint, uint[]) {&#13;
    require(martialId &lt; listedMartials.length);&#13;
    Martial memory martial = listedMartials[martialId];&#13;
    return (martial.x, martial.y, martial.owner, martial.lastProduceTime, martial.martialId, martial.rareNumber, martial.epicNumber, martial.mythNumber, martial.enterPrice, martial.cardTypeList);&#13;
  }&#13;
  &#13;
  function getMartialListInfo() public view returns(uint[]) {&#13;
      // rareNumber, epicNumber, mythNumber, ownerPower&#13;
      uint[] memory result = new uint[](listedMartials.length.mul(5)+1);&#13;
      uint index = 1;&#13;
      result[0] = listedMartials.length;&#13;
      for (uint i=0; i&lt;listedMartials.length;i++) {&#13;
          Martial memory martial = listedMartials[i];&#13;
          result[index] = martial.rareNumber;&#13;
          result[index+1] = martial.epicNumber;&#13;
          result[index+2] = martial.mythNumber;&#13;
          result[index+3] = mapUserPower[martial.owner];&#13;
          result[index+4] = mapMartialUserCount[i];&#13;
          index += 5;&#13;
      }&#13;
      return result;&#13;
  }&#13;
  &#13;
  function getMartialOwner() public view returns(address[]) {&#13;
    address[] memory result = new address[](listedMartials.length);&#13;
    for (uint i=0;i&lt;listedMartials.length;i++) {&#13;
        result[i] = listedMartials[i].owner;&#13;
    }&#13;
    return result;&#13;
  }&#13;
  &#13;
  function getMartialNumber() public view returns(uint) {&#13;
    return listedMartials.length;&#13;
  }&#13;
&#13;
  function absSub(uint a, uint b) private pure returns(uint) {&#13;
    if (a&gt;b) return a.sub(b);&#13;
    return b.sub(a);&#13;
  }&#13;
  // 用户当前旅行的成本&#13;
  function _getTravelPrice(address userAddress, uint martialId) private view returns(uint) {&#13;
    Martial storage currentMartial = listedMartials[mapUserCurrentMartialId[userAddress]];&#13;
    Martial storage nextMartial = listedMartials[martialId];&#13;
    require(currentMartial.martialId != nextMartial.martialId);  // 旅程起点、终点不能相同&#13;
    uint stepNumber = absSub(currentMartial.x, nextMartial.x).add(absSub(currentMartial.y, nextMartial.y));&#13;
    uint travelPrice = stepNumber.mul(stepPrice).add(nextMartial.enterPrice);&#13;
    // 凌波微步的旅行成本减半&#13;
    if (mapUserHasSmartSpeed[userAddress]) {&#13;
      travelPrice = travelPrice.div(2);&#13;
    }&#13;
    return travelPrice;&#13;
  }&#13;
&#13;
  function getTravelPrice(uint martialId) public view returns(uint) {&#13;
    return _getTravelPrice(msg.sender, martialId);&#13;
  }&#13;
&#13;
  // 旅行&#13;
  function changeMartial(uint martialId) public payable {&#13;
    uint travelPrice = _getTravelPrice(msg.sender, martialId);&#13;
    require(msg.value&gt;=travelPrice);&#13;
    require(martialId&lt;listedMartials.length);&#13;
    if (mapUserLotteryNumber[msg.sender] &gt; 0) {&#13;
        if (mapMartialUserCount[mapUserCurrentMartialId[msg.sender]] &gt; 0) {&#13;
            mapMartialUserCount[mapUserCurrentMartialId[msg.sender]] = mapMartialUserCount[mapUserCurrentMartialId[msg.sender]].sub(1);&#13;
        }&#13;
        mapMartialUserCount[martialId] += 1;&#13;
    }&#13;
    uint excess = msg.value.sub(travelPrice);&#13;
    if (excess&gt;0) {&#13;
      msg.sender.transfer(excess);&#13;
    }&#13;
    mapUserCurrentMartialId[msg.sender] = martialId;&#13;
    _tryCreateEtherMonster(totalEarning, totalEarning.add(travelPrice));&#13;
    totalEarning = totalEarning.add(travelPrice);&#13;
    travelTotalEarning = travelTotalEarning.add(travelPrice);&#13;
  }&#13;
&#13;
  // 2.5 lottery&#13;
  // get random number in [0, maxNumber)&#13;
  function getRandomNumber(uint maxNumber) private returns(uint) {&#13;
    require(maxNumber&gt;0);&#13;
    randNonce += 1;&#13;
    return uint(keccak256(now, randNonce, block.blockhash(block.number - 1), block.coinbase)) % maxNumber;&#13;
  }&#13;
  // 2.5 lottery&#13;
  // whether user can lottery for free&#13;
  function _canLotteryFree(address userAddress) private view returns(bool) {&#13;
    uint lastLotteryTimestamp = mapUserLastFreeLotteryTimestamp[userAddress];&#13;
    return now - lastLotteryTimestamp &gt; freeLotterySeconds;&#13;
  }&#13;
&#13;
// Test for Remix support of tuple params&#13;
//   uint public debugNumber = 0;&#13;
//   function setDebugNumber(uint a) {&#13;
//       debugNumber = a;&#13;
//   }&#13;
&#13;
//   function setDebugNumber2(uint a, uint b) {&#13;
//       debugNumber = b;&#13;
//   }&#13;
&#13;
//   function getDebugNumber() public view returns(uint) {&#13;
//       return debugNumber;&#13;
//   }&#13;
  function debug() public view returns(uint, uint, uint, uint, bool) {&#13;
      uint lastLotteryTimestamp = mapUserLastFreeLotteryTimestamp[msg.sender];&#13;
      return (now, lastLotteryTimestamp, now-lastLotteryTimestamp, freeLotterySeconds, now - lastLotteryTimestamp &gt; freeLotterySeconds);&#13;
  }&#13;
&#13;
  function getNowTimestamp() public view returns(uint) {&#13;
      return now;&#13;
  }&#13;
&#13;
  function getMyLastFreeLotteryTimestamp() public view returns(uint) {&#13;
    return mapUserLastFreeLotteryTimestamp[msg.sender];&#13;
  }&#13;
&#13;
  function canLotteryFree() public view returns(bool) {&#13;
    return _canLotteryFree(msg.sender);&#13;
  }&#13;
&#13;
  //获取某个门派的所有卡片&#13;
  function getMartialCardTypeIdList(uint martialId) public view returns(uint[]) {&#13;
    require(martialId&lt;listedMartials.length);&#13;
    return listedMartials[martialId].cardTypeList;&#13;
  }&#13;
&#13;
  function getCardTypeInfo(uint typeId) public view returns(uint, uint, uint, uint, uint) {&#13;
    require(typeId &lt; listedCardType.length);&#13;
    CardType memory cardType = listedCardType[typeId];&#13;
    return (cardType.typeId, cardType.martialId, cardType.initPower, cardType.growthFactor, cardType.category);&#13;
  }&#13;
&#13;
  function getCardPower(uint cardTypeId, uint cardLevel) public view returns(uint){&#13;
    require(cardLevel&lt;=3);&#13;
    require(cardTypeId&lt;listedCardType.length);&#13;
    CardType memory cardType = listedCardType[cardTypeId];&#13;
    if (cardLevel == 0) {&#13;
      return cardType.initPower;&#13;
    } else if (cardLevel == 1) {&#13;
      return cardType.initPower.mul(cardType.growthFactor);&#13;
    } else if (cardLevel == 2) {&#13;
      return cardType.initPower.mul(cardType.growthFactor).mul(cardType.growthFactor);&#13;
    } else if (cardLevel == 3) {&#13;
      return cardType.initPower.mul(cardType.growthFactor).mul(cardType.growthFactor).mul(cardType.growthFactor);&#13;
    }&#13;
  }&#13;
&#13;
  function getUserPower(address userAddress) public view returns(uint) {&#13;
      return mapUserPower[userAddress];&#13;
  }&#13;
  // 用户只能在自己的据点抽卡&#13;
  function lottery() public payable {&#13;
    require((msg.value &gt;= lotteryPrice || _canLotteryFree(msg.sender)));&#13;
    totalLotteryNumber = totalLotteryNumber.add(1);&#13;
    uint currentLotteryPrice = 0;&#13;
    if (_canLotteryFree(msg.sender)) {&#13;
      mapUserLastFreeLotteryTimestamp[msg.sender] = now;&#13;
    } else {&#13;
      currentLotteryPrice = lotteryPrice;&#13;
    }&#13;
    uint excess = msg.value.sub(currentLotteryPrice);&#13;
    // 掌门抽成&#13;
    uint userCurrentMartialId = mapUserCurrentMartialId[msg.sender];&#13;
    if (currentLotteryPrice &gt; 0) {&#13;
      address martialOwner = listedMartials[userCurrentMartialId].owner;&#13;
      if (martialOwner != address(0)) {&#13;
        uint martialOwnerCut = currentLotteryPrice.mul(30).div(100);&#13;
        martialOwner.transfer(martialOwnerCut);&#13;
        // martialOwner.transfer(currentLotteryPrice);&#13;
      }&#13;
    }&#13;
    if (excess&gt;0) {&#13;
      msg.sender.transfer(excess);&#13;
    }&#13;
  &#13;
    // cardType &amp;&amp; cardLevel&#13;
    // cardType&#13;
    uint martialCardTypeCount = listedMartials[userCurrentMartialId].cardTypeList.length;&#13;
    // 3个随机 50%概率本据点的卡 epic_number%抽到特殊卡 lotteryId抽到的卡片数量&#13;
    uint randomNumber = getRandomNumber(martialCardTypeCount.mul(1000));&#13;
&#13;
    uint lotteryCardTypeId = listedMartials[userCurrentMartialId].cardTypeList[randomNumber % martialCardTypeCount];&#13;
    // 据点玩家有50%的概率抽到本据点的卡&#13;
    if (randomNumber % 10 &gt;= 5) {&#13;
        lotteryCardTypeId = randomNumber % listedCardType.length;&#13;
    }&#13;
    randomNumber = randomNumber.div(10).div(martialCardTypeCount);&#13;
    // cardLevel&#13;
    if (now - listedMartials[userCurrentMartialId].lastProduceTime &gt;= produceUnitSeconds) {&#13;
      listedMartials[userCurrentMartialId].epicNumber += unitEpicGrowth;&#13;
      listedMartials[userCurrentMartialId].rareNumber += unitRareGrowth;&#13;
      listedMartials[userCurrentMartialId].mythNumber += unitMythGrowth;&#13;
      listedMartials[userCurrentMartialId].lastProduceTime = listedMartials[userCurrentMartialId].lastProduceTime.add(produceUnitSeconds);&#13;
    }&#13;
    uint lotteryCardLevel = 0;&#13;
    Martial memory userCurrentMartial = listedMartials[userCurrentMartialId];&#13;
    uint luckyStoneFactor = 1;&#13;
    if (mapUserHasLuckyStone[msg.sender]) {&#13;
      luckyStoneFactor = 2;&#13;
    }&#13;
&#13;
    // 如果用户拥有luckyStone 那么抽到好卡的概率翻倍&#13;
    // Free lottery can only get normal card&#13;
    if (randomNumber % 100 &lt; userCurrentMartial.mythNumber.mul(luckyStoneFactor) &amp;&amp; userCurrentMartial.mythNumber &gt; 0 &amp;&amp; currentLotteryPrice&gt;0) {&#13;
      lotteryCardLevel = 3;&#13;
      listedMartials[userCurrentMartialId].mythNumber = listedMartials[userCurrentMartialId].mythNumber.sub(1);&#13;
    } else if (randomNumber % 100 &lt; luckyStoneFactor.mul(userCurrentMartial.mythNumber.add(userCurrentMartial.epicNumber)) &amp;&amp; userCurrentMartial.epicNumber &gt; 0 &amp;&amp; currentLotteryPrice &gt; 0) {&#13;
      lotteryCardLevel = 2;&#13;
      listedMartials[userCurrentMartialId].epicNumber = listedMartials[userCurrentMartialId].epicNumber.sub(1);&#13;
    } else if (randomNumber % 100 &lt; luckyStoneFactor.mul(userCurrentMartial.mythNumber.add(userCurrentMartial.epicNumber.add(userCurrentMartial.rareNumber))) &amp;&amp; userCurrentMartial.rareNumber &gt; 0 &amp;&amp; currentLotteryPrice &gt; 0) {&#13;
      lotteryCardLevel = 1;&#13;
      listedMartials[userCurrentMartialId].rareNumber = listedMartials[userCurrentMartialId].rareNumber.sub(1);&#13;
    }&#13;
&#13;
    // issue card&#13;
    Card memory card = Card(listedCard.length, lotteryCardTypeId, lotteryCardLevel, false, 0, msg.sender);&#13;
    mapOwnerOfCard[listedCard.length] = msg.sender;&#13;
    if (mapUserLotteryNumber[msg.sender] == 0) {&#13;
        totalUserNumber = totalUserNumber.add(1);&#13;
        mapMartialUserCount[mapUserCurrentMartialId[msg.sender]] += 1;&#13;
    }&#13;
    mapUserLotteryNumber[msg.sender] += 1;&#13;
    if (lotteryGiveHunt &amp;&amp; mapUserLotteryNumber[msg.sender] &gt;= lotteryGiveHuntMinimalNumber) {&#13;
        if (mapUserHasHunterLicence[msg.sender] == false) {&#13;
            mapUserHasHunterLicence[msg.sender] = true;&#13;
        }&#13;
    }&#13;
    mapMartialLotteryCount[mapUserCurrentMartialId[msg.sender]] += 1;&#13;
    mapUserPower[msg.sender] = mapUserPower[msg.sender].add(getCardPower(lotteryCardTypeId, lotteryCardLevel));&#13;
    if (mapUserPower[msg.sender] &gt; maxUserPower) {&#13;
      maxUserPower = mapUserPower[msg.sender];&#13;
      maxPowerUserAddress = msg.sender;&#13;
    }&#13;
    listedCard.push(card);&#13;
&#13;
    _tryCreateEtherMonster(totalEarning, totalEarning.add(currentLotteryPrice));&#13;
    totalEarning = totalEarning.add(currentLotteryPrice);&#13;
    totalTrading = totalTrading.add(currentLotteryPrice);&#13;
    lotteryTotalEarning = lotteryTotalEarning.add(currentLotteryPrice);&#13;
  }&#13;
&#13;
  function getCardNumber() public view returns(uint) {&#13;
      return listedCard.length;&#13;
  }&#13;
&#13;
  function getCardInfo(uint cardId) public view returns(uint, uint, uint, bool, uint, address) {&#13;
      require(cardId&lt;listedCard.length);&#13;
      Card memory card = listedCard[cardId];&#13;
      return (card.cardId, card.typeId, card.level, card.onSell, card.sellPrice, card.owner);&#13;
  }&#13;
  &#13;
  function getGameStats() public view returns(uint, uint, uint, uint, uint, address) {&#13;
      return (totalUserNumber, totalBuyCardNumber, totalLotteryNumber, totalEarning, totalTrading, wuxiaMaster);&#13;
  }&#13;
&#13;
  // 2.6 卡片合成&#13;
  // 两张卡必须不能在卖出状态&#13;
  function mergeCard(uint a, uint b) public {&#13;
    require(a&lt;listedCard.length);&#13;
    require(b&lt;listedCard.length);&#13;
    require(listedCard[a].typeId==listedCard[b].typeId);&#13;
    require(listedCard[a].level==listedCard[b].level);&#13;
    require(listedCard[a].level&lt;=2);  // 0 for normal, 1 for rare, 2 for epic, 3 for myth&#13;
    require(!listedCard[a].onSell);&#13;
    require(!listedCard[b].onSell);&#13;
    require(mapOwnerOfCard[a]==msg.sender);&#13;
    require(mapOwnerOfCard[b]==msg.sender);&#13;
    Card memory card = Card(listedCard.length, listedCard[a].typeId, listedCard[a].level.add(1), false, 0, msg.sender);&#13;
    mapOwnerOfCard[a] = address(0);&#13;
    mapOwnerOfCard[b] = address(0);&#13;
    listedCard[a].owner = address(0);&#13;
    listedCard[b].owner = address(0);&#13;
    mapOwnerOfCard[listedCard.length] = msg.sender;&#13;
    listedCard.push(card);&#13;
    // 需要维护用户的战斗力&#13;
    mapUserPower[msg.sender] = mapUserPower[msg.sender].add(getCardPower(listedCard[a].typeId, listedCard[a].level.add(1)).sub(getCardPower(listedCard[a].typeId, listedCard[a].level).mul(2)));&#13;
    if (mapUserPower[msg.sender] &gt; maxUserPower) {&#13;
      maxUserPower = mapUserPower[msg.sender];&#13;
      maxPowerUserAddress = msg.sender;&#13;
    }&#13;
  }&#13;
&#13;
  // 2.7 掌门人&#13;
  // 争夺掌门人&#13;
  function beatMartialOwner() public returns (bool){&#13;
    uint myMartialId = mapUserCurrentMartialId[msg.sender];&#13;
    address martialOwner = listedMartials[myMartialId].owner;&#13;
    require(msg.sender!=martialOwner);&#13;
    require(!mapUesrAlreadyMartialOwner[msg.sender]);&#13;
    // 空的门派可以直接被占领&#13;
    if (martialOwner==address(0)) {&#13;
      listedMartials[myMartialId].owner = msg.sender;&#13;
      mapUesrAlreadyMartialOwner[msg.sender] = true;&#13;
      mapUesrAlreadyMartialOwner[martialOwner] = false;&#13;
      return true;&#13;
    } else {&#13;
      if (mapUserPower[msg.sender] &gt; mapUserPower[martialOwner]) {&#13;
        listedMartials[myMartialId].owner = msg.sender;&#13;
        mapUesrAlreadyMartialOwner[msg.sender] = true;&#13;
        mapUesrAlreadyMartialOwner[martialOwner] = false;&#13;
        return true;&#13;
      } else {&#13;
        return false;&#13;
      }&#13;
    }&#13;
  }&#13;
&#13;
  // 2.8 wuxiaMaster&#13;
  // 回本周期长, 投资需谨慎&#13;
  // 武林盟主将获得所有卡牌交易费用的5% 每获得1.1单位收益 武林盟主的价格会下降1 也就是说你最多可以获得投资的110%的收益&#13;
  // 设立wuxiaMaster的主要目的是希望有看得起这个游戏的人 投一点钱 让我请女朋友吃顿自助&#13;
  // 希望不会让你亏损~&#13;
  function currentWulinMasterPrice() public view returns(uint){&#13;
    return wuxiaMasterPrice;&#13;
  }&#13;
&#13;
  function buyWuxiaMaster() payable public {&#13;
    require(msg.value&gt;=wuxiaMasterPrice);&#13;
    require(msg.sender!=wuxiaMaster);&#13;
    // 给老的owner转出当时买入的价钱&#13;
    wuxiaMaster.transfer(wuxiaMasterPrice - 100 finney);&#13;
    uint excess = msg.value.sub(wuxiaMasterPrice);&#13;
    // 转出余额&#13;
    if (excess&gt;0) {&#13;
      msg.sender.transfer(excess);&#13;
    }&#13;
    // wuxiaMaster其实是亏钱买卖 不计入totalEarning&#13;
    masterTotalEarning = masterTotalEarning.add(wuxiaMasterPrice);&#13;
    totalTrading = totalTrading.add(wuxiaMasterPrice);&#13;
&#13;
    // 更新武林盟主&#13;
    wuxiaMaster = msg.sender;&#13;
    wuxiaMasterPrice = wuxiaMasterPrice.add(100 finney);&#13;
  }&#13;
&#13;
&#13;
  // 2.9 card Trading&#13;
  function sellCard(uint cardId, uint price) public {&#13;
    require(cardId&lt;listedCard.length);&#13;
    totalSellCardNumber = totalSellCardNumber.add(1);&#13;
    address cardOwner = mapOwnerOfCard[cardId];&#13;
    require(cardOwner!=address(0));  // 不能卖出被销毁的卡&#13;
    require(cardOwner==msg.sender);  // 只能卖出自己的卡&#13;
    require(!listedCard[cardId].onSell); // 不能卖出已在卖出状态的卡&#13;
    listedCard[cardId].onSell = true;&#13;
    listedCard[cardId].sellPrice = price;&#13;
  }&#13;
&#13;
  function cancelSell(uint cardId) public {&#13;
    require(cardId&lt;listedCard.length);&#13;
    address cardOwner = mapOwnerOfCard[cardId];&#13;
    require(cardOwner!=address(0));&#13;
    require(cardOwner==msg.sender);  // 只能取消自己的卡&#13;
    require(listedCard[cardId].onSell); // 必须在待卖出状态&#13;
    listedCard[cardId].onSell = false;&#13;
  }&#13;
&#13;
  // 用户卖出卡片 需要支付5%的佣金 其中2%给开发者 3%给武林盟主&#13;
  function buyCard(uint cardId) payable public {&#13;
    require(mapOwnerOfCard[cardId]!=address(0));&#13;
    require(msg.sender!=mapOwnerOfCard[cardId]);&#13;
    require(listedCard[cardId].onSell);&#13;
    uint buyPrice = listedCard[cardId].sellPrice;&#13;
    totalBuyCardNumber = totalBuyCardNumber.add(1);&#13;
    require(msg.value&gt;=buyPrice);&#13;
    // 处理余额&#13;
    uint excess = msg.value.sub(buyPrice);&#13;
    if (excess&gt;0) {&#13;
      msg.sender.transfer(excess);&#13;
    }&#13;
    // 给开发5%&#13;
    uint devCut = buyPrice.div(100).mul(0);&#13;
    uint masterCut = buyPrice.div(100).mul(5);&#13;
    if (wuxiaMaster==address(0)) {&#13;
      devCut = devCut.add(masterCut);&#13;
      masterCut = 0;&#13;
    } else {&#13;
      wuxiaMaster.transfer(masterCut);&#13;
    }&#13;
    // 修改wuxiaMaster的price&#13;
    // 保证MasterPrice&gt;=100 finney&#13;
    uint masterPriceMinus = masterCut.mul(100).div(110);&#13;
    if (wuxiaMasterPrice &gt;= masterPriceMinus.add(100 finney)) {&#13;
        wuxiaMasterPrice = wuxiaMasterPrice.sub(masterPriceMinus);&#13;
    } else {&#13;
        wuxiaMasterPrice = 100 finney;&#13;
    }&#13;
    // 给用户95%&#13;
    uint moneyToSeller = buyPrice.sub(devCut.add(masterCut));&#13;
    mapOwnerOfCard[cardId].transfer(moneyToSeller);&#13;
    // 维护战力&#13;
    uint cardPower = getCardPower(listedCard[cardId].typeId, listedCard[cardId].level);&#13;
    // change onSell&#13;
    listedCard[cardId].onSell = false;&#13;
    mapUserPower[mapOwnerOfCard[cardId]] = mapUserPower[mapOwnerOfCard[cardId]].sub(cardPower);&#13;
    mapUserPower[msg.sender] = mapUserPower[msg.sender].add(cardPower);&#13;
    // // 所有权转移&#13;
    mapOwnerOfCard[cardId] = msg.sender;&#13;
    listedCard[cardId].owner = msg.sender;&#13;
    // etherMonster&#13;
    _tryCreateEtherMonster(totalEarning, totalEarning.add(devCut));&#13;
    totalEarning = totalEarning.add(devCut);&#13;
    totalTrading = totalTrading.add(buyPrice);&#13;
    marketTotalEarning = marketTotalEarning.add(devCut);&#13;
  }&#13;
&#13;
  // 2.10 龙女彩票 =&gt; 每5张彩票开奖一次&#13;
  // 获得一张普通的小龙女 cardType为0的卡片定义为小龙女&#13;
  function getCurrentDragonGirlLotteryNumber() public view returns(uint) {&#13;
    return dragonGirlLotteryNumber;&#13;
  }&#13;
&#13;
  function buyLittleDragonGirlLottery() public payable{&#13;
    require(msg.value&gt;=dragonGirlLotteryPrice);&#13;
    require(listedCardType.length&gt;0);&#13;
    totalDragonLotteryNumber = totalDragonLotteryNumber.add(1);&#13;
    listedDragonGirlLotteryUser[dragonGirlLotteryNumber] = msg.sender;&#13;
    dragonGirlLotteryNumber = dragonGirlLotteryNumber.add(1);&#13;
&#13;
    if (dragonGirlLotteryNumber == 5) {&#13;
      // 抽奖&#13;
      uint randomNumber = getRandomNumber(5);&#13;
      address winner = listedDragonGirlLotteryUser[randomNumber];&#13;
      mapOwnerOfCard[listedCard.length] = winner;&#13;
      Card memory card = Card(listedCard.length, 0, 0, false, 0, winner);&#13;
      listedCard.push(card);&#13;
      // 更新获奖者战力&#13;
      mapUserPower[winner] = mapUserPower[winner].add(getCardPower(0, 0));&#13;
      dragonGirlLotteryNumber = 0;&#13;
    }&#13;
  }&#13;
&#13;
  // 收入的30%反馈给掌门人和猎以太怪人&#13;
  function _tryCreateEtherMonster(uint price_a, uint price_b) private {&#13;
    uint priceTimes = price_b.div(0.5 ether);&#13;
    // 40% for little monster&#13;
    if (price_a&lt;priceTimes*0.5 ether &amp;&amp; price_b&gt;=priceTimes*0.5 ether) {&#13;
      // 生成小怪兽&#13;
      uint martialId = getRandomNumber(listedMartials.length);&#13;
      EtherMonster memory monster = EtherMonster(listedEtherMonster.length, martialId, 0.2 ether, maxUserPower.mul(smallMonsterPowerFactor), now, maxUserPower.mul(smallMonsterPowerFactor), false, address(0));&#13;
      listedEtherMonster.push(monster);&#13;
    }&#13;
    priceTimes = price_b.div(5 ether);&#13;
    // 20% for large monster&#13;
    if (price_a&lt;priceTimes*5 ether &amp;&amp; price_b&gt;=priceTimes*5 ether) {&#13;
      // 生成大怪兽&#13;
      uint bigMartialId = (getRandomNumber(listedEtherMonster.length).add(10007)) % listedMartials.length;&#13;
      EtherMonster memory bigMonster = EtherMonster(listedEtherMonster.length, bigMartialId, 1 ether, maxUserPower.mul(bigMonsterPowerFactor), now, maxUserPower.mul(bigMonsterPowerFactor), false, address(0));&#13;
      listedEtherMonster.push(bigMonster);&#13;
    }&#13;
  }&#13;
&#13;
  function getEtherMonsterNumber() public view returns(uint) {&#13;
    return listedEtherMonster.length;&#13;
  }&#13;
&#13;
  function getCanAttackMonsterIds() public view returns(uint[]) {&#13;
      uint[] memory result = new uint[](listedEtherMonster.length+1);&#13;
      uint index=0;&#13;
      for (uint i=0; i&lt;listedEtherMonster.length; i++) {&#13;
        EtherMonster memory monster = listedEtherMonster[i];&#13;
        if (monster.produceTime.add(etherMonsterHuntSeconds)&gt;now &amp;&amp; !monster.defeated) {&#13;
            result[index] = i+1;&#13;
            index += 1;&#13;
        }&#13;
      }&#13;
      return result;&#13;
    }&#13;
&#13;
  function getOnSellCardIds() public view returns(uint[]) {&#13;
      uint[] memory result = new uint[](listedCard.length+1);&#13;
      uint index = 0;&#13;
      for (uint i=0; i&lt;listedCard.length; i++) {&#13;
          if (listedCard[i].onSell) {&#13;
              result[index] = i+1;&#13;
              index += 1;&#13;
          }&#13;
      }&#13;
      return result;&#13;
  }&#13;
&#13;
  function getEtherMonsterInfo(uint monsterId) public view returns(uint, uint, uint, uint, uint, uint, bool, address) {&#13;
      require(monsterId&lt;listedEtherMonster.length);&#13;
      EtherMonster memory monster = listedEtherMonster[monsterId];&#13;
      return (monster.monsterId, monster.martialId, monster.balance, monster.blood, monster.produceTime, monster.currentBlood, monster.defeated, monster.winner);&#13;
  }&#13;
&#13;
  // 掌门人会获得&#13;
  function attackMonster(uint monsterId) public {&#13;
    // 每个人只能攻击一次&#13;
    require(!listedEtherMonster[monsterId].defeated);  // 没有被打败过&#13;
    require(address(this).balance&gt;=listedEtherMonster[monsterId].balance);  // 要有足够的奖金&#13;
    require(mapUserLastAttackMonsterTimestamp[msg.sender].add(userAttackMonsterCDSeconds) &lt; now);&#13;
    require(listedEtherMonster[monsterId].produceTime.add(etherMonsterHuntSeconds) &gt; now);&#13;
    require(mapUserHasHunterLicence[msg.sender]);  // 用户有狩猎凭证&#13;
    // 只要在该门派的人才能攻击&#13;
    require(mapUserCurrentMartialId[msg.sender]==listedEtherMonster[monsterId].martialId);&#13;
    // 判断monster当前的血量&#13;
    uint monsterCurrentBlood = listedEtherMonster[monsterId].currentBlood;&#13;
    uint monsterTotalBlood = listedEtherMonster[monsterId].blood;&#13;
    mapUserLastAttackMonsterTimestamp[msg.sender] = now;&#13;
    if (mapUserPower[msg.sender] &gt;= monsterCurrentBlood) {&#13;
      // 战力取胜&#13;
      listedEtherMonster[monsterId].defeated = true;&#13;
      listedEtherMonster[monsterId].winner = msg.sender;&#13;
      _sendMonsterPrize(monsterId, msg.sender);&#13;
    } else {&#13;
      // 判断能否概率取胜&#13;
      uint randomNumber = getRandomNumber(monsterTotalBlood);&#13;
      if (randomNumber &lt; mapUserPower[msg.sender]) {&#13;
        listedEtherMonster[monsterId].defeated = true;&#13;
        listedEtherMonster[monsterId].winner = msg.sender;&#13;
        _sendMonsterPrize(monsterId, msg.sender);&#13;
      } else {&#13;
        listedEtherMonster[monsterId].currentBlood = monsterCurrentBlood.sub(mapUserPower[msg.sender]);&#13;
      }&#13;
    }&#13;
  }&#13;
&#13;
  function _sendMonsterPrize(uint monsterId, address winner) private {&#13;
    uint totalPrize = listedEtherMonster[monsterId].balance;&#13;
    uint martialOwnerCut = 0;&#13;
    if (listedMartials[listedEtherMonster[monsterId].martialId].owner != address(0)) {&#13;
      martialOwnerCut = totalPrize.mul(10).div(100);&#13;
    }&#13;
    winner.transfer(totalPrize.sub(martialOwnerCut));&#13;
    listedMartials[listedEtherMonster[monsterId].martialId].owner.transfer(martialOwnerCut);&#13;
  }&#13;
&#13;
  // 2.12 用户设nickname&#13;
  function setNickname(bytes32 nickname) public {&#13;
    mapUserNickname[msg.sender] = nickname;&#13;
  }&#13;
&#13;
  function getAddressNickname(address userAddress) public view returns(bytes32){&#13;
    return mapUserNickname[userAddress];&#13;
  }&#13;
&#13;
  // 2.13 统计指标&#13;
  function listedMartialsLength() public view returns(uint length) {&#13;
      return listedMartials.length;&#13;
  }&#13;
&#13;
&#13;
    function initMartial() onlyOwner() public {&#13;
        require(!hasInitMartial);&#13;
        createNewMartial(16,14,0);&#13;
        createNewMartial(10,11,0);&#13;
        createNewMartial(13,10,0);&#13;
        createNewMartial(12,12,0);&#13;
        createNewMartial(4,3,0);&#13;
        createNewMartial(11,10,0);&#13;
        createNewMartial(6,14,0);&#13;
        createNewMartial(9,9,0);&#13;
        createNewMartial(10,10,0);&#13;
        createNewMartial(9,7,0);&#13;
        createNewMartial(12,10,0);&#13;
        hasInitMartial = true;&#13;
    }&#13;
&#13;
  function initCard1() onlyOwner() public {&#13;
    require(!hasInitCard1);&#13;
    createNewCardType(1,8,10,1);&#13;
    createNewCardType(1,10,10,1);&#13;
    createNewCardType(1,8,10,1);&#13;
    createNewCardType(1,5,12,3);&#13;
    createNewCardType(1,4,12,3);&#13;
    createNewCardType(1,200,3,2);&#13;
    createNewCardType(1,200,3,2);&#13;
    createNewCardType(0,1,2,1);&#13;
    createNewCardType(0,1,30,3);&#13;
    createNewCardType(0,5,2,2);&#13;
    createNewCardType(0,3,2,2);&#13;
    createNewCardType(0,2,2,3);&#13;
    createNewCardType(0,4,2,3);&#13;
    createNewCardType(0,8,2,2);&#13;
    createNewCardType(2,12,10,1);&#13;
    createNewCardType(2,10,10,1);&#13;
    createNewCardType(2,5,12,3);&#13;
    createNewCardType(2,5,12,3);&#13;
    createNewCardType(2,4,12,3);&#13;
    createNewCardType(2,5,20,4);&#13;
    createNewCardType(2,18,15,4);&#13;
    createNewCardType(3,13,10,1);&#13;
    createNewCardType(3,5,13,3);&#13;
    createNewCardType(3,5,12,3);&#13;
    createNewCardType(3,5,10,3);&#13;
    createNewCardType(3,10,8,3);&#13;
    createNewCardType(3,80,5,2);&#13;
    createNewCardType(3,7,20,4);&#13;
    createNewCardType(4,11,10,1);&#13;
    createNewCardType(4,10,10,1);&#13;
    createNewCardType(4,9,10,1);&#13;
    createNewCardType(4,5,12,3);&#13;
    createNewCardType(4,5,11,3);&#13;
    createNewCardType(4,5,10,3);&#13;
    createNewCardType(4,200,3,2);&#13;
    hasInitCard1 = true;&#13;
  }&#13;
&#13;
    function initCard2() onlyOwner() public {&#13;
    require(!hasInitCard2);&#13;
    createNewCardType(5,10,10,1);&#13;
    createNewCardType(5,8,10,1);&#13;
    createNewCardType(5,5,8,1);&#13;
    createNewCardType(5,3,10,3);&#13;
    createNewCardType(5,5,12,3);&#13;
    createNewCardType(5,3,11,3);&#13;
    createNewCardType(5,70,4,2);&#13;
    createNewCardType(6,10,10,1);&#13;
    createNewCardType(6,6,8,1);&#13;
    createNewCardType(6,5,8,1);&#13;
    createNewCardType(6,4,12,3);&#13;
    createNewCardType(6,5,12,3);&#13;
    createNewCardType(6,5,12,3);&#13;
    createNewCardType(6,80,5,2);&#13;
    createNewCardType(7,10,12,1);&#13;
    createNewCardType(7,100,4,2);&#13;
    createNewCardType(7,100,5,2);&#13;
    createNewCardType(7,100,4,2);&#13;
    createNewCardType(7,100,4,2);&#13;
    createNewCardType(7,100,4,2);&#13;
    createNewCardType(8,10,10,1);&#13;
    createNewCardType(8,9,10,1);&#13;
    createNewCardType(8,5,6,1);&#13;
    createNewCardType(8,4,12,3);&#13;
    createNewCardType(8,5,12,3);&#13;
    createNewCardType(8,4,12,3);&#13;
    createNewCardType(8,4,20,4);&#13;
    createNewCardType(9,10,10,1);&#13;
    createNewCardType(9,7,10,1);&#13;
    createNewCardType(9,1,20,1);&#13;
    createNewCardType(9,5,13,3);&#13;
    createNewCardType(9,5,13,3);&#13;
    createNewCardType(9,80,5,2);&#13;
    createNewCardType(9,90,5,2);&#13;
    createNewCardType(10,9,10,1);&#13;
    createNewCardType(10,10,10,1);&#13;
    createNewCardType(10,4,12,1);&#13;
    createNewCardType(10,80,5,2);&#13;
    createNewCardType(10,5,12,3);&#13;
    createNewCardType(10,5,12,3);&#13;
    hasInitCard2 = true;&#13;
  }&#13;
&#13;
  /* Withdraw */&#13;
  /*&#13;
    NOTICE: These functions withdraw the developer's cut which is left&#13;
    in the contract by `buy`. User funds are immediately sent to the old&#13;
    owner in `buy`, no user funds are left in the contract.&#13;
  */&#13;
  function withdrawAll () onlyAdmins() public {&#13;
   msg.sender.transfer(address(this).balance);&#13;
  }&#13;
&#13;
  function withdrawAmount (uint256 _amount) onlyAdmins() public {&#13;
    msg.sender.transfer(_amount);&#13;
  }&#13;
&#13;
  /* ERC721 */&#13;
&#13;
  function name() public pure returns (string) {&#13;
    return "Ethwuxia.pro";&#13;
  }&#13;
&#13;
  function symbol() public pure returns (string) {&#13;
    return "EWX";&#13;
  }&#13;
&#13;
  function totalSupply() public view returns (uint256) {&#13;
    return listedCard.length;&#13;
  }&#13;
&#13;
  function balanceOf (address _owner) public view returns (uint256 _balance) {&#13;
    uint counter = 0;&#13;
&#13;
    for (uint i = 0; i &lt; listedCard.length; i++) {&#13;
      if (ownerOf(listedCard[i].cardId) == _owner) {&#13;
        counter++;&#13;
      }&#13;
    }&#13;
&#13;
    return counter;&#13;
  }&#13;
&#13;
  function ownerOf (uint256 _itemId) public view returns (address _owner) {&#13;
    return mapOwnerOfCard[_itemId];&#13;
  }&#13;
&#13;
  function tokensOf (address _owner) public view returns (uint[]) {&#13;
    uint[] memory result = new uint[](balanceOf(_owner));&#13;
&#13;
    uint256 itemCounter = 0;&#13;
    for (uint256 i = 0; i &lt; listedCard.length; i++) {&#13;
      if (ownerOf(i) == _owner) {&#13;
        result[itemCounter] = listedCard[i].cardId;&#13;
        itemCounter += 1;&#13;
      }&#13;
    }&#13;
    return result;&#13;
  }&#13;
&#13;
  function tokenExists (uint256 _itemId) public view returns (bool _exists) {&#13;
    return mapOwnerOfCard[_itemId] != address(0);&#13;
  }&#13;
&#13;
  function approvedFor(uint256 _itemId) public view returns (address _approved) {&#13;
    return approvedOfItem[_itemId];&#13;
  }&#13;
&#13;
  function approve(address _to, uint256 _itemId) public {&#13;
    require(msg.sender != _to);&#13;
    require(tokenExists(_itemId));&#13;
    require(ownerOf(_itemId) == msg.sender);&#13;
&#13;
    if (_to == 0) {&#13;
      if (approvedOfItem[_itemId] != 0) {&#13;
        delete approvedOfItem[_itemId];&#13;
        emit Approval(msg.sender, 0, _itemId);&#13;
      }&#13;
    } else {&#13;
      approvedOfItem[_itemId] = _to;&#13;
      emit Approval(msg.sender, _to, _itemId);&#13;
    }&#13;
  }&#13;
&#13;
  /* Transferring a country to another owner will entitle the new owner the profits from `buy` */&#13;
  function transfer(address _to, uint256 _itemId) public {&#13;
    require(msg.sender == ownerOf(_itemId));&#13;
    _transfer(msg.sender, _to, _itemId);&#13;
  }&#13;
&#13;
  function transferFrom(address _from, address _to, uint256 _itemId) public {&#13;
    require(approvedFor(_itemId) == msg.sender);&#13;
    _transfer(_from, _to, _itemId);&#13;
  }&#13;
&#13;
  function _transfer(address _from, address _to, uint256 _itemId) internal {&#13;
    require(tokenExists(_itemId));&#13;
    require(ownerOf(_itemId) == _from);&#13;
    require(_to != address(0));&#13;
    require(_to != address(this));&#13;
    return ;  // disable card transfer&#13;
&#13;
    mapOwnerOfCard[_itemId] = _to;&#13;
    approvedOfItem[_itemId] = 0;&#13;
&#13;
    emit Transfer(_from, _to, _itemId);&#13;
  }&#13;
&#13;
  /* Read */&#13;
  function isAdmin (address _admin) public view returns (bool _isAdmin) {&#13;
    return admins[_admin];&#13;
  }&#13;
&#13;
  /* Util */&#13;
  function isContract(address addr) internal view returns (bool) {&#13;
    uint size;&#13;
    assembly { size := extcodesize(addr) } // solium-disable-line&#13;
    return size &gt; 0;&#13;
  }&#13;
}&#13;
&#13;
interface IItemRegistry {&#13;
  function itemsForSaleLimit (uint256 _from, uint256 _take) external view returns (uint256[] _items);&#13;
  function ownerOf (uint256 _itemId) external view returns (address _owner);&#13;
  function priceOf (uint256 _itemId) external view returns (uint256 _price);&#13;
}