/**
 * MPSBoardSig.sol
 * Governance smart contract including multi-signature capabilities.
 * It uniquely represents the Board of Directors of Mt Pelerin Group SA on-chain
 * until it is superseded by a resolution of the board referring to a new
 * governance on-chain reference.

 * The unflattened code is available through this github tag:
 * https://github.com/MtPelerin/MtPelerin-protocol/tree/etherscan-verify-batch-1

 * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved

 * @notice All matters regarding the intellectual property of this code 
 * @notice or software are subject to Swiss Law without reference to its 
 * @notice conflicts of law rules.

 * @notice License for each contract is available in the respective file
 * @notice or in the LICENSE.md file.
 * @notice https://github.com/MtPelerin/

 * @notice Code by OpenZeppelin is copyrighted and licensed on their repository:
 * @notice https://github.com/OpenZeppelin/openzeppelin-solidity
 */


pragma solidity ^0.4.24;

// File: contracts/multisig/private/MultiSig.sol

/**
 * @title MultiSig
 * @dev MultiSig contract
 * @author Cyril Lapinte - <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="c4a7bdb6ada8eaa8a5b4adaab0a184a9b0b4a1a8a1b6adaaeaa7aba9">[email protected]</a>&gt;&#13;
&#13;
 * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved&#13;
 * @notice Please refer to the top of this file for the license.&#13;
&#13;
 * Error messages&#13;
 * MS01: Valid signatures below threshold&#13;
 * MS02: Transaction validity has expired&#13;
 * MS03: Sender does not belong to signers&#13;
 * MS04: Execution should be correct&#13;
 */&#13;
contract MultiSig {&#13;
  address[]  signers_;&#13;
  uint8 public threshold;&#13;
&#13;
  bytes32 public replayProtection;&#13;
  uint256 public nonce;&#13;
&#13;
  /**&#13;
   * @dev constructor&#13;
   */&#13;
  constructor(address[] _signers, uint8 _threshold) public {&#13;
    signers_ = _signers;&#13;
    threshold = _threshold;&#13;
&#13;
    // Prevent first transaction of different contracts&#13;
    // to be replayed here&#13;
    updateReplayProtection();&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev fallback function&#13;
   */&#13;
  function () public payable { }&#13;
&#13;
  /**&#13;
   * @dev read a function selector from a bytes field&#13;
   * @param _data contains the selector&#13;
   */&#13;
  function readSelector(bytes _data) public pure returns (bytes4) {&#13;
    bytes4 selector;&#13;
    // solium-disable-next-line security/no-inline-assembly&#13;
    assembly {&#13;
      selector := mload(add(_data, 0x20))&#13;
    }&#13;
    return selector;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev read ERC20 destination&#13;
   * @param _data ERC20 transfert&#13;
   */&#13;
  function readERC20Destination(bytes _data) public pure returns (address) {&#13;
    address destination;&#13;
    // solium-disable-next-line security/no-inline-assembly&#13;
    assembly {&#13;
      destination := mload(add(_data, 0x24))&#13;
    }&#13;
    return destination;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev read ERC20 value&#13;
   * @param _data contains the selector&#13;
   */&#13;
  function readERC20Value(bytes _data) public pure returns (uint256) {&#13;
    uint256 value;&#13;
    // solium-disable-next-line security/no-inline-assembly&#13;
    assembly {&#13;
      value := mload(add(_data, 0x44))&#13;
    }&#13;
    return value;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Modifier verifying that valid signatures are above _threshold&#13;
   */&#13;
  modifier thresholdRequired(&#13;
    address _destination, uint256 _value, bytes _data,&#13;
    uint256 _validity, uint256 _threshold,&#13;
    bytes32[] _sigR, bytes32[] _sigS, uint8[] _sigV)&#13;
  {&#13;
    require(&#13;
      reviewSignatures(&#13;
        _destination, _value, _data, _validity, _sigR, _sigS, _sigV&#13;
      ) &gt;= _threshold,&#13;
      "MS01"&#13;
    );&#13;
    _;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Modifier verifying that transaction is still valid&#13;
   * @dev This modifier also protects against replay on forked chain.&#13;
   *&#13;
   * @notice If both the _validity and gasPrice are low, then there is a risk&#13;
   * @notice that the transaction is executed after its _validity but before it does timeout&#13;
   * @notice In that case, the transaction will fail.&#13;
   * @notice In general, it is recommended to use a _validity greater than the potential timeout&#13;
   */&#13;
  modifier stillValid(uint256 _validity)&#13;
  {&#13;
    if (_validity != 0) {&#13;
      require(_validity &gt;= block.number, "MS02");&#13;
    }&#13;
    _;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Modifier requiring that the message sender belongs to the signers&#13;
   */&#13;
  modifier onlySigners() {&#13;
    bool found = false;&#13;
    for (uint256 i = 0; i &lt; signers_.length &amp;&amp; !found; i++) {&#13;
      found = (msg.sender == signers_[i]);&#13;
    }&#13;
    require(found, "MS03");&#13;
    _;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev returns signers&#13;
   */&#13;
  function signers() public view returns (address[]) {&#13;
    return signers_;&#13;
  }&#13;
&#13;
  /**&#13;
   * returns threshold&#13;
   */&#13;
  function threshold() public view returns (uint8) {&#13;
    return threshold;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev returns replayProtection&#13;
   */&#13;
  function replayProtection() public view returns (bytes32) {&#13;
    return replayProtection;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev returns nonce&#13;
   */&#13;
  function nonce() public view returns (uint256) {&#13;
    return nonce;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev returns the number of valid signatures&#13;
   */&#13;
  function reviewSignatures(&#13;
    address _destination, uint256 _value, bytes _data,&#13;
    uint256 _validity,&#13;
    bytes32[] _sigR, bytes32[] _sigS, uint8[] _sigV)&#13;
    public view returns (uint256)&#13;
  {&#13;
    return reviewSignaturesInternal(&#13;
      _destination,&#13;
      _value,&#13;
      _data,&#13;
      _validity,&#13;
      signers_,&#13;
      _sigR,&#13;
      _sigS,&#13;
      _sigV&#13;
    );&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev buildHash&#13;
   **/&#13;
  function buildHash(&#13;
    address _destination, uint256 _value,&#13;
    bytes _data, uint256 _validity)&#13;
    public view returns (bytes32)&#13;
  {&#13;
    // FIXME: web3/solidity behaves differently with empty bytes&#13;
    if (_data.length == 0) {&#13;
      return keccak256(&#13;
        abi.encode(&#13;
          _destination, _value, _validity, replayProtection&#13;
        )&#13;
      );&#13;
    } else {&#13;
      return keccak256(&#13;
        abi.encode(&#13;
          _destination, _value, _data, _validity, replayProtection&#13;
        )&#13;
      );&#13;
    }&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev recover the public address from the signatures&#13;
   **/&#13;
  function recoverAddress(&#13;
    address _destination, uint256 _value,&#13;
    bytes _data, uint256 _validity,&#13;
    bytes32 _r, bytes32 _s, uint8 _v)&#13;
    public view returns (address)&#13;
  {&#13;
    // When used in web.eth.sign, geth will prepend the hash&#13;
    bytes32 hash = keccak256(&#13;
      abi.encodePacked("\x19Ethereum Signed Message:\n32",&#13;
        buildHash(&#13;
          _destination,&#13;
          _value,&#13;
          _data,&#13;
          _validity&#13;
        )&#13;
      )&#13;
    );&#13;
&#13;
    // Version of signature should be 27 or 28, but 0 and 1 are also possible versions&#13;
    uint8 v = (_v &lt; 27) ? _v += 27: _v;&#13;
&#13;
    // If the version is correct return the signer address&#13;
    if (v != 27 &amp;&amp; v != 28) {&#13;
      return address(0);&#13;
    } else {&#13;
      return ecrecover(&#13;
        hash,&#13;
        v,&#13;
        _r,&#13;
        _s&#13;
      );&#13;
    }&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev execute a transaction if enough signatures are valid&#13;
   **/&#13;
  function execute(&#13;
    bytes32[] _sigR,&#13;
    bytes32[] _sigS,&#13;
    uint8[] _sigV,&#13;
    address _destination, uint256 _value, bytes _data, uint256 _validity)&#13;
    public&#13;
    stillValid(_validity)&#13;
    thresholdRequired(_destination, _value, _data, _validity, threshold, _sigR, _sigS, _sigV)&#13;
    returns (bool)&#13;
  {&#13;
    executeInternal(_destination, _value, _data);&#13;
    return true;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev review signatures against a list of signers&#13;
   * Signatures must be provided in the same order as the list of signers&#13;
   * All provided signatures must be valid and correspond to one of the signers&#13;
   * returns the number of valid signatures&#13;
   * returns 0 if the inputs are inconsistent&#13;
   */&#13;
  function reviewSignaturesInternal(&#13;
    address _destination, uint256 _value, bytes _data, uint256 _validity,&#13;
    address[] _signers,&#13;
    bytes32[] _sigR, bytes32[] _sigS, uint8[] _sigV)&#13;
    internal view returns (uint256)&#13;
  {&#13;
    uint256 length = _sigR.length;&#13;
    if (length == 0 || length &gt; _signers.length || (&#13;
      _sigS.length != length || _sigV.length != length&#13;
    ))&#13;
    {&#13;
      return 0;&#13;
    }&#13;
&#13;
    uint256 validSigs = 0;&#13;
    address recovered = recoverAddress(&#13;
      _destination, _value, _data, _validity, &#13;
      _sigR[0], _sigS[0], _sigV[0]);&#13;
    for (uint256 i = 0; i &lt; _signers.length; i++) {&#13;
      if (_signers[i] == recovered) {&#13;
        validSigs++;&#13;
        if (validSigs &lt; length) {&#13;
          recovered = recoverAddress(&#13;
            _destination,&#13;
            _value,&#13;
            _data,&#13;
            _validity,&#13;
            _sigR[validSigs],&#13;
            _sigS[validSigs],&#13;
            _sigV[validSigs]&#13;
          );&#13;
        } else {&#13;
          break;&#13;
        }&#13;
      }&#13;
    }&#13;
&#13;
    if (validSigs != length) {&#13;
      return 0;&#13;
    }&#13;
&#13;
    return validSigs;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev execute a transaction&#13;
   **/&#13;
  function executeInternal(address _destination, uint256 _value, bytes _data)&#13;
    internal&#13;
  {&#13;
    updateReplayProtection();&#13;
    if (_data.length == 0) {&#13;
      _destination.transfer(_value);&#13;
    } else {&#13;
      // solium-disable-next-line security/no-call-value&#13;
      require(_destination.call.value(_value)(_data), "MS04");&#13;
    }&#13;
    emit Execution(_destination, _value, _data);&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev update replay protection&#13;
   * contract address is used to prevent replay between different contracts&#13;
   * block hash is used to prevent replay between branches&#13;
   * nonce is used to prevent replay within the contract&#13;
   **/&#13;
  function updateReplayProtection() internal {&#13;
    replayProtection = keccak256(&#13;
      abi.encodePacked(address(this), blockhash(block.number-1), nonce));&#13;
    nonce++;&#13;
  }&#13;
&#13;
  event Execution(address to, uint256 value, bytes data);&#13;
}&#13;
&#13;
// File: contracts/zeppelin/token/ERC20/ERC20Basic.sol&#13;
&#13;
/**&#13;
 * @title ERC20Basic&#13;
 * @dev Simpler version of ERC20 interface&#13;
 * @dev see https://github.com/ethereum/EIPs/issues/179&#13;
 */&#13;
contract ERC20Basic {&#13;
  function totalSupply() public view returns (uint256);&#13;
  function balanceOf(address who) public view returns (uint256);&#13;
  function transfer(address to, uint256 value) public returns (bool);&#13;
  event Transfer(address indexed from, address indexed to, uint256 value);&#13;
}&#13;
&#13;
// File: contracts/zeppelin/math/SafeMath.sol&#13;
&#13;
/**&#13;
 * @title SafeMath&#13;
 * @dev Math operations with safety checks that throw on error&#13;
 */&#13;
library SafeMath {&#13;
&#13;
  /**&#13;
  * @dev Multiplies two numbers, throws on overflow.&#13;
  */&#13;
  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {&#13;
    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the&#13;
    // benefit is lost if 'b' is also tested.&#13;
    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522&#13;
    if (a == 0) {&#13;
      return 0;&#13;
    }&#13;
&#13;
    c = a * b;&#13;
    assert(c / a == b);&#13;
    return c;&#13;
  }&#13;
&#13;
  /**&#13;
  * @dev Integer division of two numbers, truncating the quotient.&#13;
  */&#13;
  function div(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
    // assert(b &gt; 0); // Solidity automatically throws when dividing by 0&#13;
    // uint256 c = a / b;&#13;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold&#13;
    return a / b;&#13;
  }&#13;
&#13;
  /**&#13;
  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).&#13;
  */&#13;
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
    assert(b &lt;= a);&#13;
    return a - b;&#13;
  }&#13;
&#13;
  /**&#13;
  * @dev Adds two numbers, throws on overflow.&#13;
  */&#13;
  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {&#13;
    c = a + b;&#13;
    assert(c &gt;= a);&#13;
    return c;&#13;
  }&#13;
}&#13;
&#13;
// File: contracts/zeppelin/token/ERC20/BasicToken.sol&#13;
&#13;
/**&#13;
 * @title Basic token&#13;
 * @dev Basic version of StandardToken, with no allowances.&#13;
 */&#13;
contract BasicToken is ERC20Basic {&#13;
  using SafeMath for uint256;&#13;
&#13;
  mapping(address =&gt; uint256) balances;&#13;
&#13;
  uint256 totalSupply_;&#13;
&#13;
  /**&#13;
  * @dev total number of tokens in existence&#13;
  */&#13;
  function totalSupply() public view returns (uint256) {&#13;
    return totalSupply_;&#13;
  }&#13;
&#13;
  /**&#13;
  * @dev transfer token for a specified address&#13;
  * @param _to The address to transfer to.&#13;
  * @param _value The amount to be transferred.&#13;
  */&#13;
  function transfer(address _to, uint256 _value) public returns (bool) {&#13;
    require(_to != address(0));&#13;
    require(_value &lt;= balances[msg.sender]);&#13;
&#13;
    balances[msg.sender] = balances[msg.sender].sub(_value);&#13;
    balances[_to] = balances[_to].add(_value);&#13;
    emit Transfer(msg.sender, _to, _value);&#13;
    return true;&#13;
  }&#13;
&#13;
  /**&#13;
  * @dev Gets the balance of the specified address.&#13;
  * @param _owner The address to query the the balance of.&#13;
  * @return An uint256 representing the amount owned by the passed address.&#13;
  */&#13;
  function balanceOf(address _owner) public view returns (uint256) {&#13;
    return balances[_owner];&#13;
  }&#13;
&#13;
}&#13;
&#13;
// File: contracts/interface/ISeizable.sol&#13;
&#13;
/**&#13;
 * @title ISeizable&#13;
 * @dev ISeizable interface&#13;
 * @author Cyril Lapinte - &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="781b010a11145614190811160c1d38150c081d141d0a1116561b1715">[email protected]</a>&gt;&#13;
 *&#13;
 * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved&#13;
 * @notice Please refer to the top of this file for the license.&#13;
 **/&#13;
contract ISeizable {&#13;
  function seize(address _account, uint256 _value) public;&#13;
  event Seize(address account, uint256 amount);&#13;
}&#13;
&#13;
// File: contracts/zeppelin/ownership/Ownable.sol&#13;
&#13;
/**&#13;
 * @title Ownable&#13;
 * @dev The Ownable contract has an owner address, and provides basic authorization control&#13;
 * functions, this simplifies the implementation of "user permissions".&#13;
 */&#13;
contract Ownable {&#13;
  address public owner;&#13;
&#13;
&#13;
  event OwnershipRenounced(address indexed previousOwner);&#13;
  event OwnershipTransferred(&#13;
    address indexed previousOwner,&#13;
    address indexed newOwner&#13;
  );&#13;
&#13;
&#13;
  /**&#13;
   * @dev The Ownable constructor sets the original `owner` of the contract to the sender&#13;
   * account.&#13;
   */&#13;
  constructor() public {&#13;
    owner = msg.sender;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Throws if called by any account other than the owner.&#13;
   */&#13;
  modifier onlyOwner() {&#13;
    require(msg.sender == owner);&#13;
    _;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Allows the current owner to relinquish control of the contract.&#13;
   */&#13;
  function renounceOwnership() public onlyOwner {&#13;
    emit OwnershipRenounced(owner);&#13;
    owner = address(0);&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Allows the current owner to transfer control of the contract to a newOwner.&#13;
   * @param _newOwner The address to transfer ownership to.&#13;
   */&#13;
  function transferOwnership(address _newOwner) public onlyOwner {&#13;
    _transferOwnership(_newOwner);&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Transfers control of the contract to a newOwner.&#13;
   * @param _newOwner The address to transfer ownership to.&#13;
   */&#13;
  function _transferOwnership(address _newOwner) internal {&#13;
    require(_newOwner != address(0));&#13;
    emit OwnershipTransferred(owner, _newOwner);&#13;
    owner = _newOwner;&#13;
  }&#13;
}&#13;
&#13;
// File: contracts/Authority.sol&#13;
&#13;
/**&#13;
 * @title Authority&#13;
 * @dev The Authority contract has an authority address, and provides basic authorization control&#13;
 * functions, this simplifies the implementation of "user permissions".&#13;
 * Authority means to represent a legal entity that is entitled to specific rights&#13;
 *&#13;
 * @author Cyril Lapinte - &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="b0d3c9c2d9dc9edcd1c0d9dec4d5f0ddc4c0d5dcd5c2d9de9ed3dfdd">[email protected]</a>&gt;&#13;
 *&#13;
 * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved&#13;
 * @notice Please refer to the top of this file for the license.&#13;
 *&#13;
 * Error messages&#13;
 * AU01: Message sender must be an authority&#13;
 */&#13;
contract Authority is Ownable {&#13;
&#13;
  address authority;&#13;
&#13;
  /**&#13;
   * @dev Throws if called by any account other than the authority.&#13;
   */&#13;
  modifier onlyAuthority {&#13;
    require(msg.sender == authority, "AU01");&#13;
    _;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev return the address associated to the authority&#13;
   */&#13;
  function authorityAddress() public view returns (address) {&#13;
    return authority;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev rdefines an authority&#13;
   * @param _name the authority name&#13;
   * @param _address the authority address.&#13;
   */&#13;
  function defineAuthority(string _name, address _address) public onlyOwner {&#13;
    emit AuthorityDefined(_name, _address);&#13;
    authority = _address;&#13;
  }&#13;
&#13;
  event AuthorityDefined(&#13;
    string name,&#13;
    address _address&#13;
  );&#13;
}&#13;
&#13;
// File: contracts/token/component/SeizableToken.sol&#13;
&#13;
/**&#13;
 * @title SeizableToken&#13;
 * @dev BasicToken contract which allows owner to seize accounts&#13;
 * @author Cyril Lapinte - &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="b7d4cec5dedb99dbd6c7ded9c3d2f7dac3c7d2dbd2c5ded999d4d8da">[email protected]</a>&gt;&#13;
 *&#13;
 * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved&#13;
 * @notice Please refer to the top of this file for the license.&#13;
 *&#13;
 * Error messages&#13;
 * ST01: Owner cannot seize itself&#13;
*/&#13;
contract SeizableToken is BasicToken, Authority, ISeizable {&#13;
  using SafeMath for uint256;&#13;
&#13;
  // Although very unlikely, the value below may overflow.&#13;
  // This contract and its children should expect it to happened and consider&#13;
  // this value as only the first 256 bits of the complete value.&#13;
  uint256 public allTimeSeized = 0; // overflow may happend&#13;
&#13;
  /**&#13;
   * @dev called by the owner to seize value from the account&#13;
   */&#13;
  function seize(address _account, uint256 _value)&#13;
    public onlyAuthority&#13;
  {&#13;
    require(_account != owner, "ST01");&#13;
&#13;
    balances[_account] = balances[_account].sub(_value);&#13;
    balances[authority] = balances[authority].add(_value);&#13;
&#13;
    allTimeSeized += _value;&#13;
    emit Seize(_account, _value);&#13;
  }&#13;
}&#13;
&#13;
// File: contracts/zeppelin/token/ERC20/ERC20.sol&#13;
&#13;
/**&#13;
 * @title ERC20 interface&#13;
 * @dev see https://github.com/ethereum/EIPs/issues/20&#13;
 */&#13;
contract ERC20 is ERC20Basic {&#13;
  function allowance(address owner, address spender)&#13;
    public view returns (uint256);&#13;
&#13;
  function transferFrom(address from, address to, uint256 value)&#13;
    public returns (bool);&#13;
&#13;
  function approve(address spender, uint256 value) public returns (bool);&#13;
  event Approval(&#13;
    address indexed owner,&#13;
    address indexed spender,&#13;
    uint256 value&#13;
  );&#13;
}&#13;
&#13;
// File: contracts/zeppelin/token/ERC20/StandardToken.sol&#13;
&#13;
/**&#13;
 * @title Standard ERC20 token&#13;
 *&#13;
 * @dev Implementation of the basic standard token.&#13;
 * @dev https://github.com/ethereum/EIPs/issues/20&#13;
 * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol&#13;
 */&#13;
contract StandardToken is ERC20, BasicToken {&#13;
&#13;
  mapping (address =&gt; mapping (address =&gt; uint256)) internal allowed;&#13;
&#13;
&#13;
  /**&#13;
   * @dev Transfer tokens from one address to another&#13;
   * @param _from address The address which you want to send tokens from&#13;
   * @param _to address The address which you want to transfer to&#13;
   * @param _value uint256 the amount of tokens to be transferred&#13;
   */&#13;
  function transferFrom(&#13;
    address _from,&#13;
    address _to,&#13;
    uint256 _value&#13;
  )&#13;
    public&#13;
    returns (bool)&#13;
  {&#13;
    require(_to != address(0));&#13;
    require(_value &lt;= balances[_from]);&#13;
    require(_value &lt;= allowed[_from][msg.sender]);&#13;
&#13;
    balances[_from] = balances[_from].sub(_value);&#13;
    balances[_to] = balances[_to].add(_value);&#13;
    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);&#13;
    emit Transfer(_from, _to, _value);&#13;
    return true;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.&#13;
   *&#13;
   * Beware that changing an allowance with this method brings the risk that someone may use both the old&#13;
   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this&#13;
   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:&#13;
   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729&#13;
   * @param _spender The address which will spend the funds.&#13;
   * @param _value The amount of tokens to be spent.&#13;
   */&#13;
  function approve(address _spender, uint256 _value) public returns (bool) {&#13;
    allowed[msg.sender][_spender] = _value;&#13;
    emit Approval(msg.sender, _spender, _value);&#13;
    return true;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Function to check the amount of tokens that an owner allowed to a spender.&#13;
   * @param _owner address The address which owns the funds.&#13;
   * @param _spender address The address which will spend the funds.&#13;
   * @return A uint256 specifying the amount of tokens still available for the spender.&#13;
   */&#13;
  function allowance(&#13;
    address _owner,&#13;
    address _spender&#13;
   )&#13;
    public&#13;
    view&#13;
    returns (uint256)&#13;
  {&#13;
    return allowed[_owner][_spender];&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Increase the amount of tokens that an owner allowed to a spender.&#13;
   *&#13;
   * approve should be called when allowed[_spender] == 0. To increment&#13;
   * allowed value is better to use this function to avoid 2 calls (and wait until&#13;
   * the first transaction is mined)&#13;
   * From MonolithDAO Token.sol&#13;
   * @param _spender The address which will spend the funds.&#13;
   * @param _addedValue The amount of tokens to increase the allowance by.&#13;
   */&#13;
  function increaseApproval(&#13;
    address _spender,&#13;
    uint _addedValue&#13;
  )&#13;
    public&#13;
    returns (bool)&#13;
  {&#13;
    allowed[msg.sender][_spender] = (&#13;
      allowed[msg.sender][_spender].add(_addedValue));&#13;
    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);&#13;
    return true;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Decrease the amount of tokens that an owner allowed to a spender.&#13;
   *&#13;
   * approve should be called when allowed[_spender] == 0. To decrement&#13;
   * allowed value is better to use this function to avoid 2 calls (and wait until&#13;
   * the first transaction is mined)&#13;
   * From MonolithDAO Token.sol&#13;
   * @param _spender The address which will spend the funds.&#13;
   * @param _subtractedValue The amount of tokens to decrease the allowance by.&#13;
   */&#13;
  function decreaseApproval(&#13;
    address _spender,&#13;
    uint _subtractedValue&#13;
  )&#13;
    public&#13;
    returns (bool)&#13;
  {&#13;
    uint oldValue = allowed[msg.sender][_spender];&#13;
    if (_subtractedValue &gt; oldValue) {&#13;
      allowed[msg.sender][_spender] = 0;&#13;
    } else {&#13;
      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);&#13;
    }&#13;
    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);&#13;
    return true;&#13;
  }&#13;
&#13;
}&#13;
&#13;
// File: contracts/interface/IProvableOwnership.sol&#13;
&#13;
/**&#13;
 * @title IProvableOwnership&#13;
 * @dev IProvableOwnership interface which describe proof of ownership.&#13;
 * @author Cyril Lapinte - &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="13706a617a7f3d7f72637a7d6776537e6763767f76617a7d3d707c7e">[email protected]</a>&gt;&#13;
 *&#13;
 * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved&#13;
 * @notice Please refer to the top of this file for the license.&#13;
 **/&#13;
contract IProvableOwnership {&#13;
  function proofLength(address _holder) public view returns (uint256);&#13;
  function proofAmount(address _holder, uint256 _proofId)&#13;
    public view returns (uint256);&#13;
&#13;
  function proofDateFrom(address _holder, uint256 _proofId)&#13;
    public view returns (uint256);&#13;
&#13;
  function proofDateTo(address _holder, uint256 _proofId)&#13;
    public view returns (uint256);&#13;
&#13;
  function createProof(address _holder) public;&#13;
  function checkProof(address _holder, uint256 _proofId, uint256 _at)&#13;
    public view returns (uint256);&#13;
&#13;
  function transferWithProofs(&#13;
    address _to,&#13;
    uint256 _value,&#13;
    bool _proofFrom,&#13;
    bool _proofTo&#13;
    ) public returns (bool);&#13;
&#13;
  function transferFromWithProofs(&#13;
    address _from,&#13;
    address _to,&#13;
    uint256 _value,&#13;
    bool _proofFrom,&#13;
    bool _proofTo&#13;
    ) public returns (bool);&#13;
&#13;
  event ProofOfOwnership(address indexed holder, uint256 proofId);&#13;
}&#13;
&#13;
// File: contracts/interface/IAuditableToken.sol&#13;
&#13;
/**&#13;
 * @title IAuditableToken&#13;
 * @dev IAuditableToken interface describing the audited data&#13;
 * @author Cyril Lapinte - &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="f4978d869d98da9895849d9a8091b4998084919891869d9ada979b99">[email protected]</a>&gt;&#13;
 *&#13;
 * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved&#13;
 * @notice Please refer to the top of this file for the license.&#13;
 **/&#13;
contract IAuditableToken {&#13;
  function lastTransactionAt(address _address) public view returns (uint256);&#13;
  function lastReceivedAt(address _address) public view returns (uint256);&#13;
  function lastSentAt(address _address) public view returns (uint256);&#13;
  function transactionCount(address _address) public view returns (uint256);&#13;
  function receivedCount(address _address) public view returns (uint256);&#13;
  function sentCount(address _address) public view returns (uint256);&#13;
  function totalReceivedAmount(address _address) public view returns (uint256);&#13;
  function totalSentAmount(address _address) public view returns (uint256);&#13;
}&#13;
&#13;
// File: contracts/token/component/AuditableToken.sol&#13;
&#13;
/**&#13;
 * @title AuditableToken&#13;
 * @dev AuditableToken contract&#13;
 * AuditableToken provides transaction data which can be used&#13;
 * in other smart contracts&#13;
 *&#13;
 * @author Cyril Lapinte - &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="a9cad0dbc0c587c5c8d9c0c7ddcce9c4ddd9ccc5ccdbc0c787cac6c4">[email protected]</a>&gt;&#13;
 *&#13;
 * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved&#13;
 * @notice Please refer to the top of this file for the license.&#13;
 **/&#13;
contract AuditableToken is IAuditableToken, StandardToken {&#13;
&#13;
   // Although very unlikely, the following values below may overflow:&#13;
   //   receivedCount, sentCount, totalReceivedAmount, totalSentAmount&#13;
   // This contract and its children should expect it to happen and consider&#13;
   // these values as only the first 256 bits of the complete value.&#13;
  struct Audit {&#13;
    uint256 createdAt;&#13;
    uint256 lastReceivedAt;&#13;
    uint256 lastSentAt;&#13;
    uint256 receivedCount; // potential overflow&#13;
    uint256 sentCount; // poential overflow&#13;
    uint256 totalReceivedAmount; // potential overflow&#13;
    uint256 totalSentAmount; // potential overflow&#13;
  }&#13;
  mapping(address =&gt; Audit) internal audits;&#13;
&#13;
  /**&#13;
   * @dev Time of the creation of the audit struct&#13;
   */&#13;
  function auditCreatedAt(address _address) public view returns (uint256) {&#13;
    return audits[_address].createdAt;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Time of the last transaction&#13;
   */&#13;
  function lastTransactionAt(address _address) public view returns (uint256) {&#13;
    return ( audits[_address].lastReceivedAt &gt; audits[_address].lastSentAt ) ?&#13;
      audits[_address].lastReceivedAt : audits[_address].lastSentAt;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Time of the last received transaction&#13;
   */&#13;
  function lastReceivedAt(address _address) public view returns (uint256) {&#13;
    return audits[_address].lastReceivedAt;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Time of the last sent transaction&#13;
   */&#13;
  function lastSentAt(address _address) public view returns (uint256) {&#13;
    return audits[_address].lastSentAt;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Count of transactions&#13;
   */&#13;
  function transactionCount(address _address) public view returns (uint256) {&#13;
    return audits[_address].receivedCount + audits[_address].sentCount;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Count of received transactions&#13;
   */&#13;
  function receivedCount(address _address) public view returns (uint256) {&#13;
    return audits[_address].receivedCount;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Count of sent transactions&#13;
   */&#13;
  function sentCount(address _address) public view returns (uint256) {&#13;
    return audits[_address].sentCount;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev All time received&#13;
   */&#13;
  function totalReceivedAmount(address _address)&#13;
    public view returns (uint256)&#13;
  {&#13;
    return audits[_address].totalReceivedAmount;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev All time sent&#13;
   */&#13;
  function totalSentAmount(address _address) public view returns (uint256) {&#13;
    return audits[_address].totalSentAmount;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Overriden transfer function&#13;
   */&#13;
  function transfer(address _to, uint256 _value) public returns (bool) {&#13;
    if (!super.transfer(_to, _value)) {&#13;
      return false;&#13;
    }&#13;
    updateAudit(msg.sender, _to, _value);&#13;
    return true;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Overriden transferFrom function&#13;
   */&#13;
  function transferFrom(address _from, address _to, uint256 _value)&#13;
    public returns (bool)&#13;
  {&#13;
    if (!super.transferFrom(_from, _to, _value)) {&#13;
      return false;&#13;
    }&#13;
&#13;
    updateAudit(_from, _to, _value);&#13;
    return true;&#13;
  }&#13;
&#13;
 /**&#13;
   * @dev currentTime()&#13;
   */&#13;
  function currentTime() internal view returns (uint256) {&#13;
    // solium-disable-next-line security/no-block-members&#13;
    return now;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Update audit data&#13;
   */&#13;
  function updateAudit(address _sender, address _receiver, uint256 _value)&#13;
    private returns (uint256)&#13;
  {&#13;
    Audit storage senderAudit = audits[_sender];&#13;
    senderAudit.lastSentAt = currentTime();&#13;
    senderAudit.sentCount++;&#13;
    senderAudit.totalSentAmount += _value;&#13;
    if (senderAudit.createdAt == 0) {&#13;
      senderAudit.createdAt = currentTime();&#13;
    }&#13;
&#13;
    Audit storage receiverAudit = audits[_receiver];&#13;
    receiverAudit.lastReceivedAt = currentTime();&#13;
    receiverAudit.receivedCount++;&#13;
    receiverAudit.totalReceivedAmount += _value;&#13;
    if (receiverAudit.createdAt == 0) {&#13;
      receiverAudit.createdAt = currentTime();&#13;
    }&#13;
  }&#13;
}&#13;
&#13;
// File: contracts/token/component/ProvableOwnershipToken.sol&#13;
&#13;
/**&#13;
 * @title ProvableOwnershipToken&#13;
 * @dev ProvableOwnershipToken is a StandardToken&#13;
 * with ability to record a proof of ownership&#13;
 *&#13;
 * When desired a proof of ownership can be generated.&#13;
 * The proof is stored within the contract.&#13;
 * A proofId is then returned.&#13;
 * The proof can later be used to retrieve the amount needed.&#13;
 *&#13;
 * @author Cyril Lapinte - &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="a3c0dad1cacf8dcfc2d3cacdd7c6e3ced7d3c6cfc6d1cacd8dc0ccce">[email protected]</a>&gt;&#13;
 *&#13;
 * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved&#13;
 * @notice Please refer to the top of this file for the license.&#13;
 **/&#13;
contract ProvableOwnershipToken is IProvableOwnership, AuditableToken, Ownable {&#13;
  struct Proof {&#13;
    uint256 amount;&#13;
    uint256 dateFrom;&#13;
    uint256 dateTo;&#13;
  }&#13;
  mapping(address =&gt; mapping(uint256 =&gt; Proof)) internal proofs;&#13;
  mapping(address =&gt; uint256) internal proofLengths;&#13;
&#13;
  /**&#13;
   * @dev number of proof stored in the contract&#13;
   */&#13;
  function proofLength(address _holder) public view returns (uint256) {&#13;
    return proofLengths[_holder];&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev amount contains for the proofId reccord&#13;
   */&#13;
  function proofAmount(address _holder, uint256 _proofId)&#13;
    public view returns (uint256)&#13;
  {&#13;
    return proofs[_holder][_proofId].amount;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev date from which the proof is valid&#13;
   */&#13;
  function proofDateFrom(address _holder, uint256 _proofId)&#13;
    public view returns (uint256)&#13;
  {&#13;
    return proofs[_holder][_proofId].dateFrom;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev date until the proof is valid&#13;
   */&#13;
  function proofDateTo(address _holder, uint256 _proofId)&#13;
    public view returns (uint256)&#13;
  {&#13;
    return proofs[_holder][_proofId].dateTo;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev called to challenge a proof at a point in the past&#13;
   * Return the amount tokens owned by the proof owner at that time&#13;
   */&#13;
  function checkProof(address _holder, uint256 _proofId, uint256 _at)&#13;
    public view returns (uint256)&#13;
  {&#13;
    if (_proofId &lt; proofLengths[_holder]) {&#13;
      Proof storage proof = proofs[_holder][_proofId];&#13;
&#13;
      if (proof.dateFrom &lt;= _at &amp;&amp; _at &lt;= proof.dateTo) {&#13;
        return proof.amount;&#13;
      }&#13;
    }&#13;
    return 0;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev called to create a proof of token ownership&#13;
   */&#13;
  function createProof(address _holder) public {&#13;
    createProofInternal(&#13;
      _holder,&#13;
      balanceOf(_holder),&#13;
      lastTransactionAt(_holder)&#13;
    );&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev transfer function with also create a proof of ownership to any of the participants&#13;
   * @param _proofSender if true a proof will be created for the sender&#13;
   * @param _proofReceiver if true a proof will be created for the receiver&#13;
   */&#13;
  function transferWithProofs(&#13;
    address _to,&#13;
    uint256 _value,&#13;
    bool _proofSender,&#13;
    bool _proofReceiver&#13;
  ) public returns (bool)&#13;
  {&#13;
    uint256 balanceBeforeFrom = balanceOf(msg.sender);&#13;
    uint256 beforeFrom = lastTransactionAt(msg.sender);&#13;
    uint256 balanceBeforeTo = balanceOf(_to);&#13;
    uint256 beforeTo = lastTransactionAt(_to);&#13;
&#13;
    if (!super.transfer(_to, _value)) {&#13;
      return false;&#13;
    }&#13;
&#13;
    transferPostProcessing(&#13;
      msg.sender,&#13;
      balanceBeforeFrom,&#13;
      beforeFrom,&#13;
      _proofSender&#13;
    );&#13;
    transferPostProcessing(&#13;
      _to,&#13;
      balanceBeforeTo,&#13;
      beforeTo,&#13;
      _proofReceiver&#13;
    );&#13;
    return true;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev transfer function with also create a proof of ownership to any of the participants&#13;
   * @param _proofSender if true a proof will be created for the sender&#13;
   * @param _proofReceiver if true a proof will be created for the receiver&#13;
   */&#13;
  function transferFromWithProofs(&#13;
    address _from,&#13;
    address _to, &#13;
    uint256 _value,&#13;
    bool _proofSender, bool _proofReceiver)&#13;
    public returns (bool)&#13;
  {&#13;
    uint256 balanceBeforeFrom = balanceOf(_from);&#13;
    uint256 beforeFrom = lastTransactionAt(_from);&#13;
    uint256 balanceBeforeTo = balanceOf(_to);&#13;
    uint256 beforeTo = lastTransactionAt(_to);&#13;
&#13;
    if (!super.transferFrom(_from, _to, _value)) {&#13;
      return false;&#13;
    }&#13;
&#13;
    transferPostProcessing(&#13;
      _from,&#13;
      balanceBeforeFrom,&#13;
      beforeFrom,&#13;
      _proofSender&#13;
    );&#13;
    transferPostProcessing(&#13;
      _to,&#13;
      balanceBeforeTo,&#13;
      beforeTo,&#13;
      _proofReceiver&#13;
    );&#13;
    return true;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev can be used to force create a proof (with a fake amount potentially !)&#13;
   * Only usable by child contract internaly&#13;
   */&#13;
  function createProofInternal(&#13;
    address _holder, uint256 _amount, uint256 _from) internal&#13;
  {&#13;
    uint proofId = proofLengths[_holder];&#13;
    // solium-disable-next-line security/no-block-members&#13;
    proofs[_holder][proofId] = Proof(_amount, _from, currentTime());&#13;
    proofLengths[_holder] = proofId+1;&#13;
    emit ProofOfOwnership(_holder, proofId);&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev private function updating contract state after a transfer operation&#13;
   */&#13;
  function transferPostProcessing(&#13;
    address _holder,&#13;
    uint256 _balanceBefore,&#13;
    uint256 _before,&#13;
    bool _proof) private&#13;
  {&#13;
    if (_proof) {&#13;
      createProofInternal(_holder, _balanceBefore, _before);&#13;
    }&#13;
  }&#13;
&#13;
  event ProofOfOwnership(address indexed holder, uint256 proofId);&#13;
}&#13;
&#13;
// File: contracts/interface/IClaimable.sol&#13;
&#13;
/**&#13;
 * @title IClaimable&#13;
 * @dev IClaimable interface&#13;
 * @author Cyril Lapinte - &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="a3c0dad1cacf8dcfc2d3cacdd7c6e3ced7d3c6cfc6d1cacd8dc0ccce">[email protected]</a>&gt;&#13;
 *&#13;
 * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved&#13;
 * @notice Please refer to the top of this file for the license.&#13;
 **/&#13;
interface IClaimable {&#13;
  function hasClaimsSince(address _address, uint256 at)&#13;
    external view returns (bool);&#13;
}&#13;
&#13;
// File: contracts/interface/IWithClaims.sol&#13;
&#13;
/**&#13;
 * @title IWithClaims&#13;
 * @dev IWithClaims interface&#13;
 * @author Cyril Lapinte - &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="02617b706b6e2c6e63726b6c7667426f7672676e67706b6c2c616d6f">[email protected]</a>&gt;&#13;
 *&#13;
 * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved&#13;
 * @notice Please refer to the top of this file for the license.&#13;
 **/&#13;
contract IWithClaims {&#13;
  function claimableLength() public view returns (uint256);&#13;
  function claimable(uint256 _claimableId) public view returns (IClaimable);&#13;
  function hasClaims(address _holder) public view returns (bool);&#13;
  function defineClaimables(IClaimable[] _claimables) public;&#13;
&#13;
  event ClaimablesDefined(uint256 count);&#13;
}&#13;
&#13;
// File: contracts/token/component/TokenWithClaims.sol&#13;
&#13;
/**&#13;
 * @title TokenWithClaims&#13;
 * @dev TokenWithClaims contract&#13;
 * TokenWithClaims is a token that will create a&#13;
 * proofOfOwnership during transfers if a claim can be made.&#13;
 * Holder may ask for the claim later using the proofOfOwnership&#13;
 * @author Cyril Lapinte - &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="2c4f555e454002404d5c454258496c41585c4940495e4542024f4341">[email protected]</a>&gt;&#13;
 *&#13;
 * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved&#13;
 * @notice Please refer to the top of this file for the license.&#13;
 *&#13;
 * Error messages&#13;
 * E01: Claimable address must be defined&#13;
 * E02: Claimables parameter must not be empty&#13;
 * E03: Claimable does not exist&#13;
**/&#13;
contract TokenWithClaims is IWithClaims, ProvableOwnershipToken {&#13;
&#13;
  IClaimable[] claimables;&#13;
&#13;
  /**&#13;
   * @dev Constructor&#13;
   */&#13;
  constructor(IClaimable[] _claimables) public {&#13;
    claimables = _claimables;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Returns the number of claimables&#13;
   */&#13;
  function claimableLength() public view returns (uint256) {&#13;
    return claimables.length;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Returns the Claimable associated to the specified claimableId&#13;
   */&#13;
  function claimable(uint256 _claimableId) public view returns (IClaimable) {&#13;
    return claimables[_claimableId];&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Returns true if there are any claims associated to this token&#13;
   * to be made at this time for the _holder&#13;
   */&#13;
  function hasClaims(address _holder) public view returns (bool) {&#13;
    uint256 lastTransaction = lastTransactionAt(_holder);&#13;
    for (uint256 i = 0; i &lt; claimables.length; i++) {&#13;
      if (claimables[i].hasClaimsSince(_holder, lastTransaction)) {&#13;
        return true;&#13;
      }&#13;
    }&#13;
    return false;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Override the transfer function with transferWithProofs&#13;
   * A proof of ownership will be made if any claims can be made by the participants&#13;
   */&#13;
  function transfer(address _to, uint256 _value) public returns (bool) {&#13;
    bool proofFrom = hasClaims(msg.sender);&#13;
    bool proofTo = hasClaims(_to);&#13;
&#13;
    return super.transferWithProofs(&#13;
      _to,&#13;
      _value,&#13;
      proofFrom,&#13;
      proofTo&#13;
    );&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Override the transfer function with transferWithProofs&#13;
   * A proof of ownership will be made if any claims can be made by the participants&#13;
   */&#13;
  function transferFrom(address _from, address _to, uint256 _value)&#13;
    public returns (bool)&#13;
  {&#13;
    bool proofFrom = hasClaims(_from);&#13;
    bool proofTo = hasClaims(_to);&#13;
&#13;
    return super.transferFromWithProofs(&#13;
      _from,&#13;
      _to,&#13;
      _value,&#13;
      proofFrom,&#13;
      proofTo&#13;
    );&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev transfer with proofs&#13;
   */&#13;
  function transferWithProofs(&#13;
    address _to,&#13;
    uint256 _value,&#13;
    bool _proofFrom,&#13;
    bool _proofTo&#13;
  ) public returns (bool)&#13;
  {&#13;
    bool proofFrom = _proofFrom || hasClaims(msg.sender);&#13;
    bool proofTo = _proofTo || hasClaims(_to);&#13;
&#13;
    return super.transferWithProofs(&#13;
      _to,&#13;
      _value,&#13;
      proofFrom,&#13;
      proofTo&#13;
    );&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev transfer from with proofs&#13;
   */&#13;
  function transferFromWithProofs(&#13;
    address _from,&#13;
    address _to,&#13;
    uint256 _value,&#13;
    bool _proofFrom,&#13;
    bool _proofTo&#13;
  ) public returns (bool)&#13;
  {&#13;
    bool proofFrom = _proofFrom || hasClaims(_from);&#13;
    bool proofTo = _proofTo || hasClaims(_to);&#13;
&#13;
    return super.transferFromWithProofs(&#13;
      _from,&#13;
      _to,&#13;
      _value,&#13;
      proofFrom,&#13;
      proofTo&#13;
    );&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev define claimables contract to this token&#13;
   */&#13;
  function defineClaimables(IClaimable[] _claimables) public onlyOwner {&#13;
    claimables = _claimables;&#13;
    emit ClaimablesDefined(claimables.length);&#13;
  }&#13;
}&#13;
&#13;
// File: contracts/interface/IRule.sol&#13;
&#13;
/**&#13;
 * @title IRule&#13;
 * @dev IRule interface&#13;
 * @author Cyril Lapinte - &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="fa9983889396d4969b8a93948e9fba978e8a9f969f889394d4999597">[email protected]</a>&gt;&#13;
 *&#13;
 * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved&#13;
 * @notice Please refer to the top of this file for the license.&#13;
 **/&#13;
interface IRule {&#13;
  function isAddressValid(address _address) external view returns (bool);&#13;
  function isTransferValid(address _from, address _to, uint256 _amount)&#13;
    external view returns (bool);&#13;
}&#13;
&#13;
// File: contracts/interface/IWithRules.sol&#13;
&#13;
/**&#13;
 * @title IWithRules&#13;
 * @dev IWithRules interface&#13;
 * @author Cyril Lapinte - &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="690a101b00054705081900071d0c29041d190c050c1b0007470a0604">[email protected]</a>&gt;&#13;
 *&#13;
 * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved&#13;
 * @notice Please refer to the top of this file for the license.&#13;
 **/&#13;
contract IWithRules {&#13;
  function ruleLength() public view returns (uint256);&#13;
  function rule(uint256 _ruleId) public view returns (IRule);&#13;
  function validateAddress(address _address) public view returns (bool);&#13;
  function validateTransfer(address _from, address _to, uint256 _amount)&#13;
    public view returns (bool);&#13;
&#13;
  function defineRules(IRule[] _rules) public;&#13;
&#13;
  event RulesDefined(uint256 count);&#13;
}&#13;
&#13;
// File: contracts/rule/WithRules.sol&#13;
&#13;
/**&#13;
 * @title WithRules&#13;
 * @dev WithRules contract allows inheriting contract to use a set of validation rules&#13;
 * @dev contract owner may add or remove rules&#13;
 *&#13;
 * @author Cyril Lapinte - &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="e2819b908b8ecc8e83928b8c9687a28f9692878e87908b8ccc818d8f">[email protected]</a>&gt;&#13;
 *&#13;
 * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved&#13;
 * @notice Please refer to the top of this file for the license.&#13;
 *&#13;
 * Error messages&#13;
 * WR01: The rules rejected this address&#13;
 * WR02: The rules rejected the transfer&#13;
 **/&#13;
contract WithRules is IWithRules, Ownable {&#13;
&#13;
  IRule[] internal rules;&#13;
&#13;
  /**&#13;
   * @dev Constructor&#13;
   */&#13;
  constructor(IRule[] _rules) public {&#13;
    rules = _rules;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Returns the number of rules&#13;
   */&#13;
  function ruleLength() public view returns (uint256) {&#13;
    return rules.length;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Returns the Rule associated to the specified ruleId&#13;
   */&#13;
  function rule(uint256 _ruleId) public view returns (IRule) {&#13;
    return rules[_ruleId];&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Check if the rules are valid for an address&#13;
   */&#13;
  function validateAddress(address _address) public view returns (bool) {&#13;
    for (uint256 i = 0; i &lt; rules.length; i++) {&#13;
      if (!rules[i].isAddressValid(_address)) {&#13;
        return false;&#13;
      }&#13;
    }&#13;
    return true;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Check if the rules are valid&#13;
   */&#13;
  function validateTransfer(address _from, address _to, uint256 _amount)&#13;
    public view returns (bool)&#13;
  {&#13;
    for (uint256 i = 0; i &lt; rules.length; i++) {&#13;
      if (!rules[i].isTransferValid(_from, _to, _amount)) {&#13;
        return false;&#13;
      }&#13;
    }&#13;
    return true;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Modifier to make functions callable&#13;
   * only when participants follow rules&#13;
   */&#13;
  modifier whenAddressRulesAreValid(address _address) {&#13;
    require(validateAddress(_address), "WR01");&#13;
    _;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Modifier to make transfer functions callable&#13;
   * only when participants follow rules&#13;
   */&#13;
  modifier whenTransferRulesAreValid(&#13;
    address _from,&#13;
    address _to,&#13;
    uint256 _amount)&#13;
  {&#13;
    require(validateTransfer(_from, _to, _amount), "WR02");&#13;
    _;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Define rules to the token&#13;
   */&#13;
  function defineRules(IRule[] _rules) public onlyOwner {&#13;
    rules = _rules;&#13;
    emit RulesDefined(rules.length);&#13;
  }&#13;
}&#13;
&#13;
// File: contracts/token/component/TokenWithRules.sol&#13;
&#13;
/**&#13;
 * @title TokenWithRules&#13;
 * @dev TokenWithRules contract&#13;
 * TokenWithRules is a token that will apply&#13;
 * rules restricting transferability&#13;
 *&#13;
 * @author Cyril Lapinte - &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="b7d4cec5dedb99dbd6c7ded9c3d2f7dac3c7d2dbd2c5ded999d4d8da">[email protected]</a>&gt;&#13;
 *&#13;
 * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved&#13;
 * @notice Please refer to the top of this file for the license.&#13;
 *&#13;
 **/&#13;
contract TokenWithRules is StandardToken, WithRules {&#13;
&#13;
  /**&#13;
   * @dev Constructor&#13;
   */&#13;
  constructor(IRule[] _rules) public WithRules(_rules) { }&#13;
&#13;
  /**&#13;
   * @dev Overriden transfer function&#13;
   */&#13;
  function transfer(address _to, uint256 _value)&#13;
    public whenTransferRulesAreValid(msg.sender, _to, _value)&#13;
    returns (bool)&#13;
  {&#13;
    return super.transfer(_to, _value);&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Overriden transferFrom function&#13;
   */&#13;
  function transferFrom(address _from, address _to, uint256 _value)&#13;
    public whenTransferRulesAreValid(_from, _to, _value)&#13;
    whenAddressRulesAreValid(msg.sender)&#13;
    returns (bool)&#13;
  {&#13;
    return super.transferFrom(_from, _to, _value);&#13;
  }&#13;
}&#13;
&#13;
// File: contracts/token/BridgeToken.sol&#13;
&#13;
/**&#13;
 * @title BridgeToken&#13;
 * @dev BridgeToken contract&#13;
 * @author Cyril Lapinte - &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="a2c1dbd0cbce8ccec3d2cbccd6c7e2cfd6d2c7cec7d0cbcc8cc1cdcf">[email protected]</a>&gt;&#13;
 *&#13;
 * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved&#13;
 * @notice Please refer to the top of this file for the license.&#13;
 */&#13;
contract BridgeToken is TokenWithRules, TokenWithClaims, SeizableToken {&#13;
  string public name;&#13;
  string public symbol;&#13;
&#13;
  /**&#13;
   * @dev constructor&#13;
   */&#13;
  constructor(string _name, string _symbol) &#13;
    TokenWithRules(new IRule[](0))&#13;
    TokenWithClaims(new IClaimable[](0)) public&#13;
  {&#13;
    name = _name;&#13;
    symbol = _symbol;&#13;
  }&#13;
}&#13;
&#13;
// File: contracts/governance/BoardSig.sol&#13;
&#13;
/**&#13;
 * @title BoardSig&#13;
 * @dev BoardSig contract&#13;
 * @author Cyril Lapinte - &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="66051f140f0a480a07160f081203260b1216030a03140f084805090b">[email protected]</a>&gt;&#13;
 *&#13;
 * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved&#13;
 * @notice Please refer to the top of this file for the license.&#13;
 *&#13;
 * @notice Swissquote Bank SA solely is entitled to the GNU LGPL.&#13;
 * @notice Any other party is subject to the copyright mentioned in the software.&#13;
 *&#13;
 * Error messages&#13;
 */&#13;
contract BoardSig is MultiSig {&#13;
  bytes32 public constant TOKENIZE = keccak256("TOKENIZE");&#13;
&#13;
  string public companyName;&#13;
&#13;
  string public country;&#13;
  string public registeredNumber;&#13;
&#13;
  BridgeToken public token;&#13;
&#13;
  /**&#13;
   * @dev constructor function&#13;
   */&#13;
  constructor(address[] _addresses, uint8 _threshold) public&#13;
    MultiSig(_addresses, _threshold)&#13;
  {&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev returns hash of hashed "TOKENIZE"+ token address + document hash&#13;
   */&#13;
  function tokenizeHash(BridgeToken _token, bytes32 _hash)&#13;
    public pure returns (bytes32)&#13;
  {&#13;
    return keccak256(&#13;
      abi.encode(TOKENIZE, address(_token), _hash)&#13;
    );&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev tokenize shares&#13;
   */&#13;
  function tokenizeShares(&#13;
    BridgeToken _token,&#13;
    bytes32 _hash,&#13;
    bytes32[] _sigR,&#13;
    bytes32[] _sigS,&#13;
    uint8[] _sigV) public&#13;
    thresholdRequired(address(this), 0,&#13;
      abi.encodePacked(tokenizeHash(_token, _hash)),&#13;
      0, threshold, _sigR, _sigS, _sigV)&#13;
  {&#13;
    updateReplayProtection();&#13;
    token = _token;&#13;
&#13;
    emit ShareTokenization(_token, _hash);&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev add board meeting&#13;
   */&#13;
  function addBoardMeeting(&#13;
    bytes32 _hash,&#13;
    bytes32[] _sigR,&#13;
    bytes32[] _sigS,&#13;
    uint8[] _sigV) public&#13;
    thresholdRequired(address(this), 0,&#13;
      abi.encodePacked(_hash),&#13;
      0, threshold, _sigR, _sigS, _sigV)&#13;
  {&#13;
    emit BoardMeetingHash(_hash);&#13;
  }&#13;
&#13;
  event ShareTokenization(BridgeToken token, bytes32 hash);&#13;
  event BoardMeetingHash(bytes32 hash);&#13;
&#13;
}&#13;
&#13;
// File: contracts/mps/MPSBoardSig.sol&#13;
&#13;
/**&#13;
 * @title MPSBoardSig&#13;
 * @dev MPSBoardSig contract&#13;
 * @author Cyril Lapinte - &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="98fbe1eaf1f4b6f4f9e8f1f6ecfdd8f5ece8fdf4fdeaf1f6b6fbf7f5">[email protected]</a>&gt;&#13;
 *&#13;
 * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved&#13;
 * @notice Please refer to the top of this file for the license.&#13;
 *&#13;
 * Error messages&#13;
 */&#13;
contract MPSBoardSig is BoardSig {&#13;
&#13;
  string public companyName = "MtPelerin Group SA";&#13;
  string public country = "Switzerland";&#13;
  string public registeredNumber = "CHE-188.552.084";&#13;
&#13;
  /**&#13;
   * @dev constructor function&#13;
   */&#13;
  constructor(address[] _addresses, uint8 _threshold) public&#13;
    BoardSig(_addresses, _threshold)&#13;
  {&#13;
  }&#13;
}