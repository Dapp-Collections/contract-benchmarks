pragma solidity ^0.4.24;

/*
 * ETHCutter Contract
 * 
 * - 1% per hour for 5 days (120% total)
 * - 6% referral program (1 level)
 * - 0.1-100 ETH per deposit (unlimited deposits count)
 * 
 *  1. Set an address of you upline in DATA field (if exists), and send 0.1-100 ETH to contract address. Gas limit: 300000.
 *  2. Send 0 or not more than 0.1 ETH and get your profit. You can get profit at any time (every minute, every hour, every day).
 *
 * EMAIL: <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="5035243833252424352210373d31393c7e333f3d">[emailÂ protected]</a>&#13;
 * TELEGRAM SUPPORT 24/7: https://t.me/ethcutter_support or tg://resolve?domain=ethcutter_support&#13;
 * TELEGRAM CHAT (RU): https://t.me/ethcutter_ru or tg://resolve?domain=ethcutter_ru&#13;
 * TELEGRAM CHAT (EN): https://t.me/ethcutter_en or tg://resolve?domain=ethcutter_en&#13;
 */&#13;
&#13;
library SafeMath {&#13;
    function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {&#13;
        if (_a == 0) {&#13;
            return 0;&#13;
        }&#13;
        c = _a * _b;&#13;
        require(c / _a == _b);&#13;
        return c;&#13;
    }&#13;
&#13;
    function div(uint256 _a, uint256 _b) internal pure returns (uint256) {&#13;
        return _a / _b;&#13;
    }&#13;
&#13;
    function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {&#13;
        require(_b &lt;= _a);&#13;
        return _a - _b;&#13;
    }&#13;
&#13;
    function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {&#13;
        c = _a + _b;&#13;
        require(c &gt;= _a);&#13;
        return c;&#13;
    }&#13;
}&#13;
&#13;
library AddressUtils {&#13;
    function isContract(address _addr) internal view returns (bool) {&#13;
        uint256 size;&#13;
        assembly {size := extcodesize(_addr)}&#13;
        return size &gt; 0;&#13;
    }&#13;
}&#13;
&#13;
library Helpers {&#13;
    function walletFromData(bytes data) internal pure returns (address wallet) {&#13;
        assembly {&#13;
            wallet := mload(add(data, 20))&#13;
        }&#13;
    }&#13;
}&#13;
&#13;
contract ETHCutter {&#13;
    using SafeMath for uint256;&#13;
    using AddressUtils for address;&#13;
&#13;
    address public adminWallet;&#13;
&#13;
    uint256 constant public DEPOSIT_MIN = 10 finney;&#13;
    uint256 constant public DEPOSIT_MAX = 10 ether;&#13;
    uint256 constant public DEPOSIT_PERIOD = 5 days;&#13;
    uint256 constant public TOTAL_PERCENT = 120;&#13;
    uint256 constant public UPLINE_PERCENT = 6;&#13;
    uint256 constant public EXPENSES_PERCENT = 15;&#13;
&#13;
    uint256 public totalDeposited = 0;&#13;
    uint256 public totalWithdrawn = 0;&#13;
    uint256 public usersCount = 0;&#13;
    uint256 public depositsCount = 0;&#13;
    uint256 public expenses = 0;&#13;
&#13;
    mapping(address =&gt; User) public users;&#13;
    mapping(uint256 =&gt; Deposit) public deposits;&#13;
&#13;
    struct Deposit {&#13;
        uint256 createdAt;&#13;
        uint256 endAt;&#13;
        uint256 amount;&#13;
        uint256 accrued;&#13;
        uint256 totalForAccrual;&#13;
        bool active;&#13;
    }&#13;
&#13;
    struct User {&#13;
        uint256 createdAt;&#13;
        address upline;&#13;
        uint256 totalDeposited;&#13;
        uint256 totalWithdrawn;&#13;
        uint256 depositsCount;&#13;
        uint256[] deposits;&#13;
    }&#13;
&#13;
    modifier onlyAdmin() {&#13;
        require(msg.sender == adminWallet);&#13;
        _;&#13;
    }&#13;
&#13;
    constructor() public {&#13;
        adminWallet = msg.sender;&#13;
        createUser(msg.sender, address(0));&#13;
    }&#13;
&#13;
    function createUser(address wallet, address upline) internal {&#13;
        users[wallet] = User({&#13;
            createdAt : now,&#13;
            upline : upline,&#13;
            totalDeposited : 0,&#13;
            totalWithdrawn : 0,&#13;
            depositsCount : 0,&#13;
            deposits : new uint256[](0)&#13;
            });&#13;
        usersCount++;&#13;
    }&#13;
&#13;
    function createDeposit(address wallet, uint256 amount) internal {&#13;
        User storage user = users[wallet];&#13;
&#13;
        Deposit memory deposit = Deposit({&#13;
            createdAt : now,&#13;
            endAt : now.add(DEPOSIT_PERIOD),&#13;
            amount : amount,&#13;
            accrued : 0,&#13;
            totalForAccrual : amount.div(100).mul(TOTAL_PERCENT),&#13;
            active : true&#13;
        });&#13;
&#13;
        deposits[depositsCount] = deposit;&#13;
        user.deposits.push(depositsCount);&#13;
&#13;
        user.totalDeposited = user.totalDeposited.add(amount);&#13;
        totalDeposited = amount.add(totalDeposited);&#13;
&#13;
        user.depositsCount++;&#13;
        depositsCount++;&#13;
        expenses = expenses.add(amount.div(100).mul(EXPENSES_PERCENT));&#13;
&#13;
        uint256 referralFee = amount.div(100).mul(UPLINE_PERCENT);&#13;
        transferReferralFee(user.upline, referralFee);&#13;
    }&#13;
&#13;
    function transferReferralFee(address to, uint256 amount) internal {&#13;
        if (to != address(0)) {&#13;
            to.transfer(amount);&#13;
        }&#13;
    }&#13;
&#13;
    function getUpline() internal view returns (address){&#13;
        address uplineWallet = Helpers.walletFromData(msg.data);&#13;
        return users[uplineWallet].createdAt &gt; 0 &amp;&amp; msg.sender != uplineWallet&#13;
        ? uplineWallet&#13;
        : adminWallet;&#13;
    }&#13;
&#13;
    function() payable public {&#13;
        address wallet = msg.sender;&#13;
        uint256 amount = msg.value;&#13;
&#13;
        require(wallet != address(0), 'Address incorrect');&#13;
        require(!wallet.isContract(), 'Address is contract');&#13;
        require(amount &lt;= DEPOSIT_MAX, 'Amount too big');&#13;
&#13;
        if (users[wallet].createdAt == 0) {&#13;
            createUser(wallet, getUpline());&#13;
        }&#13;
&#13;
        if (amount &gt;= DEPOSIT_MIN) {&#13;
            createDeposit(wallet, amount);&#13;
        } else {&#13;
            accrualDeposits();&#13;
        }&#13;
    }&#13;
&#13;
    function accrualDeposits() internal {&#13;
        address wallet = msg.sender;&#13;
        User storage user = users[wallet];&#13;
&#13;
        for (uint i = 0; i &lt; user.depositsCount; i++) {&#13;
            if (deposits[user.deposits[i]].active) {&#13;
                accrual(user.deposits[i], wallet);&#13;
            }&#13;
        }&#13;
    }&#13;
&#13;
    function getAccrualAmount(Deposit deposit) internal view returns (uint256){&#13;
        uint256 amount = deposit.totalForAccrual&#13;
        .div(DEPOSIT_PERIOD)&#13;
        .mul(&#13;
            now.sub(deposit.createdAt)&#13;
        )&#13;
        .sub(deposit.accrued);&#13;
&#13;
        if (amount.add(deposit.accrued) &gt; deposit.totalForAccrual) {&#13;
            amount = deposit.totalForAccrual.sub(deposit.accrued);&#13;
        }&#13;
&#13;
        return amount;&#13;
    }&#13;
&#13;
    function accrual(uint256 depositId, address wallet) internal {&#13;
        uint256 amount = getAccrualAmount(deposits[depositId]);&#13;
        Deposit storage deposit = deposits[depositId];&#13;
&#13;
        withdraw(wallet, amount);&#13;
&#13;
        deposits[depositId].accrued = deposit.accrued.add(amount);&#13;
&#13;
        if (deposits[depositId].accrued &gt;= deposit.totalForAccrual) {&#13;
            deposits[depositId].active = false;&#13;
        }&#13;
    }&#13;
&#13;
    function withdraw(address wallet, uint256 amount) internal {&#13;
        wallet.transfer(amount);&#13;
        totalWithdrawn = totalWithdrawn.add(amount);&#13;
        users[wallet].totalWithdrawn = users[wallet].totalWithdrawn.add(amount);&#13;
    }&#13;
&#13;
    function withdrawExpenses() public onlyAdmin {&#13;
        adminWallet.transfer(expenses);&#13;
        expenses = 0;&#13;
    }&#13;
&#13;
    function getUserDeposits(address _address) public view returns (uint256[]){&#13;
        return users[_address].deposits;&#13;
    }&#13;
&#13;
}