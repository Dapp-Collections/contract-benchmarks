pragma solidity ^0.4.18;
/* ==================================================================== */
/* Copyright (c) 2018 The Priate Conquest Project.  All rights reserved.
/* 
/* https://www.pirateconquest.com One of the world's slg games of blockchain 
/*  
/* authors <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="1d6f7c7473645d71746b786e697c6f337e7270">[email protected]</a>/<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="9ad0f5f4f4e3b4dcefdaf6f3ecffe9eefbe8b4f9f5f7">[email protected]</a>&#13;
/*                 &#13;
/* ==================================================================== */&#13;
/// This Random is inspired by https://github.com/axiomzen/eth-random&#13;
contract Random {&#13;
    uint256 _seed;&#13;
&#13;
    function _rand() internal returns (uint256) {&#13;
        _seed = uint256(keccak256(_seed, block.blockhash(block.number - 1), block.coinbase, block.difficulty));&#13;
        return _seed;&#13;
    }&#13;
&#13;
    function _randBySeed(uint256 _outSeed) internal view returns (uint256) {&#13;
        return uint256(keccak256(_outSeed, block.blockhash(block.number - 1), block.coinbase, block.difficulty));&#13;
    }&#13;
&#13;
    &#13;
    function _randByRange(uint256 _min, uint256 _max) internal returns (uint256) {&#13;
        if (_min &gt;= _max) {&#13;
            return _min;&#13;
        }&#13;
        return (_rand() % (_max - _min +1)) + _min;&#13;
    }&#13;
&#13;
    function _rankByNumber(uint256 _max) internal returns (uint256) {&#13;
        return _rand() % _max;&#13;
    }&#13;
    &#13;
}&#13;
&#13;
interface CaptainTokenInterface {&#13;
  function CreateCaptainToken(address _owner,uint256 _price, uint32 _captainId, uint32 _color,uint32 _atk,uint32 _defense,uint32 _atk_min,uint32 _atk_max) public ;&#13;
  function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256);&#13;
  function balanceOf(address _owner) external view returns (uint256);&#13;
  function setTokenPrice(uint256 _tokenId, uint256 _price) external;&#13;
  function checkCaptain(address _owner,uint32 _captainId) external returns (bool);&#13;
  function setSelled(uint256 _tokenId, bool fsell) external;&#13;
}&#13;
&#13;
interface CaptainGameConfigInterface {&#13;
  function getCardInfo(uint32 cardId) external constant returns (uint32,uint32,uint32, uint32,uint32,uint256,uint256);&#13;
  function getSellable(uint32 _captainId) external returns (bool);&#13;
  function getLevelConfig(uint32 cardId, uint32 level) external view returns (uint32 atk,uint32 defense,uint32 atk_min,uint32 atk_max);&#13;
}&#13;
&#13;
contract CaptainPreSell is Random {&#13;
  using SafeMath for SafeMath;&#13;
  address devAddress;&#13;
  &#13;
  function CaptainPreSell() public {&#13;
    devAddress = msg.sender;&#13;
  }&#13;
&#13;
  CaptainTokenInterface public captains;&#13;
  CaptainGameConfigInterface public config; &#13;
  /// @dev The BuyToken event is fired whenever a token is sold.&#13;
  event BuyToken(uint256 tokenId, uint256 oldPrice, address prevOwner, address winner);&#13;
  &#13;
  //mapping&#13;
  mapping(uint32 =&gt; uint256) captainToCount;&#13;
  mapping(address =&gt; uint32[]) captainUserMap; &#13;
  /// @notice No tipping!&#13;
  /// @dev Reject all Ether from being sent here, unless it's from one of the&#13;
  ///  two auction contracts. (Hopefully, we can prevent user accidents.)&#13;
  function() external payable {&#13;
  }&#13;
&#13;
  modifier onlyOwner() {&#13;
    require(msg.sender == devAddress);&#13;
    _;&#13;
  }&#13;
&#13;
  //setting configuration&#13;
  function setGameConfigContract(address _address) external onlyOwner {&#13;
    config = CaptainGameConfigInterface(_address);&#13;
  }&#13;
&#13;
  //setting configuration&#13;
  function setCaptainTokenContract(address _address) external onlyOwner {&#13;
    captains = CaptainTokenInterface(_address);&#13;
  }&#13;
&#13;
  function prepurchase(uint32 _captainId) external payable {&#13;
    uint32 color;&#13;
    uint32 atk;&#13;
    uint32 defense;&#13;
    uint256 price;&#13;
    uint256 captainCount;&#13;
    uint256 SellCount = captainToCount[_captainId];&#13;
    (color,atk,,,defense,price,captainCount) = config.getCardInfo(_captainId);&#13;
    require(config.getSellable(_captainId) == true);&#13;
    SellCount += 1;&#13;
    require(SellCount&lt;=captainCount);&#13;
    uint256 rdm = _randByRange(90,110) % 10000;&#13;
    // Safety check to prevent against an unexpected 0x0 default.&#13;
    require(msg.sender != address(0));&#13;
    require(!captains.checkCaptain(msg.sender,_captainId));&#13;
    // Making sure sent amount is greater than or equal to the sellingPrice&#13;
    require(msg.value &gt;= price);&#13;
     //get the config&#13;
    uint32 atk_min;&#13;
    uint32 atk_max; &#13;
    (,,atk_min,atk_max) = config.getLevelConfig(_captainId,1);&#13;
   &#13;
    atk_min = uint32(SafeMath.div(SafeMath.mul(uint256(atk_min),rdm),100));&#13;
    atk_max = uint32(SafeMath.div(SafeMath.mul(uint256(atk_max),rdm),100));&#13;
   &#13;
    price = SafeMath.div(SafeMath.mul(price,130),100);&#13;
    captains.CreateCaptainToken(msg.sender,price,_captainId,color,atk, defense,atk_min,atk_max);&#13;
  &#13;
    uint256 balance = captains.balanceOf(msg.sender);&#13;
    uint256 tokenId = captains.tokenOfOwnerByIndex(msg.sender,balance-1);&#13;
    captains.setTokenPrice(tokenId,price);&#13;
    //captains.setSelled(tokenId,true);&#13;
    captainToCount[_captainId] = SellCount;&#13;
&#13;
    //transfer&#13;
    //devAddress.transfer(msg.value);&#13;
    //event &#13;
    BuyToken(_captainId, price,address(this),msg.sender);&#13;
  }&#13;
&#13;
  function getCaptainCount(uint32 _captainId) external constant returns (uint256) {&#13;
    return captainToCount[_captainId];&#13;
  }&#13;
&#13;
  //@notice withraw all by dev&#13;
  function withdraw() external onlyOwner {&#13;
    require(this.balance&gt;0);&#13;
    msg.sender.transfer(this.balance);&#13;
  }&#13;
}&#13;
&#13;
library SafeMath {&#13;
&#13;
  /**&#13;
  * @dev Multiplies two numbers, throws on overflow.&#13;
  */&#13;
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
    if (a == 0) {&#13;
      return 0;&#13;
    }&#13;
    uint256 c = a * b;&#13;
    assert(c / a == b);&#13;
    return c;&#13;
  }&#13;
&#13;
  function mul32(uint32 a, uint32 b) internal pure returns (uint32) {&#13;
    if (a == 0) {&#13;
      return 0;&#13;
    }&#13;
    uint32 c = a * b;&#13;
    assert(c / a == b);&#13;
    return c;&#13;
  }&#13;
&#13;
  /**&#13;
  * @dev Integer division of two numbers, truncating the quotient.&#13;
  */&#13;
  function div(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
    // assert(b &gt; 0); // Solidity automatically throws when dividing by 0&#13;
    uint256 c = a / b;&#13;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold&#13;
    return c;&#13;
  }&#13;
&#13;
  function div32(uint32 a, uint32 b) internal pure returns (uint32) {&#13;
    // assert(b &gt; 0); // Solidity automatically throws when dividing by 0&#13;
    uint32 c = a / b;&#13;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold&#13;
    return c;&#13;
  }&#13;
&#13;
  /**&#13;
  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).&#13;
  */&#13;
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
    assert(b &lt;= a);&#13;
    return a - b;&#13;
  }&#13;
&#13;
  function sub32(uint32 a, uint32 b) internal pure returns (uint32) {&#13;
    assert(b &lt;= a);&#13;
    return a - b;&#13;
  }&#13;
&#13;
  /**&#13;
  * @dev Adds two numbers, throws on overflow.&#13;
  */&#13;
  function add(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
    uint256 c = a + b;&#13;
    assert(c &gt;= a);&#13;
    return c;&#13;
  }&#13;
&#13;
  function add32(uint32 a, uint32 b) internal pure returns (uint32) {&#13;
    uint32 c = a + b;&#13;
    assert(c &gt;= a);&#13;
    return c;&#13;
  }&#13;
}