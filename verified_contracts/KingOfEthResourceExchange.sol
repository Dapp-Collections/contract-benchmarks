// File: contracts/GodMode.sol

/****************************************************
 *
 * Copyright 2018 BurzNest LLC. All rights reserved.
 *
 * The contents of this file are provided for review
 * and educational purposes ONLY. You MAY NOT use,
 * copy, distribute, or modify this software without
 * explicit written permission from BurzNest LLC.
 *
 ****************************************************/

pragma solidity ^0.4.24;

/// @title God Mode
/// @author Anthony Burzillo <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="d8baadaaa298baadaaa2b6bdabacf6bbb7b5">[email protected]</a>&gt;&#13;
/// @dev This contract provides a basic interface for God&#13;
///  in a contract as well as the ability for God to pause&#13;
///  the contract&#13;
contract GodMode {&#13;
    /// @dev Is the contract paused?&#13;
    bool public isPaused;&#13;
&#13;
    /// @dev God's address&#13;
    address public god;&#13;
&#13;
    /// @dev Only God can run this function&#13;
    modifier onlyGod()&#13;
    {&#13;
        require(god == msg.sender);&#13;
        _;&#13;
    }&#13;
&#13;
    /// @dev This function can only be run while the contract&#13;
    ///  is not paused&#13;
    modifier notPaused()&#13;
    {&#13;
        require(!isPaused);&#13;
        _;&#13;
    }&#13;
&#13;
    /// @dev This event is fired when the contract is paused&#13;
    event GodPaused();&#13;
&#13;
    /// @dev This event is fired when the contract is unpaused&#13;
    event GodUnpaused();&#13;
&#13;
    constructor() public&#13;
    {&#13;
        // Make the creator of the contract God&#13;
        god = msg.sender;&#13;
    }&#13;
&#13;
    /// @dev God can change the address of God&#13;
    /// @param _newGod The new address for God&#13;
    function godChangeGod(address _newGod) public onlyGod&#13;
    {&#13;
        god = _newGod;&#13;
    }&#13;
&#13;
    /// @dev God can pause the game&#13;
    function godPause() public onlyGod&#13;
    {&#13;
        isPaused = true;&#13;
&#13;
        emit GodPaused();&#13;
    }&#13;
&#13;
    /// @dev God can unpause the game&#13;
    function godUnpause() public onlyGod&#13;
    {&#13;
        isPaused = false;&#13;
&#13;
        emit GodUnpaused();&#13;
    }&#13;
}&#13;
&#13;
// File: contracts/KingOfEthEthExchangeReferencer.sol&#13;
&#13;
/****************************************************&#13;
 *&#13;
 * Copyright 2018 BurzNest LLC. All rights reserved.&#13;
 *&#13;
 * The contents of this file are provided for review&#13;
 * and educational purposes ONLY. You MAY NOT use,&#13;
 * copy, distribute, or modify this software without&#13;
 * explicit written permission from BurzNest LLC.&#13;
 *&#13;
 ****************************************************/&#13;
&#13;
pragma solidity ^0.4.24;&#13;
&#13;
&#13;
/// @title King of Eth: Resource-to-ETH Exchange Referencer&#13;
/// @author Anthony Burzillo &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="fb998e8981bb998e8981959e888fd5989496">[email protected]</a>&gt;&#13;
/// @dev Provides functionality to interface with the&#13;
///  ETH exchange contract&#13;
contract KingOfEthEthExchangeReferencer is GodMode {&#13;
    /// @dev Address of the ETH exchange contract&#13;
    address public ethExchangeContract;&#13;
&#13;
    /// @dev Only the ETH exchange contract may run this function&#13;
    modifier onlyEthExchangeContract()&#13;
    {&#13;
        require(ethExchangeContract == msg.sender);&#13;
        _;&#13;
    }&#13;
&#13;
    /// @dev God may set the ETH exchange contract's address&#13;
    /// @dev _ethExchangeContract The new address&#13;
    function godSetEthExchangeContract(address _ethExchangeContract)&#13;
        public&#13;
        onlyGod&#13;
    {&#13;
        ethExchangeContract = _ethExchangeContract;&#13;
    }&#13;
}&#13;
&#13;
// File: contracts/KingOfEthResourceExchangeReferencer.sol&#13;
&#13;
/****************************************************&#13;
 *&#13;
 * Copyright 2018 BurzNest LLC. All rights reserved.&#13;
 *&#13;
 * The contents of this file are provided for review&#13;
 * and educational purposes ONLY. You MAY NOT use,&#13;
 * copy, distribute, or modify this software without&#13;
 * explicit written permission from BurzNest LLC.&#13;
 *&#13;
 ****************************************************/&#13;
&#13;
pragma solidity ^0.4.24;&#13;
&#13;
&#13;
/// @title King of Eth: Resource-to-Resource Exchange Referencer&#13;
/// @author Anthony Burzillo &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="610314131b210314131b0f0412154f020e0c">[email protected]</a>&gt;&#13;
/// @dev Provides functionality to interface with the&#13;
///  resource-to-resource contract&#13;
contract KingOfEthResourceExchangeReferencer is GodMode {&#13;
    /// @dev Address of the resource-to-resource contract&#13;
    address public resourceExchangeContract;&#13;
&#13;
    /// @dev Only the resource-to-resource contract may run this function&#13;
    modifier onlyResourceExchangeContract()&#13;
    {&#13;
        require(resourceExchangeContract == msg.sender);&#13;
        _;&#13;
    }&#13;
&#13;
    /// @dev God may set the resource-to-resource contract's address&#13;
    /// @dev _resourceExchangeContract The new address&#13;
    function godSetResourceExchangeContract(address _resourceExchangeContract)&#13;
        public&#13;
        onlyGod&#13;
    {&#13;
        resourceExchangeContract = _resourceExchangeContract;&#13;
    }&#13;
}&#13;
&#13;
// File: contracts/KingOfEthExchangeReferencer.sol&#13;
&#13;
/****************************************************&#13;
 *&#13;
 * Copyright 2018 BurzNest LLC. All rights reserved.&#13;
 *&#13;
 * The contents of this file are provided for review&#13;
 * and educational purposes ONLY. You MAY NOT use,&#13;
 * copy, distribute, or modify this software without&#13;
 * explicit written permission from BurzNest LLC.&#13;
 *&#13;
 ****************************************************/&#13;
&#13;
pragma solidity ^0.4.24;&#13;
&#13;
&#13;
&#13;
&#13;
/// @title King of Eth: Exchange Referencer&#13;
/// @author Anthony Burzillo &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="036176717943617671796d6670772d606c6e">[email protected]</a>&gt;&#13;
/// @dev Provides functionality to interface with the exchange contract&#13;
contract KingOfEthExchangeReferencer is&#13;
      GodMode&#13;
    , KingOfEthEthExchangeReferencer&#13;
    , KingOfEthResourceExchangeReferencer&#13;
{&#13;
    /// @dev Only one of the exchange contracts may&#13;
    ///  run this function&#13;
    modifier onlyExchangeContract()&#13;
    {&#13;
        require(&#13;
               ethExchangeContract == msg.sender&#13;
            || resourceExchangeContract == msg.sender&#13;
        );&#13;
        _;&#13;
    }&#13;
}&#13;
&#13;
// File: contracts/KingOfEthHousesReferencer.sol&#13;
&#13;
/****************************************************&#13;
 *&#13;
 * Copyright 2018 BurzNest LLC. All rights reserved.&#13;
 *&#13;
 * The contents of this file are provided for review&#13;
 * and educational purposes ONLY. You MAY NOT use,&#13;
 * copy, distribute, or modify this software without&#13;
 * explicit written permission from BurzNest LLC.&#13;
 *&#13;
 ****************************************************/&#13;
&#13;
pragma solidity ^0.4.24;&#13;
&#13;
&#13;
/// @title King of Eth: Houses Referencer&#13;
/// @author Anthony Burzillo &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="284a5d5a52684a5d5a52464d5b5c064b4745">[email protected]</a>&gt;&#13;
/// @dev Provides functionality to reference the houses contract&#13;
contract KingOfEthHousesReferencer is GodMode {&#13;
    /// @dev The houses contract's address&#13;
    address public housesContract;&#13;
&#13;
    /// @dev Only the houses contract can run this function&#13;
    modifier onlyHousesContract()&#13;
    {&#13;
        require(housesContract == msg.sender);&#13;
        _;&#13;
    }&#13;
&#13;
    /// @dev God can set the realty contract&#13;
    /// @param _housesContract The new address&#13;
    function godSetHousesContract(address _housesContract)&#13;
        public&#13;
        onlyGod&#13;
    {&#13;
        housesContract = _housesContract;&#13;
    }&#13;
}&#13;
&#13;
// File: contracts/KingOfEthResourcesInterfaceReferencer.sol&#13;
&#13;
/****************************************************&#13;
 *&#13;
 * Copyright 2018 BurzNest LLC. All rights reserved.&#13;
 *&#13;
 * The contents of this file are provided for review&#13;
 * and educational purposes ONLY. You MAY NOT use,&#13;
 * copy, distribute, or modify this software without&#13;
 * explicit written permission from BurzNest LLC.&#13;
 *&#13;
 ****************************************************/&#13;
&#13;
pragma solidity ^0.4.24;&#13;
&#13;
&#13;
/// @title King of Eth: Resources Interface Referencer&#13;
/// @author Anthony Burzillo &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="d6b4a3a4ac96b4a3a4acb8b3a5a2f8b5b9bb">[email protected]</a>&gt;&#13;
/// @dev Provides functionality to reference the resource interface contract&#13;
contract KingOfEthResourcesInterfaceReferencer is GodMode {&#13;
    /// @dev The interface contract's address&#13;
    address public interfaceContract;&#13;
&#13;
    /// @dev Only the interface contract can run this function&#13;
    modifier onlyInterfaceContract()&#13;
    {&#13;
        require(interfaceContract == msg.sender);&#13;
        _;&#13;
    }&#13;
&#13;
    /// @dev God can set the realty contract&#13;
    /// @param _interfaceContract The new address&#13;
    function godSetInterfaceContract(address _interfaceContract)&#13;
        public&#13;
        onlyGod&#13;
    {&#13;
        interfaceContract = _interfaceContract;&#13;
    }&#13;
}&#13;
&#13;
// File: contracts/KingOfEthResource.sol&#13;
&#13;
/****************************************************&#13;
 *&#13;
 * Copyright 2018 BurzNest LLC. All rights reserved.&#13;
 *&#13;
 * The contents of this file are provided for review&#13;
 * and educational purposes ONLY. You MAY NOT use,&#13;
 * copy, distribute, or modify this software without&#13;
 * explicit written permission from BurzNest LLC.&#13;
 *&#13;
 ****************************************************/&#13;
&#13;
pragma solidity ^0.4.24;&#13;
&#13;
&#13;
&#13;
/// @title ERC20Interface&#13;
/// @dev ERC20 token interface contract&#13;
contract ERC20Interface {&#13;
    function totalSupply() public constant returns(uint);&#13;
    function balanceOf(address _tokenOwner) public constant returns(uint balance);&#13;
    function allowance(address _tokenOwner, address _spender) public constant returns(uint remaining);&#13;
    function transfer(address _to, uint _tokens) public returns(bool success);&#13;
    function approve(address _spender, uint _tokens) public returns(bool success);&#13;
    function transferFrom(address _from, address _to, uint _tokens) public returns(bool success);&#13;
&#13;
    event Transfer(address indexed from, address indexed to, uint tokens);&#13;
    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);&#13;
}&#13;
&#13;
/// @title King of Eth: Resource&#13;
/// @author Anthony Burzillo &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="0c6e797e764c6e797e7662697f78226f6361">[email protected]</a>&gt;&#13;
/// @dev Common contract implementation for resources&#13;
contract KingOfEthResource is&#13;
      ERC20Interface&#13;
    , GodMode&#13;
    , KingOfEthResourcesInterfaceReferencer&#13;
{&#13;
    /// @dev Current resource supply&#13;
    uint public resourceSupply;&#13;
&#13;
    /// @dev ERC20 token's decimals&#13;
    uint8 public constant decimals = 0;&#13;
&#13;
    /// @dev mapping of addresses to holdings&#13;
    mapping (address =&gt; uint) holdings;&#13;
&#13;
    /// @dev mapping of addresses to amount of tokens frozen&#13;
    mapping (address =&gt; uint) frozenHoldings;&#13;
&#13;
    /// @dev mapping of addresses to mapping of allowances for an address&#13;
    mapping (address =&gt; mapping (address =&gt; uint)) allowances;&#13;
&#13;
    /// @dev ERC20 total supply&#13;
    /// @return The current total supply of the resource&#13;
    function totalSupply()&#13;
        public&#13;
        constant&#13;
        returns(uint)&#13;
    {&#13;
        return resourceSupply;&#13;
    }&#13;
&#13;
    /// @dev ERC20 balance of address&#13;
    /// @param _tokenOwner The address to look up&#13;
    /// @return The balance of the address&#13;
    function balanceOf(address _tokenOwner)&#13;
        public&#13;
        constant&#13;
        returns(uint balance)&#13;
    {&#13;
        return holdings[_tokenOwner];&#13;
    }&#13;
&#13;
    /// @dev Total resources frozen for an address&#13;
    /// @param _tokenOwner The address to look up&#13;
    /// @return The frozen balance of the address&#13;
    function frozenTokens(address _tokenOwner)&#13;
        public&#13;
        constant&#13;
        returns(uint balance)&#13;
    {&#13;
        return frozenHoldings[_tokenOwner];&#13;
    }&#13;
&#13;
    /// @dev The allowance for a spender on an account&#13;
    /// @param _tokenOwner The account that allows withdrawels&#13;
    /// @param _spender The account that is allowed to withdraw&#13;
    /// @return The amount remaining in the allowance&#13;
    function allowance(address _tokenOwner, address _spender)&#13;
        public&#13;
        constant&#13;
        returns(uint remaining)&#13;
    {&#13;
        return allowances[_tokenOwner][_spender];&#13;
    }&#13;
&#13;
    /// @dev Only run if player has at least some amount of tokens&#13;
    /// @param _owner The owner of the tokens&#13;
    /// @param _tokens The amount of tokens required&#13;
    modifier hasAvailableTokens(address _owner, uint _tokens)&#13;
    {&#13;
        require(holdings[_owner] - frozenHoldings[_owner] &gt;= _tokens);&#13;
        _;&#13;
    }&#13;
&#13;
    /// @dev Only run if player has at least some amount of tokens frozen&#13;
    /// @param _owner The owner of the tokens&#13;
    /// @param _tokens The amount of frozen tokens required&#13;
    modifier hasFrozenTokens(address _owner, uint _tokens)&#13;
    {&#13;
        require(frozenHoldings[_owner] &gt;= _tokens);&#13;
        _;&#13;
    }&#13;
&#13;
    /// @dev Set up the exact same state in each resource&#13;
    constructor() public&#13;
    {&#13;
        // God gets 200 to put on exchange&#13;
        holdings[msg.sender] = 200;&#13;
&#13;
        resourceSupply = 200;&#13;
    }&#13;
&#13;
    /// @dev The resources interface can burn tokens for building&#13;
    ///  roads or houses&#13;
    /// @param _owner The owner of the tokens&#13;
    /// @param _tokens The amount of tokens to burn&#13;
    function interfaceBurnTokens(address _owner, uint _tokens)&#13;
        public&#13;
        onlyInterfaceContract&#13;
        hasAvailableTokens(_owner, _tokens)&#13;
    {&#13;
        holdings[_owner] -= _tokens;&#13;
&#13;
        resourceSupply -= _tokens;&#13;
&#13;
        // Pretend the tokens were sent to 0x0&#13;
        emit Transfer(_owner, 0x0, _tokens);&#13;
    }&#13;
&#13;
    /// @dev The resources interface contract can mint tokens for houses&#13;
    /// @param _owner The owner of the tokens&#13;
    /// @param _tokens The amount of tokens to burn&#13;
    function interfaceMintTokens(address _owner, uint _tokens)&#13;
        public&#13;
        onlyInterfaceContract&#13;
    {&#13;
        holdings[_owner] += _tokens;&#13;
&#13;
        resourceSupply += _tokens;&#13;
&#13;
        // Pretend the tokens were sent from the interface contract&#13;
        emit Transfer(interfaceContract, _owner, _tokens);&#13;
    }&#13;
&#13;
    /// @dev The interface can freeze tokens&#13;
    /// @param _owner The owner of the tokens&#13;
    /// @param _tokens The amount of tokens to freeze&#13;
    function interfaceFreezeTokens(address _owner, uint _tokens)&#13;
        public&#13;
        onlyInterfaceContract&#13;
        hasAvailableTokens(_owner, _tokens)&#13;
    {&#13;
        frozenHoldings[_owner] += _tokens;&#13;
    }&#13;
&#13;
    /// @dev The interface can thaw tokens&#13;
    /// @param _owner The owner of the tokens&#13;
    /// @param _tokens The amount of tokens to thaw&#13;
    function interfaceThawTokens(address _owner, uint _tokens)&#13;
        public&#13;
        onlyInterfaceContract&#13;
        hasFrozenTokens(_owner, _tokens)&#13;
    {&#13;
        frozenHoldings[_owner] -= _tokens;&#13;
    }&#13;
&#13;
    /// @dev The interface can transfer tokens&#13;
    /// @param _from The owner of the tokens&#13;
    /// @param _to The new owner of the tokens&#13;
    /// @param _tokens The amount of tokens to transfer&#13;
    function interfaceTransfer(address _from, address _to, uint _tokens)&#13;
        public&#13;
        onlyInterfaceContract&#13;
    {&#13;
        assert(holdings[_from] &gt;= _tokens);&#13;
&#13;
        holdings[_from] -= _tokens;&#13;
        holdings[_to]   += _tokens;&#13;
&#13;
        emit Transfer(_from, _to, _tokens);&#13;
    }&#13;
&#13;
    /// @dev The interface can transfer frozend tokens&#13;
    /// @param _from The owner of the tokens&#13;
    /// @param _to The new owner of the tokens&#13;
    /// @param _tokens The amount of frozen tokens to transfer&#13;
    function interfaceFrozenTransfer(address _from, address _to, uint _tokens)&#13;
        public&#13;
        onlyInterfaceContract&#13;
        hasFrozenTokens(_from, _tokens)&#13;
    {&#13;
        // Make sure to deduct the tokens from both the total and frozen amounts&#13;
        holdings[_from]       -= _tokens;&#13;
        frozenHoldings[_from] -= _tokens;&#13;
        holdings[_to]         += _tokens;&#13;
&#13;
        emit Transfer(_from, _to, _tokens);&#13;
    }&#13;
&#13;
    /// @dev ERC20 transfer&#13;
    /// @param _to The address to transfer to&#13;
    /// @param _tokens The amount of tokens to transfer&#13;
    function transfer(address _to, uint _tokens)&#13;
        public&#13;
        hasAvailableTokens(msg.sender, _tokens)&#13;
        returns(bool success)&#13;
    {&#13;
        holdings[_to]        += _tokens;&#13;
        holdings[msg.sender] -= _tokens;&#13;
&#13;
        emit Transfer(msg.sender, _to, _tokens);&#13;
&#13;
        return true;&#13;
    }&#13;
&#13;
    /// @dev ERC20 approve&#13;
    /// @param _spender The address to approve&#13;
    /// @param _tokens The amount of tokens to approve&#13;
    function approve(address _spender, uint _tokens)&#13;
        public&#13;
        returns(bool success)&#13;
    {&#13;
        allowances[msg.sender][_spender] = _tokens;&#13;
&#13;
        emit Approval(msg.sender, _spender, _tokens);&#13;
&#13;
        return true;&#13;
    }&#13;
&#13;
    /// @dev ERC20 transfer from&#13;
    /// @param _from The address providing the allowance&#13;
    /// @param _to The address using the allowance&#13;
    /// @param _tokens The amount of tokens to transfer&#13;
    function transferFrom(address _from, address _to, uint _tokens)&#13;
        public&#13;
        hasAvailableTokens(_from, _tokens)&#13;
        returns(bool success)&#13;
    {&#13;
        require(allowances[_from][_to] &gt;= _tokens);&#13;
&#13;
        holdings[_to]          += _tokens;&#13;
        holdings[_from]        -= _tokens;&#13;
        allowances[_from][_to] -= _tokens;&#13;
&#13;
        emit Transfer(_from, _to, _tokens);&#13;
&#13;
        return true;&#13;
    }&#13;
}&#13;
&#13;
// File: contracts/KingOfEthResourceType.sol&#13;
&#13;
/****************************************************&#13;
 *&#13;
 * Copyright 2018 BurzNest LLC. All rights reserved.&#13;
 *&#13;
 * The contents of this file are provided for review&#13;
 * and educational purposes ONLY. You MAY NOT use,&#13;
 * copy, distribute, or modify this software without&#13;
 * explicit written permission from BurzNest LLC.&#13;
 *&#13;
 ****************************************************/&#13;
&#13;
pragma solidity ^0.4.24;&#13;
&#13;
/// @title King of Eth: Resource Type&#13;
/// @author Anthony Burzillo &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="294b5c5b53694b5c5b53474c5a5d074a4644">[email protected]</a>&gt;&#13;
/// @dev Provides enum to choose resource types&#13;
contract KingOfEthResourceType {&#13;
    /// @dev Enum describing a choice of a resource&#13;
    enum ResourceType {&#13;
          ETH&#13;
        , BRONZE&#13;
        , CORN&#13;
        , GOLD&#13;
        , OIL&#13;
        , ORE&#13;
        , STEEL&#13;
        , URANIUM&#13;
        , WOOD&#13;
    }&#13;
}&#13;
&#13;
// File: contracts/KingOfEthRoadsReferencer.sol&#13;
&#13;
/****************************************************&#13;
 *&#13;
 * Copyright 2018 BurzNest LLC. All rights reserved.&#13;
 *&#13;
 * The contents of this file are provided for review&#13;
 * and educational purposes ONLY. You MAY NOT use,&#13;
 * copy, distribute, or modify this software without&#13;
 * explicit written permission from BurzNest LLC.&#13;
 *&#13;
 ****************************************************/&#13;
&#13;
pragma solidity ^0.4.24;&#13;
&#13;
&#13;
/// @title King of Eth: Roads Referencer&#13;
/// @author Anthony Burzillo &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="3f5d4a4d457f5d4a4d45515a4c4b115c5052">[email protected]</a>&gt;&#13;
/// @dev Provides functionality to reference the roads contract&#13;
contract KingOfEthRoadsReferencer is GodMode {&#13;
    /// @dev The roads contract's address&#13;
    address public roadsContract;&#13;
&#13;
    /// @dev Only the roads contract can run this function&#13;
    modifier onlyRoadsContract()&#13;
    {&#13;
        require(roadsContract == msg.sender);&#13;
        _;&#13;
    }&#13;
&#13;
    /// @dev God can set the realty contract&#13;
    /// @param _roadsContract The new address&#13;
    function godSetRoadsContract(address _roadsContract)&#13;
        public&#13;
        onlyGod&#13;
    {&#13;
        roadsContract = _roadsContract;&#13;
    }&#13;
}&#13;
&#13;
// File: contracts/KingOfEthResourcesInterface.sol&#13;
&#13;
/****************************************************&#13;
 *&#13;
 * Copyright 2018 BurzNest LLC. All rights reserved.&#13;
 *&#13;
 * The contents of this file are provided for review&#13;
 * and educational purposes ONLY. You MAY NOT use,&#13;
 * copy, distribute, or modify this software without&#13;
 * explicit written permission from BurzNest LLC.&#13;
 *&#13;
 ****************************************************/&#13;
&#13;
pragma solidity ^0.4.24;&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
/// @title King of Eth: Resources Interface&#13;
/// @author Anthony Burzillo &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="bfddcacdc5ffddcacdc5d1dacccb91dcd0d2">[email protected]</a>&gt;&#13;
/// @dev Contract for interacting with resources&#13;
contract KingOfEthResourcesInterface is&#13;
      GodMode&#13;
    , KingOfEthExchangeReferencer&#13;
    , KingOfEthHousesReferencer&#13;
    , KingOfEthResourceType&#13;
    , KingOfEthRoadsReferencer&#13;
{&#13;
    /// @dev Amount of resources a user gets for building a house&#13;
    uint public constant resourcesPerHouse = 3;&#13;
&#13;
    /// @dev Address for the bronze contract&#13;
    address public bronzeContract;&#13;
&#13;
    /// @dev Address for the corn contract&#13;
    address public cornContract;&#13;
&#13;
    /// @dev Address for the gold contract&#13;
    address public goldContract;&#13;
&#13;
    /// @dev Address for the oil contract&#13;
    address public oilContract;&#13;
&#13;
    /// @dev Address for the ore contract&#13;
    address public oreContract;&#13;
&#13;
    /// @dev Address for the steel contract&#13;
    address public steelContract;&#13;
&#13;
    /// @dev Address for the uranium contract&#13;
    address public uraniumContract;&#13;
&#13;
    /// @dev Address for the wood contract&#13;
    address public woodContract;&#13;
&#13;
    /// @param _bronzeContract The address of the bronze contract&#13;
    /// @param _cornContract The address of the corn contract&#13;
    /// @param _goldContract The address of the gold contract&#13;
    /// @param _oilContract The address of the oil contract&#13;
    /// @param _oreContract The address of the ore contract&#13;
    /// @param _steelContract The address of the steel contract&#13;
    /// @param _uraniumContract The address of the uranium contract&#13;
    /// @param _woodContract The address of the wood contract&#13;
    constructor(&#13;
          address _bronzeContract&#13;
        , address _cornContract&#13;
        , address _goldContract&#13;
        , address _oilContract&#13;
        , address _oreContract&#13;
        , address _steelContract&#13;
        , address _uraniumContract&#13;
        , address _woodContract&#13;
    )&#13;
        public&#13;
    {&#13;
        bronzeContract  = _bronzeContract;&#13;
        cornContract    = _cornContract;&#13;
        goldContract    = _goldContract;&#13;
        oilContract     = _oilContract;&#13;
        oreContract     = _oreContract;&#13;
        steelContract   = _steelContract;&#13;
        uraniumContract = _uraniumContract;&#13;
        woodContract    = _woodContract;&#13;
    }&#13;
&#13;
    /// @dev Return the particular address for a certain resource type&#13;
    /// @param _type The resource type&#13;
    /// @return The address for that resource&#13;
    function contractFor(ResourceType _type)&#13;
        public&#13;
        view&#13;
        returns(address)&#13;
    {&#13;
        // ETH does not have a contract&#13;
        require(ResourceType.ETH != _type);&#13;
&#13;
        if(ResourceType.BRONZE == _type)&#13;
        {&#13;
            return bronzeContract;&#13;
        }&#13;
        else if(ResourceType.CORN == _type)&#13;
        {&#13;
            return cornContract;&#13;
        }&#13;
        else if(ResourceType.GOLD == _type)&#13;
        {&#13;
            return goldContract;&#13;
        }&#13;
        else if(ResourceType.OIL == _type)&#13;
        {&#13;
            return oilContract;&#13;
        }&#13;
        else if(ResourceType.ORE == _type)&#13;
        {&#13;
            return oreContract;&#13;
        }&#13;
        else if(ResourceType.STEEL == _type)&#13;
        {&#13;
            return steelContract;&#13;
        }&#13;
        else if(ResourceType.URANIUM == _type)&#13;
        {&#13;
            return uraniumContract;&#13;
        }&#13;
        else if(ResourceType.WOOD == _type)&#13;
        {&#13;
            return woodContract;&#13;
        }&#13;
    }&#13;
&#13;
    /// @dev Determine the resource type of a tile&#13;
    /// @param _x The x coordinate of the top left corner of the tile&#13;
    /// @param _y The y coordinate of the top left corner of the tile&#13;
    function resourceType(uint _x, uint _y)&#13;
        public&#13;
        pure&#13;
        returns(ResourceType resource)&#13;
    {&#13;
        uint _seed = (_x + 7777777) ^  _y;&#13;
&#13;
        if(0 == _seed % 97)&#13;
        {&#13;
          return ResourceType.URANIUM;&#13;
        }&#13;
        else if(0 == _seed % 29)&#13;
        {&#13;
          return ResourceType.OIL;&#13;
        }&#13;
        else if(0 == _seed % 23)&#13;
        {&#13;
          return ResourceType.STEEL;&#13;
        }&#13;
        else if(0 == _seed % 17)&#13;
        {&#13;
          return ResourceType.GOLD;&#13;
        }&#13;
        else if(0 == _seed % 11)&#13;
        {&#13;
          return ResourceType.BRONZE;&#13;
        }&#13;
        else if(0 == _seed % 5)&#13;
        {&#13;
          return ResourceType.WOOD;&#13;
        }&#13;
        else if(0 == _seed % 2)&#13;
        {&#13;
          return ResourceType.CORN;&#13;
        }&#13;
        else&#13;
        {&#13;
          return ResourceType.ORE;&#13;
        }&#13;
    }&#13;
&#13;
    /// @dev Lookup the number of resource points for a certain&#13;
    ///  player&#13;
    /// @param _player The player in question&#13;
    function lookupResourcePoints(address _player)&#13;
        public&#13;
        view&#13;
        returns(uint)&#13;
    {&#13;
        uint result = 0;&#13;
&#13;
        result += KingOfEthResource(bronzeContract).balanceOf(_player);&#13;
        result += KingOfEthResource(goldContract).balanceOf(_player)    * 3;&#13;
        result += KingOfEthResource(steelContract).balanceOf(_player)   * 6;&#13;
        result += KingOfEthResource(oilContract).balanceOf(_player)     * 10;&#13;
        result += KingOfEthResource(uraniumContract).balanceOf(_player) * 44;&#13;
&#13;
        return result;&#13;
    }&#13;
&#13;
    /// @dev Burn the resources necessary to build a house&#13;
    /// @param _count the number of houses being built&#13;
    /// @param _player The player who is building the house&#13;
    function burnHouseCosts(uint _count, address _player)&#13;
        public&#13;
        onlyHousesContract&#13;
    {&#13;
        // Costs 2 corn per house&#13;
        KingOfEthResource(contractFor(ResourceType.CORN)).interfaceBurnTokens(&#13;
              _player&#13;
            , 2 * _count&#13;
        );&#13;
&#13;
        // Costs 2 ore per house&#13;
        KingOfEthResource(contractFor(ResourceType.ORE)).interfaceBurnTokens(&#13;
              _player&#13;
            , 2 * _count&#13;
        );&#13;
&#13;
        // Costs 1 wood per house&#13;
        KingOfEthResource(contractFor(ResourceType.WOOD)).interfaceBurnTokens(&#13;
              _player&#13;
            , _count&#13;
        );&#13;
    }&#13;
&#13;
    /// @dev Burn the costs of upgrading a house&#13;
    /// @param _currentLevel The level of the house before the upgrade&#13;
    /// @param _player The player who is upgrading the house&#13;
    function burnUpgradeCosts(uint8 _currentLevel, address _player)&#13;
        public&#13;
        onlyHousesContract&#13;
    {&#13;
        // Do not allow upgrades after level 4&#13;
        require(5 &gt; _currentLevel);&#13;
&#13;
        // Burn the base house cost&#13;
        burnHouseCosts(1, _player);&#13;
&#13;
        if(0 == _currentLevel)&#13;
        {&#13;
            // Level 1 costs bronze&#13;
            KingOfEthResource(contractFor(ResourceType.BRONZE)).interfaceBurnTokens(&#13;
                  _player&#13;
                , 1&#13;
            );&#13;
        }&#13;
        else if(1 == _currentLevel)&#13;
        {&#13;
            // Level 2 costs gold&#13;
            KingOfEthResource(contractFor(ResourceType.GOLD)).interfaceBurnTokens(&#13;
                  _player&#13;
                , 1&#13;
            );&#13;
        }&#13;
        else if(2 == _currentLevel)&#13;
        {&#13;
            // Level 3 costs steel&#13;
            KingOfEthResource(contractFor(ResourceType.STEEL)).interfaceBurnTokens(&#13;
                  _player&#13;
                , 1&#13;
            );&#13;
        }&#13;
        else if(3 == _currentLevel)&#13;
        {&#13;
            // Level 4 costs oil&#13;
            KingOfEthResource(contractFor(ResourceType.OIL)).interfaceBurnTokens(&#13;
                  _player&#13;
                , 1&#13;
            );&#13;
        }&#13;
        else if(4 == _currentLevel)&#13;
        {&#13;
            // Level 5 costs uranium&#13;
            KingOfEthResource(contractFor(ResourceType.URANIUM)).interfaceBurnTokens(&#13;
                  _player&#13;
                , 1&#13;
            );&#13;
        }&#13;
    }&#13;
&#13;
    /// @dev Mint resources for a house and distribute all to its owner&#13;
    /// @param _owner The owner of the house&#13;
    /// @param _x The x coordinate of the house&#13;
    /// @param _y The y coordinate of the house&#13;
    /// @param _y The y coordinate of the house&#13;
    /// @param _level The new level of the house&#13;
    function distributeResources(address _owner, uint _x, uint _y, uint8 _level)&#13;
        public&#13;
        onlyHousesContract&#13;
    {&#13;
        // Calculate the count of resources for this level&#13;
        uint _count = resourcesPerHouse * uint(_level + 1);&#13;
&#13;
        // Distribute the top left resource&#13;
        KingOfEthResource(contractFor(resourceType(_x - 1, _y - 1))).interfaceMintTokens(&#13;
            _owner&#13;
          , _count&#13;
        );&#13;
&#13;
        // Distribute the top right resource&#13;
        KingOfEthResource(contractFor(resourceType(_x, _y - 1))).interfaceMintTokens(&#13;
            _owner&#13;
          , _count&#13;
        );&#13;
&#13;
        // Distribute the bottom right resource&#13;
        KingOfEthResource(contractFor(resourceType(_x, _y))).interfaceMintTokens(&#13;
            _owner&#13;
          , _count&#13;
        );&#13;
&#13;
        // Distribute the bottom left resource&#13;
        KingOfEthResource(contractFor(resourceType(_x - 1, _y))).interfaceMintTokens(&#13;
            _owner&#13;
          , _count&#13;
        );&#13;
    }&#13;
&#13;
    /// @dev Burn the costs necessary to build a road&#13;
    /// @param _length The length of the road&#13;
    /// @param _player The player who is building the house&#13;
    function burnRoadCosts(uint _length, address _player)&#13;
        public&#13;
        onlyRoadsContract&#13;
    {&#13;
        // Burn corn&#13;
        KingOfEthResource(cornContract).interfaceBurnTokens(&#13;
              _player&#13;
            , _length&#13;
        );&#13;
&#13;
        // Burn ore&#13;
        KingOfEthResource(oreContract).interfaceBurnTokens(&#13;
              _player&#13;
            , _length&#13;
        );&#13;
    }&#13;
&#13;
    /// @dev The exchange can freeze tokens&#13;
    /// @param _type The type of resource&#13;
    /// @param _owner The owner of the tokens&#13;
    /// @param _tokens The amount of tokens to freeze&#13;
    function exchangeFreezeTokens(ResourceType _type, address _owner, uint _tokens)&#13;
        public&#13;
        onlyExchangeContract&#13;
    {&#13;
        KingOfEthResource(contractFor(_type)).interfaceFreezeTokens(_owner, _tokens);&#13;
    }&#13;
&#13;
    /// @dev The exchange can thaw tokens&#13;
    /// @param _type The type of resource&#13;
    /// @param _owner The owner of the tokens&#13;
    /// @param _tokens The amount of tokens to thaw&#13;
    function exchangeThawTokens(ResourceType _type, address _owner, uint _tokens)&#13;
        public&#13;
        onlyExchangeContract&#13;
    {&#13;
        KingOfEthResource(contractFor(_type)).interfaceThawTokens(_owner, _tokens);&#13;
    }&#13;
&#13;
    /// @dev The exchange can transfer tokens&#13;
    /// @param _type The type of resource&#13;
    /// @param _from The owner of the tokens&#13;
    /// @param _to The new owner of the tokens&#13;
    /// @param _tokens The amount of tokens to transfer&#13;
    function exchangeTransfer(ResourceType _type, address _from, address _to, uint _tokens)&#13;
        public&#13;
        onlyExchangeContract&#13;
    {&#13;
        KingOfEthResource(contractFor(_type)).interfaceTransfer(_from, _to, _tokens);&#13;
    }&#13;
&#13;
    /// @dev The exchange can transfer frozend tokens&#13;
    /// @param _type The type of resource&#13;
    /// @param _from The owner of the tokens&#13;
    /// @param _to The new owner of the tokens&#13;
    /// @param _tokens The amount of frozen tokens to transfer&#13;
    function exchangeFrozenTransfer(ResourceType _type, address _from, address _to, uint _tokens)&#13;
        public&#13;
        onlyExchangeContract&#13;
    {&#13;
        KingOfEthResource(contractFor(_type)).interfaceFrozenTransfer(_from, _to, _tokens);&#13;
    }&#13;
}&#13;
&#13;
// File: contracts/KingOfEthResourceExchange.sol&#13;
&#13;
/****************************************************&#13;
 *&#13;
 * Copyright 2018 BurzNest LLC. All rights reserved.&#13;
 *&#13;
 * The contents of this file are provided for review&#13;
 * and educational purposes ONLY. You MAY NOT use,&#13;
 * copy, distribute, or modify this software without&#13;
 * explicit written permission from BurzNest LLC.&#13;
 *&#13;
 ****************************************************/&#13;
&#13;
pragma solidity ^0.4.24;&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
/// @title King of Eth: Resource-to-Resource Exchange&#13;
/// @author Anthony Burzillo &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="cfadbabdb58fadbabdb5a1aabcbbe1aca0a2">[email protected]</a>&gt;&#13;
/// @dev All the resource-to-resource exchange functionality&#13;
contract KingOfEthResourceExchange is&#13;
      GodMode&#13;
    , KingOfEthResourcesInterfaceReferencer&#13;
    , KingOfEthResourceType&#13;
{&#13;
    /// @dev Struct to hold data about a trade&#13;
    struct Trade {&#13;
        /// @dev The creator of the trade&#13;
        address creator;&#13;
&#13;
        /// @dev The resource the trade is providing&#13;
        ResourceType resource;&#13;
&#13;
        /// @dev The resource the trade is asking for&#13;
        ResourceType tradingFor;&#13;
&#13;
        /// @dev The amount of the resource that is left to trade&#13;
        uint amountRemaining;&#13;
&#13;
        /// @dev The number to multiply an amount by to get the size&#13;
        ///  for that amount&#13;
        uint numerator;&#13;
&#13;
        /// @dev The number to divide an amount by to get the size&#13;
        ///  for that amount&#13;
        uint denominator;&#13;
    }&#13;
&#13;
    /// @dev The id of the next trade created&#13;
    uint public nextTradeId;&#13;
&#13;
    /// @dev Mapping of trade ids to info about the trade&#13;
    mapping (uint =&gt; Trade) trades;&#13;
&#13;
    /// @dev Fired when a trade is created&#13;
    event ResourceTradeCreated(&#13;
          uint tradeId&#13;
        , ResourceType resource&#13;
        , ResourceType tradingFor&#13;
        , uint amountTrading&#13;
        , uint amountRequesting&#13;
        , address creator&#13;
    );&#13;
&#13;
    /// @dev Fired when a trade is (partially) filled&#13;
    event ResourceTradeFilled(&#13;
          uint tradeId&#13;
        , ResourceType resource&#13;
        , ResourceType tradingFor&#13;
        , uint amount&#13;
        , uint numerator&#13;
        , uint denominator&#13;
        , address creator&#13;
        , address filler&#13;
    );&#13;
&#13;
    /// @dev Fired when a trade is cancelled&#13;
    event ResourceTradeCancelled(&#13;
          uint tradeId&#13;
        , ResourceType resource&#13;
        , ResourceType tradingFor&#13;
        , uint amount&#13;
        , address creator&#13;
    );&#13;
&#13;
    /// @param _interfaceContract The address of the resources&#13;
    ///  interface contract&#13;
    constructor(address _interfaceContract)&#13;
        public&#13;
    {&#13;
        interfaceContract = _interfaceContract;&#13;
    }&#13;
&#13;
    /// @dev Create a trade&#13;
    /// @param _resource The resource the trade is providing&#13;
    /// @param _tradingFor The resource the trade is asking for&#13;
    /// @param _amountTrading The amount of the resource to trade&#13;
    /// @param _amountRequesting The amount of the other resource&#13;
    ///   to request&#13;
    /// @return The id of the trade&#13;
    function createTrade(&#13;
          ResourceType _resource&#13;
        , ResourceType _tradingFor&#13;
        , uint _amountTrading&#13;
        , uint _amountRequesting&#13;
    )&#13;
        public&#13;
        returns(uint)&#13;
    {&#13;
        // Don't allow ETH trades&#13;
        require(&#13;
               ResourceType.ETH != _resource&#13;
            &amp;&amp; ResourceType.ETH != _tradingFor&#13;
        );&#13;
&#13;
        // Don't allow trades for the same resource&#13;
        require(_resource != _tradingFor);&#13;
&#13;
        // Require that the amount for trade is greater than 0&#13;
        require(0 &lt; _amountTrading);&#13;
&#13;
        // Require that the amount requested is greater than 0&#13;
        require(0 &lt; _amountRequesting);&#13;
&#13;
        // Freeze the amount of tokens for that resource&#13;
        KingOfEthResourcesInterface(interfaceContract).exchangeFreezeTokens(&#13;
              _resource&#13;
            , msg.sender&#13;
            , _amountTrading&#13;
        );&#13;
&#13;
        // Set up the info about the trade&#13;
        trades[nextTradeId] = Trade(&#13;
              msg.sender&#13;
            , _resource&#13;
            , _tradingFor&#13;
            , _amountTrading // Amount remaining to trade&#13;
            , _amountRequesting&#13;
            , _amountTrading&#13;
        );&#13;
&#13;
        emit ResourceTradeCreated(&#13;
              nextTradeId&#13;
            , _resource&#13;
            , _tradingFor&#13;
            , _amountTrading&#13;
            , _amountRequesting&#13;
            , msg.sender&#13;
        );&#13;
&#13;
        // Return the trade id&#13;
        return nextTradeId++;&#13;
    }&#13;
&#13;
    /// @dev Fill an amount of some trade&#13;
    /// @param _tradeId The id of the trade&#13;
    /// @param _amount The amount of the provided resource to fill&#13;
    function fillTrade(uint _tradeId, uint _amount) public&#13;
    {&#13;
        // Require a nonzero amount to be filled&#13;
        require(0 &lt; _amount);&#13;
&#13;
        // Lookup the trade&#13;
        Trade storage _trade = trades[_tradeId];&#13;
&#13;
        // Require that at least the amount filling is available to trade&#13;
        require(_trade.amountRemaining &gt;= _amount);&#13;
&#13;
        // Start calculating the size of the resources filling with&#13;
        uint _size = _amount * _trade.numerator;&#13;
&#13;
        // Ensure that the result is reversable (there is no overflow)&#13;
        require(_amount == _size / _trade.numerator);&#13;
&#13;
        // Require that the resulting amount is a whole number&#13;
        require(0 == _size % _trade.denominator);&#13;
&#13;
        // Finish the size calculation&#13;
        _size /= _trade.denominator;&#13;
&#13;
        // Reduce the amount remaining by the amount being filled&#13;
        _trade.amountRemaining -= _amount;&#13;
&#13;
        // Send the filler the creator's frozen resources&#13;
        KingOfEthResourcesInterface(interfaceContract).exchangeFrozenTransfer(&#13;
              _trade.resource&#13;
            , _trade.creator&#13;
            , msg.sender&#13;
            , _amount&#13;
        );&#13;
&#13;
        // Send the creator the filler's resources&#13;
        KingOfEthResourcesInterface(interfaceContract).exchangeTransfer(&#13;
              _trade.tradingFor&#13;
            , msg.sender&#13;
            , _trade.creator&#13;
            , _size&#13;
        );&#13;
&#13;
        emit ResourceTradeFilled(&#13;
              _tradeId&#13;
            , _trade.resource&#13;
            , _trade.tradingFor&#13;
            , _amount&#13;
            , _trade.numerator&#13;
            , _trade.denominator&#13;
            , _trade.creator&#13;
            , msg.sender&#13;
        );&#13;
    }&#13;
&#13;
    /// @dev Cancel a trade&#13;
    /// @param _tradeId The trade's id&#13;
    function cancelTrade(uint _tradeId) public&#13;
    {&#13;
        // Lookup the trade's info&#13;
        Trade storage _trade = trades[_tradeId];&#13;
&#13;
        // Require that the creator is cancelling the trade&#13;
        require(_trade.creator == msg.sender);&#13;
&#13;
        // Save the amount remaining&#13;
        uint _amountRemaining = _trade.amountRemaining;&#13;
&#13;
        // Set the amount remaining to trade to 0.&#13;
        // Note that this effectively cancels the trade&#13;
        _trade.amountRemaining = 0;&#13;
&#13;
        // Thaw the creator's resource&#13;
        KingOfEthResourcesInterface(interfaceContract).exchangeThawTokens(&#13;
              _trade.resource&#13;
            , msg.sender&#13;
            , _amountRemaining&#13;
        );&#13;
&#13;
        emit ResourceTradeCancelled(&#13;
              _tradeId&#13;
            , _trade.resource&#13;
            , _trade.tradingFor&#13;
            , _amountRemaining&#13;
            , msg.sender&#13;
        );&#13;
    }&#13;
}