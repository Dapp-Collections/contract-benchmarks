/*
 * Safe Math Smart Contract.  Copyright © 2016–2017 by ABDK Consulting.
 * Author: Mikhail Vladimirov <<span class="__cf_email__" data-cfemail="15787c7e7d747c793b637974717c787c677a63557278747c793b767a78">[email protected]</span>&gt;&#13;
 */&#13;
pragma solidity ^0.4.20;&#13;
&#13;
/**&#13;
 * Provides methods to safely add, subtract and multiply uint256 numbers.&#13;
 */&#13;
contract SafeMath {&#13;
  uint256 constant private MAX_UINT256 =&#13;
    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;&#13;
&#13;
  /**&#13;
   * Add two uint256 values, throw in case of overflow.&#13;
   *&#13;
   * @param x first value to add&#13;
   * @param y second value to add&#13;
   * @return x + y&#13;
   */&#13;
  function safeAdd (uint256 x, uint256 y)&#13;
  pure internal&#13;
  returns (uint256 z) {&#13;
    assert (x &lt;= MAX_UINT256 - y);&#13;
    return x + y;&#13;
  }&#13;
&#13;
  /**&#13;
   * Subtract one uint256 value from another, throw in case of underflow.&#13;
   *&#13;
   * @param x value to subtract from&#13;
   * @param y value to subtract&#13;
   * @return x - y&#13;
   */&#13;
  function safeSub (uint256 x, uint256 y)&#13;
  pure internal&#13;
  returns (uint256 z) {&#13;
    assert (x &gt;= y);&#13;
    return x - y;&#13;
  }&#13;
&#13;
  /**&#13;
   * Multiply two uint256 values, throw in case of overflow.&#13;
   *&#13;
   * @param x first value to multiply&#13;
   * @param y second value to multiply&#13;
   * @return x * y&#13;
   */&#13;
  function safeMul (uint256 x, uint256 y)&#13;
  pure internal&#13;
  returns (uint256 z) {&#13;
    if (y == 0) return 0; // Prevent division by zero at the next line&#13;
    assert (x &lt;= MAX_UINT256 / y);&#13;
    return x * y;&#13;
  }&#13;
}&#13;
/*&#13;
 * EIP-20 Standard Token Smart Contract Interface.&#13;
 * Copyright © 2016–2018 by ABDK Consulting.&#13;
 * Author: Mikhail Vladimirov &lt;<span class="__cf_email__" data-cfemail="a5c8cccecdc4ccc98bd3c9c4c1ccc8ccd7cad3e5c2c8c4ccc98bc6cac8">[email protected]</span>&gt;&#13;
 */&#13;
&#13;
/**&#13;
 * ERC-20 standard token interface, as defined&#13;
 * &lt;a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md"&gt;here&lt;/a&gt;.&#13;
 */&#13;
contract Token {&#13;
  /**&#13;
   * Get total number of tokens in circulation.&#13;
   *&#13;
   * @return total number of tokens in circulation&#13;
   */&#13;
  function totalSupply () public view returns (uint256 supply);&#13;
&#13;
  /**&#13;
   * Get number of tokens currently belonging to given owner.&#13;
   *&#13;
   * @param _owner address to get number of tokens currently belonging to the&#13;
   *        owner of&#13;
   * @return number of tokens currently belonging to the owner of given address&#13;
   */&#13;
  function balanceOf (address _owner) public view returns (uint256 balance);&#13;
&#13;
  /**&#13;
   * Transfer given number of tokens from message sender to given recipient.&#13;
   *&#13;
   * @param _to address to transfer tokens to the owner of&#13;
   * @param _value number of tokens to transfer to the owner of given address&#13;
   * @return true if tokens were transferred successfully, false otherwise&#13;
   */&#13;
  function transfer (address _to, uint256 _value)&#13;
  public returns (bool success);&#13;
&#13;
  /**&#13;
   * Transfer given number of tokens from given owner to given recipient.&#13;
   *&#13;
   * @param _from address to transfer tokens from the owner of&#13;
   * @param _to address to transfer tokens to the owner of&#13;
   * @param _value number of tokens to transfer from given owner to given&#13;
   *        recipient&#13;
   * @return true if tokens were transferred successfully, false otherwise&#13;
   */&#13;
  function transferFrom (address _from, address _to, uint256 _value)&#13;
  public returns (bool success);&#13;
&#13;
  /**&#13;
   * Allow given spender to transfer given number of tokens from message sender.&#13;
   *&#13;
   * @param _spender address to allow the owner of to transfer tokens from&#13;
   *        message sender&#13;
   * @param _value number of tokens to allow to transfer&#13;
   * @return true if token transfer was successfully approved, false otherwise&#13;
   */&#13;
  function approve (address _spender, uint256 _value)&#13;
  public returns (bool success);&#13;
&#13;
  /**&#13;
   * Tell how many tokens given spender is currently allowed to transfer from&#13;
   * given owner.&#13;
   *&#13;
   * @param _owner address to get number of tokens allowed to be transferred&#13;
   *        from the owner of&#13;
   * @param _spender address to get number of tokens allowed to be transferred&#13;
   *        by the owner of&#13;
   * @return number of tokens given spender is currently allowed to transfer&#13;
   *         from given owner&#13;
   */&#13;
  function allowance (address _owner, address _spender)&#13;
  public view returns (uint256 remaining);&#13;
&#13;
  /**&#13;
   * Logged when tokens were transferred from one owner to another.&#13;
   *&#13;
   * @param _from address of the owner, tokens were transferred from&#13;
   * @param _to address of the owner, tokens were transferred to&#13;
   * @param _value number of tokens transferred&#13;
   */&#13;
  event Transfer (address indexed _from, address indexed _to, uint256 _value);&#13;
&#13;
  /**&#13;
   * Logged when owner approved his tokens to be transferred by some spender.&#13;
   *&#13;
   * @param _owner owner who approved his tokens to be transferred&#13;
   * @param _spender spender who were allowed to transfer the tokens belonging&#13;
   *        to the owner&#13;
   * @param _value number of tokens belonging to the owner, approved to be&#13;
   *        transferred by the spender&#13;
   */&#13;
  event Approval (&#13;
    address indexed _owner, address indexed _spender, uint256 _value);&#13;
}/*&#13;
 * Address Set Smart Contract Interface.&#13;
 * Copyright © 2017–2018 by ABDK Consulting.&#13;
 * Author: Mikhail Vladimirov &lt;<span class="__cf_email__" data-cfemail="5b363230333a3237752d373a3f32363229342d1b3c363a323775383436">[email protected]</span>&gt;&#13;
 */&#13;
&#13;
/**&#13;
 * Address Set smart contract interface.&#13;
 */&#13;
contract AddressSet {&#13;
  /**&#13;
   * Check whether address set contains given address.&#13;
   *&#13;
   * @param _address address to check&#13;
   * @return true if address set contains given address, false otherwise&#13;
   */&#13;
  function contains (address _address) public view returns (bool);&#13;
}&#13;
/*&#13;
 * Abstract Token Smart Contract.  Copyright © 2017 by ABDK Consulting.&#13;
 * Author: Mikhail Vladimirov &lt;<span class="__cf_email__" data-cfemail="264b4f4d4e474f4a08504a47424f4b4f54495066414b474f4a0845494b">[email protected]</span>&gt;&#13;
 */&#13;
&#13;
/**&#13;
 * Abstract Token Smart Contract that could be used as a base contract for&#13;
 * ERC-20 token contracts.&#13;
 */&#13;
contract AbstractToken is Token, SafeMath {&#13;
  /**&#13;
   * Create new Abstract Token contract.&#13;
   */&#13;
  function AbstractToken () public {&#13;
    // Do nothing&#13;
  }&#13;
&#13;
  /**&#13;
   * Get number of tokens currently belonging to given owner.&#13;
   *&#13;
   * @param _owner address to get number of tokens currently belonging to the&#13;
   *        owner of&#13;
   * @return number of tokens currently belonging to the owner of given address&#13;
   */&#13;
  function balanceOf (address _owner) public view returns (uint256 balance) {&#13;
    return accounts [_owner];&#13;
  }&#13;
&#13;
  /**&#13;
   * Transfer given number of tokens from message sender to given recipient.&#13;
   *&#13;
   * @param _to address to transfer tokens to the owner of&#13;
   * @param _value number of tokens to transfer to the owner of given address&#13;
   * @return true if tokens were transferred successfully, false otherwise&#13;
   */&#13;
  function transfer (address _to, uint256 _value)&#13;
  public returns (bool success) {&#13;
    uint256 fromBalance = accounts [msg.sender];&#13;
    if (fromBalance &lt; _value) return false;&#13;
    if (_value &gt; 0 &amp;&amp; msg.sender != _to) {&#13;
      accounts [msg.sender] = safeSub (fromBalance, _value);&#13;
      accounts [_to] = safeAdd (accounts [_to], _value);&#13;
    }&#13;
    Transfer (msg.sender, _to, _value);&#13;
    return true;&#13;
  }&#13;
&#13;
  /**&#13;
   * Transfer given number of tokens from given owner to given recipient.&#13;
   *&#13;
   * @param _from address to transfer tokens from the owner of&#13;
   * @param _to address to transfer tokens to the owner of&#13;
   * @param _value number of tokens to transfer from given owner to given&#13;
   *        recipient&#13;
   * @return true if tokens were transferred successfully, false otherwise&#13;
   */&#13;
  function transferFrom (address _from, address _to, uint256 _value)&#13;
  public returns (bool success) {&#13;
    uint256 spenderAllowance = allowances [_from][msg.sender];&#13;
    if (spenderAllowance &lt; _value) return false;&#13;
    uint256 fromBalance = accounts [_from];&#13;
    if (fromBalance &lt; _value) return false;&#13;
&#13;
    allowances [_from][msg.sender] =&#13;
      safeSub (spenderAllowance, _value);&#13;
&#13;
    if (_value &gt; 0 &amp;&amp; _from != _to) {&#13;
      accounts [_from] = safeSub (fromBalance, _value);&#13;
      accounts [_to] = safeAdd (accounts [_to], _value);&#13;
    }&#13;
    Transfer (_from, _to, _value);&#13;
    return true;&#13;
  }&#13;
&#13;
  /**&#13;
   * Allow given spender to transfer given number of tokens from message sender.&#13;
   *&#13;
   * @param _spender address to allow the owner of to transfer tokens from&#13;
   *        message sender&#13;
   * @param _value number of tokens to allow to transfer&#13;
   * @return true if token transfer was successfully approved, false otherwise&#13;
   */&#13;
  function approve (address _spender, uint256 _value)&#13;
  public returns (bool success) {&#13;
    allowances [msg.sender][_spender] = _value;&#13;
    Approval (msg.sender, _spender, _value);&#13;
&#13;
    return true;&#13;
  }&#13;
&#13;
  /**&#13;
   * Tell how many tokens given spender is currently allowed to transfer from&#13;
   * given owner.&#13;
   *&#13;
   * @param _owner address to get number of tokens allowed to be transferred&#13;
   *        from the owner of&#13;
   * @param _spender address to get number of tokens allowed to be transferred&#13;
   *        by the owner of&#13;
   * @return number of tokens given spender is currently allowed to transfer&#13;
   *         from given owner&#13;
   */&#13;
  function allowance (address _owner, address _spender)&#13;
  public view returns (uint256 remaining) {&#13;
    return allowances [_owner][_spender];&#13;
  }&#13;
&#13;
  /**&#13;
   * Mapping from addresses of token holders to the numbers of tokens belonging&#13;
   * to these token holders.&#13;
   */&#13;
  mapping (address =&gt; uint256) internal accounts;&#13;
&#13;
  /**&#13;
   * Mapping from addresses of token holders to the mapping of addresses of&#13;
   * spenders to the allowances set by these token holders to these spenders.&#13;
   */&#13;
  mapping (address =&gt; mapping (address =&gt; uint256)) internal allowances;&#13;
}&#13;
/*&#13;
 * Abstract Virtual Token Smart Contract.&#13;
 * Copyright © 2017–2018 by ABDK Consulting.&#13;
 * Author: Mikhail Vladimirov &lt;<span class="__cf_email__" data-cfemail="1c717577747d7570326a707d787571756e736a5c7b717d7570327f7371">[email protected]</span>&gt;&#13;
 */&#13;
&#13;
&#13;
/**&#13;
 * Abstract Token Smart Contract that could be used as a base contract for&#13;
 * ERC-20 token contracts supporting virtual balance.&#13;
 */&#13;
contract AbstractVirtualToken is AbstractToken {&#13;
  /**&#13;
   * Maximum number of real (i.e. non-virtual) tokens in circulation (2^255-1).&#13;
   */&#13;
  uint256 constant MAXIMUM_TOKENS_COUNT =&#13;
    0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;&#13;
&#13;
  /**&#13;
   * Mask used to extract real balance of an account (2^255-1).&#13;
   */&#13;
  uint256 constant BALANCE_MASK =&#13;
    0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;&#13;
&#13;
  /**&#13;
   * Mask used to extract "materialized" flag of an account (2^255).&#13;
   */&#13;
  uint256 constant MATERIALIZED_FLAG_MASK =&#13;
    0x8000000000000000000000000000000000000000000000000000000000000000;&#13;
&#13;
  /**&#13;
   * Create new Abstract Virtual Token contract.&#13;
   */&#13;
  function AbstractVirtualToken () public AbstractToken () {&#13;
    // Do nothing&#13;
  }&#13;
&#13;
  /**&#13;
   * Get total number of tokens in circulation.&#13;
   *&#13;
   * @return total number of tokens in circulation&#13;
   */&#13;
  function totalSupply () public view returns (uint256 supply) {&#13;
    return tokensCount;&#13;
  }&#13;
&#13;
  /**&#13;
   * Get number of tokens currently belonging to given owner.&#13;
   *&#13;
   * @param _owner address to get number of tokens currently belonging to the&#13;
   *        owner of&#13;
   * @return number of tokens currently belonging to the owner of given address&#13;
   */&#13;
  function balanceOf (address _owner) public view returns (uint256 balance) {&#13;
    return safeAdd (&#13;
      accounts [_owner] &amp; BALANCE_MASK, getVirtualBalance (_owner));&#13;
  }&#13;
&#13;
  /**&#13;
   * Transfer given number of tokens from message sender to given recipient.&#13;
   *&#13;
   * @param _to address to transfer tokens to the owner of&#13;
   * @param _value number of tokens to transfer to the owner of given address&#13;
   * @return true if tokens were transferred successfully, false otherwise&#13;
   */&#13;
  function transfer (address _to, uint256 _value)&#13;
  public returns (bool success) {&#13;
    if (_value &gt; balanceOf (msg.sender)) return false;&#13;
    else {&#13;
      materializeBalanceIfNeeded (msg.sender, _value);&#13;
      return AbstractToken.transfer (_to, _value);&#13;
    }&#13;
  }&#13;
&#13;
  /**&#13;
   * Transfer given number of tokens from given owner to given recipient.&#13;
   *&#13;
   * @param _from address to transfer tokens from the owner of&#13;
   * @param _to address to transfer tokens to the owner of&#13;
   * @param _value number of tokens to transfer from given owner to given&#13;
   *        recipient&#13;
   * @return true if tokens were transferred successfully, false otherwise&#13;
   */&#13;
  function transferFrom (address _from, address _to, uint256 _value)&#13;
  public returns (bool success) {&#13;
    if (_value &gt; allowance (_from, msg.sender)) return false;&#13;
    if (_value &gt; balanceOf (_from)) return false;&#13;
    else {&#13;
      materializeBalanceIfNeeded (_from, _value);&#13;
      return AbstractToken.transferFrom (_from, _to, _value);&#13;
    }&#13;
  }&#13;
&#13;
  /**&#13;
   * Get virtual balance of the owner of given address.&#13;
   *&#13;
   * @param _owner address to get virtual balance for the owner of&#13;
   * @return virtual balance of the owner of given address&#13;
   */&#13;
  function virtualBalanceOf (address _owner)&#13;
  internal view returns (uint256 _virtualBalance);&#13;
&#13;
  /**&#13;
   * Calculate virtual balance of the owner of given address taking into account&#13;
   * materialized flag and total number of real tokens already in circulation.&#13;
   */&#13;
  function getVirtualBalance (address _owner)&#13;
  private view returns (uint256 _virtualBalance) {&#13;
    if (accounts [_owner] &amp; MATERIALIZED_FLAG_MASK != 0) return 0;&#13;
    else {&#13;
      _virtualBalance = virtualBalanceOf (_owner);&#13;
      uint256 maxVirtualBalance = safeSub (MAXIMUM_TOKENS_COUNT, tokensCount);&#13;
      if (_virtualBalance &gt; maxVirtualBalance)&#13;
        _virtualBalance = maxVirtualBalance;&#13;
    }&#13;
  }&#13;
&#13;
  /**&#13;
   * Materialize virtual balance of the owner of given address if this will help&#13;
   * to transfer given number of tokens from it.&#13;
   *&#13;
   * @param _owner address to materialize virtual balance of&#13;
   * @param _value number of tokens to be transferred&#13;
   */&#13;
  function materializeBalanceIfNeeded (address _owner, uint256 _value) private {&#13;
    uint256 storedBalance = accounts [_owner];&#13;
    if (storedBalance &amp; MATERIALIZED_FLAG_MASK == 0) {&#13;
      // Virtual balance is not materialized yet&#13;
      if (_value &gt; storedBalance) {&#13;
        // Real balance is not enough&#13;
        uint256 virtualBalance = getVirtualBalance (_owner);&#13;
        require (safeSub (_value, storedBalance) &lt;= virtualBalance);&#13;
        accounts [_owner] = MATERIALIZED_FLAG_MASK |&#13;
          safeAdd (storedBalance, virtualBalance);&#13;
        tokensCount = safeAdd (tokensCount, virtualBalance);&#13;
      }&#13;
    }&#13;
  }&#13;
&#13;
  /**&#13;
   * Number of real (i.e. non-virtual) tokens in circulation.&#13;
   */&#13;
  uint256 internal tokensCount;&#13;
}&#13;
/*&#13;
 * MediChain Promo Token Smart Contract.  Copyright © 2018 by ABDK Consulting.&#13;
 * Author: Mikhail Vladimirov &lt;<span class="__cf_email__" data-cfemail="88e5e1e3e0e9e1e4a6fee4e9ece1e5e1fae7fec8efe5e9e1e4a6ebe7e5">[email protected]</span>&gt;&#13;
 */&#13;
&#13;
/**&#13;
 * MediChain Promo Tokem Smart Contract.&#13;
 */&#13;
contract MCUXPromoToken is AbstractVirtualToken {&#13;
  /**&#13;
   * Number of virtual tokens to assign to the owners of addresses from given&#13;
   * address set.&#13;
   */&#13;
  uint256 private constant VIRTUAL_COUNT = 10e8;&#13;
&#13;
  /**&#13;
   * Create MediChainPromoToken smart contract with given address set.&#13;
   *&#13;
   * @param _addressSet address set to use&#13;
   */&#13;
  function MCUXPromoToken (AddressSet _addressSet)&#13;
  public AbstractVirtualToken () {&#13;
    owner = msg.sender;&#13;
    addressSet = _addressSet;&#13;
  }&#13;
&#13;
  /**&#13;
   * Get name of this token.&#13;
   *&#13;
   * @return name of this token&#13;
   */&#13;
  function name () public pure returns (string) {&#13;
    return "MediChain Promo Token ";&#13;
  }&#13;
&#13;
  /**&#13;
   * Get symbol of this token.&#13;
   *&#13;
   * @return symbol of this token&#13;
   */&#13;
  function symbol () public pure returns (string) {&#13;
    return "MCUX";&#13;
  }&#13;
&#13;
  /**&#13;
   * Get number of decimals for this token.&#13;
   *&#13;
   * @return number of decimals for this token&#13;
   */&#13;
  function decimals () public pure returns (uint8) {&#13;
    return 8;&#13;
  }&#13;
&#13;
  /**&#13;
   * Notify owners about their virtual balances.&#13;
   *&#13;
   * @param _owners addresses of the owners to be notified&#13;
   */&#13;
  function massNotify (address [] _owners) public {&#13;
    require (msg.sender == owner);&#13;
    uint256 count = _owners.length;&#13;
    for (uint256 i = 0; i &lt; count; i++)&#13;
      Transfer (address (0), _owners [i], VIRTUAL_COUNT);&#13;
  }&#13;
&#13;
  /**&#13;
   * Kill this smart contract.&#13;
   */&#13;
  function kill () public {&#13;
    require (msg.sender == owner);&#13;
    selfdestruct (owner);&#13;
  }&#13;
&#13;
  /**&#13;
   * Change owner of the smart contract.&#13;
   *&#13;
   * @param _owner address of a new owner of the smart contract&#13;
   */&#13;
  function changeOwner (address _owner) public {&#13;
    require (msg.sender == owner);&#13;
&#13;
    owner = _owner;&#13;
  }&#13;
&#13;
  /**&#13;
   * Get virtual balance of the owner of given address.&#13;
   *&#13;
   * @param _owner address to get virtual balance for the owner of&#13;
   * @return virtual balance of the owner of given address&#13;
   */&#13;
  function virtualBalanceOf (address _owner)&#13;
  internal view returns (uint256 _virtualBalance) {&#13;
    return addressSet.contains (_owner) ? VIRTUAL_COUNT : 0;&#13;
  }&#13;
&#13;
  /**&#13;
   * Address of the owner of this smart contract.&#13;
   */&#13;
  address internal owner;&#13;
&#13;
  /**&#13;
   * Address set of addresses that are eligible for initial balance.&#13;
   */&#13;
  AddressSet internal addressSet;&#13;
}