pragma solidity 0.4.24;
pragma experimental "v0.5.0";
/******************************************************************************\
* Author: Nick Mudge, <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="6806010b03280507030d061b460107">[emailÂ protected]</a>&#13;
*&#13;
* Mokens&#13;
* Copyright (c) 2018&#13;
*&#13;
* This delegate contract contains functions related to eras and starting new&#13;
* eras.&#13;
/******************************************************************************/&#13;
///////////////////////////////////////////////////////////////////////////////////&#13;
//Storage contracts&#13;
////////////&#13;
//Some delegate contracts are listed with storage contracts they inherit.&#13;
///////////////////////////////////////////////////////////////////////////////////&#13;
&#13;
///////////////////////////////////////////////////////////////////////////////////&#13;
//Mokens&#13;
///////////////////////////////////////////////////////////////////////////////////&#13;
contract Storage0 {&#13;
    // funcId =&gt; delegate contract&#13;
    mapping(bytes4 =&gt; address) internal delegates;&#13;
}&#13;
///////////////////////////////////////////////////////////////////////////////////&#13;
//MokenUpdates&#13;
//MokenOwner&#13;
//QueryMokenDelegates&#13;
///////////////////////////////////////////////////////////////////////////////////&#13;
contract Storage1 is Storage0 {&#13;
    address internal contractOwner;&#13;
    string[] internal functionSignatures;&#13;
    // signature =&gt; index+1&#13;
    mapping(string =&gt; uint256) internal functionSignatureToIndex;&#13;
}&#13;
///////////////////////////////////////////////////////////////////////////////////&#13;
//MokensSupportsInterfaces&#13;
///////////////////////////////////////////////////////////////////////////////////&#13;
contract Storage2 is Storage1 {&#13;
    mapping(bytes4 =&gt; bool) internal supportedInterfaces;&#13;
}&#13;
///////////////////////////////////////////////////////////////////////////////////&#13;
//MokenRootOwnerOf&#13;
//MokenERC721Metadata&#13;
///////////////////////////////////////////////////////////////////////////////////&#13;
contract Storage3 is Storage2 {&#13;
    struct Moken {&#13;
        string name;&#13;
        uint256 data;&#13;
        uint256 parentTokenId;&#13;
    }&#13;
    //tokenId =&gt; moken&#13;
    mapping(uint256 =&gt; Moken) internal mokens;&#13;
    uint256 internal mokensLength;&#13;
    // child address =&gt; child tokenId =&gt; tokenId+1&#13;
    mapping(address =&gt; mapping(uint256 =&gt; uint256)) internal childTokenOwner;&#13;
}&#13;
///////////////////////////////////////////////////////////////////////////////////&#13;
//MokenERC721Enumerable&#13;
//MokenLinkHash&#13;
///////////////////////////////////////////////////////////////////////////////////&#13;
contract Storage4 is Storage3 {&#13;
    // root token owner address =&gt; (tokenId =&gt; approved address)&#13;
    mapping(address =&gt; mapping(uint256 =&gt; address)) internal rootOwnerAndTokenIdToApprovedAddress;&#13;
    // token owner =&gt; (operator address =&gt; bool)&#13;
    mapping(address =&gt; mapping(address =&gt; bool)) internal tokenOwnerToOperators;&#13;
    // Mapping from owner to list of owned token IDs&#13;
    mapping(address =&gt; uint32[]) internal ownedTokens;&#13;
}&#13;
///////////////////////////////////////////////////////////////////////////////////&#13;
//MokenERC998ERC721TopDown&#13;
//MokenERC998ERC721TopDownBatch&#13;
//MokenERC721&#13;
//MokenERC721Batch&#13;
///////////////////////////////////////////////////////////////////////////////////&#13;
contract Storage5 is Storage4 {&#13;
    // tokenId =&gt; (child address =&gt; array of child tokens)&#13;
    mapping(uint256 =&gt; mapping(address =&gt; uint256[])) internal childTokens;&#13;
    // tokenId =&gt; (child address =&gt; (child token =&gt; child index)&#13;
    mapping(uint256 =&gt; mapping(address =&gt; mapping(uint256 =&gt; uint256))) internal childTokenIndex;&#13;
    // tokenId =&gt; (child address =&gt; contract index)&#13;
    mapping(uint256 =&gt; mapping(address =&gt; uint256)) internal childContractIndex;&#13;
    // tokenId =&gt; child contract&#13;
    mapping(uint256 =&gt; address[]) internal childContracts;&#13;
}&#13;
///////////////////////////////////////////////////////////////////////////////////&#13;
//MokenERC998ERC20TopDown&#13;
//MokenStateChange&#13;
///////////////////////////////////////////////////////////////////////////////////&#13;
contract Storage6 is Storage5 {&#13;
    // tokenId =&gt; token contract&#13;
    mapping(uint256 =&gt; address[]) internal erc20Contracts;&#13;
    // tokenId =&gt; (token contract =&gt; token contract index)&#13;
    mapping(uint256 =&gt; mapping(address =&gt; uint256)) erc20ContractIndex;&#13;
    // tokenId =&gt; (token contract =&gt; balance)&#13;
    mapping(uint256 =&gt; mapping(address =&gt; uint256)) internal erc20Balances;&#13;
}&#13;
///////////////////////////////////////////////////////////////////////////////////&#13;
//MokenERC998ERC721BottomUp&#13;
//MokenERC998ERC721BottomUpBatch&#13;
///////////////////////////////////////////////////////////////////////////////////&#13;
contract Storage7 is Storage6 {&#13;
    // parent address =&gt; (parent tokenId =&gt; array of child tokenIds)&#13;
    mapping(address =&gt; mapping(uint256 =&gt; uint32[])) internal parentToChildTokenIds;&#13;
    // tokenId =&gt; position in childTokens array&#13;
    mapping(uint256 =&gt; uint256) internal tokenIdToChildTokenIdsIndex;&#13;
}&#13;
///////////////////////////////////////////////////////////////////////////////////&#13;
//MokenMinting&#13;
//MokenEras&#13;
//QueryMokenData&#13;
///////////////////////////////////////////////////////////////////////////////////&#13;
contract Storage8 is Storage7 {&#13;
    // index =&gt; era&#13;
    mapping(uint256 =&gt; bytes32) internal eras;&#13;
    uint256 internal eraLength;&#13;
    // era =&gt; index+1&#13;
    mapping(bytes32 =&gt; uint256) internal eraIndex;&#13;
    uint256 internal mintPriceOffset; // = 0 szabo;&#13;
    uint256 internal mintStepPrice; // = 500 szabo;&#13;
    uint256 internal mintPriceBuffer; // = 5000 szabo;&#13;
    address[] internal mintContracts;&#13;
    mapping(address =&gt; uint256) internal mintContractIndex;&#13;
    //moken name =&gt; tokenId+1&#13;
    mapping(string =&gt; uint256) internal tokenByName_;&#13;
}&#13;
contract MokenEras is Storage8 {&#13;
&#13;
    event NewEra(&#13;
        uint256 index,&#13;
        bytes32 name,&#13;
        uint256 startTokenId&#13;
    );&#13;
&#13;
    event MintPriceChange(&#13;
        uint256 mintPrice&#13;
    );&#13;
&#13;
    event MintPriceConfigurationChange(&#13;
        uint256 mintPrice,&#13;
        uint256 mintStepPrice,&#13;
        uint256 mintPriceOffset,&#13;
        uint256 mintPriceBuffer&#13;
    );&#13;
&#13;
    function startNextEra_(bytes32 _eraName) internal returns (uint256 index, uint256 startTokenId) {&#13;
        require(_eraName != 0, "eraName is empty string.");&#13;
        require(eraIndex[_eraName] == 0, "Era name already exists.");&#13;
        startTokenId = mokensLength;&#13;
        index = eraLength++;&#13;
        eras[index] = _eraName;&#13;
        eraIndex[_eraName] = index + 1;&#13;
        emit NewEra(index, _eraName, startTokenId);&#13;
        return (index, startTokenId);&#13;
    }&#13;
&#13;
    // It is predicted that often a new era comes with a mint price change&#13;
    function startNextEra(bytes32 _eraName, uint256 _mintStepPrice, uint256 _mintPriceOffset, uint256 _mintPriceBuffer) external&#13;
    returns (uint256 index, uint256 startTokenId, uint256 mintPrice) {&#13;
        require(msg.sender == contractOwner, "Must own Mokens contract.");&#13;
        require(_mintStepPrice &lt; 10000 ether, "mintStepPrice must be less than 10,000 ether.");&#13;
        mintStepPrice = _mintStepPrice;&#13;
        mintPriceOffset = _mintPriceOffset;&#13;
        mintPriceBuffer = _mintPriceBuffer;&#13;
        uint256 totalStepPrice = mokensLength * _mintStepPrice;&#13;
        require(totalStepPrice &gt;= _mintPriceOffset, "(mokensLength * mintStepPrice) must be greater than or equal to mintPriceOffset.");&#13;
        mintPrice = totalStepPrice - _mintPriceOffset;&#13;
        emit MintPriceConfigurationChange(mintPrice, _mintStepPrice, _mintPriceOffset, _mintPriceBuffer);&#13;
        emit MintPriceChange(mintPrice);&#13;
        (index, startTokenId) = startNextEra_(_eraName);&#13;
        return (index, startTokenId, mintPrice);&#13;
    }&#13;
&#13;
    function startNextEra(bytes32 _eraName) external returns (uint256 index, uint256 startTokenId) {&#13;
        require(msg.sender == contractOwner, "Must own Mokens contract.");&#13;
        return startNextEra_(_eraName);&#13;
    }&#13;
&#13;
    function eraByIndex(uint256 _index) external view returns (bytes32 era) {&#13;
        require(_index &lt; eraLength, "No era at this index.");&#13;
        return eras[_index];&#13;
    }&#13;
&#13;
&#13;
    function eraByName(bytes32 _eraName) external view returns (uint256 indexOfEra) {&#13;
        uint256 index = eraIndex[_eraName];&#13;
        require(index != 0, "No era exists with this name.");&#13;
        return index - 1;&#13;
    }&#13;
&#13;
    function currentEra() external view returns (bytes32 era) {&#13;
        return eras[eraLength - 1];&#13;
    }&#13;
&#13;
    function currentEraIndex() external view returns (uint256 indexOfEra) {&#13;
        return eraLength - 1;&#13;
    }&#13;
&#13;
    function eraExists(bytes32 _eraName) external view returns (bool) {&#13;
        return eraIndex[_eraName] != 0;&#13;
    }&#13;
&#13;
    function totalEras() external view returns (uint256 totalEras_) {&#13;
        return eraLength;&#13;
    }&#13;
}