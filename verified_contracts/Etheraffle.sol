pragma solidity^0.4.15;
/*
 * @title String & slice utility library for Solidity contracts.
 * @author Nick Johnson <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="7f1e0d1e1c1711161b3f11100b1b100b51111a0b">[emailÂ protected]</a>&gt;&#13;
 *&#13;
 * @dev Functionality in this library is largely implemented using an&#13;
 *      abstraction called a 'slice'. A slice represents a part of a string -&#13;
 *      anything from the entire string to a single character, or even no&#13;
 *      characters at all (a 0-length slice). Since a slice only has to specify&#13;
 *      an offset and a length, copying and manipulating slices is a lot less&#13;
 *      expensive than copying and manipulating the strings they reference.&#13;
 *&#13;
 *      To further reduce gas costs, most functions on slice that need to return&#13;
 *      a slice modify the original one instead of allocating a new one; for&#13;
 *      instance, `s.split(".")` will return the text up to the first '.',&#13;
 *      modifying s to only contain the remainder of the string after the '.'.&#13;
 *      In situations where you do not want to modify the original slice, you&#13;
 *      can make a copy first with `.copy()`, for example:&#13;
 *      `s.copy().split(".")`. Try and avoid using this idiom in loops; since&#13;
 *      Solidity has no memory management, it will result in allocating many&#13;
 *      short-lived slices that are later discarded.&#13;
 *&#13;
 *      Functions that return two slices come in two versions: a non-allocating&#13;
 *      version that takes the second slice as an argument, modifying it in&#13;
 *      place, and an allocating version that allocates and returns the second&#13;
 *      slice; see `nextRune` for example.&#13;
 *&#13;
 *      Functions that have to copy string data will return strings rather than&#13;
 *      slices; these can be cast back to slices for further processing if&#13;
 *      required.&#13;
 *&#13;
 *      For convenience, some functions are provided with non-modifying&#13;
 *      variants that create a new slice and return both; for instance,&#13;
 *      `s.splitNew('.')` leaves s unmodified, and returns two values&#13;
 *      corresponding to the left and right parts of the string.&#13;
 */&#13;
 &#13;
//pragma solidity ^0.4.14;&#13;
&#13;
library strings {&#13;
    struct slice {&#13;
        uint _len;&#13;
        uint _ptr;&#13;
    }&#13;
&#13;
    function memcpy(uint dest, uint src, uint len) private {&#13;
        // Copy word-length chunks while possible&#13;
        for(; len &gt;= 32; len -= 32) {&#13;
            assembly {&#13;
                mstore(dest, mload(src))&#13;
            }&#13;
            dest += 32;&#13;
            src += 32;&#13;
        }&#13;
&#13;
        // Copy remaining bytes&#13;
        uint mask = 256 ** (32 - len) - 1;&#13;
        assembly {&#13;
            let srcpart := and(mload(src), not(mask))&#13;
            let destpart := and(mload(dest), mask)&#13;
            mstore(dest, or(destpart, srcpart))&#13;
        }&#13;
    }&#13;
&#13;
    /*&#13;
     * @dev Returns a slice containing the entire string.&#13;
     * @param self The string to make a slice from.&#13;
     * @return A newly allocated slice containing the entire string.&#13;
     */&#13;
    function toSlice(string self) internal returns (slice) {&#13;
        uint ptr;&#13;
        assembly {&#13;
            ptr := add(self, 0x20)&#13;
        }&#13;
        return slice(bytes(self).length, ptr);&#13;
    }&#13;
&#13;
    /*&#13;
     * @dev Returns the length of a null-terminated bytes32 string.&#13;
     * @param self The value to find the length of.&#13;
     * @return The length of the string, from 0 to 32.&#13;
     */&#13;
    function len(bytes32 self) internal returns (uint) {&#13;
        uint ret;&#13;
        if (self == 0)&#13;
            return 0;&#13;
        if (self &amp; 0xffffffffffffffffffffffffffffffff == 0) {&#13;
            ret += 16;&#13;
            self = bytes32(uint(self) / 0x100000000000000000000000000000000);&#13;
        }&#13;
        if (self &amp; 0xffffffffffffffff == 0) {&#13;
            ret += 8;&#13;
            self = bytes32(uint(self) / 0x10000000000000000);&#13;
        }&#13;
        if (self &amp; 0xffffffff == 0) {&#13;
            ret += 4;&#13;
            self = bytes32(uint(self) / 0x100000000);&#13;
        }&#13;
        if (self &amp; 0xffff == 0) {&#13;
            ret += 2;&#13;
            self = bytes32(uint(self) / 0x10000);&#13;
        }&#13;
        if (self &amp; 0xff == 0) {&#13;
            ret += 1;&#13;
        }&#13;
        return 32 - ret;&#13;
    }&#13;
&#13;
    /*&#13;
     * @dev Returns a slice containing the entire bytes32, interpreted as a&#13;
     *      null-termintaed utf-8 string.&#13;
     * @param self The bytes32 value to convert to a slice.&#13;
     * @return A new slice containing the value of the input argument up to the&#13;
     *         first null.&#13;
     */&#13;
    function toSliceB32(bytes32 self) internal returns (slice ret) {&#13;
        // Allocate space for `self` in memory, copy it there, and point ret at it&#13;
        assembly {&#13;
            let ptr := mload(0x40)&#13;
            mstore(0x40, add(ptr, 0x20))&#13;
            mstore(ptr, self)&#13;
            mstore(add(ret, 0x20), ptr)&#13;
        }&#13;
        ret._len = len(self);&#13;
    }&#13;
&#13;
    /*&#13;
     * @dev Returns a new slice containing the same data as the current slice.&#13;
     * @param self The slice to copy.&#13;
     * @return A new slice containing the same data as `self`.&#13;
     */&#13;
    function copy(slice self) internal returns (slice) {&#13;
        return slice(self._len, self._ptr);&#13;
    }&#13;
&#13;
    /*&#13;
     * @dev Copies a slice to a new string.&#13;
     * @param self The slice to copy.&#13;
     * @return A newly allocated string containing the slice's text.&#13;
     */&#13;
    function toString(slice self) internal returns (string) {&#13;
        var ret = new string(self._len);&#13;
        uint retptr;&#13;
        assembly { retptr := add(ret, 32) }&#13;
&#13;
        memcpy(retptr, self._ptr, self._len);&#13;
        return ret;&#13;
    }&#13;
&#13;
    /*&#13;
     * @dev Returns the length in runes of the slice. Note that this operation&#13;
     *      takes time proportional to the length of the slice; avoid using it&#13;
     *      in loops, and call `slice.empty()` if you only need to know whether&#13;
     *      the slice is empty or not.&#13;
     * @param self The slice to operate on.&#13;
     * @return The length of the slice in runes.&#13;
     */&#13;
    function len(slice self) internal returns (uint l) {&#13;
        // Starting at ptr-31 means the LSB will be the byte we care about&#13;
        var ptr = self._ptr - 31;&#13;
        var end = ptr + self._len;&#13;
        for (l = 0; ptr &lt; end; l++) {&#13;
            uint8 b;&#13;
            assembly { b := and(mload(ptr), 0xFF) }&#13;
            if (b &lt; 0x80) {&#13;
                ptr += 1;&#13;
            } else if(b &lt; 0xE0) {&#13;
                ptr += 2;&#13;
            } else if(b &lt; 0xF0) {&#13;
                ptr += 3;&#13;
            } else if(b &lt; 0xF8) {&#13;
                ptr += 4;&#13;
            } else if(b &lt; 0xFC) {&#13;
                ptr += 5;&#13;
            } else {&#13;
                ptr += 6;&#13;
            }&#13;
        }&#13;
    }&#13;
&#13;
    /*&#13;
     * @dev Returns true if the slice is empty (has a length of 0).&#13;
     * @param self The slice to operate on.&#13;
     * @return True if the slice is empty, False otherwise.&#13;
     */&#13;
    function empty(slice self) internal returns (bool) {&#13;
        return self._len == 0;&#13;
    }&#13;
&#13;
    /*&#13;
     * @dev Returns a positive number if `other` comes lexicographically after&#13;
     *      `self`, a negative number if it comes before, or zero if the&#13;
     *      contents of the two slices are equal. Comparison is done per-rune,&#13;
     *      on unicode codepoints.&#13;
     * @param self The first slice to compare.&#13;
     * @param other The second slice to compare.&#13;
     * @return The result of the comparison.&#13;
     */&#13;
    function compare(slice self, slice other) internal returns (int) {&#13;
        uint shortest = self._len;&#13;
        if (other._len &lt; self._len)&#13;
            shortest = other._len;&#13;
&#13;
        var selfptr = self._ptr;&#13;
        var otherptr = other._ptr;&#13;
        for (uint idx = 0; idx &lt; shortest; idx += 32) {&#13;
            uint a;&#13;
            uint b;&#13;
            assembly {&#13;
                a := mload(selfptr)&#13;
                b := mload(otherptr)&#13;
            }&#13;
            if (a != b) {&#13;
                // Mask out irrelevant bytes and check again&#13;
                uint mask = ~(2 ** (8 * (32 - shortest + idx)) - 1);&#13;
                var diff = (a &amp; mask) - (b &amp; mask);&#13;
                if (diff != 0)&#13;
                    return int(diff);&#13;
            }&#13;
            selfptr += 32;&#13;
            otherptr += 32;&#13;
        }&#13;
        return int(self._len) - int(other._len);&#13;
    }&#13;
&#13;
    /*&#13;
     * @dev Returns true if the two slices contain the same text.&#13;
     * @param self The first slice to compare.&#13;
     * @param self The second slice to compare.&#13;
     * @return True if the slices are equal, false otherwise.&#13;
     */&#13;
    function equals(slice self, slice other) internal returns (bool) {&#13;
        return compare(self, other) == 0;&#13;
    }&#13;
&#13;
    /*&#13;
     * @dev Extracts the first rune in the slice into `rune`, advancing the&#13;
     *      slice to point to the next rune and returning `self`.&#13;
     * @param self The slice to operate on.&#13;
     * @param rune The slice that will contain the first rune.&#13;
     * @return `rune`.&#13;
     */&#13;
    function nextRune(slice self, slice rune) internal returns (slice) {&#13;
        rune._ptr = self._ptr;&#13;
&#13;
        if (self._len == 0) {&#13;
            rune._len = 0;&#13;
            return rune;&#13;
        }&#13;
&#13;
        uint len;&#13;
        uint b;&#13;
        // Load the first byte of the rune into the LSBs of b&#13;
        assembly { b := and(mload(sub(mload(add(self, 32)), 31)), 0xFF) }&#13;
        if (b &lt; 0x80) {&#13;
            len = 1;&#13;
        } else if(b &lt; 0xE0) {&#13;
            len = 2;&#13;
        } else if(b &lt; 0xF0) {&#13;
            len = 3;&#13;
        } else {&#13;
            len = 4;&#13;
        }&#13;
&#13;
        // Check for truncated codepoints&#13;
        if (len &gt; self._len) {&#13;
            rune._len = self._len;&#13;
            self._ptr += self._len;&#13;
            self._len = 0;&#13;
            return rune;&#13;
        }&#13;
&#13;
        self._ptr += len;&#13;
        self._len -= len;&#13;
        rune._len = len;&#13;
        return rune;&#13;
    }&#13;
&#13;
    /*&#13;
     * @dev Returns the first rune in the slice, advancing the slice to point&#13;
     *      to the next rune.&#13;
     * @param self The slice to operate on.&#13;
     * @return A slice containing only the first rune from `self`.&#13;
     */&#13;
    function nextRune(slice self) internal returns (slice ret) {&#13;
        nextRune(self, ret);&#13;
    }&#13;
&#13;
    /*&#13;
     * @dev Returns the number of the first codepoint in the slice.&#13;
     * @param self The slice to operate on.&#13;
     * @return The number of the first codepoint in the slice.&#13;
     */&#13;
    function ord(slice self) internal returns (uint ret) {&#13;
        if (self._len == 0) {&#13;
            return 0;&#13;
        }&#13;
&#13;
        uint word;&#13;
        uint length;&#13;
        uint divisor = 2 ** 248;&#13;
&#13;
        // Load the rune into the MSBs of b&#13;
        assembly { word:= mload(mload(add(self, 32))) }&#13;
        var b = word / divisor;&#13;
        if (b &lt; 0x80) {&#13;
            ret = b;&#13;
            length = 1;&#13;
        } else if(b &lt; 0xE0) {&#13;
            ret = b &amp; 0x1F;&#13;
            length = 2;&#13;
        } else if(b &lt; 0xF0) {&#13;
            ret = b &amp; 0x0F;&#13;
            length = 3;&#13;
        } else {&#13;
            ret = b &amp; 0x07;&#13;
            length = 4;&#13;
        }&#13;
&#13;
        // Check for truncated codepoints&#13;
        if (length &gt; self._len) {&#13;
            return 0;&#13;
        }&#13;
&#13;
        for (uint i = 1; i &lt; length; i++) {&#13;
            divisor = divisor / 256;&#13;
            b = (word / divisor) &amp; 0xFF;&#13;
            if (b &amp; 0xC0 != 0x80) {&#13;
                // Invalid UTF-8 sequence&#13;
                return 0;&#13;
            }&#13;
            ret = (ret * 64) | (b &amp; 0x3F);&#13;
        }&#13;
&#13;
        return ret;&#13;
    }&#13;
&#13;
    /*&#13;
     * @dev Returns the keccak-256 hash of the slice.&#13;
     * @param self The slice to hash.&#13;
     * @return The hash of the slice.&#13;
     */&#13;
    function keccak(slice self) internal returns (bytes32 ret) {&#13;
        assembly {&#13;
            ret := keccak256(mload(add(self, 32)), mload(self))&#13;
        }&#13;
    }&#13;
&#13;
    /*&#13;
     * @dev Returns true if `self` starts with `needle`.&#13;
     * @param self The slice to operate on.&#13;
     * @param needle The slice to search for.&#13;
     * @return True if the slice starts with the provided text, false otherwise.&#13;
     */&#13;
    function startsWith(slice self, slice needle) internal returns (bool) {&#13;
        if (self._len &lt; needle._len) {&#13;
            return false;&#13;
        }&#13;
&#13;
        if (self._ptr == needle._ptr) {&#13;
            return true;&#13;
        }&#13;
&#13;
        bool equal;&#13;
        assembly {&#13;
            let length := mload(needle)&#13;
            let selfptr := mload(add(self, 0x20))&#13;
            let needleptr := mload(add(needle, 0x20))&#13;
            equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))&#13;
        }&#13;
        return equal;&#13;
    }&#13;
&#13;
    /*&#13;
     * @dev If `self` starts with `needle`, `needle` is removed from the&#13;
     *      beginning of `self`. Otherwise, `self` is unmodified.&#13;
     * @param self The slice to operate on.&#13;
     * @param needle The slice to search for.&#13;
     * @return `self`&#13;
     */&#13;
    function beyond(slice self, slice needle) internal returns (slice) {&#13;
        if (self._len &lt; needle._len) {&#13;
            return self;&#13;
        }&#13;
&#13;
        bool equal = true;&#13;
        if (self._ptr != needle._ptr) {&#13;
            assembly {&#13;
                let length := mload(needle)&#13;
                let selfptr := mload(add(self, 0x20))&#13;
                let needleptr := mload(add(needle, 0x20))&#13;
                equal := eq(sha3(selfptr, length), sha3(needleptr, length))&#13;
            }&#13;
        }&#13;
&#13;
        if (equal) {&#13;
            self._len -= needle._len;&#13;
            self._ptr += needle._len;&#13;
        }&#13;
&#13;
        return self;&#13;
    }&#13;
&#13;
    /*&#13;
     * @dev Returns true if the slice ends with `needle`.&#13;
     * @param self The slice to operate on.&#13;
     * @param needle The slice to search for.&#13;
     * @return True if the slice starts with the provided text, false otherwise.&#13;
     */&#13;
    function endsWith(slice self, slice needle) internal returns (bool) {&#13;
        if (self._len &lt; needle._len) {&#13;
            return false;&#13;
        }&#13;
&#13;
        var selfptr = self._ptr + self._len - needle._len;&#13;
&#13;
        if (selfptr == needle._ptr) {&#13;
            return true;&#13;
        }&#13;
&#13;
        bool equal;&#13;
        assembly {&#13;
            let length := mload(needle)&#13;
            let needleptr := mload(add(needle, 0x20))&#13;
            equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))&#13;
        }&#13;
&#13;
        return equal;&#13;
    }&#13;
&#13;
    /*&#13;
     * @dev If `self` ends with `needle`, `needle` is removed from the&#13;
     *      end of `self`. Otherwise, `self` is unmodified.&#13;
     * @param self The slice to operate on.&#13;
     * @param needle The slice to search for.&#13;
     * @return `self`&#13;
     */&#13;
    function until(slice self, slice needle) internal returns (slice) {&#13;
        if (self._len &lt; needle._len) {&#13;
            return self;&#13;
        }&#13;
&#13;
        var selfptr = self._ptr + self._len - needle._len;&#13;
        bool equal = true;&#13;
        if (selfptr != needle._ptr) {&#13;
            assembly {&#13;
                let length := mload(needle)&#13;
                let needleptr := mload(add(needle, 0x20))&#13;
                equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))&#13;
            }&#13;
        }&#13;
&#13;
        if (equal) {&#13;
            self._len -= needle._len;&#13;
        }&#13;
&#13;
        return self;&#13;
    }&#13;
&#13;
    // Returns the memory address of the first byte of the first occurrence of&#13;
    // `needle` in `self`, or the first byte after `self` if not found.&#13;
    function findPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private returns (uint) {&#13;
        uint ptr;&#13;
        uint idx;&#13;
&#13;
        if (needlelen &lt;= selflen) {&#13;
            if (needlelen &lt;= 32) {&#13;
                // Optimized assembly for 68 gas per byte on short strings&#13;
                assembly {&#13;
                    let mask := not(sub(exp(2, mul(8, sub(32, needlelen))), 1))&#13;
                    let needledata := and(mload(needleptr), mask)&#13;
                    let end := add(selfptr, sub(selflen, needlelen))&#13;
                    ptr := selfptr&#13;
                    loop:&#13;
                    jumpi(exit, eq(and(mload(ptr), mask), needledata))&#13;
                    ptr := add(ptr, 1)&#13;
                    jumpi(loop, lt(sub(ptr, 1), end))&#13;
                    ptr := add(selfptr, selflen)&#13;
                    exit:&#13;
                }&#13;
                return ptr;&#13;
            } else {&#13;
                // For long needles, use hashing&#13;
                bytes32 hash;&#13;
                assembly { hash := sha3(needleptr, needlelen) }&#13;
                ptr = selfptr;&#13;
                for (idx = 0; idx &lt;= selflen - needlelen; idx++) {&#13;
                    bytes32 testHash;&#13;
                    assembly { testHash := sha3(ptr, needlelen) }&#13;
                    if (hash == testHash)&#13;
                        return ptr;&#13;
                    ptr += 1;&#13;
                }&#13;
            }&#13;
        }&#13;
        return selfptr + selflen;&#13;
    }&#13;
&#13;
    // Returns the memory address of the first byte after the last occurrence of&#13;
    // `needle` in `self`, or the address of `self` if not found.&#13;
    function rfindPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private returns (uint) {&#13;
        uint ptr;&#13;
&#13;
        if (needlelen &lt;= selflen) {&#13;
            if (needlelen &lt;= 32) {&#13;
                // Optimized assembly for 69 gas per byte on short strings&#13;
                assembly {&#13;
                    let mask := not(sub(exp(2, mul(8, sub(32, needlelen))), 1))&#13;
                    let needledata := and(mload(needleptr), mask)&#13;
                    ptr := add(selfptr, sub(selflen, needlelen))&#13;
                    loop:&#13;
                    jumpi(ret, eq(and(mload(ptr), mask), needledata))&#13;
                    ptr := sub(ptr, 1)&#13;
                    jumpi(loop, gt(add(ptr, 1), selfptr))&#13;
                    ptr := selfptr&#13;
                    jump(exit)&#13;
                    ret:&#13;
                    ptr := add(ptr, needlelen)&#13;
                    exit:&#13;
                }&#13;
                return ptr;&#13;
            } else {&#13;
                // For long needles, use hashing&#13;
                bytes32 hash;&#13;
                assembly { hash := sha3(needleptr, needlelen) }&#13;
                ptr = selfptr + (selflen - needlelen);&#13;
                while (ptr &gt;= selfptr) {&#13;
                    bytes32 testHash;&#13;
                    assembly { testHash := sha3(ptr, needlelen) }&#13;
                    if (hash == testHash)&#13;
                        return ptr + needlelen;&#13;
                    ptr -= 1;&#13;
                }&#13;
            }&#13;
        }&#13;
        return selfptr;&#13;
    }&#13;
&#13;
    /*&#13;
     * @dev Modifies `self` to contain everything from the first occurrence of&#13;
     *      `needle` to the end of the slice. `self` is set to the empty slice&#13;
     *      if `needle` is not found.&#13;
     * @param self The slice to search and modify.&#13;
     * @param needle The text to search for.&#13;
     * @return `self`.&#13;
     */&#13;
    function find(slice self, slice needle) internal returns (slice) {&#13;
        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr);&#13;
        self._len -= ptr - self._ptr;&#13;
        self._ptr = ptr;&#13;
        return self;&#13;
    }&#13;
&#13;
    /*&#13;
     * @dev Modifies `self` to contain the part of the string from the start of&#13;
     *      `self` to the end of the first occurrence of `needle`. If `needle`&#13;
     *      is not found, `self` is set to the empty slice.&#13;
     * @param self The slice to search and modify.&#13;
     * @param needle The text to search for.&#13;
     * @return `self`.&#13;
     */&#13;
    function rfind(slice self, slice needle) internal returns (slice) {&#13;
        uint ptr = rfindPtr(self._len, self._ptr, needle._len, needle._ptr);&#13;
        self._len = ptr - self._ptr;&#13;
        return self;&#13;
    }&#13;
&#13;
    /*&#13;
     * @dev Splits the slice, setting `self` to everything after the first&#13;
     *      occurrence of `needle`, and `token` to everything before it. If&#13;
     *      `needle` does not occur in `self`, `self` is set to the empty slice,&#13;
     *      and `token` is set to the entirety of `self`.&#13;
     * @param self The slice to split.&#13;
     * @param needle The text to search for in `self`.&#13;
     * @param token An output parameter to which the first token is written.&#13;
     * @return `token`.&#13;
     */&#13;
    function split(slice self, slice needle, slice token) internal returns (slice) {&#13;
        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr);&#13;
        token._ptr = self._ptr;&#13;
        token._len = ptr - self._ptr;&#13;
        if (ptr == self._ptr + self._len) {&#13;
            // Not found&#13;
            self._len = 0;&#13;
        } else {&#13;
            self._len -= token._len + needle._len;&#13;
            self._ptr = ptr + needle._len;&#13;
        }&#13;
        return token;&#13;
    }&#13;
&#13;
    /*&#13;
     * @dev Splits the slice, setting `self` to everything after the first&#13;
     *      occurrence of `needle`, and returning everything before it. If&#13;
     *      `needle` does not occur in `self`, `self` is set to the empty slice,&#13;
     *      and the entirety of `self` is returned.&#13;
     * @param self The slice to split.&#13;
     * @param needle The text to search for in `self`.&#13;
     * @return The part of `self` up to the first occurrence of `delim`.&#13;
     */&#13;
    function split(slice self, slice needle) internal returns (slice token) {&#13;
        split(self, needle, token);&#13;
    }&#13;
&#13;
    /*&#13;
     * @dev Splits the slice, setting `self` to everything before the last&#13;
     *      occurrence of `needle`, and `token` to everything after it. If&#13;
     *      `needle` does not occur in `self`, `self` is set to the empty slice,&#13;
     *      and `token` is set to the entirety of `self`.&#13;
     * @param self The slice to split.&#13;
     * @param needle The text to search for in `self`.&#13;
     * @param token An output parameter to which the first token is written.&#13;
     * @return `token`.&#13;
     */&#13;
    function rsplit(slice self, slice needle, slice token) internal returns (slice) {&#13;
        uint ptr = rfindPtr(self._len, self._ptr, needle._len, needle._ptr);&#13;
        token._ptr = ptr;&#13;
        token._len = self._len - (ptr - self._ptr);&#13;
        if (ptr == self._ptr) {&#13;
            // Not found&#13;
            self._len = 0;&#13;
        } else {&#13;
            self._len -= token._len + needle._len;&#13;
        }&#13;
        return token;&#13;
    }&#13;
&#13;
    /*&#13;
     * @dev Splits the slice, setting `self` to everything before the last&#13;
     *      occurrence of `needle`, and returning everything after it. If&#13;
     *      `needle` does not occur in `self`, `self` is set to the empty slice,&#13;
     *      and the entirety of `self` is returned.&#13;
     * @param self The slice to split.&#13;
     * @param needle The text to search for in `self`.&#13;
     * @return The part of `self` after the last occurrence of `delim`.&#13;
     */&#13;
    function rsplit(slice self, slice needle) internal returns (slice token) {&#13;
        rsplit(self, needle, token);&#13;
    }&#13;
&#13;
    /*&#13;
     * @dev Counts the number of nonoverlapping occurrences of `needle` in `self`.&#13;
     * @param self The slice to search.&#13;
     * @param needle The text to search for in `self`.&#13;
     * @return The number of occurrences of `needle` found in `self`.&#13;
     */&#13;
    function count(slice self, slice needle) internal returns (uint cnt) {&#13;
        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr) + needle._len;&#13;
        while (ptr &lt;= self._ptr + self._len) {&#13;
            cnt++;&#13;
            ptr = findPtr(self._len - (ptr - self._ptr), ptr, needle._len, needle._ptr) + needle._len;&#13;
        }&#13;
    }&#13;
&#13;
    /*&#13;
     * @dev Returns True if `self` contains `needle`.&#13;
     * @param self The slice to search.&#13;
     * @param needle The text to search for in `self`.&#13;
     * @return True if `needle` is found in `self`, false otherwise.&#13;
     */&#13;
    function contains(slice self, slice needle) internal returns (bool) {&#13;
        return rfindPtr(self._len, self._ptr, needle._len, needle._ptr) != self._ptr;&#13;
    }&#13;
&#13;
    /*&#13;
     * @dev Returns a newly allocated string containing the concatenation of&#13;
     *      `self` and `other`.&#13;
     * @param self The first slice to concatenate.&#13;
     * @param other The second slice to concatenate.&#13;
     * @return The concatenation of the two strings.&#13;
     */&#13;
    function concat(slice self, slice other) internal returns (string) {&#13;
        var ret = new string(self._len + other._len);&#13;
        uint retptr;&#13;
        assembly { retptr := add(ret, 32) }&#13;
        memcpy(retptr, self._ptr, self._len);&#13;
        memcpy(retptr + self._len, other._ptr, other._len);&#13;
        return ret;&#13;
    }&#13;
&#13;
    /*&#13;
     * @dev Joins an array of slices, using `self` as a delimiter, returning a&#13;
     *      newly allocated string.&#13;
     * @param self The delimiter to use.&#13;
     * @param parts A list of slices to join.&#13;
     * @return A newly allocated string containing all the slices in `parts`,&#13;
     *         joined with `self`.&#13;
     */&#13;
    function join(slice self, slice[] parts) internal returns (string) {&#13;
        if (parts.length == 0)&#13;
            return "";&#13;
&#13;
        uint length = self._len * (parts.length - 1);&#13;
        for(uint i = 0; i &lt; parts.length; i++)&#13;
            length += parts[i]._len;&#13;
&#13;
        var ret = new string(length);&#13;
        uint retptr;&#13;
        assembly { retptr := add(ret, 32) }&#13;
&#13;
        for(i = 0; i &lt; parts.length; i++) {&#13;
            memcpy(retptr, parts[i]._ptr, parts[i]._len);&#13;
            retptr += parts[i]._len;&#13;
            if (i &lt; parts.length - 1) {&#13;
                memcpy(retptr, self._ptr, self._len);&#13;
                retptr += self._len;&#13;
            }&#13;
        }&#13;
&#13;
        return ret;&#13;
    }&#13;
}&#13;
// &lt;ORACLIZE_API&gt;&#13;
/*&#13;
Copyright (c) 2015-2016 Oraclize SRL&#13;
Copyright (c) 2016 Oraclize LTD&#13;
&#13;
&#13;
&#13;
Permission is hereby granted, free of charge, to any person obtaining a copy&#13;
of this software and associated documentation files (the "Software"), to deal&#13;
in the Software without restriction, including without limitation the rights&#13;
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell&#13;
copies of the Software, and to permit persons to whom the Software is&#13;
furnished to do so, subject to the following conditions:&#13;
&#13;
&#13;
&#13;
The above copyright notice and this permission notice shall be included in&#13;
all copies or substantial portions of the Software.&#13;
&#13;
&#13;
&#13;
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR&#13;
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,&#13;
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE&#13;
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER&#13;
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,&#13;
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN&#13;
THE SOFTWARE.&#13;
*/&#13;
&#13;
//pragma solidity ^0.4.0;//please import oraclizeAPI_pre0.4.sol when solidity &lt; 0.4.0&#13;
&#13;
contract OraclizeI {&#13;
    address public cbAddress;&#13;
    function query(uint _timestamp, string _datasource, string _arg) payable returns (bytes32 _id);&#13;
    function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) payable returns (bytes32 _id);&#13;
    function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) payable returns (bytes32 _id);&#13;
    function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) payable returns (bytes32 _id);&#13;
    function queryN(uint _timestamp, string _datasource, bytes _argN) payable returns (bytes32 _id);&#13;
    function queryN_withGasLimit(uint _timestamp, string _datasource, bytes _argN, uint _gaslimit) payable returns (bytes32 _id);&#13;
    function getPrice(string _datasource) returns (uint _dsprice);&#13;
    function getPrice(string _datasource, uint gaslimit) returns (uint _dsprice);&#13;
    function useCoupon(string _coupon);&#13;
    function setProofType(byte _proofType);&#13;
    function setConfig(bytes32 _config);&#13;
    function setCustomGasPrice(uint _gasPrice);&#13;
    function randomDS_getSessionPubKeyHash() returns(bytes32);&#13;
}&#13;
contract OraclizeAddrResolverI {&#13;
    function getAddress() returns (address _addr);&#13;
}&#13;
contract usingOraclize {&#13;
    uint constant day = 60*60*24;&#13;
    uint constant week = 60*60*24*7;&#13;
    uint constant month = 60*60*24*30;&#13;
    byte constant proofType_NONE = 0x00;&#13;
    byte constant proofType_TLSNotary = 0x10;&#13;
    byte constant proofType_Android = 0x20;&#13;
    byte constant proofType_Ledger = 0x30;&#13;
    byte constant proofType_Native = 0xF0;&#13;
    byte constant proofStorage_IPFS = 0x01;&#13;
    uint8 constant networkID_auto = 0;&#13;
    uint8 constant networkID_mainnet = 1;&#13;
    uint8 constant networkID_testnet = 2;&#13;
    uint8 constant networkID_morden = 2;&#13;
    uint8 constant networkID_consensys = 161;&#13;
&#13;
    OraclizeAddrResolverI OAR;&#13;
&#13;
    OraclizeI oraclize;&#13;
    modifier oraclizeAPI {&#13;
        if((address(OAR)==0)||(getCodeSize(address(OAR))==0))&#13;
            oraclize_setNetwork(networkID_auto);&#13;
&#13;
        if(address(oraclize) != OAR.getAddress())&#13;
            oraclize = OraclizeI(OAR.getAddress());&#13;
&#13;
        _;&#13;
    }&#13;
    modifier coupon(string code){&#13;
        oraclize = OraclizeI(OAR.getAddress());&#13;
        oraclize.useCoupon(code);&#13;
        _;&#13;
    }&#13;
&#13;
    function oraclize_setNetwork(uint8 networkID) internal returns(bool){&#13;
        if (getCodeSize(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed)&gt;0){ //mainnet&#13;
            OAR = OraclizeAddrResolverI(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed);&#13;
            oraclize_setNetworkName("eth_mainnet");&#13;
            return true;&#13;
        }&#13;
        if (getCodeSize(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1)&gt;0){ //ropsten testnet&#13;
            OAR = OraclizeAddrResolverI(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1);&#13;
            oraclize_setNetworkName("eth_ropsten3");&#13;
            return true;&#13;
        }&#13;
        if (getCodeSize(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e)&gt;0){ //kovan testnet&#13;
            OAR = OraclizeAddrResolverI(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e);&#13;
            oraclize_setNetworkName("eth_kovan");&#13;
            return true;&#13;
        }&#13;
        if (getCodeSize(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48)&gt;0){ //rinkeby testnet&#13;
            OAR = OraclizeAddrResolverI(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48);&#13;
            oraclize_setNetworkName("eth_rinkeby");&#13;
            return true;&#13;
        }&#13;
        if (getCodeSize(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475)&gt;0){ //ethereum-bridge&#13;
            OAR = OraclizeAddrResolverI(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475);&#13;
            return true;&#13;
        }&#13;
        if (getCodeSize(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF)&gt;0){ //ether.camp ide&#13;
            OAR = OraclizeAddrResolverI(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF);&#13;
            return true;&#13;
        }&#13;
        if (getCodeSize(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA)&gt;0){ //browser-solidity&#13;
            OAR = OraclizeAddrResolverI(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA);&#13;
            return true;&#13;
        }&#13;
        return false;&#13;
    }&#13;
&#13;
    function __callback(bytes32 myid, string result) {&#13;
        __callback(myid, result, new bytes(0));&#13;
    }&#13;
    function __callback(bytes32 myid, string result, bytes proof) {&#13;
    }&#13;
&#13;
    function oraclize_useCoupon(string code) oraclizeAPI internal {&#13;
        oraclize.useCoupon(code);&#13;
    }&#13;
&#13;
    function oraclize_getPrice(string datasource) oraclizeAPI internal returns (uint){&#13;
        return oraclize.getPrice(datasource);&#13;
    }&#13;
&#13;
    function oraclize_getPrice(string datasource, uint gaslimit) oraclizeAPI internal returns (uint){&#13;
        return oraclize.getPrice(datasource, gaslimit);&#13;
    }&#13;
&#13;
    function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){&#13;
        uint price = oraclize.getPrice(datasource);&#13;
        if (price &gt; 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price&#13;
        return oraclize.query.value(price)(0, datasource, arg);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){&#13;
        uint price = oraclize.getPrice(datasource);&#13;
        if (price &gt; 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price&#13;
        return oraclize.query.value(price)(timestamp, datasource, arg);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){&#13;
        uint price = oraclize.getPrice(datasource, gaslimit);&#13;
        if (price &gt; 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price&#13;
        return oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){&#13;
        uint price = oraclize.getPrice(datasource, gaslimit);&#13;
        if (price &gt; 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price&#13;
        return oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){&#13;
        uint price = oraclize.getPrice(datasource);&#13;
        if (price &gt; 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price&#13;
        return oraclize.query2.value(price)(0, datasource, arg1, arg2);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){&#13;
        uint price = oraclize.getPrice(datasource);&#13;
        if (price &gt; 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price&#13;
        return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){&#13;
        uint price = oraclize.getPrice(datasource, gaslimit);&#13;
        if (price &gt; 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price&#13;
        return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){&#13;
        uint price = oraclize.getPrice(datasource, gaslimit);&#13;
        if (price &gt; 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price&#13;
        return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, string[] argN) oraclizeAPI internal returns (bytes32 id){&#13;
        uint price = oraclize.getPrice(datasource);&#13;
        if (price &gt; 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price&#13;
        bytes memory args = stra2cbor(argN);&#13;
        return oraclize.queryN.value(price)(0, datasource, args);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, string[] argN) oraclizeAPI internal returns (bytes32 id){&#13;
        uint price = oraclize.getPrice(datasource);&#13;
        if (price &gt; 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price&#13;
        bytes memory args = stra2cbor(argN);&#13;
        return oraclize.queryN.value(price)(timestamp, datasource, args);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, string[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){&#13;
        uint price = oraclize.getPrice(datasource, gaslimit);&#13;
        if (price &gt; 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price&#13;
        bytes memory args = stra2cbor(argN);&#13;
        return oraclize.queryN_withGasLimit.value(price)(timestamp, datasource, args, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, string[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){&#13;
        uint price = oraclize.getPrice(datasource, gaslimit);&#13;
        if (price &gt; 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price&#13;
        bytes memory args = stra2cbor(argN);&#13;
        return oraclize.queryN_withGasLimit.value(price)(0, datasource, args, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, string[1] args) oraclizeAPI internal returns (bytes32 id) {&#13;
        string[] memory dynargs = new string[](1);&#13;
        dynargs[0] = args[0];&#13;
        return oraclize_query(datasource, dynargs);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, string[1] args) oraclizeAPI internal returns (bytes32 id) {&#13;
        string[] memory dynargs = new string[](1);&#13;
        dynargs[0] = args[0];&#13;
        return oraclize_query(timestamp, datasource, dynargs);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, string[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {&#13;
        string[] memory dynargs = new string[](1);&#13;
        dynargs[0] = args[0];&#13;
        return oraclize_query(timestamp, datasource, dynargs, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, string[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {&#13;
        string[] memory dynargs = new string[](1);&#13;
        dynargs[0] = args[0];&#13;
        return oraclize_query(datasource, dynargs, gaslimit);&#13;
    }&#13;
&#13;
    function oraclize_query(string datasource, string[2] args) oraclizeAPI internal returns (bytes32 id) {&#13;
        string[] memory dynargs = new string[](2);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        return oraclize_query(datasource, dynargs);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, string[2] args) oraclizeAPI internal returns (bytes32 id) {&#13;
        string[] memory dynargs = new string[](2);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        return oraclize_query(timestamp, datasource, dynargs);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, string[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {&#13;
        string[] memory dynargs = new string[](2);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        return oraclize_query(timestamp, datasource, dynargs, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, string[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {&#13;
        string[] memory dynargs = new string[](2);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        return oraclize_query(datasource, dynargs, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, string[3] args) oraclizeAPI internal returns (bytes32 id) {&#13;
        string[] memory dynargs = new string[](3);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        return oraclize_query(datasource, dynargs);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, string[3] args) oraclizeAPI internal returns (bytes32 id) {&#13;
        string[] memory dynargs = new string[](3);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        return oraclize_query(timestamp, datasource, dynargs);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, string[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {&#13;
        string[] memory dynargs = new string[](3);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        return oraclize_query(timestamp, datasource, dynargs, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, string[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {&#13;
        string[] memory dynargs = new string[](3);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        return oraclize_query(datasource, dynargs, gaslimit);&#13;
    }&#13;
&#13;
    function oraclize_query(string datasource, string[4] args) oraclizeAPI internal returns (bytes32 id) {&#13;
        string[] memory dynargs = new string[](4);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        dynargs[3] = args[3];&#13;
        return oraclize_query(datasource, dynargs);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, string[4] args) oraclizeAPI internal returns (bytes32 id) {&#13;
        string[] memory dynargs = new string[](4);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        dynargs[3] = args[3];&#13;
        return oraclize_query(timestamp, datasource, dynargs);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, string[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {&#13;
        string[] memory dynargs = new string[](4);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        dynargs[3] = args[3];&#13;
        return oraclize_query(timestamp, datasource, dynargs, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, string[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {&#13;
        string[] memory dynargs = new string[](4);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        dynargs[3] = args[3];&#13;
        return oraclize_query(datasource, dynargs, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, string[5] args) oraclizeAPI internal returns (bytes32 id) {&#13;
        string[] memory dynargs = new string[](5);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        dynargs[3] = args[3];&#13;
        dynargs[4] = args[4];&#13;
        return oraclize_query(datasource, dynargs);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, string[5] args) oraclizeAPI internal returns (bytes32 id) {&#13;
        string[] memory dynargs = new string[](5);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        dynargs[3] = args[3];&#13;
        dynargs[4] = args[4];&#13;
        return oraclize_query(timestamp, datasource, dynargs);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, string[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {&#13;
        string[] memory dynargs = new string[](5);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        dynargs[3] = args[3];&#13;
        dynargs[4] = args[4];&#13;
        return oraclize_query(timestamp, datasource, dynargs, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, string[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {&#13;
        string[] memory dynargs = new string[](5);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        dynargs[3] = args[3];&#13;
        dynargs[4] = args[4];&#13;
        return oraclize_query(datasource, dynargs, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, bytes[] argN) oraclizeAPI internal returns (bytes32 id){&#13;
        uint price = oraclize.getPrice(datasource);&#13;
        if (price &gt; 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price&#13;
        bytes memory args = ba2cbor(argN);&#13;
        return oraclize.queryN.value(price)(0, datasource, args);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, bytes[] argN) oraclizeAPI internal returns (bytes32 id){&#13;
        uint price = oraclize.getPrice(datasource);&#13;
        if (price &gt; 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price&#13;
        bytes memory args = ba2cbor(argN);&#13;
        return oraclize.queryN.value(price)(timestamp, datasource, args);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, bytes[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){&#13;
        uint price = oraclize.getPrice(datasource, gaslimit);&#13;
        if (price &gt; 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price&#13;
        bytes memory args = ba2cbor(argN);&#13;
        return oraclize.queryN_withGasLimit.value(price)(timestamp, datasource, args, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, bytes[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){&#13;
        uint price = oraclize.getPrice(datasource, gaslimit);&#13;
        if (price &gt; 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price&#13;
        bytes memory args = ba2cbor(argN);&#13;
        return oraclize.queryN_withGasLimit.value(price)(0, datasource, args, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, bytes[1] args) oraclizeAPI internal returns (bytes32 id) {&#13;
        bytes[] memory dynargs = new bytes[](1);&#13;
        dynargs[0] = args[0];&#13;
        return oraclize_query(datasource, dynargs);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, bytes[1] args) oraclizeAPI internal returns (bytes32 id) {&#13;
        bytes[] memory dynargs = new bytes[](1);&#13;
        dynargs[0] = args[0];&#13;
        return oraclize_query(timestamp, datasource, dynargs);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, bytes[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {&#13;
        bytes[] memory dynargs = new bytes[](1);&#13;
        dynargs[0] = args[0];&#13;
        return oraclize_query(timestamp, datasource, dynargs, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, bytes[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {&#13;
        bytes[] memory dynargs = new bytes[](1);&#13;
        dynargs[0] = args[0];&#13;
        return oraclize_query(datasource, dynargs, gaslimit);&#13;
    }&#13;
&#13;
    function oraclize_query(string datasource, bytes[2] args) oraclizeAPI internal returns (bytes32 id) {&#13;
        bytes[] memory dynargs = new bytes[](2);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        return oraclize_query(datasource, dynargs);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, bytes[2] args) oraclizeAPI internal returns (bytes32 id) {&#13;
        bytes[] memory dynargs = new bytes[](2);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        return oraclize_query(timestamp, datasource, dynargs);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, bytes[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {&#13;
        bytes[] memory dynargs = new bytes[](2);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        return oraclize_query(timestamp, datasource, dynargs, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, bytes[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {&#13;
        bytes[] memory dynargs = new bytes[](2);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        return oraclize_query(datasource, dynargs, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, bytes[3] args) oraclizeAPI internal returns (bytes32 id) {&#13;
        bytes[] memory dynargs = new bytes[](3);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        return oraclize_query(datasource, dynargs);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, bytes[3] args) oraclizeAPI internal returns (bytes32 id) {&#13;
        bytes[] memory dynargs = new bytes[](3);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        return oraclize_query(timestamp, datasource, dynargs);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, bytes[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {&#13;
        bytes[] memory dynargs = new bytes[](3);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        return oraclize_query(timestamp, datasource, dynargs, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, bytes[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {&#13;
        bytes[] memory dynargs = new bytes[](3);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        return oraclize_query(datasource, dynargs, gaslimit);&#13;
    }&#13;
&#13;
    function oraclize_query(string datasource, bytes[4] args) oraclizeAPI internal returns (bytes32 id) {&#13;
        bytes[] memory dynargs = new bytes[](4);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        dynargs[3] = args[3];&#13;
        return oraclize_query(datasource, dynargs);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, bytes[4] args) oraclizeAPI internal returns (bytes32 id) {&#13;
        bytes[] memory dynargs = new bytes[](4);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        dynargs[3] = args[3];&#13;
        return oraclize_query(timestamp, datasource, dynargs);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, bytes[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {&#13;
        bytes[] memory dynargs = new bytes[](4);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        dynargs[3] = args[3];&#13;
        return oraclize_query(timestamp, datasource, dynargs, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, bytes[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {&#13;
        bytes[] memory dynargs = new bytes[](4);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        dynargs[3] = args[3];&#13;
        return oraclize_query(datasource, dynargs, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, bytes[5] args) oraclizeAPI internal returns (bytes32 id) {&#13;
        bytes[] memory dynargs = new bytes[](5);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        dynargs[3] = args[3];&#13;
        dynargs[4] = args[4];&#13;
        return oraclize_query(datasource, dynargs);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, bytes[5] args) oraclizeAPI internal returns (bytes32 id) {&#13;
        bytes[] memory dynargs = new bytes[](5);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        dynargs[3] = args[3];&#13;
        dynargs[4] = args[4];&#13;
        return oraclize_query(timestamp, datasource, dynargs);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, bytes[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {&#13;
        bytes[] memory dynargs = new bytes[](5);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        dynargs[3] = args[3];&#13;
        dynargs[4] = args[4];&#13;
        return oraclize_query(timestamp, datasource, dynargs, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, bytes[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {&#13;
        bytes[] memory dynargs = new bytes[](5);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        dynargs[3] = args[3];&#13;
        dynargs[4] = args[4];&#13;
        return oraclize_query(datasource, dynargs, gaslimit);&#13;
    }&#13;
&#13;
    function oraclize_cbAddress() oraclizeAPI internal returns (address){&#13;
        return oraclize.cbAddress();&#13;
    }&#13;
    function oraclize_setProof(byte proofP) oraclizeAPI internal {&#13;
        return oraclize.setProofType(proofP);&#13;
    }&#13;
    function oraclize_setCustomGasPrice(uint gasPrice) oraclizeAPI internal {&#13;
        return oraclize.setCustomGasPrice(gasPrice);&#13;
    }&#13;
    function oraclize_setConfig(bytes32 config) oraclizeAPI internal {&#13;
        return oraclize.setConfig(config);&#13;
    }&#13;
&#13;
    function oraclize_randomDS_getSessionPubKeyHash() oraclizeAPI internal returns (bytes32){&#13;
        return oraclize.randomDS_getSessionPubKeyHash();&#13;
    }&#13;
&#13;
    function getCodeSize(address _addr) constant internal returns(uint _size) {&#13;
        assembly {&#13;
            _size := extcodesize(_addr)&#13;
        }&#13;
    }&#13;
&#13;
    function parseAddr(string _a) internal returns (address){&#13;
        bytes memory tmp = bytes(_a);&#13;
        uint160 iaddr = 0;&#13;
        uint160 b1;&#13;
        uint160 b2;&#13;
        for (uint i=2; i&lt;2+2*20; i+=2){&#13;
            iaddr *= 256;&#13;
            b1 = uint160(tmp[i]);&#13;
            b2 = uint160(tmp[i+1]);&#13;
            if ((b1 &gt;= 97)&amp;&amp;(b1 &lt;= 102)) b1 -= 87;&#13;
            else if ((b1 &gt;= 65)&amp;&amp;(b1 &lt;= 70)) b1 -= 55;&#13;
            else if ((b1 &gt;= 48)&amp;&amp;(b1 &lt;= 57)) b1 -= 48;&#13;
            if ((b2 &gt;= 97)&amp;&amp;(b2 &lt;= 102)) b2 -= 87;&#13;
            else if ((b2 &gt;= 65)&amp;&amp;(b2 &lt;= 70)) b2 -= 55;&#13;
            else if ((b2 &gt;= 48)&amp;&amp;(b2 &lt;= 57)) b2 -= 48;&#13;
            iaddr += (b1*16+b2);&#13;
        }&#13;
        return address(iaddr);&#13;
    }&#13;
&#13;
    function strCompare(string _a, string _b) internal returns (int) {&#13;
        bytes memory a = bytes(_a);&#13;
        bytes memory b = bytes(_b);&#13;
        uint minLength = a.length;&#13;
        if (b.length &lt; minLength) minLength = b.length;&#13;
        for (uint i = 0; i &lt; minLength; i ++)&#13;
            if (a[i] &lt; b[i])&#13;
                return -1;&#13;
            else if (a[i] &gt; b[i])&#13;
                return 1;&#13;
        if (a.length &lt; b.length)&#13;
            return -1;&#13;
        else if (a.length &gt; b.length)&#13;
            return 1;&#13;
        else&#13;
            return 0;&#13;
    }&#13;
&#13;
    function indexOf(string _haystack, string _needle) internal returns (int) {&#13;
        bytes memory h = bytes(_haystack);&#13;
        bytes memory n = bytes(_needle);&#13;
        if(h.length &lt; 1 || n.length &lt; 1 || (n.length &gt; h.length))&#13;
            return -1;&#13;
        else if(h.length &gt; (2**128 -1))&#13;
            return -1;&#13;
        else&#13;
        {&#13;
            uint subindex = 0;&#13;
            for (uint i = 0; i &lt; h.length; i ++)&#13;
            {&#13;
                if (h[i] == n[0])&#13;
                {&#13;
                    subindex = 1;&#13;
                    while(subindex &lt; n.length &amp;&amp; (i + subindex) &lt; h.length &amp;&amp; h[i + subindex] == n[subindex])&#13;
                    {&#13;
                        subindex++;&#13;
                    }&#13;
                    if(subindex == n.length)&#13;
                        return int(i);&#13;
                }&#13;
            }&#13;
            return -1;&#13;
        }&#13;
    }&#13;
&#13;
    function strConcat(string _a, string _b, string _c, string _d, string _e) internal returns (string) {&#13;
        bytes memory _ba = bytes(_a);&#13;
        bytes memory _bb = bytes(_b);&#13;
        bytes memory _bc = bytes(_c);&#13;
        bytes memory _bd = bytes(_d);&#13;
        bytes memory _be = bytes(_e);&#13;
        string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);&#13;
        bytes memory babcde = bytes(abcde);&#13;
        uint k = 0;&#13;
        for (uint i = 0; i &lt; _ba.length; i++) babcde[k++] = _ba[i];&#13;
        for (i = 0; i &lt; _bb.length; i++) babcde[k++] = _bb[i];&#13;
        for (i = 0; i &lt; _bc.length; i++) babcde[k++] = _bc[i];&#13;
        for (i = 0; i &lt; _bd.length; i++) babcde[k++] = _bd[i];&#13;
        for (i = 0; i &lt; _be.length; i++) babcde[k++] = _be[i];&#13;
        return string(babcde);&#13;
    }&#13;
&#13;
    function strConcat(string _a, string _b, string _c, string _d) internal returns (string) {&#13;
        return strConcat(_a, _b, _c, _d, "");&#13;
    }&#13;
&#13;
    function strConcat(string _a, string _b, string _c) internal returns (string) {&#13;
        return strConcat(_a, _b, _c, "", "");&#13;
    }&#13;
&#13;
    function strConcat(string _a, string _b) internal returns (string) {&#13;
        return strConcat(_a, _b, "", "", "");&#13;
    }&#13;
&#13;
    // parseInt&#13;
    function parseInt(string _a) internal returns (uint) {&#13;
        return parseInt(_a, 0);&#13;
    }&#13;
&#13;
    // parseInt(parseFloat*10^_b)&#13;
    function parseInt(string _a, uint _b) internal returns (uint) {&#13;
        bytes memory bresult = bytes(_a);&#13;
        uint mint = 0;&#13;
        bool decimals = false;&#13;
        for (uint i=0; i&lt;bresult.length; i++){&#13;
            if ((bresult[i] &gt;= 48)&amp;&amp;(bresult[i] &lt;= 57)){&#13;
                if (decimals){&#13;
                   if (_b == 0) break;&#13;
                    else _b--;&#13;
                }&#13;
                mint *= 10;&#13;
                mint += uint(bresult[i]) - 48;&#13;
            } else if (bresult[i] == 46) decimals = true;&#13;
        }&#13;
        if (_b &gt; 0) mint *= 10**_b;&#13;
        return mint;&#13;
    }&#13;
&#13;
    function uint2str(uint i) internal returns (string){&#13;
        if (i == 0) return "0";&#13;
        uint j = i;&#13;
        uint len;&#13;
        while (j != 0){&#13;
            len++;&#13;
            j /= 10;&#13;
        }&#13;
        bytes memory bstr = new bytes(len);&#13;
        uint k = len - 1;&#13;
        while (i != 0){&#13;
            bstr[k--] = byte(48 + i % 10);&#13;
            i /= 10;&#13;
        }&#13;
        return string(bstr);&#13;
    }&#13;
&#13;
    function stra2cbor(string[] arr) internal returns (bytes) {&#13;
            uint arrlen = arr.length;&#13;
&#13;
            // get correct cbor output length&#13;
            uint outputlen = 0;&#13;
            bytes[] memory elemArray = new bytes[](arrlen);&#13;
            for (uint i = 0; i &lt; arrlen; i++) {&#13;
                elemArray[i] = (bytes(arr[i]));&#13;
                outputlen += elemArray[i].length + (elemArray[i].length - 1)/23 + 3; //+3 accounts for paired identifier types&#13;
            }&#13;
            uint ctr = 0;&#13;
            uint cborlen = arrlen + 0x80;&#13;
            outputlen += byte(cborlen).length;&#13;
            bytes memory res = new bytes(outputlen);&#13;
&#13;
            while (byte(cborlen).length &gt; ctr) {&#13;
                res[ctr] = byte(cborlen)[ctr];&#13;
                ctr++;&#13;
            }&#13;
            for (i = 0; i &lt; arrlen; i++) {&#13;
                res[ctr] = 0x5F;&#13;
                ctr++;&#13;
                for (uint x = 0; x &lt; elemArray[i].length; x++) {&#13;
                    // if there's a bug with larger strings, this may be the culprit&#13;
                    if (x % 23 == 0) {&#13;
                        uint elemcborlen = elemArray[i].length - x &gt;= 24 ? 23 : elemArray[i].length - x;&#13;
                        elemcborlen += 0x40;&#13;
                        uint lctr = ctr;&#13;
                        while (byte(elemcborlen).length &gt; ctr - lctr) {&#13;
                            res[ctr] = byte(elemcborlen)[ctr - lctr];&#13;
                            ctr++;&#13;
                        }&#13;
                    }&#13;
                    res[ctr] = elemArray[i][x];&#13;
                    ctr++;&#13;
                }&#13;
                res[ctr] = 0xFF;&#13;
                ctr++;&#13;
            }&#13;
            return res;&#13;
        }&#13;
&#13;
    function ba2cbor(bytes[] arr) internal returns (bytes) {&#13;
            uint arrlen = arr.length;&#13;
&#13;
            // get correct cbor output length&#13;
            uint outputlen = 0;&#13;
            bytes[] memory elemArray = new bytes[](arrlen);&#13;
            for (uint i = 0; i &lt; arrlen; i++) {&#13;
                elemArray[i] = (bytes(arr[i]));&#13;
                outputlen += elemArray[i].length + (elemArray[i].length - 1)/23 + 3; //+3 accounts for paired identifier types&#13;
            }&#13;
            uint ctr = 0;&#13;
            uint cborlen = arrlen + 0x80;&#13;
            outputlen += byte(cborlen).length;&#13;
            bytes memory res = new bytes(outputlen);&#13;
&#13;
            while (byte(cborlen).length &gt; ctr) {&#13;
                res[ctr] = byte(cborlen)[ctr];&#13;
                ctr++;&#13;
            }&#13;
            for (i = 0; i &lt; arrlen; i++) {&#13;
                res[ctr] = 0x5F;&#13;
                ctr++;&#13;
                for (uint x = 0; x &lt; elemArray[i].length; x++) {&#13;
                    // if there's a bug with larger strings, this may be the culprit&#13;
                    if (x % 23 == 0) {&#13;
                        uint elemcborlen = elemArray[i].length - x &gt;= 24 ? 23 : elemArray[i].length - x;&#13;
                        elemcborlen += 0x40;&#13;
                        uint lctr = ctr;&#13;
                        while (byte(elemcborlen).length &gt; ctr - lctr) {&#13;
                            res[ctr] = byte(elemcborlen)[ctr - lctr];&#13;
                            ctr++;&#13;
                        }&#13;
                    }&#13;
                    res[ctr] = elemArray[i][x];&#13;
                    ctr++;&#13;
                }&#13;
                res[ctr] = 0xFF;&#13;
                ctr++;&#13;
            }&#13;
            return res;&#13;
        }&#13;
&#13;
&#13;
    string oraclize_network_name;&#13;
    function oraclize_setNetworkName(string _network_name) internal {&#13;
        oraclize_network_name = _network_name;&#13;
    }&#13;
&#13;
    function oraclize_getNetworkName() internal returns (string) {&#13;
        return oraclize_network_name;&#13;
    }&#13;
&#13;
    function oraclize_newRandomDSQuery(uint _delay, uint _nbytes, uint _customGasLimit) internal returns (bytes32){&#13;
        if ((_nbytes == 0)||(_nbytes &gt; 32)) throw;&#13;
	// Convert from seconds to ledger timer ticks&#13;
        _delay *= 10; &#13;
        bytes memory nbytes = new bytes(1);&#13;
        nbytes[0] = byte(_nbytes);&#13;
        bytes memory unonce = new bytes(32);&#13;
        bytes memory sessionKeyHash = new bytes(32);&#13;
        bytes32 sessionKeyHash_bytes32 = oraclize_randomDS_getSessionPubKeyHash();&#13;
        assembly {&#13;
            mstore(unonce, 0x20)&#13;
            mstore(add(unonce, 0x20), xor(blockhash(sub(number, 1)), xor(coinbase, timestamp)))&#13;
            mstore(sessionKeyHash, 0x20)&#13;
            mstore(add(sessionKeyHash, 0x20), sessionKeyHash_bytes32)&#13;
        }&#13;
        bytes memory delay = new bytes(32);&#13;
        assembly { &#13;
            mstore(add(delay, 0x20), _delay) &#13;
        }&#13;
        &#13;
        bytes memory delay_bytes8 = new bytes(8);&#13;
        copyBytes(delay, 24, 8, delay_bytes8, 0);&#13;
&#13;
        bytes[4] memory args = [unonce, nbytes, sessionKeyHash, delay];&#13;
        bytes32 queryId = oraclize_query("random", args, _customGasLimit);&#13;
        &#13;
        bytes memory delay_bytes8_left = new bytes(8);&#13;
        &#13;
        assembly {&#13;
            let x := mload(add(delay_bytes8, 0x20))&#13;
            mstore8(add(delay_bytes8_left, 0x27), div(x, 0x100000000000000000000000000000000000000000000000000000000000000))&#13;
            mstore8(add(delay_bytes8_left, 0x26), div(x, 0x1000000000000000000000000000000000000000000000000000000000000))&#13;
            mstore8(add(delay_bytes8_left, 0x25), div(x, 0x10000000000000000000000000000000000000000000000000000000000))&#13;
            mstore8(add(delay_bytes8_left, 0x24), div(x, 0x100000000000000000000000000000000000000000000000000000000))&#13;
            mstore8(add(delay_bytes8_left, 0x23), div(x, 0x1000000000000000000000000000000000000000000000000000000))&#13;
            mstore8(add(delay_bytes8_left, 0x22), div(x, 0x10000000000000000000000000000000000000000000000000000))&#13;
            mstore8(add(delay_bytes8_left, 0x21), div(x, 0x100000000000000000000000000000000000000000000000000))&#13;
            mstore8(add(delay_bytes8_left, 0x20), div(x, 0x1000000000000000000000000000000000000000000000000))&#13;
&#13;
        }&#13;
        &#13;
        oraclize_randomDS_setCommitment(queryId, sha3(delay_bytes8_left, args[1], sha256(args[0]), args[2]));&#13;
        return queryId;&#13;
    }&#13;
    &#13;
    function oraclize_randomDS_setCommitment(bytes32 queryId, bytes32 commitment) internal {&#13;
        oraclize_randomDS_args[queryId] = commitment;&#13;
    }&#13;
&#13;
    mapping(bytes32=&gt;bytes32) oraclize_randomDS_args;&#13;
    mapping(bytes32=&gt;bool) oraclize_randomDS_sessionKeysHashVerified;&#13;
&#13;
    function verifySig(bytes32 tosignh, bytes dersig, bytes pubkey) internal returns (bool){&#13;
        bool sigok;&#13;
        address signer;&#13;
&#13;
        bytes32 sigr;&#13;
        bytes32 sigs;&#13;
&#13;
        bytes memory sigr_ = new bytes(32);&#13;
        uint offset = 4+(uint(dersig[3]) - 0x20);&#13;
        sigr_ = copyBytes(dersig, offset, 32, sigr_, 0);&#13;
        bytes memory sigs_ = new bytes(32);&#13;
        offset += 32 + 2;&#13;
        sigs_ = copyBytes(dersig, offset+(uint(dersig[offset-1]) - 0x20), 32, sigs_, 0);&#13;
&#13;
        assembly {&#13;
            sigr := mload(add(sigr_, 32))&#13;
            sigs := mload(add(sigs_, 32))&#13;
        }&#13;
&#13;
&#13;
        (sigok, signer) = safer_ecrecover(tosignh, 27, sigr, sigs);&#13;
        if (address(sha3(pubkey)) == signer) return true;&#13;
        else {&#13;
            (sigok, signer) = safer_ecrecover(tosignh, 28, sigr, sigs);&#13;
            return (address(sha3(pubkey)) == signer);&#13;
        }&#13;
    }&#13;
&#13;
    function oraclize_randomDS_proofVerify__sessionKeyValidity(bytes proof, uint sig2offset) internal returns (bool) {&#13;
        bool sigok;&#13;
&#13;
        // Step 6: verify the attestation signature, APPKEY1 must sign the sessionKey from the correct ledger app (CODEHASH)&#13;
        bytes memory sig2 = new bytes(uint(proof[sig2offset+1])+2);&#13;
        copyBytes(proof, sig2offset, sig2.length, sig2, 0);&#13;
&#13;
        bytes memory appkey1_pubkey = new bytes(64);&#13;
        copyBytes(proof, 3+1, 64, appkey1_pubkey, 0);&#13;
&#13;
        bytes memory tosign2 = new bytes(1+65+32);&#13;
        tosign2[0] = 1; //role&#13;
        copyBytes(proof, sig2offset-65, 65, tosign2, 1);&#13;
        bytes memory CODEHASH = hex"fd94fa71bc0ba10d39d464d0d8f465efeef0a2764e3887fcc9df41ded20f505c";&#13;
        copyBytes(CODEHASH, 0, 32, tosign2, 1+65);&#13;
        sigok = verifySig(sha256(tosign2), sig2, appkey1_pubkey);&#13;
&#13;
        if (sigok == false) return false;&#13;
&#13;
&#13;
        // Step 7: verify the APPKEY1 provenance (must be signed by Ledger)&#13;
        bytes memory LEDGERKEY = hex"7fb956469c5c9b89840d55b43537e66a98dd4811ea0a27224272c2e5622911e8537a2f8e86a46baec82864e98dd01e9ccc2f8bc5dfc9cbe5a91a290498dd96e4";&#13;
&#13;
        bytes memory tosign3 = new bytes(1+65);&#13;
        tosign3[0] = 0xFE;&#13;
        copyBytes(proof, 3, 65, tosign3, 1);&#13;
&#13;
        bytes memory sig3 = new bytes(uint(proof[3+65+1])+2);&#13;
        copyBytes(proof, 3+65, sig3.length, sig3, 0);&#13;
&#13;
        sigok = verifySig(sha256(tosign3), sig3, LEDGERKEY);&#13;
&#13;
        return sigok;&#13;
    }&#13;
&#13;
    modifier oraclize_randomDS_proofVerify(bytes32 _queryId, string _result, bytes _proof) {&#13;
        // Step 1: the prefix has to match 'LP\x01' (Ledger Proof version 1)&#13;
        if ((_proof[0] != "L")||(_proof[1] != "P")||(_proof[2] != 1)) throw;&#13;
&#13;
        bool proofVerified = oraclize_randomDS_proofVerify__main(_proof, _queryId, bytes(_result), oraclize_getNetworkName());&#13;
        if (proofVerified == false) throw;&#13;
&#13;
        _;&#13;
    }&#13;
&#13;
    function oraclize_randomDS_proofVerify__returnCode(bytes32 _queryId, string _result, bytes _proof) internal returns (uint8){&#13;
        // Step 1: the prefix has to match 'LP\x01' (Ledger Proof version 1)&#13;
        if ((_proof[0] != "L")||(_proof[1] != "P")||(_proof[2] != 1)) return 1;&#13;
&#13;
        bool proofVerified = oraclize_randomDS_proofVerify__main(_proof, _queryId, bytes(_result), oraclize_getNetworkName());&#13;
        if (proofVerified == false) return 2;&#13;
&#13;
        return 0;&#13;
    }&#13;
&#13;
    function matchBytes32Prefix(bytes32 content, bytes prefix, uint n_random_bytes) internal returns (bool){&#13;
        bool match_ = true;&#13;
	&#13;
	if (prefix.length != n_random_bytes) throw;&#13;
	        &#13;
        for (uint256 i=0; i&lt; n_random_bytes; i++) {&#13;
            if (content[i] != prefix[i]) match_ = false;&#13;
        }&#13;
&#13;
        return match_;&#13;
    }&#13;
&#13;
    function oraclize_randomDS_proofVerify__main(bytes proof, bytes32 queryId, bytes result, string context_name) internal returns (bool){&#13;
&#13;
        // Step 2: the unique keyhash has to match with the sha256 of (context name + queryId)&#13;
        uint ledgerProofLength = 3+65+(uint(proof[3+65+1])+2)+32;&#13;
        bytes memory keyhash = new bytes(32);&#13;
        copyBytes(proof, ledgerProofLength, 32, keyhash, 0);&#13;
        if (!(sha3(keyhash) == sha3(sha256(context_name, queryId)))) return false;&#13;
&#13;
        bytes memory sig1 = new bytes(uint(proof[ledgerProofLength+(32+8+1+32)+1])+2);&#13;
        copyBytes(proof, ledgerProofLength+(32+8+1+32), sig1.length, sig1, 0);&#13;
&#13;
        // Step 3: we assume sig1 is valid (it will be verified during step 5) and we verify if 'result' is the prefix of sha256(sig1)&#13;
        if (!matchBytes32Prefix(sha256(sig1), result, uint(proof[ledgerProofLength+32+8]))) return false;&#13;
&#13;
        // Step 4: commitment match verification, sha3(delay, nbytes, unonce, sessionKeyHash) == commitment in storage.&#13;
        // This is to verify that the computed args match with the ones specified in the query.&#13;
        bytes memory commitmentSlice1 = new bytes(8+1+32);&#13;
        copyBytes(proof, ledgerProofLength+32, 8+1+32, commitmentSlice1, 0);&#13;
&#13;
        bytes memory sessionPubkey = new bytes(64);&#13;
        uint sig2offset = ledgerProofLength+32+(8+1+32)+sig1.length+65;&#13;
        copyBytes(proof, sig2offset-64, 64, sessionPubkey, 0);&#13;
&#13;
        bytes32 sessionPubkeyHash = sha256(sessionPubkey);&#13;
        if (oraclize_randomDS_args[queryId] == sha3(commitmentSlice1, sessionPubkeyHash)){ //unonce, nbytes and sessionKeyHash match&#13;
            delete oraclize_randomDS_args[queryId];&#13;
        } else return false;&#13;
&#13;
&#13;
        // Step 5: validity verification for sig1 (keyhash and args signed with the sessionKey)&#13;
        bytes memory tosign1 = new bytes(32+8+1+32);&#13;
        copyBytes(proof, ledgerProofLength, 32+8+1+32, tosign1, 0);&#13;
        if (!verifySig(sha256(tosign1), sig1, sessionPubkey)) return false;&#13;
&#13;
        // verify if sessionPubkeyHash was verified already, if not.. let's do it!&#13;
        if (oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash] == false){&#13;
            oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash] = oraclize_randomDS_proofVerify__sessionKeyValidity(proof, sig2offset);&#13;
        }&#13;
&#13;
        return oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash];&#13;
    }&#13;
&#13;
&#13;
    // the following function has been written by Alex Beregszaszi (@axic), use it under the terms of the MIT license&#13;
    function copyBytes(bytes from, uint fromOffset, uint length, bytes to, uint toOffset) internal returns (bytes) {&#13;
        uint minLength = length + toOffset;&#13;
&#13;
        if (to.length &lt; minLength) {&#13;
            // Buffer too small&#13;
            throw; // Should be a better way?&#13;
        }&#13;
&#13;
        // NOTE: the offset 32 is added to skip the `size` field of both bytes variables&#13;
        uint i = 32 + fromOffset;&#13;
        uint j = 32 + toOffset;&#13;
&#13;
        while (i &lt; (32 + fromOffset + length)) {&#13;
            assembly {&#13;
                let tmp := mload(add(from, i))&#13;
                mstore(add(to, j), tmp)&#13;
            }&#13;
            i += 32;&#13;
            j += 32;&#13;
        }&#13;
&#13;
        return to;&#13;
    }&#13;
&#13;
    // the following function has been written by Alex Beregszaszi (@axic), use it under the terms of the MIT license&#13;
    // Duplicate Solidity's ecrecover, but catching the CALL return value&#13;
    function safer_ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal returns (bool, address) {&#13;
        // We do our own memory management here. Solidity uses memory offset&#13;
        // 0x40 to store the current end of memory. We write past it (as&#13;
        // writes are memory extensions), but don't update the offset so&#13;
        // Solidity will reuse it. The memory used here is only needed for&#13;
        // this context.&#13;
&#13;
        // FIXME: inline assembly can't access return values&#13;
        bool ret;&#13;
        address addr;&#13;
&#13;
        assembly {&#13;
            let size := mload(0x40)&#13;
            mstore(size, hash)&#13;
            mstore(add(size, 32), v)&#13;
            mstore(add(size, 64), r)&#13;
            mstore(add(size, 96), s)&#13;
&#13;
            // NOTE: we can reuse the request memory because we deal with&#13;
            //       the return code&#13;
            ret := call(3000, 1, 0, size, 128, size, 32)&#13;
            addr := mload(size)&#13;
        }&#13;
&#13;
        return (ret, addr);&#13;
    }&#13;
&#13;
    // the following function has been written by Alex Beregszaszi (@axic), use it under the terms of the MIT license&#13;
    function ecrecovery(bytes32 hash, bytes sig) internal returns (bool, address) {&#13;
        bytes32 r;&#13;
        bytes32 s;&#13;
        uint8 v;&#13;
&#13;
        if (sig.length != 65)&#13;
          return (false, 0);&#13;
&#13;
        // The signature format is a compact form of:&#13;
        //   {bytes32 r}{bytes32 s}{uint8 v}&#13;
        // Compact means, uint8 is not padded to 32 bytes.&#13;
        assembly {&#13;
            r := mload(add(sig, 32))&#13;
            s := mload(add(sig, 64))&#13;
&#13;
            // Here we are loading the last 32 bytes. We exploit the fact that&#13;
            // 'mload' will pad with zeroes if we overread.&#13;
            // There is no 'mload8' to do this, but that would be nicer.&#13;
            v := byte(0, mload(add(sig, 96)))&#13;
&#13;
            // Alternative solution:&#13;
            // 'byte' is not working due to the Solidity parser, so lets&#13;
            // use the second best option, 'and'&#13;
            // v := and(mload(add(sig, 65)), 255)&#13;
        }&#13;
&#13;
        // albeit non-transactional signatures are not specified by the YP, one would expect it&#13;
        // to match the YP range of [27, 28]&#13;
        //&#13;
        // geth uses [0, 1] and some clients have followed. This might change, see:&#13;
        //  https://github.com/ethereum/go-ethereum/issues/2053&#13;
        if (v &lt; 27)&#13;
          v += 27;&#13;
&#13;
        if (v != 27 &amp;&amp; v != 28)&#13;
            return (false, 0);&#13;
&#13;
        return safer_ecrecover(hash, v, r, s);&#13;
    }&#13;
&#13;
}&#13;
// &lt;/ORACLIZE_API&gt;&#13;
&#13;
contract FreeLOTInterface {&#13;
    function balanceOf(address who) constant public returns (uint) {}&#13;
    function destroy(address _from, uint _amt) external {}&#13;
}&#13;
&#13;
contract EtheraffleUpgrade {&#13;
    function addToPrizePool() payable external {}&#13;
}&#13;
&#13;
contract ReceiverInterface {&#13;
    function receiveEther() external payable {}&#13;
}&#13;
&#13;
contract Etheraffle is EtheraffleUpgrade, FreeLOTInterface, ReceiverInterface, usingOraclize {&#13;
    using strings for *;&#13;
&#13;
    uint    public week;&#13;
    bool    public paused;&#13;
    uint    public upgraded;&#13;
    uint    public prizePool;&#13;
    address public ethRelief;&#13;
    address public etheraffle;&#13;
    address public upgradeAddr;&#13;
    address public disburseAddr;&#13;
    uint    public take         = 150;//ppt&#13;
    uint    public gasAmt       = 500000;&#13;
    uint    public gasPrc       = 20000000000;//20 gwei&#13;
    uint    public rafEnd       = 500400;//7:00pm Saturdays&#13;
    uint    public tktPrice     = 2000000000000000;&#13;
    uint    public oracCost     = 1500000000000000;//$1 @ $700&#13;
    uint    public wdrawBfr     = 6048000;&#13;
    uint[]  public pctOfPool    = [520, 114, 47, 319];//ppt...&#13;
    uint    public resultsDelay = 3600;&#13;
    uint    public matchesDelay = 3600;&#13;
    uint  constant weekDur      = 604800;&#13;
    uint  constant birthday     = 1500249600;//Etheraffle's birthday &lt;3&#13;
&#13;
    FreeLOTInterface freeLOT;&#13;
&#13;
    string randomStr1 = "[URL] ['json(https://api.random.org/json-rpc/1/invoke).result.random[\"data\", \"serialNumber\"]','\\n{\"jsonrpc\": \"2.0\",\"method\":\"generateSignedIntegers\",\"id\":\"";&#13;
    string randomStr2 = "\",\"params\":{\"n\":\"6\",\"min\":1,\"max\":49,\"replacement\":false,\"base\":10,\"apiKey\":${[decrypt] BOxU9jP2laZmGPe29WvCh5HY57objD14TTuYv1Y1p7M43mHS8rDupPiIjIq8DNPGm4A8OtbBmBxUZant/WqG0eGgfzb5STSsb44VzOIRrSk2A8r10SxTE5Ysl2HahYHZO18LZmWYCnqjVJ7UTmCBxwRpb5OVIVcp9A==}}']";&#13;
    string apiStr1 = "[URL] ['json(https://etheraffle.com/api/a).m','{\"r\":\"";&#13;
    string apiStr2 = "\",\"k\":${[decrypt] BLQNU9ZQxS6ardpB9gmUfVKwKhxSF2MmyB7sh2gmQFH49VewFs52EgaYId5KVEkYuNCP0S2ppzDmiN/5JUzHGTPpkPuTAZdx/ydBCcRMcuuqxg4lSpvtG3oB6zvXfTcCVjGMPbep}}']";&#13;
&#13;
    mapping (uint =&gt; rafStruct) public raffle;&#13;
    struct rafStruct {&#13;
        mapping (address =&gt; uint[][]) entries;&#13;
        uint unclaimed;&#13;
        uint[] winNums;&#13;
        uint[] winAmts;&#13;
        uint timeStamp;&#13;
        bool wdrawOpen;&#13;
        uint numEntries;&#13;
        uint freeEntries;&#13;
    }&#13;
&#13;
    mapping (bytes32 =&gt; qIDStruct) public qID;&#13;
    struct qIDStruct {&#13;
        uint weekNo;&#13;
        bool isRandom;&#13;
        bool isManual;&#13;
    }&#13;
    /**&#13;
    * @dev  Modifier to prepend to functions adding the additional&#13;
    *       conditional requiring caller of the method to be the&#13;
    *       etheraffle address.&#13;
    */&#13;
    modifier onlyEtheraffle() {&#13;
        require(msg.sender == etheraffle);&#13;
        _;&#13;
    }&#13;
    /**&#13;
    * @dev  Modifier to prepend to functions adding the additional&#13;
    *       conditional requiring the paused bool to be false.&#13;
    */&#13;
    modifier onlyIfNotPaused() {&#13;
        require(!paused);&#13;
        _;&#13;
    }&#13;
    event LogFunctionsPaused(uint identifier, uint atTime);&#13;
    event LogQuerySent(bytes32 queryID, uint dueAt, uint sendTime);&#13;
    event LogReclaim(uint indexed fromRaffle, uint amount, uint atTime);&#13;
    event LogUpgrade(address newContract, uint ethTransferred, uint atTime);&#13;
    event LogPrizePoolAddition(address fromWhom, uint howMuch, uint atTime);&#13;
    event LogOraclizeCallback(bytes32 queryID, string result, uint indexed forRaffle, uint atTime);&#13;
    event LogFundsDisbursed(uint indexed forRaffle, uint oraclizeTotal, uint amount, address indexed toAddress, uint atTime);&#13;
    event LogWithdraw(uint indexed forRaffle, address indexed toWhom, uint forEntryNumber, uint matches, uint amountWon, uint atTime);&#13;
    event LogWinningNumbers(uint indexed forRaffle, uint numberOfEntries, uint[] wNumbers, uint currentPrizePool, uint randomSerialNo, uint atTime);&#13;
    event LogTicketBought(uint indexed forRaffle, uint indexed entryNumber, address indexed theEntrant, uint[] chosenNumbers, uint personalEntryNumber, uint tktCost, uint atTime, uint affiliateID);&#13;
    event LogPrizePoolsUpdated(uint newMainPrizePool, uint indexed forRaffle, uint unclaimedPrizePool, uint threeMatchWinAmt, uint fourMatchWinAmt, uint fiveMatchWinAmt, uint sixMatchwinAmt, uint atTime);&#13;
    /**&#13;
     * @dev   Constructor - sets the Etheraffle contract address &amp;&#13;
     *        the disbursal contract address for investors, calls&#13;
     *        the newRaffle() function with sets the current&#13;
     *        raffle ID global var plus sets up the first raffle's&#13;
     *        struct with correct time stamp. Sets the withdraw&#13;
     *        before time to a ten week period, and prepares the&#13;
     *        initial oraclize call which will begin the recursive&#13;
     *        function.&#13;
     *&#13;
     * @param _freeLOT    The address of the Etheraffle FreeLOT special token.&#13;
     * @param _dsbrs      The address of the Etheraffle disbursal contract.&#13;
     * @param _msig       The address of the Etheraffle managerial multisig wallet.&#13;
     * @param _ethRelief  The address of the EthRelief charity contract.&#13;
     */&#13;
    function Etheraffle(address _freeLOT, address _dsbrs, address _msig, address _ethRelief) payable {&#13;
        week         = getWeek();&#13;
        etheraffle   = _msig;&#13;
        disburseAddr = _dsbrs;&#13;
        ethRelief    = _ethRelief;&#13;
        freeLOT      = FreeLOTInterface(_freeLOT);&#13;
        uint delay   = (week * weekDur) + birthday + rafEnd + resultsDelay;&#13;
        raffle[week].timeStamp = (week * weekDur) + birthday;&#13;
        bytes32 query = oraclize_query(delay, "nested", strConcat(randomStr1, uint2str(getWeek()), randomStr2), gasAmt);&#13;
        qID[query].weekNo = week;&#13;
        qID[query].isRandom = true;&#13;
        LogQuerySent(query, delay, now);&#13;
    }&#13;
    /**&#13;
     * @dev   Function using Etheraffle's birthday to calculate the&#13;
     *        week number since then.&#13;
     */&#13;
    function getWeek() public constant returns (uint) {&#13;
        uint curWeek = (now - birthday) / weekDur;&#13;
        if (now - ((curWeek * weekDur) + birthday) &gt; rafEnd) {&#13;
            curWeek++;&#13;
        }&#13;
        return curWeek;&#13;
    }&#13;
    /**&#13;
     * @dev   Function which gets current week number and if different&#13;
     *        from the global var week number, it updates that and sets&#13;
     *        up the new raffle struct. Should only be called once a&#13;
     *        week after the raffle is closed. Should it get called&#13;
     *        sooner, the contract is paused for inspection.&#13;
     */&#13;
    function newRaffle() internal {&#13;
        uint newWeek = getWeek();&#13;
        if(newWeek == week) {&#13;
            pauseContract(4);&#13;
            return;&#13;
        } else {//â´ new raffle...&#13;
            week = newWeek;&#13;
            raffle[newWeek].timeStamp = birthday + (newWeek * weekDur);&#13;
        }&#13;
    }&#13;
    /**&#13;
     * @dev  To pause the contract's functions should the need arise. Internal.&#13;
     *       Logs an event of the pausing.&#13;
     *&#13;
     * @param _id    A uint to identify the caller of this function.&#13;
     */&#13;
    function pauseContract(uint _id) internal {&#13;
      paused = true;&#13;
      LogFunctionsPaused(_id, now);&#13;
    }&#13;
    /**&#13;
     * @dev  Function to enter the raffle. Requires the caller to send ether&#13;
     *       of amount greater than or equal to the ticket price.&#13;
     *&#13;
     * @param _cNums    Ordered array of entrant's six selected numbers.&#13;
     * @param _affID    Affiliate ID of the source of this entry.&#13;
     */&#13;
    function enterRaffle(uint[] _cNums, uint _affID) payable external onlyIfNotPaused {&#13;
        require(msg.value &gt;= tktPrice);&#13;
        buyTicket(_cNums, msg.sender, msg.value, _affID);&#13;
    }&#13;
    /**&#13;
     * @dev  Function to enter the raffle for free. Requires the caller's&#13;
     *       balance of the Etheraffle freeLOT token to be greater than&#13;
     *       zero. Function destroys one freeLOT token, increments the&#13;
     *       freeEntries variable in the raffle struct then purchases the&#13;
     *       ticket.&#13;
     *&#13;
     * @param _cNums    Ordered array of entrant's six selected numbers.&#13;
     * @param _affID    Affiliate ID of the source of this entry.&#13;
     */&#13;
    function enterFreeRaffle(uint[] _cNums, uint _affID) payable external onlyIfNotPaused {&#13;
        freeLOT.destroy(msg.sender, 1);&#13;
        raffle[week].freeEntries++;&#13;
        buyTicket(_cNums, msg.sender, msg.value, _affID);&#13;
    }&#13;
    /**&#13;
     * @dev   Function to buy tickets. Internal. Requires the entry number&#13;
     *        array to be of length 6, requires the timestamp of the current&#13;
     *        raffle struct to have been set, and for this time this function&#13;
     *        is call to be before the end of the raffle. Then requires that&#13;
     *        the chosen numbers are ordered lowest to highest &amp; bound between&#13;
     *        1 and 49. Function increments the total number of entries in the&#13;
     *        current raffle's struct, increments the prize pool accordingly&#13;
     *        and pushes the chosen number array into the entries map and then&#13;
     *        logs the ticket purchase.&#13;
     *&#13;
     * @param _cNums       Array of users selected numbers.&#13;
     * @param _entrant     Entrant's ethereum address.&#13;
     * @param _value       The ticket purchase price.&#13;
     * @param _affID       The affiliate ID of the source of this entry.&#13;
     */&#13;
    function buyTicket&#13;
    (&#13;
        uint[]  _cNums,&#13;
        address _entrant,&#13;
        uint    _value,&#13;
        uint    _affID&#13;
    )&#13;
        internal&#13;
    {&#13;
        require&#13;
        (&#13;
            _cNums.length == 6 &amp;&amp;&#13;
            raffle[week].timeStamp &gt; 0 &amp;&amp;&#13;
            now &lt; raffle[week].timeStamp + rafEnd &amp;&amp;&#13;
            0         &lt; _cNums[0] &amp;&amp;&#13;
            _cNums[0] &lt; _cNums[1] &amp;&amp;&#13;
            _cNums[1] &lt; _cNums[2] &amp;&amp;&#13;
            _cNums[2] &lt; _cNums[3] &amp;&amp;&#13;
            _cNums[3] &lt; _cNums[4] &amp;&amp;&#13;
            _cNums[4] &lt; _cNums[5] &amp;&amp;&#13;
            _cNums[5] &lt;= 49&#13;
        );&#13;
        raffle[week].numEntries++;&#13;
        prizePool += _value;&#13;
        raffle[week].entries[_entrant].push(_cNums);&#13;
        LogTicketBought(week, raffle[week].numEntries, _entrant, _cNums, raffle[week].entries[_entrant].length, _value, now, _affID);&#13;
    }&#13;
    /**&#13;
     * @dev Withdraw Winnings function. User calls this function in order to withdraw&#13;
     *      whatever winnings they are owed. Function can be paused via the modifier&#13;
     *      function "onlyIfNotPaused"&#13;
     *&#13;
     * @param _week        Week number of the raffle the winning entry is from&#13;
     * @param _entryNum    The entrants entry number into this raffle&#13;
     */&#13;
    function withdrawWinnings(uint _week, uint _entryNum) onlyIfNotPaused external {&#13;
        require&#13;
        (&#13;
            raffle[_week].timeStamp &gt; 0 &amp;&amp;&#13;
            now - raffle[_week].timeStamp &gt; weekDur - (weekDur / 7) &amp;&amp;&#13;
            now - raffle[_week].timeStamp &lt; wdrawBfr &amp;&amp;&#13;
            raffle[_week].wdrawOpen == true &amp;&amp;&#13;
            raffle[_week].entries[msg.sender][_entryNum - 1].length == 6&#13;
        );&#13;
        uint matches = getMatches(_week, msg.sender, _entryNum);&#13;
        require&#13;
        (&#13;
            matches &gt;= 3 &amp;&amp;&#13;
            raffle[_week].winAmts[matches - 3] &gt; 0 &amp;&amp;&#13;
            raffle[_week].winAmts[matches - 3] &lt;= this.balance&#13;
        );&#13;
        raffle[_week].entries[msg.sender][_entryNum - 1].push(0);&#13;
        if(raffle[_week].winAmts[matches - 3] &lt;= raffle[_week].unclaimed) {&#13;
            raffle[_week].unclaimed -= raffle[_week].winAmts[matches - 3];&#13;
        } else {&#13;
            raffle[_week].unclaimed = 0;&#13;
            pauseContract(5);&#13;
        }&#13;
        msg.sender.transfer(raffle[_week].winAmts[matches - 3]);&#13;
        LogWithdraw(_week, msg.sender, _entryNum, matches, raffle[_week].winAmts[matches - 3], now);&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev    Called by the weekly oraclize callback. Checks raffle 10&#13;
     *         weeks older than current raffle for any unclaimed prize&#13;
     *         pool. If any found, returns it to the main prizePool and&#13;
     *         zeros the amount.&#13;
     */&#13;
    function reclaimUnclaimed() internal {&#13;
        uint old = getWeek() - 11;&#13;
        prizePool += raffle[old].unclaimed;&#13;
        LogReclaim(old, raffle[old].unclaimed, now);&#13;
    }&#13;
    /**&#13;
     * @dev  Function totals up oraclize cost for the raffle, subtracts&#13;
     *       it from the prizepool (if less than, if greater than if&#13;
     *       pauses the contract and fires an event). Calculates profit&#13;
     *       based on raffle's tickets sales and the take percentage,&#13;
     *       then forwards that amount of ether to the disbursal contract.&#13;
     *&#13;
     * @param _week   The week number of the raffle in question.&#13;
     */&#13;
    function disburseFunds(uint _week) internal {&#13;
        uint oracTot = 2 * ((gasAmt * gasPrc) + oracCost);//2 queries per draw...&#13;
        if(oracTot &gt; prizePool) {&#13;
          pauseContract(1);&#13;
          return;&#13;
        }&#13;
        prizePool -= oracTot;&#13;
        uint profit;&#13;
        if(raffle[_week].numEntries &gt; 0) {&#13;
            profit = ((raffle[_week].numEntries - raffle[_week].freeEntries) * tktPrice * take) / 1000;&#13;
            prizePool -= profit;&#13;
            uint half = profit / 2;&#13;
            ReceiverInterface(disburseAddr).receiveEther.value(half)();&#13;
            ReceiverInterface(ethRelief).receiveEther.value(profit - half)();&#13;
            LogFundsDisbursed(_week, oracTot, profit - half, ethRelief, now);&#13;
            LogFundsDisbursed(_week, oracTot, half, disburseAddr, now);&#13;
            return;&#13;
        }&#13;
        LogFundsDisbursed(_week, oracTot, profit, 0, now);&#13;
        return;&#13;
    }&#13;
    /**&#13;
     * @dev   The Oralize call back function. The oracalize api calls are&#13;
     *        recursive. One to random.org for the draw and the other to&#13;
     *        the Etheraffle api for the numbers of matches each entry made&#13;
     *        against the winning numbers. Each calls the other recursively.&#13;
     *        The former when calledback closes and reclaims any unclaimed&#13;
     *        prizepool from the raffle ten weeks previous to now. Then it&#13;
     *        disburses profit to the disbursal contract, then it sets the&#13;
     *        winning numbers received from random.org into the raffle&#13;
     *        struct. Finally it prepares the next oraclize call. Which&#13;
     *        latter callback first sets up the new raffle struct, then&#13;
     *        sets the payouts based on the number of winners in each tier&#13;
     *        returned from the api call, then prepares the next oraclize&#13;
     *        query for a week later to draw the next raffle's winning&#13;
     *        numbers.&#13;
     *&#13;
     * @param _myID     bytes32 - Unique id oraclize provides with their&#13;
     *                            callbacks.&#13;
     * @param _result   string - The result of the api call.&#13;
     */&#13;
    function __callback(bytes32 _myID, string _result) onlyIfNotPaused {&#13;
        require(msg.sender == oraclize_cbAddress());&#13;
        LogOraclizeCallback(_myID, _result, qID[_myID].weekNo, now);&#13;
        if(qID[_myID].isRandom == true){//is random callback...&#13;
            reclaimUnclaimed();&#13;
            disburseFunds(qID[_myID].weekNo);&#13;
            setWinningNumbers(qID[_myID].weekNo, _result);&#13;
            if(qID[_myID].isManual == true) { return; }&#13;
            bytes32 query = oraclize_query(matchesDelay, "nested", strConcat(apiStr1, uint2str(qID[_myID].weekNo), apiStr2), gasAmt);&#13;
            qID[query].weekNo = qID[_myID].weekNo;&#13;
            LogQuerySent(query, matchesDelay + now, now);&#13;
        } else {//is api callback&#13;
            newRaffle();&#13;
            setPayOuts(qID[_myID].weekNo, _result);&#13;
            if(qID[_myID].isManual == true) { return; }&#13;
            uint delay = (getWeek() * weekDur) + birthday + rafEnd + resultsDelay;&#13;
            query = oraclize_query(delay, "nested", strConcat(randomStr1, uint2str(getWeek()), randomStr2), gasAmt);&#13;
            qID[query].weekNo = getWeek();&#13;
            qID[query].isRandom = true;&#13;
            LogQuerySent(query, delay, now);&#13;
        }&#13;
    }&#13;
    /**&#13;
     * @dev   Slices a string according to specified delimiter, returning&#13;
     *        the sliced parts in an array.&#13;
     *&#13;
     * @param _string   The string to be sliced.&#13;
     */&#13;
    function stringToArray(string _string) internal returns (string[]) {&#13;
        var str    = _string.toSlice();&#13;
        var delim  = ",".toSlice();&#13;
        var parts  = new string[](str.count(delim) + 1);&#13;
        for(uint i = 0; i &lt; parts.length; i++) {&#13;
            parts[i] = str.split(delim).toString();&#13;
        }&#13;
        return parts;&#13;
    }&#13;
    /**&#13;
     * @dev   Takes oraclize random.org api call result string and splits&#13;
     *        it at the commas into an array, parses those strings in that&#13;
     *        array as integers and pushes them into the winning numbers&#13;
     *        array in the raffle's struct. Fires event logging the data,&#13;
     *        including the serial number of the random.org callback so&#13;
     *        its veracity can be proven.&#13;
     *&#13;
     * @param _week    The week number of the raffle in question.&#13;
     * @param _result   The results string from oraclize callback.&#13;
     */&#13;
    function setWinningNumbers(uint _week, string _result) internal {&#13;
        string[] memory arr = stringToArray(_result);&#13;
        for(uint i = 0; i &lt; arr.length; i++){&#13;
            raffle[_week].winNums.push(parseInt(arr[i]));&#13;
        }&#13;
        uint serialNo = parseInt(arr[6]);&#13;
        LogWinningNumbers(_week, raffle[_week].numEntries, raffle[_week].winNums, prizePool, serialNo, now);&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev   Takes the results of the oraclize Etheraffle api call back&#13;
     *        and uses them to calculate the prizes due to each tier&#13;
     *        (3 matches, 4 matches etc) then pushes them into the winning&#13;
     *        amounts array in the raffle in question's struct. Calculates&#13;
     *        the total winnings of the raffle, subtracts it from the&#13;
     *        global prize pool sequesters that amount into the raffle's&#13;
     *        struct "unclaimed" variable, â´ "rolling over" the unwon&#13;
     *        ether. Enables winner withdrawals by setting the withdraw&#13;
     *        open bool to true.&#13;
     *&#13;
     * @param _week    The week number of the raffle in question.&#13;
     * @param _result  The results string from oraclize callback.&#13;
     */&#13;
    function setPayOuts(uint _week, string _result) internal {&#13;
        string[] memory numWinnersStr = stringToArray(_result);&#13;
        if(numWinnersStr.length &lt; 4) {&#13;
          pauseContract(2);&#13;
          return;&#13;
        }&#13;
        uint[] memory numWinnersInt = new uint[](4);&#13;
        for (uint i = 0; i &lt; 4; i++) {&#13;
            numWinnersInt[i] = parseInt(numWinnersStr[i]);&#13;
        }&#13;
        uint[] memory payOuts = new uint[](4);&#13;
        uint total;&#13;
        for(i = 0; i &lt; 4; i++) {&#13;
            if(numWinnersInt[i] != 0) {&#13;
                payOuts[i] = (prizePool * pctOfPool[i]) / (numWinnersInt[i] * 1000);&#13;
                total += payOuts[i] * numWinnersInt[i];&#13;
            }&#13;
        }&#13;
        raffle[_week].unclaimed = total;&#13;
        if(raffle[_week].unclaimed &gt; prizePool) {&#13;
          pauseContract(3);&#13;
          return;&#13;
        }&#13;
        prizePool -= raffle[_week].unclaimed;&#13;
        for(i = 0; i &lt; payOuts.length; i++) {&#13;
            raffle[_week].winAmts.push(payOuts[i]);&#13;
        }&#13;
        raffle[_week].wdrawOpen = true;&#13;
        LogPrizePoolsUpdated(prizePool, _week, raffle[_week].unclaimed, payOuts[0], payOuts[1], payOuts[2], payOuts[3], now);&#13;
    }&#13;
    /**&#13;
     * @dev   Function compares array of entrant's 6 chosen numbers to&#13;
      *       the raffle in question's winning numbers, counting how&#13;
      *       many matches there are.&#13;
      *&#13;
      * @param _week         The week number of the Raffle in question&#13;
      * @param _entrant      Entrant's ethereum address&#13;
      * @param _entryNum     number of entrant's entry in question.&#13;
     */&#13;
    function getMatches(uint _week, address _entrant, uint _entryNum) constant internal returns (uint) {&#13;
        uint matches;&#13;
        for(uint i = 0; i &lt; 6; i++) {&#13;
            for(uint j = 0; j &lt; 6; j++) {&#13;
                if(raffle[_week].entries[_entrant][_entryNum - 1][i] == raffle[_week].winNums[j]) {&#13;
                    matches++;&#13;
                    break;&#13;
                }&#13;
            }&#13;
        }&#13;
        return matches;&#13;
    }&#13;
    /**&#13;
     * @dev     Manually make an Oraclize API call, incase of automation&#13;
     *          failure. Only callable by the Etheraffle address.&#13;
     *&#13;
     * @param _delay      Either a time in seconds before desired callback&#13;
     *                    time for the API call, or a future UTC format time for&#13;
     *                    the desired time for the API callback.&#13;
     * @param _week       The week number this query is for.&#13;
     * @param _isRandom   Whether or not the api call being made is for&#13;
     *                    the random.org results draw, or for the Etheraffle&#13;
     *                    API results call.&#13;
     * @param _isManual   The Oraclize call back is a recursive function in&#13;
     *                    which each call fires off another call in perpetuity.&#13;
     *                    This bool allows that recursiveness for this call to be&#13;
     *                    turned on or off depending on caller's requirements.&#13;
     */&#13;
    function manuallyMakeOraclizeCall&#13;
    (&#13;
        uint _week,&#13;
        uint _delay,&#13;
        bool _isRandom,&#13;
        bool _isManual&#13;
    )&#13;
        onlyEtheraffle external&#13;
    {&#13;
        string memory weekNumStr = uint2str(_week);&#13;
        if(_isRandom == true){&#13;
            bytes32 query = oraclize_query(_delay, "nested", strConcat(randomStr1, weekNumStr, randomStr2), gasAmt);&#13;
            qID[query].weekNo   = _week;&#13;
            qID[query].isRandom = true;&#13;
            qID[query].isManual = _isManual;&#13;
        } else {&#13;
            query = oraclize_query(_delay, "nested", strConcat(apiStr1, weekNumStr, apiStr2), gasAmt);&#13;
            qID[query].weekNo   = _week;&#13;
            qID[query].isManual = _isManual;&#13;
        }&#13;
    }&#13;
    /**&#13;
     * @dev Set the gas relevant price parameters for the Oraclize calls, in case&#13;
     *      of future needs for higher gas prices for adequate transaction times,&#13;
     *      or incase of Oraclize price hikes. Only callable be the Etheraffle&#13;
     *      address.&#13;
     *&#13;
     * @param _newAmt    uint - new allowed gas amount for Oraclize.&#13;
     * @param _newPrice  uint - new gas price for Oraclize.&#13;
     * @param _newCost   uint - new cose of Oraclize service.&#13;
     *&#13;
     */&#13;
    function setGasForOraclize&#13;
    (&#13;
        uint _newAmt,&#13;
        uint _newCost,&#13;
        uint _newPrice&#13;
    )&#13;
        onlyEtheraffle external&#13;
    {&#13;
        gasAmt   = _newAmt;&#13;
        oracCost = _newCost;&#13;
        if(_newPrice &gt; 0) {&#13;
            oraclize_setCustomGasPrice(_newPrice);&#13;
            gasPrc = _newPrice;&#13;
        }&#13;
    }&#13;
    /**&#13;
     * @dev    Set the Oraclize strings, in case of url changes. Only callable by&#13;
     *         the Etheraffle address  .&#13;
     *&#13;
     * @param _newRandomHalfOne       string - with properly escaped characters for&#13;
     *                                the first half of the random.org call string.&#13;
     * @param _newRandomHalfTwo       string - with properly escaped characters for&#13;
     *                                the second half of the random.org call string.&#13;
     * @param _newEtheraffleHalfOne   string - with properly escaped characters for&#13;
     *                                the first half of the EtheraffleAPI call string.&#13;
     * @param _newEtheraffleHalfTwo   string - with properly escaped characters for&#13;
     *                                the second half of the EtheraffleAPI call string.&#13;
     *&#13;
     */&#13;
    function setOraclizeString&#13;
    (&#13;
        string _newRandomHalfOne,&#13;
        string _newRandomHalfTwo,&#13;
        string _newEtheraffleHalfOne,&#13;
        string _newEtheraffleHalfTwo&#13;
    )&#13;
        onlyEtheraffle external&#13;
    {&#13;
        randomStr1 = _newRandomHalfOne;&#13;
        randomStr2 = _newRandomHalfTwo;&#13;
        apiStr1    = _newEtheraffleHalfOne;&#13;
        apiStr2    = _newEtheraffleHalfTwo;&#13;
    }&#13;
    /**&#13;
     * @dev   Set the ticket price of the raffle. Only callable by the&#13;
     *        Etheraffle address.&#13;
     *&#13;
     * @param _newPrice   uint - The desired new ticket price.&#13;
     *&#13;
     */&#13;
    function setTktPrice(uint _newPrice) onlyEtheraffle external {&#13;
        tktPrice = _newPrice;&#13;
    }&#13;
    /**&#13;
     * @dev    Set new take percentage. Only callable by the Etheraffle&#13;
     *         address.&#13;
     *&#13;
     * @param _newTake   uint - The desired new take, parts per thousand.&#13;
     *&#13;
     */&#13;
    function setTake(uint _newTake) onlyEtheraffle external {&#13;
        take = _newTake;&#13;
    }&#13;
    /**&#13;
     * @dev     Set the payouts manually, in case of a failed Oraclize call.&#13;
     *          Only callable by the Etheraffle address.&#13;
     *&#13;
     * @param _week         The week number of the raffle to set the payouts for.&#13;
     * @param _numMatches   Number of matches. Comma-separated STRING of 4&#13;
     *                      integers long, consisting of the number of 3 match&#13;
     *                      winners, 4 match winners, 5 &amp; 6 match winners in&#13;
     *                      that order.&#13;
     */&#13;
    function setPayouts(uint _week, string _numMatches) onlyEtheraffle external {&#13;
        setPayOuts(_week, _numMatches);&#13;
    }&#13;
    /**&#13;
     * @dev   Set the FreeLOT token contract address, in case of future updrades.&#13;
     *        Only allable by the Etheraffle address.&#13;
     *&#13;
     * @param _newAddr   New address of FreeLOT contract.&#13;
     */&#13;
    function setFreeLOT(address _newAddr) onlyEtheraffle external {&#13;
        freeLOT = FreeLOTInterface(_newAddr);&#13;
      }&#13;
    /**&#13;
     * @dev   Set the EthRelief contract address, and gas required to run&#13;
     *        the receiving function. Only allable by the Etheraffle address.&#13;
     *&#13;
     * @param _newAddr   New address of the EthRelief contract.&#13;
     */&#13;
    function setEthRelief(address _newAddr) onlyEtheraffle external {&#13;
        ethRelief = _newAddr;&#13;
    }&#13;
    /**&#13;
     * @dev   Set the dividend contract address, and gas required to run&#13;
     *        the receive ether function. Only callable by the Etheraffle&#13;
     *        address.&#13;
     *&#13;
     * @param _newAddr   New address of dividend contract.&#13;
     */&#13;
    function setDisbursingAddr(address _newAddr) onlyEtheraffle external {&#13;
        disburseAddr = _newAddr;&#13;
    }&#13;
    /**&#13;
     * @dev   Set the Etheraffle multisig contract address, in case of future&#13;
     *        upgrades. Only callable by the current Etheraffle address.&#13;
     *&#13;
     * @param _newAddr   New address of Etheraffle multisig contract.&#13;
     */&#13;
    function setEtheraffle(address _newAddr) onlyEtheraffle external {&#13;
        etheraffle = _newAddr;&#13;
    }&#13;
    /**&#13;
     * @dev     Set the raffle end time, in number of seconds passed&#13;
     *          the start time of 00:00am Monday. Only callable by&#13;
     *          the Etheraffle address.&#13;
     *&#13;
     * @param _newTime    The time desired in seconds.&#13;
     */&#13;
    function setRafEnd(uint _newTime) onlyEtheraffle external {&#13;
        rafEnd = _newTime;&#13;
    }&#13;
    /**&#13;
     * @dev     Set the wdrawBfr time - the time a winner has to withdraw&#13;
     *          their winnings before the unclaimed prizepool is rolled&#13;
     *          back into the global prizepool. Only callable by the&#13;
     *          Etheraffle address.&#13;
     *&#13;
     * @param _newTime    The time desired in seconds.&#13;
     */&#13;
    function setWithdrawBeforeTime(uint _newTime) onlyEtheraffle external {&#13;
        wdrawBfr = _newTime;&#13;
    }&#13;
    /**&#13;
     * @dev     Set the paused status of the raffles. Only callable by&#13;
     *          the Etheraffle address.&#13;
     *&#13;
     * @param _status    The desired status of the raffles.&#13;
     */&#13;
    function setPaused(bool _status) onlyEtheraffle external {&#13;
        paused = _status;&#13;
    }&#13;
    /**&#13;
     * @dev     Set the percentage-of-prizepool array. Only callable by the&#13;
     *          Etheraffle address.&#13;
     *&#13;
     * @param _newPoP     An array of four integers totalling 1000.&#13;
     */&#13;
    function setPercentOfPool(uint[] _newPoP) onlyEtheraffle external {&#13;
        pctOfPool = _newPoP;&#13;
    }&#13;
    /**&#13;
     * @dev     Get a entrant's number of entries into a specific raffle&#13;
     *&#13;
     * @param _week       The week number of the queried raffle.&#13;
     * @param _entrant    The entrant in question.&#13;
     */&#13;
    function getUserNumEntries(address _entrant, uint _week) constant external returns (uint) {&#13;
        return raffle[_week].entries[_entrant].length;&#13;
    }&#13;
    /**&#13;
     * @dev     Get chosen numbers of an entrant, for a specific raffle.&#13;
     *          Returns an array.&#13;
     *&#13;
     * @param _entrant    The entrant in question's address.&#13;
     * @param _week       The week number of the queried raffle.&#13;
     * @param _entryNum   The entrant's entry number in this raffle.&#13;
     */&#13;
    function getChosenNumbers(address _entrant, uint _week, uint _entryNum) constant external returns (uint[]) {&#13;
        return raffle[_week].entries[_entrant][_entryNum-1];&#13;
    }&#13;
    /**&#13;
     * @dev     Get winning details of a raffle, ie, it's winning numbers&#13;
     *          and the prize amounts. Returns two arrays.&#13;
     *&#13;
     * @param _week   The week number of the raffle in question.&#13;
     */&#13;
    function getWinningDetails(uint _week) constant external returns (uint[], uint[]) {&#13;
        return (raffle[_week].winNums, raffle[_week].winAmts);&#13;
    }&#13;
    /**&#13;
     * @dev     Upgrades the Etheraffle contract. Only callable by the&#13;
     *          Etheraffle address. Calls an addToPrizePool method as&#13;
     *          per the abstract contract above. Function renders the&#13;
     *          entry method uncallable, cancels the Oraclize recursion,&#13;
     *          then zeroes the prizepool and sends the funds to the new&#13;
     *          contract. Sets a var tracking when upgrade occurred and logs&#13;
     *          the event.&#13;
     *&#13;
     * @param _newAddr   The new contract address.&#13;
     */&#13;
    function upgradeContract(address _newAddr) onlyEtheraffle external {&#13;
        require(upgraded == 0 &amp;&amp; upgradeAddr == address(0));&#13;
        uint amt    = prizePool;&#13;
        upgradeAddr = _newAddr;&#13;
        upgraded    = now;&#13;
        week        = 0;//no struct for this raffle â´ no timestamp â´ no entry possible&#13;
        prizePool   = 0;&#13;
        gasAmt      = 0;//will arrest the oraclize recursive callbacks&#13;
        apiStr1     = "";&#13;
        randomStr1  = "";&#13;
        require(this.balance &gt;= amt);&#13;
        EtheraffleUpgrade(_newAddr).addToPrizePool.value(amt)();&#13;
        LogUpgrade(_newAddr, amt, upgraded);&#13;
    }&#13;
    /**&#13;
     * @dev     Self destruct contract. Only callable by Etheraffle address.&#13;
     *          function. It deletes all contract code and data and forwards&#13;
     *          any remaining ether from non-claimed winning raffle tickets&#13;
     *          to the EthRelief charity contract. Requires the upgrade contract&#13;
     *          method to have been called 10 or more weeks prior, to allow&#13;
     *          winning tickets to be claimed within the usual withdrawal time&#13;
     *          frame.&#13;
     */&#13;
    function selfDestruct() onlyEtheraffle external {&#13;
        require(now - upgraded &gt; weekDur * 10);&#13;
        selfdestruct(ethRelief);&#13;
    }&#13;
    /**&#13;
     * @dev     Function allowing manual addition to the global prizepool.&#13;
     *          Requires the caller to send ether.&#13;
     */&#13;
    function addToPrizePool() payable external {&#13;
        require(msg.value &gt; 0);&#13;
        prizePool += msg.value;&#13;
        LogPrizePoolAddition(msg.sender, msg.value, now);&#13;
    }&#13;
    /**&#13;
     * @dev   Fallback function.&#13;
     */&#13;
    function () payable external {}&#13;
}