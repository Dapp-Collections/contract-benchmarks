// MUSystem is based of the mathematical algorithm created 
// by the Mavrodi brothers - Sergey and Vyacheslav. 
// The solidity code was written by the enthusiast and devoted MMM participant Andrew from Russia.
// According to these rules MMM worked in Russia in the nineties. 
// Today you help someone — Tomorrow you will be helped out!
// Mutual Uniting System (MUSystem) email: <span class="__cf_email__" data-cfemail="bbd6cecfcedad7ced5d2cfd2d5dcc8c2c8cfded6fbdcd6dad2d795d8d4d6">[email protected]</span>&#13;
// http:// Musystem.online&#13;
// Hello from Russia with love! ;) Привет из России! ;)&#13;
// "MMM IS A FINANCIAL NUCLEAR WEAPON.&#13;
// They say Baba Vanga predicted, “Pyramid from Russia will travel the world.”&#13;
// When Sergey Mavrodi passed away, many people thought this prediction &#13;
// wasn't going to come true. What if it's just started to materialize?"&#13;
&#13;
// Financial apocalypse is inevitable! Together we can do a lot!&#13;
// Thank you Sergey Mavrodi. You've opened my eyes.&#13;
&#13;
pragma solidity ^0.4.21;&#13;
&#13;
library SafeMath {&#13;
  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {&#13;
    if (a == 0) {&#13;
      return 0;&#13;
    }&#13;
    c = a * b;&#13;
    assert(c / a == b);&#13;
    return c;&#13;
  }&#13;
  function div(uint256 a, uint256 b) internal pure returns (uint256 c) {&#13;
    c = a / b;&#13;
    return c;&#13;
  }&#13;
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
    assert(b &lt;= a);&#13;
    return a - b;&#13;
  }&#13;
  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {&#13;
    c = a + b;&#13;
    assert(c &gt;= a);&#13;
    return c;&#13;
  }&#13;
}&#13;
&#13;
contract MUSystem {&#13;
    &#13;
    using SafeMath for uint;&#13;
    &#13;
    string public constant name = "Mutual Uniting System";&#13;
    string public constant symbol = "MUS";&#13;
    uint public constant decimals = 15;&#13;
    uint public totalSupply;&#13;
    address private creatorOwner;&#13;
    address private userAddr;&#13;
    mapping (address =&gt; uint) balances;&#13;
    struct UserWhoBuy {&#13;
        uint UserAmt;&#13;
        uint UserTokenObtain;&#13;
        uint UserBuyDate;&#13;
        uint UserBuyFirstDate;&#13;
        uint UserBuyTokenPackNum;&#13;
        uint UserFirstAmt;&#13;
        uint UserContinued;&#13;
        uint UserTotalAmtDepositCurrentPack;&#13;
    }&#13;
    mapping (address =&gt; UserWhoBuy) usersWhoBuy;&#13;
    address[] private userWhoBuyDatas;&#13;
    struct UserWhoSell {&#13;
        uint UserAmtWithdrawal;&#13;
        uint UserTokenSell;&#13;
        uint UserSellDate;&#13;
        uint UserSellTokenPackNum;&#13;
        uint UserTotalAmtWithdrawal;&#13;
        uint UserTotalAmtWithdrawalCurrentPack;&#13;
    }&#13;
    mapping (address =&gt; UserWhoSell) usersWhoSell;&#13;
    address[] private userWhoSellDatas;&#13;
&#13;
// The basic parameters of MUSystem that determine &#13;
// the participant's income per package, &#13;
// the initial price of one token, &#13;
// the number of tokens in pack, Disparity mode percentage&#13;
// and another internal constants.&#13;
&#13;
    uint private CoMargin = 101; &#13;
    uint private CoOverlap = 110; &#13;
    uint private Disparity = 70; &#13;
    bool private DisparityMode;&#13;
    uint private RestartModeDate;&#13;
    bool private RestartMode;&#13;
    uint private PackVolume = 50;  &#13;
    uint private FirstPackTokenPriceSellout = 50;    &#13;
    uint private BigAmt = 250 * 1 ether; &#13;
    bool private feeTransfered;&#13;
    uint private PrevPrevPackTokenPriceSellout;&#13;
    uint private PrevPackTokenPriceSellout;&#13;
    uint private PrevPackTokenPriceBuyout; &#13;
    uint private PrevPackDelta; &#13;
    uint private PrevPackCost;&#13;
    uint private PrevPackTotalAmt;&#13;
    uint private CurrentPackYield;&#13;
    uint private CurrentPackDelta;&#13;
    uint private CurrentPackCost;&#13;
    uint private CurrentPackTotalToPay;&#13;
    uint private CurrentPackTotalAmt;&#13;
    uint private CurrentPackRestAmt;&#13;
    uint private CurrentPackFee;&#13;
    uint private CurrentPackTotalToPayDisparity;&#13;
    uint private CurrentPackNumber; &#13;
    uint private CurrentPackStartDate; &#13;
    uint private CurrentPackTokenPriceSellout;  &#13;
    uint private CurrentPackTokenPriceBuyout;&#13;
    uint private CurrentPackTokenAvailablePercent;&#13;
    uint private NextPackTokenPriceBuyout; &#13;
    uint private NextPackYield; &#13;
    uint private NextPackDelta;&#13;
    uint private userContinued;&#13;
    uint private userAmt; &#13;
    uint private userFirstAmt;&#13;
    uint private userTotalAmtDepositCurrentPack;&#13;
    uint private userBuyFirstDate;&#13;
    uint private userTotalAmtWithdrawal;&#13;
    uint private userTotalAmtWithdrawalCurrentPack;&#13;
    uint private UserTokensReturn;&#13;
    bool private returnTokenInCurrentPack;&#13;
    uint private withdrawAmtToCurrentPack;&#13;
    uint private withdrawAmtAboveCurrentPack;&#13;
    uint private UserTokensReturnToCurrentPack;&#13;
    uint private UserTokensReturnAboveCurrentPack;&#13;
    uint private bonus;&#13;
    uint private userAmtOverloadToSend;&#13;
&#13;
// MUSystem is launched at the time of the contract deployment. &#13;
// It all starts with the first package. &#13;
// Settings are applied and the number of tokens is released.&#13;
&#13;
    constructor () public payable {&#13;
        creatorOwner = msg.sender;&#13;
        PackVolume = (10 ** decimals).mul(PackVolume);&#13;
        DisparityMode = false;&#13;
        RestartMode = false;&#13;
        CurrentPackNumber = 1; &#13;
        CurrentPackStartDate = now;&#13;
        mint(PackVolume);&#13;
        packSettings(CurrentPackNumber);&#13;
    }&#13;
&#13;
// Write down participants who make deposits.&#13;
&#13;
    function addUserWhoBuy (&#13;
    address _address, &#13;
    uint _UserAmt, &#13;
    uint _UserTokenObtain, &#13;
    uint _UserBuyDate,&#13;
    uint _UserBuyFirstDate,&#13;
    uint _UserBuyTokenPackNum,&#13;
    uint _UserFirstAmt,&#13;
    uint _UserContinued,&#13;
    uint _UserTotalAmtDepositCurrentPack) internal {&#13;
        UserWhoBuy storage userWhoBuy = usersWhoBuy[_address];&#13;
        userWhoBuy.UserAmt = _UserAmt;&#13;
        userWhoBuy.UserTokenObtain = _UserTokenObtain;&#13;
        userWhoBuy.UserBuyDate = _UserBuyDate;&#13;
        userWhoBuy.UserBuyFirstDate = _UserBuyFirstDate;&#13;
        userWhoBuy.UserBuyTokenPackNum = _UserBuyTokenPackNum;&#13;
        userWhoBuy.UserFirstAmt = _UserFirstAmt;&#13;
        userWhoBuy.UserContinued = _UserContinued;&#13;
        userWhoBuy.UserTotalAmtDepositCurrentPack = _UserTotalAmtDepositCurrentPack;&#13;
        userWhoBuyDatas.push(_address) -1;&#13;
    }&#13;
// Write down also participants who make withdrawals.&#13;
&#13;
    function addUserWhoSell (&#13;
    address _address, &#13;
    uint _UserAmtWithdrawal, &#13;
    uint _UserTokenSell, &#13;
    uint _UserSellDate,&#13;
    uint _UserSellTokenPackNum,&#13;
    uint _UserTotalAmtWithdrawal,&#13;
    uint _UserTotalAmtWithdrawalCurrentPack) internal {&#13;
        UserWhoSell storage userWhoSell = usersWhoSell[_address];&#13;
        userWhoSell.UserAmtWithdrawal = _UserAmtWithdrawal;&#13;
        userWhoSell.UserTokenSell = _UserTokenSell;&#13;
        userWhoSell.UserSellDate = _UserSellDate;&#13;
        userWhoSell.UserSellTokenPackNum = _UserSellTokenPackNum;&#13;
        userWhoSell.UserTotalAmtWithdrawal = _UserTotalAmtWithdrawal; &#13;
        userWhoSell.UserTotalAmtWithdrawalCurrentPack = _UserTotalAmtWithdrawalCurrentPack;&#13;
        userWhoSellDatas.push(_address) -1;&#13;
    }&#13;
&#13;
// Calculation of pack's parameters "on the fly". &#13;
// Course (price) of tokens is growing by a special technique, &#13;
// which designed increases with the passage of time the size &#13;
// of a possible return donations for the participants, &#13;
// subject to a maximum system stability.&#13;
&#13;
    function packSettings (uint _currentPackNumber) internal {&#13;
        CurrentPackNumber = _currentPackNumber;&#13;
        if(CurrentPackNumber == 1){&#13;
            PrevPackDelta = 0;&#13;
            PrevPackCost = 0;&#13;
            PrevPackTotalAmt = 0;&#13;
            CurrentPackStartDate = now;&#13;
            CurrentPackTokenPriceSellout = FirstPackTokenPriceSellout;&#13;
            CurrentPackTokenPriceBuyout = FirstPackTokenPriceSellout; &#13;
            CurrentPackCost = PackVolume.mul(CurrentPackTokenPriceSellout);&#13;
            CurrentPackTotalToPay = 0;&#13;
            CurrentPackTotalToPayDisparity = 0;&#13;
            CurrentPackYield = 0;&#13;
            CurrentPackDelta = 0;&#13;
            CurrentPackTotalAmt = CurrentPackCost;&#13;
            CurrentPackFee = 0;&#13;
            CurrentPackRestAmt = CurrentPackCost.sub(CurrentPackTotalToPay);&#13;
            if (FirstPackTokenPriceSellout == 50){NextPackTokenPriceBuyout = 60;}else{NextPackTokenPriceBuyout = FirstPackTokenPriceSellout+5;}&#13;
        }&#13;
        if(CurrentPackNumber == 2){&#13;
            PrevPrevPackTokenPriceSellout = 0;&#13;
            PrevPackTokenPriceSellout = CurrentPackTokenPriceSellout;&#13;
            PrevPackTokenPriceBuyout = CurrentPackTokenPriceBuyout;&#13;
            PrevPackDelta = CurrentPackDelta;&#13;
            PrevPackCost = CurrentPackCost;&#13;
            PrevPackTotalAmt = CurrentPackTotalAmt;&#13;
            CurrentPackYield = 0;&#13;
            CurrentPackDelta = 0;&#13;
            NextPackTokenPriceBuyout = PrevPackTokenPriceSellout.mul(CoOverlap).div(100);&#13;
            NextPackYield = NextPackTokenPriceBuyout.sub(PrevPackTokenPriceSellout);&#13;
            NextPackDelta = NextPackYield;&#13;
            CurrentPackTokenPriceSellout = NextPackTokenPriceBuyout.add(NextPackDelta);&#13;
            CurrentPackTokenPriceBuyout = CurrentPackTokenPriceSellout;&#13;
            CurrentPackCost = PackVolume.mul(CurrentPackTokenPriceSellout);&#13;
            CurrentPackTotalToPay = 0;&#13;
            CurrentPackTotalAmt = CurrentPackCost.add(PrevPackTotalAmt);&#13;
            CurrentPackFee = 0;&#13;
            CurrentPackTotalToPayDisparity = PrevPackCost.mul(Disparity).div(100);&#13;
            CurrentPackRestAmt = CurrentPackCost.sub(CurrentPackTotalToPay);&#13;
        }&#13;
        if(CurrentPackNumber &gt; 2){&#13;
            PrevPackTokenPriceSellout = CurrentPackTokenPriceSellout;&#13;
            PrevPackTokenPriceBuyout = CurrentPackTokenPriceBuyout;&#13;
            PrevPackDelta = CurrentPackDelta;&#13;
            PrevPackCost = CurrentPackCost;&#13;
            PrevPackTotalAmt = CurrentPackTotalAmt;&#13;
            CurrentPackYield = NextPackYield;&#13;
            CurrentPackDelta = NextPackDelta;&#13;
            CurrentPackTokenPriceBuyout = NextPackTokenPriceBuyout;&#13;
            NextPackTokenPriceBuyout = PrevPackTokenPriceSellout.mul(CoOverlap);&#13;
            if(NextPackTokenPriceBuyout&lt;=100){  &#13;
                NextPackTokenPriceBuyout=PrevPackTokenPriceSellout.mul(CoOverlap).div(100);&#13;
            }&#13;
            if(NextPackTokenPriceBuyout&gt;100){ &#13;
                NextPackTokenPriceBuyout=NextPackTokenPriceBuyout*10**3;&#13;
                NextPackTokenPriceBuyout=((NextPackTokenPriceBuyout/10000)+5)/10;&#13;
            }&#13;
            NextPackYield = NextPackTokenPriceBuyout.sub(PrevPackTokenPriceSellout);&#13;
            NextPackDelta = NextPackYield.mul(CoMargin);&#13;
            if(NextPackDelta &lt;= 100){ &#13;
                NextPackDelta = CurrentPackDelta.add(NextPackYield.mul(CoMargin).div(100));&#13;
            }&#13;
            if(NextPackDelta &gt; 100){&#13;
                NextPackDelta = NextPackDelta*10**3;&#13;
                NextPackDelta = ((NextPackDelta/10000)+5)/10;&#13;
                NextPackDelta = CurrentPackDelta.add(NextPackDelta);&#13;
            }&#13;
            CurrentPackTokenPriceSellout = NextPackTokenPriceBuyout.add(NextPackDelta);&#13;
            CurrentPackCost = PackVolume.mul(CurrentPackTokenPriceSellout);&#13;
            CurrentPackTotalToPay = PackVolume.mul(CurrentPackTokenPriceBuyout);&#13;
            CurrentPackTotalToPayDisparity = PrevPackCost.mul(Disparity).div(100);&#13;
            CurrentPackRestAmt = CurrentPackCost.sub(CurrentPackTotalToPay);&#13;
            CurrentPackTotalAmt = CurrentPackRestAmt.add(PrevPackTotalAmt);&#13;
            CurrentPackFee = PrevPackTotalAmt.sub(CurrentPackTotalToPay).sub(CurrentPackTotalToPayDisparity);&#13;
        }&#13;
        CurrentPackTokenAvailablePercent = balances[address(this)].mul(100).div(PackVolume);&#13;
        emit NextPack(CurrentPackTokenPriceSellout, CurrentPackTokenPriceBuyout);&#13;
    }&#13;
&#13;
// The data of the current package can be obtained &#13;
// by performing this function.&#13;
// Available tokens - the remaining number of available &#13;
// tokens in the current package. &#13;
// At onetime you can not buy more than this number of tokens.&#13;
// Available tokens in percentage - the percentage of &#13;
// remaining available tokens in the current package.&#13;
// Available amount to deposit in wei - the maximum amount &#13;
// that can be deposited in the current package.&#13;
// Attempt to exceed this amount too much &#13;
// (i.e., an attempt to buy more tokens than the Available tokens &#13;
// in the current package) will be rejected. &#13;
// In case of a small excess of the amount, the unused leftover &#13;
// will return to your Ethereum account.&#13;
// Current pack token price sellout -  the price at which &#13;
// tokens are bought by a participant.&#13;
// Current pack token price buyout - the price at which &#13;
// tokens are sold by a participant (are bought by the system).&#13;
&#13;
    function aboutCurrentPack () public constant returns (uint availableTokens, uint availableTokensInPercentage, uint availableAmountToDepositInWei, uint tokenPriceSellout, uint tokenPriceBuyout){&#13;
        uint _availableTokens = balances[address(this)];&#13;
        uint _availableAmountToDepositInWei = _availableTokens.mul(CurrentPackTokenPriceSellout);&#13;
        return (_availableTokens, CurrentPackTokenAvailablePercent, _availableAmountToDepositInWei, CurrentPackTokenPriceSellout, CurrentPackTokenPriceBuyout);&#13;
    }&#13;
&#13;
// Move to the next package. Sending a reward to the owner. &#13;
// Minting of new tokens.&#13;
&#13;
    function nextPack (uint _currentPackNumber) internal { &#13;
        transferFee();&#13;
        feeTransfered = false;&#13;
        CurrentPackNumber=_currentPackNumber.add(1);&#13;
        CurrentPackStartDate = now;&#13;
        mint(PackVolume);&#13;
        packSettings(CurrentPackNumber);&#13;
    }&#13;
&#13;
// Restart occurs if the Disparity mode is enabled and &#13;
// there were no new donations within 14 days. &#13;
// Everything will start with the first package. &#13;
// After restart, the system saves the participant's tokens. &#13;
// Moreover, by participating from the very beginning &#13;
// (starting from the first package of the new cycle), &#13;
// the participant can easily compensate for his &#13;
// insignificant losses. And quickly achieve a good profit!&#13;
&#13;
    function restart(bool _dm)internal{&#13;
        if(_dm==true){if(RestartMode==false){RestartMode=true;RestartModeDate=now;}&#13;
            else{if(now&gt;RestartModeDate+14*1 days){RestartMode=false;DisparityMode=false;nextPack(0);}}}&#13;
        else{if(RestartMode==true){RestartMode=false;RestartModeDate=0;}}&#13;
    }&#13;
&#13;
// Sending reward to the owner. &#13;
// No more and no less - just as much as it does not hurt. &#13;
// Exactly as much as provided by the algorithm.&#13;
&#13;
    function transferFee()internal{&#13;
        if(CurrentPackNumber &gt; 2 &amp;&amp; feeTransfered == false){&#13;
            if(address(this).balance&gt;=CurrentPackFee){&#13;
                creatorOwner.transfer(CurrentPackFee);&#13;
                feeTransfered = true;&#13;
            }&#13;
        }&#13;
    }&#13;
&#13;
// Receiving a donation and calculating the number of participant tokens. &#13;
// Bonuses, penalties.&#13;
&#13;
    function deposit() public payable returns (uint UserTokenObtain){ &#13;
        require(msg.sender != 0x0 &amp;&amp; msg.sender != 0);&#13;
        require(msg.value &lt; BigAmt); &#13;
        uint availableTokens = balances[address(this)];&#13;
        require(msg.value &lt;= availableTokens.mul(CurrentPackTokenPriceSellout).add(availableTokens.mul(CurrentPackTokenPriceSellout).mul(10).div(100)).add(10*1 finney)); &#13;
        require(msg.value.div(CurrentPackTokenPriceSellout) &gt; 0);&#13;
        userAddr = msg.sender;&#13;
        userAmt = msg.value;&#13;
        if(usersWhoBuy[userAddr].UserBuyTokenPackNum == CurrentPackNumber){&#13;
            userTotalAmtDepositCurrentPack = usersWhoBuy[userAddr].UserTotalAmtDepositCurrentPack;&#13;
        }&#13;
        else{&#13;
            userTotalAmtDepositCurrentPack = 0;&#13;
        }&#13;
        if(usersWhoBuy[userAddr].UserBuyTokenPackNum == CurrentPackNumber){&#13;
            require(userTotalAmtDepositCurrentPack.add(userAmt) &lt; BigAmt);&#13;
        }&#13;
&#13;
// If the participant making a donation in the current package &#13;
// has already received a backward donation in the same package, &#13;
// the amount of the new donation is reduced by 5% of the amount&#13;
// of the received donation; a kind of "penalty" is imposed in &#13;
// the amount of 5% of the amount received earlier &#13;
// by the participant in the same package.&#13;
&#13;
        if(usersWhoSell[userAddr].UserSellTokenPackNum == CurrentPackNumber){&#13;
            uint penalty = usersWhoSell[userAddr].UserTotalAmtWithdrawalCurrentPack.mul(5).div(100);&#13;
            userAmt = userAmt.sub(penalty);&#13;
            require(userAmt.div(CurrentPackTokenPriceSellout) &gt; 0);&#13;
            penalty=0;&#13;
        }&#13;
        UserTokenObtain = userAmt.div(CurrentPackTokenPriceSellout);&#13;
        bonus = 0;&#13;
&#13;
// Participants who made donation amounting to at least  0.1 ether:&#13;
// In the 1st day of the current package is entitled to receive &#13;
// the amount of possible backward donation to 0.75% more than usual.&#13;
// In the 2nd day of the current package - 0.5% more than usual.&#13;
// In the 3rd day of the current package - 0.25% more than usual.&#13;
&#13;
        if(userAmt &gt;= 100*1 finney){&#13;
            if(now &lt;= (CurrentPackStartDate + 1*1 days)){&#13;
                bonus = UserTokenObtain.mul(75).div(10000);&#13;
            }&#13;
            if(now &gt; (CurrentPackStartDate + 1*1 days) &amp;&amp; now &lt;= (CurrentPackStartDate + 2*1 days)){&#13;
                bonus = UserTokenObtain.mul(50).div(10000);&#13;
            }&#13;
            if(now &gt; (CurrentPackStartDate + 2*1 days) &amp;&amp; now &lt;= (CurrentPackStartDate + 3*1 days)){&#13;
                bonus = UserTokenObtain.mul(25).div(10000);&#13;
            }&#13;
        }&#13;
&#13;
// For continuous long-time participation, &#13;
// starting from the second week of participation &#13;
// (starting from the 4th participation package), &#13;
// bonus incentives for the continuous participation &#13;
// of 1% of the contributed amount for each subsequent &#13;
// "own" package are accrued for the participant.&#13;
&#13;
        if(userContinued &gt; 4 &amp;&amp; now &gt; (userBuyFirstDate + 1 * 1 weeks)){&#13;
            bonus = bonus.add(UserTokenObtain.mul(1).div(100));&#13;
        }&#13;
        UserTokenObtain = UserTokenObtain.add(bonus);  &#13;
        if(UserTokenObtain &gt; availableTokens){&#13;
            userAmtOverloadToSend = CurrentPackTokenPriceSellout.mul(UserTokenObtain.sub(availableTokens)); &#13;
            transfer(address(this), userAddr, availableTokens);&#13;
            UserTokenObtain = availableTokens;&#13;
            if(address(this).balance&gt;=userAmtOverloadToSend){&#13;
                userAddr.transfer(userAmtOverloadToSend);&#13;
            }&#13;
        }                &#13;
        else{                 &#13;
            transfer(address(this), userAddr, UserTokenObtain);&#13;
        }&#13;
        if(usersWhoBuy[userAddr].UserBuyTokenPackNum == 0){&#13;
            userFirstAmt = userAmt;&#13;
            userBuyFirstDate = now;&#13;
        }&#13;
        else{&#13;
            userFirstAmt = usersWhoBuy[userAddr].UserFirstAmt;&#13;
            userBuyFirstDate = usersWhoBuy[userAddr].UserBuyFirstDate;&#13;
        }&#13;
        if(usersWhoBuy[userAddr].UserContinued == 0){&#13;
            userContinued = 1;&#13;
        }&#13;
        else{&#13;
            if(usersWhoBuy[userAddr].UserBuyTokenPackNum == CurrentPackNumber.sub(1)){&#13;
                userContinued = userContinued.add(1);&#13;
            }&#13;
            else{&#13;
                userContinued = 1;&#13;
            }&#13;
        }&#13;
        userTotalAmtDepositCurrentPack = userTotalAmtDepositCurrentPack.add(userAmt);&#13;
        addUserWhoBuy(userAddr, userAmt, UserTokenObtain, now, userBuyFirstDate, CurrentPackNumber, userFirstAmt, userContinued, userTotalAmtDepositCurrentPack);&#13;
        CurrentPackTokenAvailablePercent = balances[address(this)].mul(100).div(PackVolume);&#13;
        bonus = 0;&#13;
        availableTokens = 0;&#13;
        userAmtOverloadToSend = 0;&#13;
        userAddr = 0;&#13;
        userAmt = 0;&#13;
        restart(false);&#13;
        DisparityMode = false;&#13;
&#13;
// Move to the next pack, if all the tokens of the current one are over.&#13;
&#13;
        if(balances[address(this)] == 0){nextPack(CurrentPackNumber);}&#13;
        return UserTokenObtain;&#13;
    } &#13;
&#13;
// And here the participant decided to sell his tokens (some or all at once) and sends us his withdrawal request.&#13;
&#13;
    function withdraw(uint WithdrawAmount, uint WithdrawTokens) public returns (uint withdrawAmt){&#13;
        require(msg.sender != 0x0 &amp;&amp; msg.sender != 0);&#13;
        require(WithdrawTokens &gt; 0 || WithdrawAmount &gt; 0);&#13;
        require(WithdrawTokens&lt;=balances[msg.sender]); &#13;
        require(WithdrawAmount.mul(1 finney)&lt;=balances[msg.sender].mul(CurrentPackTokenPriceSellout).add(balances[msg.sender].mul(CurrentPackTokenPriceSellout).mul(5).div(100)));&#13;
&#13;
// If the normal work is braked then Disparity mode is turning on.&#13;
// If Disparity mode is already enabled, then we check whether it's time to restart.&#13;
&#13;
        if(RestartMode==true){restart(true);}&#13;
        if(address(this).balance&lt;=CurrentPackTotalToPayDisparity){&#13;
            DisparityMode=true;}else{DisparityMode=false;}&#13;
&#13;
// The participant can apply at any time for the selling &#13;
// his tokens at the buyout price of the last realized (current) package.&#13;
// Let calculate how much tokens are returned in the current package, &#13;
// and how much was purchased earlier.&#13;
&#13;
        userTotalAmtWithdrawal = usersWhoSell[msg.sender].UserTotalAmtWithdrawal;&#13;
        if(usersWhoSell[msg.sender].UserSellTokenPackNum == CurrentPackNumber){&#13;
            userTotalAmtWithdrawalCurrentPack = usersWhoSell[msg.sender].UserTotalAmtWithdrawalCurrentPack;&#13;
        }&#13;
        else{&#13;
            userTotalAmtWithdrawalCurrentPack = 0;&#13;
        }&#13;
        if(usersWhoBuy[msg.sender].UserBuyTokenPackNum == CurrentPackNumber &amp;&amp; userTotalAmtWithdrawalCurrentPack &lt; usersWhoBuy[msg.sender].UserTotalAmtDepositCurrentPack){&#13;
            returnTokenInCurrentPack = true;&#13;
            withdrawAmtToCurrentPack = usersWhoBuy[msg.sender].UserTotalAmtDepositCurrentPack.sub(userTotalAmtWithdrawalCurrentPack);&#13;
        }&#13;
        else{ &#13;
            returnTokenInCurrentPack = false;&#13;
        }&#13;
        if(WithdrawAmount &gt; 0){&#13;
            withdrawAmt = WithdrawAmount.mul(1 finney);&#13;
            if(returnTokenInCurrentPack == true){&#13;
                UserTokensReturnToCurrentPack = withdrawAmtToCurrentPack.div(CurrentPackTokenPriceSellout);&#13;
                if(withdrawAmt&gt;withdrawAmtToCurrentPack){ &#13;
                    withdrawAmtAboveCurrentPack = withdrawAmt.sub(withdrawAmtToCurrentPack);&#13;
                    UserTokensReturnAboveCurrentPack = withdrawAmtAboveCurrentPack.div(CurrentPackTokenPriceBuyout);&#13;
                } &#13;
                else{&#13;
                    withdrawAmtToCurrentPack = withdrawAmt;&#13;
                    UserTokensReturnToCurrentPack = withdrawAmtToCurrentPack.div(CurrentPackTokenPriceSellout);&#13;
                    withdrawAmtAboveCurrentPack = 0;&#13;
                    UserTokensReturnAboveCurrentPack = 0;&#13;
                }&#13;
            }&#13;
            else{&#13;
                withdrawAmtToCurrentPack = 0;&#13;
                UserTokensReturnToCurrentPack = 0;&#13;
                withdrawAmtAboveCurrentPack = withdrawAmt;&#13;
                UserTokensReturnAboveCurrentPack = withdrawAmtAboveCurrentPack.div(CurrentPackTokenPriceBuyout);&#13;
            }&#13;
        }&#13;
        else{&#13;
            UserTokensReturn = WithdrawTokens;&#13;
            if(returnTokenInCurrentPack == true){&#13;
                UserTokensReturnToCurrentPack = withdrawAmtToCurrentPack.div(CurrentPackTokenPriceSellout);&#13;
                if(UserTokensReturn&gt;UserTokensReturnToCurrentPack){&#13;
                    UserTokensReturnAboveCurrentPack = UserTokensReturn.sub(UserTokensReturnToCurrentPack);&#13;
                    withdrawAmtAboveCurrentPack = UserTokensReturnAboveCurrentPack.mul(CurrentPackTokenPriceBuyout);&#13;
                }&#13;
                else{&#13;
                    withdrawAmtToCurrentPack = UserTokensReturn.mul(CurrentPackTokenPriceSellout);&#13;
                    UserTokensReturnToCurrentPack = UserTokensReturn;&#13;
                    withdrawAmtAboveCurrentPack = 0;&#13;
                    UserTokensReturnAboveCurrentPack = 0;&#13;
                }&#13;
            }&#13;
            else{&#13;
                withdrawAmtToCurrentPack = 0;&#13;
                UserTokensReturnToCurrentPack = 0;&#13;
                UserTokensReturnAboveCurrentPack = UserTokensReturn;&#13;
                withdrawAmtAboveCurrentPack = UserTokensReturnAboveCurrentPack.mul(CurrentPackTokenPriceBuyout);&#13;
            }    &#13;
        }&#13;
        withdrawAmt = withdrawAmtToCurrentPack.add(withdrawAmtAboveCurrentPack);&#13;
&#13;
// When applying for a donation, if the remaining number &#13;
// of available tokens of the current package is less than 10%, &#13;
// participants are entitled to withdraw of 1% more than usual.&#13;
&#13;
        if(balances[address(this)]&lt;=(PackVolume.mul(10).div(100))){&#13;
            withdrawAmtAboveCurrentPack = withdrawAmtAboveCurrentPack.add(withdrawAmt.mul(1).div(100));&#13;
        }&#13;
&#13;
// With each withdrawal, the system checks the total balance &#13;
// and if the system is on the verge, when it can pay to each participant &#13;
// 70% of his initial donation, the protection mode called "Disparity mode" is activated.&#13;
// In disparity mode: participant who made a donation in the current package &#13;
// can withdraw up to 100% of his initial donation amount,&#13;
// participant who made a donation earlier (in previous packs) &#13;
// can withdraw up to 70% of his initial donation amount.&#13;
&#13;
        if(address(this).balance&lt;CurrentPackTotalToPayDisparity || withdrawAmt &gt; address(this).balance || DisparityMode == true){&#13;
            uint disparityAmt = usersWhoBuy[msg.sender].UserFirstAmt.mul(Disparity).div(100);&#13;
            if(userTotalAmtWithdrawal &gt;= disparityAmt){&#13;
                withdrawAmtAboveCurrentPack = 0;&#13;
                UserTokensReturnAboveCurrentPack = 0;&#13;
            }&#13;
            else{&#13;
                if(withdrawAmtAboveCurrentPack.add(userTotalAmtWithdrawal) &gt;= disparityAmt){&#13;
                    withdrawAmtAboveCurrentPack = disparityAmt.sub(userTotalAmtWithdrawal);&#13;
                    UserTokensReturnAboveCurrentPack = withdrawAmtAboveCurrentPack.div(CurrentPackTokenPriceBuyout);&#13;
                }&#13;
            }&#13;
            DisparityMode = true;&#13;
            if(CurrentPackNumber&gt;2){restart(true);}&#13;
        }&#13;
        if(withdrawAmt&gt;address(this).balance){&#13;
            withdrawAmt = address(this).balance;&#13;
            withdrawAmtAboveCurrentPack = address(this).balance.sub(withdrawAmtToCurrentPack);&#13;
            UserTokensReturnAboveCurrentPack = withdrawAmtAboveCurrentPack.div(CurrentPackTokenPriceBuyout);&#13;
            if(CurrentPackNumber&gt;2){restart(true);}&#13;
        }&#13;
        withdrawAmt = withdrawAmtToCurrentPack.add(withdrawAmtAboveCurrentPack);&#13;
        UserTokensReturn = UserTokensReturnToCurrentPack.add(UserTokensReturnAboveCurrentPack);&#13;
        require(UserTokensReturn&lt;=balances[msg.sender]); &#13;
        transfer(msg.sender, address(this), UserTokensReturn);&#13;
        msg.sender.transfer(withdrawAmt);&#13;
        userTotalAmtWithdrawal = userTotalAmtWithdrawal.add(withdrawAmt);&#13;
        userTotalAmtWithdrawalCurrentPack = userTotalAmtWithdrawalCurrentPack.add(withdrawAmt);&#13;
        addUserWhoSell(msg.sender, withdrawAmt, UserTokensReturn, now, CurrentPackNumber, userTotalAmtWithdrawal, userTotalAmtWithdrawalCurrentPack);&#13;
        CurrentPackTokenAvailablePercent = balances[address(this)].mul(100).div(PackVolume);&#13;
        withdrawAmtToCurrentPack = 0;&#13;
        withdrawAmtAboveCurrentPack = 0;&#13;
        UserTokensReturnToCurrentPack = 0;&#13;
        UserTokensReturnAboveCurrentPack = 0;&#13;
        return withdrawAmt;&#13;
    }&#13;
&#13;
// If tokens purchased in the current package are returned, &#13;
// they are again available for purchase by other participants.&#13;
// If tokens purchased in previous packages are returned, &#13;
// then such tokens are no longer available to anyone.&#13;
&#13;
    function transfer(address _from, address _to, uint _value) internal returns (bool success) {&#13;
        balances[_from] = balances[_from].sub(_value); &#13;
        if(_to == address(this)){ &#13;
            if(returnTokenInCurrentPack == true){&#13;
                balances[_to] = balances[_to].add(UserTokensReturnToCurrentPack);&#13;
            }&#13;
            else{&#13;
                balances[_to] = balances[_to];&#13;
            }&#13;
            totalSupply = totalSupply.sub(UserTokensReturnAboveCurrentPack);&#13;
        }&#13;
        else{&#13;
            balances[_to] = balances[_to].add(_value);&#13;
        }&#13;
        emit Transfer(_from, _to, _value); &#13;
        return true;&#13;
    }  &#13;
&#13;
// BalanceOf — get balance of tokens.&#13;
&#13;
    function balanceOf(address tokenOwner) public constant returns (uint balance) {&#13;
        return balances[tokenOwner];&#13;
    }&#13;
&#13;
// Minting new tokens if the moving to a new package occurred.&#13;
&#13;
    function mint(uint _value) internal returns (bool) {&#13;
        balances[address(this)] = balances[address(this)].add(_value);&#13;
        totalSupply = totalSupply.add(_value);&#13;
        return true;&#13;
    }&#13;
&#13;
    event Transfer(address indexed _from, address indexed _to, uint _value);&#13;
    event NextPack(uint indexed CurrentPackTokenPriceSellout, uint indexed CurrentPackTokenPriceBuyout);&#13;
}