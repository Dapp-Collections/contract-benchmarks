/* Token - simple token for PreICO and ICO
   Copyright (C) 2017  Sergey Sherkunov <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="4f232a2621232e383a210f232a2621232e383a2161203d28">[emailÂ protected]</a>&gt;&#13;
&#13;
   This file is part of Token.&#13;
&#13;
   Token is free software: you can redistribute it and/or modify&#13;
   it under the terms of the GNU General Public License as published by&#13;
   the Free Software Foundation, either version 3 of the License, or&#13;
   (at your option) any later version.&#13;
&#13;
   This program is distributed in the hope that it will be useful,&#13;
   but WITHOUT ANY WARRANTY; without even the implied warranty of&#13;
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&#13;
   GNU General Public License for more details.&#13;
&#13;
   You should have received a copy of the GNU General Public License&#13;
   along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.  */&#13;
&#13;
pragma solidity ^0.4.18;&#13;
&#13;
library SafeMath {&#13;
  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {&#13;
    c = a + b;&#13;
&#13;
    assert (c &gt;= a);&#13;
  }&#13;
&#13;
  function sub(uint256 a, uint256 b) internal pure returns (uint256 c) {&#13;
    assert(b &lt;= a);&#13;
&#13;
    c = a - b;&#13;
  }&#13;
&#13;
  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {&#13;
    c = a * b;&#13;
&#13;
    assert (c / a == b);&#13;
  }&#13;
&#13;
  function div(uint256 a, uint256 b) internal pure returns (uint256 c) {&#13;
    c = a / b;&#13;
  }&#13;
}&#13;
&#13;
contract ERC20MintableToken {&#13;
  using SafeMath for uint256;&#13;
&#13;
  address public owner;&#13;
&#13;
  Minter public minter;&#13;
&#13;
  string constant public name = "PayAll";&#13;
&#13;
  string constant public symbol = "PLL";&#13;
&#13;
  uint8 constant public decimals = 0;&#13;
&#13;
  uint256 public totalSupply;&#13;
&#13;
  mapping (address =&gt; uint256) public balanceOf;&#13;
&#13;
  mapping (address =&gt; mapping (address =&gt; uint256)) public allowance;&#13;
&#13;
  event Transfer(address indexed _oldTokensHolder,&#13;
                 address indexed _newTokensHolder, uint256 _tokensNumber);&#13;
&#13;
  //https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729&#13;
  event Transfer(address indexed _tokensSpender,&#13;
                 address indexed _oldTokensHolder,&#13;
                 address indexed _newTokensHolder, uint256 _tokensNumber);&#13;
&#13;
  event Approval(address indexed _tokensHolder, address indexed _tokensSpender,&#13;
                 uint256 _newTokensNumber);&#13;
&#13;
  //https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729&#13;
  event Approval(address indexed _tokensHolder, address indexed _tokensSpender,&#13;
                 uint256 _oldTokensNumber, uint256 _newTokensNumber);&#13;
&#13;
  modifier onlyOwner {&#13;
    require (owner == msg.sender);&#13;
&#13;
    _;&#13;
  }&#13;
&#13;
  modifier onlyMinter {&#13;
    require (minter == msg.sender);&#13;
&#13;
    _;&#13;
  }&#13;
&#13;
  //https://vessenes.com/the-erc20-short-address-attack-explained&#13;
  //https://blog.golemproject.net/how-to-find-10m-by-just-reading-blockchain-6ae9d39fcd95&#13;
  //https://ericrafaloff.com/analyzing-the-erc20-short-address-attack&#13;
  modifier checkPayloadSize(uint256 size) {&#13;
     require (msg.data.length == size + 4);&#13;
&#13;
     _;&#13;
  }&#13;
&#13;
  function setOwner(address _owner) public onlyOwner {&#13;
    uint256 _allowance = allowance[this][owner];&#13;
&#13;
    _approve(this, owner, 0);&#13;
&#13;
    owner = _owner;&#13;
&#13;
    _approve(this, owner, _allowance);&#13;
  }&#13;
&#13;
  function setMinter(Minter _minter) public onlyOwner {&#13;
    uint256 _allowance = allowance[this][minter];&#13;
&#13;
    _approve(this, minter, 0);&#13;
&#13;
    minter = _minter;&#13;
&#13;
    _approve(this, minter, _allowance);&#13;
  }&#13;
&#13;
  function ERC20MintableToken(Minter _minter) public {&#13;
    owner = tx.origin;&#13;
    minter = _minter;&#13;
  }&#13;
&#13;
  function _transfer(address _oldTokensHolder, address _newTokensHolder,&#13;
                     uint256 _tokensNumber) private {&#13;
    balanceOf[_oldTokensHolder] =&#13;
      balanceOf[_oldTokensHolder].sub(_tokensNumber);&#13;
&#13;
    balanceOf[_newTokensHolder] =&#13;
      balanceOf[_newTokensHolder].add(_tokensNumber);&#13;
&#13;
    Transfer(_oldTokensHolder, _newTokensHolder, _tokensNumber);&#13;
  }&#13;
&#13;
  //https://vessenes.com/the-erc20-short-address-attack-explained&#13;
  //https://blog.golemproject.net/how-to-find-10m-by-just-reading-blockchain-6ae9d39fcd95&#13;
  //https://ericrafaloff.com/analyzing-the-erc20-short-address-attack&#13;
  function transfer(address _newTokensHolder, uint256 _tokensNumber) public&#13;
                   checkPayloadSize(2 * 32) returns (bool) {&#13;
    _transfer(msg.sender, _newTokensHolder, _tokensNumber);&#13;
&#13;
    return true;&#13;
  }&#13;
&#13;
  //https://vessenes.com/the-erc20-short-address-attack-explained&#13;
  //https://blog.golemproject.net/how-to-find-10m-by-just-reading-blockchain-6ae9d39fcd95&#13;
  //https://ericrafaloff.com/analyzing-the-erc20-short-address-attack&#13;
  //https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729&#13;
  function transferFrom(address _oldTokensHolder, address _newTokensHolder,&#13;
                        uint256 _tokensNumber) public checkPayloadSize(3 * 32)&#13;
                       returns (bool) {&#13;
    allowance[_oldTokensHolder][msg.sender] =&#13;
      allowance[_oldTokensHolder][msg.sender].sub(_tokensNumber);&#13;
&#13;
    _transfer(_oldTokensHolder, _newTokensHolder, _tokensNumber);&#13;
&#13;
    Transfer(msg.sender, _oldTokensHolder, _newTokensHolder, _tokensNumber);&#13;
&#13;
    return true;&#13;
  }&#13;
&#13;
  function _approve(address _tokensHolder, address _tokensSpender,&#13;
                    uint256 _newTokensNumber) private {&#13;
    allowance[_tokensHolder][_tokensSpender] = _newTokensNumber;&#13;
&#13;
    Approval(msg.sender, _tokensSpender, _newTokensNumber);&#13;
  }&#13;
&#13;
  //https://vessenes.com/the-erc20-short-address-attack-explained&#13;
  //https://blog.golemproject.net/how-to-find-10m-by-just-reading-blockchain-6ae9d39fcd95&#13;
  //https://ericrafaloff.com/analyzing-the-erc20-short-address-attack&#13;
  //https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729&#13;
  function approve(address _tokensSpender, uint256 _newTokensNumber) public&#13;
                  checkPayloadSize(2 * 32) returns (bool) {&#13;
    require (allowance[msg.sender][_tokensSpender] == 0 ||&#13;
             _newTokensNumber == 0);&#13;
&#13;
    _approve(msg.sender, _tokensSpender, _newTokensNumber);&#13;
&#13;
    return true;&#13;
  }&#13;
&#13;
  //https://vessenes.com/the-erc20-short-address-attack-explained&#13;
  //https://blog.golemproject.net/how-to-find-10m-by-just-reading-blockchain-6ae9d39fcd95&#13;
  //https://ericrafaloff.com/analyzing-the-erc20-short-address-attack&#13;
  //https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729&#13;
  function approve(address _tokensSpender, uint256 _oldTokensNumber,&#13;
                   uint256 _newTokensNumber) public checkPayloadSize(3 * 32)&#13;
                  returns (bool) {&#13;
    require (allowance[msg.sender][_tokensSpender] == _oldTokensNumber);&#13;
&#13;
    _approve(msg.sender, _tokensSpender, _newTokensNumber);&#13;
&#13;
    Approval(msg.sender, _tokensSpender, _oldTokensNumber, _newTokensNumber);&#13;
&#13;
    return true;&#13;
  }&#13;
&#13;
  function () public {&#13;
    revert();&#13;
  }&#13;
&#13;
  function mint(uint256 _tokensNumber) public onlyMinter {&#13;
    totalSupply = totalSupply.add(_tokensNumber);&#13;
&#13;
    balanceOf[this] = balanceOf[this].add(_tokensNumber);&#13;
&#13;
    uint256 _allowance = allowance[this][msg.sender].add(_tokensNumber);&#13;
&#13;
    _approve(this, minter, _allowance);&#13;
&#13;
    _approve(this, owner, _allowance);&#13;
  }&#13;
&#13;
  function burnUndistributed() public onlyMinter {&#13;
    _approve(this, minter, 0);&#13;
&#13;
    _approve(this, owner, 0);&#13;
&#13;
    totalSupply = totalSupply.sub(balanceOf[this]);&#13;
&#13;
    balanceOf[this] = 0;&#13;
  }&#13;
}&#13;
&#13;
contract Minter {&#13;
  using SafeMath for uint256;&#13;
&#13;
  enum MinterState {&#13;
    PreICOWait,&#13;
    PreICOStarted,&#13;
    ICOWait,&#13;
    ICOStarted,&#13;
    Over&#13;
  }&#13;
&#13;
  struct Tokensale {&#13;
    uint256 startTime;&#13;
    uint256 endTime;&#13;
    uint256 tokensMinimumNumberForBuy;&#13;
    uint256 tokensCost;&#13;
    uint256 tokensNumberForMint;&#13;
    bool tokensMinted;&#13;
    uint256 tokensStepOneBountyTime;&#13;
    uint256 tokensStepTwoBountyTime;&#13;
    uint256 tokensStepThreeBountyTime;&#13;
    uint256 tokensStepFourBountyTime;&#13;
    uint8 tokensStepOneBounty;&#13;
    uint8 tokensStepTwoBounty;&#13;
    uint8 tokensStepThreeBounty;&#13;
    uint8 tokensStepFourBounty;&#13;
  }&#13;
&#13;
  address public owner;&#13;
&#13;
  ERC20MintableToken public token;&#13;
&#13;
  Tokensale public PreICO =&#13;
    Tokensale(1511211600, 1513803600, 150, 340000000000000 wei, 10000000, false,&#13;
              1 weeks, 2 weeks, 3 weeks, 4 weeks + 2 days, 25, 15, 10, 5);&#13;
&#13;
  Tokensale public ICO =&#13;
    Tokensale(1526850000, 1529528400, 150, 340000000000000 wei, 290000000,&#13;
              false, 1 weeks, 2 weeks, 3 weeks, 4 weeks + 3 days, 20, 10, 5, 0);&#13;
&#13;
  bool public paused = false;&#13;
&#13;
  modifier onlyOwner {&#13;
    require (owner == msg.sender);&#13;
&#13;
    _;&#13;
  }&#13;
&#13;
  modifier onlyDuringTokensale {&#13;
    MinterState _minterState_ = _minterState();&#13;
&#13;
    require (_minterState_ == MinterState.PreICOStarted ||&#13;
             _minterState_ == MinterState.ICOStarted);&#13;
&#13;
    _;&#13;
  }&#13;
&#13;
  modifier onlyAfterTokensaleOver {&#13;
    MinterState _minterState_ = _minterState();&#13;
&#13;
    require (_minterState_ == MinterState.Over);&#13;
&#13;
    _;&#13;
  }&#13;
&#13;
  modifier onlyNotPaused {&#13;
    require (!paused);&#13;
&#13;
    _;&#13;
  }&#13;
&#13;
  modifier checkLimitsToBuyTokens {&#13;
    MinterState _minterState_ = _minterState();&#13;
&#13;
    require (_minterState_ == MinterState.PreICOStarted &amp;&amp;&#13;
             PreICO.tokensMinimumNumberForBuy &lt;= msg.value / PreICO.tokensCost ||&#13;
             _minterState_ == MinterState.ICOStarted &amp;&amp;&#13;
             ICO.tokensMinimumNumberForBuy &lt;= msg.value / ICO.tokensCost);&#13;
&#13;
    _;&#13;
  }&#13;
&#13;
  function setOwner(address _owner) public onlyOwner {&#13;
    owner = _owner;&#13;
  }&#13;
&#13;
  function setPaused(bool _paused) public onlyOwner {&#13;
    paused = _paused;&#13;
  }&#13;
&#13;
  function Minter() public {&#13;
    owner = msg.sender;&#13;
    token = new ERC20MintableToken(this);&#13;
  }&#13;
&#13;
  function _minterState() private constant returns (MinterState) {&#13;
    if (PreICO.startTime &gt; now) {&#13;
      return MinterState.PreICOWait;&#13;
    } else if (PreICO.endTime &gt; now) {&#13;
      return MinterState.PreICOStarted;&#13;
    } else if (ICO.startTime &gt; now) {&#13;
      return MinterState.ICOWait;&#13;
    } else if (ICO.endTime &gt; now) {&#13;
      return MinterState.ICOStarted;&#13;
    } else {&#13;
      return MinterState.Over;&#13;
    }&#13;
  }&#13;
&#13;
  function _tokensaleCountTokensNumber(Tokensale _tokensale, uint256 _timestamp,&#13;
                                       uint256 _wei, uint256 _totalTokensNumber,&#13;
                                       uint256 _totalTokensNumberAllowance)&#13;
                                      private pure&#13;
                                      returns (uint256, uint256) {&#13;
    uint256 _tokensNumber = _wei.div(_tokensale.tokensCost);&#13;
&#13;
    require (_tokensNumber &gt;= _tokensale.tokensMinimumNumberForBuy);&#13;
&#13;
    uint256 _aviableTokensNumber =&#13;
      _totalTokensNumber &lt;= _totalTokensNumberAllowance ?&#13;
        _totalTokensNumber : _totalTokensNumberAllowance;&#13;
&#13;
    uint256 _restWei = 0;&#13;
&#13;
    if (_tokensNumber &gt;= _aviableTokensNumber) {&#13;
      uint256 _restTokensNumber = _tokensNumber.sub(_aviableTokensNumber);&#13;
&#13;
      _restWei = _restTokensNumber.mul(_tokensale.tokensCost);&#13;
&#13;
      _tokensNumber = _aviableTokensNumber;&#13;
    } else {&#13;
      uint256 _timePassed = _timestamp.sub(_tokensale.startTime);&#13;
&#13;
      uint256 _tokensNumberBounty = 0;&#13;
&#13;
      if (_timePassed &lt; _tokensale.tokensStepOneBountyTime) {&#13;
        _tokensNumberBounty = _tokensNumber.mul(_tokensale.tokensStepOneBounty)&#13;
                                           .div(100);&#13;
      } else if (_timePassed &lt; _tokensale.tokensStepTwoBountyTime) {&#13;
        _tokensNumberBounty = _tokensNumber.mul(_tokensale.tokensStepTwoBounty)&#13;
                                           .div(100);&#13;
      } else if (_timePassed &lt; _tokensale.tokensStepThreeBountyTime) {&#13;
        _tokensNumberBounty =&#13;
          _tokensNumber.mul(_tokensale.tokensStepThreeBounty).div(100);&#13;
      } else if (_timePassed &lt; _tokensale.tokensStepFourBountyTime) {&#13;
        _tokensNumberBounty = _tokensNumber.mul(_tokensale.tokensStepFourBounty)&#13;
                                           .div(100);&#13;
      }&#13;
&#13;
      _tokensNumber = _tokensNumber.add(_tokensNumberBounty);&#13;
&#13;
      if (_tokensNumber &gt; _aviableTokensNumber) {&#13;
        _tokensNumber = _aviableTokensNumber;&#13;
      }&#13;
    }&#13;
&#13;
    return (_tokensNumber, _restWei);&#13;
  }&#13;
&#13;
  function _tokensaleStart(Tokensale storage _tokensale) private {&#13;
    if (!_tokensale.tokensMinted) {&#13;
      token.mint(_tokensale.tokensNumberForMint);&#13;
&#13;
      _tokensale.tokensMinted = true;&#13;
    }&#13;
&#13;
    uint256 _totalTokensNumber = token.balanceOf(token);&#13;
&#13;
    uint256 _totalTokensNumberAllowance = token.allowance(token, this);&#13;
&#13;
    var (_tokensNumber, _restWei) =&#13;
      _tokensaleCountTokensNumber(_tokensale, now, msg.value,&#13;
                                  _totalTokensNumber,&#13;
                                  _totalTokensNumberAllowance);&#13;
&#13;
    token.transferFrom(token, msg.sender, _tokensNumber);&#13;
&#13;
    if (_restWei &gt; 0) {&#13;
      msg.sender.transfer(_restWei);&#13;
    }&#13;
  }&#13;
&#13;
  function _tokensaleSelect() private constant returns (Tokensale storage) {&#13;
    MinterState _minterState_ = _minterState();&#13;
&#13;
    if (_minterState_ == MinterState.PreICOStarted) {&#13;
      return PreICO;&#13;
    } else if (_minterState_ == MinterState.ICOStarted) {&#13;
      return ICO;&#13;
    } else {&#13;
      revert();&#13;
    }&#13;
  }&#13;
&#13;
  function () public payable onlyDuringTokensale onlyNotPaused&#13;
    checkLimitsToBuyTokens {&#13;
    Tokensale storage _tokensale = _tokensaleSelect();&#13;
&#13;
    _tokensaleStart(_tokensale);&#13;
  }&#13;
&#13;
  function mint(uint256 _tokensNumber) public onlyOwner onlyDuringTokensale {&#13;
    token.mint(_tokensNumber);&#13;
  }&#13;
&#13;
  function burnUndistributed() public onlyAfterTokensaleOver {&#13;
    token.burnUndistributed();&#13;
  }&#13;
&#13;
  function withdraw() public onlyOwner {&#13;
    msg.sender.transfer(this.balance);&#13;
  }&#13;
}