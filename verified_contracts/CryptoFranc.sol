pragma solidity "0.4.25";
// produced by the Solididy File Flattener (c) David Appleton 2018
// contact : <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="680c091e0d28090307050a09460b0705">[email protected]</a>&#13;
// released under Apache 2.0 licence&#13;
// input  C:\projects\BTCS.CHFToken\contracts\Chftoken\CryptoFranc.sol&#13;
// flattened :  Wednesday, 24-Oct-18 14:07:18 UTC&#13;
contract InterestRateInterface {&#13;
&#13;
    uint256 public constant SCALEFACTOR = 1e18;&#13;
&#13;
    /// @notice get compounding level for currenct day&#13;
    function getCurrentCompoundingLevel() public view returns (uint256);&#13;
&#13;
    /// @notice get compounding level for _date `_date`&#13;
    /// @param _date The date &#13;
    function getCompoundingLevelDate(uint256 _date) public view returns (uint256);&#13;
&#13;
}&#13;
library SafeMath {&#13;
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
        uint256 c = a * b;&#13;
        assert(a == 0 || c / a == b);&#13;
        return c;&#13;
    }&#13;
&#13;
    function div(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
        // assert(b &gt; 0); // Solidity automatically throws when dividing by 0&#13;
        uint256 c = a / b;&#13;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold&#13;
        return c;&#13;
    }&#13;
&#13;
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
        assert(b &lt;= a);&#13;
        return a - b;&#13;
    }&#13;
&#13;
    function add(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
        uint256 c = a + b;&#13;
        assert(c &gt;= a);&#13;
        return c;&#13;
    }&#13;
}&#13;
&#13;
contract ERC20Interface {&#13;
    /// total amount of tokens&#13;
    function totalSupply() public view returns(uint256 supply);&#13;
&#13;
    /// @param _owner The address from which the balance will be retrieved&#13;
    /// @return The balance&#13;
    function balanceOf(address _owner) public view returns (uint256 balance);&#13;
&#13;
    /// @notice send `_value` token to `_to` from `msg.sender`&#13;
    /// @param _to The address of the recipient&#13;
    /// @param _value The amount of token to be transferred&#13;
    /// @return Whether the transfer was successful or not&#13;
    function transfer(address _to, uint256 _value) public returns (bool success);&#13;
&#13;
    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`&#13;
    /// @param _from The address of the sender&#13;
    /// @param _to The address of the recipient&#13;
    /// @param _value The amount of token to be transferred&#13;
    /// @return Whether the transfer was successful or not&#13;
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);&#13;
&#13;
    /// @notice `msg.sender` approves `_spender` to spend `_value` tokens&#13;
    /// @param _spender The address of the account able to transfer the tokens&#13;
    /// @param _value The amount of tokens to be approved for transfer&#13;
    /// @return Whether the approval was successful or not&#13;
    function approve(address _spender, uint256 _value) public returns (bool success);&#13;
&#13;
    /// @param _owner The address of the account owning tokens&#13;
    /// @param _spender The address of the account able to transfer the tokens&#13;
    /// @return Amount of remaining tokens allowed to spent&#13;
    function allowance(address _owner, address _spender) public view returns (uint256 remaining);&#13;
&#13;
    // EVENTS&#13;
    &#13;
    // solhint-disable-next-line no-simple-event-func-name&#13;
    event Transfer(address indexed _from, address indexed _to, uint256 _value);&#13;
    &#13;
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);&#13;
}&#13;
contract Ownable {&#13;
    address public owner;&#13;
    address public newOwner;&#13;
&#13;
    // MODIFIERS&#13;
&#13;
    /// @dev Throws if called by any account other than the owner.&#13;
    modifier onlyOwner() {&#13;
        require(msg.sender == owner, "Only Owner");&#13;
        _;&#13;
    }&#13;
&#13;
    /// @dev Throws if called by any account other than the new owner.&#13;
    modifier onlyNewOwner() {&#13;
        require(msg.sender == newOwner, "Only New Owner");&#13;
        _;&#13;
    }&#13;
&#13;
    modifier notNull(address _address) {&#13;
        require(_address != 0,"address is Null");&#13;
        _;&#13;
    }&#13;
&#13;
    // CONSTRUCTORS&#13;
&#13;
    /**&#13;
    * @dev The Ownable constructor sets the original `owner` of the contract to the sender&#13;
    * account.&#13;
    */&#13;
    constructor() public {&#13;
        owner = msg.sender;&#13;
    }&#13;
&#13;
    /// @dev Allows the current owner to transfer control of the contract to a newOwner.&#13;
    /// @param _newOwner The address to transfer ownership to.&#13;
    &#13;
    function transferOwnership(address _newOwner) public notNull(_newOwner) onlyOwner {&#13;
        newOwner = _newOwner;&#13;
    }&#13;
&#13;
    /// @dev Allow the new owner to claim ownership and so proving that the newOwner is valid.&#13;
    function acceptOwnership() public onlyNewOwner {&#13;
        address oldOwner = owner;&#13;
        owner = newOwner;&#13;
        newOwner = address(0);&#13;
        emit OwnershipTransferred(oldOwner, owner);&#13;
    }&#13;
&#13;
    // EVENTS&#13;
    &#13;
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);&#13;
}&#13;
&#13;
contract InterestRateNone is InterestRateInterface {&#13;
    &#13;
    /// @notice get compounding level for currenct day&#13;
    function getCurrentCompoundingLevel() public view returns (uint256) {&#13;
        return SCALEFACTOR;&#13;
    }&#13;
&#13;
    /// @notice get compounding level for day `_date`&#13;
    /// param _date The daynumber &#13;
    function getCompoundingLevelDate(uint256 /* _date */) public view returns (uint256) {&#13;
        return SCALEFACTOR;&#13;
    }&#13;
&#13;
}&#13;
contract MigrationAgent is Ownable {&#13;
&#13;
    address public migrationToContract; // the contract to migrate to&#13;
    address public migrationFromContract; // the conttactto migate from&#13;
&#13;
    // MODIFIERS&#13;
    &#13;
    modifier onlyMigrationFromContract() {&#13;
        require(msg.sender == migrationFromContract, "Only from migration contract");&#13;
        _;&#13;
    }&#13;
    // EXTERNAL FUNCTIONS&#13;
&#13;
    // PUBLIC FUNCTIONS&#13;
&#13;
    /// @dev set contract to migrate to &#13;
    /// @param _toContract Then contract address to migrate to&#13;
    function startMigrateToContract(address _toContract) public onlyOwner {&#13;
        migrationToContract = _toContract;&#13;
        require(MigrationAgent(migrationToContract).isMigrationAgent(), "not a migratable contract");&#13;
        emit StartMigrateToContract(address(this), _toContract);&#13;
    }&#13;
&#13;
    /// @dev set contract to migrate from&#13;
    /// @param _fromConstract Then contract address to migrate from&#13;
    function startMigrateFromContract(address _fromConstract) public onlyOwner {&#13;
        migrationFromContract = _fromConstract;&#13;
        require(MigrationAgent(migrationFromContract).isMigrationAgent(), "not a migratable contract");&#13;
        emit StartMigrateFromContract(_fromConstract, address(this));&#13;
    }&#13;
&#13;
    /// @dev Each user calls the migrate function on the original contract to migrate the users’ tokens to the migration agent migrateFrom on the `migrationToContract` contract&#13;
    function migrate() public;   &#13;
&#13;
    /// @dev migrageFrom is called from the migrating contract `migrationFromContract`&#13;
    /// @param _from The account to be migrated into new contract&#13;
    /// @param _value The token balance to be migrated&#13;
    function migrateFrom(address _from, uint256 _value) public returns(bool);&#13;
&#13;
    /// @dev is a valid migration agent&#13;
    /// @return true if contract is a migratable contract&#13;
    function isMigrationAgent() public pure returns(bool) {&#13;
        return true;&#13;
    }&#13;
&#13;
    // INTERNAL FUNCTIONS&#13;
&#13;
    // PRIVATE FUNCTIONS&#13;
&#13;
    // EVENTS&#13;
&#13;
    event StartMigrateToContract(address indexed fromConstract, address indexed toContract);&#13;
&#13;
    event StartMigrateFromContract(address indexed fromConstract, address indexed toContract);&#13;
&#13;
    event MigratedTo(address indexed owner, address indexed _contract, uint256 value);&#13;
&#13;
    event MigratedFrom(address indexed owner, address indexed _contract, uint256 value);&#13;
}&#13;
contract Pausable is Ownable {&#13;
&#13;
    bool public paused = false;&#13;
&#13;
    // MODIFIERS&#13;
&#13;
    /**&#13;
    * @dev Modifier to make a function callable only when the contract is not paused.&#13;
    */&#13;
    modifier whenNotPaused() {&#13;
        require(!paused, "only when not paused");&#13;
        _;&#13;
    }&#13;
&#13;
    /**&#13;
    * @dev Modifier to make a function callable only when the contract is paused.&#13;
    */&#13;
    modifier whenPaused() {&#13;
        require(paused, "only when paused");&#13;
        _;&#13;
    }&#13;
&#13;
    /**&#13;
    * @dev called by the owner to pause, triggers stopped state&#13;
    */&#13;
    function pause() public onlyOwner whenNotPaused {&#13;
        paused = true;&#13;
        emit Pause();&#13;
    }&#13;
&#13;
    /**&#13;
    * @dev called by the owner to unpause, returns to normal state&#13;
    */&#13;
    function unpause() public onlyOwner whenPaused {&#13;
        paused = false;&#13;
        emit Unpause();&#13;
    }&#13;
&#13;
    // EVENTS&#13;
&#13;
    event Pause();&#13;
&#13;
    event Unpause();&#13;
}&#13;
&#13;
contract Operator is Ownable {&#13;
&#13;
    address public operator;&#13;
&#13;
    // MODIFIERS&#13;
&#13;
    /**&#13;
     * @dev modifier check for operator&#13;
     */&#13;
    modifier onlyOperator {&#13;
        require(msg.sender == operator, "Only Operator");&#13;
        _;&#13;
    }&#13;
&#13;
    // CONSTRUCTORS&#13;
&#13;
    constructor() public {&#13;
        operator = msg.sender;&#13;
    }&#13;
    /**&#13;
     * @dev Transfer operator to `newOperator`.&#13;
     *&#13;
     * @param _newOperator   The address of the new operator&#13;
     * @return balance Balance of the `_owner`.&#13;
     */&#13;
    function transferOperator(address _newOperator) public notNull(_newOperator) onlyOwner {&#13;
        operator = _newOperator;&#13;
        emit TransferOperator(operator, _newOperator);&#13;
    }&#13;
&#13;
    // EVENTS&#13;
    &#13;
    event TransferOperator(address indexed from, address indexed to);&#13;
}&#13;
&#13;
contract ERC20Token is Ownable, ERC20Interface {&#13;
&#13;
    using SafeMath for uint256;&#13;
&#13;
    mapping(address =&gt; uint256) internal balances;&#13;
    mapping (address =&gt; mapping (address =&gt; uint256)) internal allowed;&#13;
&#13;
    // CONSTRUCTORS&#13;
&#13;
    constructor() public {&#13;
    }&#13;
&#13;
    // EXTERNAL FUNCTIONS&#13;
&#13;
    // PUBLIC FUNCTIONS&#13;
&#13;
    /// @notice send `_value` token to `_to` from `msg.sender`&#13;
    /// @param _to The address of the recipient&#13;
    /// @param _value The amount of token to be transferred&#13;
    /// @return Whether the transfer was successful or not&#13;
    function transfer(address _to, uint256 _value) public returns (bool success) {&#13;
&#13;
        return transferInternal(msg.sender, _to, _value);&#13;
    }&#13;
&#13;
    /* ALLOW FUNCTIONS */&#13;
&#13;
    /**&#13;
    * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.&#13;
    *&#13;
    * Beware that changing an allowance with this method brings the risk that someone may use both the old&#13;
    * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this&#13;
    * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:&#13;
    * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729&#13;
    */&#13;
   &#13;
    /// @notice `msg.sender` approves `_spender` to spend `_value` tokens   &#13;
    /// @param _spender The address of the account able to transfer the tokens&#13;
    /// @param _value The amount of tokens to be approved for transfer&#13;
    /// @return Whether the approval was successful or not&#13;
    function approve(address _spender, uint256 _value) public notNull(_spender) returns (bool success) {&#13;
        allowed[msg.sender][_spender] = _value;&#13;
        emit Approval(msg.sender, _spender, _value);&#13;
        return true;&#13;
    }&#13;
&#13;
    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`&#13;
    /// @param _from The address of the sender&#13;
    /// @param _to The address of the recipient&#13;
    /// @param _value The amount of token to be transferred&#13;
    /// @return Whether the transfer was successful or not&#13;
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {&#13;
        require(_value &lt;= allowed[_from][msg.sender], "insufficient tokens");&#13;
&#13;
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);&#13;
        return transferInternal(_from, _to, _value);&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Returns balance of the `_owner`.&#13;
     *&#13;
     * @param _owner   The address whose balance will be returned.&#13;
     * @return balance Balance of the `_owner`.&#13;
     */&#13;
    function balanceOf(address _owner) public view returns (uint256) {&#13;
        return balances[_owner];&#13;
    }&#13;
&#13;
    /// @param _owner The address of the account owning tokens&#13;
    /// @param _spender The address of the account able to transfer the tokens&#13;
    /// @return Amount of remaining tokens allowed to spent&#13;
    function allowance(address _owner, address _spender) public view returns (uint256) {&#13;
        return allowed[_owner][_spender];&#13;
    }&#13;
&#13;
    // INTERNAL FUNCTIONS&#13;
&#13;
    /// @notice internal send `_value` token to `_to` from `_from` &#13;
    /// @param _from The address of the sender (null check performed in subTokens)&#13;
    /// @param _to The address of the recipient (null check performed in addTokens)&#13;
    /// @param _value The amount of token to be transferred &#13;
    /// @return Whether the transfer was successful or not&#13;
    function transferInternal(address _from, address _to, uint256 _value) internal returns (bool) {&#13;
        uint256 value = subTokens(_from, _value);&#13;
        addTokens(_to, value);&#13;
        emit Transfer(_from, _to, value);&#13;
        return true;&#13;
    }&#13;
   &#13;
    /// @notice add tokens `_value` tokens to `owner`&#13;
    /// @param _owner The address of the account&#13;
    /// @param _value The amount of tokens to be added&#13;
    function addTokens(address _owner, uint256 _value) internal;&#13;
&#13;
    /// @notice subtract tokens `_value` tokens from `owner`&#13;
    /// @param _owner The address of the account&#13;
    /// @param _value The amount of tokens to be subtracted&#13;
    function subTokens(address _owner, uint256 _value) internal returns (uint256 _valueDeducted );&#13;
    &#13;
    /// @notice set balance of account `owner` to `_value`&#13;
    /// @param _owner The address of the account&#13;
    /// @param _value The new balance &#13;
    function setBalance(address _owner, uint256 _value) internal notNull(_owner) {&#13;
        balances[_owner] = _value;&#13;
    }&#13;
&#13;
    // PRIVATE FUNCTIONS&#13;
&#13;
}&#13;
&#13;
contract PausableToken is ERC20Token, Pausable {&#13;
&#13;
    /// @notice send `_value` token to `_to` from `msg.sender`&#13;
    /// @param _to The address of the recipient&#13;
    /// @param _value The amount of token to be transferred&#13;
    /// @return Whether the transfer was successful or not&#13;
    function transfer(address _to, uint256 _value) public whenNotPaused returns (bool success) {&#13;
        return super.transfer(_to, _value);&#13;
    }&#13;
&#13;
    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`&#13;
    /// @param _from The address of the sender&#13;
    /// @param _to The address of the recipient&#13;
    /// @param _value The amount of token to be transferred&#13;
    /// @return Whether the transfer was successful or not&#13;
    function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool success) {&#13;
        return super.transferFrom(_from, _to, _value);&#13;
    }&#13;
&#13;
    /// @notice `msg.sender` approves `_spender` to spend `_value` tokens&#13;
    /// @param _spender The address of the account able to transfer the tokens&#13;
    /// @param _value The amount of tokens to be approved for transfer&#13;
    /// @return Whether the approval was successful or not&#13;
    function approve(address _spender, uint256 _value) public whenNotPaused returns (bool success) {&#13;
        return super.approve(_spender, _value);&#13;
    }&#13;
}&#13;
&#13;
contract MintableToken is PausableToken&#13;
{&#13;
    using SafeMath for uint256;&#13;
&#13;
    address public minter; // minter&#13;
&#13;
    uint256 internal minted; // total minted tokens&#13;
    uint256 internal burned; // total burned tokens&#13;
&#13;
    // MODIFIERS&#13;
&#13;
    modifier onlyMinter {&#13;
        assert(msg.sender == minter);&#13;
        _; &#13;
    }&#13;
&#13;
    constructor() public {&#13;
        minter = msg.sender;   // Set the owner to minter&#13;
    }&#13;
&#13;
    // EXTERNAL FUNCTIONS&#13;
&#13;
    // PUBLIC FUNCTIONS&#13;
&#13;
    /// @dev  mint tokens to address&#13;
    /// @notice mint `_value` token to `_to`&#13;
    /// @param _to The address of the recipient&#13;
    /// @param _value The amount of token to be minted&#13;
    function mint(address _to, uint256 _value) public notNull(_to) onlyMinter {&#13;
        addTokens(_to, _value);&#13;
        notifyMinted(_to, _value);&#13;
    }&#13;
&#13;
    /// @dev burn tokens, e.g. when migrating&#13;
    /// @notice burn `_value` token to `_to`&#13;
    /// @param _value The amount of token to be burned from the callers account&#13;
    function burn(uint256 _value) public whenNotPaused {&#13;
        uint256 value = subTokens(msg.sender, _value);&#13;
        notifyBurned(msg.sender, value);&#13;
    }&#13;
&#13;
    /// @dev transfer minter to new address&#13;
    /// @notice transfer minter addres from  `minter` to `_newMinter`&#13;
    /// @param _newMinter The address of the recipient&#13;
    function transferMinter(address _newMinter) public notNull(_newMinter) onlyOwner {&#13;
        address oldMinter = minter;&#13;
        minter = _newMinter;&#13;
        emit TransferMinter(oldMinter, _newMinter);&#13;
    }&#13;
&#13;
    // INTERNAL FUNCTIONS&#13;
&#13;
    /// @dev update burned and emit Transfer event of burned tokens&#13;
    /// @notice burn `_value` token from `_owner`&#13;
    /// @param _owner The address of the owner&#13;
    /// @param _value The amount of token burned&#13;
    function notifyBurned(address _owner, uint256 _value) internal {&#13;
        burned = burned.add(_value);&#13;
        emit Transfer(_owner, address(0), _value);&#13;
    }&#13;
&#13;
    /// @dev update burned and emit Transfer event of burned tokens&#13;
    /// @notice mint `_value` token to `_to`&#13;
    /// @param _to The address of the recipient&#13;
    /// @param _value The amount of token minted&#13;
    function notifyMinted(address _to, uint256 _value) internal {&#13;
        minted = minted.add(_value);&#13;
        emit Transfer(address(0), _to, _value);&#13;
    }&#13;
&#13;
    /// @dev helper function to update token supply state and emit events &#13;
    /// @notice checkMintOrBurn for account `_owner` tokens chainging  from `_balanceBefore` to `_balanceAfter`&#13;
    /// @param _owner The address of the owner&#13;
    /// @param _balanceBefore The balance before the transaction&#13;
    /// @param _balanceAfter The balance after the tranaaction&#13;
    function checkMintOrBurn(address _owner, uint256 _balanceBefore, uint256 _balanceAfter) internal {&#13;
        if (_balanceBefore &gt; _balanceAfter) {&#13;
            uint256 burnedTokens = _balanceBefore.sub(_balanceAfter);&#13;
            notifyBurned(_owner, burnedTokens);&#13;
        } else if (_balanceBefore &lt; _balanceAfter) {&#13;
            uint256 mintedTokens = _balanceAfter.sub(_balanceBefore);&#13;
            notifyMinted(_owner, mintedTokens);&#13;
        }&#13;
    }&#13;
&#13;
    /// @dev return total amount of tokens&#13;
    function totalSupply() public view returns(uint256 supply) {&#13;
        return minted.sub(burned);&#13;
    }&#13;
&#13;
    // PRIVATE FUNCTIONS&#13;
&#13;
    // EVENTS&#13;
    &#13;
    event TransferMinter(address indexed from, address indexed to);&#13;
}&#13;
&#13;
contract CryptoFranc is MintableToken, MigrationAgent, Operator, InterestRateNone {&#13;
&#13;
    using SafeMath for uint256;&#13;
&#13;
    string constant public name = "CryptoFranc";&#13;
    string constant public symbol = "XCHF";&#13;
    uint256 constant public decimals = 18;&#13;
    string constant public version = "1.0.0.0";&#13;
    uint256 public dustAmount;&#13;
&#13;
    // Changes as the token is converted to the next vintage&#13;
    string public currentFullName;&#13;
    string public announcedFullName;&#13;
    uint256 public currentMaturityDate;&#13;
    uint256 public announcedMaturityDate;&#13;
    uint256 public currentTermEndDate;&#13;
    uint256 public announcedTermEndDate;&#13;
    InterestRateInterface public currentTerms;&#13;
    InterestRateInterface public announcedTerms;&#13;
&#13;
    mapping(address =&gt; uint256) internal compoundedInterestFactor;&#13;
&#13;
    // CONSTRUCTORS&#13;
&#13;
    constructor(string _initialFullName, uint256 _dustAmount) public {&#13;
        // initially, there is no interest. This contract has an interest-free default implementation&#13;
        // of the InterestRateInterface. Having this internalized saves gas in comparison to having an&#13;
        // external, separate smart contract.&#13;
        currentFullName = _initialFullName;&#13;
        announcedFullName = _initialFullName;&#13;
        dustAmount = _dustAmount;    &#13;
        currentTerms = this;&#13;
        announcedTerms = this;&#13;
        announcedMaturityDate = block.timestamp;&#13;
        announcedTermEndDate = block.timestamp;&#13;
    }&#13;
&#13;
    // EXTERNAL FUNCTIONS&#13;
&#13;
    // PUBLIC FUNCTIONS&#13;
&#13;
    /// @dev Invoked by the issuer to convert all the outstanding tokens into bonds of the latest vintage.&#13;
    /// @param _newName Name of announced bond&#13;
    /// @param _newTerms Address of announced bond&#13;
    /// @param _newMaturityDate Maturity Date of announced bond&#13;
    /// @param _newTermEndDate End Date of announced bond&#13;
    function announceRollover(string _newName, address _newTerms, uint256 _newMaturityDate, uint256 _newTermEndDate) public notNull(_newTerms) onlyOperator {&#13;
        // a new term can not be announced before the current is expired&#13;
        require(block.timestamp &gt;= announcedMaturityDate);&#13;
&#13;
        // for test purposes&#13;
        uint256 newMaturityDate;&#13;
        if (_newMaturityDate == 0)&#13;
            newMaturityDate = block.timestamp;&#13;
        else&#13;
            newMaturityDate = _newMaturityDate;&#13;
&#13;
        // new newMaturityDate must be at least or greater than the existing announced terms end date&#13;
        require(newMaturityDate &gt;= announcedTermEndDate);&#13;
&#13;
        //require new term dates not too far in the future&#13;
        //this is to prevent severe operator time calculaton errors&#13;
        require(newMaturityDate &lt;= block.timestamp.add(100 days),"sanitycheck on newMaturityDate");&#13;
        require(newMaturityDate &lt;= _newTermEndDate,"term must start before it ends");&#13;
        require(_newTermEndDate &lt;= block.timestamp.add(200 days),"sanitycheck on newTermEndDate");&#13;
&#13;
        InterestRateInterface terms = InterestRateInterface(_newTerms);&#13;
        &#13;
        // ensure that _newTerms begins at the compoundLevel that the announcedTerms ends&#13;
        // they must align&#13;
        uint256 newBeginLevel = terms.getCompoundingLevelDate(newMaturityDate);&#13;
        uint256 annEndLevel = announcedTerms.getCompoundingLevelDate(newMaturityDate);&#13;
        require(annEndLevel == newBeginLevel,"new initialCompoundingLevel &lt;&gt; old finalCompoundingLevel");&#13;
&#13;
        //rollover&#13;
        currentTerms = announcedTerms;&#13;
        currentFullName = announcedFullName;&#13;
        currentMaturityDate = announcedMaturityDate;&#13;
        currentTermEndDate = announcedTermEndDate;&#13;
        announcedTerms = terms;&#13;
        announcedFullName = _newName;&#13;
        announcedMaturityDate = newMaturityDate;&#13;
        announcedTermEndDate = _newTermEndDate;&#13;
&#13;
        emit AnnounceRollover(_newName, _newTerms, newMaturityDate, _newTermEndDate);&#13;
    }&#13;
&#13;
    /// @dev collectInterest is called to update the internal state of `_owner` balance and force a interest payment&#13;
    /// This function does not change the effective amount of the `_owner` as returned by balanceOf&#13;
    /// and thus, can be called by anyone willing to pay for the gas.&#13;
    /// The designed usage for this function is to allow the CryptoFranc owner to collect interest from inactive accounts, &#13;
    /// since interest collection is updated automatically in normal transfers&#13;
    /// calling collectInterest is functional equivalent to transfer 0 tokens to `_owner`&#13;
    /// @param _owner The account being updated&#13;
    function collectInterest( address _owner) public notNull(_owner) whenNotPaused {&#13;
        uint256 rawBalance = super.balanceOf(_owner);&#13;
        uint256 adjustedBalance = getAdjustedValue(_owner);&#13;
        setBalance(_owner, adjustedBalance);&#13;
        checkMintOrBurn(_owner, rawBalance, adjustedBalance);&#13;
    }&#13;
&#13;
    /*&#13;
        MIGRATE FUNCTIONS&#13;
     */&#13;
    // safe migrate function&#13;
    /// @dev migrageFrom is called from the migrating contract `migrationFromContract`&#13;
    /// @param _from The account to be migrated into new contract&#13;
    /// @param _value The token balance to be migrated&#13;
    function migrateFrom(address _from, uint256 _value) public onlyMigrationFromContract returns(bool) {&#13;
        addTokens(_from, _value);&#13;
        notifyMinted(_from, _value);&#13;
&#13;
        emit MigratedFrom(_from, migrationFromContract, _value);&#13;
        return true;&#13;
    }&#13;
&#13;
    /// @dev Each user calls the migrate function on the original contract to migrate the users’ tokens to the migration agent migrateFrom on the `migrationToContract` contract&#13;
    function migrate() public whenNotPaused {&#13;
        require(migrationToContract != 0, "not in migration mode"); // revert if not in migrate mode&#13;
        uint256 value = balanceOf(msg.sender);&#13;
        require (value &gt; 0, "no balance"); // revert if not value left to transfer&#13;
        value = subTokens(msg.sender, value);&#13;
        notifyBurned(msg.sender, value);&#13;
        require(MigrationAgent(migrationToContract).migrateFrom(msg.sender, value)==true, "migrateFrom must return true");&#13;
&#13;
        emit MigratedTo(msg.sender, migrationToContract, value);&#13;
    }&#13;
&#13;
    /*&#13;
        Helper FUNCTIONS&#13;
    */&#13;
&#13;
    /// @dev helper function to return foreign tokens accidental send to contract address&#13;
    /// @param _tokenaddress Address of foreign ERC20 contract&#13;
    /// @param _to Address to send foreign tokens to&#13;
    function refundForeignTokens(address _tokenaddress,address _to) public notNull(_to) onlyOperator {&#13;
        ERC20Interface token = ERC20Interface(_tokenaddress);&#13;
        // transfer current balance for this contract to _to  in token contract&#13;
        token.transfer(_to, token.balanceOf(this));&#13;
    }&#13;
&#13;
    /// @dev get fullname of active interest contract&#13;
    function getFullName() public view returns (string) {&#13;
        if ((block.timestamp &lt;= announcedMaturityDate))&#13;
            return currentFullName;&#13;
        else&#13;
            return announcedFullName;&#13;
    }&#13;
&#13;
    /// @dev get compounding level of an owner account&#13;
    /// @param _owner tokens address&#13;
    /// @return The compouding level&#13;
    function getCompoundingLevel(address _owner) public view returns (uint256) {&#13;
        uint256 level = compoundedInterestFactor[_owner];&#13;
        if (level == 0) {&#13;
            // important note that for InterestRateNone or empty accounts the compoundedInterestFactor is newer stored by setBalance&#13;
            return SCALEFACTOR;&#13;
        } else {&#13;
            return level;&#13;
        }&#13;
    }&#13;
&#13;
    /// @param _owner The address from which the balance will be retrieved&#13;
    /// @return The balance&#13;
    function balanceOf(address _owner) public view returns (uint256) {&#13;
        return getAdjustedValue(_owner);&#13;
    }&#13;
&#13;
    // INTERNAL FUNCTIONS&#13;
&#13;
    /// @notice add tokens `_value` tokens to `owner`&#13;
    /// @param _owner The address of the account&#13;
    /// @param _value The amount of tokens to be added&#13;
    function addTokens(address _owner,uint256 _value) notNull(_owner) internal {&#13;
        uint256 rawBalance = super.balanceOf(_owner);&#13;
        uint256 adjustedBalance = getAdjustedValue(_owner);&#13;
        setBalance(_owner, adjustedBalance.add(_value));&#13;
        checkMintOrBurn(_owner, rawBalance, adjustedBalance);&#13;
    }&#13;
&#13;
    /// @notice subtract tokens `_value` tokens from `owner`&#13;
    /// @param _owner The address of the account&#13;
    /// @param _value The amount of tokens to be subtracted&#13;
    function subTokens(address _owner, uint256 _value) internal notNull(_owner) returns (uint256 _valueDeducted ) {&#13;
        uint256 rawBalance = super.balanceOf(_owner);&#13;
        uint256 adjustedBalance = getAdjustedValue(_owner);&#13;
        uint256 newBalance = adjustedBalance.sub(_value);&#13;
        if (newBalance &lt;= dustAmount) {&#13;
            // dont leave balance below dust, empty account&#13;
            _valueDeducted = _value.add(newBalance);&#13;
            newBalance =  0;&#13;
        } else {&#13;
            _valueDeducted = _value;&#13;
        }&#13;
        setBalance(_owner, newBalance);&#13;
        checkMintOrBurn(_owner, rawBalance, adjustedBalance);&#13;
    }&#13;
&#13;
    /// @notice set balance of account `owner` to `_value`&#13;
    /// @param _owner The address of the account&#13;
    /// @param _value The new balance &#13;
    function setBalance(address _owner, uint256 _value) internal {&#13;
        super.setBalance(_owner, _value);&#13;
        // update `owner`s compoundLevel&#13;
        if (_value == 0) {&#13;
            // stall account release storage&#13;
            delete compoundedInterestFactor[_owner];&#13;
        } else {&#13;
            // only update compoundedInterestFactor when value has changed &#13;
            // important note: for InterestRateNone the compoundedInterestFactor is newer stored because the default value for getCompoundingLevel is SCALEFACTOR&#13;
            uint256 currentLevel = getInterestRate().getCurrentCompoundingLevel();&#13;
            if (currentLevel != getCompoundingLevel(_owner)) {&#13;
                compoundedInterestFactor[_owner] = currentLevel;&#13;
            }&#13;
        }&#13;
    }&#13;
&#13;
    /// @dev get address of active bond&#13;
    function getInterestRate() internal view returns (InterestRateInterface) {&#13;
        if ((block.timestamp &lt;= announcedMaturityDate))&#13;
            return currentTerms;&#13;
        else&#13;
            return announcedTerms;&#13;
    }&#13;
&#13;
    /// @notice get adjusted balance of account `owner`&#13;
    /// @param _owner The address of the account&#13;
    function getAdjustedValue(address _owner) internal view returns (uint256) {&#13;
        uint256 _rawBalance = super.balanceOf(_owner);&#13;
        // if _rawBalance is 0 dont perform calculations&#13;
        if (_rawBalance == 0)&#13;
            return 0;&#13;
        // important note: for empty/new account the getCompoundingLevel value is not meaningfull&#13;
        uint256 startLevel = getCompoundingLevel(_owner);&#13;
        uint256 currentLevel = getInterestRate().getCurrentCompoundingLevel();&#13;
        return _rawBalance.mul(currentLevel).div(startLevel);&#13;
    }&#13;
&#13;
    /// @notice get adjusted balance of account `owner` at data `date`&#13;
    /// @param _owner The address of the account&#13;
    /// @param _date The date of the balance NB: MUST be within valid current and announced Terms date range&#13;
    function getAdjustedValueDate(address _owner,uint256 _date) public view returns (uint256) {&#13;
        uint256 _rawBalance = super.balanceOf(_owner);&#13;
        // if _rawBalance is 0 dont perform calculations&#13;
        if (_rawBalance == 0)&#13;
            return 0;&#13;
        // important note: for empty/new account the getCompoundingLevel value is not meaningfull&#13;
        uint256 startLevel = getCompoundingLevel(_owner);&#13;
&#13;
        InterestRateInterface dateTerms;&#13;
        if (_date &lt;= announcedMaturityDate)&#13;
            dateTerms = currentTerms;&#13;
        else&#13;
            dateTerms = announcedTerms;&#13;
&#13;
        uint256 dateLevel = dateTerms.getCompoundingLevelDate(_date);&#13;
        return _rawBalance.mul(dateLevel).div(startLevel);&#13;
    }&#13;
&#13;
    // PRIVATE FUNCTIONS&#13;
&#13;
    // EVENTS&#13;
&#13;
    event AnnounceRollover(string newName, address indexed newTerms, uint256 indexed newMaturityDate, uint256 indexed newTermEndDate);&#13;
}