pragma solidity ^0.4.17;

/*

 * source       https://github.com/blockbitsio/

 * @name        Application Entity Generic Contract
 * @package     BlockBitsIO
 * @author      Micky Socaci <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="9cf1f5fff7e5dcf2f3ebf0f5eaf9b2eef3">[email protected]</a>&gt;&#13;
&#13;
    Used for the ABI interface when assets need to call Application Entity.&#13;
&#13;
    This is required, otherwise we end up loading the assets themselves when we load the ApplicationEntity contract&#13;
    and end up in a loop&#13;
*/&#13;
&#13;
&#13;
&#13;
contract ApplicationEntityABI {&#13;
&#13;
    address public ProposalsEntity;&#13;
    address public FundingEntity;&#13;
    address public MilestonesEntity;&#13;
    address public MeetingsEntity;&#13;
    address public BountyManagerEntity;&#13;
    address public TokenManagerEntity;&#13;
    address public ListingContractEntity;&#13;
    address public FundingManagerEntity;&#13;
    address public NewsContractEntity;&#13;
&#13;
    bool public _initialized = false;&#13;
    bool public _locked = false;&#13;
    uint8 public CurrentEntityState;&#13;
    uint8 public AssetCollectionNum;&#13;
    address public GatewayInterfaceAddress;&#13;
    address public deployerAddress;&#13;
    address testAddressAllowUpgradeFrom;&#13;
    mapping (bytes32 =&gt; uint8) public EntityStates;&#13;
    mapping (bytes32 =&gt; address) public AssetCollection;&#13;
    mapping (uint8 =&gt; bytes32) public AssetCollectionIdToName;&#13;
    mapping (bytes32 =&gt; uint256) public BylawsUint256;&#13;
    mapping (bytes32 =&gt; bytes32) public BylawsBytes32;&#13;
&#13;
    function ApplicationEntity() public;&#13;
    function getEntityState(bytes32 name) public view returns (uint8);&#13;
    function linkToGateway( address _GatewayInterfaceAddress, bytes32 _sourceCodeUrl ) external;&#13;
    function setUpgradeState(uint8 state) public ;&#13;
    function addAssetProposals(address _assetAddresses) external;&#13;
    function addAssetFunding(address _assetAddresses) external;&#13;
    function addAssetMilestones(address _assetAddresses) external;&#13;
    function addAssetMeetings(address _assetAddresses) external;&#13;
    function addAssetBountyManager(address _assetAddresses) external;&#13;
    function addAssetTokenManager(address _assetAddresses) external;&#13;
    function addAssetFundingManager(address _assetAddresses) external;&#13;
    function addAssetListingContract(address _assetAddresses) external;&#13;
    function addAssetNewsContract(address _assetAddresses) external;&#13;
    function getAssetAddressByName(bytes32 _name) public view returns (address);&#13;
    function setBylawUint256(bytes32 name, uint256 value) public;&#13;
    function getBylawUint256(bytes32 name) public view returns (uint256);&#13;
    function setBylawBytes32(bytes32 name, bytes32 value) public;&#13;
    function getBylawBytes32(bytes32 name) public view returns (bytes32);&#13;
    function initialize() external returns (bool);&#13;
    function getParentAddress() external view returns(address);&#13;
    function createCodeUpgradeProposal( address _newAddress, bytes32 _sourceCodeUrl ) external returns (uint256);&#13;
    function acceptCodeUpgradeProposal(address _newAddress) external;&#13;
    function initializeAssetsToThisApplication() external returns (bool);&#13;
    function transferAssetsToNewApplication(address _newAddress) external returns (bool);&#13;
    function lock() external returns (bool);&#13;
    function canInitiateCodeUpgrade(address _sender) public view returns(bool);&#13;
    function doStateChanges() public;&#13;
    function hasRequiredStateChanges() public view returns (bool);&#13;
    function anyAssetHasChanges() public view returns (bool);&#13;
    function extendedAnyAssetHasChanges() internal view returns (bool);&#13;
    function getRequiredStateChanges() public view returns (uint8, uint8);&#13;
    function getTimestamp() view public returns (uint256);&#13;
&#13;
}&#13;
&#13;
/*&#13;
&#13;
 * source       https://github.com/blockbitsio/&#13;
&#13;
 * @name        Application Asset Contract&#13;
 * @package     BlockBitsIO&#13;
 * @author      Micky Socaci &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="7b16121810023b15140c17120d1e550914">[email protected]</a>&gt;&#13;
&#13;
 Any contract inheriting this will be usable as an Asset in the Application Entity&#13;
&#13;
*/&#13;
&#13;
&#13;
&#13;
&#13;
contract ApplicationAsset {&#13;
&#13;
    event EventAppAssetOwnerSet(bytes32 indexed _name, address indexed _owner);&#13;
    event EventRunBeforeInit(bytes32 indexed _name);&#13;
    event EventRunBeforeApplyingSettings(bytes32 indexed _name);&#13;
&#13;
&#13;
    mapping (bytes32 =&gt; uint8) public EntityStates;&#13;
    mapping (bytes32 =&gt; uint8) public RecordStates;&#13;
    uint8 public CurrentEntityState;&#13;
&#13;
    event EventEntityProcessor(bytes32 indexed _assetName, uint8 indexed _current, uint8 indexed _required);&#13;
    event DebugEntityRequiredChanges( bytes32 _assetName, uint8 indexed _current, uint8 indexed _required );&#13;
&#13;
    bytes32 public assetName;&#13;
&#13;
    /* Asset records */&#13;
    uint8 public RecordNum = 0;&#13;
&#13;
    /* Asset initialised or not */&#13;
    bool public _initialized = false;&#13;
&#13;
    /* Asset settings present or not */&#13;
    bool public _settingsApplied = false;&#13;
&#13;
    /* Asset owner ( ApplicationEntity address ) */&#13;
    address public owner = address(0x0) ;&#13;
    address public deployerAddress;&#13;
&#13;
    function ApplicationAsset() public {&#13;
        deployerAddress = msg.sender;&#13;
    }&#13;
&#13;
    function setInitialApplicationAddress(address _ownerAddress) public onlyDeployer requireNotInitialised {&#13;
        owner = _ownerAddress;&#13;
    }&#13;
&#13;
    function setInitialOwnerAndName(bytes32 _name) external&#13;
        requireNotInitialised&#13;
        onlyOwner&#13;
        returns (bool)&#13;
    {&#13;
        // init states&#13;
        setAssetStates();&#13;
        assetName = _name;&#13;
        // set initial state&#13;
        CurrentEntityState = getEntityState("NEW");&#13;
        runBeforeInitialization();&#13;
        _initialized = true;&#13;
        EventAppAssetOwnerSet(_name, owner);&#13;
        return true;&#13;
    }&#13;
&#13;
    function setAssetStates() internal {&#13;
        // Asset States&#13;
        EntityStates["__IGNORED__"]     = 0;&#13;
        EntityStates["NEW"]             = 1;&#13;
        // Funding Stage States&#13;
        RecordStates["__IGNORED__"]     = 0;&#13;
    }&#13;
&#13;
    function getRecordState(bytes32 name) public view returns (uint8) {&#13;
        return RecordStates[name];&#13;
    }&#13;
&#13;
    function getEntityState(bytes32 name) public view returns (uint8) {&#13;
        return EntityStates[name];&#13;
    }&#13;
&#13;
    function runBeforeInitialization() internal requireNotInitialised  {&#13;
        EventRunBeforeInit(assetName);&#13;
    }&#13;
&#13;
    function applyAndLockSettings()&#13;
        public&#13;
        onlyDeployer&#13;
        requireInitialised&#13;
        requireSettingsNotApplied&#13;
        returns(bool)&#13;
    {&#13;
        runBeforeApplyingSettings();&#13;
        _settingsApplied = true;&#13;
        return true;&#13;
    }&#13;
&#13;
    function runBeforeApplyingSettings() internal requireInitialised requireSettingsNotApplied  {&#13;
        EventRunBeforeApplyingSettings(assetName);&#13;
    }&#13;
&#13;
    function transferToNewOwner(address _newOwner) public requireInitialised onlyOwner returns (bool) {&#13;
        require(owner != address(0x0) &amp;&amp; _newOwner != address(0x0));&#13;
        owner = _newOwner;&#13;
        EventAppAssetOwnerSet(assetName, owner);&#13;
        return true;&#13;
    }&#13;
&#13;
    function getApplicationAssetAddressByName(bytes32 _name)&#13;
        public&#13;
        view&#13;
        returns(address)&#13;
    {&#13;
        address asset = ApplicationEntityABI(owner).getAssetAddressByName(_name);&#13;
        if( asset != address(0x0) ) {&#13;
            return asset;&#13;
        } else {&#13;
            revert();&#13;
        }&#13;
    }&#13;
&#13;
    function getApplicationState() public view returns (uint8) {&#13;
        return ApplicationEntityABI(owner).CurrentEntityState();&#13;
    }&#13;
&#13;
    function getApplicationEntityState(bytes32 name) public view returns (uint8) {&#13;
        return ApplicationEntityABI(owner).getEntityState(name);&#13;
    }&#13;
&#13;
    function getAppBylawUint256(bytes32 name) public view requireInitialised returns (uint256) {&#13;
        ApplicationEntityABI CurrentApp = ApplicationEntityABI(owner);&#13;
        return CurrentApp.getBylawUint256(name);&#13;
    }&#13;
&#13;
    function getAppBylawBytes32(bytes32 name) public view requireInitialised returns (bytes32) {&#13;
        ApplicationEntityABI CurrentApp = ApplicationEntityABI(owner);&#13;
        return CurrentApp.getBylawBytes32(name);&#13;
    }&#13;
&#13;
    modifier onlyOwner() {&#13;
        require(msg.sender == owner);&#13;
        _;&#13;
    }&#13;
&#13;
    modifier onlyApplicationEntity() {&#13;
        require(msg.sender == owner);&#13;
        _;&#13;
    }&#13;
&#13;
    modifier requireInitialised() {&#13;
        require(_initialized == true);&#13;
        _;&#13;
    }&#13;
&#13;
    modifier requireNotInitialised() {&#13;
        require(_initialized == false);&#13;
        _;&#13;
    }&#13;
&#13;
    modifier requireSettingsApplied() {&#13;
        require(_settingsApplied == true);&#13;
        _;&#13;
    }&#13;
&#13;
    modifier requireSettingsNotApplied() {&#13;
        require(_settingsApplied == false);&#13;
        _;&#13;
    }&#13;
&#13;
    modifier onlyDeployer() {&#13;
        require(msg.sender == deployerAddress);&#13;
        _;&#13;
    }&#13;
&#13;
    modifier onlyAsset(bytes32 _name) {&#13;
        address AssetAddress = getApplicationAssetAddressByName(_name);&#13;
        require( msg.sender == AssetAddress);&#13;
        _;&#13;
    }&#13;
&#13;
    function getTimestamp() view public returns (uint256) {&#13;
        return now;&#13;
    }&#13;
&#13;
&#13;
}&#13;
&#13;
/*&#13;
&#13;
 * source       https://github.com/blockbitsio/&#13;
&#13;
 * @name        Application Asset Contract ABI&#13;
 * @package     BlockBitsIO&#13;
 * @author      Micky Socaci &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="8de0e4eee6f4cde3e2fae1e4fbe8a3ffe2">[email protected]</a>&gt;&#13;
&#13;
 Any contract inheriting this will be usable as an Asset in the Application Entity&#13;
&#13;
*/&#13;
&#13;
&#13;
&#13;
contract ABIApplicationAsset {&#13;
&#13;
    bytes32 public assetName;&#13;
    uint8 public CurrentEntityState;&#13;
    uint8 public RecordNum;&#13;
    bool public _initialized;&#13;
    bool public _settingsApplied;&#13;
    address public owner;&#13;
    address public deployerAddress;&#13;
    mapping (bytes32 =&gt; uint8) public EntityStates;&#13;
    mapping (bytes32 =&gt; uint8) public RecordStates;&#13;
&#13;
    function setInitialApplicationAddress(address _ownerAddress) public;&#13;
    function setInitialOwnerAndName(bytes32 _name) external returns (bool);&#13;
    function getRecordState(bytes32 name) public view returns (uint8);&#13;
    function getEntityState(bytes32 name) public view returns (uint8);&#13;
    function applyAndLockSettings() public returns(bool);&#13;
    function transferToNewOwner(address _newOwner) public returns (bool);&#13;
    function getApplicationAssetAddressByName(bytes32 _name) public returns(address);&#13;
    function getApplicationState() public view returns (uint8);&#13;
    function getApplicationEntityState(bytes32 name) public view returns (uint8);&#13;
    function getAppBylawUint256(bytes32 name) public view returns (uint256);&#13;
    function getAppBylawBytes32(bytes32 name) public view returns (bytes32);&#13;
    function getTimestamp() view public returns (uint256);&#13;
&#13;
&#13;
}&#13;
&#13;
/*&#13;
&#13;
 * source       https://github.com/blockbitsio/&#13;
&#13;
 * @name        Funding Contract ABI&#13;
 * @package     BlockBitsIO&#13;
 * @author      Micky Socaci &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="e68b8f858d9fa68889918a8f9083c89489">[email protected]</a>&gt;&#13;
&#13;
 Contains the Funding Contract code deployed and linked to the Application Entity&#13;
&#13;
*/&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
contract ABIFundingManager is ABIApplicationAsset {&#13;
&#13;
    bool public fundingProcessed;&#13;
    bool FundingPoolBalancesAllocated;&#13;
    uint8 public VaultCountPerProcess;&#13;
    uint256 public lastProcessedVaultId;&#13;
    uint256 public vaultNum;&#13;
    uint256 public LockedVotingTokens;&#13;
    bytes32 public currentTask;&#13;
    mapping (bytes32 =&gt; bool) public taskByHash;&#13;
    mapping  (address =&gt; address) public vaultList;&#13;
    mapping  (uint256 =&gt; address) public vaultById;&#13;
&#13;
    function receivePayment(address _sender, uint8 _payment_method, uint8 _funding_stage) payable public returns(bool);&#13;
    function getMyVaultAddress(address _sender) public view returns (address);&#13;
    function setVaultCountPerProcess(uint8 _perProcess) external;&#13;
    function getHash(bytes32 actionType, bytes32 arg1) public pure returns ( bytes32 );&#13;
    function getCurrentMilestoneProcessed() public view returns (bool);&#13;
    function processFundingFailedFinished() public view returns (bool);&#13;
    function processFundingSuccessfulFinished() public view returns (bool);&#13;
    function getCurrentMilestoneIdHash() internal view returns (bytes32);&#13;
    function processMilestoneFinished() public view returns (bool);&#13;
    function processEmergencyFundReleaseFinished() public view returns (bool);&#13;
    function getAfterTransferLockedTokenBalances(address vaultAddress, bool excludeCurrent) public view returns (uint256);&#13;
    function VaultRequestedUpdateForLockedVotingTokens(address owner) public;&#13;
    function doStateChanges() public;&#13;
    function hasRequiredStateChanges() public view returns (bool);&#13;
    function getRequiredStateChanges() public view returns (uint8, uint8);&#13;
    function ApplicationInFundingOrDevelopment() public view returns(bool);&#13;
&#13;
}&#13;
&#13;
/*&#13;
&#13;
 * source       https://github.com/blockbitsio/&#13;
&#13;
 * @name        Token Manager Contract&#13;
 * @package     BlockBitsIO&#13;
 * @author      Micky Socaci &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="721f1b11190b321c1d051e1b04175c001d">[email protected]</a>&gt;&#13;
&#13;
*/&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
contract ABITokenManager is ABIApplicationAsset {&#13;
&#13;
    address public TokenSCADAEntity;&#13;
    address public TokenEntity;&#13;
    address public MarketingMethodAddress;&#13;
    bool OwnerTokenBalancesReleased = false;&#13;
&#13;
    function addSettings(address _scadaAddress, address _tokenAddress, address _marketing ) public;&#13;
    function getTokenSCADARequiresHardCap() public view returns (bool);&#13;
    function mint(address _to, uint256 _amount) public returns (bool);&#13;
    function finishMinting() public returns (bool);&#13;
    function mintForMarketingPool(address _to, uint256 _amount) external returns (bool);&#13;
    function ReleaseOwnersLockedTokens(address _multiSigOutputAddress) public returns (bool);&#13;
&#13;
}&#13;
&#13;
/*&#13;
&#13;
 * source       https://github.com/blockbitsio/&#13;
&#13;
 * @name        General Funding Input Contract ABI&#13;
 * @package     BlockBitsIO&#13;
 * @author      Micky Socaci &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="9af7f3f9f1e3daf4f5edf6f3ecffb4e8f5">[email protected]</a>&gt;&#13;
&#13;
*/&#13;
&#13;
&#13;
&#13;
contract ABIFundingInputGeneral {&#13;
&#13;
    bool public initialized = false;&#13;
    uint8 public typeId;&#13;
    address public FundingAssetAddress;&#13;
&#13;
    event EventInputPaymentReceived(address sender, uint amount, uint8 _type);&#13;
&#13;
    function setFundingAssetAddress(address _addr) public;&#13;
    function () public payable;&#13;
    function buy() public payable returns(bool);&#13;
}&#13;
&#13;
/*&#13;
&#13;
 * source       https://github.com/blockbitsio/&#13;
&#13;
 * @name        Funding Contract&#13;
 * @package     BlockBitsIO&#13;
 * @author      Micky Socaci &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="c5a8aca6aebc85abaab2a9acb3a0ebb7aa">[email protected]</a>&gt;&#13;
&#13;
 Contains the Funding Contract code deployed and linked to the Application Entity&#13;
&#13;
 !!! Links directly to Milestones&#13;
&#13;
*/&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
contract Funding is ApplicationAsset {&#13;
&#13;
    address public multiSigOutputAddress;&#13;
    ABIFundingInputGeneral public DirectInput;&#13;
    ABIFundingInputGeneral public MilestoneInput;&#13;
&#13;
    // mapping (bytes32 =&gt; uint8) public FundingMethods;&#13;
    enum FundingMethodIds {&#13;
        __IGNORED__,&#13;
        DIRECT_ONLY, 				//&#13;
        MILESTONE_ONLY, 		    //&#13;
        DIRECT_AND_MILESTONE		//&#13;
    }&#13;
&#13;
    ABITokenManager public TokenManagerEntity;&#13;
    ABIFundingManager public FundingManagerEntity;&#13;
&#13;
    event FundingStageCreated( uint8 indexed index, bytes32 indexed name );&#13;
&#13;
    struct FundingStage {&#13;
        bytes32 name;&#13;
        uint8   state;&#13;
        uint256 time_start;&#13;
        uint256 time_end;&#13;
        uint256 amount_cap_soft;            // 0 = not enforced&#13;
        uint256 amount_cap_hard;            // 0 = not enforced&#13;
        uint256 amount_raised;              // 0 = not enforced&#13;
        // funding method settings&#13;
        uint256 minimum_entry;&#13;
        uint8   methods;                    // FundingMethodIds&#13;
        // token settings&#13;
        uint256 fixed_tokens;&#13;
        uint8   price_addition_percentage;  //&#13;
        uint8   token_share_percentage;&#13;
        uint8   index;&#13;
    }&#13;
&#13;
    mapping (uint8 =&gt; FundingStage) public Collection;&#13;
    uint8 public FundingStageNum = 0;&#13;
    uint8 public currentFundingStage = 1;&#13;
&#13;
    // funding settings&#13;
    uint256 public AmountRaised = 0;&#13;
    uint256 public MilestoneAmountRaised = 0;&#13;
&#13;
    uint256 public GlobalAmountCapSoft = 0;&#13;
    uint256 public GlobalAmountCapHard = 0;&#13;
&#13;
    uint8 public TokenSellPercentage = 0;&#13;
&#13;
    uint256 public Funding_Setting_funding_time_start = 0;&#13;
    uint256 public Funding_Setting_funding_time_end = 0;&#13;
&#13;
    uint256 public Funding_Setting_cashback_time_start = 0;&#13;
    // end time is ignored at this stage, anyone can cashback forever if funding fails.&#13;
    uint256 public Funding_Setting_cashback_time_end = 0;&#13;
&#13;
    // to be taken from application bylaws&#13;
    uint256 public Funding_Setting_cashback_before_start_wait_duration = 7 days;&#13;
    uint256 public Funding_Setting_cashback_duration = 365 days;&#13;
&#13;
    event LifeCycle();&#13;
    event DebugRecordRequiredChanges( bytes32 indexed _assetName, uint8 indexed _current, uint8 indexed _required );&#13;
    event DebugCallAgain(uint8 indexed _who);&#13;
&#13;
    event EventEntityProcessor(bytes32 indexed _assetName, uint8 indexed _current, uint8 indexed _required);&#13;
    event EventRecordProcessor(bytes32 indexed _assetName, uint8 indexed _current, uint8 indexed _required);&#13;
&#13;
    event DebugAction(bytes32 indexed _name, bool indexed _allowed);&#13;
&#13;
&#13;
    event EventFundingReceivedPayment(address indexed _sender, uint8 indexed _payment_method, uint256 indexed _amount );&#13;
&#13;
    function runBeforeInitialization() internal requireNotInitialised {&#13;
&#13;
        // instantiate token manager, moved from runBeforeApplyingSettings&#13;
        TokenManagerEntity = ABITokenManager( getApplicationAssetAddressByName('TokenManager') );&#13;
        FundingManagerEntity = ABIFundingManager( getApplicationAssetAddressByName('FundingManager') );&#13;
&#13;
        EventRunBeforeInit(assetName);&#13;
    }&#13;
&#13;
    function setAssetStates() internal {&#13;
        // Asset States&#13;
        EntityStates["__IGNORED__"]     = 0;&#13;
        EntityStates["NEW"]             = 1;&#13;
        EntityStates["WAITING"]         = 2;&#13;
        EntityStates["IN_PROGRESS"]     = 3;&#13;
        EntityStates["COOLDOWN"]        = 4;&#13;
        EntityStates["FUNDING_ENDED"]   = 5;&#13;
        EntityStates["FAILED"]          = 6;&#13;
        EntityStates["FAILED_FINAL"]    = 7;&#13;
        EntityStates["SUCCESSFUL"]      = 8;&#13;
        EntityStates["SUCCESSFUL_FINAL"]= 9;&#13;
&#13;
        // Funding Stage States&#13;
        RecordStates["__IGNORED__"]     = 0;&#13;
        RecordStates["NEW"]             = 1;&#13;
        RecordStates["IN_PROGRESS"]     = 2;&#13;
        RecordStates["FINAL"]           = 3;&#13;
    }&#13;
&#13;
    function addSettings(address _outputAddress, uint256 soft_cap, uint256 hard_cap, uint8 sale_percentage, address _direct, address _milestone )&#13;
        public&#13;
        requireInitialised&#13;
        requireSettingsNotApplied&#13;
    {&#13;
        if(soft_cap &gt; hard_cap) {&#13;
            revert();&#13;
        }&#13;
&#13;
        multiSigOutputAddress = _outputAddress;&#13;
        GlobalAmountCapSoft = soft_cap;&#13;
        GlobalAmountCapHard = hard_cap;&#13;
&#13;
        if(sale_percentage &gt; 90) {&#13;
            revert();&#13;
        }&#13;
&#13;
        TokenSellPercentage = sale_percentage;&#13;
&#13;
        DirectInput = ABIFundingInputGeneral(_direct);&#13;
        MilestoneInput = ABIFundingInputGeneral(_milestone);&#13;
    }&#13;
&#13;
    function addFundingStage(&#13;
        bytes32 _name,&#13;
        uint256 _time_start,&#13;
        uint256 _time_end,&#13;
        uint256 _amount_cap_soft,&#13;
        uint256 _amount_cap_hard,   // required &gt; 0&#13;
        uint8   _methods,&#13;
        uint256 _minimum_entry,&#13;
        uint256 _fixed_tokens,&#13;
        uint8   _price_addition_percentage,&#13;
        uint8   _token_share_percentage&#13;
    )&#13;
        public&#13;
        onlyDeployer&#13;
        requireInitialised&#13;
        requireSettingsNotApplied&#13;
    {&#13;
&#13;
        // make sure end time is later than start time&#13;
        if(_time_end &lt;= _time_start) {&#13;
            revert();&#13;
        }&#13;
&#13;
        // make sure hard cap exists!&#13;
        if(_amount_cap_hard == 0) {&#13;
            revert();&#13;
        }&#13;
&#13;
        // make sure soft cap is not higher than hard cap&#13;
        if(_amount_cap_soft &gt; _amount_cap_hard) {&#13;
            revert();&#13;
        }&#13;
&#13;
        if(_token_share_percentage &gt; 0) {&#13;
            revert();&#13;
        }&#13;
&#13;
        FundingStage storage prevRecord = Collection[FundingStageNum];&#13;
        if(FundingStageNum &gt; 0) {&#13;
&#13;
            // new stage does not start before the previous one ends&#13;
            if( _time_start &lt;= prevRecord.time_end ) {&#13;
                revert();&#13;
            }&#13;
        }&#13;
&#13;
        FundingStage storage record = Collection[++FundingStageNum];&#13;
        record.name             = _name;&#13;
        record.time_start       = _time_start;&#13;
        record.time_end         = _time_end;&#13;
        record.amount_cap_soft  = _amount_cap_soft;&#13;
        record.amount_cap_hard  = _amount_cap_hard;&#13;
&#13;
        // funding method settings&#13;
        record.methods          = _methods;&#13;
        record.minimum_entry    = _minimum_entry;&#13;
&#13;
        // token settings&#13;
        record.fixed_tokens              = _fixed_tokens;&#13;
        record.price_addition_percentage = _price_addition_percentage;&#13;
        record.token_share_percentage    = _token_share_percentage;&#13;
&#13;
        // state new&#13;
        record.state = getRecordState("NEW");&#13;
        record.index = FundingStageNum;&#13;
&#13;
        FundingStageCreated( FundingStageNum, _name );&#13;
&#13;
        adjustFundingSettingsBasedOnNewFundingStage();&#13;
    }&#13;
&#13;
    function adjustFundingSettingsBasedOnNewFundingStage() internal {&#13;
&#13;
        // set funding start&#13;
        Funding_Setting_funding_time_start = Collection[1].time_start;&#13;
        // set funding end&#13;
        Funding_Setting_funding_time_end = Collection[FundingStageNum].time_end;&#13;
&#13;
        // cashback starts 1 day after funding status is failed&#13;
        Funding_Setting_cashback_time_start = Funding_Setting_funding_time_end + Funding_Setting_cashback_before_start_wait_duration;&#13;
        Funding_Setting_cashback_time_end = Funding_Setting_cashback_time_start + Funding_Setting_cashback_duration;&#13;
    }&#13;
&#13;
    function getStageAmount(uint8 StageId) public view returns ( uint256 ) {&#13;
        return Collection[StageId].fixed_tokens;&#13;
    }&#13;
&#13;
    function allowedPaymentMethod(uint8 _payment_method) public pure returns (bool) {&#13;
        if(&#13;
        _payment_method == uint8(FundingMethodIds.DIRECT_ONLY) ||&#13;
        _payment_method == uint8(FundingMethodIds.MILESTONE_ONLY)&#13;
        ){&#13;
            return true;&#13;
        } else {&#13;
            return false;&#13;
        }&#13;
    }&#13;
&#13;
    function receivePayment(address _sender, uint8 _payment_method)&#13;
        payable&#13;
        public&#13;
        requireInitialised&#13;
        onlyInputPaymentMethod&#13;
        returns(bool)&#13;
    {&#13;
        // check that msg.value is higher than 0, don't really want to have to deal with minus in case the network breaks this somehow&#13;
        if(allowedPaymentMethod(_payment_method) &amp;&amp; canAcceptPayment(msg.value) ) {&#13;
&#13;
            uint256 contributed_value = msg.value;&#13;
&#13;
            uint256 amountOverCap = getValueOverCurrentCap(contributed_value);&#13;
            if ( amountOverCap &gt; 0 ) {&#13;
                // calculate how much we can accept&#13;
&#13;
                // update contributed value&#13;
                contributed_value -= amountOverCap;&#13;
            }&#13;
&#13;
            Collection[currentFundingStage].amount_raised+= contributed_value;&#13;
            AmountRaised+= contributed_value;&#13;
&#13;
            if(_payment_method == uint8(FundingMethodIds.MILESTONE_ONLY)) {&#13;
                MilestoneAmountRaised+=contributed_value;&#13;
            }&#13;
&#13;
            EventFundingReceivedPayment(_sender, _payment_method, contributed_value);&#13;
&#13;
            if( FundingManagerEntity.receivePayment.value(contributed_value)( _sender, _payment_method, currentFundingStage ) ) {&#13;
&#13;
                if(amountOverCap &gt; 0) {&#13;
                    // last step, if we received more than we can accept, send remaining back&#13;
                    // amountOverCap sent back&#13;
                    if( _sender.send(this.balance) ) {&#13;
                        return true;&#13;
                    }&#13;
                    else {&#13;
                        revert();&#13;
                    }&#13;
                } else {&#13;
                    return true;&#13;
                }&#13;
            } else {&#13;
                revert();&#13;
            }&#13;
&#13;
        } else {&#13;
            revert();&#13;
        }&#13;
    }&#13;
&#13;
    modifier onlyInputPaymentMethod() {&#13;
        require(msg.sender != 0x0 &amp;&amp; ( msg.sender == address(DirectInput) || msg.sender == address(MilestoneInput) ));&#13;
        _;&#13;
    }&#13;
&#13;
    function canAcceptPayment(uint256 _amount) public view returns (bool) {&#13;
        if( _amount &gt; 0 ) {&#13;
            // funding state should be IN_PROGRESS, no state changes should be required&#13;
            if( CurrentEntityState == getEntityState("IN_PROGRESS") &amp;&amp; hasRequiredStateChanges() == false) {&#13;
                return true;&#13;
            }&#13;
        }&#13;
        return false;&#13;
    }&#13;
&#13;
    function getValueOverCurrentCap(uint256 _amount) public view returns (uint256) {&#13;
        FundingStage memory record = Collection[currentFundingStage];&#13;
        uint256 remaining = record.amount_cap_hard - AmountRaised;&#13;
        if( _amount &gt; remaining ) {&#13;
            return _amount - remaining;&#13;
        }&#13;
        return 0;&#13;
    }&#13;
&#13;
&#13;
    /*&#13;
    * Update Existing FundingStage&#13;
    *&#13;
    * @param        uint8 _record_id&#13;
    * @param        uint8 _new_state&#13;
    * @param        uint8 _duration&#13;
    *&#13;
    * @access       public&#13;
    * @type         method&#13;
    * @modifiers    onlyOwner, requireInitialised, updateAllowed&#13;
    *&#13;
    * @return       void&#13;
    */&#13;
&#13;
    function updateFundingStage( uint8 _new_state )&#13;
        internal&#13;
        requireInitialised&#13;
        FundingStageUpdateAllowed(_new_state)&#13;
        returns (bool)&#13;
    {&#13;
        FundingStage storage rec = Collection[currentFundingStage];&#13;
        rec.state       = _new_state;&#13;
        return true;&#13;
    }&#13;
&#13;
&#13;
    /*&#13;
    * Modifier: Validate if record updates are allowed&#13;
    *&#13;
    * @type         modifier&#13;
    *&#13;
    * @param        uint8 _record_id&#13;
    * @param        uint8 _new_state&#13;
    * @param        uint256 _duration&#13;
    *&#13;
    * @return       bool&#13;
    */&#13;
&#13;
    modifier FundingStageUpdateAllowed(uint8 _new_state) {&#13;
        require( isFundingStageUpdateAllowed( _new_state )  );&#13;
        _;&#13;
    }&#13;
&#13;
    /*&#13;
     * Method: Validate if record can be updated to requested state&#13;
     *&#13;
     * @access       public&#13;
     * @type         method&#13;
     *&#13;
     * @param        uint8 _record_id&#13;
     * @param        uint8 _new_state&#13;
     *&#13;
     * @return       bool&#13;
     */&#13;
    function isFundingStageUpdateAllowed(uint8 _new_state ) public view returns (bool) {&#13;
&#13;
        var (CurrentRecordState, RecordStateRequired, EntityStateRequired) = getRequiredStateChanges();&#13;
&#13;
        CurrentRecordState = 0;&#13;
        EntityStateRequired = 0;&#13;
&#13;
        if(_new_state == uint8(RecordStateRequired)) {&#13;
            return true;&#13;
        }&#13;
        return false;&#13;
    }&#13;
&#13;
    /*&#13;
     * Funding Phase changes&#13;
     *&#13;
     * Method: Get FundingStage Required State Changes&#13;
     *&#13;
     * @access       public&#13;
     * @type         method&#13;
     * @modifiers    onlyOwner&#13;
     *&#13;
     * @return       uint8 RecordStateRequired&#13;
     */&#13;
    function getRecordStateRequiredChanges() public view returns (uint8) {&#13;
&#13;
        FundingStage memory record = Collection[currentFundingStage];&#13;
        uint8 RecordStateRequired = getRecordState("__IGNORED__");&#13;
&#13;
        if(record.state == getRecordState("FINAL")) {&#13;
            return getRecordState("__IGNORED__");&#13;
        }&#13;
&#13;
        /*&#13;
            If funding stage is not started and timestamp is after start time:&#13;
            - we need to change state to IN_PROGRESS so we can start receiving funds&#13;
        */&#13;
        if( getTimestamp() &gt;= record.time_start ) {&#13;
            RecordStateRequired = getRecordState("IN_PROGRESS");&#13;
        }&#13;
&#13;
        /*&#13;
            This is where we're accepting payments unless we can change state to FINAL&#13;
&#13;
            1. Check if timestamp is after record time_end&#13;
            2. Check hard caps&#13;
            All lead to state change =&gt; FINAL&#13;
        */&#13;
&#13;
        // Time check&#13;
        if(getTimestamp() &gt;= record.time_end) {&#13;
            // Funding Phase ended passed&#13;
            return getRecordState("FINAL");&#13;
        }&#13;
&#13;
        // will trigger in pre-ico&#13;
        // Record Hard Cap Check&#13;
        if(AmountRaised &gt;= record.amount_cap_hard) {&#13;
            // record hard cap reached&#13;
            return getRecordState("FINAL");&#13;
        }&#13;
&#13;
        // will trigger in ico&#13;
        // Global Hard Cap Check&#13;
        if(AmountRaised &gt;= GlobalAmountCapHard) {&#13;
            // hard cap reached&#13;
            return getRecordState("FINAL");&#13;
        }&#13;
&#13;
        if( record.state == RecordStateRequired ) {&#13;
            RecordStateRequired = getRecordState("__IGNORED__");&#13;
        }&#13;
&#13;
        return RecordStateRequired;&#13;
    }&#13;
&#13;
    function doStateChanges() public {&#13;
        var (CurrentRecordState, RecordStateRequired, EntityStateRequired) = getRequiredStateChanges();&#13;
        bool callAgain = false;&#13;
&#13;
        DebugRecordRequiredChanges( assetName, CurrentRecordState, RecordStateRequired );&#13;
        DebugEntityRequiredChanges( assetName, CurrentEntityState, EntityStateRequired );&#13;
&#13;
        if( RecordStateRequired != getRecordState("__IGNORED__") ) {&#13;
            // process record changes.&#13;
            RecordProcessor(CurrentRecordState, RecordStateRequired);&#13;
            DebugCallAgain(2);&#13;
            callAgain = true;&#13;
        }&#13;
&#13;
        if(EntityStateRequired != getEntityState("__IGNORED__") ) {&#13;
            // process entity changes.&#13;
            // if(CurrentEntityState != EntityStateRequired) {&#13;
            EntityProcessor(EntityStateRequired);&#13;
            DebugCallAgain(1);&#13;
            callAgain = true;&#13;
            //}&#13;
        }&#13;
    }&#13;
&#13;
    function hasRequiredStateChanges() public view returns (bool) {&#13;
        bool hasChanges = false;&#13;
&#13;
        var (CurrentRecordState, RecordStateRequired, EntityStateRequired) = getRequiredStateChanges();&#13;
        CurrentRecordState = 0;&#13;
&#13;
        if( RecordStateRequired != getRecordState("__IGNORED__") ) {&#13;
            hasChanges = true;&#13;
        }&#13;
        if(EntityStateRequired != getEntityState("__IGNORED__") ) {&#13;
            hasChanges = true;&#13;
        }&#13;
        return hasChanges;&#13;
    }&#13;
&#13;
    // view methods decide if changes are to be made&#13;
    // in case of tasks, we do them in the Processors.&#13;
&#13;
    function RecordProcessor(uint8 CurrentRecordState, uint8 RecordStateRequired) internal {&#13;
        EventRecordProcessor( assetName, CurrentRecordState, RecordStateRequired );&#13;
        updateFundingStage( RecordStateRequired );&#13;
        if( RecordStateRequired == getRecordState("FINAL") ) {&#13;
            if(currentFundingStage &lt; FundingStageNum) {&#13;
                // jump to next stage&#13;
                currentFundingStage++;&#13;
            }&#13;
        }&#13;
    }&#13;
&#13;
    function EntityProcessor(uint8 EntityStateRequired) internal {&#13;
        EventEntityProcessor( assetName, CurrentEntityState, EntityStateRequired );&#13;
&#13;
        // Do State Specific Updates&#13;
        // Update our Entity State&#13;
        CurrentEntityState = EntityStateRequired;&#13;
&#13;
        if ( EntityStateRequired == getEntityState("FUNDING_ENDED") ) {&#13;
            /*&#13;
                STATE: FUNDING_ENDED&#13;
                @Processor hook&#13;
                Action: Check if funding is successful or not, and move state to "FAILED" or "SUCCESSFUL"&#13;
            */&#13;
&#13;
            // Global Hard Cap Check&#13;
            if(AmountRaised &gt;= GlobalAmountCapSoft) {&#13;
                // hard cap reached&#13;
                CurrentEntityState = getEntityState("SUCCESSFUL");&#13;
            } else {&#13;
                CurrentEntityState = getEntityState("FAILED");&#13;
            }&#13;
        }&#13;
&#13;
&#13;
    }&#13;
&#13;
    /*&#13;
     * Method: Get Record and Entity State Changes&#13;
     *&#13;
     * @access       public&#13;
     * @type         method&#13;
     * @modifiers    onlyOwner&#13;
     *&#13;
     * @return       ( uint8 CurrentRecordState, uint8 RecordStateRequired, uint8 EntityStateRequired)&#13;
     */&#13;
    function getRequiredStateChanges() public view returns (uint8, uint8, uint8) {&#13;
&#13;
        // get FundingStage current state&#13;
        FundingStage memory record = Collection[currentFundingStage];&#13;
&#13;
        uint8 CurrentRecordState = record.state;&#13;
        uint8 RecordStateRequired = getRecordStateRequiredChanges();&#13;
        uint8 EntityStateRequired = getEntityState("__IGNORED__");&#13;
&#13;
&#13;
        // Funding Record State Overrides&#13;
        // if(CurrentRecordState != RecordStateRequired) {&#13;
        if(RecordStateRequired != getRecordState("__IGNORED__"))&#13;
        {&#13;
            // direct state overrides by funding stage&#13;
            if(RecordStateRequired == getRecordState("IN_PROGRESS") ) {&#13;
                // both funding stage and entity states need to move to IN_PROGRESS&#13;
                EntityStateRequired = getEntityState("IN_PROGRESS");&#13;
&#13;
            } else if (RecordStateRequired == getRecordState("FINAL")) {&#13;
                // funding stage moves to FINAL&#13;
&#13;
                if (currentFundingStage == FundingStageNum) {&#13;
                    // if current funding is last&#13;
                    EntityStateRequired = getEntityState("FUNDING_ENDED");&#13;
                }&#13;
                else {&#13;
                    // start cooldown between funding stages&#13;
                    EntityStateRequired = getEntityState("COOLDOWN");&#13;
                }&#13;
            }&#13;
&#13;
        } else {&#13;
&#13;
            // Records do not require any updates.&#13;
            // Do Entity Checks&#13;
&#13;
            if( CurrentEntityState == getEntityState("NEW") ) {&#13;
                /*&#13;
                    STATE: NEW&#13;
                    Processor Action: Allocate Tokens to Funding / Owners then Update to WAITING&#13;
                */&#13;
                EntityStateRequired = getEntityState("WAITING");&#13;
            } else  if ( CurrentEntityState == getEntityState("FUNDING_ENDED") ) {&#13;
                /*&#13;
                    STATE: FUNDING_ENDED&#13;
                    Processor Action: Check if funding is successful or not, and move state to "SUCCESSFUL" or "FAILED"&#13;
                */&#13;
            } else if ( CurrentEntityState == getEntityState("SUCCESSFUL") ) {&#13;
                /*&#13;
                    STATE: SUCCESSFUL&#13;
                    Processor Action: none&#13;
&#13;
                    External Action:&#13;
                    FundingManager - Run Internal Processor ( deliver tokens, deliver direct funding eth )&#13;
                */&#13;
&#13;
                // check funding manager has processed the FUNDING_SUCCESSFUL Task, if true =&gt; FUNDING_SUCCESSFUL_DONE&#13;
                if(FundingManagerEntity.taskByHash( FundingManagerEntity.getHash("FUNDING_SUCCESSFUL_START", "") ) == true) {&#13;
                    EntityStateRequired = getEntityState("SUCCESSFUL_FINAL");&#13;
                }&#13;
                /*&#13;
                if( FundingManagerEntity.CurrentEntityState() == FundingManagerEntity.getEntityState("FUNDING_SUCCESSFUL_DONE") ) {&#13;
                    EntityStateRequired = getEntityState("SUCCESSFUL_FINAL");&#13;
                }&#13;
                */&#13;
&#13;
            } else if ( CurrentEntityState == getEntityState("FAILED") ) {&#13;
                /*&#13;
                    STATE: FAILED&#13;
                    Processor Action: none&#13;
&#13;
                    External Action:&#13;
                    FundingManager - Run Internal Processor (release tokens to owner) ( Cashback is available )&#13;
                */&#13;
&#13;
                // check funding manager state, if FUNDING_NOT_PROCESSED -&gt; getEntityState("__IGNORED__")&#13;
                // if FUNDING_FAILED_DONE&#13;
&#13;
                if(FundingManagerEntity.taskByHash( FundingManagerEntity.getHash("FUNDING_FAILED_START", "") ) == true) {&#13;
                    EntityStateRequired = getEntityState("FAILED_FINAL");&#13;
                }&#13;
            } else if ( CurrentEntityState == getEntityState("SUCCESSFUL_FINAL") ) {&#13;
                /*&#13;
                    STATE: SUCCESSFUL_FINAL&#13;
                    Processor Action: none&#13;
&#13;
                    External Action:&#13;
                    Application: Run Internal Processor ( Change State to IN_DEVELOPMENT )&#13;
                */&#13;
            } else if ( CurrentEntityState == getEntityState("FAILED_FINAL") ) {&#13;
                /*&#13;
                    STATE: FINAL_FAILED&#13;
                    Processor Action: none&#13;
&#13;
                    External Action:&#13;
                    Application: Run Internal Processor ( Change State to FUNDING_FAILED )&#13;
                */&#13;
            }&#13;
        }&#13;
&#13;
        return (CurrentRecordState, RecordStateRequired, EntityStateRequired);&#13;
    }&#13;
&#13;
}