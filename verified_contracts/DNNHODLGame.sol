pragma solidity ^0.4.15;

/// @title DNNToken contract - Main DNN contract
/// @author Dondrey Taylor - <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="10747f7e7462756950747e7e3e7d75747971">[email protected]</a>&gt;&#13;
contract DNNToken {&#13;
    enum DNNSupplyAllocations {&#13;
        EarlyBackerSupplyAllocation,&#13;
        PRETDESupplyAllocation,&#13;
        TDESupplyAllocation,&#13;
        BountySupplyAllocation,&#13;
        WriterAccountSupplyAllocation,&#13;
        AdvisorySupplyAllocation,&#13;
        PlatformSupplyAllocation&#13;
    }&#13;
    function balanceOf(address who) constant public returns (uint256);&#13;
    function issueTokens(address, uint256, DNNSupplyAllocations) public pure returns (bool) {}&#13;
}&#13;
&#13;
/// @title DNNHODLGame contrac&#13;
/// @author Dondrey Taylor - &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="75111a1b1107100c35111b1b5b1810111c14">[email protected]</a>&gt;&#13;
contract DNNHODLGame {&#13;
&#13;
  // DNN Token&#13;
  DNNToken public dnnToken;&#13;
&#13;
  // Owner&#13;
  address owner = 0x3Cf26a9FE33C219dB87c2e50572e50803eFb2981;&#13;
&#13;
  // Stores largest HODLER information&#13;
  uint256 public largestHODLERBalance = 0;&#13;
  address public largestHODLERAddress = 0x0;&#13;
&#13;
  // Stores last largest HODLER information&#13;
  uint256 public lastLargestHODLERBalance = 0;&#13;
  address public lastLargestHODLER = 0x0;&#13;
&#13;
	// Event that gets triggered each time a user&#13;
	// sends a redemption transaction to this smart contract&#13;
  event WINNER(address indexed to, uint256 dnnBalance, uint256 dnnWon);&#13;
	event HODLER(address indexed to, uint256 dnnBalance);&#13;
	event NEWLARGESTHODLER(address indexed from, uint256 dnnBalance);&#13;
&#13;
  // Owner&#13;
  modifier onlyOwner() {&#13;
      require (msg.sender == owner);&#13;
      _;&#13;
  }&#13;
&#13;
  // Decide DNN Winner&#13;
  function decideWinner(uint256 dnnToReward, DNNToken.DNNSupplyAllocations allocationType)&#13;
    public&#13;
    onlyOwner&#13;
  {&#13;
      if (!dnnToken.issueTokens(largestHODLERAddress, dnnToReward, allocationType)) {&#13;
          revert();&#13;
      }&#13;
      else {&#13;
          emit WINNER(largestHODLERAddress, largestHODLERBalance, dnnToReward);&#13;
          lastLargestHODLER = largestHODLERAddress;&#13;
          lastLargestHODLERBalance = largestHODLERBalance;&#13;
          largestHODLERAddress = 0x0;&#13;
          largestHODLERBalance = 0;&#13;
      }&#13;
  }&#13;
&#13;
  // Constructor&#13;
  constructor() public&#13;
  {&#13;
      dnnToken = DNNToken(0x9D9832d1beb29CC949d75D61415FD00279f84Dc2);&#13;
  }&#13;
&#13;
	// Handles incoming transactions&#13;
	function () public payable {&#13;
&#13;
      // Sender address&#13;
      address dnnHODLER = msg.sender;&#13;
&#13;
      // Sender balance&#13;
      uint256 dnnHODLERBalance = dnnToken.balanceOf(msg.sender);&#13;
&#13;
      // Check if the senders balance is the largest&#13;
      if (largestHODLERBalance &lt;= dnnHODLERBalance) {&#13;
          if ( (lastLargestHODLER != dnnHODLER) ||&#13;
              (lastLargestHODLER == dnnHODLER &amp;&amp; lastLargestHODLERBalance &lt; dnnHODLERBalance)&#13;
          ) {&#13;
              largestHODLERBalance = dnnHODLERBalance;&#13;
              largestHODLERAddress = dnnHODLER;&#13;
              emit NEWLARGESTHODLER(msg.sender, dnnHODLERBalance);&#13;
          }&#13;
      }&#13;
&#13;
      emit HODLER(msg.sender, dnnHODLERBalance);&#13;
&#13;
      if (msg.value &gt; 0) {&#13;
          owner.transfer(msg.value);&#13;
      }&#13;
	}&#13;
}