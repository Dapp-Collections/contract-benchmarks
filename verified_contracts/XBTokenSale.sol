pragma solidity ^0.4.16;
/**
 * @title xBounty Pre-seed token sale ICO Smart Contract.
 * @author <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="99f3f0edfcf7fdebf8d9faf1f0ededf6fdf8b7faf6f4">[emailÂ protected]</a>&#13;
 */&#13;
/**&#13;
 * @title SafeMath&#13;
 * @dev Math operations with safety checks that throw on error&#13;
 */&#13;
library SafeMath {&#13;
    function mul(uint256 a, uint256 b) internal constant returns (uint256) {&#13;
        uint256 c = a * b;&#13;
        assert(a == 0 || c / a == b);&#13;
        return c;&#13;
    }&#13;
&#13;
    function div(uint256 a, uint256 b) internal constant returns (uint256) {&#13;
        // assert(b &gt; 0); // Solidity automatically throws when dividing by 0&#13;
        uint256 c = a / b;&#13;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold&#13;
        return c;&#13;
    }&#13;
&#13;
    function sub(uint256 a, uint256 b) internal constant returns (uint256) {&#13;
        assert(b &lt;= a);&#13;
        return a - b;&#13;
    }&#13;
&#13;
    function add(uint256 a, uint256 b) internal constant returns (uint256) {&#13;
        uint256 c = a + b;&#13;
        assert(c &gt;= a);&#13;
        return c;&#13;
    }&#13;
}&#13;
&#13;
&#13;
/**&#13;
 * @title ERC20Basic&#13;
 * @dev Simpler version of ERC20 interface&#13;
 * @dev see https://github.com/ethereum/EIPs/issues/179&#13;
 */&#13;
contract ERC20Basic {&#13;
    uint256 public totalSupply;&#13;
    mapping(address =&gt; uint256) balances;&#13;
    function balanceOf(address _owner) public constant returns (uint256) { return balances[_owner]; }&#13;
    //Transfer is disabled&#13;
    //function transfer(address to, uint256 value) public returns (bool);&#13;
    event Transfer(address indexed from, address indexed to, uint256 value);&#13;
}&#13;
&#13;
&#13;
/**&#13;
 * @title Ownable&#13;
 * @dev The Ownable contract has an owner address, and provides basic authorization control&#13;
 * functions, this simplifies the implementation of "user permissions".&#13;
 */&#13;
contract Ownable {&#13;
    address public owner;&#13;
&#13;
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);&#13;
&#13;
    /**&#13;
     * @dev The Ownable constructor sets the original `owner` of the contract to the sender&#13;
     * account.&#13;
     */&#13;
    function Ownable() {&#13;
        owner = msg.sender;&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Throws if called by any account other than the owner.&#13;
     */&#13;
    modifier onlyOwner() {&#13;
        require(msg.sender == owner);&#13;
        _;&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Allows the current owner to transfer control of the contract to a newOwner.&#13;
     * @param newOwner The address to transfer ownership to.&#13;
     */&#13;
    function transferOwnership(address newOwner) onlyOwner public {&#13;
        require(newOwner != address(0));&#13;
        OwnershipTransferred(owner, newOwner);&#13;
        owner = newOwner;&#13;
    }&#13;
&#13;
}&#13;
&#13;
&#13;
/**&#13;
 * @title Pausable&#13;
 * @dev Base contract which allows children to implement an emergency stop mechanism.&#13;
 */&#13;
contract Pausable is Ownable {&#13;
    event Pause();&#13;
    event Unpause();&#13;
&#13;
    bool public paused = false;&#13;
&#13;
&#13;
    /**&#13;
     * @dev Modifier to make a function callable only when the contract is not paused.&#13;
     */&#13;
    modifier whenNotPaused() {&#13;
        require(!paused);&#13;
        _;&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Modifier to make a function callable only when the contract is paused.&#13;
     */&#13;
    modifier whenPaused() {&#13;
        require(paused);&#13;
        _;&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev called by the owner to pause, triggers stopped state&#13;
     */&#13;
    function pause() onlyOwner whenNotPaused public {&#13;
        paused = true;&#13;
        Pause();&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev called by the owner to unpause, returns to normal state&#13;
     */&#13;
    function unpause() onlyOwner whenPaused public {&#13;
        paused = false;&#13;
        Unpause();&#13;
    }&#13;
}&#13;
&#13;
&#13;
contract XBTokenSale is ERC20Basic, Pausable {&#13;
&#13;
    using SafeMath for uint256;&#13;
    string public constant name = "XB Token";&#13;
    string public constant symbol = "XB";&#13;
    uint256 public constant decimals = 18;&#13;
&#13;
    // address where funds are collected&#13;
    address public wallet;&#13;
&#13;
    // Total XB tokens for PreSale&#13;
    uint256 public constant TOTAL_XB_TOKEN_FOR_PRE_SALE = 2640000 * (10**decimals); //2,640,000 * 10^decimals&#13;
&#13;
    // how many token units a buyer gets per ETH&#13;
    uint256 public rate = 1250; //1250 XB tokens per ETH, including 25% discount&#13;
&#13;
    // How many sold in PreSale&#13;
    uint256 public presaleSoldTokens = 0;&#13;
&#13;
    // amount of raised money in wei&#13;
    uint256 public weiRaised;&#13;
&#13;
    /**&#13;
     * event for token purchase logging&#13;
     * @param purchaser who paid for the tokens&#13;
     * @param beneficiary who got the tokens&#13;
     * @param value weis paid for purchase&#13;
     * @param amount amount of tokens purchased&#13;
     */&#13;
    event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);&#13;
    event Mint(address indexed to, uint256 amount);&#13;
&#13;
    function XBTokenSale(address _wallet) public {&#13;
        require(_wallet != 0x0);&#13;
        wallet = _wallet;&#13;
    }&#13;
&#13;
&#13;
    // fallback function can be used to buy tokens&#13;
    function () whenNotPaused public payable {&#13;
        buyTokens(msg.sender);&#13;
    }&#13;
&#13;
    // low level token purchase function&#13;
    //Only when the PreSale is running&#13;
    function buyTokens(address beneficiary) whenNotPaused public payable {&#13;
        require(beneficiary != 0x0);&#13;
&#13;
        uint256 weiAmount = msg.value;&#13;
&#13;
        // calculate token amount to be created&#13;
        uint256 tokens = weiAmount.mul(rate);&#13;
&#13;
        require(presaleSoldTokens + tokens &lt;= TOTAL_XB_TOKEN_FOR_PRE_SALE);&#13;
        presaleSoldTokens = presaleSoldTokens.add(tokens);&#13;
&#13;
        // update state&#13;
        weiRaised = weiRaised.add(weiAmount);&#13;
&#13;
        mint(beneficiary, tokens);&#13;
        TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);&#13;
&#13;
        forwardFunds();&#13;
    }&#13;
&#13;
&#13;
    /**&#13;
      * @dev Function to mint tokens&#13;
      * @param _to The address that will receive the minted tokens.&#13;
      * @param _amount The amount of tokens to mint.&#13;
      * @return A boolean that indicates if the operation was successful.&#13;
      */&#13;
    function mint(address _to, uint256 _amount) internal returns (bool) {&#13;
        totalSupply = totalSupply.add(_amount);&#13;
        balances[_to] = balances[_to].add(_amount);&#13;
        Mint(_to, _amount);&#13;
        Transfer(0x0, _to, _amount);&#13;
        return true;&#13;
    }&#13;
&#13;
&#13;
    // send ether to the fund collection wallet&#13;
    // override to create custom fund forwarding mechanisms&#13;
    function forwardFunds() internal {&#13;
        wallet.transfer(msg.value);&#13;
    }&#13;
&#13;
}