pragma solidity ^0.4.18;
/* ==================================================================== */
/* Copyright (c) 2018 The MagicAcademy Project.  All rights reserved.
/* 
/* https://www.magicacademy.io One of the world's first idle strategy games of blockchain 
/*  
/* authors <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="d3a1b2babdaa93bfbaa5b6a0a7b2a1fdb0bcbe">[email protected]</a>/<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="d2b4b3bcbcabfca8bab7bcb592bebba4b7a1a6b3a0fcb1bdbf">[email protected]</a>&#13;
/*                 &#13;
/* ==================================================================== */&#13;
&#13;
/**&#13;
 * @title Ownable&#13;
 * @dev The Ownable contract has an owner address, and provides basic authorization control&#13;
 * functions, this simplifies the implementation of "user permissions".&#13;
 */&#13;
contract Ownable {&#13;
  address public owner;&#13;
&#13;
  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);&#13;
&#13;
  /*&#13;
   * @dev The Ownable constructor sets the original `owner` of the contract to the sender&#13;
   * account.&#13;
   */&#13;
  function Ownable() public {&#13;
    owner = msg.sender;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Throws if called by any account other than the owner.&#13;
   */&#13;
  modifier onlyOwner() {&#13;
    require(msg.sender == owner);&#13;
    _;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Allows the current owner to transfer control of the contract to a newOwner.&#13;
   * @param newOwner The address to transfer ownership to.&#13;
   */&#13;
  function transferOwnership(address newOwner) public onlyOwner {&#13;
    require(newOwner != address(0));&#13;
    OwnershipTransferred(owner, newOwner);&#13;
    owner = newOwner;&#13;
  }&#13;
}&#13;
library SafeMath {&#13;
&#13;
  /**&#13;
  * @dev Multiplies two numbers, throws on overflow.&#13;
  */&#13;
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
    if (a == 0) {&#13;
      return 0;&#13;
    }&#13;
    uint256 c = a * b;&#13;
    assert(c / a == b);&#13;
    return c;&#13;
  }&#13;
&#13;
  /**&#13;
  * @dev Integer division of two numbers, truncating the quotient.&#13;
  */&#13;
  function div(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
    // assert(b &gt; 0); // Solidity automatically throws when dividing by 0&#13;
    uint256 c = a / b;&#13;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold&#13;
    return c;&#13;
  }&#13;
&#13;
  /**&#13;
  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).&#13;
  */&#13;
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
    assert(b &lt;= a);&#13;
    return a - b;&#13;
  }&#13;
&#13;
  /**&#13;
  * @dev Adds two numbers, throws on overflow.&#13;
  */&#13;
  function add(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
    uint256 c = a + b;&#13;
    assert(c &gt;= a);&#13;
    return c;&#13;
  }&#13;
}&#13;
&#13;
interface CardsInterface {&#13;
    function getJadeProduction(address player) external constant returns (uint256);&#13;
    function getUpgradeValue(address player, uint256 upgradeClass, uint256 unitId, uint256 upgradeValue) external view returns (uint256);&#13;
    function getGameStarted() external constant returns (bool);&#13;
    function balanceOf(address player) external constant returns(uint256);&#13;
    function balanceOfUnclaimed(address player) external constant returns (uint256);&#13;
    function coinBalanceOf(address player,uint8 itype) external constant returns(uint256);&#13;
&#13;
    function setCoinBalance(address player, uint256 eth, uint8 itype, bool iflag) external;&#13;
    function setJadeCoin(address player, uint256 coin, bool iflag) external;&#13;
    function setJadeCoinZero(address player) external;&#13;
&#13;
    function setLastJadeSaveTime(address player) external;&#13;
    function setRoughSupply(uint256 iroughSupply) external;&#13;
&#13;
    function updatePlayersCoinByPurchase(address player, uint256 purchaseCost) external;&#13;
    function updatePlayersCoinByOut(address player) external;&#13;
&#13;
    function increasePlayersJadeProduction(address player, uint256 increase) external;&#13;
    function reducePlayersJadeProduction(address player, uint256 decrease) external;&#13;
&#13;
    function getUintsOwnerCount(address _address) external view returns (uint256);&#13;
    function setUintsOwnerCount(address _address, uint256 amount, bool iflag) external;&#13;
&#13;
    function getOwnedCount(address player, uint256 cardId) external view returns (uint256);&#13;
    function setOwnedCount(address player, uint256 cardId, uint256 amount, bool iflag) external;&#13;
&#13;
    function getUpgradesOwned(address player, uint256 upgradeId) external view returns (uint256);&#13;
    function setUpgradesOwned(address player, uint256 upgradeId) external;&#13;
    &#13;
    function getTotalEtherPool(uint8 itype) external view returns (uint256);&#13;
    function setTotalEtherPool(uint256 inEth, uint8 itype, bool iflag) external;&#13;
&#13;
    function setNextSnapshotTime(uint256 iTime) external;&#13;
    function getNextSnapshotTime() external view;&#13;
&#13;
    function AddPlayers(address _address) external;&#13;
    function getTotalUsers()  external view returns (uint256);&#13;
    function getRanking() external view returns (address[] addr, uint256[] _arr);&#13;
    function getAttackRanking() external view returns (address[] addr, uint256[] _arr);&#13;
&#13;
    function getUnitsProduction(address player, uint256 cardId, uint256 amount) external constant returns (uint256);&#13;
&#13;
    function getUnitCoinProductionIncreases(address _address, uint256 cardId) external view returns (uint256);&#13;
    function setUnitCoinProductionIncreases(address _address, uint256 cardId, uint256 iValue,bool iflag) external;&#13;
     function getUnitCoinProductionMultiplier(address _address, uint256 cardId) external view returns (uint256);&#13;
    function setUnitCoinProductionMultiplier(address _address, uint256 cardId, uint256 iValue,bool iflag) external;&#13;
     function setUnitAttackIncreases(address _address, uint256 cardId, uint256 iValue,bool iflag) external;&#13;
    function setUnitAttackMultiplier(address _address, uint256 cardId, uint256 iValue,bool iflag) external;&#13;
    function setUnitDefenseIncreases(address _address, uint256 cardId, uint256 iValue,bool iflag) external;&#13;
    function setunitDefenseMultiplier(address _address, uint256 cardId, uint256 iValue,bool iflag) external;&#13;
    &#13;
    function setUnitJadeStealingIncreases(address _address, uint256 cardId, uint256 iValue,bool iflag) external;&#13;
    function setUnitJadeStealingMultiplier(address _address, uint256 cardId, uint256 iValue,bool iflag) external;&#13;
&#13;
    function setUintCoinProduction(address _address, uint256 cardId, uint256 iValue,bool iflag) external;&#13;
    function getUintCoinProduction(address _address, uint256 cardId) external returns (uint256);&#13;
&#13;
    function getUnitsInProduction(address player, uint256 unitId, uint256 amount) external constant returns (uint256);&#13;
    function getPlayersBattleStats(address player) public constant returns (&#13;
    uint256 attackingPower, &#13;
    uint256 defendingPower, &#13;
    uint256 stealingPower,&#13;
    uint256 battlePower); &#13;
}&#13;
&#13;
interface GameConfigInterface {&#13;
  function getMaxCAP() external returns (uint256);&#13;
  function unitCoinProduction(uint256 cardId) external constant returns (uint256);&#13;
  function unitPLATCost(uint256 cardId) external constant returns (uint256);&#13;
  function getCostForCards(uint256 cardId, uint256 existing, uint256 amount) external constant returns (uint256);&#13;
  function getCostForBattleCards(uint256 cardId, uint256 existing, uint256 amount) external constant returns (uint256);&#13;
  function unitBattlePLATCost(uint256 cardId) external constant returns (uint256);&#13;
  function getUpgradeCardsInfo(uint256 upgradecardId,uint256 existing) external constant returns (&#13;
    uint256 coinCost, &#13;
    uint256 ethCost, &#13;
    uint256 upgradeClass, &#13;
    uint256 cardId, &#13;
    uint256 upgradeValue,&#13;
    uint256 platCost&#13;
  );&#13;
 function getCardInfo(uint256 cardId, uint256 existing, uint256 amount) external constant returns (uint256, uint256, uint256, uint256, bool);&#13;
 function getBattleCardInfo(uint256 cardId, uint256 existing, uint256 amount) external constant returns (uint256, uint256, uint256, bool);&#13;
}&#13;
interface RareInterface {&#13;
  function getRareItemsOwner(uint256 rareId) external view returns (address);&#13;
  function getRareItemsPrice(uint256 rareId) external view returns (uint256);&#13;
  function getRareItemsPLATPrice(uint256 rareId) external view returns (uint256);&#13;
   function getRarePLATInfo(uint256 _tokenId) external view returns (&#13;
    uint256 sellingPrice,&#13;
    address owner,&#13;
    uint256 nextPrice,&#13;
    uint256 rareClass,&#13;
    uint256 cardId,&#13;
    uint256 rareValue&#13;
  );&#13;
  function transferToken(address _from, address _to, uint256 _tokenId) external;&#13;
  function setRarePrice(uint256 _rareId, uint256 _price) external;&#13;
}&#13;
&#13;
contract BitGuildHelper is Ownable {&#13;
  //data contract&#13;
  CardsInterface public cards ;&#13;
  GameConfigInterface public schema;&#13;
  RareInterface public rare;&#13;
&#13;
  function setCardsAddress(address _address) external onlyOwner {&#13;
    cards = CardsInterface(_address);&#13;
  }&#13;
&#13;
   //normal cards&#13;
  function setConfigAddress(address _address) external onlyOwner {&#13;
    schema = GameConfigInterface(_address);&#13;
  }&#13;
&#13;
  //rare cards&#13;
  function setRareAddress(address _address) external onlyOwner {&#13;
    rare = RareInterface(_address);&#13;
  }&#13;
  &#13;
/// add multiplier&#13;
  function upgradeUnitMultipliers(address player, uint256 upgradeClass, uint256 unitId, uint256 upgradeValue) internal {&#13;
    uint256 productionGain;&#13;
    if (upgradeClass == 0) {&#13;
      cards.setUnitCoinProductionIncreases(player, unitId, upgradeValue,true);&#13;
      productionGain = (cards.getOwnedCount(player,unitId) * upgradeValue * (10 + cards.getUnitCoinProductionMultiplier(player,unitId)));&#13;
      cards.setUintCoinProduction(player,unitId,productionGain,true); &#13;
      cards.increasePlayersJadeProduction(player,productionGain);&#13;
    } else if (upgradeClass == 1) {&#13;
      cards.setUnitCoinProductionMultiplier(player,unitId,upgradeValue,true);&#13;
      productionGain = (cards.getOwnedCount(player,unitId) * upgradeValue * (schema.unitCoinProduction(unitId) + cards.getUnitCoinProductionIncreases(player,unitId)));&#13;
      cards.setUintCoinProduction(player,unitId,productionGain,true);&#13;
      cards.increasePlayersJadeProduction(player,productionGain);&#13;
    } else if (upgradeClass == 2) {&#13;
      cards.setUnitAttackIncreases(player,unitId,upgradeValue,true);&#13;
    } else if (upgradeClass == 3) {&#13;
      cards.setUnitAttackMultiplier(player,unitId,upgradeValue,true);&#13;
    } else if (upgradeClass == 4) {&#13;
      cards.setUnitDefenseIncreases(player,unitId,upgradeValue,true);&#13;
    } else if (upgradeClass == 5) {&#13;
      cards.setunitDefenseMultiplier(player,unitId,upgradeValue,true);&#13;
    } else if (upgradeClass == 6) {&#13;
      cards.setUnitJadeStealingIncreases(player,unitId,upgradeValue,true);&#13;
    } else if (upgradeClass == 7) {&#13;
      cards.setUnitJadeStealingMultiplier(player,unitId,upgradeValue,true);&#13;
    }&#13;
  }&#13;
  /// move multipliers&#13;
  function removeUnitMultipliers(address player, uint256 upgradeClass, uint256 unitId, uint256 upgradeValue) internal {&#13;
    uint256 productionLoss;&#13;
    if (upgradeClass == 0) {&#13;
      cards.setUnitCoinProductionIncreases(player, unitId, upgradeValue,false);&#13;
      productionLoss = (cards.getOwnedCount(player,unitId) * upgradeValue * (10 + cards.getUnitCoinProductionMultiplier(player,unitId)));&#13;
      cards.setUintCoinProduction(player,unitId,productionLoss,false); &#13;
      cards.reducePlayersJadeProduction(player, productionLoss);&#13;
    } else if (upgradeClass == 1) {&#13;
      cards.setUnitCoinProductionMultiplier(player,unitId,upgradeValue,false);&#13;
      productionLoss = (cards.getOwnedCount(player,unitId) * upgradeValue * (schema.unitCoinProduction(unitId) + cards.getUnitCoinProductionIncreases(player,unitId)));&#13;
      cards.setUintCoinProduction(player,unitId,productionLoss,false); &#13;
      cards.reducePlayersJadeProduction(player, productionLoss);&#13;
    } else if (upgradeClass == 2) {&#13;
      cards.setUnitAttackIncreases(player,unitId,upgradeValue,false);&#13;
    } else if (upgradeClass == 3) {&#13;
      cards.setUnitAttackMultiplier(player,unitId,upgradeValue,false);&#13;
    } else if (upgradeClass == 4) {&#13;
      cards.setUnitDefenseIncreases(player,unitId,upgradeValue,false);&#13;
    } else if (upgradeClass == 5) {&#13;
      cards.setunitDefenseMultiplier(player,unitId,upgradeValue,false);&#13;
    } else if (upgradeClass == 6) { &#13;
      cards.setUnitJadeStealingIncreases(player,unitId,upgradeValue,false);&#13;
    } else if (upgradeClass == 7) {&#13;
      cards.setUnitJadeStealingMultiplier(player,unitId,upgradeValue,false);&#13;
    }&#13;
  }&#13;
}&#13;
&#13;
interface BitGuildTokenInterface { // implements ERC20Interface&#13;
  function totalSupply() public constant returns (uint);&#13;
  function balanceOf(address tokenOwner) public constant returns (uint balance);&#13;
  function allowance(address tokenOwner, address spender) public constant returns (uint remaining);&#13;
  function transfer(address to, uint tokens) public returns (bool success);&#13;
  function approve(address spender, uint tokens) public returns (bool success);&#13;
  function transferFrom(address from, address to, uint tokens) public returns (bool success);&#13;
&#13;
  event Transfer(address indexed from, address indexed to, uint tokens);&#13;
  event Approval(address indexed tokenOwner, address indexed spender, uint tokens);&#13;
}&#13;
/// @notice Purchase on BitGuild&#13;
contract BitGuildTrade is BitGuildHelper {&#13;
  BitGuildTokenInterface public tokenContract;&#13;
&#13;
  event UnitBought(address player, uint256 unitId, uint256 amount);&#13;
  event UpgradeCardBought(address player, uint256 upgradeId);&#13;
  event BuyRareCard(address player, address previous, uint256 rareId,uint256 iPrice);&#13;
  event UnitSold(address player, uint256 unitId, uint256 amount);&#13;
&#13;
  mapping(address =&gt; mapping(uint256 =&gt; uint256)) unitsOwnedOfPLAT; //cards bought through plat&#13;
  function() external payable {&#13;
    revert();&#13;
  }&#13;
  function setBitGuildToken(address _tokenContract) external {&#13;
    tokenContract = BitGuildTokenInterface(_tokenContract);&#13;
  } &#13;
&#13;
  function kill() public onlyOwner {&#13;
    tokenContract.transferFrom(this, msg.sender, tokenContract.balanceOf(this));&#13;
    selfdestruct(msg.sender); //end execution, destroy current contract and send funds to a&#13;
  }  &#13;
  /// @notice Returns all the relevant information about a specific tokenId.&#13;
  /// val1:flag,val2:id,val3:amount&#13;
  function _getExtraParam(bytes _extraData) private pure returns(uint256 val1,uint256 val2,uint256 val3) {&#13;
    if (_extraData.length == 2) {&#13;
      val1 = uint256(_extraData[0]);&#13;
      val2 = uint256(_extraData[1]);&#13;
      val3 = 1; &#13;
    } else if (_extraData.length == 3) {&#13;
      val1 = uint256(_extraData[0]);&#13;
      val2 = uint256(_extraData[1]);&#13;
      val3 = uint256(_extraData[2]);&#13;
    }&#13;
    &#13;
  }&#13;
  &#13;
  function receiveApproval(address _player, uint256 _value, address _tokenContractAddr, bytes _extraData) external {&#13;
    require(msg.sender == _tokenContractAddr);&#13;
    require(_extraData.length &gt;=1);&#13;
    require(tokenContract.transferFrom(_player, address(this), _value));&#13;
    uint256 flag;&#13;
    uint256 unitId;&#13;
    uint256 amount;&#13;
    (flag,unitId,amount) = _getExtraParam(_extraData);&#13;
&#13;
    if (flag==1) {&#13;
      buyPLATCards(_player, _value, unitId, amount);  // 1-39&#13;
    } else if (flag==3) {&#13;
      buyUpgradeCard(_player, _value, unitId);  // &gt;=1&#13;
    } else if (flag==4) {&#13;
      buyRareItem(_player, _value, unitId); //rarecard&#13;
    } &#13;
  } &#13;
&#13;
  function buyPLATCards(address _player, uint256 _platValue, uint256 _cardId, uint256 _amount) internal {&#13;
    require(cards.getGameStarted());&#13;
    require(_amount&gt;=1);&#13;
    uint256 existing = cards.getOwnedCount(_player,_cardId);&#13;
    require(existing &lt; schema.getMaxCAP());    &#13;
    &#13;
    uint256 iAmount;&#13;
    if (SafeMath.add(existing, _amount) &gt; schema.getMaxCAP()) {&#13;
      iAmount = SafeMath.sub(schema.getMaxCAP(),existing);&#13;
    } else {&#13;
      iAmount = _amount;&#13;
    }&#13;
    uint256 coinProduction;&#13;
    uint256 coinCost;&#13;
    uint256 ethCost;&#13;
&#13;
    if (_cardId&gt;=1 &amp;&amp; _cardId&lt;=39) {&#13;
      coinProduction = schema.unitCoinProduction(_cardId);&#13;
      coinCost = schema.getCostForCards(_cardId, existing, iAmount);&#13;
      ethCost = SafeMath.mul(schema.unitPLATCost(_cardId),iAmount);  // get platprice&#13;
    } else if (_cardId&gt;=40) {&#13;
      coinCost = schema.getCostForBattleCards(_cardId, existing, iAmount);&#13;
      ethCost = SafeMath.mul(schema.unitBattlePLATCost(_cardId),iAmount);  // get platprice&#13;
    }&#13;
    require(ethCost&gt;0);&#13;
    require(SafeMath.add(cards.coinBalanceOf(_player,1),_platValue) &gt;= ethCost);&#13;
    require(cards.balanceOf(_player) &gt;= coinCost);   &#13;
&#13;
    // Update players jade  &#13;
    cards.updatePlayersCoinByPurchase(_player, coinCost);&#13;
&#13;
    if (ethCost &gt; _platValue) {&#13;
      cards.setCoinBalance(_player,SafeMath.sub(ethCost,_platValue),1,false);&#13;
    } else if (_platValue &gt; ethCost) {&#13;
      // Store overbid in their balance&#13;
      cards.setCoinBalance(_player,SafeMath.sub(_platValue,ethCost),1,true);&#13;
    } &#13;
&#13;
    uint256 devFund = uint256(SafeMath.div(ethCost,20)); // 5% fee&#13;
    cards.setTotalEtherPool(uint256(SafeMath.div(ethCost,4)),1,true);  // 20% to pool&#13;
    cards.setCoinBalance(owner,devFund,1,true);  &#13;
    &#13;
    if (coinProduction &gt; 0) {&#13;
      cards.increasePlayersJadeProduction(_player, cards.getUnitsProduction(_player, _cardId, iAmount)); &#13;
      cards.setUintCoinProduction(_player,_cardId,cards.getUnitsProduction(_player, _cardId, iAmount),true); &#13;
    }&#13;
    &#13;
    if (cards.getUintsOwnerCount(_player)&lt;=0) {&#13;
      cards.AddPlayers(_player);&#13;
    }&#13;
    cards.setUintsOwnerCount(_player,iAmount, true);&#13;
    cards.setOwnedCount(_player,_cardId,iAmount,true);&#13;
    unitsOwnedOfPLAT[_player][_cardId] = SafeMath.add(unitsOwnedOfPLAT[_player][_cardId],iAmount);&#13;
    //event&#13;
    UnitBought(_player, _cardId, iAmount);&#13;
  }&#13;
&#13;
  /// upgrade cards-- jade + plat&#13;
  function buyUpgradeCard(address _player, uint256 _platValue,uint256 _upgradeId) internal {&#13;
    require(cards.getGameStarted());&#13;
    require(_upgradeId&gt;=1);&#13;
    uint256 existing = cards.getUpgradesOwned(_player,_upgradeId);&#13;
    require(existing&lt;=5);  // v1 - v6&#13;
    uint256 coinCost;&#13;
    uint256 ethCost;&#13;
    uint256 upgradeClass;&#13;
    uint256 unitId;&#13;
    uint256 upgradeValue;&#13;
    uint256 platCost;&#13;
    (coinCost, ethCost, upgradeClass, unitId, upgradeValue,platCost) = schema.getUpgradeCardsInfo(_upgradeId,existing);&#13;
&#13;
    require(platCost&gt;0);&#13;
    if (platCost &gt; 0) {&#13;
      require(SafeMath.add(cards.coinBalanceOf(_player,1),_platValue) &gt;= platCost); &#13;
&#13;
      if (platCost &gt; _platValue) { // They can use their balance instead&#13;
        cards.setCoinBalance(_player, SafeMath.sub(platCost,_platValue),1,false);&#13;
      } else if (platCost &lt; _platValue) {  &#13;
        cards.setCoinBalance(_player,SafeMath.sub(_platValue,platCost),1,true);&#13;
    } &#13;
      &#13;
&#13;
      // defund 5%，upgrade card can not be sold，&#13;
      uint256 devFund = uint256(SafeMath.div(platCost, 20)); // 5% fee on purchases (marketing, gameplay &amp; maintenance)&#13;
      cards.setTotalEtherPool(SafeMath.sub(platCost,devFund),1,true); // Rest goes to div pool (Can't sell upgrades)&#13;
      cards.setCoinBalance(owner,devFund,1,true);  &#13;
    }&#13;
        &#13;
     // Update &#13;
    require(cards.balanceOf(_player) &gt;= coinCost);  &#13;
    cards.updatePlayersCoinByPurchase(_player, coinCost);&#13;
    &#13;
    //add weight&#13;
    upgradeUnitMultipliers(_player, upgradeClass, unitId, upgradeValue);  &#13;
    cards.setUpgradesOwned(_player,_upgradeId); // upgrade level up&#13;
&#13;
     //add user to userlist&#13;
    if (cards.getUintsOwnerCount(_player)&lt;=0) {&#13;
      cards.AddPlayers(_player);&#13;
    }&#13;
 &#13;
    UpgradeCardBought(_player, _upgradeId);&#13;
  }&#13;
&#13;
  // Allows someone to send ether and obtain the token&#13;
  function buyRareItem(address _player, uint256 _platValue,uint256 _rareId) internal {&#13;
    require(cards.getGameStarted());        &#13;
    address previousOwner = rare.getRareItemsOwner(_rareId);  // rare card&#13;
    require(previousOwner != 0);&#13;
    require(_player!=previousOwner);  // can not buy from itself&#13;
    &#13;
    uint256 ethCost = rare.getRareItemsPLATPrice(_rareId); // get plat cost&#13;
    uint256 totalCost = SafeMath.add(cards.coinBalanceOf(_player,1),_platValue);&#13;
    require(totalCost &gt;= ethCost); &#13;
    // We have to claim buyer/sellder's goo before updating their production values &#13;
    cards.updatePlayersCoinByOut(_player);&#13;
    cards.updatePlayersCoinByOut(previousOwner);&#13;
&#13;
    uint256 upgradeClass;&#13;
    uint256 unitId;&#13;
    uint256 upgradeValue;&#13;
    (,,,,upgradeClass, unitId, upgradeValue) = rare.getRarePLATInfo(_rareId);&#13;
    &#13;
    // modify weight&#13;
    upgradeUnitMultipliers(_player, upgradeClass, unitId, upgradeValue); &#13;
    removeUnitMultipliers(previousOwner, upgradeClass, unitId, upgradeValue); &#13;
&#13;
    // Splitbid/Overbid&#13;
    if (ethCost &gt; _platValue) {&#13;
      cards.setCoinBalance(_player,SafeMath.sub(ethCost,_platValue),1,false);&#13;
    } else if (_platValue &gt; ethCost) {&#13;
      // Store overbid in their balance&#13;
      cards.setCoinBalance(_player,SafeMath.sub(_platValue,ethCost),1,true);&#13;
    }  &#13;
    // Distribute ethCost  uint256 devFund = ethCost / 50; &#13;
    uint256 devFund = uint256(SafeMath.div(ethCost, 20)); // 5% fee on purchases (marketing, gameplay &amp; maintenance)  抽成2%&#13;
    uint256 dividends = uint256(SafeMath.div(ethCost,20)); // 5% goes to pool &#13;
&#13;
    cards.setTotalEtherPool(dividends,1,true);  // 5% to pool&#13;
    cards.setCoinBalance(owner,devFund,1,true);  // 5% fee&#13;
        &#13;
    // Transfer / update rare item&#13;
    rare.transferToken(previousOwner,_player,_rareId); &#13;
    rare.setRarePrice(_rareId,SafeMath.div(SafeMath.mul(rare.getRareItemsPrice(_rareId),5),4));&#13;
    &#13;
    cards.setCoinBalance(previousOwner,SafeMath.sub(ethCost,SafeMath.add(dividends,devFund)),1,true);&#13;
    &#13;
    if (cards.getUintsOwnerCount(_player)&lt;=0) {&#13;
      cards.AddPlayers(_player);&#13;
    }&#13;
   &#13;
    cards.setUintsOwnerCount(_player,1,true);&#13;
    cards.setUintsOwnerCount(previousOwner,1,true);&#13;
&#13;
    //tell the world&#13;
    BuyRareCard(_player, previousOwner, _rareId, ethCost);&#13;
  }&#13;
&#13;
  /// refunds 75% since no transfer between bitguild and player,no need to call approveAndCall&#13;
  function sellCards( uint256 _unitId, uint256 _amount) external {&#13;
    require(cards.getGameStarted());&#13;
    uint256 existing = cards.getOwnedCount(msg.sender,_unitId);&#13;
    require(existing &gt;= _amount &amp;&amp; _amount&gt;0); &#13;
    existing = SafeMath.sub(existing,_amount);&#13;
    uint256 coinChange;&#13;
    uint256 decreaseCoin;&#13;
    uint256 schemaUnitId;&#13;
    uint256 coinProduction;&#13;
    uint256 coinCost;&#13;
    uint256 ethCost;&#13;
    bool sellable;&#13;
    if (_unitId&gt;=40) { // upgrade card&#13;
      (schemaUnitId,coinCost,, sellable) = schema.getBattleCardInfo(_unitId, existing, _amount);&#13;
      ethCost = SafeMath.mul(schema.unitBattlePLATCost(_unitId),_amount);&#13;
    } else {&#13;
      (schemaUnitId, coinProduction, coinCost, , sellable) = schema.getCardInfo(_unitId, existing, _amount);&#13;
      ethCost = SafeMath.mul(schema.unitPLATCost(_unitId),_amount); // plat &#13;
    }&#13;
    require(sellable);  // can be refunded&#13;
    if (ethCost&gt;0) {&#13;
      require(unitsOwnedOfPLAT[msg.sender][_unitId]&gt;=_amount);&#13;
    }&#13;
    if (coinCost&gt;0) {&#13;
      coinChange = SafeMath.add(cards.balanceOfUnclaimed(msg.sender), SafeMath.div(SafeMath.mul(coinCost,70),100)); // Claim unsaved goo whilst here&#13;
    } else {&#13;
      coinChange = cards.balanceOfUnclaimed(msg.sender); &#13;
    }&#13;
&#13;
    cards.setLastJadeSaveTime(msg.sender); &#13;
    cards.setRoughSupply(coinChange);  &#13;
    cards.setJadeCoin(msg.sender, coinChange, true); // refund 75% Jadecoin to player &#13;
&#13;
    decreaseCoin = cards.getUnitsInProduction(msg.sender, _unitId, _amount);&#13;
  &#13;
    if (coinProduction &gt; 0) { &#13;
      cards.reducePlayersJadeProduction(msg.sender, decreaseCoin);&#13;
      //update the speed of jade minning&#13;
      cards.setUintCoinProduction(msg.sender,_unitId,decreaseCoin,false); &#13;
    }&#13;
&#13;
    if (ethCost &gt; 0) { // Premium units sell for 75% of buy cost&#13;
      cards.setCoinBalance(msg.sender,SafeMath.div(SafeMath.mul(ethCost,70),100),1,true);&#13;
    }&#13;
&#13;
    cards.setOwnedCount(msg.sender,_unitId,_amount,false); &#13;
    cards.setUintsOwnerCount(msg.sender,_amount,false);&#13;
    if (ethCost&gt;0) {&#13;
      unitsOwnedOfPLAT[msg.sender][_unitId] = SafeMath.sub(unitsOwnedOfPLAT[msg.sender][_unitId],_amount);&#13;
    }&#13;
    //tell the world&#13;
    UnitSold(msg.sender, _unitId, _amount);&#13;
  }&#13;
&#13;
  //@notice for player withdraw&#13;
  function withdrawEtherFromTrade(uint256 amount) external {&#13;
    require(amount &lt;= cards.coinBalanceOf(msg.sender,1));&#13;
    cards.setCoinBalance(msg.sender,amount,1,false);&#13;
    tokenContract.transfer(msg.sender,amount);&#13;
  } &#13;
&#13;
  //@notice withraw all PLAT by dev&#13;
  function withdrawToken(uint256 amount) external onlyOwner {&#13;
    uint256 balance = tokenContract.balanceOf(this);&#13;
    require(balance &gt; 0 &amp;&amp; balance &gt;= amount);&#13;
    cards.setCoinBalance(msg.sender,amount,1,false);&#13;
    tokenContract.transfer(msg.sender, amount);&#13;
  }&#13;
&#13;
  function getCanSellUnit(address _address, uint256 unitId) external view returns (uint256) {&#13;
    return unitsOwnedOfPLAT[_address][unitId];&#13;
  }&#13;
}