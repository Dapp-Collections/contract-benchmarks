pragma solidity ^0.4.17;

/// @title Interface for contracts conforming to ERC-721: Non-Fungible Tokens
/// @author Dieter Shirley <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="ee8a8b9a8bae8f96878183948b80c08d81">[email protected]</a>&gt; (https://github.com/dete)&#13;
contract ERC721 {&#13;
    // Required methods&#13;
    function implementsERC721() public pure returns (bool);&#13;
    function totalSupply() public view returns (uint256 total);&#13;
    function balanceOf(address _owner) public view returns (uint256 balance);&#13;
    function ownerOf(uint256 _tokenId) external view returns (address owner);&#13;
    function approve(address _to, uint256 _tokenId) external;&#13;
    function transfer(address _to, uint256 _tokenId) public;&#13;
    function transferFrom(address _from, address _to, uint256 _tokenId) external;&#13;
&#13;
    // Events&#13;
    event Transfer(address from, address to, uint256 tokenId);&#13;
    event Approval(address owner, address approved, uint256 tokenId);&#13;
    // Optional&#13;
    // function name() public view returns (string name);&#13;
    // function symbol() public view returns (string symbol);&#13;
    // function tokensOfOwner(address _owner) external view returns (uint256[] tokenIds);&#13;
    // function tokenMetadata(uint256 _tokenId, string _preferredTransport) public view returns (string infoUrl);&#13;
&#13;
    // ERC-165 Compatibility (https://github.com/ethereum/EIPs/issues/165)&#13;
    // function supportsInterface(bytes4 _interfaceID) external view returns (bool);&#13;
}&#13;
&#13;
contract FootballerAccessControl{&#13;
&#13;
  ///@dev Emited when contract is upgraded&#13;
  event ContractUpgrade(address newContract);&#13;
  //The address of manager (the account or contracts) that can execute action within the role.&#13;
  address public managerAddress;&#13;
&#13;
  ///@dev keeps track whether the contract is paused.&#13;
  bool public paused = false;&#13;
&#13;
  function FootballerAccessControl() public {&#13;
    managerAddress = msg.sender;&#13;
  }&#13;
&#13;
  /// @dev Access modifier for manager-only functionality&#13;
  modifier onlyManager() {&#13;
    require(msg.sender == managerAddress);&#13;
    _;&#13;
  }&#13;
&#13;
  ///@dev assigns a new address to act as the Manager.Only available to the current Manager.&#13;
  function setManager(address _newManager) external onlyManager {&#13;
    require(_newManager != address(0));&#13;
    managerAddress = _newManager;&#13;
  }&#13;
&#13;
  /*** Pausable functionality adapted from OpenZeppelin ***/&#13;
&#13;
  /// @dev Modifier to allow actions only when the contract IS NOT paused&#13;
  modifier whenNotPaused() {&#13;
    require(!paused);&#13;
    _;&#13;
  }&#13;
&#13;
  /// @dev Modifier to allow actions only when the contract IS paused&#13;
  modifier whenPaused {&#13;
      require(paused);&#13;
      _;&#13;
  }&#13;
&#13;
  /// @dev Called by manager to pause the contract. Used only when&#13;
  ///  a bug or exploit is detected and we need to limit damage.&#13;
  function pause() external onlyManager whenNotPaused {&#13;
    paused = true;&#13;
  }&#13;
&#13;
  /// @dev Unpauses the smart contract. Can only be called by the manager,&#13;
  /// since one reason we may pause the contract is when manager accounts are compromised.&#13;
  /// @notice This is public rather than external so it can be called by derived contracts.&#13;
  function unpause() public onlyManager {&#13;
    // can't unpause if contract was upgraded&#13;
    paused = false;&#13;
  }&#13;
&#13;
}&#13;
&#13;
contract FootballerBase is FootballerAccessControl {&#13;
  using SafeMath for uint256;&#13;
  /*** events ***/&#13;
  event Create(address owner, uint footballerId);&#13;
  event Transfer(address _from, address _to, uint256 tokenId);&#13;
&#13;
  uint private randNonce = 0;&#13;
&#13;
  //球员/球星 属性&#13;
  struct footballer {&#13;
    uint price; //球员-价格 ， 球星-一口价 单位wei&#13;
    //球员的战斗属性&#13;
    uint defend; //防御&#13;
    uint attack; //进攻&#13;
    uint quality; //素质&#13;
  }&#13;
&#13;
  //存球星和球员&#13;
  footballer[] public footballers;&#13;
  //将球员的id和球员的拥有者对应起来&#13;
  mapping (uint256 =&gt; address) public footballerToOwner;&#13;
&#13;
  //记录拥有者有多少球员，在balanceOf（）内部使用来解决所有权计数&#13;
  mapping (address =&gt; uint256) public ownershipTokenCount;&#13;
&#13;
  //从footballID 到 已批准调用transferFrom（）的地址的映射&#13;
  //每个球员只能有一个批准的地址。零值表示没有批准&#13;
  mapping (uint256 =&gt; address) public footballerToApproved;&#13;
&#13;
  // 将特定球员的所有权 赋给 某个地址&#13;
  function _transfer(address _from, address _to, uint256 _tokenId) internal {&#13;
    footballerToApproved[_tokenId] = address(0);&#13;
    ownershipTokenCount[_to] = ownershipTokenCount[_to].add(1);&#13;
    footballerToOwner[_tokenId] = _to;&#13;
    ownershipTokenCount[_from] = ownershipTokenCount[_from].sub(1);&#13;
    emit Transfer(_from, _to, _tokenId);&#13;
  }&#13;
&#13;
  //管理员用于投放球星,和createStar函数一起使用，才能将球星完整信息保存起来&#13;
  function _createFootballerStar(uint _price,uint _defend,uint _attack, uint _quality) internal onlyManager returns(uint) {&#13;
      footballer memory _player = footballer({&#13;
        price:_price,&#13;
        defend:_defend,&#13;
        attack:_attack,&#13;
        quality:_quality&#13;
      });&#13;
      uint newFootballerId = footballers.push(_player) - 1;&#13;
      footballerToOwner[newFootballerId] = managerAddress;&#13;
      ownershipTokenCount[managerAddress] = ownershipTokenCount[managerAddress].add(1);&#13;
      //记录这个球星可以进行交易&#13;
      footballerToApproved[newFootballerId] = managerAddress;&#13;
      require(newFootballerId == uint256(uint32(newFootballerId)));&#13;
      emit Create(managerAddress, newFootballerId);&#13;
      return newFootballerId;&#13;
    }&#13;
&#13;
&#13;
    //用于当用户买卡包时，随机生成球员&#13;
    function createFootballer () internal returns (uint) {&#13;
        footballer memory _player = footballer({&#13;
          price: 0,&#13;
          defend: _randMod(20,80),&#13;
          attack: _randMod(20,80),&#13;
          quality: _randMod(20,80)&#13;
        });&#13;
        uint newFootballerId = footballers.push(_player) - 1;&#13;
      //  require(newFootballerId == uint256(uint32(newFootballerId)));&#13;
        footballerToOwner[newFootballerId] = msg.sender;&#13;
        ownershipTokenCount[msg.sender] =ownershipTokenCount[msg.sender].add(1);&#13;
        emit Create(msg.sender, newFootballerId);&#13;
        return newFootballerId;&#13;
    }&#13;
&#13;
  // 生成一个从 _min 到 _max 范围内的随机数（不包括 _max）&#13;
  function _randMod(uint _min, uint _max) private returns(uint) {&#13;
      randNonce++;&#13;
      uint modulus = _max - _min;&#13;
      return uint(keccak256(now, msg.sender, randNonce)) % modulus + _min;&#13;
  }&#13;
&#13;
}&#13;
&#13;
contract FootballerOwnership is FootballerBase, ERC721 {&#13;
  /// @notice Name and symbol of the non fungible token, as defined in ERC721.&#13;
  string public constant name = "CyptoWorldCup";&#13;
  string public constant symbol = "CWC";&#13;
&#13;
&#13;
  function implementsERC721() public pure returns (bool) {&#13;
    return true;&#13;
  }&#13;
&#13;
  //判断一个给定的地址是不是现在某个球员的拥有者&#13;
  function _owns(address _claimant, uint256 _tokenId) internal view returns (bool) {&#13;
    return footballerToOwner[_tokenId] == _claimant;&#13;
  }&#13;
&#13;
  //判断一个给定的地址现在对于某个球员 是不是有 transferApproval&#13;
  function _approvedFor(address _claimant, uint256 _tokenId) internal view returns (bool) {&#13;
    return footballerToApproved[_tokenId] == _claimant;&#13;
  }&#13;
&#13;
  //给某地址的用户 对 球员有transfer的权利&#13;
  function _approve(uint256 _tokenId, address _approved) internal {&#13;
      footballerToApproved[_tokenId] = _approved;&#13;
  }&#13;
&#13;
  //返回 owner 拥有的球员数&#13;
  function balanceOf(address _owner) public view returns (uint256 count) {&#13;
    return ownershipTokenCount[_owner];&#13;
  }&#13;
&#13;
  //转移 球员 给 另一个地址&#13;
  function transfer(address _to, uint256 _tokenId) public whenNotPaused {&#13;
    require(_to != address(0));&#13;
    require(_to != address(this));&#13;
    //只能send自己的球员&#13;
    require(_owns(msg.sender, _tokenId));&#13;
    //重新分配所有权，清除待批准 approvals ，发出转移事件&#13;
    _transfer(msg.sender, _to, _tokenId);&#13;
  }&#13;
&#13;
  //授予另一个地址通过transferFrom（）转移特定球员的权利。&#13;
  function approve(address _to, uint256 _tokenId) external whenNotPaused {&#13;
    //只有球员的拥有者才有资格决定要把这个权利给谁&#13;
    require(_owns(msg.sender, _tokenId));&#13;
    _approve(_tokenId, _to);&#13;
    emit Approval(msg.sender, _to, _tokenId);&#13;
  }&#13;
&#13;
  //转让由另一个地址所拥有的球员，该地址之前已经获得所有者的转让批准&#13;
  function transferFrom(address _from, address _to, uint256 _tokenId) external whenNotPaused {&#13;
    require(_to != address(0));&#13;
    //不允许转让本合同以防止意外滥用。&#13;
    // 合约不应该拥有任何球员（除非 在创建球星之后并且在拍卖之前 非常短）。&#13;
    require(_to != address(this));&#13;
    require(_approvedFor(msg.sender, _tokenId));&#13;
    require(_owns(_from, _tokenId));&#13;
    //该函数定义在FootballerBase&#13;
    _transfer(_from, _to, _tokenId);&#13;
  }&#13;
&#13;
  //返回现在一共有多少（球员+球星）&#13;
  function totalSupply() public view returns (uint) {&#13;
    return footballers.length;&#13;
  }&#13;
&#13;
  //返回该特定球员的拥有者的地址&#13;
  function ownerOf(uint256 _tokenId) external view returns (address owner) {&#13;
    owner = footballerToOwner[_tokenId];&#13;
    require(owner != address(0));&#13;
  }&#13;
&#13;
  //返回该地址的用户拥有的球员的id&#13;
  function tokensOfOwner(address _owner) external view returns(uint256[] ownerTokens) {&#13;
    uint256 tokenCount = balanceOf(_owner);&#13;
    if(tokenCount == 0) {&#13;
      return new uint256[](0);&#13;
    } else {&#13;
      uint256[] memory result = new uint256[](tokenCount);&#13;
      uint256 totalpalyers = totalSupply();&#13;
      uint256 resultIndex = 0;&#13;
      uint256 footballerId;&#13;
      for (footballerId = 0; footballerId &lt; totalpalyers; footballerId++) {&#13;
        if(footballerToOwner[footballerId] == _owner) {&#13;
          result[resultIndex] = footballerId;&#13;
          resultIndex++;&#13;
        }&#13;
      }&#13;
      return result;&#13;
    }&#13;
  }&#13;
}&#13;
&#13;
contract FootballerAction is FootballerOwnership {&#13;
  //创建球星&#13;
  function createFootballerStar(uint _price,uint _defend,uint _attack, uint _quality) public returns(uint) {&#13;
      return _createFootballerStar(_price,_defend,_attack,_quality);&#13;
  }&#13;
&#13;
  //抽卡包得球星&#13;
  function CardFootballers() public payable returns (uint) {&#13;
      uint price = 4000000000000 wei; //0.04 eth&#13;
      require(msg.value &gt;= price);&#13;
      uint ballerCount = 14;&#13;
      uint newFootballerId = 0;&#13;
      for (uint i = 0; i &lt; ballerCount; i++) {&#13;
         newFootballerId = createFootballer();&#13;
      }&#13;
      managerAddress.transfer(msg.value);&#13;
      return price;&#13;
  }&#13;
&#13;
  function buyStar(uint footballerId,uint price) public payable  {&#13;
    require(msg.value &gt;= price);&#13;
    //将球星的拥有权 交给 购买的用户&#13;
    address holder = footballerToApproved[footballerId];&#13;
    require(holder != address(0));&#13;
    _transfer(holder,msg.sender,footballerId);&#13;
    //给卖家转钱&#13;
    holder.transfer(msg.value);&#13;
  }&#13;
&#13;
  //用户出售自己拥有的球员或球星&#13;
  function sell(uint footballerId,uint price) public returns(uint) {&#13;
    require(footballerToOwner[footballerId] == msg.sender);&#13;
    require(footballerToApproved[footballerId] == address(0));&#13;
    footballerToApproved[footballerId] = msg.sender;&#13;
    footballers[footballerId].price = price;&#13;
  }&#13;
&#13;
  //显示球队&#13;
  function getTeamBallers(address actor) public view returns (uint[]) {&#13;
    uint len = footballers.length;&#13;
    uint count=0;&#13;
    for(uint i = 0; i &lt; len; i++) {&#13;
        if(_owns(actor, i)){&#13;
          if(footballerToApproved[i] == address(0)){&#13;
            count++;&#13;
          }&#13;
       }&#13;
    }&#13;
    uint[] memory res = new uint256[](count);&#13;
    uint index = 0;&#13;
    for(i = 0; i &lt; len; i++) {&#13;
      if(_owns(actor, i)){&#13;
          if(footballerToApproved[i] == address(0)){&#13;
            res[index] = i;&#13;
            index++;&#13;
          }&#13;
        }&#13;
    }&#13;
    return res;&#13;
  }&#13;
&#13;
  //显示出售的球星+球员&#13;
  function getSellBallers() public view returns (uint[]) {&#13;
    uint len = footballers.length;&#13;
    uint count = 0;&#13;
    for(uint i = 0; i &lt; len; i++) {&#13;
        if(footballerToApproved[i] != address(0)){&#13;
          count++;&#13;
        }&#13;
    }&#13;
    uint[] memory res = new uint256[](count);&#13;
    uint index = 0;&#13;
    for( i = 0; i &lt; len; i++) {&#13;
        if(footballerToApproved[i] != address(0)){&#13;
          res[index] = i;&#13;
          index++;&#13;
        }&#13;
    }&#13;
    return res;&#13;
  }&#13;
&#13;
  //获得球员+球星的总数量&#13;
  function getAllBaller() public view returns (uint) {&#13;
    uint len = totalSupply();&#13;
    return len;&#13;
  }&#13;
&#13;
}&#13;
&#13;
library SafeMath {&#13;
    /**&#13;
    * @dev Multiplies two numbers, throws on overflow.&#13;
    */&#13;
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
        if (a == 0) {&#13;
            return 0;&#13;
        }&#13;
        uint256 c = a * b;&#13;
        assert(c / a == b);&#13;
        return c;&#13;
    }&#13;
&#13;
&#13;
    /**&#13;
    * @dev Integer division of two numbers, truncating the quotient.&#13;
    */&#13;
    function div(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
        // assert(b &gt; 0); // Solidity automatically throws when dividing by 0&#13;
        uint256 c = a / b;&#13;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold&#13;
        return c;&#13;
    }&#13;
&#13;
    /**&#13;
    * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).&#13;
    */&#13;
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
        assert(b &lt;= a);&#13;
        return a - b;&#13;
    }&#13;
&#13;
    /**&#13;
    * @dev Adds two numbers, throws on overflow.&#13;
    */&#13;
    function add(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
        uint256 c = a + b;&#13;
        assert(c &gt;= a);&#13;
        return c;&#13;
    }&#13;
}