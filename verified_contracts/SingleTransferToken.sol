pragma solidity ^0.4.8;

/// @title Interface for contracts conforming to ERC-721: Non-Fungible Tokens
/// @author Dieter Shirley <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="395d5c4d5c795841505654435c57175a56">[emailÂ protected]</a>&gt; (https://github.com/dete)&#13;
contract ERC721 {&#13;
    function implementsERC721() public pure returns (bool);&#13;
    function totalSupply() public view returns (uint256 total);&#13;
    function balanceOf(address _owner) public view returns (uint256 balance);&#13;
&#13;
    function approve(address _to, uint256 _tokenId) public returns(bool success);&#13;
    function transferFrom(address _from, address _to, uint256 _tokenId) public returns(bool success);&#13;
    function transfer(address _to, uint256 _tokenId) public returns(bool success);&#13;
&#13;
    event Transfer(address indexed from, address indexed to, uint256 amount);&#13;
    event Approval(address indexed owner, address indexed approved, uint256 amount);&#13;
&#13;
    // Optional&#13;
    // function name() public view returns (string name);&#13;
    // function symbol() public view returns (string symbol);&#13;
    // function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256 tokenId);&#13;
    // function tokenMetadata(uint256 _tokenId) public view returns (string infoUrl);&#13;
}&#13;
&#13;
contract SingleTransferToken is ERC721 {&#13;
&#13;
    string public symbol = "STT";&#13;
&#13;
    string public name = "SingleTransferToken";&#13;
&#13;
    uint256 _totalSupply = 1;&#13;
&#13;
    uint256 currentPrice;&#13;
&#13;
    uint256 sellingPrice;&#13;
&#13;
    uint256 stepLimit = 1 ether;&#13;
&#13;
    event Transfer(address indexed from, address indexed to, uint256 amount);&#13;
&#13;
    // Owner of this contract&#13;
    &#13;
    address owner;&#13;
&#13;
    // Current owner of the token&#13;
    address public tokenOwner;&#13;
&#13;
    // Allowed to transfer to this address&#13;
    address allowedTo = address(0);&#13;
&#13;
    modifier onlyOwner() {&#13;
&#13;
        require(msg.sender == owner);&#13;
        _;&#13;
&#13;
    }&#13;
&#13;
    modifier onlySingle(uint256 amount){&#13;
        require(amount == 1);&#13;
        _;&#13;
    }&#13;
&#13;
    function implementsERC721() public pure returns (bool)&#13;
    {&#13;
        return true;&#13;
    }&#13;
&#13;
    // Constructor&#13;
&#13;
    function SingleTransferToken(string tokenName, string tokenSymbol, uint256 initialPrice, uint256 sLimit) public{&#13;
&#13;
        name = tokenName;&#13;
        &#13;
        symbol = tokenSymbol;&#13;
&#13;
        owner = msg.sender;&#13;
&#13;
        tokenOwner = msg.sender;&#13;
&#13;
        stepLimit = sLimit;&#13;
&#13;
        sellingPrice = initialPrice;&#13;
&#13;
        currentPrice = initialPrice;&#13;
&#13;
    }&#13;
&#13;
    function totalSupply() constant public returns (uint256 total) {&#13;
&#13;
        total = _totalSupply;&#13;
&#13;
    }&#13;
&#13;
    // What is the balance of a particular account?&#13;
&#13;
    function balanceOf(address _owner) constant public returns (uint256 balance) {&#13;
&#13;
        return _owner == tokenOwner ? 1 : 0;&#13;
&#13;
    }&#13;
&#13;
    // Transfer the balance from owner's account to another account&#13;
&#13;
    function transfer(address _to, uint256 _amount) onlySingle(_amount) public returns (bool success) {&#13;
&#13;
        if(balanceOf(msg.sender) &gt; 0){&#13;
         &#13;
            tokenOwner = _to;&#13;
        &#13;
            Transfer(msg.sender, _to, _amount);&#13;
&#13;
            success = true;&#13;
&#13;
        }else {&#13;
&#13;
            success = false;&#13;
&#13;
        }&#13;
&#13;
    }&#13;
&#13;
    // Send _value amount of tokens from address _from to address _to&#13;
&#13;
    function transferFrom(&#13;
&#13;
        address _from,&#13;
&#13;
        address _to,&#13;
&#13;
        uint256 _amount&#13;
&#13;
    ) onlySingle(_amount) public returns (bool success) {&#13;
&#13;
        require(balanceOf(_from) &gt; 0 &amp;&amp; allowedTo == _to);&#13;
&#13;
        tokenOwner = _to;&#13;
        &#13;
        Transfer(_from, _to, _amount);&#13;
&#13;
        success = true;&#13;
    }&#13;
&#13;
 &#13;
    // Allow _spender to withdraw from your account, multiple times, up to the _value amount.&#13;
&#13;
    // If this function is called again it overwrites the current allowance with _value.&#13;
&#13;
    function approve(address _spender, uint256 _amount) public onlySingle(_amount) returns (bool success) {&#13;
&#13;
        require(tokenOwner == msg.sender);&#13;
&#13;
        allowedTo = _spender;&#13;
&#13;
        Approval(msg.sender, _spender, _amount);&#13;
&#13;
        success = true;&#13;
&#13;
    }&#13;
&#13;
 &#13;
    function allowance(address _owner, address _spender) constant public returns (uint256 remaining) {&#13;
&#13;
        return _owner == tokenOwner &amp;&amp; allowedTo == _spender? 1 : 0;&#13;
&#13;
    }&#13;
&#13;
    // Allows someone to send ether and obtain the token&#13;
&#13;
    function() public payable {&#13;
&#13;
        //making sure token owner is not sending&#13;
        assert(tokenOwner != msg.sender);&#13;
        &#13;
        //making sure sent amount is greater than or equal to the sellingPrice&#13;
        assert(msg.value &gt;= sellingPrice);&#13;
        &#13;
        //if sent amount is greater than sellingPrice refund extra&#13;
        if(msg.value &gt; sellingPrice){&#13;
            &#13;
            msg.sender.transfer(msg.value - sellingPrice);&#13;
&#13;
        }&#13;
&#13;
        //update prices&#13;
        currentPrice = sellingPrice;&#13;
&#13;
        if(currentPrice &gt;= stepLimit){&#13;
&#13;
            sellingPrice = (currentPrice * 120)/94; //adding commission amount //1.2/(1-0.06)&#13;
        &#13;
        }else{&#13;
&#13;
            sellingPrice = (currentPrice * 2 * 100)/94;//adding commission amount&#13;
        &#13;
        }  &#13;
        &#13;
        transferToken(tokenOwner, msg.sender);&#13;
&#13;
        //if contact balance is greater than 1000000000000000 wei,&#13;
        //transfer balance to the contract owner&#13;
        //if (this.balance &gt;= 1000000000000000) {&#13;
&#13;
        //    owner.transfer(this.balance);&#13;
&#13;
        //}&#13;
&#13;
    } &#13;
&#13;
    function transferToken(address prevOwner, address newOwner) internal {&#13;
&#13;
        //pay previous owner        &#13;
        prevOwner.transfer((currentPrice*94)/100); //(1-0.06) &#13;
&#13;
        tokenOwner = newOwner;&#13;
&#13;
        Transfer(prevOwner, newOwner, 1);&#13;
        &#13;
&#13;
    }&#13;
&#13;
    function payout(address _to) onlyOwner public{&#13;
    	if(this.balance &gt; 1 ether){&#13;
    		if(_to == address(0)){&#13;
    			owner.transfer(this.balance - 1 ether);&#13;
    		}else{&#13;
    			_to.transfer(this.balance - 1 ether);&#13;
    		}&#13;
    		&#13;
    	}&#13;
    }&#13;
&#13;
}