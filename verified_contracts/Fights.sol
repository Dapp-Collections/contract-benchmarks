pragma solidity ^0.4.24;

// File: node_modules/openzeppelin-solidity/contracts/ownership/Ownable.sol

/**
 * @title Ownable
 * @dev The Ownable contract has an owner address, and provides basic authorization control
 * functions, this simplifies the implementation of "user permissions".
 */
contract Ownable {
  address private _owner;

  event OwnershipTransferred(
    address indexed previousOwner,
    address indexed newOwner
  );

  /**
   * @dev The Ownable constructor sets the original `owner` of the contract to the sender
   * account.
   */
  constructor() internal {
    _owner = msg.sender;
    emit OwnershipTransferred(address(0), _owner);
  }

  /**
   * @return the address of the owner.
   */
  function owner() public view returns(address) {
    return _owner;
  }

  /**
   * @dev Throws if called by any account other than the owner.
   */
  modifier onlyOwner() {
    require(isOwner());
    _;
  }

  /**
   * @return true if `msg.sender` is the owner of the contract.
   */
  function isOwner() public view returns(bool) {
    return msg.sender == _owner;
  }

  /**
   * @dev Allows the current owner to relinquish control of the contract.
   * @notice Renouncing to ownership will leave the contract without an owner.
   * It will not be possible to call the functions with the `onlyOwner`
   * modifier anymore.
   */
  function renounceOwnership() public onlyOwner {
    emit OwnershipTransferred(_owner, address(0));
    _owner = address(0);
  }

  /**
   * @dev Allows the current owner to transfer control of the contract to a newOwner.
   * @param newOwner The address to transfer ownership to.
   */
  function transferOwnership(address newOwner) public onlyOwner {
    _transferOwnership(newOwner);
  }

  /**
   * @dev Transfers control of the contract to a newOwner.
   * @param newOwner The address to transfer ownership to.
   */
  function _transferOwnership(address newOwner) internal {
    require(newOwner != address(0));
    emit OwnershipTransferred(_owner, newOwner);
    _owner = newOwner;
  }
}

// File: node_modules/openzeppelin-solidity/contracts/utils/ReentrancyGuard.sol

/**
 * @title Helps contracts guard against reentrancy attacks.
 * @author Remco Bloemen <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="94e6f1f9f7fbd4a6">[email protected]</a>π.com&gt;, Eenae &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="40212c25382539002d293822393425336e292f">[email protected]</a>&gt;&#13;
 * @dev If you mark a function `nonReentrant`, you should also&#13;
 * mark it `external`.&#13;
 */&#13;
contract ReentrancyGuard {&#13;
&#13;
  /// @dev counter to allow mutex lock with only one SSTORE operation&#13;
  uint256 private _guardCounter;&#13;
&#13;
  constructor() internal {&#13;
    // The counter starts at one to prevent changing it from zero to a non-zero&#13;
    // value, which is a more expensive operation.&#13;
    _guardCounter = 1;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Prevents a contract from calling itself, directly or indirectly.&#13;
   * Calling a `nonReentrant` function from another `nonReentrant`&#13;
   * function is not supported. It is possible to prevent this from happening&#13;
   * by making the `nonReentrant` function external, and make it call a&#13;
   * `private` function that does the actual work.&#13;
   */&#13;
  modifier nonReentrant() {&#13;
    _guardCounter += 1;&#13;
    uint256 localCounter = _guardCounter;&#13;
    _;&#13;
    require(localCounter == _guardCounter);&#13;
  }&#13;
&#13;
}&#13;
&#13;
// File: node_modules/openzeppelin-solidity/contracts/math/SafeMath.sol&#13;
&#13;
/**&#13;
 * @title SafeMath&#13;
 * @dev Math operations with safety checks that revert on error&#13;
 */&#13;
library SafeMath {&#13;
&#13;
  /**&#13;
  * @dev Multiplies two numbers, reverts on overflow.&#13;
  */&#13;
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the&#13;
    // benefit is lost if 'b' is also tested.&#13;
    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522&#13;
    if (a == 0) {&#13;
      return 0;&#13;
    }&#13;
&#13;
    uint256 c = a * b;&#13;
    require(c / a == b);&#13;
&#13;
    return c;&#13;
  }&#13;
&#13;
  /**&#13;
  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.&#13;
  */&#13;
  function div(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
    require(b &gt; 0); // Solidity only automatically asserts when dividing by 0&#13;
    uint256 c = a / b;&#13;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold&#13;
&#13;
    return c;&#13;
  }&#13;
&#13;
  /**&#13;
  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).&#13;
  */&#13;
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
    require(b &lt;= a);&#13;
    uint256 c = a - b;&#13;
&#13;
    return c;&#13;
  }&#13;
&#13;
  /**&#13;
  * @dev Adds two numbers, reverts on overflow.&#13;
  */&#13;
  function add(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
    uint256 c = a + b;&#13;
    require(c &gt;= a);&#13;
&#13;
    return c;&#13;
  }&#13;
&#13;
  /**&#13;
  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),&#13;
  * reverts when dividing by zero.&#13;
  */&#13;
  function mod(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
    require(b != 0);&#13;
    return a % b;&#13;
  }&#13;
}&#13;
&#13;
// File: node_modules/openzeppelin-solidity/contracts/token/ERC20/IERC20.sol&#13;
&#13;
/**&#13;
 * @title ERC20 interface&#13;
 * @dev see https://github.com/ethereum/EIPs/issues/20&#13;
 */&#13;
interface IERC20 {&#13;
  function totalSupply() external view returns (uint256);&#13;
&#13;
  function balanceOf(address who) external view returns (uint256);&#13;
&#13;
  function allowance(address owner, address spender)&#13;
    external view returns (uint256);&#13;
&#13;
  function transfer(address to, uint256 value) external returns (bool);&#13;
&#13;
  function approve(address spender, uint256 value)&#13;
    external returns (bool);&#13;
&#13;
  function transferFrom(address from, address to, uint256 value)&#13;
    external returns (bool);&#13;
&#13;
  event Transfer(&#13;
    address indexed from,&#13;
    address indexed to,&#13;
    uint256 value&#13;
  );&#13;
&#13;
  event Approval(&#13;
    address indexed owner,&#13;
    address indexed spender,&#13;
    uint256 value&#13;
  );&#13;
}&#13;
&#13;
// File: lib/CanReclaimToken.sol&#13;
&#13;
/**&#13;
 * @title Contracts that should be able to recover tokens&#13;
 * @author SylTi&#13;
 * @dev This allow a contract to recover any ERC20 token received in a contract by transferring the balance to the contract owner.&#13;
 * This will prevent any accidental loss of tokens.&#13;
 */&#13;
contract CanReclaimToken is Ownable {&#13;
&#13;
  /**&#13;
   * @dev Reclaim all ERC20 compatible tokens&#13;
   * @param token ERC20 The address of the token contract&#13;
   */&#13;
  function reclaimToken(IERC20 token) external onlyOwner {&#13;
    if (address(token) == address(0)) {&#13;
      owner().transfer(address(this).balance);&#13;
      return;&#13;
    }&#13;
    uint256 balance = token.balanceOf(this);&#13;
    token.transfer(owner(), balance);&#13;
  }&#13;
&#13;
}&#13;
&#13;
// File: openzeppelin-solidity/contracts/access/Roles.sol&#13;
&#13;
/**&#13;
 * @title Roles&#13;
 * @dev Library for managing addresses assigned to a Role.&#13;
 */&#13;
library Roles {&#13;
  struct Role {&#13;
    mapping (address =&gt; bool) bearer;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev give an account access to this role&#13;
   */&#13;
  function add(Role storage role, address account) internal {&#13;
    require(account != address(0));&#13;
    require(!has(role, account));&#13;
&#13;
    role.bearer[account] = true;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev remove an account's access to this role&#13;
   */&#13;
  function remove(Role storage role, address account) internal {&#13;
    require(account != address(0));&#13;
    require(has(role, account));&#13;
&#13;
    role.bearer[account] = false;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev check if an account has this role&#13;
   * @return bool&#13;
   */&#13;
  function has(Role storage role, address account)&#13;
    internal&#13;
    view&#13;
    returns (bool)&#13;
  {&#13;
    require(account != address(0));&#13;
    return role.bearer[account];&#13;
  }&#13;
}&#13;
&#13;
// File: lib/ServiceRole.sol&#13;
&#13;
contract ServiceRole {&#13;
  using Roles for Roles.Role;&#13;
&#13;
  event ServiceAdded(address indexed account);&#13;
  event ServiceRemoved(address indexed account);&#13;
&#13;
  Roles.Role private services;&#13;
&#13;
  constructor() internal {&#13;
    _addService(msg.sender);&#13;
  }&#13;
&#13;
  modifier onlyService() {&#13;
    require(isService(msg.sender));&#13;
    _;&#13;
  }&#13;
&#13;
  function isService(address account) public view returns (bool) {&#13;
    return services.has(account);&#13;
  }&#13;
&#13;
  function renounceService() public {&#13;
    _removeService(msg.sender);&#13;
  }&#13;
&#13;
  function _addService(address account) internal {&#13;
    services.add(account);&#13;
    emit ServiceAdded(account);&#13;
  }&#13;
&#13;
  function _removeService(address account) internal {&#13;
    services.remove(account);&#13;
    emit ServiceRemoved(account);&#13;
  }&#13;
}&#13;
&#13;
// File: contracts/Fights.sol&#13;
&#13;
interface HEROES {&#13;
  function getLevel(uint256 tokenId) external view returns (uint256);&#13;
  function getGenes(uint256 tokenId) external view returns (uint256);&#13;
  function getRace(uint256 tokenId) external view returns (uint256);&#13;
  function lock(uint256 tokenId, uint256 lockedTo, bool onlyFreeze) external returns (bool);&#13;
  function unlock(uint256 tokenId) external returns (bool);&#13;
  function ownerOf(uint256 tokenId) external view returns (address);&#13;
  function addWin(uint256 tokenId, uint winsCount, uint levelUp) external returns (bool);&#13;
  function addLoss(uint256 tokenId, uint256 lossesCount, uint levelDown) external returns (bool);&#13;
}&#13;
&#13;
//Crypto Hero Rocket coin&#13;
interface CHR {&#13;
  //  function mint(address _to, uint256 _amount) external returns (bool);&#13;
  function burn(address _from, uint256 _amount) external returns (bool);&#13;
}&#13;
&#13;
&#13;
contract Fights is Ownable, ServiceRole, ReentrancyGuard, CanReclaimToken {&#13;
  using SafeMath for uint256;&#13;
&#13;
  event SetFightInterval(uint startsFrom, uint pastFightsCount, uint fightsInterval, uint fightPeriod, uint applicationPeriod, uint betsPeriod);&#13;
  event EnterArena(uint tokenId, uint fightId, uint startsAt, uint level, uint enemyRace);&#13;
  event ChangeEnemy(uint tokenId, uint fightId, uint enemyRace);&#13;
  event LeaveArena(uint tokenId, uint fightId, Result result, uint level);&#13;
  event StartFight(uint fightId, uint startAt);&#13;
  event RemoveFight(uint fightId);&#13;
  event FightResult(uint fightId, uint[] races, uint[] values);&#13;
  event FinishFight(uint fightId, uint startedAt, uint finishedAt, uint startCheckedAt, uint finishCheckedAt);&#13;
&#13;
  HEROES public heroes;&#13;
  CHR public coin;&#13;
&#13;
  enum Result {QUAIL, WIN, LOSS, DRAW}&#13;
&#13;
  struct Fighter {&#13;
    uint index;&#13;
    bool exists;&#13;
    uint race;&#13;
    uint level;&#13;
    uint enemyRace;&#13;
    bool finished;&#13;
  }&#13;
&#13;
  struct Race {&#13;
    uint index;&#13;
    bool exists;&#13;
    uint count; //число участников данной рассы&#13;
    uint enemyCount; //число игроков выбравших эту расу соперником&#13;
    uint levelSum; //сумма всех уникальных значений уровней&#13;
    //level =&gt; count&#13;
    mapping(uint =&gt; uint) levelCount; // количество участников по уровням&#13;
    //результат битвы в универсальных единицах, может быть отрицательным (32бит)&#13;
    //измеряется в % изменении курса валюты по отношению к доллару на начало и конец периода&#13;
    //пример курс BTC на 12:00 - 6450.33, на 17:00 - 6387.22, изменение = (6387.22 - 6450.33) / 6450.33 = -0,009784 = -0.978%&#13;
    //учитываем 3 знака после запятой и переводим в целое число умножи на 1000 = -978&#13;
    int32 result;&#13;
  }&#13;
&#13;
  struct Fight {&#13;
    uint startedAt;&#13;
    uint finishedAt;&#13;
    uint startCheckedAt;&#13;
    uint finishCheckedAt;&#13;
    //index участника =&gt; tokenId&#13;
    mapping(uint =&gt; uint) arena;&#13;
    //tokenId =&gt; структура Бойца&#13;
    mapping(uint =&gt; Fighter) fighters;&#13;
    uint fightersCount;&#13;
    // raceId =&gt; Race&#13;
    mapping(uint =&gt; Race) races;&#13;
    // race index =&gt; raceId&#13;
    mapping(uint =&gt; uint) raceList;&#13;
    uint raceCount;&#13;
  }&#13;
&#13;
&#13;
  //массив произошедших битв, в него помещаются только id состоявшихся битв&#13;
  uint[] public fightsList;&#13;
  //tokenId =&gt; fightId помним ид последней битвы персонажа, чтобы он мог выйти с использованием монетки&#13;
  mapping(uint =&gt; uint[]) public characterFights;&#13;
&#13;
  //id битвы, жестко привязан к интервалам времени&#13;
  //т.е. если интервал = 1 час, то через 10 часов даже если не было ни одной битвы, id = 10&#13;
  //fightId =&gt; Fight&#13;
  mapping(uint =&gt; Fight) fights;&#13;
&#13;
  //структура описывающая интервалы битв&#13;
  struct FightInterval {&#13;
    uint fightsInterval;&#13;
    uint startsFrom;&#13;
    uint fightsCount; //число уже завершенных битв до этого интервала&#13;
    uint betsPeriod;&#13;
    uint applicationPeriod;&#13;
    uint fightPeriod;&#13;
  }&#13;
&#13;
  //массив хранит историю изменений настроек битв&#13;
  //чтобы можно было иметь доступ к прошлым битвам, в случае если интервалы изменится&#13;
  FightInterval[] public intervalHistory;&#13;
&#13;
  uint public constant FightEpoch = 1542240000; //Thursday, 15 November 2018 г., 0:00:00&#13;
  uint public minBetsLevel = 5;&#13;
  bool public allowEnterDuringBets = true;&#13;
&#13;
  modifier onlyOwnerOf(uint256 _tokenId) {&#13;
    require(heroes.ownerOf(_tokenId) == msg.sender);&#13;
    _;&#13;
  }&#13;
&#13;
  constructor(HEROES _heroes, CHR _coin) public {&#13;
    require(address(_heroes) != address(0));&#13;
    require(address(_coin) != address(0));&#13;
    heroes = _heroes;&#13;
    coin = _coin;&#13;
&#13;
    //  uint public fightsInterval = 12 * 60 * 60; //12 hours, интервал с которым проводятся бои&#13;
    //  uint public betsPeriod = 2 * 60 * 60; //период в течении которого доступны ставки 2 hours&#13;
    //  uint public applicationPeriod = 11 * 60 * 60; //11 hours, период в течении которого можно подать заявку на участие в бою до начала боя&#13;
    //  uint public fightPeriod = 5 * 60 * 60;//длительность боя, 5 часов&#13;
&#13;
    intervalHistory.push(FightInterval({&#13;
      fightPeriod: 5 * 60 * 60, //длительность боя, 5 часов,&#13;
      startsFrom : FightEpoch,&#13;
      fightsCount : 0,&#13;
      fightsInterval : 12 * 60 * 60, //12 hours, интервал с которым проводятся бои,&#13;
      betsPeriod : 2 * 60 * 60, //период в течении которого доступны ставки 2 hours,&#13;
      applicationPeriod : 11 * 60 * 60 //11 hours, период в течении которого можно подать заявку на участие в бою до начала боя&#13;
      }));&#13;
  }&#13;
&#13;
  /// @notice The fallback function payable&#13;
  function() external payable {&#13;
    require(msg.value &gt; 0);&#13;
    address(heroes).transfer(msg.value);&#13;
  }&#13;
&#13;
  function addService(address account) public onlyOwner {&#13;
    _addService(account);&#13;
  }&#13;
&#13;
  function removeService(address account) public onlyOwner {&#13;
    _removeService(account);&#13;
  }&#13;
&#13;
&#13;
  //устанавливает новые значения интервалов битв&#13;
  function setFightInterval(uint _fightsInterval, uint _applicationPeriod, uint _betsPeriod, uint _fightPeriod) external onlyOwner {&#13;
    FightInterval memory i = _getFightIntervalAt(now);&#13;
    //todo проверить )&#13;
    // количество интервалов прошедших с момента последней записи в истории&#13;
    uint intervalsCount = (now - i.startsFrom) / i.fightsInterval + 1;&#13;
    FightInterval memory ni = FightInterval({&#13;
      fightsInterval : _fightsInterval,&#13;
      startsFrom : i.startsFrom + i.fightsInterval * intervalsCount,&#13;
      fightsCount : intervalsCount + i.fightsCount,&#13;
      applicationPeriod : _applicationPeriod,&#13;
      betsPeriod : _betsPeriod,&#13;
      fightPeriod : _fightPeriod&#13;
      });&#13;
    intervalHistory.push(ni);&#13;
    emit SetFightInterval(ni.startsFrom, ni.fightsCount, _fightsInterval, _fightPeriod, _applicationPeriod, _betsPeriod);&#13;
  }&#13;
&#13;
  //устанавливает новые значения дополнительных параметров&#13;
  function setParameters(uint _minBetsLevel, bool _allowEnterDuringBets) external onlyOwner {&#13;
    minBetsLevel = _minBetsLevel;&#13;
    allowEnterDuringBets = _allowEnterDuringBets;&#13;
  }&#13;
&#13;
  function enterArena(uint _tokenId, uint _enemyRace) public onlyOwnerOf(_tokenId) {&#13;
    //only if finished last fight&#13;
    require(isAllowed(_tokenId));&#13;
    uint intervalId = _getFightIntervalIdAt(now);&#13;
    FightInterval memory i = intervalHistory[intervalId];&#13;
    uint nextStartsAt = _getFightStartsAt(intervalId, 1);&#13;
    //вступить в арену можно только в период приема заявок&#13;
    require(now &gt;= nextStartsAt - i.applicationPeriod);&#13;
    //вступить в арену можно только до начала битвы или до начала ставок&#13;
    require(now &lt; nextStartsAt - (allowEnterDuringBets ? 0 : i.betsPeriod));&#13;
&#13;
    uint nextFightId = getFightId(intervalId, 1);&#13;
    Fight storage f = fights[nextFightId];&#13;
    //на всякий случай, если мы вдруг решим закрыть определенную битву в будущем&#13;
//    require(f.finishedAt != 0);&#13;
&#13;
    //участник еще не на арене&#13;
    require(!f.fighters[_tokenId].exists);&#13;
&#13;
    uint level = heroes.getLevel(_tokenId);&#13;
    uint race = heroes.getRace(_tokenId);&#13;
    require(race != _enemyRace);&#13;
&#13;
    //начать fight если он еще не был начат&#13;
    if (f.startedAt == 0) {&#13;
      f.startedAt = nextStartsAt;&#13;
      fightsList.push(nextFightId);&#13;
      emit StartFight(nextFightId, nextStartsAt);&#13;
      //todo что еще?&#13;
    }&#13;
&#13;
    //добавляем на арену&#13;
    f.fighters[_tokenId] = Fighter({&#13;
      exists : true,&#13;
      finished : false,&#13;
      index : f.fightersCount,&#13;
      race : race,&#13;
      enemyRace : _enemyRace,&#13;
      level: level&#13;
      });&#13;
    f.arena[f.fightersCount++] = _tokenId;&#13;
    //запоминаем в списке битв конкретного токена&#13;
    characterFights[_tokenId].push(nextFightId);&#13;
&#13;
    Race storage r = f.races[race];&#13;
    if (!r.exists) {&#13;
      r.exists = true;&#13;
      r.index = f.raceCount;&#13;
      f.raceList[f.raceCount++] = race;&#13;
    }&#13;
    r.count++;&#13;
    //для будущего расчета выигрыша&#13;
    //учет только игроков 5 и выше уровня&#13;
    if (level &gt;= minBetsLevel) {&#13;
      //если еще не было участников с таким уровнем, считаем что это новый уникальный&#13;
      if (r.levelCount[level] == 0) {&#13;
        //суммируем уникальное значения уровня&#13;
        r.levelSum = r.levelSum.add(level);&#13;
      }&#13;
      //счетчик количества игроков с данным уровнем&#13;
      r.levelCount[level]++;&#13;
    }&#13;
    //учтем вражескую расу, просто создаем ее и добавляем в список, без изменения количеств,&#13;
    //чтобы потом с бэкенда было проще пройтись по списку рас&#13;
    Race storage er = f.races[_enemyRace];&#13;
    if (!er.exists) {&#13;
      er.exists = true;&#13;
      er.index = f.raceCount;&#13;
      f.raceList[f.raceCount++] = _enemyRace;&#13;
    }&#13;
    er.enemyCount++;&#13;
&#13;
    //устанавливаем блокировку до конца битвы&#13;
    require(heroes.lock(_tokenId, nextStartsAt + i.fightPeriod, false));&#13;
    emit EnterArena(_tokenId, nextFightId, nextStartsAt, level, _enemyRace);&#13;
&#13;
  }&#13;
&#13;
&#13;
  function changeEnemy(uint _tokenId, uint _enemyRace) public onlyOwnerOf(_tokenId) {&#13;
    uint fightId = characterLastFightId(_tokenId);&#13;
&#13;
    //последняя битва должны существовать&#13;
    require(fightId != 0);&#13;
    Fight storage f = fights[fightId];&#13;
    Fighter storage fr = f.fighters[_tokenId];&#13;
    //участник уже на арене&#13;
    //todo излишне, такого быть не должно, проанализировать&#13;
    require(fr.exists);&#13;
    //только если еще не завершена битва для  данного бойца&#13;
    require(!fr.finished);&#13;
&#13;
    //поменять на новую только&#13;
    require(fr.enemyRace != _enemyRace);&#13;
&#13;
    FightInterval memory i = _getFightIntervalAt(f.startedAt);&#13;
&#13;
    //требуем либо текущее время до начала ставок&#13;
    //todo излишне, достаточно now &lt; f.startedAt - params.betsPeriod&#13;
    //т.к. в теории игрок не может находится до начала периода заявок&#13;
    require(now &gt;= f.startedAt - i.applicationPeriod &amp;&amp; now &lt; f.startedAt - i.betsPeriod &amp;&amp; f.finishedAt != 0);&#13;
&#13;
    fr.enemyRace = _enemyRace;&#13;
&#13;
    //уменьшаем счетчик расс врагов&#13;
    Race storage er_old = f.races[fr.enemyRace];&#13;
    er_old.enemyCount--;&#13;
&#13;
    if (er_old.count == 0 &amp;&amp; er_old.enemyCount == 0) {&#13;
      f.races[f.raceList[--f.raceCount]].index = er_old.index;&#13;
      f.raceList[er_old.index] = f.raceList[f.raceCount];&#13;
      delete f.arena[f.raceCount];&#13;
      delete f.races[fr.enemyRace];&#13;
    }&#13;
&#13;
    //учтем вражескую расу, просто создаем ее и добавляем в список, без изменения количеств,&#13;
    //чтобы потом с бэкенда было проще пройтись по списку рас&#13;
    Race storage er_new = f.races[_enemyRace];&#13;
    if (!er_new.exists) {&#13;
      er_new.index = f.raceCount;&#13;
      f.raceList[f.raceCount++] = _enemyRace;&#13;
    }&#13;
    er_new.enemyCount++;&#13;
    emit ChangeEnemy(_tokenId, fightId, _enemyRace);&#13;
  }&#13;
&#13;
  function reenterArena(uint _tokenId, uint _enemyRace, bool _useCoin) public onlyOwnerOf(_tokenId) {&#13;
    uint fightId = characterLastFightId(_tokenId);&#13;
    //последняя битва должны существовать&#13;
    require(fightId != 0);&#13;
    Fight storage f = fights[fightId];&#13;
    Fighter storage fr = f.fighters[_tokenId];&#13;
    //участник уже на арене&#13;
    //todo излишне, такого быть не должно, проанализировать&#13;
    require(fr.exists);&#13;
    //нельзя перезайти из не начатой битвы&#13;
//    require (f.startedAt != 0);&#13;
&#13;
    //только если еще не завершена битва для  данного бойца&#13;
    require(!fr.finished);&#13;
&#13;
    //требуем либо текущее время после конца битвы, которая завершена&#13;
    require(f.finishedAt != 0 &amp;&amp; now &gt; f.finishedAt);&#13;
&#13;
    Result result = Result.QUAIL;&#13;
&#13;
    //обработка результатов&#13;
    if (f.races[f.fighters[_tokenId].race].result &gt; f.races[f.fighters[_tokenId].enemyRace].result) {&#13;
      result = Result.WIN;&#13;
      //wins +1, level + 1&#13;
      heroes.addWin(_tokenId, 1, 1);&#13;
    } else if (f.races[f.fighters[_tokenId].race].result &lt; f.races[f.fighters[_tokenId].enemyRace].result) {&#13;
      result = Result.LOSS;&#13;
      //засчитываем поражение&#13;
      if (_useCoin) {&#13;
        require(coin.burn(heroes.ownerOf(_tokenId), 1));&#13;
        //losses +1, level the same&#13;
        heroes.addLoss(_tokenId, 1, 0);&#13;
      } else {&#13;
        //losses +1, level - 1&#13;
        heroes.addLoss(_tokenId, 1, 1);&#13;
      }&#13;
    } else {&#13;
      //todo ничья&#13;
//      result = Result.QUAIL;&#13;
    }&#13;
    fr.finished = true;&#13;
&#13;
    emit LeaveArena(_tokenId, fightId, result, fr.level);&#13;
    //вход на арену&#13;
    enterArena(_tokenId, _enemyRace);&#13;
  }&#13;
&#13;
&#13;
  //покинуть арену можно до начала ставок или после окончания, и естественно только последнюю&#13;
  function leaveArena(uint _tokenId, bool _useCoin) public onlyOwnerOf(_tokenId) {&#13;
    uint fightId = characterLastFightId(_tokenId);&#13;
&#13;
    //последняя битва должны существовать&#13;
    require(fightId != 0);&#13;
    Fight storage f = fights[fightId];&#13;
    Fighter storage fr = f.fighters[_tokenId];&#13;
    //участник уже на арене&#13;
    //todo излишне, такого быть не должно, проанализировать&#13;
    require(fr.exists);&#13;
&#13;
    //нельзя покинуть не начатую битву&#13;
    //    require (f.startedAt != 0);&#13;
&#13;
    //только если еще не завершена битва для  данного бойца&#13;
    require(!fr.finished);&#13;
&#13;
    FightInterval memory i = _getFightIntervalAt(f.startedAt);&#13;
&#13;
    //требуем либо текущее время до начала ставок, либо уже после конца битвы, которая завершена&#13;
    require(now &lt; f.startedAt - i.betsPeriod || (f.finishedAt != 0 &amp;&amp; now &gt; f.finishedAt));&#13;
    Result result = Result.QUAIL;&#13;
    //выход до начала битвы&#13;
    if (f.finishedAt == 0) {&#13;
&#13;
      Race storage r = f.races[fr.race];&#13;
      //учет только игроков 5 и выше уровня&#13;
      if (fr.level &gt;= minBetsLevel) {&#13;
        //уменьшаем счетчик игроков этого уровня&#13;
        r.levelCount[fr.level]--;&#13;
        //если это был последний игрок&#13;
        if (r.levelCount[fr.level] == 0) {&#13;
          r.levelSum = r.levelSum.sub(fr.level);&#13;
        }&#13;
      }&#13;
      r.count--;&#13;
&#13;
      Race storage er = f.races[fr.enemyRace];&#13;
      er.enemyCount--;&#13;
&#13;
      //если больше не осталось игроков в этих расах удаляем их&#13;
      if (r.count == 0 &amp;&amp; r.enemyCount == 0) {&#13;
        f.races[f.raceList[--f.raceCount]].index = r.index;&#13;
        f.raceList[r.index] = f.raceList[f.raceCount];&#13;
        delete f.arena[f.raceCount];&#13;
        delete f.races[fr.race];&#13;
      }&#13;
      if (er.count == 0 &amp;&amp; er.enemyCount == 0) {&#13;
          f.races[f.raceList[--f.raceCount]].index = er.index;&#13;
        f.raceList[er.index] = f.raceList[f.raceCount];&#13;
        delete f.arena[f.raceCount];&#13;
        delete f.races[fr.enemyRace];&#13;
      }&#13;
&#13;
      // удалить с арены&#13;
      f.fighters[f.arena[--f.fightersCount]].index = fr.index;&#13;
      f.arena[fr.index] = f.arena[f.fightersCount];&#13;
      delete f.arena[f.fightersCount];&#13;
      delete f.fighters[_tokenId];&#13;
      //удаляем из списка битв&#13;
      delete characterFights[_tokenId][characterFights[_tokenId].length--];&#13;
&#13;
      //todo если участник последний - то удалить битву&#13;
      if (f.fightersCount == 0) {&#13;
        delete fights[fightId];&#13;
        emit RemoveFight(fightId);&#13;
      }&#13;
    } else {&#13;
&#13;
      //выход после окончания битвы&#13;
      if (f.races[f.fighters[_tokenId].race].result &gt; f.races[f.fighters[_tokenId].enemyRace].result) {&#13;
        result = Result.WIN;&#13;
        heroes.addWin(_tokenId, 1, 1);&#13;
      } else if (f.races[f.fighters[_tokenId].race].result &lt; f.races[f.fighters[_tokenId].enemyRace].result) {&#13;
        result = Result.LOSS;&#13;
        //засчитываем поражение&#13;
        if (_useCoin) {&#13;
          //сжигаем 1 монетку&#13;
          require(coin.burn(heroes.ownerOf(_tokenId), 1));&#13;
          //при использовании монетки не уменьшаем уровень, при этом счетчик поражений +1&#13;
          heroes.addLoss(_tokenId, 1, 0);&#13;
        } else {&#13;
          heroes.addLoss(_tokenId, 1, 1);&#13;
        }&#13;
      } else {&#13;
        //todo ничья&#13;
        result = Result.DRAW;&#13;
      }&#13;
&#13;
      fr.finished = true;&#13;
    }&#13;
    //разблокируем игрока&#13;
    require(heroes.unlock(_tokenId));&#13;
    emit LeaveArena(_tokenId, fightId, result, fr.level);&#13;
&#13;
  }&#13;
&#13;
  function fightsCount() public view returns (uint) {&#13;
    return fightsList.length;&#13;
  }&#13;
&#13;
  //возвращает id битвы актуальный в данный момент&#13;
  function getCurrentFightId() public view returns (uint) {&#13;
    return getFightId(_getFightIntervalIdAt(now), 0);&#13;
  }&#13;
&#13;
  function getNextFightId() public view returns (uint) {&#13;
    return getFightId(_getFightIntervalIdAt(now), 1);&#13;
  }&#13;
&#13;
  function getFightId(uint intervalId, uint nextShift) internal view returns (uint) {&#13;
    FightInterval memory i = intervalHistory[intervalId];&#13;
    return (now - i.startsFrom) / i.fightsInterval + i.fightsCount + nextShift;&#13;
  }&#13;
&#13;
  function characterFightsCount(uint _tokenId) public view returns (uint) {&#13;
    return characterFights[_tokenId].length;&#13;
  }&#13;
&#13;
  function characterLastFightId(uint _tokenId) public view returns (uint) {&#13;
    //    require(characterFights[_tokenId].length &gt; 0);&#13;
    return characterFights[_tokenId].length &gt; 0 ? characterFights[_tokenId][characterFights[_tokenId].length - 1] : 0;&#13;
  }&#13;
&#13;
  function characterLastFight(uint _tokenId) public view returns (&#13;
    uint index,&#13;
    uint race,&#13;
    uint level,&#13;
    uint enemyRace,&#13;
    bool finished&#13;
  ) {&#13;
    return getFightFighter(characterLastFightId(_tokenId), _tokenId);&#13;
  }&#13;
&#13;
  function getFightFighter(uint _fightId, uint _tokenId) public view returns (&#13;
    uint index,&#13;
    uint race,&#13;
    uint level,&#13;
    uint enemyRace,&#13;
    bool finished&#13;
  ) {&#13;
    Fighter memory fr = fights[_fightId].fighters[_tokenId];&#13;
    return (fr.index, fr.race, fr.level, fr.enemyRace, fr.finished);&#13;
  }&#13;
&#13;
  function getFightArenaFighter(uint _fightId, uint _fighterIndex) public view returns (&#13;
    uint tokenId,&#13;
    uint race,&#13;
    uint level,&#13;
    uint enemyRace,&#13;
    bool finished&#13;
  ) {&#13;
    uint _tokenId = fights[_fightId].arena[_fighterIndex];&#13;
    Fighter memory fr = fights[_fightId].fighters[_tokenId];&#13;
    return (_tokenId, fr.race, fr.level, fr.enemyRace, fr.finished);&#13;
  }&#13;
&#13;
  function getFightRaces(uint _fightId) public view returns(uint[]) {&#13;
    Fight storage f = fights[_fightId];&#13;
    if (f.startedAt == 0) return;&#13;
    uint[] memory r = new uint[](f.raceCount);&#13;
    for(uint i; i &lt; f.raceCount; i++) {&#13;
      r[i] = f.raceList[i];&#13;
    }&#13;
    return r;&#13;
  }&#13;
&#13;
  function getFightRace(uint _fightId, uint _race) external view returns (&#13;
    uint index,&#13;
    uint count, //число участников данной рассы&#13;
    uint enemyCount, //число игроков выбравших эту расу соперником&#13;
    int32 result&#13;
  ){&#13;
    Race memory r = fights[_fightId].races[_race];&#13;
    return (r.index, r.count, r.enemyCount, r.result);&#13;
  }&#13;
&#13;
  function getFightRaceLevelStat(uint _fightId, uint _race, uint _level) external view returns (&#13;
    uint levelCount, //число участников данной рассы данного уровня&#13;
    uint levelSum //сумма уникальных значений всех уровней данной рассы&#13;
  ){&#13;
    Race storage r = fights[_fightId].races[_race];&#13;
    return (r.levelCount[_level], r.levelSum);&#13;
  }&#13;
&#13;
  function getFightResult(uint _fightId, uint _tokenId) public view returns (Result) {&#13;
//    uint fightId = getCharacterLastFightId(_tokenId);&#13;
    //    require(fightId != 0);&#13;
    Fight storage f = fights[_fightId];&#13;
    Fighter storage fr = f.fighters[_tokenId];&#13;
    //участник существует&#13;
    if (!fr.exists) {&#13;
      return Result.QUAIL;&#13;
    }&#13;
//    return (int(f.races[fr.race].result) - int(f.races[fr.enemyRace].result));&#13;
    return f.races[fr.race].result &gt; f.races[fr.enemyRace].result ? Result.WIN : f.races[fr.race].result &lt; f.races[fr.enemyRace].result ? Result.LOSS : Result.DRAW;&#13;
  }&#13;
&#13;
&#13;
  function isAllowed(uint tokenId) public view returns (bool) {&#13;
    uint fightId = characterLastFightId(tokenId);&#13;
    return fightId == 0 ? true : fights[fightId].fighters[tokenId].finished;&#13;
  }&#13;
&#13;
  function getCurrentFight() public view returns (&#13;
    uint256 fightId,&#13;
    uint256 startedAt,&#13;
    uint256 finishedAt,&#13;
    uint256 startCheckedAt,&#13;
    uint256 finishCheckedAt,&#13;
    uint256 fightersCount,&#13;
    uint256 raceCount&#13;
  ) {&#13;
    fightId = getCurrentFightId();&#13;
    (startedAt, finishedAt, startCheckedAt, finishCheckedAt, fightersCount, raceCount) = getFight(fightId);&#13;
  }&#13;
&#13;
  function getNextFight() public view returns (&#13;
    uint256 fightId,&#13;
    uint256 startedAt,&#13;
    uint256 finishedAt,&#13;
    uint256 startCheckedAt,&#13;
    uint256 finishCheckedAt,&#13;
    uint256 fightersCount,&#13;
    uint256 raceCount&#13;
  ) {&#13;
    fightId = getNextFightId();&#13;
    (startedAt, finishedAt, startCheckedAt, finishCheckedAt, fightersCount, raceCount) = getFight(fightId);&#13;
  }&#13;
&#13;
  function getFight(uint _fightId) public view returns (&#13;
    uint256 startedAt,&#13;
    uint256 finishedAt,&#13;
    uint256 startCheckedAt,&#13;
    uint256 finishCheckedAt,&#13;
    uint256 fightersCount,&#13;
    uint256 raceCount&#13;
  ) {&#13;
    Fight memory f = fights[_fightId];&#13;
    return (f.startedAt, f.finishedAt, f.startCheckedAt, f.finishCheckedAt, f.fightersCount, f.raceCount);&#13;
  }&#13;
&#13;
  function getNextFightInterval() external view returns (&#13;
    uint fightId,&#13;
    uint currentTime,&#13;
    uint applicationStartAt,&#13;
    uint betsStartAt,&#13;
    uint fightStartAt,&#13;
    uint fightFinishAt&#13;
  ) {&#13;
    uint intervalId = _getFightIntervalIdAt(now);&#13;
    fightId = getFightId(intervalId, 1);&#13;
    (currentTime, applicationStartAt, betsStartAt, fightStartAt, fightFinishAt) = _getFightInterval(intervalId, 1);&#13;
  }&#13;
&#13;
  function getCurrentFightInterval() external view returns (&#13;
    uint fightId,&#13;
    uint currentTime,&#13;
    uint applicationStartAt,&#13;
    uint betsStartAt,&#13;
    uint fightStartAt,&#13;
    uint fightFinishAt&#13;
  ) {&#13;
    uint intervalId = _getFightIntervalIdAt(now);&#13;
    fightId = getFightId(intervalId, 0);&#13;
    (currentTime, applicationStartAt, betsStartAt, fightStartAt, fightFinishAt) = _getFightInterval(intervalId, 0);&#13;
  }&#13;
&#13;
  function _getFightInterval(uint intervalId, uint nextShift) internal view returns (&#13;
//    uint fightId,&#13;
    uint currentTime,&#13;
    uint applicationStartAt,&#13;
    uint betsStartAt,&#13;
    uint fightStartAt,&#13;
    uint fightFinishAt&#13;
  ) {&#13;
&#13;
    fightStartAt = _getFightStartsAt(intervalId, nextShift);&#13;
&#13;
    FightInterval memory i = intervalHistory[intervalId];&#13;
    currentTime = now;&#13;
    applicationStartAt = fightStartAt - i.applicationPeriod;&#13;
    betsStartAt = fightStartAt - i.betsPeriod;&#13;
    fightFinishAt = fightStartAt + i.fightPeriod;&#13;
  }&#13;
&#13;
  function _getFightStartsAt(uint intervalId, uint nextShift) internal view returns (uint) {&#13;
    FightInterval memory i = intervalHistory[intervalId];&#13;
    uint intervalsCount = (now - i.startsFrom) / i.fightsInterval + nextShift;&#13;
    return i.startsFrom + i.fightsInterval * intervalsCount;&#13;
  }&#13;
&#13;
&#13;
  function getCurrentIntervals() external view returns (&#13;
    uint fightsInterval,&#13;
    uint fightPeriod,&#13;
    uint applicationPeriod,&#13;
    uint betsPeriod&#13;
  ) {&#13;
    FightInterval memory i = _getFightIntervalAt(now);&#13;
    fightsInterval = i.fightsInterval;&#13;
    fightPeriod = i.fightPeriod;&#13;
    applicationPeriod = i.applicationPeriod;&#13;
    betsPeriod = i.betsPeriod;&#13;
  }&#13;
&#13;
&#13;
  function _getFightIntervalAt(uint _time)  internal view returns (FightInterval memory) {&#13;
    return intervalHistory[_getFightIntervalIdAt(_time)];&#13;
  }&#13;
&#13;
&#13;
  function _getFightIntervalIdAt(uint _time)  internal view returns (uint) {&#13;
    require(intervalHistory.length&gt;0);&#13;
    //    if (intervalHistory.length == 0) return 0;&#13;
&#13;
    // Shortcut for the actual value&#13;
    if (_time &gt;= intervalHistory[intervalHistory.length - 1].startsFrom)&#13;
      return intervalHistory.length - 1;&#13;
    if (_time &lt; intervalHistory[0].startsFrom) return 0;&#13;
&#13;
    // Binary search of the value in the array&#13;
    uint min = 0;&#13;
    uint max = intervalHistory.length - 1;&#13;
    while (max &gt; min) {&#13;
      uint mid = (max + min + 1) / 2;&#13;
      if (intervalHistory[mid].startsFrom &lt;= _time) {&#13;
        min = mid;&#13;
      } else {&#13;
        max = mid - 1;&#13;
      }&#13;
    }&#13;
    return min;&#13;
  }&#13;
&#13;
&#13;
  //устанавливает результаты для битвы для всех расс&#13;
  //принимает 2 соответствующих массива id расс и значений результата битвы&#13;
  //значения 32битные, упакованы в uint256&#13;
  // !!! закрытие битвы отдельной функцией, т.к. результатов может быть очень много и не уложится в один вызов !!!&#13;
  function setFightResult(uint fightId, uint count, uint[] packedRaces, uint[] packedResults) public onlyService {&#13;
    require(packedRaces.length == packedResults.length);&#13;
    require(packedRaces.length * 8 &gt;= count);&#13;
&#13;
    Fight storage f = fights[fightId];&#13;
    require(f.startedAt != 0 &amp;&amp; f.finishedAt == 0);&#13;
&#13;
    //    f.finishedAt = now;&#13;
    for (uint i = 0; i &lt; count; i++) {&#13;
//      for (uint n = 0; n &lt; 8 || ; n++) {&#13;
        f.races[_upack(packedRaces[i / 8], i % 8)].result = int32(_upack(packedResults[i / 8], i % 8));&#13;
//      }&#13;
    }&#13;
    emit FightResult(fightId, packedRaces, packedResults);&#13;
&#13;
  }&#13;
&#13;
  //close the fight, save check points time&#13;
  function finishFight(uint fightId, uint startCheckedAt, uint finishCheckedAt) public onlyService {&#13;
    Fight storage f = fights[fightId];&#13;
    require(f.startedAt != 0 &amp;&amp; f.finishedAt == 0);&#13;
    FightInterval memory i = _getFightIntervalAt(f.startedAt);&#13;
    //нельзя закрыть до истечения периода битвы&#13;
    require(now &gt;= f.startedAt + i.fightPeriod);&#13;
    f.finishedAt = now;&#13;
    f.startCheckedAt = startCheckedAt;&#13;
    f.finishCheckedAt = finishCheckedAt;&#13;
    emit FinishFight(fightId, f.startedAt, f.finishedAt, startCheckedAt, finishCheckedAt);&#13;
  }&#13;
&#13;
  //extract n-th 32-bit int from uint&#13;
  function _upack(uint _v, uint _n) internal pure returns (uint) {&#13;
    //    _n = _n &amp; 7; //be sure &lt; 8&#13;
    return (_v &gt;&gt; (32 * _n)) &amp; 0xFFFFFFFF;&#13;
  }&#13;
&#13;
  //merge n-th 32-bit int to uint&#13;
  function _puck(uint _v, uint _n, uint _x) internal pure returns (uint) {&#13;
    //    _n = _n &amp; 7; //be sure &lt; 8&#13;
    //number = number &amp; ~(1 &lt;&lt; n) | (x &lt;&lt; n);&#13;
    return _v &amp; ~(0xFFFFFFFF &lt;&lt; (32 * _n)) | ((_x &amp; 0xFFFFFFFF) &lt;&lt; (32 * _n));&#13;
  }&#13;
}