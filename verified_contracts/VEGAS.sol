pragma solidity ^0.4.21;

// EtherVegas V3 
// Updates: time is now a hard reset and is based on the price you buy with minimum 
// Name feature introduced plus quotes [added to UI soon]
// Poker feature added, pays about ~4/25 of entire collected pot currently 
// can be claimed multiple times (by other users). Last poker winner gets 
// remaining pot when complete jackpot is paid out 

// HOST: ethlasvegas.surge.sh 
// Made by EtherGuy 
// Questions or suggestions? <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="a8cddcc0cddacfddd1e8c5c9c1c486cbc7c5">[emailÂ protected]</a> &#13;
&#13;
contract RNG{&#13;
     uint256 secret = 0;&#13;
     &#13;
    // Thanks to TechnicalRise&#13;
    // Ban contracts&#13;
    modifier NoContract(){&#13;
        uint size;&#13;
        address addr = msg.sender;&#13;
        assembly { size := extcodesize(addr) }&#13;
        require(size == 0);&#13;
        _;&#13;
    }&#13;
    &#13;
    function RNG() public NoContract{&#13;
        secret = uint256(keccak256(block.coinbase));&#13;
    }&#13;
    &#13;
    function _giveRNG(uint256 modulo, uint256 secr) private view returns (uint256, uint256){&#13;
        uint256 seed1 = uint256(block.coinbase);&#13;
        uint256 seed3 = secr; &#13;
        uint256 newsecr = (uint256(keccak256(seed1,seed3)));&#13;
        return (newsecr % modulo, newsecr);&#13;
    }&#13;
    &#13;
&#13;
    function GiveRNG(uint256 max) internal NoContract returns (uint256){&#13;
        uint256 num;&#13;
        uint256 newsecret = secret;&#13;
&#13;
        (num,newsecret) = _giveRNG(max, newsecret);&#13;
        secret=newsecret;&#13;
        return num; &#13;
    }&#13;
    &#13;
&#13;
}&#13;
&#13;
contract Poker is RNG{&#13;
    // warning; number 0 is a non-existing card; means empty;&#13;
&#13;
    uint8[5] public HouseCards;&#13;
    &#13;
    mapping(address =&gt; uint8[2]) public PlayerCards;&#13;
    mapping(address =&gt; uint256) public PlayerRound;&#13;
    &#13;
    uint256 public RoundNumber;&#13;
    &#13;
    uint8[6] public WinningHand; // tracks winning hand. ID 1 defines winning level (9=straight flush, 8=4 of a kind, etc) and other numbers &#13;
    address  public PokerWinner;&#13;
    &#13;
    uint8[2] public WinningCards;&#13;
    // define the other cards which might play in defining the winner. &#13;
&#13;
    function GetCardNumber(uint8 rank, uint8 suit) public pure returns (uint8){&#13;
        if (rank==0){&#13;
            return 0;&#13;
        }&#13;
        &#13;
        return ((rank-1)*4+1)+suit;&#13;
    }&#13;
    &#13;
    function GetPlayerRound(address who) public view returns (uint256){&#13;
        return PlayerRound[who];&#13;
    }&#13;
    &#13;
    &#13;
    &#13;
    function GetCardInfo(uint8 n) public pure returns (uint8 rank, uint8 suit){&#13;
        if (n==0){&#13;
            return (0,0);&#13;
        }&#13;
        suit = (n-1)%4;&#13;
        rank = (n-1)/4+1;&#13;
    }&#13;
    &#13;
   // event pushifo(uint8, uint8, uint8,uint8,uint8);&#13;
    // resets game &#13;
    function DrawHouse() internal{&#13;
        // Draw table cards &#13;
        uint8 i;&#13;
        uint8 rank;&#13;
        uint8 suit;&#13;
        uint8 n;&#13;
        for (i=0; i&lt;5; i++){&#13;
            rank = uint8(GiveRNG(13)+1);&#13;
            suit = uint8(GiveRNG(4));&#13;
            n = GetCardNumber(rank,suit);&#13;
            HouseCards[i]=n;&#13;
        }&#13;
&#13;
        uint8[2] storage target = PlayerCards[address(this)];&#13;
        for (i=0; i&lt;2; i++){&#13;
            rank = uint8(GiveRNG(13)+1);&#13;
            suit = uint8(GiveRNG(4));&#13;
            n = GetCardNumber(rank,suit);&#13;
&#13;
            target[i]=n;&#13;
&#13;
        }&#13;
        &#13;
        WinningHand = RankScore(address(this));&#13;
        WinningCards=[target[0],target[1]];&#13;
        PokerWinner= address(this);&#13;
    }&#13;
    &#13;
    event DrawnCards(address player, uint8 card1, uint8 card2);&#13;
    function DrawAddr() internal {&#13;
        uint8 tcard1;&#13;
        uint8 tcard2;&#13;
        for (uint8 i=0; i&lt;2; i++){&#13;
            uint8 rank = uint8(GiveRNG(13)+1);&#13;
            uint8 suit = uint8(GiveRNG(4));&#13;
            uint8 n = GetCardNumber(rank,suit);&#13;
            &#13;
            if (i==0){&#13;
                tcard1=n;&#13;
            }&#13;
            else{&#13;
                tcard2=n;&#13;
            }&#13;
&#13;
            PlayerCards[msg.sender][i]=n;&#13;
&#13;
        }&#13;
        &#13;
        if (PlayerRound[msg.sender] != RoundNumber){&#13;
            PlayerRound[msg.sender] = RoundNumber;&#13;
        }&#13;
        emit DrawnCards(msg.sender,tcard1, tcard2);&#13;
    }&#13;
    &#13;
    function GetPlayerCards(address who) public view NoContract returns (uint8, uint8){&#13;
        uint8[2] memory target = PlayerCards[who];&#13;
        &#13;
        return (target[0], target[1]);&#13;
    }&#13;
&#13;
    function GetWinCards() public view returns (uint8, uint8){&#13;
        return (WinningCards[0], WinningCards[1]);&#13;
    }&#13;
    &#13;
    &#13;
    &#13;
    // welp this is handy &#13;
    struct Card{&#13;
        uint8 rank;&#13;
        uint8 suit;&#13;
    }&#13;
    &#13;
    // web &#13;
  //  function HandWinsView(address checkhand) view returns (uint8){&#13;
    //    return HandWins(checkhand);&#13;
    //}&#13;
    &#13;
    &#13;
    function HandWins(address checkhand) internal returns (uint8){&#13;
        uint8 result = HandWinsView(checkhand);&#13;
        &#13;
        uint8[6] memory CurrScore = RankScore(checkhand);&#13;
            &#13;
        uint8[2] memory target = PlayerCards[checkhand];&#13;
        &#13;
        if (result == 1){&#13;
            WinningHand = CurrScore;&#13;
            WinningCards= [target[0],target[1]];&#13;
            PokerWinner=msg.sender;&#13;
            // clear cards &#13;
            //PlayerCards[checkhand][0]=0;&#13;
            //PlayerCards[checkhand][1]=0;&#13;
        }&#13;
        return result;&#13;
    }&#13;
    &#13;
    // returns 0 if lose, 1 if win, 2 if equal &#13;
    // if winner found immediately sets winner values &#13;
    function HandWinsView(address checkhand) public view returns (uint8){ &#13;
        if (PlayerRound[checkhand] != RoundNumber){&#13;
            return 0; // empty cards in new round. &#13;
        }&#13;
        uint8[6] memory CurrentWinHand = WinningHand;&#13;
        &#13;
        uint8[6] memory CurrScore = RankScore(checkhand);&#13;
        &#13;
        &#13;
        uint8 ret = 2;&#13;
        if (CurrScore[0] &gt; CurrentWinHand[0]){&#13;
 &#13;
            return 1;&#13;
        }&#13;
        else if (CurrScore[0] == CurrentWinHand[0]){&#13;
            for (uint i=1; i&lt;=5; i++){&#13;
                if (CurrScore[i] &gt;= CurrentWinHand[i]){&#13;
                    if (CurrScore[i] &gt; CurrentWinHand[i]){&#13;
&#13;
                        return 1;&#13;
                    }&#13;
                }&#13;
                else{&#13;
                    ret=0;&#13;
                    break;&#13;
                }&#13;
            }&#13;
        }&#13;
        else{&#13;
            ret=0;&#13;
        }&#13;
        // 2 is same hand. commented out in pay mode &#13;
        // only winner gets pot. &#13;
        return ret;&#13;
    }&#13;
    &#13;
    &#13;
&#13;
    function RankScore(address checkhand) internal view returns (uint8[6] output){&#13;
      &#13;
        uint8[4] memory FlushTracker;&#13;
        uint8[14] memory CardTracker;&#13;
        &#13;
        uint8 rank;&#13;
        uint8 suit;&#13;
        &#13;
        Card[7] memory Cards;&#13;
        &#13;
        for (uint8 i=0; i&lt;7; i++){&#13;
            if (i&gt;=5){&#13;
                (rank,suit) = GetCardInfo(PlayerCards[checkhand][i-5]);&#13;
                FlushTracker[suit]++;&#13;
                CardTracker[rank]++;&#13;
                Cards[i] = Card(rank,suit);&#13;
            }&#13;
            else{&#13;
                (rank,suit) = GetCardInfo(HouseCards[i]);&#13;
                FlushTracker[suit]++;&#13;
                CardTracker[rank]++;&#13;
                Cards[i] = Card(rank,suit);&#13;
            }&#13;
        }&#13;
        &#13;
        uint8 straight = 0;&#13;
        // skip all zero's&#13;
        uint8[3] memory straight_startcard;&#13;
        for (uint8 startcard=13; i&gt;=5; i--){&#13;
            if (CardTracker[startcard] &gt;= 1){&#13;
                for (uint8 currcard=startcard-1; currcard&gt;=(startcard-4); currcard--){&#13;
                    if (CardTracker[currcard] &gt;= 1){&#13;
                        if (currcard == (startcard-4)){&#13;
                            // at end, straight &#13;
                            straight_startcard[straight] = startcard;&#13;
                            straight++;&#13;
                        }&#13;
                    }&#13;
                    else{&#13;
                        break;&#13;
                    }&#13;
                }&#13;
            }&#13;
        }&#13;
        &#13;
        uint8 flush=0;&#13;
&#13;
        for (i=0;i&lt;=3;i++){&#13;
            if (FlushTracker[i]&gt;=5){&#13;
                flush=i;&#13;
                break;&#13;
            }&#13;
        }&#13;
        &#13;
        // done init. &#13;
        &#13;
        // straight flush? &#13;
        &#13;
        &#13;
        &#13;
        if (flush&gt;0 &amp;&amp; straight&gt;0){&#13;
            // someone has straight flush? &#13;
            // level score 9 &#13;
            output[0] = 9;&#13;
            currcard=0;&#13;
            for (i=0; i&lt;3; i++){&#13;
                startcard=straight_startcard[i];&#13;
                currcard=5; // track flush, num 5 is standard.    &#13;
                for (rank=0; i&lt;7; i++){&#13;
                    if (Cards[i].suit == flush &amp;&amp; Cards[i].rank &lt;= startcard &amp;&amp; Cards[i].rank&gt;=(startcard-4)){&#13;
                        currcard--;&#13;
                        if (currcard==0){&#13;
                            break;&#13;
                        }&#13;
                    }&#13;
                }&#13;
                if (currcard==0){&#13;
                    // found straight flush high. &#13;
                    output[1] = straight_startcard[i]; // save the high card &#13;
                    break;&#13;
                }&#13;
            }&#13;
            &#13;
            return output; &#13;
        }&#13;
        &#13;
        // high card &#13;
        &#13;
        //reuse the rank variable to sum cards; &#13;
        rank=0;&#13;
        for (i=13;i&gt;=1;i--){&#13;
            rank = rank + CardTracker[i];&#13;
            if (CardTracker[i] &gt;= 4){&#13;
                output[0] = 8; // high card &#13;
                output[1] = i; // the type of card &#13;
                return output;&#13;
            }&#13;
            if (rank &gt;=4){&#13;
                break;&#13;
            }&#13;
        }&#13;
        &#13;
        // full house &#13;
        &#13;
        rank=0; // track 3-kind &#13;
        suit=0; // track 2-kind &#13;
        startcard=0;&#13;
        currcard=0;&#13;
        &#13;
        for (i=13;i&gt;=1;i--){&#13;
            if (rank == 0 &amp;&amp; CardTracker[i] &gt;= 3){&#13;
                rank = i;&#13;
            }&#13;
            else if(CardTracker[i] &gt;= 2){&#13;
                if (suit == 0){&#13;
                    suit = CardTracker[i];&#13;
                }&#13;
                else{&#13;
                    // double nice &#13;
                    if (startcard==0){&#13;
                        startcard=CardTracker[i];&#13;
                    }&#13;
                }&#13;
            }&#13;
        }&#13;
        &#13;
        if (rank != 0 &amp;&amp; suit != 0){&#13;
            output[0] = 7;&#13;
            output[1] = rank; // full house tripple high &#13;
            output[2] = suit; // full house tripple low &#13;
            return output;&#13;
        }&#13;
        &#13;
        if (flush&gt;0){&#13;
            // flush &#13;
            output[0] = 6;&#13;
            output[1] = flush;&#13;
            return output;&#13;
            &#13;
        }&#13;
        &#13;
        if (straight&gt;0){&#13;
            //straight &#13;
            output[0] = 5;&#13;
            output[1] = straight_startcard[0];&#13;
            return output;&#13;
        }&#13;
        &#13;
        if (rank&gt;0){&#13;
            // tripple &#13;
            output[0]=4;&#13;
            output[1]=rank;&#13;
            currcard=2; // track index; &#13;
            // get 2 highest cards &#13;
            for (i=13;i&gt;=1;i--){&#13;
                if (i != rank){&#13;
                    if (CardTracker[i] &gt; 0){&#13;
                        // note at three of a kind we have no other doubles; all other ranks are different so no check &gt; 1 &#13;
                        output[currcard] = i;&#13;
                        currcard++;&#13;
                        if(currcard==4){&#13;
                            return output;&#13;
                        }&#13;
                    }&#13;
                }&#13;
            }&#13;
        }&#13;
        &#13;
        if (suit &gt; 0 &amp;&amp; startcard &gt; 0){&#13;
            // double pair &#13;
            output[0] = 3;&#13;
            output[1] = suit;&#13;
            output[2] = startcard;&#13;
            // get highest card &#13;
            for (i=13;i&gt;=1;i--){&#13;
                if (i!=suit &amp;&amp; i!=startcard &amp;&amp; CardTracker[i]&gt;0){&#13;
                    output[3]=i;&#13;
                    return output;&#13;
                }&#13;
            }&#13;
        }&#13;
        &#13;
        if (suit &gt; 0){&#13;
            // pair &#13;
            output[0]=2;&#13;
            output[1]=suit;&#13;
            currcard=2;&#13;
            // fill 3 other positions with high cards. &#13;
            for (i=13;i&gt;=1;i--){&#13;
                if (i!=suit &amp;&amp; CardTracker[i]&gt;0){&#13;
                    output[currcard]=i;&#13;
                    currcard++;&#13;
                    if(currcard==5){&#13;
                        return output;&#13;
                    }&#13;
                }   &#13;
            }&#13;
        }&#13;
        &#13;
        // welp you are here now, only have high card?&#13;
        // boring &#13;
        output[0]=1;&#13;
        currcard=1;&#13;
        for (i=13;i&gt;=1;i--){&#13;
            if (CardTracker[i]&gt;0){&#13;
                output[currcard]=i;&#13;
                currcard++;&#13;
                if (currcard==6){&#13;
                    return output;&#13;
                }&#13;
            }&#13;
        }&#13;
    }&#13;
    &#13;
}&#13;
&#13;
contract Vegas is Poker{&#13;
    address owner;&#13;
    address public feesend;&#13;
    &#13;
    &#13;
    uint256 public Timer;&#13;
    &#13;
    uint8 constant MAXPRICEPOWER = 40; // &lt; 255&#13;
    &#13;
    address public JackpotWinner;&#13;
    &#13;
    uint16 public JackpotPayout = 8000; &#13;
    uint16 public PokerPayout = 2000;&#13;
    uint16 public PreviousPayout = 6500;&#13;
    uint16 public Increase = 9700;&#13;
    uint16 public Tax = 500;&#13;
    uint16 public PotPayout = 8000;&#13;
    &#13;
    uint256 public BasePrice = (0.005 ether);&#13;
    &#13;
    uint256 public TotalPot;&#13;
    uint256 public PokerPayoutValue;&#13;
    &#13;
    // mainnet &#13;
    uint256[9] TimeArray = [uint256(6 hours), uint256(3 hours), uint256(2 hours), uint256(1 hours), uint256(50 minutes), uint256(40 minutes), uint256(30 minutes), uint256(20 minutes), uint256(15 minutes)];&#13;
    // testnet &#13;
    //uint256[3] TimeArray = [uint256(3 minutes), uint256(3 minutes), uint256(2 minutes)];&#13;
    &#13;
    struct Item{&#13;
        address Holder;&#13;
        uint8 PriceID;&#13;
    }&#13;
    &#13;
    Item[16] public Market;&#13;
    &#13;
    uint8 public MaxItems = 12; // max ID, is NOT index but actual max items to buy. 0 means really nothing, not 1 item &#13;
    &#13;
    event ItemBought(uint256 Round, uint8 ID,  uint256 Price, address BoughtFrom, address NewOwner, uint256 NewTimer, uint256 NewJP, string Quote, string Name);&#13;
    // quotes here ? &#13;
    event PokerPaid(uint256 Round, uint256 AmountWon, address Who, string Quote, string Name, uint8[6] WinHand);&#13;
    event JackpotPaid(uint256 Round, uint256 Amount,  address Who, string Quote, string Name);&#13;
    event NewRound();&#13;
    &#13;
    bool public EditMode;&#13;
    bool public SetEditMode;&#13;
    // dev functions &#13;
    &#13;
    modifier OnlyOwner(){&#13;
        require(msg.sender == owner);&#13;
        _;&#13;
    }&#13;
    &#13;
    modifier GameClosed(){&#13;
        require (block.timestamp &gt; Timer);&#13;
        _;&#13;
    }&#13;
    &#13;
&#13;
    &#13;
    function Vegas() public{&#13;
        owner=msg.sender;&#13;
        feesend=0xC1086FA97549CEA7acF7C2a7Fa7820FD06F3e440;&#13;
        // withdraw also setups new game. &#13;
        // pays out 0 eth of course to owner, no eth in contract. &#13;
        Timer = 1; // makes sure withdrawal runs&#13;
        //Withdraw("Game init", "Admin");&#13;
    }&#13;
    &#13;
    // all contract calls are banned from buying &#13;
    function Buy(uint8 ID, string Quote, string Name) public payable NoContract {&#13;
        require(ID &lt; MaxItems);&#13;
        require(!EditMode);&#13;
        // get price &#13;
        //uint8 pid = Market[ID].PriceID;&#13;
        uint256 price = GetPrice(Market[ID].PriceID);&#13;
        require(msg.value &gt;= price);&#13;
        &#13;
        if (block.timestamp &gt; Timer){&#13;
            if (Timer != 0){ // timer 0 means withdraw is gone; withdraw will throw on 0&#13;
                Withdraw("GameInit", "Admin");&#13;
                return;&#13;
            }&#13;
        }&#13;
        &#13;
        // return excess &#13;
        if (msg.value &gt; price){&#13;
            msg.sender.transfer(msg.value-price);&#13;
        }&#13;
        &#13;
        uint256 PayTax = (price * Tax)/10000;&#13;
        feesend.transfer(PayTax);&#13;
        uint256 Left = (price-PayTax);&#13;
        &#13;
        &#13;
        if (Market[ID].PriceID!=0){&#13;
            // unzero, move to previous owner&#13;
            uint256 pay = (Left*PreviousPayout)/10000;&#13;
            TotalPot = TotalPot + (Left-pay);&#13;
           // Left=Left-pay;&#13;
            Market[ID].Holder.transfer(pay);&#13;
        }&#13;
        else{&#13;
            TotalPot = TotalPot + Left;&#13;
        }&#13;
        &#13;
        // reset timer; &#13;
        Timer = block.timestamp + GetTime(Market[ID].PriceID);&#13;
        //set jackpot winner &#13;
        JackpotWinner = msg.sender;&#13;
&#13;
&#13;
        // give user new card; &#13;
        &#13;
        emit ItemBought(RoundNumber,ID,  price,  Market[ID].Holder, msg.sender, Timer,  TotalPot,  Quote, Name);&#13;
        &#13;
        DrawAddr(); // give player cards&#13;
        &#13;
        // update price &#13;
        Market[ID].PriceID++;&#13;
        //set holder &#13;
        Market[ID].Holder=msg.sender;&#13;
    }&#13;
    &#13;
    function GetPrice(uint8 id) public view returns (uint256){&#13;
        uint256 p = BasePrice;&#13;
        if (id &gt; 0){&#13;
            // max price baseprice * increase^20 is reasonable&#13;
            for (uint i=1; i&lt;=id; i++){&#13;
                if (i==MAXPRICEPOWER){&#13;
                    break; // prevent overflow (not sure why someone would buy at increase^255)&#13;
                }&#13;
                p = (p * (10000 + Increase))/10000;&#13;
            }&#13;
        }&#13;
        &#13;
        return p;&#13;
    }&#13;
    &#13;
    function PayPoker(string Quote, string Name) public NoContract{&#13;
        uint8 wins = HandWins(msg.sender);&#13;
        if (wins&gt;0){&#13;
            uint256 available_balance = (TotalPot*PotPayout)/10000;&#13;
            uint256 payment = sub ((available_balance * PokerPayout)/10000 , PokerPayoutValue);&#13;
            &#13;
            &#13;
            &#13;
            PokerPayoutValue = PokerPayoutValue + payment;&#13;
            if (wins==1){&#13;
                msg.sender.transfer(payment);&#13;
                emit PokerPaid(RoundNumber, payment, msg.sender,  Quote,  Name, WinningHand);&#13;
            }&#13;
            /*&#13;
            else if (wins==2){&#13;
                uint256 pval = payment/2;&#13;
                msg.sender.transfer(pval);&#13;
                PokerWinner.transfer(payment-pval);// saves 1 wei error &#13;
                emit PokerPaid(RoundNumber, pval, msg.sender,  Quote,  Name, WinningHand);&#13;
                emit PokerPaid(RoundNumber, pval, msg.sender, "", "", WinningHand);&#13;
            }*/&#13;
        }&#13;
        else{&#13;
            // nice bluff mate &#13;
            revert();&#13;
        }&#13;
    }&#13;
    &#13;
    function GetTime(uint8 id) public view returns (uint256){&#13;
        if (id &gt;= TimeArray.length){&#13;
            return TimeArray[TimeArray.length-1];&#13;
        }&#13;
        else{&#13;
            return TimeArray[id];&#13;
        }&#13;
    }&#13;
    &#13;
    //function Call() public {&#13;
   //     DrawHouse();&#13;
   // }&#13;
    &#13;
    &#13;
    // pays winner. &#13;
    // also sets up new game &#13;
    // winner receives lots of eth compared to gas so a small payment to gas is reasonable.&#13;
    &#13;
    function Withdraw(string Quote, string Name) public NoContract {&#13;
        _withdraw(Quote,Name,false);&#13;
    }&#13;
    &#13;
    // in case there is a revert bug in the poker contract &#13;
    // allows winner to get paid without calling poker. should never be called &#13;
    // follows all normal rules of game .&#13;
    function WithdrawEmergency() public OnlyOwner{&#13;
        _withdraw("Emergency withdraw call","Admin",true);&#13;
    }&#13;
    function _withdraw(string Quote, string Name, bool Emergency) NoContract internal {&#13;
        // Setup cards for new game. &#13;
        &#13;
        require(block.timestamp &gt; Timer &amp;&amp; Timer != 0);&#13;
        Timer=0; // prevent re-entrancy immediately. &#13;
        &#13;
        // send from this.balance &#13;
        uint256 available_balance = (TotalPot*PotPayout)/10000;&#13;
        uint256 bal = (available_balance * JackpotPayout)/10000;&#13;
        &#13;
                    &#13;
        JackpotWinner.transfer(bal);&#13;
        emit JackpotPaid(RoundNumber, bal,  JackpotWinner, Quote, Name);&#13;
        &#13;
        // pay the last poker winner remaining poker pot.&#13;
        bal = sub(sub(available_balance, bal),PokerPayoutValue);&#13;
        if (bal &gt; 0 &amp;&amp; PokerWinner != address(this)){&#13;
            // this only happens at start game,  some wei error &#13;
            if (bal &gt; address(this).balance){&#13;
                PokerWinner.transfer(address(this).balance);&#13;
            }&#13;
            else{&#13;
                PokerWinner.transfer(bal);     &#13;
            }&#13;
           &#13;
            emit PokerPaid(RoundNumber, bal, PokerWinner,  "Paid out left poker pot", "Dealer", WinningHand);&#13;
        }&#13;
        TotalPot = address(this).balance;&#13;
    &#13;
        // next poker pot starts at zero. &#13;
        PokerPayoutValue= (TotalPot * PotPayout * PokerPayout)/(10000*10000);&#13;
&#13;
        // reset price &#13;
&#13;
        for (uint i=0; i&lt;MaxItems; i++){&#13;
            Market[i].PriceID=0;&#13;
        }&#13;
        &#13;
        if (!Emergency){&#13;
            DrawHouse();&#13;
        }&#13;
        RoundNumber++;&#13;
        // enable edit mode if set by dev.&#13;
        EditMode=SetEditMode;&#13;
        &#13;
        emit NewRound();&#13;
    }&#13;
    &#13;
    // dev edit functions below &#13;
    &#13;
    &#13;
    function setEditModeBool(bool editmode) public OnlyOwner {&#13;
        // start edit mode closes the whole game. &#13;
        SetEditMode=editmode;&#13;
        if (!editmode){&#13;
            // enable game round.&#13;
            EditMode=false;&#13;
        }&#13;
    }&#13;
    &#13;
    function emergencyDropEth() public payable{&#13;
        // any weird error might be solved by dropping eth (and no this is not even a scam, if contract needs a wei more, we send a wei, get funds out and fix contract)&#13;
    }&#13;
        &#13;
    function editTimer(uint8 ID, uint256 Time) public OnlyOwner GameClosed{&#13;
        TimeArray[ID] = Time;&#13;
    }&#13;
    &#13;
    function editBasePrice(uint256 NewBasePrice) public OnlyOwner GameClosed{&#13;
        BasePrice = NewBasePrice;  &#13;
    }&#13;
    &#13;
    function editMaxItems(uint8 NewMax) public OnlyOwner GameClosed{&#13;
        MaxItems = NewMax;&#13;
    }&#13;
    &#13;
    function editPayoutSetting(uint8 setting, uint16 newv) public OnlyOwner GameClosed{&#13;
        require(setting &gt; 0);&#13;
        if (setting == 1){&#13;
            require(newv &lt;= 10000);&#13;
            JackpotPayout = newv;&#13;
            PokerPayout = 10000-newv;&#13;
        }&#13;
        else if (setting == 2){&#13;
            require(newv &lt;= 10000);&#13;
           &#13;
            PokerPayout = newv;&#13;
            JackpotPayout = 10000-newv;&#13;
        }&#13;
        else if (setting == 3){&#13;
            require (newv &lt;= 10000);&#13;
            PreviousPayout = newv;&#13;
        }&#13;
        else if (setting == 4){&#13;
            require(newv &lt;= 30000);&#13;
            Increase = newv;&#13;
        }&#13;
        else if (setting == 5){&#13;
            require(newv &lt;=10000);&#13;
            PotPayout = newv;&#13;
        }&#13;
        else if (setting == 6){&#13;
            require(newv &lt; 700);&#13;
            Tax = newv;&#13;
        }&#13;
        else{&#13;
            revert();&#13;
        }&#13;
    }&#13;
    &#13;
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
    if (a == 0) {&#13;
      return 0;&#13;
    }&#13;
    uint256 c = a * b;&#13;
    assert(c / a == b);&#13;
    return c;&#13;
  }&#13;
&#13;
  /**&#13;
  * @dev Integer division of two numbers, truncating the quotient.&#13;
  */&#13;
  function div(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
    // assert(b &gt; 0); // Solidity automatically throws when dividing by 0&#13;
    uint256 c = a / b;&#13;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold&#13;
    return c;&#13;
  }&#13;
&#13;
  /**&#13;
  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).&#13;
  */&#13;
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
    assert(b &lt;= a);&#13;
    return a - b;&#13;
  }&#13;
&#13;
  /**&#13;
  * @dev Adds two numbers, throws on overflow.&#13;
  */&#13;
  function add(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
    uint256 c = a + b;&#13;
    assert(c &gt;= a);&#13;
    return c;&#13;
  }&#13;
}