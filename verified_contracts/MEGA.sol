pragma solidity 0.4.23;
///////////////////////////////
//By <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="57317936392338393e3879363c323b17303a363e3b7934383a">[emailÂ protected]</a>//&#13;
///////////////////////////////&#13;
/**&#13;
 * @title SafeMath&#13;
 * @dev Math operations with safety checks that throw on error&#13;
 */&#13;
library SafeMath {&#13;
&#13;
  /**&#13;
  * @dev Multiplies two numbers, throws on overflow.&#13;
  */&#13;
  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {&#13;
    if (a == 0) {&#13;
      return 0;&#13;
    }&#13;
    c = a * b;&#13;
    assert(c / a == b);&#13;
    return c;&#13;
  }&#13;
&#13;
  /**&#13;
  * @dev Integer division of two numbers, truncating the quotient.&#13;
  */&#13;
  function div(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
    // assert(b &gt; 0); // Solidity automatically throws when dividing by 0&#13;
    // uint256 c = a / b;&#13;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold&#13;
    return a / b;&#13;
  }&#13;
&#13;
  /**&#13;
  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).&#13;
  */&#13;
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
    assert(b &lt;= a);&#13;
    return a - b;&#13;
  }&#13;
&#13;
  /**&#13;
  * @dev Adds two numbers, throws on overflow.&#13;
  */&#13;
  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {&#13;
    c = a + b;&#13;
    assert(c &gt;= a);&#13;
    return c;&#13;
  }&#13;
}&#13;
&#13;
/*&#13;
    Owned contract interface&#13;
*/&#13;
contract IOwned {&#13;
    // this function isn't abstract since the compiler emits automatically generated getter functions as external&#13;
    function owner() public view returns (address) {}&#13;
&#13;
    function transferOwnership(address _newOwner) public;&#13;
    function acceptOwnership() public;&#13;
}&#13;
&#13;
/*&#13;
    Bancor Converter interface&#13;
*/&#13;
contract IBancorConverter{&#13;
&#13;
    function getReturn(address _fromToken, address _toToken, uint256 _amount) public view returns (uint256);&#13;
	function quickConvert(address[] _path, uint256 _amount, uint256 _minReturn) public payable returns (uint256);&#13;
&#13;
}&#13;
/*&#13;
    Bancor Quick Converter interface&#13;
*/&#13;
contract IBancorQuickConverter {&#13;
    function convert(IERC20Token[] _path, uint256 _amount, uint256 _minReturn) public payable returns (uint256);&#13;
    function convertFor(IERC20Token[] _path, uint256 _amount, uint256 _minReturn, address _for) public payable returns (uint256);&#13;
    function convertForPrioritized(IERC20Token[] _path, uint256 _amount, uint256 _minReturn, address _for, uint256 _block, uint256 _nonce, uint8 _v, bytes32 _r, bytes32 _s) public payable returns (uint256);&#13;
}&#13;
&#13;
/*&#13;
    Bancor Gas tools interface&#13;
*/&#13;
contract IBancorGasPriceLimit {&#13;
    function gasPrice() public view returns (uint256) {}&#13;
    function validateGasPrice(uint256) public view;&#13;
}&#13;
&#13;
/*&#13;
    EIP228 Token Converter interface&#13;
*/&#13;
contract ITokenConverter {&#13;
    function convertibleTokenCount() public view returns (uint16);&#13;
    function convertibleToken(uint16 _tokenIndex) public view returns (address);&#13;
    function getReturn(IERC20Token _fromToken, IERC20Token _toToken, uint256 _amount) public view returns (uint256);&#13;
    function convert(IERC20Token _fromToken, IERC20Token _toToken, uint256 _amount, uint256 _minReturn) public returns (uint256);&#13;
    // deprecated, backward compatibility&#13;
    function change(IERC20Token _fromToken, IERC20Token _toToken, uint256 _amount, uint256 _minReturn) public returns (uint256);&#13;
}&#13;
&#13;
/*&#13;
    ERC20 Standard Token interface&#13;
*/&#13;
contract IERC20Token {&#13;
    // these functions aren't abstract since the compiler emits automatically generated getter functions as external&#13;
    function name() public view returns (string) {}&#13;
    function symbol() public view returns (string) {}&#13;
    function decimals() public view returns (uint8) {}&#13;
    function totalSupply() public view returns (uint256) {}&#13;
    function balanceOf(address _owner) public view returns (uint256) { _owner; }&#13;
    function allowance(address _owner, address _spender) public view returns (uint256) { _owner; _spender; }&#13;
&#13;
    function transfer(address _to, uint256 _value) public returns (bool success);&#13;
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);&#13;
    function approve(address _spender, uint256 _value) public returns (bool success);&#13;
}&#13;
&#13;
/*&#13;
    Smart Token interface&#13;
*/&#13;
contract ISmartToken is IOwned, IERC20Token {&#13;
    function disableTransfers(bool _disable) public;&#13;
    function issue(address _to, uint256 _amount) public;&#13;
    function destroy(address _from, uint256 _amount) public;&#13;
}&#13;
&#13;
/**&#13;
* @title Admin parameters&#13;
* @dev Define administration parameters for this contract&#13;
*/&#13;
contract admined { //This token contract is administered&#13;
    address public admin; //Admin address is public&#13;
&#13;
    /**&#13;
    * @dev Contract constructor&#13;
    * define initial administrator&#13;
    */&#13;
    constructor() internal {&#13;
        admin = msg.sender; //Set initial admin to contract creator&#13;
        emit Admined(admin);&#13;
    }&#13;
&#13;
    modifier onlyAdmin() { //A modifier to define admin-only functions&#13;
        require(msg.sender == admin);&#13;
        _;&#13;
    }&#13;
&#13;
   /**&#13;
    * @dev Function to set new admin address&#13;
    * @param _newAdmin The address to transfer administration to&#13;
    */&#13;
    function transferAdminship(address _newAdmin) onlyAdmin public { //Admin can be transfered&#13;
        require(_newAdmin != 0);&#13;
        admin = _newAdmin;&#13;
        emit TransferAdminship(admin);&#13;
    }&#13;
&#13;
    event TransferAdminship(address newAdminister);&#13;
    event Admined(address administer);&#13;
&#13;
}&#13;
&#13;
&#13;
/**&#13;
* @title ERC20Token&#13;
* @notice Token definition contract&#13;
*/&#13;
contract MEGA is admined,IERC20Token { //Standar definition of an ERC20Token&#13;
    using SafeMath for uint256; //SafeMath is used for uint256 operations&#13;
&#13;
///////////////////////////////////////////////////////////////////////////////////////&#13;
///									Token Related									///&#13;
///////////////////////////////////////////////////////////////////////////////////////&#13;
&#13;
    mapping (address =&gt; uint256) balances; //A mapping of all balances per address&#13;
    mapping (address =&gt; mapping (address =&gt; uint256)) allowed; //A mapping of all allowances&#13;
    uint256 public totalSupply;&#13;
    &#13;
    /**&#13;
    * @notice Get the balance of an _owner address.&#13;
    * @param _owner The address to be query.&#13;
    */&#13;
    function balanceOf(address _owner) public constant returns (uint256 bal) {&#13;
        return balances[_owner];&#13;
    }&#13;
&#13;
    /**&#13;
    * @notice transfer _value tokens to address _to&#13;
    * @param _to The address to transfer to.&#13;
    * @param _value The amount to be transferred.&#13;
    * @return success with boolean value true if done&#13;
    */&#13;
    function transfer(address _to, uint256 _value) public returns (bool success) {&#13;
        require(_to != address(0)); //If you dont want that people destroy token&#13;
        &#13;
        if(_to == address(this)){&#13;
        	burnToken(msg.sender, _value);&#13;
        	sell(msg.sender,_value);&#13;
        	return true;&#13;
        } else {&#13;
            balances[msg.sender] = balances[msg.sender].sub(_value);&#13;
	        balances[_to] = balances[_to].add(_value);&#13;
    	    emit Transfer(msg.sender, _to, _value);&#13;
        	return true;&#13;
&#13;
        }&#13;
    }&#13;
&#13;
    /**&#13;
    * @notice Transfer _value tokens from address _from to address _to using allowance msg.sender allowance on _from&#13;
    * @param _from The address where tokens comes.&#13;
    * @param _to The address to transfer to.&#13;
    * @param _value The amount to be transferred.&#13;
    * @return success with boolean value true if done&#13;
    */&#13;
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {&#13;
        require(_to != address(0)); //If you dont want that people destroy token&#13;
        balances[_from] = balances[_from].sub(_value);&#13;
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);&#13;
        balances[_to] = balances[_to].add(_value);&#13;
        emit Transfer(_from, _to, _value);&#13;
        return true;&#13;
    }&#13;
&#13;
    /**&#13;
    * @notice Assign allowance _value to _spender address to use the msg.sender balance&#13;
    * @param _spender The address to be allowed to spend.&#13;
    * @param _value The amount to be allowed.&#13;
    * @return success with boolean value true&#13;
    */&#13;
    function approve(address _spender, uint256 _value) public returns (bool success) {&#13;
    	require((_value == 0) || (allowed[msg.sender][_spender] == 0)); //exploit mitigation&#13;
        allowed[msg.sender][_spender] = _value;&#13;
        emit Approval(msg.sender, _spender, _value);&#13;
        return true;&#13;
    }&#13;
&#13;
    /**&#13;
    * @notice Get the allowance of an specified address to use another address balance.&#13;
    * @param _owner The address of the owner of the tokens.&#13;
    * @param _spender The address of the allowed spender.&#13;
    * @return remaining with the allowance value&#13;
    */&#13;
    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {&#13;
        return allowed[_owner][_spender];&#13;
    }&#13;
&#13;
    /**&#13;
    * @dev Mint token to an specified address.&#13;
    * @param _target The address of the receiver of the tokens.&#13;
    * @param _mintedAmount amount to mint.&#13;
    */&#13;
    function mintToken(address _target, uint256 _mintedAmount) private {&#13;
        balances[_target] = SafeMath.add(balances[_target], _mintedAmount);&#13;
        totalSupply = SafeMath.add(totalSupply, _mintedAmount);&#13;
        emit Transfer(0, this, _mintedAmount);&#13;
        emit Transfer(this, _target, _mintedAmount);&#13;
    }&#13;
&#13;
    /**&#13;
    * @dev Burn token of an specified address.&#13;
    * @param _target The address of the holder of the tokens.&#13;
    * @param _burnedAmount amount to burn.&#13;
    */&#13;
    function burnToken(address _target, uint256 _burnedAmount) private {&#13;
        balances[_target] = SafeMath.sub(balances[_target], _burnedAmount);&#13;
        totalSupply = SafeMath.sub(totalSupply, _burnedAmount);&#13;
        emit Burned(_target, _burnedAmount);&#13;
    }&#13;
&#13;
    /**&#13;
    * @dev Log Events&#13;
    */&#13;
    event Transfer(address indexed _from, address indexed _to, uint256 _value);&#13;
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);&#13;
    event Burned(address indexed _target, uint256 _value);&#13;
&#13;
///////////////////////////////////////////////////////////////////////////////////////&#13;
///								Investment related									///&#13;
///////////////////////////////////////////////////////////////////////////////////////&#13;
&#13;
	//Internal Variables&#13;
	IBancorConverter BancorConverter = IBancorConverter(0xc6725aE749677f21E4d8f85F41cFB6DE49b9Db29);&#13;
	IBancorQuickConverter Bancor = IBancorQuickConverter(0xcF1CC6eD5B653DeF7417E3fA93992c3FFe49139B);&#13;
	IBancorGasPriceLimit BancorGas = IBancorGasPriceLimit(0x607a5C47978e2Eb6d59C6C6f51bc0bF411f4b85a);&#13;
&#13;
	IERC20Token ETHToken = IERC20Token(0xc0829421C1d260BD3cB3E0F06cfE2D52db2cE315);&#13;
&#13;
	IERC20Token BNTToken = IERC20Token(0x1F573D6Fb3F13d689FF844B4cE37794d79a7FF1C);&#13;
&#13;
	IERC20Token EOSRelay = IERC20Token(0x507b06c23d7Cb313194dBF6A6D80297137fb5E01);&#13;
	IERC20Token EOSToken = IERC20Token(0x86Fa049857E0209aa7D9e616F7eb3b3B78ECfdb0);&#13;
&#13;
	IERC20Token ELFRelay = IERC20Token(0x0F2318565f1996CB1eD2F88e172135791BC1FcBf);&#13;
	IERC20Token ELFToken = IERC20Token(0xbf2179859fc6D5BEE9Bf9158632Dc51678a4100e);&#13;
&#13;
	IERC20Token OMGToken = IERC20Token(0x99eBD396Ce7AA095412a4Cd1A0C959D6Fd67B340);&#13;
	IERC20Token OMGRelay = IERC20Token(0xd26114cd6EE289AccF82350c8d8487fedB8A0C07);&#13;
&#13;
	IERC20Token POAToken = IERC20Token(0x564c07255AFe5050D82c8816F78dA13f2B17ac6D);&#13;
	IERC20Token POARelay = IERC20Token(0x6758B7d441a9739b98552B373703d8d3d14f9e62);&#13;
&#13;
	IERC20Token DRGNToken = IERC20Token(0xa7774F9386E1653645E1A08fb7Aae525B4DeDb24);&#13;
	IERC20Token DRGNRelay = IERC20Token(0x419c4dB4B9e25d6Db2AD9691ccb832C8D9fDA05E);&#13;
&#13;
	IERC20Token SRNToken = IERC20Token(0xd2Deb679ed81238CaeF8E0c32257092cEcc8888b);&#13;
	IERC20Token SRNRelay = IERC20Token(0x68d57c9a1C35f63E2c83eE8e49A64e9d70528D25);&#13;
&#13;
	IERC20Token WAXToken = IERC20Token(0x67563E7A0F13642068F6F999e48c690107A4571F);&#13;
	IERC20Token WAXRelay = IERC20Token(0x39Bb259F66E1C59d5ABEF88375979b4D20D98022);&#13;
&#13;
&#13;
	IERC20Token POWRToken = IERC20Token(0x168D7Bbf38E17941173a352f1352DF91a7771dF3);&#13;
	IERC20Token POWRRelay = IERC20Token(0x595832F8FC6BF59c85C527fEC3740A1b7a361269);&#13;
&#13;
	bool buyFlag = false; //False = set rate - True = auto rate&#13;
	uint256 constant internal magnitude = 2**64;&#13;
	//Path to exchanges&#13;
	mapping(uint8 =&gt; IERC20Token[]) paths;&#13;
	mapping(uint8 =&gt; IERC20Token[]) reversePaths;&#13;
&#13;
&#13;
	//public variables&#13;
	address public feeWallet;&#13;
	uint256 public rate = 6850;&#13;
	//token related&#13;
	string public name = "MEGAINVEST v2";&#13;
    uint8 public decimals = 18;&#13;
    string public symbol = "MEG2";&#13;
    string public version = '2';&#13;
&#13;
	constructor(address _feeWallet) public {&#13;
		feeWallet = _feeWallet;&#13;
		paths[0] = [ETHToken,BNTToken,BNTToken,EOSRelay,EOSRelay,EOSRelay,EOSToken];&#13;
    	paths[1] = [ETHToken,BNTToken,BNTToken,ELFRelay,ELFRelay,ELFRelay,ELFToken];&#13;
    	paths[2] = [ETHToken,BNTToken,BNTToken,OMGRelay,OMGRelay,OMGRelay,OMGToken];&#13;
    	paths[3] = [ETHToken,BNTToken,BNTToken,POARelay,POARelay,POARelay,POAToken];&#13;
    	paths[4] = [ETHToken,BNTToken,BNTToken,DRGNRelay,DRGNRelay,DRGNRelay,DRGNToken];&#13;
    	paths[5] = [ETHToken,BNTToken,BNTToken,SRNRelay,SRNRelay,SRNRelay,SRNToken];&#13;
    	paths[6] = [ETHToken,BNTToken,BNTToken,WAXRelay,WAXRelay,WAXRelay,WAXToken];&#13;
    	paths[7] = [ETHToken,BNTToken,BNTToken,POWRRelay,POWRRelay,POWRRelay,POWRToken];&#13;
&#13;
    	reversePaths[0] = [EOSToken,EOSRelay,EOSRelay,EOSRelay,BNTToken,BNTToken,ETHToken];&#13;
    	reversePaths[1] = [ELFToken,ELFRelay,ELFRelay,ELFRelay,BNTToken,BNTToken,ETHToken];&#13;
    	reversePaths[2] = [OMGToken,OMGRelay,OMGRelay,OMGRelay,BNTToken,BNTToken,ETHToken];&#13;
    	reversePaths[3] = [POAToken,POARelay,POARelay,POARelay,BNTToken,BNTToken,ETHToken];&#13;
    	reversePaths[4] = [DRGNToken,DRGNRelay,DRGNRelay,DRGNRelay,BNTToken,BNTToken,ETHToken];&#13;
    	reversePaths[5] = [SRNToken,SRNRelay,SRNRelay,SRNRelay,BNTToken,BNTToken,ETHToken];&#13;
    	reversePaths[6] = [WAXToken,WAXRelay,WAXRelay,WAXRelay,BNTToken,BNTToken,ETHToken];&#13;
    	reversePaths[7] = [POWRToken,POWRRelay,POWRRelay,POWRRelay,BNTToken,BNTToken,ETHToken];&#13;
	}&#13;
&#13;
	function changeBuyFlag(bool _flag) public onlyAdmin {&#13;
		buyFlag = _flag;&#13;
	}&#13;
	&#13;
	function updateRate(uint256 _rate) public onlyAdmin {&#13;
	    rate = _rate;&#13;
	}&#13;
&#13;
	function valueOnContract() public view returns (uint256){&#13;
&#13;
		ISmartToken smartToken;&#13;
        IERC20Token toToken;&#13;
        ITokenConverter converter;&#13;
        IERC20Token[] memory _path;&#13;
        uint256 pathLength;&#13;
        uint256 sumUp;&#13;
        uint256 _amount;&#13;
        IERC20Token _fromToken;&#13;
&#13;
        for(uint8 j=0;j&lt;8;j++){&#13;
        	_path = reversePaths[j];&#13;
        	// iterate over the conversion path&#13;
	        pathLength = _path.length;&#13;
	        _fromToken = _path[0];&#13;
	        _amount = _fromToken.balanceOf(address(this));&#13;
&#13;
	        for (uint256 i = 1; i &lt; pathLength; i += 2) {&#13;
	            smartToken = ISmartToken(_path[i]);&#13;
	            toToken = _path[i + 1];&#13;
	            converter = ITokenConverter(smartToken.owner());&#13;
&#13;
	            // make the conversion - if it's the last one, also provide the minimum return value&#13;
	            _amount = converter.getReturn(_fromToken, toToken, _amount);&#13;
	            _fromToken = toToken;&#13;
	        }&#13;
	        &#13;
	        sumUp += _amount;&#13;
        }&#13;
&#13;
        return sumUp;&#13;
&#13;
	}&#13;
&#13;
	function buy() public payable {&#13;
	    BancorGas.validateGasPrice(tx.gasprice);&#13;
&#13;
		if(buyFlag == false){&#13;
			tokenBuy = msg.value.mul(rate);&#13;
		} else {&#13;
&#13;
			uint256 valueStored = valueOnContract();&#13;
			uint256 tokenBuy;&#13;
&#13;
			if(totalSupply &gt; valueStored){&#13;
&#13;
				uint256 tempRate = totalSupply.div(valueStored); // Must be &gt; 0 Tok/Eth&#13;
				tokenBuy = msg.value.mul(tempRate); // Eth * Tok / Eth = Tok&#13;
&#13;
			} else {&#13;
				&#13;
				uint256 tempPrice = valueStored.div(totalSupply); // Must be &gt; 0 Eth/Tok&#13;
				tokenBuy = msg.value.div(tempPrice); // Eth / Eth / Tok = Tok&#13;
&#13;
			}&#13;
		}&#13;
		&#13;
&#13;
		uint256 ethFee = msg.value.mul(5)/1000; //5/1000 =&gt; 0.5%&#13;
		uint256 ethToInvest = msg.value.sub(ethFee);&#13;
&#13;
		feeWallet.transfer(ethFee);&#13;
		invest(ethToInvest);&#13;
&#13;
		mintToken(msg.sender,tokenBuy);&#13;
&#13;
	}&#13;
&#13;
	function invest(uint256 _amount) private {&#13;
		uint256 standarValue = _amount.div(8);&#13;
&#13;
		for(uint8 i=0; i&lt;8; i++){ &#13;
			Bancor.convertForPrioritized.value(standarValue)(paths[i],standarValue,1,address(this),0,0,0,0x0,0x0);&#13;
		}&#13;
&#13;
	}&#13;
&#13;
	function sell(address _target, uint256 _amount) private {&#13;
		uint256 tempBalance;&#13;
		uint256 tempFee;&#13;
		IERC20Token tempToken;&#13;
		uint256 dividedSupply = totalSupply.div(magnitude); //ethereum is not decimals friendly&#13;
&#13;
		if(dividedSupply == 0 || _amount &lt; dividedSupply) revert();&#13;
		&#13;
		uint256 factor = _amount.div(dividedSupply);&#13;
&#13;
		if( factor == 0) revert();&#13;
&#13;
		for(uint8 i=0; i&lt;8; i++){ &#13;
	&#13;
			tempToken = IERC20Token(paths[i][paths[i].length - 1]);&#13;
			tempBalance = tempToken.balanceOf(this);&#13;
			tempBalance = tempBalance.mul(factor);&#13;
			tempBalance = tempBalance.div(magnitude);&#13;
			tempFee = tempBalance.mul(5);&#13;
			tempFee = tempFee.div(1000); //0.5%&#13;
			tempBalance = tempBalance.sub(tempFee);&#13;
			tempToken.transfer(feeWallet,tempFee);&#13;
			tempToken.transfer(_target,tempBalance);&#13;
&#13;
		}&#13;
	}&#13;
	&#13;
	function emergency() onlyAdmin public{&#13;
	    msg.sender.transfer(address(this).balance);&#13;
	}&#13;
	&#13;
    function claimTokens(IERC20Token _address, address _to) onlyAdmin public  {&#13;
        require(_to != address(0));&#13;
        uint256 remainder = _address.balanceOf(this); //Check remainder tokens&#13;
        _address.transfer(_to,remainder); //Transfer tokens to creator&#13;
    }&#13;
&#13;
	function () public payable{&#13;
		buy();&#13;
	}&#13;
&#13;
}