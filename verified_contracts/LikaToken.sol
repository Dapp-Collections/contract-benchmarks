pragma solidity ^0.4.18;

//contract By Yoav Taieb: <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="4f36202e396126203c2b2a390f28222e2623612c2022">[emailÂ protected]</a>&#13;
&#13;
library SafeMath {&#13;
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
    uint256 c = a * b;&#13;
    assert(a == 0 || c / a == b);&#13;
    return c;&#13;
  }&#13;
&#13;
  function div(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
    uint256 c = a / b;&#13;
    return c;&#13;
  }&#13;
&#13;
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
    assert(b &lt;= a);&#13;
    return a - b;&#13;
  }&#13;
&#13;
  function add(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
    uint256 c = a + b;&#13;
    assert(c &gt;= a);&#13;
    return c;&#13;
  }&#13;
}&#13;
&#13;
interface TokenUpgraderInterface{&#13;
    function upgradeFor(address _for, uint256 _value) external returns (bool success);&#13;
    function upgradeFrom(address _by, address _for, uint256 _value) external returns (bool success);&#13;
}&#13;
&#13;
contract LikaToken {&#13;
    using SafeMath for uint256;&#13;
&#13;
    address public owner = msg.sender;&#13;
    address public crowdsaleContractAddress;&#13;
    address public crowdsaleManager;&#13;
&#13;
    string public name;&#13;
    string public symbol;&#13;
&#13;
    bool public upgradable = false;&#13;
    bool public upgraderSet = false;&#13;
    TokenUpgraderInterface public upgrader;&#13;
&#13;
    bool public locked = true;&#13;
    bool public mintingAllowed = true;&#13;
    uint8 public decimals = 18;&#13;
&#13;
    modifier unlocked() {&#13;
        require(!locked);&#13;
        _;&#13;
    }&#13;
&#13;
    modifier unlockedOrByManager() {&#13;
        require(!locked || (crowdsaleManager != address(0) &amp;&amp; msg.sender == crowdsaleManager) || (msg.sender == owner));&#13;
        _;&#13;
    }&#13;
    // Ownership&#13;
&#13;
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);&#13;
&#13;
    modifier onlyOwner() {&#13;
        require(msg.sender == owner);&#13;
        _;&#13;
    }&#13;
&#13;
    modifier onlyCrowdsale() {&#13;
        require(msg.sender == crowdsaleContractAddress);&#13;
        _;&#13;
    }&#13;
&#13;
    modifier ownerOrCrowdsale() {&#13;
        require(msg.sender == owner || msg.sender == crowdsaleContractAddress);&#13;
        _;&#13;
    }&#13;
&#13;
    function transferOwnership(address newOwner) public onlyOwner returns (bool success) {&#13;
        require(newOwner != address(0));&#13;
        emit OwnershipTransferred(owner, newOwner);&#13;
        owner = newOwner;&#13;
        return true;&#13;
    }&#13;
&#13;
    // ERC20 related functions&#13;
    uint256 public totalSupply = 0;&#13;
&#13;
    mapping(address =&gt; uint256) balances;&#13;
    mapping (address =&gt; mapping (address =&gt; uint256)) allowed;&#13;
&#13;
&#13;
    event Transfer(address indexed _from, address indexed _to, uint256 _value);&#13;
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);&#13;
&#13;
    function transfer(address _to, uint256 _value) unlockedOrByManager public returns (bool) {&#13;
        require(_to != address(0));&#13;
        balances[msg.sender] = balances[msg.sender].sub(_value);&#13;
        balances[_to] = balances[_to].add(_value);&#13;
        emit Transfer(msg.sender, _to, _value);&#13;
        return true;&#13;
    }&#13;
&#13;
    function balanceOf(address _owner) view public returns (uint256 balance) {&#13;
        return balances[_owner];&#13;
    }&#13;
&#13;
    function transferFrom(address _from, address _to, uint256 _value) unlocked public returns (bool) {&#13;
        require(_to != address(0));&#13;
        uint256 _allowance = allowed[_from][msg.sender];&#13;
        balances[_from] = balances[_from].sub(_value);&#13;
        balances[_to] = balances[_to].add(_value);&#13;
        allowed[_from][msg.sender] = _allowance.sub(_value);&#13;
        emit Transfer(_from, _to, _value);&#13;
        return true;&#13;
    }&#13;
&#13;
    function approve(address _spender, uint256 _value) unlocked public returns (bool) {&#13;
        require((_value == 0) || (allowed[msg.sender][_spender] == 0));&#13;
        allowed[msg.sender][_spender] = _value;&#13;
        emit Approval(msg.sender, _spender, _value);&#13;
        return true;&#13;
    }&#13;
&#13;
    function allowance(address _owner, address _spender) view public returns (uint256 remaining) {&#13;
        return allowed[_owner][_spender];&#13;
    }&#13;
&#13;
    function increaseApproval (address _spender, uint _addedValue) unlocked public&#13;
        returns (bool success) {&#13;
            allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);&#13;
            emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);&#13;
            return true;&#13;
    }&#13;
&#13;
    function decreaseApproval (address _spender, uint _subtractedValue) unlocked public&#13;
        returns (bool success) {&#13;
            uint oldValue = allowed[msg.sender][_spender];&#13;
            if (_subtractedValue &gt; oldValue) {&#13;
            allowed[msg.sender][_spender] = 0;&#13;
            } else {&#13;
            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);&#13;
            }&#13;
            emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);&#13;
            return true;&#13;
    }&#13;
&#13;
    constructor(string _name, string _symbol, uint8 _decimals) public {&#13;
        require(bytes(_name).length &gt; 1);&#13;
        require(bytes(_symbol).length &gt; 1);&#13;
        name = _name;&#13;
        symbol = _symbol;&#13;
        decimals = _decimals;&#13;
    }&#13;
&#13;
    function setNameAndTicker(string _name, string _symbol) onlyOwner public returns (bool success) {&#13;
        require(bytes(_name).length &gt; 1);&#13;
        require(bytes(_symbol).length &gt; 1);&#13;
        name = _name;&#13;
        symbol = _symbol;&#13;
        return true;&#13;
    }&#13;
&#13;
    function setLock(bool _newLockState) ownerOrCrowdsale public returns (bool success) {&#13;
        require(_newLockState != locked);&#13;
        locked = _newLockState;&#13;
        return true;&#13;
    }&#13;
&#13;
    function disableMinting() ownerOrCrowdsale public returns (bool success) {&#13;
        require(mintingAllowed);&#13;
        mintingAllowed = false;&#13;
        return true;&#13;
    }&#13;
&#13;
    function setCrowdsale(address _newCrowdsale) onlyOwner public returns (bool success) {&#13;
        crowdsaleContractAddress = _newCrowdsale;&#13;
        return true;&#13;
    }&#13;
&#13;
    function setManager(address _newManager) onlyOwner public returns (bool success) {&#13;
        crowdsaleManager = _newManager;&#13;
        return true;&#13;
    }&#13;
&#13;
    function mint(address _for, uint256 _amount) onlyCrowdsale public returns (bool success) {&#13;
        require(mintingAllowed);&#13;
        balances[_for] = balances[_for].add(_amount);&#13;
        totalSupply = totalSupply.add(_amount);&#13;
        emit Transfer(0, _for, _amount);&#13;
        return true;&#13;
    }&#13;
&#13;
    function demint(address _for, uint256 _amount) onlyCrowdsale public returns (bool success) {&#13;
        require(mintingAllowed);&#13;
        balances[_for] = balances[_for].sub(_amount);&#13;
        totalSupply = totalSupply.sub(_amount);&#13;
        emit Transfer(_for, 0, _amount);&#13;
        return true;&#13;
    }&#13;
&#13;
    function allowUpgrading(bool _newState) onlyOwner public returns (bool success) {&#13;
        upgradable = _newState;&#13;
        return true;&#13;
    }&#13;
&#13;
    function setUpgrader(address _upgraderAddress) onlyOwner public returns (bool success) {&#13;
        require(!upgraderSet);&#13;
        require(_upgraderAddress != address(0));&#13;
        upgraderSet = true;&#13;
        upgrader = TokenUpgraderInterface(_upgraderAddress);&#13;
        return true;&#13;
    }&#13;
&#13;
    function upgrade() public returns (bool success) {&#13;
        require(upgradable);&#13;
        require(upgraderSet);&#13;
        require(upgrader != TokenUpgraderInterface(0));&#13;
        uint256 value = balances[msg.sender];&#13;
        assert(value &gt; 0);&#13;
        delete balances[msg.sender];&#13;
        totalSupply = totalSupply.sub(value);&#13;
        assert(upgrader.upgradeFor(msg.sender, value));&#13;
        return true;&#13;
    }&#13;
&#13;
    function upgradeFor(address _for, uint256 _value) public returns (bool success) {&#13;
        require(upgradable);&#13;
        require(upgraderSet);&#13;
        require(upgrader != TokenUpgraderInterface(0));&#13;
        uint256 _allowance = allowed[_for][msg.sender];&#13;
        require(_allowance &gt; 0);&#13;
        require(_allowance &gt;= _value);&#13;
        balances[_for] = balances[_for].sub(_value);&#13;
        allowed[_for][msg.sender] = _allowance.sub(_value);&#13;
        totalSupply = totalSupply.sub(_value);&#13;
        assert(upgrader.upgradeFrom(msg.sender, _for, _value));&#13;
        return true;&#13;
    }&#13;
&#13;
    function () payable external {&#13;
        if (upgradable) {&#13;
            assert(upgrade());&#13;
            return;&#13;
        }&#13;
        revert();&#13;
    }&#13;
&#13;
}