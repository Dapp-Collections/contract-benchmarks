pragma solidity	^0.4.18;
//
// FogLink OS Token
// Author: FNK
// Contact: <span class="__cf_email__" data-cfemail="cdbeb8bdbda2bfb98daba2aaa1a4a3a6e3a4a2">[emailÂ protected]</span>&#13;
// Telegram	community: https://t.me/fnkofficial&#13;
//&#13;
contract FNKOSToken {	&#13;
	string public constant name			= "FNKOSToken";&#13;
	string public constant symbol		= "FNKOS";&#13;
	uint public	constant decimals		= 18;&#13;
	&#13;
	uint256 fnkEthRate					= 10 ** decimals;&#13;
	uint256	fnkSupply					= 500000000;&#13;
	uint256	public totalSupply			= fnkSupply * fnkEthRate;&#13;
    uint256 public minInvEth			= 0.1 ether;&#13;
	uint256	public maxInvEth			= 5.0 ether;&#13;
    uint256 public sellStartTime		= 1521129600;			// 2018/3/16&#13;
    uint256 public sellDeadline1		= sellStartTime + 5 days;&#13;
    uint256 public sellDeadline2		= sellDeadline1 + 5 days;&#13;
	uint256 public freezeDuration 		= 30 days;&#13;
	uint256	public ethFnkRate1			= 6000;&#13;
	uint256	public ethFnkRate2			= 6000;&#13;
&#13;
	bool public	running					= true;&#13;
	bool public	buyable					= true;&#13;
	&#13;
	address	owner;&#13;
	mapping	(address =&gt;	mapping	(address =&gt;	uint256)) allowed;&#13;
	mapping	(address =&gt;	bool) public whitelist;&#13;
	mapping	(address =&gt;	 uint256) whitelistLimit;&#13;
&#13;
    struct BalanceInfo {&#13;
        uint256 balance;&#13;
        uint256[] freezeAmount;&#13;
        uint256[] releaseTime;&#13;
    }&#13;
	mapping	(address =&gt;	BalanceInfo) balances;&#13;
	&#13;
	event Transfer(address indexed _from, address indexed _to, uint256 _value);&#13;
	event Approval(address indexed _owner, address indexed _spender, uint256 _value);&#13;
	event BeginRunning();&#13;
	event PauseRunning();&#13;
	event BeginSell();&#13;
	event PauseSell();&#13;
	event Burn(address indexed burner, uint256 val);&#13;
    event Freeze(address indexed from, uint256 value);&#13;
 	&#13;
	function FNKOSToken () public{&#13;
		owner =	msg.sender;&#13;
        balances[owner].balance = totalSupply;&#13;
	}&#13;
	&#13;
	modifier onlyOwner() {&#13;
		require(msg.sender == owner);&#13;
		_;&#13;
	}&#13;
	&#13;
	modifier onlyWhitelist() {&#13;
		require(whitelist[msg.sender] == true);&#13;
		_;&#13;
	}&#13;
	&#13;
	modifier isRunning(){&#13;
		require(running);&#13;
		_;&#13;
	}&#13;
	modifier isNotRunning(){&#13;
		require(!running);&#13;
		_;&#13;
	}&#13;
	modifier isBuyable(){&#13;
		require(buyable &amp;&amp; now &gt;= sellStartTime &amp;&amp; now &lt;= sellDeadline2);&#13;
		_;&#13;
	}&#13;
	modifier isNotBuyable(){&#13;
		require(!buyable || now &lt; sellStartTime || now &gt; sellDeadline2);&#13;
		_;&#13;
	}&#13;
	// mitigates the ERC20 short address attack&#13;
	modifier onlyPayloadSize(uint size)	{&#13;
		assert(msg.data.length &gt;= size + 4);&#13;
		_;&#13;
	}&#13;
&#13;
	function safeMul(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
		uint256	c =	a *	b;&#13;
		assert(a ==	0 || c / a == b);&#13;
		return c;&#13;
	}&#13;
&#13;
	function safeSub(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
		assert(b &lt;=	a);&#13;
		return a - b;&#13;
	}&#13;
&#13;
	function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
		uint256	c =	a +	b;&#13;
		assert(c &gt;=	a);&#13;
		return c;&#13;
	}&#13;
&#13;
	// 1eth = newRate tokens&#13;
	function setPbulicOfferingPrice(uint256 _rate1, uint256 _rate2) onlyOwner public {&#13;
		ethFnkRate1 = _rate1;&#13;
		ethFnkRate2 = _rate2;		&#13;
	}&#13;
&#13;
	//&#13;
	function setPublicOfferingLimit(uint256 _minVal, uint256 _maxVal) onlyOwner public {&#13;
		minInvEth	= _minVal;&#13;
		maxInvEth	= _maxVal;&#13;
	}&#13;
	&#13;
	function setPublicOfferingDate(uint256 _startTime, uint256 _deadLine1, uint256 _deadLine2) onlyOwner public {&#13;
		sellStartTime = _startTime;&#13;
		sellDeadline1	= _deadLine1;&#13;
		sellDeadline2	= _deadLine2;&#13;
	}&#13;
		&#13;
	function transferOwnership(address _newOwner) onlyOwner public {&#13;
		if (_newOwner !=	address(0))	{&#13;
			owner =	_newOwner;&#13;
		}&#13;
	}&#13;
	&#13;
	function pause() onlyOwner isRunning	public	 {&#13;
		running = false;&#13;
		PauseRunning();&#13;
	}&#13;
	&#13;
	function start() onlyOwner isNotRunning	public	 {&#13;
		running = true;&#13;
		BeginRunning();&#13;
	}&#13;
&#13;
	function pauseSell() onlyOwner	isBuyable isRunning public{&#13;
		buyable = false;&#13;
		PauseSell();&#13;
	}&#13;
	&#13;
	function beginSell() onlyOwner	isNotBuyable isRunning  public{&#13;
		buyable = true;&#13;
		BeginSell();&#13;
	}&#13;
&#13;
	//&#13;
	// _amount in FNK, &#13;
	//&#13;
	function airDeliver(address _to,	uint256	_amount)  onlyOwner public {&#13;
		require(owner != _to);&#13;
		require(_amount &gt; 0);&#13;
		require(balances[owner].balance &gt;= _amount);&#13;
		&#13;
		// take big number as wei&#13;
		if(_amount &lt; fnkSupply){&#13;
			_amount = _amount * fnkEthRate;&#13;
		}&#13;
		balances[owner].balance = safeSub(balances[owner].balance, _amount);&#13;
		balances[_to].balance =	safeAdd(balances[_to].balance, _amount);&#13;
		Transfer(owner, _to, _amount);&#13;
	}&#13;
	&#13;
	&#13;
	function airDeliverMulti(address[]	_addrs, uint256 _amount) onlyOwner public {&#13;
		require(_addrs.length &lt;=  255);&#13;
		&#13;
		for	(uint8 i = 0; i &lt; _addrs.length; i++)	{&#13;
			airDeliver(_addrs[i],	_amount);&#13;
		}&#13;
	}&#13;
	&#13;
	function airDeliverStandalone(address[] _addrs,	uint256[] _amounts) onlyOwner public {&#13;
		require(_addrs.length &lt;=  255);&#13;
		require(_addrs.length ==	 _amounts.length);&#13;
		&#13;
		for	(uint8 i = 0; i	&lt; _addrs.length;	i++) {&#13;
			airDeliver(_addrs[i],	_amounts[i]);&#13;
		}&#13;
	}&#13;
&#13;
	//&#13;
	// _amount, _freezeAmount in FNK&#13;
	//&#13;
	function  freezeDeliver(address _to, uint _amount, uint _freezeAmount, uint _freezeMonth, uint _unfreezeBeginTime ) onlyOwner public {&#13;
		require(owner != _to);&#13;
		require(_freezeMonth &gt; 0);&#13;
		&#13;
		uint average = _freezeAmount / _freezeMonth;&#13;
		BalanceInfo storage bi = balances[_to];&#13;
		uint[] memory fa = new uint[](_freezeMonth);&#13;
		uint[] memory rt = new uint[](_freezeMonth);&#13;
&#13;
		if(_amount &lt; fnkSupply){&#13;
			_amount = _amount * fnkEthRate;&#13;
			average = average * fnkEthRate;&#13;
			_freezeAmount = _freezeAmount * fnkEthRate;&#13;
		}&#13;
		require(balances[owner].balance &gt; _amount);&#13;
		uint remainAmount = _freezeAmount;&#13;
		&#13;
		if(_unfreezeBeginTime == 0)&#13;
			_unfreezeBeginTime = now + freezeDuration;&#13;
		for(uint i=0;i&lt;_freezeMonth-1;i++){&#13;
			fa[i] = average;&#13;
			rt[i] = _unfreezeBeginTime;&#13;
			_unfreezeBeginTime += freezeDuration;&#13;
			remainAmount = safeSub(remainAmount, average);&#13;
		}&#13;
		fa[i] = remainAmount;&#13;
		rt[i] = _unfreezeBeginTime;&#13;
		&#13;
		bi.balance = safeAdd(bi.balance, _amount);&#13;
		bi.freezeAmount = fa;&#13;
		bi.releaseTime = rt;&#13;
		balances[owner].balance = safeSub(balances[owner].balance, _amount);&#13;
		Transfer(owner, _to, _amount);&#13;
		Freeze(_to, _freezeAmount);&#13;
	}&#13;
	&#13;
	function  freezeDeliverMuti(address[] _addrs, uint _deliverAmount, uint _freezeAmount, uint _freezeMonth, uint _unfreezeBeginTime ) onlyOwner public {&#13;
		require(_addrs.length &lt;=  255);&#13;
		&#13;
		for(uint i=0;i&lt; _addrs.length;i++){&#13;
			freezeDeliver(_addrs[i], _deliverAmount, _freezeAmount, _freezeMonth, _unfreezeBeginTime);&#13;
		}&#13;
	}&#13;
&#13;
	function  freezeDeliverMultiStandalone(address[] _addrs, uint[] _deliverAmounts, uint[] _freezeAmounts, uint _freezeMonth, uint _unfreezeBeginTime ) onlyOwner public {&#13;
		require(_addrs.length &lt;=  255);&#13;
		require(_addrs.length == _deliverAmounts.length);&#13;
		require(_addrs.length == _freezeAmounts.length);&#13;
		&#13;
		for(uint i=0;i&lt; _addrs.length;i++){&#13;
			freezeDeliver(_addrs[i], _deliverAmounts[i], _freezeAmounts[i], _freezeMonth, _unfreezeBeginTime);&#13;
		}&#13;
	}&#13;
	&#13;
	// buy tokens directly&#13;
	function ()	external payable {&#13;
		buyTokens();&#13;
	}&#13;
&#13;
	//&#13;
	function buyTokens() payable isRunning isBuyable onlyWhitelist	public {&#13;
        uint256 weiVal = msg.value;&#13;
		address	investor	= msg.sender;&#13;
        require(investor != address(0) &amp;&amp; weiVal &gt;= minInvEth &amp;&amp; weiVal &lt;= maxInvEth);&#13;
		require(safeAdd(weiVal,whitelistLimit[investor]) &lt;= maxInvEth);&#13;
		&#13;
		uint256	amount = 0;&#13;
		if(now &gt; sellDeadline1)&#13;
			amount = safeMul(msg.value, ethFnkRate2);&#13;
		else&#13;
			amount = safeMul(msg.value, ethFnkRate1);	&#13;
&#13;
		whitelistLimit[investor] = safeAdd(weiVal, whitelistLimit[investor]);&#13;
		airDeliver(investor, amount);		&#13;
	}&#13;
&#13;
	function addWhitelist(address[] _addrs) public onlyOwner {&#13;
		require(_addrs.length &lt;=  255);&#13;
&#13;
		for (uint8 i = 0; i &lt; _addrs.length; i++) {&#13;
			if (!whitelist[_addrs[i]]){&#13;
				whitelist[_addrs[i]] = true;&#13;
			}&#13;
		}&#13;
	}&#13;
&#13;
	function balanceOf(address _owner) constant	public returns (uint256) {&#13;
		return balances[_owner].balance;&#13;
	}&#13;
	&#13;
	function freezeOf(address _owner) constant	public returns (uint256) {&#13;
        BalanceInfo storage bi = balances[_owner];&#13;
	    uint freezeAmount = 0;&#13;
		uint t = now;&#13;
		&#13;
        for(uint i=0;i&lt; bi.freezeAmount.length;i++){&#13;
			if(t &lt; bi.releaseTime[i])&#13;
            	freezeAmount += bi.freezeAmount[i];&#13;
        }&#13;
        return freezeAmount;&#13;
	}&#13;
	&#13;
	function transfer(address _to, uint256 _amount)	 isRunning onlyPayloadSize(2 *	32)	public returns (bool success) {&#13;
		require(_to	!= address(0));&#13;
		uint freezeAmount = freezeOf(msg.sender);&#13;
		uint256 _balance = safeSub(balances[msg.sender].balance, freezeAmount);&#13;
		require(_amount	&lt;= _balance);&#13;
		&#13;
		balances[msg.sender].balance = safeSub(balances[msg.sender].balance,_amount);&#13;
		balances[_to].balance =	safeAdd(balances[_to].balance,_amount);&#13;
		Transfer(msg.sender, _to, _amount);&#13;
		return true;&#13;
	}&#13;
	&#13;
	function transferFrom(address _from, address _to, uint256 _amount) isRunning onlyPayloadSize(3 * 32) public returns (bool	success) {&#13;
		require(_to	!= address(0));&#13;
		require(_amount	&lt;= balances[_from].balance);&#13;
		require(_amount	&lt;= allowed[_from][msg.sender]);&#13;
		&#13;
		balances[_from].balance	= safeSub(balances[_from].balance,_amount);&#13;
		allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender],_amount);&#13;
		balances[_to].balance =	safeAdd(balances[_to].balance,_amount);&#13;
		Transfer(_from,	_to, _amount);&#13;
		return true;&#13;
	}&#13;
	&#13;
	function approve(address _spender, uint256 _value) isRunning public returns (bool	success) {&#13;
		if (_value != 0	&amp;&amp; allowed[msg.sender][_spender] !=	0) { &#13;
			return	false; &#13;
		}&#13;
		allowed[msg.sender][_spender] =	_value;&#13;
		Approval(msg.sender, _spender, _value);&#13;
		return true;&#13;
	}&#13;
	&#13;
	function allowance(address _owner, address _spender) constant public returns (uint256) {&#13;
		return allowed[_owner][_spender];&#13;
	}&#13;
	&#13;
	function withdraw()	onlyOwner public {&#13;
        require(this.balance &gt; 0);&#13;
        owner.transfer(this.balance);&#13;
		Transfer(this, owner, this.balance);	&#13;
	}&#13;
	&#13;
	function burn(uint256 _value) onlyOwner	public {&#13;
		require(_value &lt;= balances[msg.sender].balance);&#13;
&#13;
		address	burner = msg.sender;&#13;
		balances[burner].balance = safeSub(balances[burner].balance, _value);&#13;
		totalSupply	= safeSub(totalSupply, _value);&#13;
		fnkSupply = totalSupply / fnkEthRate;&#13;
		Burn(burner, _value);&#13;
	}&#13;
	&#13;
	function mint(address _target, uint256 _amount) onlyOwner public {&#13;
		if(_target	== address(0))&#13;
			_target = owner;&#13;
		&#13;
		balances[_target].balance = safeAdd(balances[_target].balance, _amount);&#13;
		totalSupply = safeAdd(totalSupply,_amount);&#13;
		Transfer(0, this, _amount);&#13;
		Transfer(this, _target, _amount);&#13;
	}&#13;
}