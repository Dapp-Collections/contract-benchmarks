pragma solidity ^0.4.24;
// Developed by Phenom.Team <<span class="__cf_email__" data-cfemail="1d74737b725d6d75787372703369787c70">[emailÂ protected]</span>&gt;&#13;
&#13;
/**&#13;
 * @title SafeMath&#13;
 * @dev Math operations with safety checks that throw on error&#13;
 */&#13;
library SafeMath {&#13;
&#13;
    /**&#13;
    * @dev Multiplies two numbers, throws on overflow.&#13;
    */&#13;
    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {&#13;
        // Gas optimization: this is cheaper than asserting 'a' not being zero, but the&#13;
        // benefit is lost if 'b' is also tested.&#13;
        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522&#13;
        if (a == 0) {&#13;
            return 0;&#13;
        }&#13;
&#13;
        c = a * b;&#13;
        assert(c / a == b);&#13;
        return c;&#13;
    }&#13;
&#13;
    /**&#13;
    * @dev Integer division of two numbers, truncating the quotient.&#13;
    */&#13;
    function div(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
        // assert(b &gt; 0); // Solidity automatically throws when dividing by 0&#13;
        // uint256 c = a / b;&#13;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold&#13;
        return a / b;&#13;
    }&#13;
&#13;
    /**&#13;
    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).&#13;
    */&#13;
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
        assert(b &lt;= a);&#13;
        return a - b;&#13;
    }&#13;
&#13;
    /**&#13;
    * @dev Adds two numbers, throws on overflow.&#13;
    */&#13;
    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {&#13;
        c = a + b;&#13;
        assert(c &gt;= a);&#13;
        return c;&#13;
    }&#13;
}&#13;
&#13;
contract ERC20 {&#13;
    uint public totalSupply;&#13;
&#13;
    mapping(address =&gt; uint) balances;&#13;
    mapping(address =&gt; mapping (address =&gt; uint)) allowed;&#13;
&#13;
    function balanceOf(address _owner) view returns (uint);&#13;
    function transfer(address _to, uint _value) returns (bool);&#13;
    function transferFrom(address _from, address _to, uint _value) returns (bool);&#13;
    function approve(address _spender, uint _value) returns (bool);&#13;
    function allowance(address _owner, address _spender) view returns (uint);&#13;
&#13;
    event Transfer(address indexed _from, address indexed _to, uint _value);&#13;
    event Approval(address indexed _owner, address indexed _spender, uint _value);&#13;
&#13;
}&#13;
&#13;
contract Ownable {&#13;
    address public owner;&#13;
&#13;
    constructor() public {&#13;
        owner = tx.origin;&#13;
    }&#13;
&#13;
    modifier onlyOwner() {&#13;
        require(msg.sender == owner, 'ownership is required');&#13;
        _;&#13;
    }&#13;
}&#13;
&#13;
contract BaseTokenVesting is Ownable() {&#13;
    using SafeMath for uint;&#13;
&#13;
    address public beneficiary;&#13;
    ERC20 public token;&#13;
&#13;
    bool public vestingHasStarted;&#13;
    uint public start;&#13;
    uint public cliff;&#13;
    uint public vestingPeriod;&#13;
&#13;
    uint public released;&#13;
&#13;
    event Released(uint _amount);&#13;
&#13;
    constructor(&#13;
		address _benificiary,&#13;
		uint _cliff,&#13;
		uint _vestingPeriod,&#13;
		address _token&#13;
	) internal &#13;
	{&#13;
        require(_benificiary != address(0), 'can not send to zero-address');&#13;
&#13;
        beneficiary = _benificiary;&#13;
        cliff = _cliff;&#13;
        vestingPeriod = _vestingPeriod;&#13;
        token = ERC20(_token);&#13;
    }&#13;
&#13;
    function startVesting() public onlyOwner {&#13;
        vestingHasStarted = true;&#13;
        start = now;&#13;
        cliff = cliff.add(start);&#13;
    }&#13;
&#13;
    function sendTokens(address _to, uint _amount) public onlyOwner {&#13;
        require(vestingHasStarted == false, 'send tokens only if vesting has not been started');&#13;
        require(token.transfer(_to, _amount), 'token.transfer has failed');&#13;
    }&#13;
&#13;
    function release() public;&#13;
&#13;
    function releasableAmount() public view returns (uint _amount);&#13;
&#13;
    function vestedAmount() public view returns (uint _amount);&#13;
}&#13;
contract TokenVestingWithFloatingPercent is BaseTokenVesting {&#13;
	&#13;
    uint[] public periodPercents;&#13;
&#13;
    constructor(&#13;
        address _benificiary,&#13;
        uint _cliff,&#13;
        uint _vestingPeriod,&#13;
        address _tokenAddress,&#13;
        uint[] _periodPercents&#13;
    ) &#13;
        BaseTokenVesting(_benificiary, _cliff, _vestingPeriod, _tokenAddress)&#13;
        public &#13;
    {&#13;
        uint sum = 0;&#13;
        for (uint i = 0; i &lt; _periodPercents.length; i++) {&#13;
            sum = sum.add(_periodPercents[i]);&#13;
        }&#13;
        require(sum == 100, 'percentage sum must be equal to 100');&#13;
&#13;
        periodPercents = _periodPercents;&#13;
    }&#13;
&#13;
    function release() public {&#13;
        require(vestingHasStarted, 'vesting has not started');&#13;
        uint unreleased = releasableAmount();&#13;
&#13;
        require(unreleased &gt; 0, 'released amount has to be greter than zero');&#13;
        require(token.transfer(beneficiary, unreleased), 'revert on transfer failure');&#13;
        released = released.add(unreleased);&#13;
        emit Released(unreleased);	&#13;
    }&#13;
&#13;
    function releasableAmount() public view returns (uint _amount) {&#13;
        _amount = vestedAmount().sub(released);&#13;
    }&#13;
&#13;
    function vestedAmount() public view returns (uint _amount) {&#13;
        uint currentBalance = token.balanceOf(this);&#13;
        uint totalBalance = currentBalance.add(released);&#13;
&#13;
        if (now &lt; cliff || !vestingHasStarted) {&#13;
            _amount = 0;&#13;
        }&#13;
        else {&#13;
            uint _periodPercentsIndex = now.sub(cliff).div(vestingPeriod);&#13;
            if (_periodPercentsIndex &gt; periodPercents.length.sub(1)) {&#13;
                _amount = totalBalance;&#13;
            }&#13;
            else {&#13;
                if (_periodPercentsIndex &gt;= 1) {&#13;
                    uint totalPercent = 0;&#13;
                    for (uint i = 0; i &lt; _periodPercentsIndex - 1; i++) {&#13;
                        totalPercent = totalPercent + periodPercents[i];&#13;
                    }&#13;
                    _amount = totalBalance.mul(totalPercent).div(100);&#13;
                }&#13;
            }&#13;
        }&#13;
    }&#13;
&#13;
}