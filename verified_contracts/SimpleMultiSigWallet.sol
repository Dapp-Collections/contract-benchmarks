pragma solidity 0.4.15;

// Code taken from https://github.com/ethereum/dapp-bin/blob/master/wallet/wallet.sol
// Audit, refactoring and improvements by github.com/Eenae

// @authors:
// Gav Wood <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="15725570617d7170633b767a78">[emailÂ protected]</a>&gt;&#13;
// inheritable "property" contract that enables methods to be protected by requiring the acquiescence of either a&#13;
// single, or, crucially, each of a number of, designated owners.&#13;
// usage:&#13;
// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by&#13;
// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the&#13;
// interior is executed.&#13;
&#13;
&#13;
/// note: during any ownership changes all pending operations (waiting for more signatures) are cancelled&#13;
// TODO acceptOwnership&#13;
contract multiowned {&#13;
&#13;
	// TYPES&#13;
&#13;
    // struct for the status of a pending operation.&#13;
    struct MultiOwnedOperationPendingState {&#13;
        // count of confirmations needed&#13;
        uint yetNeeded;&#13;
&#13;
        // bitmap of confirmations where owner #ownerIndex's decision corresponds to 2**ownerIndex bit&#13;
        uint ownersDone;&#13;
&#13;
        // position of this operation key in m_multiOwnedPendingIndex&#13;
        uint index;&#13;
    }&#13;
&#13;
	// EVENTS&#13;
&#13;
    event Confirmation(address owner, bytes32 operation);&#13;
    event Revoke(address owner, bytes32 operation);&#13;
    event FinalConfirmation(address owner, bytes32 operation);&#13;
&#13;
    // some others are in the case of an owner changing.&#13;
    event OwnerChanged(address oldOwner, address newOwner);&#13;
    event OwnerAdded(address newOwner);&#13;
    event OwnerRemoved(address oldOwner);&#13;
&#13;
    // the last one is emitted if the required signatures change&#13;
    event RequirementChanged(uint newRequirement);&#13;
&#13;
	// MODIFIERS&#13;
&#13;
    // simple single-sig function modifier.&#13;
    modifier onlyowner {&#13;
        require(isOwner(msg.sender));&#13;
        _;&#13;
    }&#13;
    // multi-sig function modifier: the operation must have an intrinsic hash in order&#13;
    // that later attempts can be realised as the same underlying operation and&#13;
    // thus count as confirmations.&#13;
    modifier onlymanyowners(bytes32 _operation) {&#13;
        if (confirmAndCheck(_operation)) {&#13;
            _;&#13;
        }&#13;
        // Even if required number of confirmations has't been collected yet,&#13;
        // we can't throw here - because changes to the state have to be preserved.&#13;
        // But, confirmAndCheck itself will throw in case sender is not an owner.&#13;
    }&#13;
&#13;
    modifier validNumOwners(uint _numOwners) {&#13;
        require(_numOwners &gt; 0 &amp;&amp; _numOwners &lt;= c_maxOwners);&#13;
        _;&#13;
    }&#13;
&#13;
    modifier multiOwnedValidRequirement(uint _required, uint _numOwners) {&#13;
        require(_required &gt; 0 &amp;&amp; _required &lt;= _numOwners);&#13;
        _;&#13;
    }&#13;
&#13;
    modifier ownerExists(address _address) {&#13;
        require(isOwner(_address));&#13;
        _;&#13;
    }&#13;
&#13;
    modifier ownerDoesNotExist(address _address) {&#13;
        require(!isOwner(_address));&#13;
        _;&#13;
    }&#13;
&#13;
    modifier multiOwnedOperationIsActive(bytes32 _operation) {&#13;
        require(isOperationActive(_operation));&#13;
        _;&#13;
    }&#13;
&#13;
	// METHODS&#13;
&#13;
    // constructor is given number of sigs required to do protected "onlymanyowners" transactions&#13;
    // as well as the selection of addresses capable of confirming them (msg.sender is not added to the owners!).&#13;
    function multiowned(address[] _owners, uint _required)&#13;
        validNumOwners(_owners.length)&#13;
        multiOwnedValidRequirement(_required, _owners.length)&#13;
    {&#13;
        assert(c_maxOwners &lt;= 255);&#13;
&#13;
        m_numOwners = _owners.length;&#13;
        m_multiOwnedRequired = _required;&#13;
&#13;
        for (uint i = 0; i &lt; _owners.length; ++i)&#13;
        {&#13;
            address owner = _owners[i];&#13;
            // invalid and duplicate addresses are not allowed&#13;
            require(0 != owner &amp;&amp; !isOwner(owner) /* not isOwner yet! */);&#13;
&#13;
            uint currentOwnerIndex = checkOwnerIndex(i + 1 /* first slot is unused */);&#13;
            m_owners[currentOwnerIndex] = owner;&#13;
            m_ownerIndex[owner] = currentOwnerIndex;&#13;
        }&#13;
&#13;
        assertOwnersAreConsistent();&#13;
    }&#13;
&#13;
    /// @notice replaces an owner `_from` with another `_to`.&#13;
    /// @param _from address of owner to replace&#13;
    /// @param _to address of new owner&#13;
    // All pending operations will be canceled!&#13;
    function changeOwner(address _from, address _to)&#13;
        external&#13;
        ownerExists(_from)&#13;
        ownerDoesNotExist(_to)&#13;
        onlymanyowners(sha3(msg.data))&#13;
    {&#13;
        assertOwnersAreConsistent();&#13;
&#13;
        clearPending();&#13;
        uint ownerIndex = checkOwnerIndex(m_ownerIndex[_from]);&#13;
        m_owners[ownerIndex] = _to;&#13;
        m_ownerIndex[_from] = 0;&#13;
        m_ownerIndex[_to] = ownerIndex;&#13;
&#13;
        assertOwnersAreConsistent();&#13;
        OwnerChanged(_from, _to);&#13;
    }&#13;
&#13;
    /// @notice adds an owner&#13;
    /// @param _owner address of new owner&#13;
    // All pending operations will be canceled!&#13;
    function addOwner(address _owner)&#13;
        external&#13;
        ownerDoesNotExist(_owner)&#13;
        validNumOwners(m_numOwners + 1)&#13;
        onlymanyowners(sha3(msg.data))&#13;
    {&#13;
        assertOwnersAreConsistent();&#13;
&#13;
        clearPending();&#13;
        m_numOwners++;&#13;
        m_owners[m_numOwners] = _owner;&#13;
        m_ownerIndex[_owner] = checkOwnerIndex(m_numOwners);&#13;
&#13;
        assertOwnersAreConsistent();&#13;
        OwnerAdded(_owner);&#13;
    }&#13;
&#13;
    /// @notice removes an owner&#13;
    /// @param _owner address of owner to remove&#13;
    // All pending operations will be canceled!&#13;
    function removeOwner(address _owner)&#13;
        external&#13;
        ownerExists(_owner)&#13;
        validNumOwners(m_numOwners - 1)&#13;
        multiOwnedValidRequirement(m_multiOwnedRequired, m_numOwners - 1)&#13;
        onlymanyowners(sha3(msg.data))&#13;
    {&#13;
        assertOwnersAreConsistent();&#13;
&#13;
        clearPending();&#13;
        uint ownerIndex = checkOwnerIndex(m_ownerIndex[_owner]);&#13;
        m_owners[ownerIndex] = 0;&#13;
        m_ownerIndex[_owner] = 0;&#13;
        //make sure m_numOwners is equal to the number of owners and always points to the last owner&#13;
        reorganizeOwners();&#13;
&#13;
        assertOwnersAreConsistent();&#13;
        OwnerRemoved(_owner);&#13;
    }&#13;
&#13;
    /// @notice changes the required number of owner signatures&#13;
    /// @param _newRequired new number of signatures required&#13;
    // All pending operations will be canceled!&#13;
    function changeRequirement(uint _newRequired)&#13;
        external&#13;
        multiOwnedValidRequirement(_newRequired, m_numOwners)&#13;
        onlymanyowners(sha3(msg.data))&#13;
    {&#13;
        m_multiOwnedRequired = _newRequired;&#13;
        clearPending();&#13;
        RequirementChanged(_newRequired);&#13;
    }&#13;
&#13;
    /// @notice Gets an owner by 0-indexed position&#13;
    /// @param ownerIndex 0-indexed owner position&#13;
    function getOwner(uint ownerIndex) public constant returns (address) {&#13;
        return m_owners[ownerIndex + 1];&#13;
    }&#13;
&#13;
    /// @notice Gets owners&#13;
    /// @return memory array of owners&#13;
    function getOwners() public constant returns (address[]) {&#13;
        address[] memory result = new address[](m_numOwners);&#13;
        for (uint i = 0; i &lt; m_numOwners; i++)&#13;
            result[i] = getOwner(i);&#13;
&#13;
        return result;&#13;
    }&#13;
&#13;
    /// @notice checks if provided address is an owner address&#13;
    /// @param _addr address to check&#13;
    /// @return true if it's an owner&#13;
    function isOwner(address _addr) public constant returns (bool) {&#13;
        return m_ownerIndex[_addr] &gt; 0;&#13;
    }&#13;
&#13;
    /// @notice Tests ownership of the current caller.&#13;
    /// @return true if it's an owner&#13;
    // It's advisable to call it by new owner to make sure that the same erroneous address is not copy-pasted to&#13;
    // addOwner/changeOwner and to isOwner.&#13;
    function amIOwner() external constant onlyowner returns (bool) {&#13;
        return true;&#13;
    }&#13;
&#13;
    /// @notice Revokes a prior confirmation of the given operation&#13;
    /// @param _operation operation value, typically sha3(msg.data)&#13;
    function revoke(bytes32 _operation)&#13;
        external&#13;
        multiOwnedOperationIsActive(_operation)&#13;
        onlyowner&#13;
    {&#13;
        uint ownerIndexBit = makeOwnerBitmapBit(msg.sender);&#13;
        var pending = m_multiOwnedPending[_operation];&#13;
        require(pending.ownersDone &amp; ownerIndexBit &gt; 0);&#13;
&#13;
        assertOperationIsConsistent(_operation);&#13;
&#13;
        pending.yetNeeded++;&#13;
        pending.ownersDone -= ownerIndexBit;&#13;
&#13;
        assertOperationIsConsistent(_operation);&#13;
        Revoke(msg.sender, _operation);&#13;
    }&#13;
&#13;
    /// @notice Checks if owner confirmed given operation&#13;
    /// @param _operation operation value, typically sha3(msg.data)&#13;
    /// @param _owner an owner address&#13;
    function hasConfirmed(bytes32 _operation, address _owner)&#13;
        external&#13;
        constant&#13;
        multiOwnedOperationIsActive(_operation)&#13;
        ownerExists(_owner)&#13;
        returns (bool)&#13;
    {&#13;
        return !(m_multiOwnedPending[_operation].ownersDone &amp; makeOwnerBitmapBit(_owner) == 0);&#13;
    }&#13;
&#13;
    // INTERNAL METHODS&#13;
&#13;
    function confirmAndCheck(bytes32 _operation)&#13;
        private&#13;
        onlyowner&#13;
        returns (bool)&#13;
    {&#13;
        if (512 == m_multiOwnedPendingIndex.length)&#13;
            // In case m_multiOwnedPendingIndex grows too much we have to shrink it: otherwise at some point&#13;
            // we won't be able to do it because of block gas limit.&#13;
            // Yes, pending confirmations will be lost. Dont see any security or stability implications.&#13;
            // TODO use more graceful approach like compact or removal of clearPending completely&#13;
            clearPending();&#13;
&#13;
        var pending = m_multiOwnedPending[_operation];&#13;
&#13;
        // if we're not yet working on this operation, switch over and reset the confirmation status.&#13;
        if (! isOperationActive(_operation)) {&#13;
            // reset count of confirmations needed.&#13;
            pending.yetNeeded = m_multiOwnedRequired;&#13;
            // reset which owners have confirmed (none) - set our bitmap to 0.&#13;
            pending.ownersDone = 0;&#13;
            pending.index = m_multiOwnedPendingIndex.length++;&#13;
            m_multiOwnedPendingIndex[pending.index] = _operation;&#13;
            assertOperationIsConsistent(_operation);&#13;
        }&#13;
&#13;
        // determine the bit to set for this owner.&#13;
        uint ownerIndexBit = makeOwnerBitmapBit(msg.sender);&#13;
        // make sure we (the message sender) haven't confirmed this operation previously.&#13;
        if (pending.ownersDone &amp; ownerIndexBit == 0) {&#13;
            // ok - check if count is enough to go ahead.&#13;
            assert(pending.yetNeeded &gt; 0);&#13;
            if (pending.yetNeeded == 1) {&#13;
                // enough confirmations: reset and run interior.&#13;
                delete m_multiOwnedPendingIndex[m_multiOwnedPending[_operation].index];&#13;
                delete m_multiOwnedPending[_operation];&#13;
                FinalConfirmation(msg.sender, _operation);&#13;
                return true;&#13;
            }&#13;
            else&#13;
            {&#13;
                // not enough: record that this owner in particular confirmed.&#13;
                pending.yetNeeded--;&#13;
                pending.ownersDone |= ownerIndexBit;&#13;
                assertOperationIsConsistent(_operation);&#13;
                Confirmation(msg.sender, _operation);&#13;
            }&#13;
        }&#13;
    }&#13;
&#13;
    // Reclaims free slots between valid owners in m_owners.&#13;
    // TODO given that its called after each removal, it could be simplified.&#13;
    function reorganizeOwners() private {&#13;
        uint free = 1;&#13;
        while (free &lt; m_numOwners)&#13;
        {&#13;
            // iterating to the first free slot from the beginning&#13;
            while (free &lt; m_numOwners &amp;&amp; m_owners[free] != 0) free++;&#13;
&#13;
            // iterating to the first occupied slot from the end&#13;
            while (m_numOwners &gt; 1 &amp;&amp; m_owners[m_numOwners] == 0) m_numOwners--;&#13;
&#13;
            // swap, if possible, so free slot is located at the end after the swap&#13;
            if (free &lt; m_numOwners &amp;&amp; m_owners[m_numOwners] != 0 &amp;&amp; m_owners[free] == 0)&#13;
            {&#13;
                // owners between swapped slots should't be renumbered - that saves a lot of gas&#13;
                m_owners[free] = m_owners[m_numOwners];&#13;
                m_ownerIndex[m_owners[free]] = free;&#13;
                m_owners[m_numOwners] = 0;&#13;
            }&#13;
        }&#13;
    }&#13;
&#13;
    function clearPending() private onlyowner {&#13;
        uint length = m_multiOwnedPendingIndex.length;&#13;
        for (uint i = 0; i &lt; length; ++i) {&#13;
            if (m_multiOwnedPendingIndex[i] != 0)&#13;
                delete m_multiOwnedPending[m_multiOwnedPendingIndex[i]];&#13;
        }&#13;
        delete m_multiOwnedPendingIndex;&#13;
    }&#13;
&#13;
    function checkOwnerIndex(uint ownerIndex) private constant returns (uint) {&#13;
        assert(0 != ownerIndex &amp;&amp; ownerIndex &lt;= c_maxOwners);&#13;
        return ownerIndex;&#13;
    }&#13;
&#13;
    function makeOwnerBitmapBit(address owner) private constant returns (uint) {&#13;
        uint ownerIndex = checkOwnerIndex(m_ownerIndex[owner]);&#13;
        return 2 ** ownerIndex;&#13;
    }&#13;
&#13;
    function isOperationActive(bytes32 _operation) private constant returns (bool) {&#13;
        return 0 != m_multiOwnedPending[_operation].yetNeeded;&#13;
    }&#13;
&#13;
&#13;
    function assertOwnersAreConsistent() private constant {&#13;
        assert(m_numOwners &gt; 0);&#13;
        assert(m_numOwners &lt;= c_maxOwners);&#13;
        assert(m_owners[0] == 0);&#13;
        assert(0 != m_multiOwnedRequired &amp;&amp; m_multiOwnedRequired &lt;= m_numOwners);&#13;
    }&#13;
&#13;
    function assertOperationIsConsistent(bytes32 _operation) private constant {&#13;
        var pending = m_multiOwnedPending[_operation];&#13;
        assert(0 != pending.yetNeeded);&#13;
        assert(m_multiOwnedPendingIndex[pending.index] == _operation);&#13;
        assert(pending.yetNeeded &lt;= m_multiOwnedRequired);&#13;
    }&#13;
&#13;
&#13;
   	// FIELDS&#13;
&#13;
    uint constant c_maxOwners = 250;&#13;
&#13;
    // the number of owners that must confirm the same operation before it is run.&#13;
    uint public m_multiOwnedRequired;&#13;
&#13;
&#13;
    // pointer used to find a free slot in m_owners&#13;
    uint public m_numOwners;&#13;
&#13;
    // list of owners (addresses),&#13;
    // slot 0 is unused so there are no owner which index is 0.&#13;
    // TODO could we save space at the end of the array for the common case of &lt;10 owners? and should we?&#13;
    address[256] internal m_owners;&#13;
&#13;
    // index on the list of owners to allow reverse lookup: owner address =&gt; index in m_owners&#13;
    mapping(address =&gt; uint) internal m_ownerIndex;&#13;
&#13;
&#13;
    // the ongoing operations.&#13;
    mapping(bytes32 =&gt; MultiOwnedOperationPendingState) internal m_multiOwnedPending;&#13;
    bytes32[] internal m_multiOwnedPendingIndex;&#13;
}&#13;
&#13;
&#13;
/**&#13;
 * @title Basic demonstration of multi-owned entity.&#13;
 */&#13;
contract SimpleMultiSigWallet is multiowned {&#13;
&#13;
    event Deposit(address indexed sender, uint value);&#13;
    event EtherSent(address indexed to, uint value);&#13;
&#13;
    function SimpleMultiSigWallet(address[] _owners, uint _signaturesRequired)&#13;
        multiowned(_owners, _signaturesRequired)&#13;
    {&#13;
    }&#13;
&#13;
    /// @dev Fallback function allows to deposit ether.&#13;
    function()&#13;
        payable&#13;
    {&#13;
        if (msg.value &gt; 0)&#13;
            Deposit(msg.sender, msg.value);&#13;
    }&#13;
&#13;
    /// @notice Send `value` of ether to address `to`&#13;
    /// @param to where to send ether&#13;
    /// @param value amount of wei to send&#13;
    function sendEther(address to, uint value)&#13;
        external&#13;
        onlymanyowners(sha3(msg.data))&#13;
    {&#13;
        require(0 != to);&#13;
        require(value &gt; 0 &amp;&amp; this.balance &gt;= value);&#13;
        to.transfer(value);&#13;
        EtherSent(to, value);&#13;
    }&#13;
}