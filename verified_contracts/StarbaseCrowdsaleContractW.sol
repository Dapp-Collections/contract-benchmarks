pragma solidity ^0.4.13;

/**
 * @title SafeMath
 * @dev Math operations with safety checks that throw on error
 */
library SafeMath {
  function mul(uint256 a, uint256 b) internal constant returns (uint256) {
    uint256 c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }

  function div(uint256 a, uint256 b) internal constant returns (uint256) {
    // assert(b > 0); // Solidity automatically throws when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return c;
  }

  function sub(uint256 a, uint256 b) internal constant returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  function add(uint256 a, uint256 b) internal constant returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }
}

/**
 * @title Ownable
 * @dev The Ownable contract has an owner address, and provides basic authorization control
 * functions, this simplifies the implementation of "user permissions".
 */
contract Ownable {
  address public owner;


  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);


  /**
   * @dev The Ownable constructor sets the original `owner` of the contract to the sender
   * account.
   */
  function Ownable() {
    owner = msg.sender;
  }


  /**
   * @dev Throws if called by any account other than the owner.
   */
  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }


  /**
   * @dev Allows the current owner to transfer control of the contract to a newOwner.
   * @param newOwner The address to transfer ownership to.
   */
  function transferOwnership(address newOwner) onlyOwner public {
    require(newOwner != address(0));
    OwnershipTransferred(owner, newOwner);
    owner = newOwner;
  }

}

contract AbstractStarbaseToken {
    function isFundraiser(address fundraiserAddress) public returns (bool);
    function company() public returns (address);
    function allocateToCrowdsalePurchaser(address to, uint256 value) public returns (bool);
    function allocateToMarketingSupporter(address to, uint256 value) public returns (bool);
}

contract AbstractStarbaseCrowdsale {
    function startDate() constant returns (uint256) {}
    function endedAt() constant returns (uint256) {}
    function isEnded() constant returns (bool);
    function totalRaisedAmountInCny() constant returns (uint256);
    function numOfPurchasedTokensOnCsBy(address purchaser) constant returns (uint256);
    function numOfPurchasedTokensOnEpBy(address purchaser) constant returns (uint256);
}

/// @title EarlyPurchase contract - Keep track of purchased amount by Early Purchasers
/// @author Starbase PTE. LTD. - <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="bdd4d3dbd2fdcec9dccfdfdcced893ded2">[email protected]</a>&gt;&#13;
contract StarbaseEarlyPurchase {&#13;
    /*&#13;
     *  Constants&#13;
     */&#13;
    string public constant PURCHASE_AMOUNT_UNIT = 'CNY';    // Chinese Yuan&#13;
    string public constant PURCHASE_AMOUNT_RATE_REFERENCE = 'http://www.xe.com/currencytables/';&#13;
    uint256 public constant PURCHASE_AMOUNT_CAP = 9000000;&#13;
&#13;
    /*&#13;
     *  Types&#13;
     */&#13;
    struct EarlyPurchase {&#13;
        address purchaser;&#13;
        uint256 amount;        // CNY based amount&#13;
        uint256 purchasedAt;   // timestamp&#13;
    }&#13;
&#13;
    /*&#13;
     *  External contracts&#13;
     */&#13;
    AbstractStarbaseCrowdsale public starbaseCrowdsale;&#13;
&#13;
    /*&#13;
     *  Storage&#13;
     */&#13;
    address public owner;&#13;
    EarlyPurchase[] public earlyPurchases;&#13;
    uint256 public earlyPurchaseClosedAt;&#13;
&#13;
    /*&#13;
     *  Modifiers&#13;
     */&#13;
    modifier noEther() {&#13;
        require(msg.value == 0);&#13;
        _;&#13;
    }&#13;
&#13;
    modifier onlyOwner() {&#13;
        require(msg.sender == owner);&#13;
        _;&#13;
    }&#13;
&#13;
    modifier onlyBeforeCrowdsale() {&#13;
        assert(address(starbaseCrowdsale) == address(0) || starbaseCrowdsale.startDate() == 0);&#13;
        _;&#13;
    }&#13;
&#13;
    modifier onlyEarlyPurchaseTerm() {&#13;
        assert(earlyPurchaseClosedAt &lt;= 0);&#13;
        _;&#13;
    }&#13;
&#13;
    /*&#13;
     *  Contract functions&#13;
     */&#13;
&#13;
    /**&#13;
     * @dev Returns early purchased amount by purchaser's address&#13;
     * @param purchaser Purchaser address&#13;
     */&#13;
    function purchasedAmountBy(address purchaser)&#13;
        external&#13;
        constant&#13;
        noEther&#13;
        returns (uint256 amount)&#13;
    {&#13;
        for (uint256 i; i &lt; earlyPurchases.length; i++) {&#13;
            if (earlyPurchases[i].purchaser == purchaser) {&#13;
                amount += earlyPurchases[i].amount;&#13;
            }&#13;
        }&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Returns total amount of raised funds by Early Purchasers&#13;
     */&#13;
    function totalAmountOfEarlyPurchases()&#13;
        constant&#13;
        noEther&#13;
        public&#13;
        returns (uint256 totalAmount)&#13;
    {&#13;
        for (uint256 i; i &lt; earlyPurchases.length; i++) {&#13;
            totalAmount += earlyPurchases[i].amount;&#13;
        }&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Returns number of early purchases&#13;
     */&#13;
    function numberOfEarlyPurchases()&#13;
        external&#13;
        constant&#13;
        noEther&#13;
        returns (uint256)&#13;
    {&#13;
        return earlyPurchases.length;&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Append an early purchase log&#13;
     * @param purchaser Purchaser address&#13;
     * @param amount Purchase amount&#13;
     * @param purchasedAt Timestamp of purchased date&#13;
     */&#13;
    function appendEarlyPurchase(address purchaser, uint256 amount, uint256 purchasedAt)&#13;
        external&#13;
        noEther&#13;
        onlyOwner&#13;
        onlyBeforeCrowdsale&#13;
        onlyEarlyPurchaseTerm&#13;
        returns (bool)&#13;
    {&#13;
        if (amount == 0 ||&#13;
            totalAmountOfEarlyPurchases() + amount &gt; PURCHASE_AMOUNT_CAP)&#13;
        {&#13;
            return false;&#13;
        }&#13;
&#13;
        assert(purchasedAt != 0 || purchasedAt &lt;= now);&#13;
&#13;
        earlyPurchases.push(EarlyPurchase(purchaser, amount, purchasedAt));&#13;
        return true;&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Close early purchase term&#13;
     */&#13;
    function closeEarlyPurchase()&#13;
        external&#13;
        noEther&#13;
        onlyOwner&#13;
        returns (bool)&#13;
    {&#13;
        earlyPurchaseClosedAt = now;&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Setup function sets external contract's address&#13;
     * @param starbaseCrowdsaleAddress Token address&#13;
     */&#13;
    function setup(address starbaseCrowdsaleAddress)&#13;
        external&#13;
        noEther&#13;
        onlyOwner&#13;
        returns (bool)&#13;
    {&#13;
        if (address(starbaseCrowdsale) == 0) {&#13;
            starbaseCrowdsale = AbstractStarbaseCrowdsale(starbaseCrowdsaleAddress);&#13;
            return true;&#13;
        }&#13;
        return false;&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Contract constructor function&#13;
     */&#13;
    function StarbaseEarlyPurchase() noEther {&#13;
        owner = msg.sender;&#13;
    }&#13;
}&#13;
&#13;
/// @title EarlyPurchaseAmendment contract - Amend early purchase records of the original contract&#13;
/// @author Starbase PTE. LTD. - &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="483b3d3838273a3c083b3c293a2a293b2d662b27">[email protected]</a>&gt;&#13;
contract StarbaseEarlyPurchaseAmendment {&#13;
    /*&#13;
     *  Events&#13;
     */&#13;
    event EarlyPurchaseInvalidated(uint256 epIdx);&#13;
    event EarlyPurchaseAmended(uint256 epIdx);&#13;
&#13;
    /*&#13;
     *  External contracts&#13;
     */&#13;
    AbstractStarbaseCrowdsale public starbaseCrowdsale;&#13;
    StarbaseEarlyPurchase public starbaseEarlyPurchase;&#13;
&#13;
    /*&#13;
     *  Storage&#13;
     */&#13;
    address public owner;&#13;
    uint256[] public invalidEarlyPurchaseIndexes;&#13;
    uint256[] public amendedEarlyPurchaseIndexes;&#13;
    mapping (uint256 =&gt; StarbaseEarlyPurchase.EarlyPurchase) public amendedEarlyPurchases;&#13;
&#13;
    /*&#13;
     *  Modifiers&#13;
     */&#13;
    modifier noEther() {&#13;
        require(msg.value == 0);&#13;
        _;&#13;
    }&#13;
&#13;
    modifier onlyOwner() {&#13;
        require(msg.sender == owner);&#13;
        _;&#13;
    }&#13;
&#13;
    modifier onlyBeforeCrowdsale() {&#13;
        assert(address(starbaseCrowdsale) == address(0) || starbaseCrowdsale.startDate() == 0);&#13;
        _;&#13;
    }&#13;
&#13;
    modifier onlyEarlyPurchasesLoaded() {&#13;
        assert(address(starbaseEarlyPurchase) != address(0));&#13;
        _;&#13;
    }&#13;
&#13;
    /*&#13;
     *  Functions below are compatible with starbaseEarlyPurchase contract&#13;
     */&#13;
&#13;
    /**&#13;
     * @dev Returns an early purchase record&#13;
     * @param earlyPurchaseIndex Index number of an early purchase&#13;
     */&#13;
    function earlyPurchases(uint256 earlyPurchaseIndex)&#13;
        external&#13;
        constant&#13;
        onlyEarlyPurchasesLoaded&#13;
        returns (address purchaser, uint256 amount, uint256 purchasedAt)&#13;
    {&#13;
        return starbaseEarlyPurchase.earlyPurchases(earlyPurchaseIndex);&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Returns early purchased amount by purchaser's address&#13;
     * @param purchaser Purchaser address&#13;
     */&#13;
    function purchasedAmountBy(address purchaser)&#13;
        external&#13;
        constant&#13;
        noEther&#13;
        returns (uint256 amount)&#13;
    {&#13;
        StarbaseEarlyPurchase.EarlyPurchase[] memory normalizedEP =&#13;
            normalizedEarlyPurchases();&#13;
        for (uint256 i; i &lt; normalizedEP.length; i++) {&#13;
            if (normalizedEP[i].purchaser == purchaser) {&#13;
                amount += normalizedEP[i].amount;&#13;
            }&#13;
        }&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Returns total amount of raised funds by Early Purchasers&#13;
     */&#13;
    function totalAmountOfEarlyPurchases()&#13;
        constant&#13;
        noEther&#13;
        public&#13;
        returns (uint256 totalAmount)&#13;
    {&#13;
        StarbaseEarlyPurchase.EarlyPurchase[] memory normalizedEP =&#13;
            normalizedEarlyPurchases();&#13;
        for (uint256 i; i &lt; normalizedEP.length; i++) {&#13;
            totalAmount += normalizedEP[i].amount;&#13;
        }&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Returns number of early purchases&#13;
     */&#13;
    function numberOfEarlyPurchases()&#13;
        external&#13;
        constant&#13;
        noEther&#13;
        returns (uint256)&#13;
    {&#13;
        return normalizedEarlyPurchases().length;&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Sets up function sets external contract's address&#13;
     * @param starbaseCrowdsaleAddress Token address&#13;
     */&#13;
    function setup(address starbaseCrowdsaleAddress)&#13;
        external&#13;
        noEther&#13;
        onlyOwner&#13;
        returns (bool)&#13;
    {&#13;
        if (address(starbaseCrowdsale) == 0) {&#13;
            starbaseCrowdsale = AbstractStarbaseCrowdsale(starbaseCrowdsaleAddress);&#13;
            return true;&#13;
        }&#13;
        return false;&#13;
    }&#13;
&#13;
    /*&#13;
     *  Contract functions unique to StarbaseEarlyPurchaseAmendment&#13;
     */&#13;
&#13;
     /**&#13;
      * @dev Invalidate early purchase&#13;
      * @param earlyPurchaseIndex Index number of the purchase&#13;
      */&#13;
    function invalidateEarlyPurchase(uint256 earlyPurchaseIndex)&#13;
        external&#13;
        noEther&#13;
        onlyOwner&#13;
        onlyEarlyPurchasesLoaded&#13;
        onlyBeforeCrowdsale&#13;
        returns (bool)&#13;
    {&#13;
        assert(numberOfRawEarlyPurchases() &gt; earlyPurchaseIndex); // Array Index Out of Bounds Exception&#13;
&#13;
        for (uint256 i; i &lt; invalidEarlyPurchaseIndexes.length; i++) {&#13;
            assert(invalidEarlyPurchaseIndexes[i] != earlyPurchaseIndex);&#13;
        }&#13;
&#13;
        invalidEarlyPurchaseIndexes.push(earlyPurchaseIndex);&#13;
        EarlyPurchaseInvalidated(earlyPurchaseIndex);&#13;
        return true;&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Checks whether early purchase is invalid&#13;
     * @param earlyPurchaseIndex Index number of the purchase&#13;
     */&#13;
    function isInvalidEarlyPurchase(uint256 earlyPurchaseIndex)&#13;
        constant&#13;
        noEther&#13;
        public&#13;
        returns (bool)&#13;
    {&#13;
        assert(numberOfRawEarlyPurchases() &gt; earlyPurchaseIndex); // Array Index Out of Bounds Exception&#13;
&#13;
&#13;
        for (uint256 i; i &lt; invalidEarlyPurchaseIndexes.length; i++) {&#13;
            if (invalidEarlyPurchaseIndexes[i] == earlyPurchaseIndex) {&#13;
                return true;&#13;
            }&#13;
        }&#13;
        return false;&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Amends a given early purchase with data&#13;
     * @param earlyPurchaseIndex Index number of the purchase&#13;
     * @param purchaser Purchaser's address&#13;
     * @param amount Value of purchase&#13;
     * @param purchasedAt Purchase timestamp&#13;
     */&#13;
    function amendEarlyPurchase(uint256 earlyPurchaseIndex, address purchaser, uint256 amount, uint256 purchasedAt)&#13;
        external&#13;
        noEther&#13;
        onlyOwner&#13;
        onlyEarlyPurchasesLoaded&#13;
        onlyBeforeCrowdsale&#13;
        returns (bool)&#13;
    {&#13;
        assert(purchasedAt != 0 || purchasedAt &lt;= now);&#13;
&#13;
        assert(numberOfRawEarlyPurchases() &gt; earlyPurchaseIndex);&#13;
&#13;
        assert(!isInvalidEarlyPurchase(earlyPurchaseIndex)); // Invalid early purchase cannot be amended&#13;
&#13;
        if (!isAmendedEarlyPurchase(earlyPurchaseIndex)) {&#13;
            amendedEarlyPurchaseIndexes.push(earlyPurchaseIndex);&#13;
        }&#13;
&#13;
        amendedEarlyPurchases[earlyPurchaseIndex] =&#13;
            StarbaseEarlyPurchase.EarlyPurchase(purchaser, amount, purchasedAt);&#13;
        EarlyPurchaseAmended(earlyPurchaseIndex);&#13;
        return true;&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Checks whether early purchase is amended&#13;
     * @param earlyPurchaseIndex Index number of the purchase&#13;
     */&#13;
    function isAmendedEarlyPurchase(uint256 earlyPurchaseIndex)&#13;
        constant&#13;
        noEther&#13;
        returns (bool)&#13;
    {&#13;
        assert(numberOfRawEarlyPurchases() &gt; earlyPurchaseIndex); // Array Index Out of Bounds Exception&#13;
&#13;
        for (uint256 i; i &lt; amendedEarlyPurchaseIndexes.length; i++) {&#13;
            if (amendedEarlyPurchaseIndexes[i] == earlyPurchaseIndex) {&#13;
                return true;&#13;
            }&#13;
        }&#13;
        return false;&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Loads early purchases data to StarbaseEarlyPurchaseAmendment contract&#13;
     * @param starbaseEarlyPurchaseAddress Address from starbase early purchase&#13;
     */&#13;
    function loadStarbaseEarlyPurchases(address starbaseEarlyPurchaseAddress)&#13;
        external&#13;
        noEther&#13;
        onlyOwner&#13;
        onlyBeforeCrowdsale&#13;
        returns (bool)&#13;
    {&#13;
        assert(starbaseEarlyPurchaseAddress != 0 ||&#13;
            address(starbaseEarlyPurchase) == 0);&#13;
&#13;
        starbaseEarlyPurchase = StarbaseEarlyPurchase(starbaseEarlyPurchaseAddress);&#13;
        assert(starbaseEarlyPurchase.earlyPurchaseClosedAt() != 0); // the early purchase must be closed&#13;
&#13;
        return true;&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Contract constructor function. It sets owner&#13;
     */&#13;
    function StarbaseEarlyPurchaseAmendment() noEther {&#13;
        owner = msg.sender;&#13;
    }&#13;
&#13;
    /**&#13;
     * Internal functions&#13;
     */&#13;
&#13;
    /**&#13;
     * @dev Normalizes early purchases data&#13;
     */&#13;
    function normalizedEarlyPurchases()&#13;
        constant&#13;
        internal&#13;
        returns (StarbaseEarlyPurchase.EarlyPurchase[] normalizedEP)&#13;
    {&#13;
        uint256 rawEPCount = numberOfRawEarlyPurchases();&#13;
        normalizedEP = new StarbaseEarlyPurchase.EarlyPurchase[](&#13;
            rawEPCount - invalidEarlyPurchaseIndexes.length);&#13;
&#13;
        uint256 normalizedIdx;&#13;
        for (uint256 i; i &lt; rawEPCount; i++) {&#13;
            if (isInvalidEarlyPurchase(i)) {&#13;
                continue;   // invalid early purchase should be ignored&#13;
            }&#13;
&#13;
            StarbaseEarlyPurchase.EarlyPurchase memory ep;&#13;
            if (isAmendedEarlyPurchase(i)) {&#13;
                ep = amendedEarlyPurchases[i];  // amended early purchase should take a priority&#13;
            } else {&#13;
                ep = getEarlyPurchase(i);&#13;
            }&#13;
&#13;
            normalizedEP[normalizedIdx] = ep;&#13;
            normalizedIdx++;&#13;
        }&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Fetches early purchases data&#13;
     */&#13;
    function getEarlyPurchase(uint256 earlyPurchaseIndex)&#13;
        internal&#13;
        constant&#13;
        onlyEarlyPurchasesLoaded&#13;
        returns (StarbaseEarlyPurchase.EarlyPurchase)&#13;
    {&#13;
        var (purchaser, amount, purchasedAt) =&#13;
            starbaseEarlyPurchase.earlyPurchases(earlyPurchaseIndex);&#13;
        return StarbaseEarlyPurchase.EarlyPurchase(purchaser, amount, purchasedAt);&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Returns raw number of early purchases&#13;
     */&#13;
    function numberOfRawEarlyPurchases()&#13;
        internal&#13;
        constant&#13;
        onlyEarlyPurchasesLoaded&#13;
        returns (uint256)&#13;
    {&#13;
        return starbaseEarlyPurchase.numberOfEarlyPurchases();&#13;
    }&#13;
}&#13;
&#13;
//! Certifier contract.&#13;
//! By Parity Technologies, 2017.&#13;
//! Released under the Apache Licence 2.&#13;
&#13;
contract Certifier {&#13;
	event Confirmed(address indexed who);&#13;
	event Revoked(address indexed who);&#13;
	function certified(address) public constant returns (bool);&#13;
	function get(address, string) public constant returns (bytes32);&#13;
	function getAddress(address, string) public constant returns (address);&#13;
	function getUint(address, string) public constant returns (uint);&#13;
}&#13;
&#13;
/**&#13;
 * @title Crowdsale contract - Starbase crowdsale to create STAR.&#13;
 * @author Starbase PTE. LTD. - &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="7910171f16390a0d180b1b180a1c571a16">[email protected]</a>&gt;&#13;
 */&#13;
contract StarbaseCrowdsale is Ownable {&#13;
    using SafeMath for uint256;&#13;
    /*&#13;
     *  Events&#13;
     */&#13;
    event CrowdsaleEnded(uint256 endedAt);&#13;
    event StarbasePurchasedWithEth(address purchaser, uint256 amount, uint256 rawAmount, uint256 cnyEthRate);&#13;
    event CnyEthRateUpdated(uint256 cnyEthRate);&#13;
    event CnyBtcRateUpdated(uint256 cnyBtcRate);&#13;
    event QualifiedPartnerAddress(address qualifiedPartner);&#13;
&#13;
    /**&#13;
     *  External contracts&#13;
     */&#13;
    AbstractStarbaseToken public starbaseToken;&#13;
    StarbaseEarlyPurchaseAmendment public starbaseEpAmendment;&#13;
    Certifier public picopsCertifier;&#13;
&#13;
    /**&#13;
     *  Constants&#13;
     */&#13;
    uint256 constant public crowdsaleTokenAmount = 125000000e18;&#13;
    uint256 constant public earlyPurchaseTokenAmount = 50000000e18;&#13;
    uint256 constant public MIN_INVESTMENT = 1; // min is 1 Wei&#13;
    uint256 constant public MAX_CAP = 67000000; // in CNY. approximately 10M USD. (includes raised amount from both EP and CS)&#13;
    string public constant PURCHASE_AMOUNT_UNIT = 'CNY';  // Chinese Yuan&#13;
&#13;
    /**&#13;
     * Types&#13;
     */&#13;
    struct CrowdsalePurchase {&#13;
        address purchaser;&#13;
        uint256 amount;        // CNY based amount with bonus&#13;
        uint256 rawAmount;     // CNY based amount no bonus&#13;
        uint256 purchasedAt;   // timestamp&#13;
    }&#13;
&#13;
    struct QualifiedPartners {&#13;
        uint256 amountCap;&#13;
        uint256 amountRaised;&#13;
        bool    bonaFide;&#13;
        uint256 commissionFeePercentage; // example 5 will calculate the percentage as 5%&#13;
    }&#13;
&#13;
    /*&#13;
     *  Enums&#13;
     */&#13;
    enum BonusMilestones {&#13;
        First,&#13;
        Second,&#13;
        Third,&#13;
        Fourth,&#13;
        Fifth&#13;
    }&#13;
&#13;
    // Initialize bonusMilestones&#13;
    BonusMilestones public bonusMilestones = BonusMilestones.First;&#13;
&#13;
    /**&#13;
     *  Storage&#13;
     */&#13;
    uint public numOfDeliveredCrowdsalePurchases;  // index to keep the number of crowdsale purchases have already been processed by `withdrawPurchasedTokens`&#13;
    uint public numOfDeliveredEarlyPurchases;  // index to keep the number of early purchases have already been processed by `withdrawPurchasedTokens`&#13;
    uint256 public numOfLoadedEarlyPurchases; // index to keep the number of early purchases that have already been loaded by `loadEarlyPurchases`&#13;
&#13;
    // early purchase&#13;
    address[] public earlyPurchasers;&#13;
    mapping (address =&gt; uint256) public earlyPurchasedAmountBy; // early purchased amount in CNY per purchasers' address&#13;
    bool public earlyPurchasesLoaded = false;  // returns whether all early purchases are loaded into this contract&#13;
    uint256 public totalAmountOfEarlyPurchases; // including 20% bonus&#13;
&#13;
    // crowdsale&#13;
    bool public presalePurchasesLoaded = false; // returns whether all presale purchases are loaded into this contract&#13;
    uint256 public maxCrowdsaleCap;     // = 67M CNY - (total raised amount from EP)&#13;
    uint256 public totalAmountOfCrowdsalePurchases; // in CNY, including bonuses&#13;
    uint256 public totalAmountOfCrowdsalePurchasesWithoutBonus; // in CNY&#13;
    mapping (address =&gt; QualifiedPartners) public qualifiedPartners;&#13;
    uint256 public purchaseStartBlock;  // crowdsale purchases can be accepted from this block number&#13;
    uint256 public startDate;&#13;
    uint256 public endedAt;&#13;
    CrowdsalePurchase[] public crowdsalePurchases;&#13;
    mapping (address =&gt; uint256) public crowdsalePurchaseAmountBy; // crowdsale purchase amount in CNY per purchasers' address&#13;
    uint256 public cnyBtcRate; // this rate won't be used from a smart contract function but external system&#13;
    uint256 public cnyEthRate;&#13;
&#13;
    // bonus milestones&#13;
    uint256 public firstBonusEnds;&#13;
    uint256 public secondBonusEnds;&#13;
    uint256 public thirdBonusEnds;&#13;
    uint256 public fourthBonusEnds;&#13;
&#13;
    // after the crowdsale&#13;
    mapping (address =&gt; uint256) public numOfPurchasedTokensOnCsBy;    // the number of tokens purchased on the crowdsale by a purchaser&#13;
    mapping (address =&gt; uint256) public numOfPurchasedTokensOnEpBy;    // the number of tokens early purchased by a purchaser&#13;
&#13;
    /**&#13;
     *  Modifiers&#13;
     */&#13;
    modifier minInvestment() {&#13;
        // User has to send at least the ether value of one token.&#13;
        assert(msg.value &gt;= MIN_INVESTMENT);&#13;
        _;&#13;
    }&#13;
&#13;
    modifier whenNotStarted() {&#13;
        assert(startDate == 0);&#13;
        _;&#13;
    }&#13;
&#13;
    modifier whenEnded() {&#13;
        assert(isEnded());&#13;
        _;&#13;
    }&#13;
&#13;
    modifier hasBalance() {&#13;
        assert(this.balance &gt; 0);&#13;
        _;&#13;
    }&#13;
    modifier rateIsSet(uint256 _rate) {&#13;
        assert(_rate != 0);&#13;
        _;&#13;
    }&#13;
&#13;
    modifier whenNotEnded() {&#13;
        assert(!isEnded());&#13;
        _;&#13;
    }&#13;
&#13;
    modifier tokensNotDelivered() {&#13;
        assert(numOfDeliveredCrowdsalePurchases == 0);&#13;
        assert(numOfDeliveredEarlyPurchases == 0);&#13;
        _;&#13;
    }&#13;
&#13;
    modifier onlyFundraiser() {&#13;
        assert(address(starbaseToken) != 0);&#13;
        assert(starbaseToken.isFundraiser(msg.sender));&#13;
        _;&#13;
    }&#13;
&#13;
    modifier onlyQualifiedPartner() {&#13;
        assert(qualifiedPartners[msg.sender].bonaFide);&#13;
        _;&#13;
    }&#13;
&#13;
    modifier onlyQualifiedPartnerORPicopsCertified() {&#13;
        assert(qualifiedPartners[msg.sender].bonaFide || picopsCertifier.certified(msg.sender));&#13;
        _;&#13;
    }&#13;
&#13;
    /**&#13;
     * Contract functions&#13;
     */&#13;
    /**&#13;
     * @dev Contract constructor function sets owner address and&#13;
     *      address of StarbaseEarlyPurchaseAmendment contract.&#13;
     * @param starbaseEpAddr The address that holds the early purchasers Star tokens&#13;
     * @param picopsCertifierAddr The address of the PICOPS certifier.&#13;
     *                            See also https://picops.parity.io/#/details&#13;
     */&#13;
    function StarbaseCrowdsale(address starbaseEpAddr, address picopsCertifierAddr) {&#13;
        require(starbaseEpAddr != 0 &amp;&amp; picopsCertifierAddr != 0);&#13;
        owner = msg.sender;&#13;
        starbaseEpAmendment = StarbaseEarlyPurchaseAmendment(starbaseEpAddr);&#13;
        picopsCertifier = Certifier(picopsCertifierAddr);&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Fallback accepts payment for Star tokens with Eth&#13;
     */&#13;
    function() payable {&#13;
        redirectToPurchase();&#13;
    }&#13;
&#13;
    /**&#13;
     * External functions&#13;
     */&#13;
&#13;
    /**&#13;
     * @dev Setup function sets external contracts' addresses and set the max crowdsale cap&#13;
     * @param starbaseTokenAddress Token address.&#13;
     * @param _purchaseStartBlock Block number to start crowdsale&#13;
     */&#13;
    function setup(address starbaseTokenAddress, uint256 _purchaseStartBlock)&#13;
        external&#13;
        onlyOwner&#13;
        returns (bool)&#13;
    {&#13;
        require(starbaseTokenAddress != address(0));&#13;
        require(address(starbaseToken) == 0);&#13;
        starbaseToken = AbstractStarbaseToken(starbaseTokenAddress);&#13;
        purchaseStartBlock = _purchaseStartBlock;&#13;
&#13;
        // set the max cap of this crowdsale&#13;
        maxCrowdsaleCap = MAX_CAP.sub(totalAmountOfEarlyPurchasesWithoutBonus());&#13;
&#13;
        assert(maxCrowdsaleCap &gt; 0);&#13;
&#13;
        return true;&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Transfers raised funds to company's wallet address at any given time.&#13;
     */&#13;
    function withdrawForCompany()&#13;
        external&#13;
        onlyFundraiser&#13;
        hasBalance&#13;
    {&#13;
        address company = starbaseToken.company();&#13;
        require(company != address(0));&#13;
        company.transfer(this.balance);&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Update start block Number for the crowdsale&#13;
     */&#13;
    function updatePurchaseStartBlock(uint256 _purchaseStartBlock)&#13;
        external&#13;
        whenNotStarted&#13;
        onlyFundraiser&#13;
        returns (bool)&#13;
    {&#13;
        purchaseStartBlock = _purchaseStartBlock;&#13;
        return true;&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Update the CNY/ETH rate to record purchases in CNY&#13;
     */&#13;
    function updateCnyEthRate(uint256 rate)&#13;
        external&#13;
        onlyFundraiser&#13;
        returns (bool)&#13;
    {&#13;
        cnyEthRate = rate;&#13;
        CnyEthRateUpdated(cnyEthRate);&#13;
        return true;&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Update the CNY/BTC rate to record purchases in CNY&#13;
     */&#13;
    function updateCnyBtcRate(uint256 rate)&#13;
        external&#13;
        onlyFundraiser&#13;
        returns (bool)&#13;
    {&#13;
        cnyBtcRate = rate;&#13;
        CnyBtcRateUpdated(cnyBtcRate);&#13;
        return true;&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Allow for the possibility for contract owner to start crowdsale&#13;
     */&#13;
    function ownerStartsCrowdsale(uint256 timestamp)&#13;
        external&#13;
        whenNotStarted&#13;
        onlyOwner&#13;
    {&#13;
        assert(block.number &gt;= purchaseStartBlock);   // this should be after the crowdsale start block&#13;
        startCrowdsale(timestamp);&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Ends crowdsale&#13;
     *      This may be executed by an owner if the raised funds did not reach the map cap&#13;
     * @param timestamp Timestamp at the crowdsale ended&#13;
     */&#13;
    function endCrowdsale(uint256 timestamp)&#13;
        external&#13;
        onlyOwner&#13;
    {&#13;
        assert(timestamp &gt; 0 &amp;&amp; timestamp &lt;= now);&#13;
        assert(block.number &gt;= purchaseStartBlock &amp;&amp; endedAt == 0);   // cannot end before it starts and overwriting time is not permitted&#13;
        endedAt = timestamp;&#13;
        CrowdsaleEnded(endedAt);&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Ends crowdsale&#13;
     *      This may be executed by purchaseWithEth when the raised funds reach the map cap&#13;
     */&#13;
    function endCrowdsale() internal {&#13;
        assert(block.number &gt;= purchaseStartBlock &amp;&amp; endedAt == 0);&#13;
        endedAt = now;&#13;
        CrowdsaleEnded(endedAt);&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Deliver tokens to purchasers according to their purchase amount in CNY&#13;
     */&#13;
    function withdrawPurchasedTokens()&#13;
        external&#13;
        whenEnded&#13;
        returns (bool)&#13;
    {&#13;
        assert(earlyPurchasesLoaded);&#13;
        assert(address(starbaseToken) != 0);&#13;
&#13;
        /*&#13;
         * “Value” refers to the contribution of the User:&#13;
         *  {crowdsale_purchaser_token_amount} =&#13;
         *  {crowdsale_token_amount} * {crowdsalePurchase_value} / {earlypurchase_value} + {crowdsale_value}.&#13;
         *&#13;
         * Example: If a User contributes during the Contribution Period 100 CNY (including applicable&#13;
         * Bonus, if any) and the total amount early purchases amounts to 6’000’000 CNY&#13;
         * and total amount raised during the Contribution Period is 30’000’000, then he will get&#13;
         * 347.22 STAR = 125’000’000 STAR * 100 CNY / 30’000’000 CNY + 6’000’000 CNY.&#13;
        */&#13;
&#13;
        if (crowdsalePurchaseAmountBy[msg.sender] &gt; 0) {&#13;
            uint256 crowdsalePurchaseValue = crowdsalePurchaseAmountBy[msg.sender];&#13;
            crowdsalePurchaseAmountBy[msg.sender] = 0;&#13;
&#13;
            uint256 tokenCount =&#13;
                SafeMath.mul(crowdsaleTokenAmount, crowdsalePurchaseValue) /&#13;
                totalRaisedAmountInCny();&#13;
&#13;
            numOfPurchasedTokensOnCsBy[msg.sender] =&#13;
                SafeMath.add(numOfPurchasedTokensOnCsBy[msg.sender], tokenCount);&#13;
            assert(starbaseToken.allocateToCrowdsalePurchaser(msg.sender, tokenCount));&#13;
            numOfDeliveredCrowdsalePurchases++;&#13;
        }&#13;
&#13;
        /*&#13;
         * “Value” refers to the contribution of the User:&#13;
         * {earlypurchaser_token_amount} =&#13;
         * {earlypurchaser_token_amount} * ({earlypurchase_value} / {total_earlypurchase_value})&#13;
         *  + {crowdsale_token_amount} * ({earlypurchase_value} / {earlypurchase_value} + {crowdsale_value}).&#13;
         *&#13;
         * Example: If an Early Purchaser contributes 100 CNY (including Bonus of 20%) and the&#13;
         * total amount of early purchases amounts to 6’000’000 CNY and the total amount raised&#13;
         * during the Contribution Period is 30’000’000 CNY, then he will get 1180.55 STAR =&#13;
         * 50’000’000 STAR * 100 CNY / 6’000’000 CNY + 125’000’000 STAR * 100 CNY /&#13;
         * 30’000’000 CNY + 6’000’000 CNY&#13;
         */&#13;
&#13;
        if (earlyPurchasedAmountBy[msg.sender] &gt; 0) {  // skip if is not an early purchaser&#13;
            uint256 earlyPurchaserPurchaseValue = earlyPurchasedAmountBy[msg.sender];&#13;
            earlyPurchasedAmountBy[msg.sender] = 0;&#13;
&#13;
            uint256 epTokenCalculationFromEPTokenAmount = SafeMath.mul(earlyPurchaseTokenAmount, earlyPurchaserPurchaseValue) / totalAmountOfEarlyPurchases;&#13;
&#13;
            uint256 epTokenCalculationFromCrowdsaleTokenAmount = SafeMath.mul(crowdsaleTokenAmount, earlyPurchaserPurchaseValue) / totalRaisedAmountInCny();&#13;
&#13;
            uint256 epTokenCount = SafeMath.add(epTokenCalculationFromEPTokenAmount, epTokenCalculationFromCrowdsaleTokenAmount);&#13;
&#13;
            numOfPurchasedTokensOnEpBy[msg.sender] = SafeMath.add(numOfPurchasedTokensOnEpBy[msg.sender], epTokenCount);&#13;
            assert(starbaseToken.allocateToCrowdsalePurchaser(msg.sender, epTokenCount));&#13;
            numOfDeliveredEarlyPurchases++;&#13;
        }&#13;
&#13;
        return true;&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Load early purchases from the contract keeps track of them&#13;
     */&#13;
    function loadEarlyPurchases() external onlyOwner returns (bool) {&#13;
        if (earlyPurchasesLoaded) {&#13;
            return false;    // all EPs have already been loaded&#13;
        }&#13;
&#13;
        uint256 numOfOrigEp = starbaseEpAmendment&#13;
            .starbaseEarlyPurchase()&#13;
            .numberOfEarlyPurchases();&#13;
&#13;
        for (uint256 i = numOfLoadedEarlyPurchases; i &lt; numOfOrigEp &amp;&amp; msg.gas &gt; 200000; i++) {&#13;
            if (starbaseEpAmendment.isInvalidEarlyPurchase(i)) {&#13;
                numOfLoadedEarlyPurchases = SafeMath.add(numOfLoadedEarlyPurchases, 1);&#13;
                continue;&#13;
            }&#13;
            var (purchaser, amount,) =&#13;
                starbaseEpAmendment.isAmendedEarlyPurchase(i)&#13;
                ? starbaseEpAmendment.amendedEarlyPurchases(i)&#13;
                : starbaseEpAmendment.earlyPurchases(i);&#13;
            if (amount &gt; 0) {&#13;
                if (earlyPurchasedAmountBy[purchaser] == 0) {&#13;
                    earlyPurchasers.push(purchaser);&#13;
                }&#13;
                // each early purchaser receives 20% bonus&#13;
                uint256 bonus = SafeMath.mul(amount, 20) / 100;&#13;
                uint256 amountWithBonus = SafeMath.add(amount, bonus);&#13;
&#13;
                earlyPurchasedAmountBy[purchaser] = SafeMath.add(earlyPurchasedAmountBy[purchaser], amountWithBonus);&#13;
                totalAmountOfEarlyPurchases = totalAmountOfEarlyPurchases.add(amountWithBonus);&#13;
            }&#13;
&#13;
            numOfLoadedEarlyPurchases = SafeMath.add(numOfLoadedEarlyPurchases, 1);&#13;
        }&#13;
&#13;
        assert(numOfLoadedEarlyPurchases &lt;= numOfOrigEp);&#13;
        if (numOfLoadedEarlyPurchases == numOfOrigEp) {&#13;
            earlyPurchasesLoaded = true;    // enable the flag&#13;
        }&#13;
        return true;&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Load presale purchases from the contract keeps track of them&#13;
     * @param starbaseCrowdsalePresale Starbase presale contract address&#13;
     */&#13;
    function loadPresalePurchases(address starbaseCrowdsalePresale)&#13;
        external&#13;
        onlyOwner&#13;
        whenNotEnded&#13;
    {&#13;
        require(starbaseCrowdsalePresale != 0);&#13;
        require(!presalePurchasesLoaded);&#13;
        StarbaseCrowdsale presale = StarbaseCrowdsale(starbaseCrowdsalePresale);&#13;
        for (uint i; i &lt; presale.numOfPurchases(); i++) {&#13;
            var (purchaser, amount, rawAmount, purchasedAt) =&#13;
                presale.crowdsalePurchases(i);  // presale purchase&#13;
            crowdsalePurchases.push(CrowdsalePurchase(purchaser, amount, rawAmount, purchasedAt));&#13;
&#13;
            // Increase the sums&#13;
            crowdsalePurchaseAmountBy[purchaser] = SafeMath.add(crowdsalePurchaseAmountBy[purchaser], amount);&#13;
            totalAmountOfCrowdsalePurchases = totalAmountOfCrowdsalePurchases.add(amount);&#13;
            totalAmountOfCrowdsalePurchasesWithoutBonus = totalAmountOfCrowdsalePurchasesWithoutBonus.add(rawAmount);&#13;
        }&#13;
        presalePurchasesLoaded = true;&#13;
    }&#13;
&#13;
    /**&#13;
      * @dev Set qualified crowdsale partner i.e. Bitcoin Suisse address&#13;
      * @param _qualifiedPartner Address of the qualified partner that can purchase during crowdsale&#13;
      * @param _amountCap Ether value which partner is able to contribute&#13;
      * @param _commissionFeePercentage Integer that represents the fee to pay qualified partner 5 is 5%&#13;
      */&#13;
    function setQualifiedPartner(address _qualifiedPartner, uint256 _amountCap, uint256 _commissionFeePercentage)&#13;
        external&#13;
        onlyOwner&#13;
    {&#13;
        assert(!qualifiedPartners[_qualifiedPartner].bonaFide);&#13;
        qualifiedPartners[_qualifiedPartner].bonaFide = true;&#13;
        qualifiedPartners[_qualifiedPartner].amountCap = _amountCap;&#13;
        qualifiedPartners[_qualifiedPartner].commissionFeePercentage = _commissionFeePercentage;&#13;
        QualifiedPartnerAddress(_qualifiedPartner);&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Remove address from qualified partners list.&#13;
     * @param _qualifiedPartner Address to be removed from the list.&#13;
     */&#13;
    function unlistQualifiedPartner(address _qualifiedPartner) external onlyOwner {&#13;
        assert(qualifiedPartners[_qualifiedPartner].bonaFide);&#13;
        qualifiedPartners[_qualifiedPartner].bonaFide = false;&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Update whitelisted address amount allowed to raise during the presale.&#13;
     * @param _qualifiedPartner Qualified Partner address to be updated.&#13;
     * @param _amountCap Amount that the address is able to raise during the presale.&#13;
     */&#13;
    function updateQualifiedPartnerCapAmount(address _qualifiedPartner, uint256 _amountCap) external onlyOwner {&#13;
        assert(qualifiedPartners[_qualifiedPartner].bonaFide);&#13;
        qualifiedPartners[_qualifiedPartner].amountCap = _amountCap;&#13;
    }&#13;
&#13;
    /**&#13;
     * Public functions&#13;
     */&#13;
&#13;
    /**&#13;
     * @dev Returns boolean for whether crowdsale has ended&#13;
     */&#13;
    function isEnded() constant public returns (bool) {&#13;
        return (endedAt &gt; 0 &amp;&amp; endedAt &lt;= now);&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Returns number of purchases to date.&#13;
     */&#13;
    function numOfPurchases() constant public returns (uint256) {&#13;
        return crowdsalePurchases.length;&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Returns total raised amount in CNY (includes EP) and bonuses&#13;
     */&#13;
    function totalRaisedAmountInCny() constant public returns (uint256) {&#13;
        return totalAmountOfEarlyPurchases.add(totalAmountOfCrowdsalePurchases);&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Returns total amount of early purchases in CNY and bonuses&#13;
     */&#13;
    function totalAmountOfEarlyPurchasesWithBonus() constant public returns(uint256) {&#13;
       return starbaseEpAmendment.totalAmountOfEarlyPurchases().mul(120).div(100);&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Returns total amount of early purchases in CNY&#13;
     */&#13;
    function totalAmountOfEarlyPurchasesWithoutBonus() constant public returns(uint256) {&#13;
       return starbaseEpAmendment.totalAmountOfEarlyPurchases();&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Allows qualified crowdsale partner to purchase Star Tokens&#13;
     */&#13;
    function purchaseAsQualifiedPartner()&#13;
        payable&#13;
        public&#13;
        rateIsSet(cnyEthRate)&#13;
        onlyQualifiedPartner&#13;
        returns (bool)&#13;
    {&#13;
        require(msg.value &gt; 0);&#13;
        qualifiedPartners[msg.sender].amountRaised = SafeMath.add(msg.value, qualifiedPartners[msg.sender].amountRaised);&#13;
&#13;
        assert(qualifiedPartners[msg.sender].amountRaised &lt;= qualifiedPartners[msg.sender].amountCap);&#13;
&#13;
        uint256 rawAmount = SafeMath.mul(msg.value, cnyEthRate) / 1e18;&#13;
        recordPurchase(msg.sender, rawAmount, now);&#13;
&#13;
        if (qualifiedPartners[msg.sender].commissionFeePercentage &gt; 0) {&#13;
            sendQualifiedPartnerCommissionFee(msg.sender, msg.value);&#13;
        }&#13;
&#13;
        return true;&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Allows user to purchase STAR tokens with Ether&#13;
     */&#13;
    function purchaseWithEth()&#13;
        payable&#13;
        public&#13;
        minInvestment&#13;
        whenNotEnded&#13;
        rateIsSet(cnyEthRate)&#13;
        onlyQualifiedPartnerORPicopsCertified&#13;
        returns (bool)&#13;
    {&#13;
        require(purchaseStartBlock &gt; 0 &amp;&amp; block.number &gt;= purchaseStartBlock);&#13;
&#13;
        if (startDate == 0) {&#13;
            startCrowdsale(block.timestamp);&#13;
        }&#13;
&#13;
        uint256 rawAmount = SafeMath.mul(msg.value, cnyEthRate) / 1e18;&#13;
        recordPurchase(msg.sender, rawAmount, now);&#13;
&#13;
        if (totalAmountOfCrowdsalePurchasesWithoutBonus &gt;= maxCrowdsaleCap) {&#13;
            endCrowdsale(); // ends this crowdsale automatically&#13;
        }&#13;
&#13;
        return true;&#13;
    }&#13;
&#13;
    /**&#13;
     * Internal functions&#13;
     */&#13;
&#13;
    /**&#13;
     * @dev Initializes Starbase crowdsale&#13;
     */&#13;
    function startCrowdsale(uint256 timestamp) internal {&#13;
        startDate = timestamp;&#13;
        uint256 presaleAmount = totalAmountOfCrowdsalePurchasesWithoutBonus;&#13;
        if (maxCrowdsaleCap &gt; presaleAmount) {&#13;
            uint256 mainSaleCap = maxCrowdsaleCap.sub(presaleAmount);&#13;
            uint256 twentyPercentOfCrowdsalePurchase = mainSaleCap.mul(20).div(100);&#13;
&#13;
            // set token bonus milestones in cny total crowdsale purchase&#13;
            firstBonusEnds =  twentyPercentOfCrowdsalePurchase;&#13;
            secondBonusEnds = firstBonusEnds.add(twentyPercentOfCrowdsalePurchase);&#13;
            thirdBonusEnds =  secondBonusEnds.add(twentyPercentOfCrowdsalePurchase);&#13;
            fourthBonusEnds = thirdBonusEnds.add(twentyPercentOfCrowdsalePurchase);&#13;
        }&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Abstract record of a purchase to Tokens&#13;
     * @param purchaser Address of the buyer&#13;
     * @param rawAmount Amount in CNY as per the CNY/ETH rate used&#13;
     * @param timestamp Timestamp at the purchase made&#13;
     */&#13;
    function recordPurchase(&#13;
        address purchaser,&#13;
        uint256 rawAmount,&#13;
        uint256 timestamp&#13;
    )&#13;
        internal&#13;
        returns(uint256 amount)&#13;
    {&#13;
        amount = rawAmount; // amount to check reach of max cap. it does not care for bonus tokens here&#13;
&#13;
        // presale transfers which occurs before the crowdsale ignores the crowdsale hard cap&#13;
        if (block.number &gt;= purchaseStartBlock) {&#13;
            require(totalAmountOfCrowdsalePurchasesWithoutBonus &lt; maxCrowdsaleCap);   // check if the amount has already reached the cap&#13;
&#13;
            uint256 crowdsaleTotalAmountAfterPurchase =&#13;
                SafeMath.add(totalAmountOfCrowdsalePurchasesWithoutBonus, amount);&#13;
&#13;
            // check whether purchase goes over the cap and send the difference back to the purchaser.&#13;
            if (crowdsaleTotalAmountAfterPurchase &gt; maxCrowdsaleCap) {&#13;
              uint256 difference = SafeMath.sub(crowdsaleTotalAmountAfterPurchase, maxCrowdsaleCap);&#13;
              uint256 ethValueToReturn = SafeMath.mul(difference, 1e18) / cnyEthRate;&#13;
              purchaser.transfer(ethValueToReturn);&#13;
              amount = SafeMath.sub(amount, difference);&#13;
              rawAmount = amount;&#13;
            }&#13;
        }&#13;
&#13;
        amount = getBonusAmountCalculation(amount); // at this point amount bonus is calculated&#13;
&#13;
        CrowdsalePurchase memory purchase = CrowdsalePurchase(purchaser, amount, rawAmount, timestamp);&#13;
        crowdsalePurchases.push(purchase);&#13;
        StarbasePurchasedWithEth(msg.sender, amount, rawAmount, cnyEthRate);&#13;
        crowdsalePurchaseAmountBy[purchaser] = SafeMath.add(crowdsalePurchaseAmountBy[purchaser], amount);&#13;
        totalAmountOfCrowdsalePurchases = totalAmountOfCrowdsalePurchases.add(amount);&#13;
        totalAmountOfCrowdsalePurchasesWithoutBonus = totalAmountOfCrowdsalePurchasesWithoutBonus.add(rawAmount);&#13;
        return amount;&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Calculates amount with bonus for bonus milestones&#13;
     */&#13;
    function calculateBonus&#13;
        (&#13;
            BonusMilestones nextMilestone,&#13;
            uint256 amount,&#13;
            uint256 bonusRange,&#13;
            uint256 bonusTier,&#13;
            uint256 results&#13;
        )&#13;
        internal&#13;
        returns (uint256 result, uint256 newAmount)&#13;
    {&#13;
        uint256 bonusCalc;&#13;
&#13;
        if (amount &lt;= bonusRange) {&#13;
            bonusCalc = amount.mul(bonusTier).div(100);&#13;
&#13;
            if (amount.add(totalAmountOfCrowdsalePurchasesWithoutBonus) &gt;= bonusRange)&#13;
                bonusMilestones = nextMilestone;&#13;
&#13;
            result = results.add(amount).add(bonusCalc);&#13;
            newAmount = 0;&#13;
&#13;
        } else {&#13;
            bonusCalc = bonusRange.mul(bonusTier).div(100);&#13;
            bonusMilestones = nextMilestone;&#13;
            result = results.add(bonusRange).add(bonusCalc);&#13;
            newAmount = amount.sub(bonusRange);&#13;
        }&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Fetchs Bonus tier percentage per bonus milestones&#13;
     */&#13;
    function getBonusAmountCalculation(uint256 amount) internal returns (uint256) {&#13;
        if (block.number &lt; purchaseStartBlock) {&#13;
            uint256 bonusFromAmount = amount.mul(30).div(100); // presale has 30% bonus&#13;
            return amount.add(bonusFromAmount);&#13;
        }&#13;
&#13;
        // range of each bonus milestones&#13;
        uint256 firstBonusRange = firstBonusEnds;&#13;
        uint256 secondBonusRange = secondBonusEnds.sub(firstBonusEnds);&#13;
        uint256 thirdBonusRange = thirdBonusEnds.sub(secondBonusEnds);&#13;
        uint256 fourthBonusRange = fourthBonusEnds.sub(thirdBonusEnds);&#13;
        uint256 result;&#13;
&#13;
        if (bonusMilestones == BonusMilestones.First)&#13;
            (result, amount) = calculateBonus(BonusMilestones.Second, amount, firstBonusRange, 20, result);&#13;
&#13;
        if (bonusMilestones == BonusMilestones.Second)&#13;
            (result, amount) = calculateBonus(BonusMilestones.Third, amount, secondBonusRange, 15, result);&#13;
&#13;
        if (bonusMilestones == BonusMilestones.Third)&#13;
            (result, amount) = calculateBonus(BonusMilestones.Fourth, amount, thirdBonusRange, 10, result);&#13;
&#13;
        if (bonusMilestones == BonusMilestones.Fourth)&#13;
            (result, amount) = calculateBonus(BonusMilestones.Fifth, amount, fourthBonusRange, 5, result);&#13;
&#13;
        return result.add(amount);&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Fetchs Bonus tier percentage per bonus milestones&#13;
     * @dev qualifiedPartner Address of partners that participated in pre sale&#13;
     * @dev amountSent Value sent by qualified partner&#13;
     */&#13;
    function sendQualifiedPartnerCommissionFee(address qualifiedPartner, uint256 amountSent) internal {&#13;
        //calculate the commission fee to send to qualified partner&#13;
        uint256 commissionFeePercentageCalculationAmount = SafeMath.mul(amountSent, qualifiedPartners[qualifiedPartner].commissionFeePercentage) / 100;&#13;
&#13;
        // send commission fee amount&#13;
        qualifiedPartner.transfer(commissionFeePercentageCalculationAmount);&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev redirectToPurchase Redirect to adequate purchase function within the smart contract&#13;
     */&#13;
    function redirectToPurchase() internal {&#13;
        if (block.number &lt; purchaseStartBlock) {&#13;
            purchaseAsQualifiedPartner();&#13;
        } else {&#13;
            purchaseWithEth();&#13;
        }&#13;
    }&#13;
}&#13;
&#13;
/**&#13;
 * @title Starbase Crowdsale Contract Withdrawal contract - Provides an function&#13;
          to withdraw STAR token according to crowdsale results&#13;
 * @author Starbase PTE. LTD. - &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="f69f989099b68582978494978593d89599">[email protected]</a>&gt;&#13;
 */&#13;
contract StarbaseCrowdsaleContractW is Ownable {&#13;
    using SafeMath for uint256;&#13;
&#13;
    /*&#13;
     *  Events&#13;
     */&#13;
    event TokenWithdrawn(address purchaser, uint256 tokenCount);&#13;
    event CrowdsalePurchaseBonusLog(&#13;
        uint256 purchaseIdx, uint256 rawAmount, uint256 bonus);&#13;
&#13;
    /**&#13;
     *  External contracts&#13;
     */&#13;
    AbstractStarbaseToken public starbaseToken;&#13;
    StarbaseCrowdsale public starbaseCrowdsale;&#13;
&#13;
    /**&#13;
     *  Constants&#13;
     */&#13;
    uint256 constant public crowdsaleTokenAmount = 125000000e18;&#13;
    uint256 constant public earlyPurchaseTokenAmount = 50000000e18;&#13;
&#13;
    /**&#13;
     *  Storage&#13;
     */&#13;
&#13;
    // early purchase&#13;
    bool public earlyPurchasesLoaded = false;  // returns whether all early purchases are loaded into this contract&#13;
    uint256 public totalAmountOfEarlyPurchases; // including 20% bonus&#13;
    uint public numOfDeliveredEarlyPurchases;  // index to keep the number of early purchases have already been processed by `withdrawPurchasedTokens`&#13;
&#13;
    // crowdsale&#13;
    uint256 public totalAmountOfCrowdsalePurchases; // in CNY, including bonuses&#13;
    uint256 public totalAmountOfCrowdsalePurchasesWithoutBonus; // in CNY&#13;
    uint256 public startDate;&#13;
    uint256 public endedAt;&#13;
    mapping (address =&gt; uint256) public crowdsalePurchaseAmountBy; // crowdsale purchase amount in CNY per purchasers' address&#13;
    uint public numOfDeliveredCrowdsalePurchases;  // index to keep the number of crowdsale purchases have already been processed by `withdrawPurchasedTokens`&#13;
&#13;
    // crowdsale contract withdrawal&#13;
    bool public crowdsalePurchasesLoaded = false;   // returns whether all crowdsale purchases are loaded into this contract&#13;
    uint256 public numOfLoadedCrowdsalePurchases; // index to keep the number of crowdsale purchases that have already been loaded by `loadCrowdsalePurchases`&#13;
    uint256 public totalAmountOfPresalePurchasesWithoutBonus;  // in CNY&#13;
&#13;
    // bonus milestones&#13;
    uint256 public firstBonusEnds;&#13;
    uint256 public secondBonusEnds;&#13;
    uint256 public thirdBonusEnds;&#13;
    uint256 public fourthBonusEnds;&#13;
&#13;
    // after the crowdsale&#13;
    mapping (address =&gt; bool) public tokenWithdrawn;    // returns whether purchased tokens were withdrawn by a purchaser&#13;
    mapping (address =&gt; uint256) public numOfPurchasedTokensOnCsBy;    // the number of tokens purchased on the crowdsale by a purchaser&#13;
    mapping (address =&gt; uint256) public numOfPurchasedTokensOnEpBy;    // the number of tokens early purchased by a purchaser&#13;
&#13;
    /**&#13;
     *  Modifiers&#13;
     */&#13;
    modifier whenEnded() {&#13;
        assert(isEnded());&#13;
        _;&#13;
    }&#13;
&#13;
    /**&#13;
     * Contract functions&#13;
     */&#13;
&#13;
    /**&#13;
     * @dev Reject all incoming Ether transfers&#13;
     */&#13;
    function () { revert(); }&#13;
&#13;
    /**&#13;
     * External functions&#13;
     */&#13;
&#13;
    /**&#13;
     * @dev Setup function sets external contracts' address&#13;
     * @param starbaseTokenAddress Token address.&#13;
     * @param StarbaseCrowdsaleAddress Token address.&#13;
     */&#13;
    function setup(address starbaseTokenAddress, address StarbaseCrowdsaleAddress)&#13;
        external&#13;
        onlyOwner&#13;
    {&#13;
        require(starbaseTokenAddress != address(0) &amp;&amp; StarbaseCrowdsaleAddress != address(0));&#13;
        require(address(starbaseToken) == 0 &amp;&amp; address(starbaseCrowdsale) == 0);&#13;
&#13;
        starbaseToken = AbstractStarbaseToken(starbaseTokenAddress);&#13;
        starbaseCrowdsale = StarbaseCrowdsale(StarbaseCrowdsaleAddress);&#13;
&#13;
        require(starbaseCrowdsale.startDate() &gt; 0);&#13;
        startDate = starbaseCrowdsale.startDate();&#13;
&#13;
        require(starbaseCrowdsale.endedAt() &gt; 0);&#13;
        endedAt = starbaseCrowdsale.endedAt();&#13;
&#13;
        totalAmountOfEarlyPurchases = starbaseCrowdsale.totalAmountOfEarlyPurchases();&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Load crowdsale purchases from the contract keeps track of them&#13;
     * @param numOfPresalePurchases Number of presale purchase&#13;
     */&#13;
    function loadCrowdsalePurchases(uint256 numOfPresalePurchases)&#13;
        external&#13;
        onlyOwner&#13;
        whenEnded&#13;
    {&#13;
        require(!crowdsalePurchasesLoaded);&#13;
&#13;
        uint256 numOfPurchases = starbaseCrowdsale.numOfPurchases();&#13;
&#13;
        for (uint256 i = numOfLoadedCrowdsalePurchases; i &lt; numOfPurchases &amp;&amp; msg.gas &gt; 200000; i++) {&#13;
            var (purchaser, amount, rawAmount,) =&#13;
                starbaseCrowdsale.crowdsalePurchases(i);&#13;
&#13;
            uint256 bonus;&#13;
            if (i &lt; numOfPresalePurchases) {&#13;
                bonus = rawAmount * 30 / 100;   // presale: 30% bonus&#13;
                totalAmountOfPresalePurchasesWithoutBonus =&#13;
                    totalAmountOfPresalePurchasesWithoutBonus.add(rawAmount);&#13;
            } else {&#13;
                bonus = calculateBonus(rawAmount); // mainsale: 20% ~ 0% bonus&#13;
            }&#13;
&#13;
            // Update amount with bonus&#13;
            CrowdsalePurchaseBonusLog(i, rawAmount, bonus);&#13;
            amount = rawAmount + bonus;&#13;
&#13;
            // Increase the sums&#13;
            crowdsalePurchaseAmountBy[purchaser] = SafeMath.add(crowdsalePurchaseAmountBy[purchaser], amount);&#13;
            totalAmountOfCrowdsalePurchases = totalAmountOfCrowdsalePurchases.add(amount);&#13;
            totalAmountOfCrowdsalePurchasesWithoutBonus = totalAmountOfCrowdsalePurchasesWithoutBonus.add(rawAmount);&#13;
&#13;
            numOfLoadedCrowdsalePurchases++;    // Increase the index&#13;
        }&#13;
&#13;
        assert(numOfLoadedCrowdsalePurchases &lt;= numOfPurchases);&#13;
        if (numOfLoadedCrowdsalePurchases == numOfPurchases) {&#13;
            crowdsalePurchasesLoaded = true;    // enable the flag&#13;
        }&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Deliver tokens to purchasers according to their purchase amount in CNY&#13;
     */&#13;
    function withdrawPurchasedTokens()&#13;
        external&#13;
        whenEnded&#13;
    {&#13;
        require(starbaseCrowdsale.earlyPurchasesLoaded());&#13;
        require(crowdsalePurchasesLoaded);&#13;
        assert(address(starbaseToken) != 0);&#13;
&#13;
        // prevent double withdrawal&#13;
        require(!tokenWithdrawn[msg.sender]);&#13;
        tokenWithdrawn[msg.sender] = true;&#13;
&#13;
        /*&#13;
         * “Value” refers to the contribution of the User:&#13;
         *  {crowdsale_purchaser_token_amount} =&#13;
         *  {crowdsale_token_amount} * {crowdsalePurchase_value} / {earlypurchase_value} + {crowdsale_value}.&#13;
         *&#13;
         * Example: If a User contributes during the Contribution Period 100 CNY (including applicable&#13;
         * Bonus, if any) and the total amount early purchases amounts to 6’000’000 CNY&#13;
         * and total amount raised during the Contribution Period is 30’000’000, then he will get&#13;
         * 347.22 STAR = 125’000’000 STAR * 100 CNY / 30’000’000 CNY + 6’000’000 CNY.&#13;
        */&#13;
&#13;
        if (crowdsalePurchaseAmountBy[msg.sender] &gt; 0) {&#13;
            uint256 crowdsalePurchaseValue = crowdsalePurchaseAmountBy[msg.sender];&#13;
            uint256 tokenCount =&#13;
                SafeMath.mul(crowdsaleTokenAmount, crowdsalePurchaseValue) /&#13;
                totalRaisedAmountInCny();&#13;
&#13;
            numOfPurchasedTokensOnCsBy[msg.sender] =&#13;
                SafeMath.add(numOfPurchasedTokensOnCsBy[msg.sender], tokenCount);&#13;
            assert(starbaseToken.allocateToCrowdsalePurchaser(msg.sender, tokenCount));&#13;
            numOfDeliveredCrowdsalePurchases++;&#13;
            TokenWithdrawn(msg.sender, tokenCount);&#13;
        }&#13;
&#13;
        /*&#13;
         * “Value” refers to the contribution of the User:&#13;
         * {earlypurchaser_token_amount} =&#13;
         * {earlypurchaser_token_amount} * ({earlypurchase_value} / {total_earlypurchase_value})&#13;
         *  + {crowdsale_token_amount} * ({earlypurchase_value} / {earlypurchase_value} + {crowdsale_value}).&#13;
         *&#13;
         * Example: If an Early Purchaser contributes 100 CNY (including Bonus of 20%) and the&#13;
         * total amount of early purchases amounts to 6’000’000 CNY and the total amount raised&#13;
         * during the Contribution Period is 30’000’000 CNY, then he will get 1180.55 STAR =&#13;
         * 50’000’000 STAR * 100 CNY / 6’000’000 CNY + 125’000’000 STAR * 100 CNY /&#13;
         * 30’000’000 CNY + 6’000’000 CNY&#13;
         */&#13;
&#13;
        if (earlyPurchasedAmountBy(msg.sender) &gt; 0) {  // skip if is not an early purchaser&#13;
            uint256 earlyPurchaserPurchaseValue = earlyPurchasedAmountBy(msg.sender);&#13;
            uint256 epTokenCalculationFromEPTokenAmount = SafeMath.mul(earlyPurchaseTokenAmount, earlyPurchaserPurchaseValue) / totalAmountOfEarlyPurchases;&#13;
            uint256 epTokenCalculationFromCrowdsaleTokenAmount = SafeMath.mul(crowdsaleTokenAmount, earlyPurchaserPurchaseValue) / totalRaisedAmountInCny();&#13;
            uint256 epTokenCount = SafeMath.add(epTokenCalculationFromEPTokenAmount, epTokenCalculationFromCrowdsaleTokenAmount);&#13;
&#13;
            numOfPurchasedTokensOnEpBy[msg.sender] = SafeMath.add(numOfPurchasedTokensOnEpBy[msg.sender], epTokenCount);&#13;
            assert(starbaseToken.allocateToCrowdsalePurchaser(msg.sender, epTokenCount));&#13;
            numOfDeliveredEarlyPurchases++;&#13;
            TokenWithdrawn(msg.sender, epTokenCount);&#13;
        }&#13;
    }&#13;
&#13;
    /**&#13;
     * Public functions&#13;
     */&#13;
&#13;
    /**&#13;
     * @dev Returns purchased amount by an early purchaser&#13;
     * @param purchaser Address of an early purchaser&#13;
     */&#13;
    function earlyPurchasedAmountBy(address purchaser)&#13;
        constant&#13;
        public&#13;
        returns (uint256)&#13;
    {&#13;
        return starbaseCrowdsale.earlyPurchasedAmountBy(purchaser);&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Returns boolean for whether crowdsale has ended&#13;
     */&#13;
    function isEnded() constant public returns (bool) {&#13;
        return (starbaseCrowdsale != address(0) &amp;&amp; endedAt &gt; 0);&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Returns total raised amount in CNY (includes EP) and bonuses&#13;
     */&#13;
    function totalRaisedAmountInCny() constant public returns (uint256) {&#13;
        return totalAmountOfEarlyPurchases.add(totalAmountOfCrowdsalePurchases);&#13;
    }&#13;
&#13;
    /**&#13;
     * Internal functions&#13;
     */&#13;
&#13;
    /**&#13;
     * @dev Calculates bonus of a purchase&#13;
     */&#13;
    function calculateBonus(uint256 rawAmount)&#13;
        internal&#13;
        returns (uint256 bonus)&#13;
    {&#13;
        uint256 purchasedAmount =&#13;
            totalAmountOfCrowdsalePurchasesWithoutBonus&#13;
                .sub(totalAmountOfPresalePurchasesWithoutBonus);&#13;
        uint256 e1 = starbaseCrowdsale.firstBonusEnds();&#13;
        uint256 e2 = starbaseCrowdsale.secondBonusEnds();&#13;
        uint256 e3 = starbaseCrowdsale.thirdBonusEnds();&#13;
        uint256 e4 = starbaseCrowdsale.fourthBonusEnds();&#13;
        return calculateBonusInRange(purchasedAmount, rawAmount, 0, e1, 20)&#13;
            .add(calculateBonusInRange(purchasedAmount, rawAmount, e1, e2, 15))&#13;
            .add(calculateBonusInRange(purchasedAmount, rawAmount, e2, e3, 10))&#13;
            .add(calculateBonusInRange(purchasedAmount, rawAmount, e3, e4, 5));&#13;
    }&#13;
&#13;
    function calculateBonusInRange(&#13;
        uint256 purchasedAmount,&#13;
        uint256 rawAmount,&#13;
        uint256 bonusBegin,&#13;
        uint256 bonusEnd,&#13;
        uint256 bonusTier&#13;
    )&#13;
        public&#13;
        constant&#13;
        returns (uint256 bonus)&#13;
    {&#13;
        uint256 sum = purchasedAmount + rawAmount;&#13;
        if (purchasedAmount &gt; bonusEnd || sum &lt; bonusBegin) {&#13;
            return 0;   // out of this range&#13;
        }&#13;
&#13;
        uint256 min = purchasedAmount &lt;= bonusBegin ? bonusBegin : purchasedAmount;&#13;
        uint256 max = bonusEnd &lt;= sum ? bonusEnd : sum;&#13;
        return max.sub(min) * bonusTier / 100;&#13;
    }&#13;
}