pragma solidity ^0.4.13;

/**
 * @title SafeMath
 * @dev Math operations with safety checks that throw on error
 */
library SafeMath {
  function mul(uint256 a, uint256 b) internal constant returns (uint256) {
    uint256 c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }

  function div(uint256 a, uint256 b) internal constant returns (uint256) {
    // assert(b > 0); // Solidity automatically throws when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return c;
  }

  function sub(uint256 a, uint256 b) internal constant returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  function add(uint256 a, uint256 b) internal constant returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }
}

/**
 * @title Ownable
 * @dev The Ownable contract has an owner address, and provides basic authorization control
 * functions, this simplifies the implementation of "user permissions".
 */
contract Ownable {
  address public owner;


  /**
   * @dev The Ownable constructor sets the original `owner` of the contract to the sender
   * account.
   */
  function Ownable() {
    owner = msg.sender;
  }


  /**
   * @dev Throws if called by any account other than the owner.
   */
  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }


  /**
   * @dev Allows the current owner to transfer control of the contract to a newOwner.
   * @param newOwner The address to transfer ownership to.
   */
  function transferOwnership(address newOwner) onlyOwner {
    if (newOwner != address(0)) {
      owner = newOwner;
    }
  }

}

/**
 * @title ERC20Basic
 * @dev Simpler version of ERC20 interface
 * @dev see https://github.com/ethereum/EIPs/issues/179
 */
contract ERC20Basic {
  uint256 public totalSupply;
  function balanceOf(address who) constant returns (uint256);
  function transfer(address to, uint256 value) returns (bool);
  event Transfer(address indexed from, address indexed to, uint256 value);
}

/**
 * @title ERC20 interface
 * @dev see https://github.com/ethereum/EIPs/issues/20
 */
contract ERC20 is ERC20Basic {
  function allowance(address owner, address spender) constant returns (uint256);
  function transferFrom(address from, address to, uint256 value) returns (bool);
  function approve(address spender, uint256 value) returns (bool);
  event Approval(address indexed owner, address indexed spender, uint256 value);
}

contract AbstractStarbaseToken is ERC20 {
    function isFundraiser(address fundraiserAddress) public returns (bool);
    function company() public returns (address);
    function allocateToCrowdsalePurchaser(address to, uint256 value) public returns (bool);
    function allocateToMarketingSupporter(address to, uint256 value) public returns (bool);
}

contract AbstractStarbaseCrowdsale {
    function workshop() constant returns (address) {}
    function startDate() constant returns (uint256) {}
    function endedAt() constant returns (uint256) {}
    function isEnded() constant returns (bool);
    function totalRaisedAmountInCny() constant returns (uint256);
    function numOfPurchasedTokensOnCsBy(address purchaser) constant returns (uint256);
    function numOfPurchasedTokensOnEpBy(address purchaser) constant returns (uint256);
}

// @title EarlyPurchase contract - Keep track of purchased amount by Early Purchasers
/// @author Starbase PTE. LTD. - <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="ea83848c85aa999e8b98888b998fc48985">[email protected]</a>&gt;&#13;
contract StarbaseEarlyPurchase {&#13;
    /*&#13;
     *  Constants&#13;
     */&#13;
    string public constant PURCHASE_AMOUNT_UNIT = 'CNY';    // Chinese Yuan&#13;
    string public constant PURCHASE_AMOUNT_RATE_REFERENCE = 'http://www.xe.com/currencytables/';&#13;
    uint256 public constant PURCHASE_AMOUNT_CAP = 9000000;&#13;
&#13;
    /*&#13;
     *  Types&#13;
     */&#13;
    struct EarlyPurchase {&#13;
        address purchaser;&#13;
        uint256 amount;        // CNY based amount&#13;
        uint256 purchasedAt;   // timestamp&#13;
    }&#13;
&#13;
    /*&#13;
     *  External contracts&#13;
     */&#13;
    AbstractStarbaseCrowdsale public starbaseCrowdsale;&#13;
&#13;
    /*&#13;
     *  Storage&#13;
     */&#13;
    address public owner;&#13;
    EarlyPurchase[] public earlyPurchases;&#13;
    uint256 public earlyPurchaseClosedAt;&#13;
&#13;
    /*&#13;
     *  Modifiers&#13;
     */&#13;
    modifier noEther() {&#13;
        require(msg.value == 0);&#13;
        _;&#13;
    }&#13;
&#13;
    modifier onlyOwner() {&#13;
        require(msg.sender == owner);&#13;
        _;&#13;
    }&#13;
&#13;
    modifier onlyBeforeCrowdsale() {&#13;
        assert(address(starbaseCrowdsale) == address(0) || starbaseCrowdsale.startDate() == 0);&#13;
        _;&#13;
    }&#13;
&#13;
    modifier onlyEarlyPurchaseTerm() {&#13;
        assert(earlyPurchaseClosedAt &lt;= 0);&#13;
        _;&#13;
    }&#13;
&#13;
    /*&#13;
     *  Contract functions&#13;
     */&#13;
&#13;
    /**&#13;
     * @dev Returns early purchased amount by purchaser's address&#13;
     * @param purchaser Purchaser address&#13;
     */&#13;
    function purchasedAmountBy(address purchaser)&#13;
        external&#13;
        constant&#13;
        noEther&#13;
        returns (uint256 amount)&#13;
    {&#13;
        for (uint256 i; i &lt; earlyPurchases.length; i++) {&#13;
            if (earlyPurchases[i].purchaser == purchaser) {&#13;
                amount += earlyPurchases[i].amount;&#13;
            }&#13;
        }&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Returns total amount of raised funds by Early Purchasers&#13;
     */&#13;
    function totalAmountOfEarlyPurchases()&#13;
        constant&#13;
        noEther&#13;
        public&#13;
        returns (uint256 totalAmount)&#13;
    {&#13;
        for (uint256 i; i &lt; earlyPurchases.length; i++) {&#13;
            totalAmount += earlyPurchases[i].amount;&#13;
        }&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Returns number of early purchases&#13;
     */&#13;
    function numberOfEarlyPurchases()&#13;
        external&#13;
        constant&#13;
        noEther&#13;
        returns (uint256)&#13;
    {&#13;
        return earlyPurchases.length;&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Append an early purchase log&#13;
     * @param purchaser Purchaser address&#13;
     * @param amount Purchase amount&#13;
     * @param purchasedAt Timestamp of purchased date&#13;
     */&#13;
    function appendEarlyPurchase(address purchaser, uint256 amount, uint256 purchasedAt)&#13;
        external&#13;
        noEther&#13;
        onlyOwner&#13;
        onlyBeforeCrowdsale&#13;
        onlyEarlyPurchaseTerm&#13;
        returns (bool)&#13;
    {&#13;
        if (amount == 0 ||&#13;
            totalAmountOfEarlyPurchases() + amount &gt; PURCHASE_AMOUNT_CAP)&#13;
        {&#13;
            return false;&#13;
        }&#13;
&#13;
        assert(purchasedAt != 0 || purchasedAt &lt;= now);&#13;
&#13;
        earlyPurchases.push(EarlyPurchase(purchaser, amount, purchasedAt));&#13;
        return true;&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Close early purchase term&#13;
     */&#13;
    function closeEarlyPurchase()&#13;
        external&#13;
        noEther&#13;
        onlyOwner&#13;
        returns (bool)&#13;
    {&#13;
        earlyPurchaseClosedAt = now;&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Setup function sets external contract's address&#13;
     * @param starbaseCrowdsaleAddress Token address&#13;
     */&#13;
    function setup(address starbaseCrowdsaleAddress)&#13;
        external&#13;
        noEther&#13;
        onlyOwner&#13;
        returns (bool)&#13;
    {&#13;
        if (address(starbaseCrowdsale) == 0) {&#13;
            starbaseCrowdsale = AbstractStarbaseCrowdsale(starbaseCrowdsaleAddress);&#13;
            return true;&#13;
        }&#13;
        return false;&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Contract constructor function&#13;
     */&#13;
    function StarbaseEarlyPurchase() noEther {&#13;
        owner = msg.sender;&#13;
    }&#13;
}&#13;
&#13;
&#13;
/// @title EarlyPurchaseAmendment contract - Amend early purchase records of the original contract&#13;
/// @author Starbase PTE. LTD. - &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="1f6c6a6f6f706d6b5f6c6b7e6d7d7e6c7a317c70">[email protected]</a>&gt;&#13;
contract StarbaseEarlyPurchaseAmendment {&#13;
    /*&#13;
     *  Events&#13;
     */&#13;
    event EarlyPurchaseInvalidated(uint256 epIdx);&#13;
    event EarlyPurchaseAmended(uint256 epIdx);&#13;
&#13;
    /*&#13;
     *  External contracts&#13;
     */&#13;
    AbstractStarbaseCrowdsale public starbaseCrowdsale;&#13;
    StarbaseEarlyPurchase public starbaseEarlyPurchase;&#13;
&#13;
    /*&#13;
     *  Storage&#13;
     */&#13;
    address public owner;&#13;
    uint256[] public invalidEarlyPurchaseIndexes;&#13;
    uint256[] public amendedEarlyPurchaseIndexes;&#13;
    mapping (uint256 =&gt; StarbaseEarlyPurchase.EarlyPurchase) public amendedEarlyPurchases;&#13;
&#13;
    /*&#13;
     *  Modifiers&#13;
     */&#13;
    modifier noEther() {&#13;
        require(msg.value == 0);&#13;
        _;&#13;
    }&#13;
&#13;
    modifier onlyOwner() {&#13;
        require(msg.sender == owner);&#13;
        _;&#13;
    }&#13;
&#13;
    modifier onlyBeforeCrowdsale() {&#13;
        assert(address(starbaseCrowdsale) == address(0) || starbaseCrowdsale.startDate() == 0);&#13;
        _;&#13;
    }&#13;
&#13;
    modifier onlyEarlyPurchasesLoaded() {&#13;
        assert(address(starbaseEarlyPurchase) != address(0));&#13;
        _;&#13;
    }&#13;
&#13;
    /*&#13;
     *  Functions below are compatible with starbaseEarlyPurchase contract&#13;
     */&#13;
&#13;
    /**&#13;
     * @dev Returns an early purchase record&#13;
     * @param earlyPurchaseIndex Index number of an early purchase&#13;
     */&#13;
    function earlyPurchases(uint256 earlyPurchaseIndex)&#13;
        external&#13;
        constant&#13;
        onlyEarlyPurchasesLoaded&#13;
        returns (address purchaser, uint256 amount, uint256 purchasedAt)&#13;
    {&#13;
        return starbaseEarlyPurchase.earlyPurchases(earlyPurchaseIndex);&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Returns early purchased amount by purchaser's address&#13;
     * @param purchaser Purchaser address&#13;
     */&#13;
    function purchasedAmountBy(address purchaser)&#13;
        external&#13;
        constant&#13;
        noEther&#13;
        returns (uint256 amount)&#13;
    {&#13;
        StarbaseEarlyPurchase.EarlyPurchase[] memory normalizedEP =&#13;
            normalizedEarlyPurchases();&#13;
        for (uint256 i; i &lt; normalizedEP.length; i++) {&#13;
            if (normalizedEP[i].purchaser == purchaser) {&#13;
                amount += normalizedEP[i].amount;&#13;
            }&#13;
        }&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Returns total amount of raised funds by Early Purchasers&#13;
     */&#13;
    function totalAmountOfEarlyPurchases()&#13;
        constant&#13;
        noEther&#13;
        public&#13;
        returns (uint256 totalAmount)&#13;
    {&#13;
        StarbaseEarlyPurchase.EarlyPurchase[] memory normalizedEP =&#13;
            normalizedEarlyPurchases();&#13;
        for (uint256 i; i &lt; normalizedEP.length; i++) {&#13;
            totalAmount += normalizedEP[i].amount;&#13;
        }&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Returns number of early purchases&#13;
     */&#13;
    function numberOfEarlyPurchases()&#13;
        external&#13;
        constant&#13;
        noEther&#13;
        returns (uint256)&#13;
    {&#13;
        return normalizedEarlyPurchases().length;&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Sets up function sets external contract's address&#13;
     * @param starbaseCrowdsaleAddress Token address&#13;
     */&#13;
    function setup(address starbaseCrowdsaleAddress)&#13;
        external&#13;
        noEther&#13;
        onlyOwner&#13;
        returns (bool)&#13;
    {&#13;
        if (address(starbaseCrowdsale) == 0) {&#13;
            starbaseCrowdsale = AbstractStarbaseCrowdsale(starbaseCrowdsaleAddress);&#13;
            return true;&#13;
        }&#13;
        return false;&#13;
    }&#13;
&#13;
    /*&#13;
     *  Contract functions unique to StarbaseEarlyPurchaseAmendment&#13;
     */&#13;
&#13;
     /**&#13;
      * @dev Invalidate early purchase&#13;
      * @param earlyPurchaseIndex Index number of the purchase&#13;
      */&#13;
    function invalidateEarlyPurchase(uint256 earlyPurchaseIndex)&#13;
        external&#13;
        noEther&#13;
        onlyOwner&#13;
        onlyEarlyPurchasesLoaded&#13;
        onlyBeforeCrowdsale&#13;
        returns (bool)&#13;
    {&#13;
        assert(numberOfRawEarlyPurchases() &gt; earlyPurchaseIndex); // Array Index Out of Bounds Exception&#13;
&#13;
        for (uint256 i; i &lt; invalidEarlyPurchaseIndexes.length; i++) {&#13;
            assert(invalidEarlyPurchaseIndexes[i] != earlyPurchaseIndex);&#13;
        }&#13;
&#13;
        invalidEarlyPurchaseIndexes.push(earlyPurchaseIndex);&#13;
        EarlyPurchaseInvalidated(earlyPurchaseIndex);&#13;
        return true;&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Checks whether early purchase is invalid&#13;
     * @param earlyPurchaseIndex Index number of the purchase&#13;
     */&#13;
    function isInvalidEarlyPurchase(uint256 earlyPurchaseIndex)&#13;
        constant&#13;
        noEther&#13;
        public&#13;
        returns (bool)&#13;
    {&#13;
        assert(numberOfRawEarlyPurchases() &gt; earlyPurchaseIndex); // Array Index Out of Bounds Exception&#13;
&#13;
&#13;
        for (uint256 i; i &lt; invalidEarlyPurchaseIndexes.length; i++) {&#13;
            if (invalidEarlyPurchaseIndexes[i] == earlyPurchaseIndex) {&#13;
                return true;&#13;
            }&#13;
        }&#13;
        return false;&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Amends a given early purchase with data&#13;
     * @param earlyPurchaseIndex Index number of the purchase&#13;
     * @param purchaser Purchaser's address&#13;
     * @param amount Value of purchase&#13;
     * @param purchasedAt Purchase timestamp&#13;
     */&#13;
    function amendEarlyPurchase(uint256 earlyPurchaseIndex, address purchaser, uint256 amount, uint256 purchasedAt)&#13;
        external&#13;
        noEther&#13;
        onlyOwner&#13;
        onlyEarlyPurchasesLoaded&#13;
        onlyBeforeCrowdsale&#13;
        returns (bool)&#13;
    {&#13;
        assert(purchasedAt != 0 || purchasedAt &lt;= now);&#13;
&#13;
        assert(numberOfRawEarlyPurchases() &gt; earlyPurchaseIndex);&#13;
&#13;
        assert(!isInvalidEarlyPurchase(earlyPurchaseIndex)); // Invalid early purchase cannot be amended&#13;
&#13;
        if (!isAmendedEarlyPurchase(earlyPurchaseIndex)) {&#13;
            amendedEarlyPurchaseIndexes.push(earlyPurchaseIndex);&#13;
        }&#13;
&#13;
        amendedEarlyPurchases[earlyPurchaseIndex] =&#13;
            StarbaseEarlyPurchase.EarlyPurchase(purchaser, amount, purchasedAt);&#13;
        EarlyPurchaseAmended(earlyPurchaseIndex);&#13;
        return true;&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Checks whether early purchase is amended&#13;
     * @param earlyPurchaseIndex Index number of the purchase&#13;
     */&#13;
    function isAmendedEarlyPurchase(uint256 earlyPurchaseIndex)&#13;
        constant&#13;
        noEther&#13;
        returns (bool)&#13;
    {&#13;
        assert(numberOfRawEarlyPurchases() &gt; earlyPurchaseIndex); // Array Index Out of Bounds Exception&#13;
&#13;
        for (uint256 i; i &lt; amendedEarlyPurchaseIndexes.length; i++) {&#13;
            if (amendedEarlyPurchaseIndexes[i] == earlyPurchaseIndex) {&#13;
                return true;&#13;
            }&#13;
        }&#13;
        return false;&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Loads early purchases data to StarbaseEarlyPurchaseAmendment contract&#13;
     * @param starbaseEarlyPurchaseAddress Address from starbase early purchase&#13;
     */&#13;
    function loadStarbaseEarlyPurchases(address starbaseEarlyPurchaseAddress)&#13;
        external&#13;
        noEther&#13;
        onlyOwner&#13;
        onlyBeforeCrowdsale&#13;
        returns (bool)&#13;
    {&#13;
        assert(starbaseEarlyPurchaseAddress != 0 ||&#13;
            address(starbaseEarlyPurchase) == 0);&#13;
&#13;
        starbaseEarlyPurchase = StarbaseEarlyPurchase(starbaseEarlyPurchaseAddress);&#13;
        assert(starbaseEarlyPurchase.earlyPurchaseClosedAt() != 0); // the early purchase must be closed&#13;
&#13;
        return true;&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Contract constructor function. It sets owner&#13;
     */&#13;
    function StarbaseEarlyPurchaseAmendment() noEther {&#13;
        owner = msg.sender;&#13;
    }&#13;
&#13;
    /**&#13;
     * Internal functions&#13;
     */&#13;
&#13;
    /**&#13;
     * @dev Normalizes early purchases data&#13;
     */&#13;
    function normalizedEarlyPurchases()&#13;
        constant&#13;
        internal&#13;
        returns (StarbaseEarlyPurchase.EarlyPurchase[] normalizedEP)&#13;
    {&#13;
        uint256 rawEPCount = numberOfRawEarlyPurchases();&#13;
        normalizedEP = new StarbaseEarlyPurchase.EarlyPurchase[](&#13;
            rawEPCount - invalidEarlyPurchaseIndexes.length);&#13;
&#13;
        uint256 normalizedIdx;&#13;
        for (uint256 i; i &lt; rawEPCount; i++) {&#13;
            if (isInvalidEarlyPurchase(i)) {&#13;
                continue;   // invalid early purchase should be ignored&#13;
            }&#13;
&#13;
            StarbaseEarlyPurchase.EarlyPurchase memory ep;&#13;
            if (isAmendedEarlyPurchase(i)) {&#13;
                ep = amendedEarlyPurchases[i];  // amended early purchase should take a priority&#13;
            } else {&#13;
                ep = getEarlyPurchase(i);&#13;
            }&#13;
&#13;
            normalizedEP[normalizedIdx] = ep;&#13;
            normalizedIdx++;&#13;
        }&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Fetches early purchases data&#13;
     */&#13;
    function getEarlyPurchase(uint256 earlyPurchaseIndex)&#13;
        internal&#13;
        constant&#13;
        onlyEarlyPurchasesLoaded&#13;
        returns (StarbaseEarlyPurchase.EarlyPurchase)&#13;
    {&#13;
        var (purchaser, amount, purchasedAt) =&#13;
            starbaseEarlyPurchase.earlyPurchases(earlyPurchaseIndex);&#13;
        return StarbaseEarlyPurchase.EarlyPurchase(purchaser, amount, purchasedAt);&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Returns raw number of early purchases&#13;
     */&#13;
    function numberOfRawEarlyPurchases()&#13;
        internal&#13;
        constant&#13;
        onlyEarlyPurchasesLoaded&#13;
        returns (uint256)&#13;
    {&#13;
        return starbaseEarlyPurchase.numberOfEarlyPurchases();&#13;
    }&#13;
}&#13;
&#13;
&#13;
/**&#13;
 * @title Crowdsale contract - Starbase crowdsale to create STAR.&#13;
 * @author Starbase PTE. LTD. - &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="1871767e77586b6c796a7a796b7d367b77">[email protected]</a>&gt;&#13;
 */&#13;
contract StarbaseCrowdsale is Ownable {&#13;
    /*&#13;
     *  Events&#13;
     */&#13;
    event CrowdsaleEnded(uint256 endedAt);&#13;
    event StarBasePurchasedWithEth(address purchaser, uint256 amount, uint256 rawAmount, uint256 cnyEthRate, uint256 bonusTokensPercentage);&#13;
    event StarBasePurchasedOffChain(address purchaser, uint256 amount, uint256 rawAmount, uint256 cnyBtcRate, uint256 bonusTokensPercentage, string data);&#13;
    event CnyEthRateUpdated(uint256 cnyEthRate);&#13;
    event CnyBtcRateUpdated(uint256 cnyBtcRate);&#13;
    event QualifiedPartnerAddress(address qualifiedPartner);&#13;
    event PurchaseInvalidated(uint256 purchaseIdx);&#13;
    event PurchaseAmended(uint256 purchaseIdx);&#13;
&#13;
    /**&#13;
     *  External contracts&#13;
     */&#13;
    AbstractStarbaseToken public starbaseToken;&#13;
    StarbaseEarlyPurchaseAmendment public starbaseEpAmendment;&#13;
&#13;
    /**&#13;
     *  Constants&#13;
     */&#13;
    uint256 constant public crowdsaleTokenAmount = 125000000e18;&#13;
    uint256 constant public earlyPurchaseTokenAmount = 50000000e18;&#13;
    uint256 constant public MIN_INVESTMENT = 1; // min is 1 Wei&#13;
    uint256 constant public MAX_CROWDSALE_CAP = 60000000; // approximately 9M USD for the crowdsale(CS). 1M (by EP) + 9M (by CS) = 10M (Total)&#13;
    string public constant PURCHASE_AMOUNT_UNIT = 'CNY';  // Chinese Yuan&#13;
&#13;
    /**&#13;
     * Types&#13;
     */&#13;
    struct CrowdsalePurchase {&#13;
        address purchaser;&#13;
        uint256 amount;        // CNY based amount with bonus&#13;
        uint256 rawAmount;     // CNY based amount no bonus&#13;
        uint256 purchasedAt;   // timestamp&#13;
        string data;           // additional data (e.g. Tx ID of Bitcoin)&#13;
        uint256 bonus;&#13;
    }&#13;
&#13;
    struct QualifiedPartners {&#13;
        uint256 amountCap;&#13;
        uint256 amountRaised;&#13;
        bool    bonaFide;&#13;
        uint256 commissionFeePercentage; // example 5 will calculate the percentage as 5%&#13;
    }&#13;
&#13;
    /**&#13;
     *  Storage&#13;
     */&#13;
    address public workshop; // holds undelivered STARs&#13;
&#13;
    uint public numOfDeliveredCrowdsalePurchases = 0;  // index to keep the number of crowdsale purchases have already been processed by `deliverPurchasedTokens`&#13;
    uint public numOfDeliveredEarlyPurchases = 0;  // index to keep the number of early purchases have already been processed by `deliverPurchasedTokens`&#13;
    uint256 public numOfLoadedEarlyPurchases = 0; // index to keep the number of early purchases that have already been loaded by `loadEarlyPurchases`&#13;
&#13;
    address[] public earlyPurchasers;&#13;
    mapping (address =&gt; QualifiedPartners) public qualifiedPartners;&#13;
    mapping (address =&gt; uint256) public earlyPurchasedAmountBy; // early purchased amount in CNY per purchasers' address&#13;
    bool public earlyPurchasesLoaded = false;  // returns whether all early purchases are loaded into this contract&#13;
&#13;
    // crowdsale&#13;
    uint256 public purchaseStartBlock;  // crowdsale purchases can be accepted from this block number&#13;
    uint256 public startDate;&#13;
    uint256 public endedAt;&#13;
    CrowdsalePurchase[] public crowdsalePurchases;&#13;
    uint256 public cnyBtcRate; // this rate won't be used from a smart contract function but external system&#13;
    uint256 public cnyEthRate;&#13;
&#13;
    // bonus milestones&#13;
    uint256 public firstBonusSalesEnds;&#13;
    uint256 public secondBonusSalesEnds;&#13;
    uint256 public thirdBonusSalesEnds;&#13;
    uint256 public fourthBonusSalesEnds;&#13;
    uint256 public fifthBonusSalesEnds;&#13;
    uint256 public firstExtendedBonusSalesEnds;&#13;
    uint256 public secondExtendedBonusSalesEnds;&#13;
    uint256 public thirdExtendedBonusSalesEnds;&#13;
    uint256 public fourthExtendedBonusSalesEnds;&#13;
    uint256 public fifthExtendedBonusSalesEnds;&#13;
    uint256 public sixthExtendedBonusSalesEnds;&#13;
&#13;
    // after the crowdsale&#13;
    mapping(uint256 =&gt; CrowdsalePurchase) public invalidatedOrigPurchases;  // Original purchase which was invalidated by owner&#13;
    mapping(uint256 =&gt; CrowdsalePurchase) public amendedOrigPurchases;      // Original purchase which was amended by owner&#13;
&#13;
    mapping (address =&gt; uint256) public numOfPurchasedTokensOnCsBy;    // the number of tokens purchased on the crowdsale by a purchaser&#13;
    mapping (address =&gt; uint256) public numOfPurchasedTokensOnEpBy;    // the number of tokens early purchased by a purchaser&#13;
&#13;
    /**&#13;
     *  Modifiers&#13;
     */&#13;
    modifier minInvestment() {&#13;
        // User has to send at least the ether value of one token.&#13;
        assert(msg.value &gt;= MIN_INVESTMENT);&#13;
        _;&#13;
    }&#13;
&#13;
    modifier whenEnded() {&#13;
        assert(isEnded());&#13;
        _;&#13;
    }&#13;
&#13;
    modifier hasBalance() {&#13;
        assert(this.balance &gt; 0);&#13;
        _;&#13;
    }&#13;
    modifier rateIsSet(uint256 _rate) {&#13;
        assert(_rate != 0);&#13;
        _;&#13;
    }&#13;
&#13;
    modifier whenNotEnded() {&#13;
        assert(!isEnded());&#13;
        _;&#13;
    }&#13;
&#13;
    modifier tokensNotDelivered() {&#13;
        assert(numOfDeliveredCrowdsalePurchases == 0);&#13;
        assert(numOfDeliveredEarlyPurchases == 0);&#13;
        _;&#13;
    }&#13;
&#13;
    modifier onlyFundraiser() {&#13;
      assert(address(starbaseToken) != 0);&#13;
      assert(starbaseToken.isFundraiser(msg.sender));&#13;
      _;&#13;
    }&#13;
&#13;
    /**&#13;
     * Contract functions&#13;
     */&#13;
&#13;
    /**&#13;
     * @dev Contract constructor function sets owner and start date.&#13;
     * @param workshopAddr The address that will hold undelivered Star tokens&#13;
     * @param starbaseEpAddr The address that holds the early purchasers Star tokens&#13;
     */&#13;
    function StarbaseCrowdsale(address workshopAddr, address starbaseEpAddr) {&#13;
        require(workshopAddr != 0 &amp;&amp; starbaseEpAddr != 0);&#13;
&#13;
        owner = msg.sender;&#13;
        workshop = workshopAddr;&#13;
        starbaseEpAmendment = StarbaseEarlyPurchaseAmendment(starbaseEpAddr);&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Fallback accepts payment for Star tokens with Eth&#13;
     */&#13;
    function() payable {&#13;
        redirectToPurchase();&#13;
    }&#13;
&#13;
    /**&#13;
     * External functions&#13;
     */&#13;
&#13;
    /**&#13;
     * @dev Setup function sets external contracts' addresses.&#13;
     * @param starbaseTokenAddress Token address.&#13;
     * @param _purchaseStartBlock Block number to start crowdsale&#13;
     */&#13;
    function setup(address starbaseTokenAddress, uint256 _purchaseStartBlock)&#13;
        external&#13;
        onlyOwner&#13;
        returns (bool)&#13;
    {&#13;
        assert(address(starbaseToken) == 0);&#13;
        starbaseToken = AbstractStarbaseToken(starbaseTokenAddress);&#13;
        purchaseStartBlock = _purchaseStartBlock;&#13;
        return true;&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Allows owner to record a purchase made outside of Ethereum blockchain&#13;
     * @param purchaser Address of a purchaser&#13;
     * @param rawAmount Purchased amount in CNY&#13;
     * @param purchasedAt Timestamp at the purchase made&#13;
     * @param data Identifier as an evidence of the purchase (e.g. btc:1xyzxyz)&#13;
     */&#13;
    function recordOffchainPurchase(&#13;
        address purchaser,&#13;
        uint256 rawAmount,&#13;
        uint256 purchasedAt,&#13;
        string data&#13;
    )&#13;
        external&#13;
        onlyFundraiser&#13;
        whenNotEnded&#13;
        rateIsSet(cnyBtcRate)&#13;
        returns (bool)&#13;
    {&#13;
        require(purchaseStartBlock &gt; 0 &amp;&amp; block.number &gt;= purchaseStartBlock);&#13;
        if (startDate == 0) {&#13;
            startCrowdsale(block.timestamp);&#13;
        }&#13;
&#13;
        uint256 bonusTier = getBonusTier();&#13;
        uint amount = recordPurchase(purchaser, rawAmount, purchasedAt, data, bonusTier);&#13;
&#13;
        StarBasePurchasedOffChain(purchaser, amount, rawAmount, cnyBtcRate, bonusTier, data);&#13;
        return true;&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Transfers raised funds to company's wallet address at any given time.&#13;
     */&#13;
    function withdrawForCompany()&#13;
        external&#13;
        onlyFundraiser&#13;
        hasBalance&#13;
    {&#13;
        address company = starbaseToken.company();&#13;
        require(company != address(0));&#13;
        company.transfer(this.balance);&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Update the CNY/ETH rate to record purchases in CNY&#13;
     */&#13;
    function updateCnyEthRate(uint256 rate)&#13;
        external&#13;
        onlyFundraiser&#13;
        returns (bool)&#13;
    {&#13;
        cnyEthRate = rate;&#13;
        CnyEthRateUpdated(cnyEthRate);&#13;
        return true;&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Update the CNY/BTC rate to record purchases in CNY&#13;
     */&#13;
    function updateCnyBtcRate(uint256 rate)&#13;
        external&#13;
        onlyFundraiser&#13;
        returns (bool)&#13;
    {&#13;
        cnyBtcRate = rate;&#13;
        CnyBtcRateUpdated(cnyBtcRate);&#13;
        return true;&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Allow for the possibilyt for contract owner to start crowdsale&#13;
     */&#13;
    function ownerStartsCrowdsale(uint256 timestamp)&#13;
        external&#13;
        onlyOwner&#13;
    {&#13;
        assert(startDate == 0 &amp;&amp; block.number &gt;= purchaseStartBlock);   // overwriting startDate is not permitted and it should be after the crowdsale start block&#13;
        startCrowdsale(timestamp);&#13;
&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Ends crowdsale&#13;
     * @param timestamp Timestamp at the crowdsale ended&#13;
     */&#13;
    function endCrowdsale(uint256 timestamp)&#13;
        external&#13;
        onlyOwner&#13;
    {&#13;
        assert(timestamp &gt; 0 &amp;&amp; timestamp &lt;= now);&#13;
        assert(endedAt == 0);   // overwriting time is not permitted&#13;
        endedAt = timestamp;&#13;
        CrowdsaleEnded(endedAt);&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Invalidate a crowdsale purchase if something is wrong with it&#13;
     * @param purchaseIdx Index number of the crowdsalePurchases to invalidate&#13;
     */&#13;
    function invalidatePurchase(uint256 purchaseIdx)&#13;
        external&#13;
        onlyOwner&#13;
        whenEnded&#13;
        tokensNotDelivered&#13;
        returns (bool)&#13;
    {&#13;
        CrowdsalePurchase memory purchase = crowdsalePurchases[purchaseIdx];&#13;
        assert(purchase.purchaser != 0 &amp;&amp; purchase.amount != 0);&#13;
&#13;
        crowdsalePurchases[purchaseIdx].amount = 0;&#13;
        crowdsalePurchases[purchaseIdx].rawAmount = 0;&#13;
        invalidatedOrigPurchases[purchaseIdx] = purchase;&#13;
        PurchaseInvalidated(purchaseIdx);&#13;
        return true;&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Amend a crowdsale purchase if something is wrong with it&#13;
     * @param purchaseIdx Index number of the crowdsalePurchases to invalidate&#13;
     * @param purchaser Address of the buyer&#13;
     * @param amount Purchased tokens as per the CNY rate used&#13;
     * @param rawAmount Purchased tokens as per the CNY rate used without the bonus&#13;
     * @param purchasedAt Timestamp at the purchase made&#13;
     * @param data Identifier as an evidence of the purchase (e.g. btc:1xyzxyz)&#13;
     * @param bonus bonus milestones of the purchase&#13;
     */&#13;
    function amendPurchase(&#13;
        uint256 purchaseIdx,&#13;
        address purchaser,&#13;
        uint256 amount,&#13;
        uint256 rawAmount,&#13;
        uint256 purchasedAt,&#13;
        string data,&#13;
        uint256 bonus&#13;
    )&#13;
        external&#13;
        onlyOwner&#13;
        whenEnded&#13;
        tokensNotDelivered&#13;
        returns (bool)&#13;
    {&#13;
        CrowdsalePurchase memory purchase = crowdsalePurchases[purchaseIdx];&#13;
        assert(purchase.purchaser != 0 &amp;&amp; purchase.amount != 0);&#13;
&#13;
        amendedOrigPurchases[purchaseIdx] = purchase;&#13;
        crowdsalePurchases[purchaseIdx] =&#13;
            CrowdsalePurchase(purchaser, amount, rawAmount, purchasedAt, data, bonus);&#13;
        PurchaseAmended(purchaseIdx);&#13;
        return true;&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Deliver tokens to purchasers according to their purchase amount in CNY&#13;
     */&#13;
    function deliverPurchasedTokens()&#13;
        external&#13;
        onlyOwner&#13;
        whenEnded&#13;
        returns (bool)&#13;
    {&#13;
        assert(earlyPurchasesLoaded);&#13;
        assert(address(starbaseToken) != 0);&#13;
&#13;
        uint256 totalAmountOfPurchasesInCny = totalRaisedAmountInCny(); // totalPreSale + totalCrowdsale&#13;
&#13;
        for (uint256 i = numOfDeliveredCrowdsalePurchases; i &lt; crowdsalePurchases.length &amp;&amp; msg.gas &gt; 200000; i++) {&#13;
            CrowdsalePurchase memory purchase = crowdsalePurchases[i];&#13;
            if (purchase.amount == 0) {&#13;
                continue;   // skip invalidated purchase&#13;
            }&#13;
&#13;
            /*&#13;
             * “Value” refers to the contribution of the User:&#13;
             *  {crowdsale_purchaser_token_amount} =&#13;
             *  {crowdsale_token_amount} * {crowdsalePurchase_value} / {earlypurchase_value} + {crowdsale_value}.&#13;
             *&#13;
             * Example: If a User contributes during the Contribution Period 100 CNY (including applicable&#13;
             * Bonus, if any) and the total amount early purchases amounts to 6’000’000 CNY&#13;
             * and total amount raised during the Contribution Period is 30’000’000, then he will get&#13;
             * 347.22 STAR = 125’000’000 STAR * 100 CNY / 30’000’000 CNY + 6’000’000 CNY.&#13;
            */&#13;
&#13;
            uint256 crowdsalePurchaseValue = purchase.amount;&#13;
            uint256 tokenCount = SafeMath.mul(crowdsaleTokenAmount, crowdsalePurchaseValue) / totalAmountOfPurchasesInCny;&#13;
&#13;
            numOfPurchasedTokensOnCsBy[purchase.purchaser] = SafeMath.add(numOfPurchasedTokensOnCsBy[purchase.purchaser], tokenCount);&#13;
            starbaseToken.allocateToCrowdsalePurchaser(purchase.purchaser, tokenCount);&#13;
            numOfDeliveredCrowdsalePurchases = SafeMath.add(i, 1);&#13;
        }&#13;
&#13;
        for (uint256 j = numOfDeliveredEarlyPurchases; j &lt; earlyPurchasers.length &amp;&amp; msg.gas &gt; 200000; j++) {&#13;
            address earlyPurchaser = earlyPurchasers[j];&#13;
&#13;
            /*&#13;
             * “Value” refers to the contribution of the User:&#13;
             * {earlypurchaser_token_amount} =&#13;
             * {earlypurchaser_token_amount} * ({earlypurchase_value} / {total_earlypurchase_value})&#13;
             *  + {crowdsale_token_amount} * ({earlypurchase_value} / {earlypurchase_value} + {crowdsale_value}).&#13;
             *&#13;
             * Example: If an Early Purchaser contributes 100 CNY (including Bonus of 20%) and the&#13;
             * total amount of early purchases amounts to 6’000’000 CNY and the total amount raised&#13;
             * during the Contribution Period is 30’000’000 CNY, then he will get 1180.55 STAR =&#13;
             * 50’000’000 STAR * 100 CNY / 6’000’000 CNY + 125’000’000 STAR * 100 CNY /&#13;
             * 30’000’000 CNY + 6’000’000 CNY&#13;
             */&#13;
&#13;
            uint256 earlyPurchaserPurchaseValue = earlyPurchasedAmountBy[earlyPurchaser];&#13;
&#13;
            uint256 epTokenCalculationFromEPTokenAmount = SafeMath.mul(earlyPurchaseTokenAmount, earlyPurchaserPurchaseValue) / totalAmountOfEarlyPurchases();&#13;
&#13;
            uint256 epTokenCalculationFromCrowdsaleTokenAmount = SafeMath.mul(crowdsaleTokenAmount, earlyPurchaserPurchaseValue) / totalAmountOfPurchasesInCny;&#13;
&#13;
            uint256 epTokenCount = SafeMath.add(epTokenCalculationFromEPTokenAmount, epTokenCalculationFromCrowdsaleTokenAmount);&#13;
&#13;
            numOfPurchasedTokensOnEpBy[earlyPurchaser] = SafeMath.add(numOfPurchasedTokensOnEpBy[earlyPurchaser], epTokenCount);&#13;
            starbaseToken.allocateToCrowdsalePurchaser(earlyPurchaser, epTokenCount);&#13;
            numOfDeliveredEarlyPurchases = SafeMath.add(j, 1);&#13;
        }&#13;
&#13;
        return true;&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Load early purchases from the contract keeps track of them&#13;
     */&#13;
    function loadEarlyPurchases() external onlyOwner returns (bool) {&#13;
        if (earlyPurchasesLoaded) {&#13;
            return false;    // all EPs have already been loaded&#13;
        }&#13;
&#13;
        uint256 numOfOrigEp = starbaseEpAmendment&#13;
            .starbaseEarlyPurchase()&#13;
            .numberOfEarlyPurchases();&#13;
&#13;
        for (uint256 i = numOfLoadedEarlyPurchases; i &lt; numOfOrigEp &amp;&amp; msg.gas &gt; 200000; i++) {&#13;
            if (starbaseEpAmendment.isInvalidEarlyPurchase(i)) {&#13;
                continue;&#13;
            }&#13;
            var (purchaser, amount,) =&#13;
                starbaseEpAmendment.isAmendedEarlyPurchase(i)&#13;
                ? starbaseEpAmendment.amendedEarlyPurchases(i)&#13;
                : starbaseEpAmendment.earlyPurchases(i);&#13;
            if (amount &gt; 0) {&#13;
                if (earlyPurchasedAmountBy[purchaser] == 0) {&#13;
                    earlyPurchasers.push(purchaser);&#13;
                }&#13;
                // each early purchaser receives 20% bonus&#13;
                uint256 bonus = SafeMath.mul(amount, 20) / 100;&#13;
                uint256 amountWithBonus = SafeMath.add(amount, bonus);&#13;
&#13;
                earlyPurchasedAmountBy[purchaser] += amountWithBonus;&#13;
            }&#13;
        }&#13;
&#13;
        numOfLoadedEarlyPurchases += i;&#13;
        assert(numOfLoadedEarlyPurchases &lt;= numOfOrigEp);&#13;
        if (numOfLoadedEarlyPurchases == numOfOrigEp) {&#13;
            earlyPurchasesLoaded = true;    // enable the flag&#13;
        }&#13;
        return true;&#13;
    }&#13;
&#13;
    /**&#13;
      * @dev Set qualified crowdsale partner i.e. Bitcoin Suisse address&#13;
      * @param _qualifiedPartner Address of the qualified partner that can purchase during crowdsale&#13;
      * @param _amountCap Ether value which partner is able to contribute&#13;
      * @param _commissionFeePercentage Integer that represents the fee to pay qualified partner 5 is 5%&#13;
      */&#13;
    function setQualifiedPartner(address _qualifiedPartner, uint256 _amountCap, uint256 _commissionFeePercentage)&#13;
        external&#13;
        onlyOwner&#13;
    {&#13;
        assert(!qualifiedPartners[_qualifiedPartner].bonaFide);&#13;
        qualifiedPartners[_qualifiedPartner].bonaFide = true;&#13;
        qualifiedPartners[_qualifiedPartner].amountCap = _amountCap;&#13;
        qualifiedPartners[_qualifiedPartner].commissionFeePercentage = _commissionFeePercentage;&#13;
        QualifiedPartnerAddress(_qualifiedPartner);&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Remove address from qualified partners list.&#13;
     * @param _qualifiedPartner Address to be removed from the list.&#13;
     */&#13;
    function unlistQualifiedPartner(address _qualifiedPartner) external onlyOwner {&#13;
        assert(qualifiedPartners[_qualifiedPartner].bonaFide);&#13;
        qualifiedPartners[_qualifiedPartner].bonaFide = false;&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Update whitelisted address amount allowed to raise during the presale.&#13;
     * @param _qualifiedPartner Qualified Partner address to be updated.&#13;
     * @param _amountCap Amount that the address is able to raise during the presale.&#13;
     */&#13;
    function updateQualifiedPartnerCapAmount(address _qualifiedPartner, uint256 _amountCap) external onlyOwner {&#13;
        assert(qualifiedPartners[_qualifiedPartner].bonaFide);&#13;
        qualifiedPartners[_qualifiedPartner].amountCap = _amountCap;&#13;
    }&#13;
&#13;
    /**&#13;
     * Public functions&#13;
     */&#13;
&#13;
    /**&#13;
     * @dev Returns boolean for whether crowdsale has ended&#13;
     */&#13;
    function isEnded() constant public returns (bool) {&#13;
        return (endedAt &gt; 0 &amp;&amp; endedAt &lt;= now);&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Returns number of purchases to date.&#13;
     */&#13;
    function numOfPurchases() constant public returns (uint256) {&#13;
        return crowdsalePurchases.length;&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Calculates total amount of tokens purchased includes bonus tokens.&#13;
     */&#13;
    function totalAmountOfCrowdsalePurchases() constant public returns (uint256 amount) {&#13;
        for (uint256 i; i &lt; crowdsalePurchases.length; i++) {&#13;
            amount = SafeMath.add(amount, crowdsalePurchases[i].amount);&#13;
        }&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Calculates total amount of tokens purchased without bonus conversion.&#13;
     */&#13;
    function totalAmountOfCrowdsalePurchasesWithoutBonus() constant public returns (uint256 amount) {&#13;
        for (uint256 i; i &lt; crowdsalePurchases.length; i++) {&#13;
            amount = SafeMath.add(amount, crowdsalePurchases[i].rawAmount);&#13;
        }&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Returns total raised amount in CNY (includes EP) and bonuses&#13;
     */&#13;
    function totalRaisedAmountInCny() constant public returns (uint256) {&#13;
        return SafeMath.add(totalAmountOfEarlyPurchases(), totalAmountOfCrowdsalePurchases());&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Returns total amount of early purchases in CNY&#13;
     */&#13;
    function totalAmountOfEarlyPurchases() constant public returns(uint256) {&#13;
       return starbaseEpAmendment.totalAmountOfEarlyPurchases();&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Allows qualified crowdsale partner to purchase Star Tokens&#13;
     */&#13;
    function purchaseAsQualifiedPartner()&#13;
        payable&#13;
        public&#13;
        rateIsSet(cnyEthRate)&#13;
        returns (bool)&#13;
    {&#13;
        require(qualifiedPartners[msg.sender].bonaFide);&#13;
        qualifiedPartners[msg.sender].amountRaised = SafeMath.add(msg.value, qualifiedPartners[msg.sender].amountRaised);&#13;
&#13;
        assert(qualifiedPartners[msg.sender].amountRaised &lt;= qualifiedPartners[msg.sender].amountCap);&#13;
&#13;
        uint256 bonusTier = 30; // Pre sale purchasers get 30 percent bonus&#13;
        uint256 rawAmount = SafeMath.mul(msg.value, cnyEthRate) / 1e18;&#13;
        uint amount = recordPurchase(msg.sender, rawAmount, now, '', bonusTier);&#13;
&#13;
        if (qualifiedPartners[msg.sender].commissionFeePercentage &gt; 0) {&#13;
            sendQualifiedPartnerCommissionFee(msg.sender, msg.value);&#13;
        }&#13;
&#13;
        StarBasePurchasedWithEth(msg.sender, amount, rawAmount, cnyEthRate, bonusTier);&#13;
        return true;&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Allows user to purchase STAR tokens with Ether&#13;
     */&#13;
    function purchaseWithEth()&#13;
        payable&#13;
        public&#13;
        minInvestment&#13;
        whenNotEnded&#13;
        rateIsSet(cnyEthRate)&#13;
        returns (bool)&#13;
    {&#13;
        require(purchaseStartBlock &gt; 0 &amp;&amp; block.number &gt;= purchaseStartBlock);&#13;
        if (startDate == 0) {&#13;
            startCrowdsale(block.timestamp);&#13;
        }&#13;
&#13;
        uint256 bonusTier = getBonusTier();&#13;
&#13;
        uint256 rawAmount = SafeMath.mul(msg.value, cnyEthRate) / 1e18;&#13;
        uint amount = recordPurchase(msg.sender, rawAmount, now, '', bonusTier);&#13;
&#13;
        StarBasePurchasedWithEth(msg.sender, amount, rawAmount, cnyEthRate, bonusTier);&#13;
        return true;&#13;
    }&#13;
&#13;
    /**&#13;
     * Internal functions&#13;
     */&#13;
&#13;
    /**&#13;
     * @dev Initializes Starbase crowdsale&#13;
     */&#13;
    function startCrowdsale(uint256 timestamp) internal {&#13;
        startDate = timestamp;&#13;
&#13;
        // set token bonus milestones&#13;
        firstBonusSalesEnds = startDate + 7 days;             // 1. 1st ~ 7th day&#13;
        secondBonusSalesEnds = firstBonusSalesEnds + 14 days; // 2. 8th ~ 21st day&#13;
        thirdBonusSalesEnds = secondBonusSalesEnds + 14 days; // 3. 22nd ~ 35th day&#13;
        fourthBonusSalesEnds = thirdBonusSalesEnds + 7 days;  // 4. 36th ~ 42nd day&#13;
        fifthBonusSalesEnds = fourthBonusSalesEnds + 3 days;  // 5. 43rd ~ 45th day&#13;
&#13;
        // extended sales bonus milestones&#13;
        firstExtendedBonusSalesEnds = fifthBonusSalesEnds + 3 days;         // 1. 46th ~ 48th day&#13;
        secondExtendedBonusSalesEnds = firstExtendedBonusSalesEnds + 3 days; // 2. 49th ~ 51st day&#13;
        thirdExtendedBonusSalesEnds = secondExtendedBonusSalesEnds + 3 days; // 3. 52nd ~ 54th day&#13;
        fourthExtendedBonusSalesEnds = thirdExtendedBonusSalesEnds + 3 days; // 4. 55th ~ 57th day&#13;
        fifthExtendedBonusSalesEnds = fourthExtendedBonusSalesEnds + 3 days;  // 5. 58th ~ 60th day&#13;
        sixthExtendedBonusSalesEnds = fifthExtendedBonusSalesEnds + 60 days; // 6. 61st ~ 120th day&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Abstract record of a purchase to Tokens&#13;
     * @param purchaser Address of the buyer&#13;
     * @param rawAmount Amount in CNY as per the CNY/ETH rate used&#13;
     * @param timestamp Timestamp at the purchase made&#13;
     * @param data Identifier as an evidence of the purchase (e.g. btc:1xyzxyz)&#13;
     * @param bonusTier bonus milestones of the purchase&#13;
     */&#13;
    function recordPurchase(&#13;
        address purchaser,&#13;
        uint256 rawAmount,&#13;
        uint256 timestamp,&#13;
        string data,&#13;
        uint256 bonusTier&#13;
    )&#13;
        internal&#13;
        returns(uint256 amount)&#13;
    {&#13;
        amount = rawAmount; // amount to check reach of max cap. it does not care for bonus tokens here&#13;
&#13;
        // presale transfers which occurs before the crowdsale ignores the crowdsale hard cap&#13;
        if (block.number &gt;= purchaseStartBlock) {&#13;
&#13;
            assert(totalAmountOfCrowdsalePurchasesWithoutBonus() &lt;= MAX_CROWDSALE_CAP);&#13;
&#13;
            uint256 crowdsaleTotalAmountAfterPurchase = SafeMath.add(totalAmountOfCrowdsalePurchasesWithoutBonus(), amount);&#13;
&#13;
            // check whether purchase goes over the cap and send the difference back to the purchaser.&#13;
            if (crowdsaleTotalAmountAfterPurchase &gt; MAX_CROWDSALE_CAP) {&#13;
              uint256 difference = SafeMath.sub(crowdsaleTotalAmountAfterPurchase, MAX_CROWDSALE_CAP);&#13;
              uint256 ethValueToReturn = SafeMath.mul(difference, 1e18) / cnyEthRate;&#13;
              purchaser.transfer(ethValueToReturn);&#13;
              amount = SafeMath.sub(amount, difference);&#13;
              rawAmount = amount;&#13;
            }&#13;
&#13;
        }&#13;
&#13;
        uint256 covertedAmountwWithBonus = SafeMath.mul(amount, bonusTier) / 100;&#13;
        amount = SafeMath.add(amount, covertedAmountwWithBonus); // at this point amount bonus is calculated&#13;
&#13;
        CrowdsalePurchase memory purchase = CrowdsalePurchase(purchaser, amount, rawAmount, timestamp, data, bonusTier);&#13;
        crowdsalePurchases.push(purchase);&#13;
        return amount;&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Fetchs Bonus tier percentage per bonus milestones&#13;
     */&#13;
    function getBonusTier() internal returns (uint256) {&#13;
        bool firstBonusSalesPeriod = now &gt;= startDate &amp;&amp; now &lt;= firstBonusSalesEnds; // 1st ~ 7th day get 20% bonus&#13;
        bool secondBonusSalesPeriod = now &gt; firstBonusSalesEnds &amp;&amp; now &lt;= secondBonusSalesEnds; // 8th ~ 21st day get 15% bonus&#13;
        bool thirdBonusSalesPeriod = now &gt; secondBonusSalesEnds &amp;&amp; now &lt;= thirdBonusSalesEnds; // 22nd ~ 35th day get 10% bonus&#13;
        bool fourthBonusSalesPeriod = now &gt; thirdBonusSalesEnds &amp;&amp; now &lt;= fourthBonusSalesEnds; // 36th ~ 42nd day get 5% bonus&#13;
        bool fifthBonusSalesPeriod = now &gt; fourthBonusSalesEnds &amp;&amp; now &lt;= fifthBonusSalesEnds; // 43rd and 45th day get 0% bonus&#13;
&#13;
        // extended bonus sales&#13;
        bool firstExtendedBonusSalesPeriod = now &gt; fifthBonusSalesEnds &amp;&amp; now &lt;= firstExtendedBonusSalesEnds; // extended sales 46th ~ 48th day get 20% bonus&#13;
        bool secondExtendedBonusSalesPeriod = now &gt; firstExtendedBonusSalesEnds &amp;&amp; now &lt;= secondExtendedBonusSalesEnds; // 49th ~ 51st 15% bonus&#13;
        bool thirdExtendedBonusSalesPeriod = now &gt; secondExtendedBonusSalesEnds &amp;&amp; now &lt;= thirdExtendedBonusSalesEnds; // 52nd ~ 54th day get 10% bonus&#13;
        bool fourthExtendedBonusSalesPeriod = now &gt; thirdExtendedBonusSalesEnds &amp;&amp; now &lt;= fourthExtendedBonusSalesEnds; // 55th ~ 57th day day get 5% bonus&#13;
        bool fifthExtendedBonusSalesPeriod = now &gt; fourthExtendedBonusSalesEnds &amp;&amp; now &lt;= fifthExtendedBonusSalesEnds; // 58th ~ 60th day get 0% bonus&#13;
        bool sixthExtendedBonusSalesPeriod = now &gt; fifthExtendedBonusSalesEnds &amp;&amp; now &lt;= sixthExtendedBonusSalesEnds; // 61st ~ 120th day get {number_of_days} - 60 * 1% bonus&#13;
&#13;
        if (firstBonusSalesPeriod || firstExtendedBonusSalesPeriod) return 20;&#13;
        if (secondBonusSalesPeriod || secondExtendedBonusSalesPeriod) return 15;&#13;
        if (thirdBonusSalesPeriod || thirdExtendedBonusSalesPeriod) return 10;&#13;
        if (fourthBonusSalesPeriod || fourthExtendedBonusSalesPeriod) return 5;&#13;
        if (fifthBonusSalesPeriod || fifthExtendedBonusSalesPeriod) return 0;&#13;
&#13;
        if (sixthExtendedBonusSalesPeriod) {&#13;
          uint256 DAY_IN_SECONDS = 86400;&#13;
          uint256 secondsSinceStartDate = SafeMath.sub(now, startDate);&#13;
          uint256 numberOfDays = secondsSinceStartDate / DAY_IN_SECONDS;&#13;
&#13;
          return SafeMath.sub(numberOfDays, 60);&#13;
        }&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Fetchs Bonus tier percentage per bonus milestones&#13;
     * @dev qualifiedPartner Address of partners that participated in pre sale&#13;
     * @dev amountSent Value sent by qualified partner&#13;
     */&#13;
    function sendQualifiedPartnerCommissionFee(address qualifiedPartner, uint256 amountSent) internal {&#13;
        //calculate the commission fee to send to qualified partner&#13;
        uint256 commissionFeePercentageCalculationAmount = SafeMath.mul(amountSent, qualifiedPartners[qualifiedPartner].commissionFeePercentage) / 100;&#13;
&#13;
        // send commission fee amount&#13;
        qualifiedPartner.transfer(commissionFeePercentageCalculationAmount);&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev redirectToPurchase Redirect to adequate purchase function within the smart contract&#13;
     */&#13;
    function redirectToPurchase() internal {&#13;
        if (block.number &lt; purchaseStartBlock) {&#13;
            purchaseAsQualifiedPartner();&#13;
        } else {&#13;
            purchaseWithEth();&#13;
        }&#13;
    }&#13;
}