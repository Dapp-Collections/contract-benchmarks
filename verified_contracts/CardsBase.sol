pragma solidity ^0.4.18;
/* ==================================================================== */
/* Copyright (c) 2018 The MagicAcademy Project.  All rights reserved.
/* 
/* https://www.magicacademy.io One of the world's first idle strategy games of blockchain 
/* https://staging.bitguild.com/game/magicacademy 
/* authors <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="d8aab9b1b6a198b4b1aebdabacb9aaf6bbb7b5">[email protected]</a>/<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="690f080707104713010c070e2905001f0c1a1d081b470a0604">[email protected]</a>&#13;
/*         <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="b4c6d5dddacdf4d3d9d5ddd89ad7dbd9">[email protected]</a>           &#13;
/* ==================================================================== */&#13;
&#13;
library SafeMath {&#13;
&#13;
  /**&#13;
  * @dev Multiplies two numbers, throws on overflow.&#13;
  */&#13;
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
    if (a == 0) {&#13;
      return 0;&#13;
    }&#13;
    uint256 c = a * b;&#13;
    assert(c / a == b);&#13;
    return c;&#13;
  }&#13;
&#13;
  /**&#13;
  * @dev Integer division of two numbers, truncating the quotient.&#13;
  */&#13;
  function div(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
    // assert(b &gt; 0); // Solidity automatically throws when dividing by 0&#13;
    uint256 c = a / b;&#13;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold&#13;
    return c;&#13;
  }&#13;
&#13;
  /**&#13;
  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).&#13;
  */&#13;
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
    assert(b &lt;= a);&#13;
    return a - b;&#13;
  }&#13;
&#13;
  /**&#13;
  * @dev Adds two numbers, throws on overflow.&#13;
  */&#13;
  function add(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
    uint256 c = a + b;&#13;
    assert(c &gt;= a);&#13;
    return c;&#13;
  }&#13;
}&#13;
&#13;
/**&#13;
 * @title Ownable&#13;
 * @dev The Ownable contract has an owner address, and provides basic authorization control&#13;
 * functions, this simplifies the implementation of "user permissions".&#13;
 */&#13;
contract Ownable {&#13;
  address public owner;&#13;
&#13;
  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);&#13;
&#13;
  /*&#13;
   * @dev The Ownable constructor sets the original `owner` of the contract to the sender&#13;
   * account.&#13;
   */&#13;
  function Ownable() public {&#13;
    owner = msg.sender;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Throws if called by any account other than the owner.&#13;
   */&#13;
  modifier onlyOwner() {&#13;
    require(msg.sender == owner);&#13;
    _;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Allows the current owner to transfer control of the contract to a newOwner.&#13;
   * @param newOwner The address to transfer ownership to.&#13;
   */&#13;
  function transferOwnership(address newOwner) public onlyOwner {&#13;
    require(newOwner != address(0));&#13;
    OwnershipTransferred(owner, newOwner);&#13;
    owner = newOwner;&#13;
  }&#13;
&#13;
}&#13;
&#13;
contract OperAccess is Ownable {&#13;
  address tradeAddress;&#13;
  address platAddress;&#13;
  address attackAddress;&#13;
  address raffleAddress;&#13;
  address drawAddress;&#13;
&#13;
  function setTradeAddress(address _address) external onlyOwner {&#13;
    require(_address != address(0));&#13;
    tradeAddress = _address;&#13;
  }&#13;
&#13;
  function setPLATAddress(address _address) external onlyOwner {&#13;
    require(_address != address(0));&#13;
    platAddress = _address;&#13;
  }&#13;
&#13;
  function setAttackAddress(address _address) external onlyOwner {&#13;
    require(_address != address(0));&#13;
    attackAddress = _address;&#13;
  }&#13;
&#13;
  function setRaffleAddress(address _address) external onlyOwner {&#13;
    require(_address != address(0));&#13;
    raffleAddress = _address;&#13;
  }&#13;
&#13;
  function setDrawAddress(address _address) external onlyOwner {&#13;
    require(_address != address(0));&#13;
    drawAddress = _address;&#13;
  }&#13;
&#13;
  modifier onlyAccess() {&#13;
    require(msg.sender == tradeAddress || msg.sender == platAddress || msg.sender == attackAddress || msg.sender == raffleAddress || msg.sender == drawAddress);&#13;
    _;&#13;
  }&#13;
}&#13;
&#13;
interface ERC20 {&#13;
    function totalSupply() public constant returns (uint);&#13;
    function balanceOf(address tokenOwner) public constant returns (uint balance);&#13;
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);&#13;
    function transfer(address to, uint tokens) public returns (bool success);&#13;
    function approve(address spender, uint tokens) public returns (bool success);&#13;
    function transferFrom(address from, address to, uint tokens) public returns (bool success);&#13;
    event Transfer(address indexed from, address indexed to, uint tokens);&#13;
    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);&#13;
}&#13;
// Jade - Crypto MagicAcacedy Game&#13;
// https://www.magicAcademy.io&#13;
&#13;
contract JadeCoin is ERC20, OperAccess {&#13;
  using SafeMath for SafeMath;&#13;
  string public constant name  = "MAGICACADEMY JADE";&#13;
  string public constant symbol = "Jade";&#13;
  uint8 public constant decimals = 0;&#13;
  uint256 public roughSupply;&#13;
  uint256 public totalJadeProduction;&#13;
&#13;
  uint256[] public totalJadeProductionSnapshots; // The total goo production for each prior day past&#13;
  uint256[] public allocatedJadeResearchSnapshots; // The research eth allocated to each prior day past&#13;
&#13;
  // Balances for each player&#13;
  mapping(address =&gt; uint256) public jadeBalance;&#13;
  mapping(address =&gt; mapping(uint8 =&gt; uint256)) public coinBalance;&#13;
  mapping(uint256 =&gt; uint256) totalEtherPool; //Total Pool&#13;
  &#13;
  mapping(address =&gt; mapping(uint256 =&gt; uint256)) private jadeProductionSnapshots; // Store player's jade production for given day (snapshot)&#13;
  mapping(address =&gt; mapping(uint256 =&gt; bool)) private jadeProductionZeroedSnapshots; // This isn't great but we need know difference between 0 production and an unused/inactive day.&#13;
    &#13;
  mapping(address =&gt; uint256) public lastJadeSaveTime; // Seconds (last time player claimed their produced jade)&#13;
  mapping(address =&gt; uint256) public lastJadeProductionUpdate; // Days (last snapshot player updated their production)&#13;
  mapping(address =&gt; uint256) private lastJadeResearchFundClaim; // Days (snapshot number)&#13;
   &#13;
  // Mapping of approved ERC20 transfers (by player)&#13;
  mapping(address =&gt; mapping(address =&gt; uint256)) private allowed;&#13;
     &#13;
  // Constructor&#13;
  function JadeCoin() public {&#13;
  }&#13;
&#13;
  function totalSupply() public constant returns(uint256) {&#13;
    return roughSupply; // Stored jade (rough supply as it ignores earned/unclaimed jade)&#13;
  }&#13;
  /// balance of jade in-game&#13;
  function balanceOf(address player) public constant returns(uint256) {&#13;
    return SafeMath.add(jadeBalance[player],balanceOfUnclaimed(player));&#13;
  }&#13;
  /// unclaimed jade&#13;
  function balanceOfUnclaimed(address player) public constant returns (uint256) {&#13;
    uint256 lSave = lastJadeSaveTime[player];&#13;
    if (lSave &gt; 0 &amp;&amp; lSave &lt; block.timestamp) { &#13;
      return SafeMath.mul(getJadeProduction(player),SafeMath.div(SafeMath.sub(block.timestamp,lSave),60));&#13;
    }&#13;
    return 0;&#13;
  }&#13;
&#13;
  /// production/s&#13;
  function getJadeProduction(address player) public constant returns (uint256){&#13;
    return jadeProductionSnapshots[player][lastJadeProductionUpdate[player]];&#13;
  }&#13;
&#13;
  function getlastJadeProductionUpdate(address player) public view returns (uint256) {&#13;
    return lastJadeProductionUpdate[player];&#13;
  }&#13;
    /// increase prodution &#13;
  function increasePlayersJadeProduction(address player, uint256 increase) external onlyAccess {&#13;
    jadeProductionSnapshots[player][allocatedJadeResearchSnapshots.length] = SafeMath.add(getJadeProduction(player),increase);&#13;
    lastJadeProductionUpdate[player] = allocatedJadeResearchSnapshots.length;&#13;
    totalJadeProduction = SafeMath.add(totalJadeProduction,increase);&#13;
  }&#13;
&#13;
  /// reduce production&#13;
  function reducePlayersJadeProduction(address player, uint256 decrease) external onlyAccess {&#13;
    uint256 previousProduction = getJadeProduction(player);&#13;
    uint256 newProduction = SafeMath.sub(previousProduction, decrease);&#13;
&#13;
    if (newProduction == 0) { &#13;
      jadeProductionZeroedSnapshots[player][allocatedJadeResearchSnapshots.length] = true;&#13;
      delete jadeProductionSnapshots[player][allocatedJadeResearchSnapshots.length]; // 0&#13;
    } else {&#13;
      jadeProductionSnapshots[player][allocatedJadeResearchSnapshots.length] = newProduction;&#13;
    }   &#13;
    lastJadeProductionUpdate[player] = allocatedJadeResearchSnapshots.length;&#13;
    totalJadeProduction = SafeMath.sub(totalJadeProduction,decrease);&#13;
  }&#13;
&#13;
  /// update player's jade balance&#13;
  function updatePlayersCoin(address player) internal {&#13;
    uint256 coinGain = balanceOfUnclaimed(player);&#13;
    lastJadeSaveTime[player] = block.timestamp;&#13;
    roughSupply = SafeMath.add(roughSupply,coinGain);  &#13;
    jadeBalance[player] = SafeMath.add(jadeBalance[player],coinGain);  &#13;
  }&#13;
&#13;
  /// update player's jade balance&#13;
  function updatePlayersCoinByOut(address player) external onlyAccess {&#13;
    uint256 coinGain = balanceOfUnclaimed(player);&#13;
    lastJadeSaveTime[player] = block.timestamp;&#13;
    roughSupply = SafeMath.add(roughSupply,coinGain);  &#13;
    jadeBalance[player] = SafeMath.add(jadeBalance[player],coinGain);  &#13;
  }&#13;
  /// transfer&#13;
  function transfer(address recipient, uint256 amount) public returns (bool) {&#13;
    updatePlayersCoin(msg.sender);&#13;
    require(amount &lt;= jadeBalance[msg.sender]);&#13;
    jadeBalance[msg.sender] = SafeMath.sub(jadeBalance[msg.sender],amount);&#13;
    jadeBalance[recipient] = SafeMath.add(jadeBalance[recipient],amount);&#13;
    Transfer(msg.sender, recipient, amount);&#13;
    return true;&#13;
  }&#13;
  /// transferfrom&#13;
  function transferFrom(address player, address recipient, uint256 amount) public returns (bool) {&#13;
    updatePlayersCoin(player);&#13;
    require(amount &lt;= allowed[player][msg.sender] &amp;&amp; amount &lt;= jadeBalance[player]);&#13;
        &#13;
    jadeBalance[player] = SafeMath.sub(jadeBalance[player],amount); &#13;
    jadeBalance[recipient] = SafeMath.add(jadeBalance[recipient],amount); &#13;
    allowed[player][msg.sender] = SafeMath.sub(allowed[player][msg.sender],amount); &#13;
        &#13;
    Transfer(player, recipient, amount);  &#13;
    return true;&#13;
  }&#13;
  &#13;
  function approve(address approvee, uint256 amount) public returns (bool) {&#13;
    allowed[msg.sender][approvee] = amount;  &#13;
    Approval(msg.sender, approvee, amount);&#13;
    return true;&#13;
  }&#13;
  &#13;
  function allowance(address player, address approvee) public constant returns(uint256) {&#13;
    return allowed[player][approvee];  &#13;
  }&#13;
  &#13;
  /// update Jade via purchase&#13;
  function updatePlayersCoinByPurchase(address player, uint256 purchaseCost) external onlyAccess {&#13;
    uint256 unclaimedJade = balanceOfUnclaimed(player);&#13;
        &#13;
    if (purchaseCost &gt; unclaimedJade) {&#13;
      uint256 jadeDecrease = SafeMath.sub(purchaseCost, unclaimedJade);&#13;
      require(jadeBalance[player] &gt;= jadeDecrease);&#13;
      roughSupply = SafeMath.sub(roughSupply,jadeDecrease);&#13;
      jadeBalance[player] = SafeMath.sub(jadeBalance[player],jadeDecrease);&#13;
    } else {&#13;
      uint256 jadeGain = SafeMath.sub(unclaimedJade,purchaseCost);&#13;
      roughSupply = SafeMath.add(roughSupply,jadeGain);&#13;
      jadeBalance[player] = SafeMath.add(jadeBalance[player],jadeGain);&#13;
    }&#13;
        &#13;
    lastJadeSaveTime[player] = block.timestamp;&#13;
  }&#13;
&#13;
  function JadeCoinMining(address _addr, uint256 _amount) external onlyOwner {&#13;
    roughSupply = SafeMath.add(roughSupply,_amount);&#13;
    jadeBalance[_addr] = SafeMath.add(jadeBalance[_addr],_amount);&#13;
  }&#13;
&#13;
  function setRoughSupply(uint256 iroughSupply) external onlyAccess {&#13;
    roughSupply = SafeMath.add(roughSupply,iroughSupply);&#13;
  }&#13;
  /// balance of coin/eth  in-game&#13;
  function coinBalanceOf(address player,uint8 itype) external constant returns(uint256) {&#13;
    return coinBalance[player][itype];&#13;
  }&#13;
&#13;
  function setJadeCoin(address player, uint256 coin, bool iflag) external onlyAccess {&#13;
    if (iflag) {&#13;
      jadeBalance[player] = SafeMath.add(jadeBalance[player],coin);&#13;
    } else if (!iflag) {&#13;
      jadeBalance[player] = SafeMath.sub(jadeBalance[player],coin);&#13;
    }&#13;
  }&#13;
  &#13;
  function setCoinBalance(address player, uint256 eth, uint8 itype, bool iflag) external onlyAccess {&#13;
    if (iflag) {&#13;
      coinBalance[player][itype] = SafeMath.add(coinBalance[player][itype],eth);&#13;
    } else if (!iflag) {&#13;
      coinBalance[player][itype] = SafeMath.sub(coinBalance[player][itype],eth);&#13;
    }&#13;
  }&#13;
&#13;
  function setLastJadeSaveTime(address player) external onlyAccess {&#13;
    lastJadeSaveTime[player] = block.timestamp;&#13;
  }&#13;
&#13;
  function setTotalEtherPool(uint256 inEth, uint8 itype, bool iflag) external onlyAccess {&#13;
    if (iflag) {&#13;
      totalEtherPool[itype] = SafeMath.add(totalEtherPool[itype],inEth);&#13;
     } else if (!iflag) {&#13;
      totalEtherPool[itype] = SafeMath.sub(totalEtherPool[itype],inEth);&#13;
    }&#13;
  }&#13;
&#13;
  function getTotalEtherPool(uint8 itype) external view returns (uint256) {&#13;
    return totalEtherPool[itype];&#13;
  }&#13;
&#13;
  function setJadeCoinZero(address player) external onlyAccess {&#13;
    jadeBalance[player]=0;&#13;
  }&#13;
}&#13;
&#13;
interface GameConfigInterface {&#13;
  function productionCardIdRange() external constant returns (uint256, uint256);&#13;
  function battleCardIdRange() external constant returns (uint256, uint256);&#13;
  function upgradeIdRange() external constant returns (uint256, uint256);&#13;
  function unitCoinProduction(uint256 cardId) external constant returns (uint256);&#13;
  function unitAttack(uint256 cardId) external constant returns (uint256);&#13;
  function unitDefense(uint256 cardId) external constant returns (uint256);&#13;
  function unitStealingCapacity(uint256 cardId) external constant returns (uint256);&#13;
}&#13;
&#13;
/// @notice define the players,cards,jadecoin&#13;
/// @author rainysiu <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="b3c1d2daddcaf3dfdac5d6c0c7d2c19dd0dcde">[email protected]</a>&#13;
/// @dev MagicAcademy Games &#13;
&#13;
contract CardsBase is JadeCoin {&#13;
&#13;
  // player  &#13;
  struct Player {&#13;
    address owneraddress;&#13;
  }&#13;
&#13;
  Player[] players;&#13;
  bool gameStarted;&#13;
  &#13;
  GameConfigInterface public schema;&#13;
&#13;
  // Stuff owned by each player&#13;
  mapping(address =&gt; mapping(uint256 =&gt; uint256)) public unitsOwned;  //number of normal card&#13;
  mapping(address =&gt; mapping(uint256 =&gt; uint256)) public upgradesOwned;  //Lv of upgrade card&#13;
&#13;
  mapping(address =&gt; uint256) public uintsOwnerCount; // total number of cards&#13;
  mapping(address=&gt; mapping(uint256 =&gt; uint256)) public uintProduction;  //card's production&#13;
&#13;
  // Rares &amp; Upgrades (Increase unit's production / attack etc.)&#13;
  mapping(address =&gt; mapping(uint256 =&gt; uint256)) public unitCoinProductionIncreases; // Adds to the coin per second&#13;
  mapping(address =&gt; mapping(uint256 =&gt; uint256)) public unitCoinProductionMultiplier; // Multiplies the coin per second&#13;
  mapping(address =&gt; mapping(uint256 =&gt; uint256)) public unitAttackIncreases;&#13;
  mapping(address =&gt; mapping(uint256 =&gt; uint256)) public unitAttackMultiplier;&#13;
  mapping(address =&gt; mapping(uint256 =&gt; uint256)) public unitDefenseIncreases;&#13;
  mapping(address =&gt; mapping(uint256 =&gt; uint256)) public unitDefenseMultiplier;&#13;
  mapping(address =&gt; mapping(uint256 =&gt; uint256)) public unitJadeStealingIncreases;&#13;
  mapping(address =&gt; mapping(uint256 =&gt; uint256)) public unitJadeStealingMultiplier;&#13;
&#13;
  //setting configuration&#13;
  function setConfigAddress(address _address) external onlyOwner {&#13;
    schema = GameConfigInterface(_address);&#13;
  }&#13;
&#13;
  /// start game&#13;
  function beginGame() external onlyOwner {&#13;
    require(!gameStarted);&#13;
    gameStarted = true; &#13;
  }&#13;
  function getGameStarted() external constant returns (bool) {&#13;
    return gameStarted;&#13;
  }&#13;
  function AddPlayers(address _address) external onlyAccess { &#13;
    Player memory _player= Player({&#13;
      owneraddress: _address&#13;
    });&#13;
    players.push(_player);&#13;
  }&#13;
&#13;
  /// @notice ranking of production&#13;
  function getRanking() external view returns (address[], uint256[]) {&#13;
    uint256 len = players.length;&#13;
    uint256[] memory arr = new uint256[](len);&#13;
    address[] memory arr_addr = new address[](len);&#13;
&#13;
    uint counter =0;&#13;
    for (uint k=0;k&lt;len; k++){&#13;
      arr[counter] =  getJadeProduction(players[k].owneraddress);&#13;
      arr_addr[counter] = players[k].owneraddress;&#13;
      counter++;&#13;
    }&#13;
&#13;
    for(uint i=0;i&lt;len-1;i++) {&#13;
      for(uint j=0;j&lt;len-i-1;j++) {&#13;
        if(arr[j]&lt;arr[j+1]) {&#13;
          uint256 temp = arr[j];&#13;
          address temp_addr = arr_addr[j];&#13;
          arr[j] = arr[j+1];&#13;
          arr[j+1] = temp;&#13;
          arr_addr[j] = arr_addr[j+1];&#13;
          arr_addr[j+1] = temp_addr;&#13;
        }&#13;
      }&#13;
    }&#13;
    return (arr_addr,arr);&#13;
  }&#13;
&#13;
  /// @notice battle power ranking&#13;
  function getAttackRanking() external view returns (address[], uint256[]) {&#13;
    uint256 len = players.length;&#13;
    uint256[] memory arr = new uint256[](len);&#13;
    address[] memory arr_addr = new address[](len);&#13;
&#13;
    uint counter =0;&#13;
    for (uint k=0;k&lt;len; k++){&#13;
      (,,,arr[counter]) = getPlayersBattleStats(players[k].owneraddress);&#13;
      arr_addr[counter] = players[k].owneraddress;&#13;
      counter++;&#13;
    }&#13;
&#13;
    for(uint i=0;i&lt;len-1;i++) {&#13;
      for(uint j=0;j&lt;len-i-1;j++) {&#13;
        if(arr[j]&lt;arr[j+1]) {&#13;
          uint256 temp = arr[j];&#13;
          address temp_addr = arr_addr[j];&#13;
          arr[j] = arr[j+1];&#13;
          arr[j+1] = temp;&#13;
          arr_addr[j] = arr_addr[j+1];&#13;
          arr_addr[j+1] = temp_addr;&#13;
        }&#13;
      }&#13;
    }&#13;
    return(arr_addr,arr);&#13;
  } &#13;
&#13;
  //total users&#13;
  function getTotalUsers()  external view returns (uint256) {&#13;
    return players.length;&#13;
  }&#13;
 &#13;
  /// UnitsProuction&#13;
  function getUnitsProduction(address player, uint256 unitId, uint256 amount) external constant returns (uint256) {&#13;
    return (amount * (schema.unitCoinProduction(unitId) + unitCoinProductionIncreases[player][unitId]) * (10 + unitCoinProductionMultiplier[player][unitId])) / 10; &#13;
  } &#13;
&#13;
  /// one card's production&#13;
  function getUnitsInProduction(address player, uint256 unitId, uint256 amount) external constant returns (uint256) {&#13;
    return SafeMath.div(SafeMath.mul(amount,uintProduction[player][unitId]),unitsOwned[player][unitId]);&#13;
  } &#13;
&#13;
  /// UnitsAttack&#13;
  function getUnitsAttack(address player, uint256 unitId, uint256 amount) internal constant returns (uint256) {&#13;
    return (amount * (schema.unitAttack(unitId) + unitAttackIncreases[player][unitId]) * (10 + unitAttackMultiplier[player][unitId])) / 10;&#13;
  }&#13;
  /// UnitsDefense&#13;
  function getUnitsDefense(address player, uint256 unitId, uint256 amount) internal constant returns (uint256) {&#13;
    return (amount * (schema.unitDefense(unitId) + unitDefenseIncreases[player][unitId]) * (10 + unitDefenseMultiplier[player][unitId])) / 10;&#13;
  }&#13;
  /// UnitsStealingCapacity&#13;
  function getUnitsStealingCapacity(address player, uint256 unitId, uint256 amount) internal constant returns (uint256) {&#13;
    return (amount * (schema.unitStealingCapacity(unitId) + unitJadeStealingIncreases[player][unitId]) * (10 + unitJadeStealingMultiplier[player][unitId])) / 10;&#13;
  }&#13;
 &#13;
  // player's attacking &amp; defending &amp; stealing &amp; battle power&#13;
  function getPlayersBattleStats(address player) public constant returns (&#13;
    uint256 attackingPower, &#13;
    uint256 defendingPower, &#13;
    uint256 stealingPower,&#13;
    uint256 battlePower) {&#13;
&#13;
    uint256 startId;&#13;
    uint256 endId;&#13;
    (startId, endId) = schema.battleCardIdRange();&#13;
&#13;
    // Not ideal but will only be a small number of units (and saves gas when buying units)&#13;
    while (startId &lt;= endId) {&#13;
      attackingPower = SafeMath.add(attackingPower,getUnitsAttack(player, startId, unitsOwned[player][startId]));&#13;
      stealingPower = SafeMath.add(stealingPower,getUnitsStealingCapacity(player, startId, unitsOwned[player][startId]));&#13;
      defendingPower = SafeMath.add(defendingPower,getUnitsDefense(player, startId, unitsOwned[player][startId]));&#13;
      battlePower = SafeMath.add(attackingPower,defendingPower); &#13;
      startId++;&#13;
    }&#13;
  }&#13;
&#13;
  // @nitice number of normal card&#13;
  function getOwnedCount(address player, uint256 cardId) external view returns (uint256) {&#13;
    return unitsOwned[player][cardId];&#13;
  }&#13;
  function setOwnedCount(address player, uint256 cardId, uint256 amount, bool iflag) external onlyAccess {&#13;
    if (iflag) {&#13;
      unitsOwned[player][cardId] = SafeMath.add(unitsOwned[player][cardId],amount);&#13;
     } else if (!iflag) {&#13;
      unitsOwned[player][cardId] = SafeMath.sub(unitsOwned[player][cardId],amount);&#13;
    }&#13;
  }&#13;
&#13;
  // @notice Lv of upgrade card&#13;
  function getUpgradesOwned(address player, uint256 upgradeId) external view returns (uint256) {&#13;
    return upgradesOwned[player][upgradeId];&#13;
  }&#13;
  //set upgrade&#13;
  function setUpgradesOwned(address player, uint256 upgradeId) external onlyAccess {&#13;
    upgradesOwned[player][upgradeId] = SafeMath.add(upgradesOwned[player][upgradeId],1);&#13;
  }&#13;
&#13;
  function getUintsOwnerCount(address _address) external view returns (uint256) {&#13;
    return uintsOwnerCount[_address];&#13;
  }&#13;
  function setUintsOwnerCount(address _address, uint256 amount, bool iflag) external onlyAccess {&#13;
    if (iflag) {&#13;
      uintsOwnerCount[_address] = SafeMath.add(uintsOwnerCount[_address],amount);&#13;
    } else if (!iflag) {&#13;
      uintsOwnerCount[_address] = SafeMath.sub(uintsOwnerCount[_address],amount);&#13;
    }&#13;
  }&#13;
&#13;
  function getUnitCoinProductionIncreases(address _address, uint256 cardId) external view returns (uint256) {&#13;
    return unitCoinProductionIncreases[_address][cardId];&#13;
  }&#13;
&#13;
  function setUnitCoinProductionIncreases(address _address, uint256 cardId, uint256 iValue,bool iflag) external onlyAccess {&#13;
    if (iflag) {&#13;
      unitCoinProductionIncreases[_address][cardId] = SafeMath.add(unitCoinProductionIncreases[_address][cardId],iValue);&#13;
    } else if (!iflag) {&#13;
      unitCoinProductionIncreases[_address][cardId] = SafeMath.sub(unitCoinProductionIncreases[_address][cardId],iValue);&#13;
    }&#13;
  }&#13;
&#13;
  function getUnitCoinProductionMultiplier(address _address, uint256 cardId) external view returns (uint256) {&#13;
    return unitCoinProductionMultiplier[_address][cardId];&#13;
  }&#13;
&#13;
  function setUnitCoinProductionMultiplier(address _address, uint256 cardId, uint256 iValue, bool iflag) external onlyAccess {&#13;
    if (iflag) {&#13;
      unitCoinProductionMultiplier[_address][cardId] = SafeMath.add(unitCoinProductionMultiplier[_address][cardId],iValue);&#13;
    } else if (!iflag) {&#13;
      unitCoinProductionMultiplier[_address][cardId] = SafeMath.sub(unitCoinProductionMultiplier[_address][cardId],iValue);&#13;
    }&#13;
  }&#13;
&#13;
  function setUnitAttackIncreases(address _address, uint256 cardId, uint256 iValue,bool iflag) external onlyAccess {&#13;
    if (iflag) {&#13;
      unitAttackIncreases[_address][cardId] = SafeMath.add(unitAttackIncreases[_address][cardId],iValue);&#13;
    } else if (!iflag) {&#13;
      unitAttackIncreases[_address][cardId] = SafeMath.sub(unitAttackIncreases[_address][cardId],iValue);&#13;
    }&#13;
  }&#13;
&#13;
  function getUnitAttackIncreases(address _address, uint256 cardId) external view returns (uint256) {&#13;
    return unitAttackIncreases[_address][cardId];&#13;
  } &#13;
  function setUnitAttackMultiplier(address _address, uint256 cardId, uint256 iValue,bool iflag) external onlyAccess {&#13;
    if (iflag) {&#13;
      unitAttackMultiplier[_address][cardId] = SafeMath.add(unitAttackMultiplier[_address][cardId],iValue);&#13;
    } else if (!iflag) {&#13;
      unitAttackMultiplier[_address][cardId] = SafeMath.sub(unitAttackMultiplier[_address][cardId],iValue);&#13;
    }&#13;
  }&#13;
  function getUnitAttackMultiplier(address _address, uint256 cardId) external view returns (uint256) {&#13;
    return unitAttackMultiplier[_address][cardId];&#13;
  } &#13;
&#13;
  function setUnitDefenseIncreases(address _address, uint256 cardId, uint256 iValue,bool iflag) external onlyAccess {&#13;
    if (iflag) {&#13;
      unitDefenseIncreases[_address][cardId] = SafeMath.add(unitDefenseIncreases[_address][cardId],iValue);&#13;
    } else if (!iflag) {&#13;
      unitDefenseIncreases[_address][cardId] = SafeMath.sub(unitDefenseIncreases[_address][cardId],iValue);&#13;
    }&#13;
  }&#13;
  function getUnitDefenseIncreases(address _address, uint256 cardId) external view returns (uint256) {&#13;
    return unitDefenseIncreases[_address][cardId];&#13;
  }&#13;
  function setunitDefenseMultiplier(address _address, uint256 cardId, uint256 iValue,bool iflag) external onlyAccess {&#13;
    if (iflag) {&#13;
      unitDefenseMultiplier[_address][cardId] = SafeMath.add(unitDefenseMultiplier[_address][cardId],iValue);&#13;
    } else if (!iflag) {&#13;
      unitDefenseMultiplier[_address][cardId] = SafeMath.sub(unitDefenseMultiplier[_address][cardId],iValue);&#13;
    }&#13;
  }&#13;
  function getUnitDefenseMultiplier(address _address, uint256 cardId) external view returns (uint256) {&#13;
    return unitDefenseMultiplier[_address][cardId];&#13;
  }&#13;
  function setUnitJadeStealingIncreases(address _address, uint256 cardId, uint256 iValue,bool iflag) external onlyAccess {&#13;
    if (iflag) {&#13;
      unitJadeStealingIncreases[_address][cardId] = SafeMath.add(unitJadeStealingIncreases[_address][cardId],iValue);&#13;
    } else if (!iflag) {&#13;
      unitJadeStealingIncreases[_address][cardId] = SafeMath.sub(unitJadeStealingIncreases[_address][cardId],iValue);&#13;
    }&#13;
  }&#13;
  function getUnitJadeStealingIncreases(address _address, uint256 cardId) external view returns (uint256) {&#13;
    return unitJadeStealingIncreases[_address][cardId];&#13;
  } &#13;
&#13;
  function setUnitJadeStealingMultiplier(address _address, uint256 cardId, uint256 iValue,bool iflag) external onlyAccess {&#13;
    if (iflag) {&#13;
      unitJadeStealingMultiplier[_address][cardId] = SafeMath.add(unitJadeStealingMultiplier[_address][cardId],iValue);&#13;
    } else if (!iflag) {&#13;
      unitJadeStealingMultiplier[_address][cardId] = SafeMath.sub(unitJadeStealingMultiplier[_address][cardId],iValue);&#13;
    }&#13;
  }&#13;
  function getUnitJadeStealingMultiplier(address _address, uint256 cardId) external view returns (uint256) {&#13;
    return unitJadeStealingMultiplier[_address][cardId];&#13;
  } &#13;
&#13;
  function setUintCoinProduction(address _address, uint256 cardId, uint256 iValue, bool iflag) external onlyAccess {&#13;
    if (iflag) {&#13;
      uintProduction[_address][cardId] = SafeMath.add(uintProduction[_address][cardId],iValue);&#13;
     } else if (!iflag) {&#13;
      uintProduction[_address][cardId] = SafeMath.sub(uintProduction[_address][cardId],iValue);&#13;
    }&#13;
  }&#13;
&#13;
  function getUintCoinProduction(address _address, uint256 cardId) external view returns (uint256) {&#13;
    return uintProduction[_address][cardId];&#13;
  }&#13;
}