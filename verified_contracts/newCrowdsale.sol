/**
 * Investors relations: <span class="__cf_email__" data-cfemail="c1b1a0b3b5afa4b3b281b9b3b1a2aeafafa4a2b5efa2ae">[email protected]</span>&#13;
 * &#13;
 * Ken Brannon&#13;
 * Contact: <span class="__cf_email__" data-cfemail="107b757e50686260737f7e7e7573643e737f">[email protected]</span>&#13;
**/&#13;
&#13;
pragma solidity ^0.4.11;&#13;
&#13;
/**&#13;
 * @title Crowdsale&#13;
 * @dev Crowdsale is a base contract for managing a token crowdsale.&#13;
 * Crowdsales have a start and end timestamps, where investors can make&#13;
 * token purchases and the crowdsale will assign them tokens based&#13;
 * on a token per ETH rate. Funds collected are forwarded to a wallet&#13;
 * as they arrive.&#13;
 */&#13;
 &#13;
 &#13;
/**&#13;
 * SafeMath library to support basic mathematical operations &#13;
 * Used for security of the contract&#13;
 **/ &#13;
 &#13;
library SafeMath {&#13;
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
    uint256 c = a * b;&#13;
    assert(a == 0 || c / a == b);&#13;
    return c;&#13;
  }&#13;
&#13;
 function div(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
    assert(b &gt; 0); // Solidity automatically throws when dividing by 0&#13;
    uint256 c = a / b;&#13;
    assert(a == b * c + a % b); // There is no case in which this doesn't hold&#13;
    return c;&#13;
  }&#13;
&#13;
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
    assert(b &lt;= a);&#13;
    return a - b;&#13;
  }&#13;
&#13;
  function add(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
    uint256 c = a + b;&#13;
    assert(c &gt;= a);&#13;
    return c;&#13;
  }&#13;
}&#13;
&#13;
/**&#13;
 * Ownable contract  &#13;
 * Makes an address the owner of a contract&#13;
 * Used so that onlyOwner modifier can be Used&#13;
 * onlyOwner modifier is used so that some functions can only be called by the contract owner&#13;
 **/&#13;
&#13;
contract Ownable {&#13;
  address public owner;&#13;
&#13;
  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);&#13;
&#13;
&#13;
  /**&#13;
   * @dev The Ownable constructor sets the original `owner` of the contract to the sender&#13;
   * account.&#13;
   */&#13;
  function Ownable() public {&#13;
    owner = msg.sender;&#13;
  }&#13;
&#13;
&#13;
  /**&#13;
   * @dev Throws if called by any account other than the owner.&#13;
   */&#13;
  modifier onlyOwner() {&#13;
    require(msg.sender == owner);&#13;
    _;&#13;
  }&#13;
&#13;
&#13;
  /**&#13;
   * @dev Allows the current owner to transfer control of the contract to a newOwner.&#13;
   * @param newOwner The address to transfer ownership to.&#13;
   */&#13;
  function transferOwnership(address newOwner) onlyOwner public {&#13;
    require(newOwner != address(0));&#13;
    OwnershipTransferred(owner, newOwner);&#13;
    owner = newOwner;&#13;
  }&#13;
&#13;
}&#13;
&#13;
interface XRPCToken {&#13;
    function transfer(address receiver, uint amount) public;&#13;
    function balanceOf(address _owner) public returns (uint256 balance);&#13;
    function mint(address wallet, address buyer, uint256 tokenAmount) public;&#13;
    function showMyTokenBalance(address addr) public;&#13;
}&#13;
&#13;
// partner address is 0x8Cd68F4F20F73960AA1C3BAeA39a827C03e2532C&#13;
&#13;
contract newCrowdsale is Ownable {&#13;
    &#13;
    // safe math library imported for safe mathematical operations&#13;
    using SafeMath for uint256;&#13;
    &#13;
    // start and end timestamps where investments are allowed (both inclusive)&#13;
    uint256 public startTime;&#13;
    uint256 public endTime;&#13;
  &#13;
    // to maintain a list of owners and their specific equity percentages&#13;
    mapping(address=&gt;uint256) public ownerAddresses;  //the first one would always be the major owner&#13;
    &#13;
    address[] owners;&#13;
    &#13;
    uint256 public majorOwnerShares = 90;&#13;
    uint256 public minorOwnerShares = 10;&#13;
  &#13;
    // how many token units a buyer gets per wei&#13;
    uint256 public rate = 650;&#13;
&#13;
    // amount of raised money in wei&#13;
    uint256 public weiRaised;&#13;
  &#13;
    bool public isCrowdsaleStopped = false;&#13;
  &#13;
    bool public isCrowdsalePaused = false;&#13;
    &#13;
    /**&#13;
    * event for token purchase logging&#13;
    * @param purchaser who paid for the tokens&#13;
    * @param beneficiary who got the tokens&#13;
    * @param value weis paid for purchase&#13;
    * @param amount amount of tokens purchased&#13;
    */&#13;
    event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);&#13;
&#13;
  &#13;
    // The token that would be sold using this contract &#13;
    XRPCToken public token;&#13;
    &#13;
    &#13;
    function newCrowdsale(uint _daysToStart, address _walletMajorOwner) public &#13;
    {&#13;
        token = XRPCToken(0xAdb41FCD3DF9FF681680203A074271D3b3Dae526);  &#13;
        &#13;
        _daysToStart = _daysToStart * 1 days;&#13;
        &#13;
        startTime = now + _daysToStart;   &#13;
        endTime = startTime + 90 days;&#13;
        &#13;
        require(endTime &gt;= startTime);&#13;
        require(_walletMajorOwner != 0x0);&#13;
        &#13;
        ownerAddresses[_walletMajorOwner] = majorOwnerShares;&#13;
        &#13;
        owners.push(_walletMajorOwner);&#13;
        &#13;
        owner = _walletMajorOwner;&#13;
    }&#13;
    &#13;
    // fallback function can be used to buy tokens&#13;
    function () public payable {&#13;
    buy(msg.sender);&#13;
    }&#13;
    &#13;
    function buy(address beneficiary) public payable&#13;
    {&#13;
        require (isCrowdsaleStopped != true);&#13;
        require (isCrowdsalePaused != true);&#13;
        &#13;
        require(beneficiary != 0x0);&#13;
        require(validPurchase());&#13;
&#13;
        uint256 weiAmount = msg.value;&#13;
        uint256 tokens = weiAmount.mul(rate);&#13;
&#13;
        // update state&#13;
        weiRaised = weiRaised.add(weiAmount);&#13;
&#13;
        token.transfer(beneficiary,tokens); &#13;
        TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);&#13;
&#13;
        forwardFunds();&#13;
    }&#13;
    &#13;
     // send ether to the fund collection wallet(s)&#13;
    function forwardFunds() internal {&#13;
      for (uint i=0;i&lt;owners.length;i++)&#13;
      {&#13;
         uint percent = ownerAddresses[owners[i]];&#13;
         uint amountToBeSent = msg.value.mul(percent);&#13;
         amountToBeSent = amountToBeSent.div(100);&#13;
         owners[i].transfer(amountToBeSent);&#13;
      }&#13;
    }&#13;
   &#13;
     /**&#13;
     * function to add a minor owner&#13;
     * can only be called by the major/actual owner wallet&#13;
     **/  &#13;
    function addMinorOwner(address minorOwner) public onlyOwner {&#13;
&#13;
        require(minorOwner != 0x0);&#13;
        require(ownerAddresses[owner] &gt;=20);&#13;
        require(ownerAddresses[minorOwner] == 0);&#13;
        owners.push(minorOwner);&#13;
        ownerAddresses[minorOwner] = 10;&#13;
        uint majorOwnerShare = ownerAddresses[owner];&#13;
        ownerAddresses[owner] = majorOwnerShare.sub(10);&#13;
    }&#13;
    &#13;
    /**&#13;
     * function to remove a minor owner&#13;
     * can only be called by the major/actual owner wallet&#13;
     **/ &#13;
    function removeMinorOwner(address minorOwner) public onlyOwner  {&#13;
        require(minorOwner != 0x0);&#13;
        require(ownerAddresses[minorOwner] &gt; 0);&#13;
        require(ownerAddresses[owner] &lt;= 90);&#13;
        ownerAddresses[minorOwner] = 0;&#13;
        uint majorOwnerShare = ownerAddresses[owner];&#13;
        ownerAddresses[owner] = majorOwnerShare.add(10);&#13;
    }&#13;
&#13;
    // @return true if the transaction can buy tokens&#13;
    function validPurchase() internal constant returns (bool) {&#13;
        bool withinPeriod = now &gt;= startTime &amp;&amp; now &lt;= endTime;&#13;
        bool nonZeroPurchase = msg.value != 0;&#13;
        return withinPeriod &amp;&amp; nonZeroPurchase;&#13;
    }&#13;
&#13;
    // @return true if crowdsale event has ended&#13;
    function hasEnded() public constant returns (bool) {&#13;
        return now &gt; endTime;&#13;
    }&#13;
  &#13;
    function showMyTokenBalance(address myAddress) public returns (uint256 tokenBalance) {&#13;
       tokenBalance = token.balanceOf(myAddress);&#13;
    }&#13;
&#13;
    /**&#13;
     * function to change the end date of the ICO&#13;
     **/ &#13;
    function setEndDate(uint256 daysToEndFromToday) public onlyOwner returns(bool) {&#13;
        daysToEndFromToday = daysToEndFromToday * 1 days;&#13;
        endTime = now + daysToEndFromToday;&#13;
    }&#13;
&#13;
    /**&#13;
     * function to set the new price &#13;
     * can only be called from owner wallet&#13;
     **/ &#13;
    function setPriceRate(uint256 newPrice) public onlyOwner returns (bool) {&#13;
        rate = newPrice;&#13;
    }&#13;
    &#13;
    /**&#13;
     * function to pause the crowdsale &#13;
     * can only be called from owner wallet&#13;
     **/&#13;
     &#13;
    function pauseCrowdsale() public onlyOwner returns(bool) {&#13;
        isCrowdsalePaused = true;&#13;
    }&#13;
&#13;
    /**&#13;
     * function to resume the crowdsale if it is paused&#13;
     * can only be called from owner wallet&#13;
     * if the crowdsale has been stopped, this function would not resume it&#13;
     **/ &#13;
    function resumeCrowdsale() public onlyOwner returns (bool) {&#13;
        isCrowdsalePaused = false;&#13;
    }&#13;
    &#13;
    /**&#13;
     * function to stop the crowdsale&#13;
     * can only be called from the owner wallet&#13;
     **/&#13;
    function stopCrowdsale() public onlyOwner returns (bool) {&#13;
        isCrowdsaleStopped = true;&#13;
    }&#13;
    &#13;
    /**&#13;
     * function to start the crowdsale manually&#13;
     * can only be called from the owner wallet&#13;
     * this function can be used if the owner wants to start the ICO before the specified start date&#13;
     * this function can also be used to undo the stopcrowdsale, in case the crowdsale is stopped due to human error&#13;
     **/&#13;
    function startCrowdsale() public onlyOwner returns (bool) {&#13;
        isCrowdsaleStopped = false;&#13;
        startTime = now; &#13;
    }&#13;
    &#13;
    /**&#13;
     * Shows the remaining tokens in the contract i.e. tokens remaining for sale&#13;
     **/ &#13;
    function tokensRemainingForSale(address contractAddress) public returns (uint balance) {&#13;
        balance = token.balanceOf(contractAddress);&#13;
    }&#13;
    &#13;
    /**&#13;
     * function to show the equity percentage of an owner - major or minor&#13;
     * can only be called from the owner wallet&#13;
     **/&#13;
    function checkOwnerShare (address owner) public onlyOwner constant returns (uint share) {&#13;
        share = ownerAddresses[owner];&#13;
    }&#13;
}