pragma solidity ^0.4.8;

/**
 * @title VNET Token - The Next Generation Value Transfering Network.
 * @author Wang Yunxiao - <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="90e7e9e8a9a6a9a2a2d0f7fdf1f9fcbef3fffd">[emailÂ protected]</a>&gt;&#13;
 */&#13;
&#13;
contract SafeMath {&#13;
    function safeMul(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
        uint256 c = a * b;&#13;
        assert(a == 0 || c / a == b);&#13;
        return c;&#13;
    }&#13;
&#13;
    function safeDiv(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
        assert(b &gt; 0);&#13;
        uint256 c = a / b;&#13;
        assert(a == b * c + a % b);&#13;
        return c;&#13;
    }&#13;
&#13;
    function safeSub(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
        assert(b &lt;= a);&#13;
        return a - b;&#13;
    }&#13;
&#13;
    function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
        uint256 c = a + b;&#13;
        assert(c &gt;= a &amp;&amp; c &gt;= b);&#13;
        return c;&#13;
    }&#13;
}&#13;
&#13;
contract VNET is SafeMath {&#13;
    string constant tokenName = 'VNET';&#13;
    string constant tokenSymbol = 'VNET';&#13;
    uint8 constant decimalUnits = 8;&#13;
&#13;
    string public name;&#13;
    string public symbol;&#13;
    uint8 public decimals;&#13;
&#13;
    uint256 public totalSupply = 100 * (10**8) * (10**8); // 100 yi&#13;
&#13;
    address public owner;&#13;
    &#13;
    mapping(address =&gt; bool) restrictedAddresses;&#13;
    mapping(address =&gt; uint256) public balanceOf;&#13;
    mapping(address =&gt; mapping(address =&gt; uint256)) public allowance;&#13;
&#13;
    /* This generates a public event on the blockchain that will notify clients */&#13;
    event Transfer(address indexed from, address indexed to, uint256 value);&#13;
&#13;
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);&#13;
&#13;
    modifier onlyOwner {&#13;
        assert(owner == msg.sender);&#13;
        _;&#13;
    }&#13;
&#13;
    /* Initializes contract with initial supply tokens to the creator of the contract */&#13;
    function VNET() public {&#13;
        balanceOf[msg.sender] = totalSupply;                // Give the creator all tokens&#13;
        name = tokenName;                                   // Set the name for display purposes&#13;
        symbol = tokenSymbol;                               // Set the symbol for display purposes&#13;
        decimals = decimalUnits;                            // Amount of decimals for display purposes&#13;
        owner = msg.sender;&#13;
    }&#13;
&#13;
    function transfer(address _to, uint256 _value) public returns (bool success) {&#13;
        require(_value &gt; 0);&#13;
        require(balanceOf[msg.sender] &gt;= _value);              // Check if the sender has enough&#13;
        require(balanceOf[_to] + _value &gt;= balanceOf[_to]);    // Check for overflows&#13;
        require(!restrictedAddresses[msg.sender]);&#13;
        require(!restrictedAddresses[_to]);&#13;
        balanceOf[msg.sender] = SafeMath.safeSub(balanceOf[msg.sender], _value);   // Subtract from the sender&#13;
        balanceOf[_to] = SafeMath.safeAdd(balanceOf[_to], _value);                 // Add the same to the recipient&#13;
        Transfer(msg.sender, _to, _value);                  // Notify anyone listening that this transfer took place&#13;
        return true;&#13;
    }&#13;
&#13;
    function approve(address _spender, uint256 _value) public returns (bool success) {&#13;
        allowance[msg.sender][_spender] = _value;            // Set allowance&#13;
        Approval(msg.sender, _spender, _value);              // Raise Approval event&#13;
        return true;&#13;
    }&#13;
&#13;
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {&#13;
        require(balanceOf[_from] &gt;= _value);                  // Check if the sender has enough&#13;
        require(balanceOf[_to] + _value &gt;= balanceOf[_to]);   // Check for overflows&#13;
        require(_value &lt;= allowance[_from][msg.sender]);      // Check allowance&#13;
        require(!restrictedAddresses[_from]);&#13;
        require(!restrictedAddresses[msg.sender]);&#13;
        require(!restrictedAddresses[_to]);&#13;
        balanceOf[_from] = SafeMath.safeSub(balanceOf[_from], _value);    // Subtract from the sender&#13;
        balanceOf[_to] = SafeMath.safeAdd(balanceOf[_to], _value);        // Add the same to the recipient&#13;
        allowance[_from][msg.sender] = SafeMath.safeSub(allowance[_from][msg.sender], _value);&#13;
        Transfer(_from, _to, _value);&#13;
        return true;&#13;
    }&#13;
&#13;
    function totalSupply() constant public returns (uint256 Supply) {&#13;
        return totalSupply;&#13;
    }&#13;
&#13;
    function balanceOf(address _owner) constant public returns (uint256 balance) {&#13;
        return balanceOf[_owner];&#13;
    }&#13;
&#13;
    function allowance(address _owner, address _spender) constant public returns (uint256 remaining) {&#13;
      return allowance[_owner][_spender];&#13;
    }&#13;
&#13;
    function() public payable {&#13;
        revert();&#13;
    }&#13;
&#13;
    /* Owner can add new restricted address or removes one */&#13;
    function editRestrictedAddress(address _newRestrictedAddress) public onlyOwner {&#13;
        restrictedAddresses[_newRestrictedAddress] = !restrictedAddresses[_newRestrictedAddress];&#13;
    }&#13;
&#13;
    function isRestrictedAddress(address _querryAddress) constant public returns (bool answer) {&#13;
        return restrictedAddresses[_querryAddress];&#13;
    }&#13;
}