/*
 ______   _________  ___   ___   _______    _______             ________  ______      
/_____/\ /________/\/__/\ /__/\ /______/\  /______/\           /_______/\/_____/\     
\::::_\/_\__.::.__\/\::\ \\  \ \\::::__\/__\::::__\/__         \__.::._\/\:::_ \ \    
 \:\/___/\  \::\ \   \::\/_\ .\ \\:\ /____/\\:\ /____/\  ___      \::\ \  \:\ \ \ \   
  \::___\/_  \::\ \   \:: ___::\ \\:\\_  _\/ \:\\_  _\/ /__/\     _\::\ \__\:\ \ \ \  
   \:\____/\  \::\ \   \: \ \\::\ \\:\_\ \ \  \:\_\ \ \ \::\ \   /__\::\__/\\:\_\ \ \ 
    \_____\/   \__\/    \__\/ \::\/ \_____\/   \_____\/  \:_\/   \________\/ \_____\/ 
  ______ _______ _    _    _____  ____   ____  _____     _____          __  __ ______  _____ 
 |  ____|__   __| |  | |  / ____|/ __ \ / __ \|  __ \   / ____|   /\   |  \/  |  ____|/ ____|
 | |__     | |  | |__| | | |  __| |  | | |  | | |  | | | |  __   /  \  | \  / | |__  | (___  
 |  __|    | |  |  __  | | | |_ | |  | | |  | | |  | | | | |_ | / /\ \ | |\/| |  __|  \___ \ 
 | |____   | |  | |  | | | |__| | |__| | |__| | |__| | | |__| |/ ____ \| |  | | |____ ____) |
 |______|  |_|  |_|  |_|  \_____|\____/ \____/|_____/   \_____/_/    \_\_|  |_|______|_____/ 
                                                                                             
                                                         BY : <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="337f5e4060584a73745e525a5f1d505c5e">[email protected]</a>&#13;
*/                            &#13;
pragma solidity ^0.4.25;&#13;
pragma experimental "v0.5.0";&#13;
contract safeApi{&#13;
    &#13;
   modifier safe(){&#13;
        address _addr = msg.sender;&#13;
        require (_addr == tx.origin,'Error Action!');&#13;
        uint256 _codeLength;&#13;
        assembly {_codeLength := extcodesize(_addr)}&#13;
        require(_codeLength == 0, "Sender not authorized!");&#13;
            _;&#13;
    }&#13;
&#13;
&#13;
    &#13;
 function toBytes(uint256 _num) internal returns (bytes _ret) {&#13;
   assembly {&#13;
        _ret := mload(0x10)&#13;
        mstore(_ret, 0x20)&#13;
        mstore(add(_ret, 0x20), _num)&#13;
    }&#13;
}&#13;
&#13;
function subStr(string _s, uint start, uint end) internal pure returns (string){&#13;
        bytes memory s = bytes(_s);&#13;
        string memory copy = new string(end - start);&#13;
//        string memory copy = new string(5);&#13;
          uint k = 0;&#13;
        for (uint i = start; i &lt; end; i++){ &#13;
            bytes(copy)[k++] = bytes(_s)[i];&#13;
        }&#13;
        return copy;&#13;
    }&#13;
     &#13;
&#13;
 function safePercent(uint256 a,uint256 b) &#13;
      internal&#13;
      constant&#13;
      returns(uint256)&#13;
      {&#13;
        assert(a&gt;0 &amp;&amp; a &lt;=100);&#13;
        return  div(mul(b,a),100);&#13;
      }&#13;
      &#13;
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
    uint256 c = a * b;&#13;
    assert(a == 0 || c / a == b);&#13;
    return c;&#13;
  }&#13;
 &#13;
  function div(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
    // assert(b &gt; 0); // Solidity automatically throws when dividing by 0∂&#13;
    uint256 c = a / b;&#13;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold&#13;
    return c;&#13;
  }&#13;
 &#13;
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
    assert(b &lt;= a);&#13;
    return a - b;&#13;
  }&#13;
 &#13;
  function add(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
    uint256 c = a + b;&#13;
    assert(c &gt;= a);&#13;
    return c;&#13;
  }&#13;
&#13;
}&#13;
contract gameFinances is safeApi{&#13;
mapping(bytes32=&gt;uint)  validQueryId;&#13;
    struct player&#13;
    {&#13;
        uint64 id;&#13;
        uint32 affNumLevel_1;&#13;
        uint32 affNumLevel_2;&#13;
        uint32 timeStamp;&#13;
        uint balance;//wei&#13;
        uint gameBalance;&#13;
        address addr;&#13;
    }&#13;
&#13;
    struct  gameConfig&#13;
    {&#13;
         uint8 eachPct;&#13;
         uint8 feePct;&#13;
         uint8 poolPct;&#13;
         uint8 adminPct;&#13;
         uint8 levelPct1;&#13;
         uint8 levelPct2;&#13;
         uint16 index;&#13;
         uint32 maxPct;&#13;
         uint64 autoPlayId;&#13;
    }&#13;
    &#13;
   struct  orderInfo&#13;
    {  &#13;
       uint64 pid;&#13;
       uint32 pct;&#13;
       uint32 times;&#13;
       uint eth;&#13;
       uint balance;&#13;
    }&#13;
    &#13;
    struct gameInfo{&#13;
       uint64 winner;&#13;
       uint32 pointer;&#13;
       uint bonus;//Additional bonuses other than the prize pool are issued by the admin&#13;
       uint totalEth;&#13;
       uint lastTime;&#13;
       uint startTime;&#13;
       orderInfo[] list;&#13;
       mapping(uint64=&gt;playerRecord) pinfo;&#13;
    }&#13;
    &#13;
      struct  playerRecord&#13;
    {  &#13;
       bool status;&#13;
       uint32 times;&#13;
    } &#13;
    &#13;
    event join(&#13;
        uint16 indexed index,&#13;
        uint key,&#13;
        address indexed addr&#13;
    );&#13;
    &#13;
   &#13;
    event next_game(&#13;
        uint16 indexed index&#13;
        ); &#13;
    &#13;
     mapping (uint64 =&gt; player)  player_;&#13;
     mapping (address =&gt; uint64)  playAddr_;&#13;
     mapping (uint64 =&gt; uint64)  playAff_;&#13;
     mapping(uint16 =&gt;gameInfo) gameInfo_;&#13;
&#13;
     gameConfig  gameConfig_;&#13;
     address  admin_;&#13;
  &#13;
     constructor() public {&#13;
         admin_ = msg.sender;&#13;
         getPlayId(msg.sender);&#13;
         gameConfig_.eachPct=20;&#13;
         gameConfig_.maxPct=100;&#13;
         gameConfig_.feePct=6;&#13;
         gameConfig_.poolPct=70;&#13;
         gameConfig_.adminPct=15;&#13;
         gameConfig_.levelPct1=10;&#13;
         gameConfig_.levelPct2=5;&#13;
         gameConfig_.index=1;&#13;
         gameInfo_[1].startTime=now;&#13;
    }&#13;
    &#13;
function  joinGame(address _level1, address _level2) external payable safe(){&#13;
        uint16 _index=gameConfig_.index;&#13;
        gameInfo storage _g=gameInfo_[_index];&#13;
        uint _now=now;&#13;
        if(_g.lastTime&gt;0){&#13;
          require(_g.lastTime+86400 &gt;_now,'Please wait for the start of the next round');&#13;
        }&#13;
        uint64 _pid=getPlayId(msg.sender);&#13;
        initAddf(_pid,_level1,_level2);&#13;
        uint _value=msg.value;&#13;
        require(_value&gt;=0.1 ether &amp;&amp; _value&lt;= 100 ether,'Eth Error');&#13;
        require(_value%0.1 ether==0,'Eth Error2');&#13;
        playerRecord storage _pr=_g.pinfo[_pid];&#13;
        _g.totalEth=add(_g.totalEth,_value);&#13;
        require(_pr.status==false,'Last settlement has not been completed');&#13;
        _pr.status=true;&#13;
        _pr.times++;&#13;
         gameMatch(_g,_value);&#13;
         uint32 _pct=gameConfig_.maxPct;&#13;
        if(_pr.times&lt;5){&#13;
               _pct=_pr.times * gameConfig_.eachPct;&#13;
        }&#13;
        uint _balance = add(_value,safePercent(_pct,_value));&#13;
        _g.list.push(orderInfo(&#13;
            _pid,&#13;
            _pct,&#13;
             _pr.times,&#13;
            _value,&#13;
            _balance&#13;
          ));&#13;
      _g.lastTime=_now;&#13;
&#13;
      emit join(_index,_g.list.length,msg.sender);&#13;
}&#13;
&#13;
//Start the next round of games&#13;
function nextGame() external safe(){&#13;
    require(msg.sender == admin_,'Error 1');&#13;
    uint16 _index=gameConfig_.index;&#13;
    uint  _endTime=gameInfo_[_index].lastTime+86400;&#13;
    uint _now=now;&#13;
    require(_now &gt; _endTime,'Error 2');&#13;
     emit next_game(_index);&#13;
     uint _lastIndex=gameInfo_[_index].list.length;&#13;
     //Transfer to the winner&#13;
     if(_lastIndex&gt;0){&#13;
         uint64 _winnerId=gameInfo_[_index].list[_lastIndex-1].pid;&#13;
         uint _prizePool=safePercent(gameConfig_.feePct,gameInfo_[_index].totalEth);&#13;
         _prizePool=safePercent(gameConfig_.poolPct,_prizePool);&#13;
         _prizePool=add(_prizePool,gameInfo_[_index].bonus);//Additional bonuses other than the prize pool are issued by the admin&#13;
         uint _adminFee =  safePercent(gameConfig_.feePct,_prizePool);//Admin fee&#13;
         uint64 _adminId=playAddr_[admin_];&#13;
         player_[_adminId].balance=add(player_[_adminId].balance,_adminFee);&#13;
         uint _winnerAmount=sub(_prizePool,_adminFee);&#13;
         player_[_winnerId].addr.transfer(_winnerAmount);&#13;
     }&#13;
    _index++;&#13;
    gameConfig_.index=_index;&#13;
    gameInfo_[_index].startTime=_now;&#13;
}&#13;
&#13;
function gameMatch(gameInfo storage _g,  uint _value) private{&#13;
        uint _length=_g.list.length;&#13;
        if(_length==0){&#13;
             uint64 adminId=playAddr_[admin_];&#13;
             player_[adminId].gameBalance=add(player_[adminId].gameBalance,_value);&#13;
             return;&#13;
        }&#13;
            uint _myBalance=_value;&#13;
            for(uint32 i=_g.pointer;i&lt;_length;i++){&#13;
                orderInfo storage  _gip=_g.list[i];&#13;
                if(_gip.balance==0)&#13;
                     break;&#13;
                if(_myBalance&gt;=_gip.balance){&#13;
                    _g.pinfo[_gip.pid].status=false;&#13;
                    _myBalance=sub(_myBalance,_gip.balance);&#13;
                    player_[_gip.pid].gameBalance=add( player_[_gip.pid].gameBalance,_gip.balance);&#13;
                    _gip.balance=0;&#13;
                    _g.pointer++;&#13;
                }else{&#13;
                    _gip.balance=sub(_gip.balance,_myBalance);&#13;
                    player_[_gip.pid].gameBalance=add(player_[_gip.pid].gameBalance,_myBalance);&#13;
                    _myBalance=0;&#13;
                    break;&#13;
               }&#13;
            }&#13;
            if(_myBalance&gt;0){&#13;
                uint64 adminId=playAddr_[admin_];&#13;
                player_[adminId].gameBalance=add(player_[adminId].gameBalance,_myBalance);&#13;
            }&#13;
}&#13;
    &#13;
function initAddf(uint64 _pid,address _level1, address _level2) private{&#13;
    &#13;
            address  _errorAddr=address(0);&#13;
            uint64 _level1Pid=playAff_[_pid];&#13;
            if(_level1Pid&gt;0 || _level1 ==_errorAddr || _level1==_level2 || msg.sender==_level1 || msg.sender==_level2)&#13;
               return;&#13;
           if(_level1Pid==0 &amp;&amp; _level1 == _errorAddr){&#13;
                  uint64 adminId=playAddr_[admin_];&#13;
                  playAff_[_pid]=adminId;&#13;
                  return;&#13;
           }&#13;
              _level1Pid= playAddr_[_level1];&#13;
              if(_level1Pid==0){&#13;
                 _level1Pid=getPlayId(_level1);&#13;
              }&#13;
                  player_[_level1Pid].affNumLevel_1++;&#13;
                  playAff_[_pid]=_level1Pid;&#13;
                  uint64 _level2Pid=playAff_[_level1Pid];&#13;
                  &#13;
                  if(_level2Pid==0 &amp;&amp;  _level2 == _errorAddr){&#13;
                     return;   &#13;
                  }&#13;
                     _level2Pid= playAddr_[_level2];&#13;
                    if(_level2Pid==0){&#13;
                       _level2Pid=getPlayId(_level2);&#13;
                        playAff_[_level1Pid]=_level2Pid;&#13;
                    }&#13;
                    player_[_level2Pid].affNumLevel_2++;&#13;
}&#13;
&#13;
    &#13;
function withdraw(uint64 pid) safe() external{&#13;
        require(playAddr_[msg.sender] == pid,'Error Action');&#13;
        require(player_[pid].addr == msg.sender,'Error Action');&#13;
        require(player_[pid].balance &gt; 0,'Insufficient balance');&#13;
        uint balance =player_[pid].balance;&#13;
        player_[pid].balance=0;&#13;
        player_[pid].addr.transfer(balance);&#13;
}&#13;
&#13;
&#13;
 function withdrawGame(uint64 pid) safe() external{&#13;
        require(playAddr_[msg.sender] == pid,'Error Action');&#13;
        require(player_[pid].addr == msg.sender,'Error Action');&#13;
        require(player_[pid].gameBalance &gt;0,'Insufficient balance');&#13;
        uint _balance =player_[pid].gameBalance;&#13;
        player_[pid].gameBalance=0;&#13;
        uint64 _level1Pid=playAff_[pid];&#13;
        uint64 _adminId=playAddr_[admin_];&#13;
        //Withdrawal fee&#13;
        uint _fee=safePercent(gameConfig_.feePct,_balance);&#13;
        //The prize pool has been increased when the investment is added, there is no need to operate here.&#13;
        //Admin&#13;
        uint _adminAmount=safePercent(gameConfig_.adminPct,_fee);&#13;
        &#13;
        //1 Level&#13;
        uint levellAmount=safePercent(gameConfig_.levelPct1,_fee);&#13;
        &#13;
        //2 Level&#13;
        uint level2Amount=safePercent(gameConfig_.levelPct2,_fee);&#13;
        if(_level1Pid &gt;0 &amp;&amp; _level1Pid!=_adminId){&#13;
            player_[_level1Pid].balance=add(player_[_level1Pid].balance,levellAmount);&#13;
            uint64 _level2Pid=playAff_[_level1Pid];&#13;
             if(_level2Pid&gt;0){&#13;
                player_[_level2Pid].balance=add(player_[_level2Pid].balance,level2Amount);&#13;
             }else{&#13;
                _adminAmount=add(_adminAmount,level2Amount);&#13;
             }&#13;
        }else{&#13;
            _adminAmount=add(_adminAmount,add(levellAmount,level2Amount));&#13;
        }&#13;
        player_[_adminId].balance=add(player_[_adminId].balance,_adminAmount);&#13;
        return player_[pid].addr.transfer(sub(_balance,_fee));&#13;
    }&#13;
   &#13;
     //2020.01.01 Used to update the game&#13;
   function updateGame() external safe() {&#13;
        uint time=1577808000;&#13;
        require(now &gt; time,'Time has not arrived');&#13;
        require(msg.sender == admin_,'Error');&#13;
        selfdestruct(admin_);&#13;
    }&#13;
   &#13;
    function getPlayId(address addr) private returns(uint64){&#13;
        require (address(0)!=addr,'Error Addr');&#13;
        if(playAddr_[addr] &gt;0){&#13;
         return playAddr_[addr];&#13;
        }&#13;
              gameConfig_.autoPlayId++;&#13;
              playAddr_[addr]=  gameConfig_.autoPlayId;&#13;
              player memory _p;&#13;
              _p.id=  gameConfig_.autoPlayId;&#13;
              _p.addr=addr;&#13;
              _p.timeStamp=uint32(now);&#13;
              player_[gameConfig_.autoPlayId]=_p;&#13;
              return gameConfig_.autoPlayId;&#13;
   }&#13;
   &#13;
   function getGameInfo(uint16 _index)external view returns(&#13;
       uint16,uint,uint,uint,uint,uint,uint&#13;
       ){ &#13;
        gameInfo memory _g;&#13;
       if(_index==0){&#13;
             _g=gameInfo_[gameConfig_.index];&#13;
       }else{&#13;
             _g=gameInfo_[_index];&#13;
       }&#13;
       return(&#13;
             gameConfig_.index,&#13;
             _g.bonus,//Additional bonuses other than the prize pool are issued by the admin&#13;
            _g.totalEth,&#13;
            _g.startTime,&#13;
            _g.lastTime,&#13;
            _g.list.length,&#13;
            gameInfo_[gameConfig_.index].list.length&#13;
        );&#13;
  }&#13;
  &#13;
  function getOrderInfo(uint16 _index, uint64 _key)external view returns(uint32,uint,uint,uint32){ &#13;
           uint64 _pid =playAddr_[msg.sender];&#13;
       orderInfo memory _g=gameInfo_[_index].list[_key];&#13;
       require(_g.pid==_pid,'Error 404');&#13;
       return(&#13;
            _g.pct,&#13;
            _g.eth,&#13;
            _g.balance,&#13;
            _g.times&#13;
        );&#13;
  }&#13;
    &#13;
  function getMyGameStatus(uint16 _index)external view returns (bool,uint32){&#13;
         uint64 _pid =playAddr_[msg.sender];&#13;
         playerRecord memory _g;&#13;
       if(_index&gt;0){&#13;
           _g=gameInfo_[_index].pinfo[_pid];&#13;
       }else{&#13;
             _g=gameInfo_[gameConfig_.index].pinfo[_pid];&#13;
       }&#13;
      return (&#13;
            _g.status,&#13;
            _g.times&#13;
          );&#13;
  }&#13;
  &#13;
 function getMyInfo()external view returns(uint64,uint,uint32,uint32,uint32,uint){ &#13;
       uint64 _pid =playAddr_[msg.sender];&#13;
       player memory _p=player_[_pid];&#13;
       return(&#13;
            _pid,&#13;
            _p.balance,&#13;
            _p.affNumLevel_1,&#13;
            _p.affNumLevel_2,&#13;
            _p.timeStamp,&#13;
            _p.gameBalance&#13;
        );&#13;
  }&#13;
  &#13;
  //Add extra prizes to the prize pool ETH&#13;
  function payment() external payable safe(){&#13;
      //Additional bonuses other than the prize pool are issued by the admin&#13;
      if(msg.value&gt;0)&#13;
     gameInfo_[gameConfig_.index].bonus=add(gameInfo_[gameConfig_.index].bonus,msg.value);&#13;
  }&#13;
  &#13;
&#13;
  function getConfig() external view returns(&#13;
       uint8,uint8,uint8,uint8,uint8,uint8,uint32&#13;
       ){&#13;
     return (      &#13;
         gameConfig_.eachPct,&#13;
         gameConfig_.feePct,&#13;
         gameConfig_.poolPct,&#13;
         gameConfig_.adminPct,&#13;
         gameConfig_.levelPct1,&#13;
         gameConfig_.levelPct2,&#13;
        gameConfig_.maxPct&#13;
      );&#13;
    }&#13;
}