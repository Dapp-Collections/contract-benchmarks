pragma solidity ^0.4.18;
/* ==================================================================== */
/* Copyright (c) 2018 The MagicAcademy Project.  All rights reserved.
/* 
/* https://www.magicacademy.io One of the world's first idle strategy games of blockchain 
/*  
/* authors <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="0f7d6e6661764f6366796a7c7b6e7d216c6062">[email protected]</a>/<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="13597c7d6a3d5566537f7a6576606772613d707c7e">[email protected]</a>&#13;
/*                 &#13;
/* ==================================================================== */&#13;
/**&#13;
 * @title Ownable&#13;
 * @dev The Ownable contract has an owner address, and provides basic authorization control&#13;
 * functions, this simplifies the implementation of "user permissions".&#13;
 */&#13;
contract Ownable {&#13;
  address public owner;&#13;
&#13;
  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);&#13;
&#13;
  /*&#13;
   * @dev The Ownable constructor sets the original `owner` of the contract to the sender&#13;
   * account.&#13;
   */&#13;
  function Ownable() public {&#13;
    owner = msg.sender;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Throws if called by any account other than the owner.&#13;
   */&#13;
  modifier onlyOwner() {&#13;
    require(msg.sender == owner);&#13;
    _;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Allows the current owner to transfer control of the contract to a newOwner.&#13;
   * @param newOwner The address to transfer ownership to.&#13;
   */&#13;
  function transferOwnership(address newOwner) public onlyOwner {&#13;
    require(newOwner != address(0));&#13;
    OwnershipTransferred(owner, newOwner);&#13;
    owner = newOwner;&#13;
  }&#13;
}&#13;
&#13;
contract AccessAdmin is Ownable {&#13;
&#13;
  /// @dev Admin Address&#13;
  mapping (address =&gt; bool) adminContracts;&#13;
&#13;
  /// @dev Trust contract&#13;
  mapping (address =&gt; bool) actionContracts;&#13;
&#13;
  function setAdminContract(address _addr, bool _useful) public onlyOwner {&#13;
    require(_addr != address(0));&#13;
    adminContracts[_addr] = _useful;&#13;
  }&#13;
&#13;
  modifier onlyAdmin {&#13;
    require(adminContracts[msg.sender]); &#13;
    _;&#13;
  }&#13;
&#13;
  function setActionContract(address _actionAddr, bool _useful) public onlyAdmin {&#13;
    actionContracts[_actionAddr] = _useful;&#13;
  }&#13;
&#13;
  modifier onlyAccess() {&#13;
    require(actionContracts[msg.sender]);&#13;
    _;&#13;
  }&#13;
}&#13;
&#13;
interface CardsInterface {&#13;
  function balanceOf(address player) public constant returns(uint256);&#13;
  function updatePlayersCoinByOut(address player) external;&#13;
  function updatePlayersCoinByPurchase(address player, uint256 purchaseCost) public;&#13;
  function removeUnitMultipliers(address player, uint256 upgradeClass, uint256 unitId, uint256 upgradeValue) external;&#13;
  function upgradeUnitMultipliers(address player, uint256 upgradeClass, uint256 unitId, uint256 upgradeValue) external;&#13;
}&#13;
interface RareInterface {&#13;
  function getRareItemsOwner(uint256 rareId) external view returns (address);&#13;
  function getRareItemsPrice(uint256 rareId) external view returns (uint256);&#13;
    function getRareInfo(uint256 _tokenId) external view returns (&#13;
    uint256 sellingPrice,&#13;
    address owner,&#13;
    uint256 nextPrice,&#13;
    uint256 rareClass,&#13;
    uint256 cardId,&#13;
    uint256 rareValue&#13;
  ); &#13;
  function transferToken(address _from, address _to, uint256 _tokenId) external;&#13;
  function transferTokenByContract(uint256 _tokenId,address _to) external;&#13;
  function setRarePrice(uint256 _rareId, uint256 _price) external;&#13;
  function rareStartPrice() external view returns (uint256);&#13;
}&#13;
contract CardsRaffle is AccessAdmin {&#13;
  using SafeMath for SafeMath;&#13;
&#13;
  function CardsRaffle() public {&#13;
    setAdminContract(msg.sender,true);&#13;
    setActionContract(msg.sender,true);&#13;
  }&#13;
  //data contract&#13;
  CardsInterface public cards ;&#13;
  RareInterface public rare;&#13;
&#13;
  function setCardsAddress(address _address) external onlyOwner {&#13;
    cards = CardsInterface(_address);&#13;
  }&#13;
&#13;
  //rare cards&#13;
  function setRareAddress(address _address) external onlyOwner {&#13;
    rare = RareInterface(_address);&#13;
  }&#13;
&#13;
  function getRareAddress() public view returns (address) {&#13;
    return rare;&#13;
  }&#13;
&#13;
  //event&#13;
  event UnitBought(address player, uint256 unitId, uint256 amount);&#13;
  event RaffleSuccessful(address winner);&#13;
&#13;
  // Raffle structures&#13;
  struct TicketPurchases {&#13;
    TicketPurchase[] ticketsBought;&#13;
    uint256 numPurchases; // Allows us to reset without clearing TicketPurchase[] (avoids potential for gas limit)&#13;
    uint256 raffleRareId;&#13;
  }&#13;
    &#13;
  // Allows us to query winner without looping (avoiding potential for gas limit)&#13;
  struct TicketPurchase {&#13;
    uint256 startId;&#13;
    uint256 endId;&#13;
  }&#13;
    &#13;
  // Raffle tickets&#13;
  mapping(address =&gt; TicketPurchases) private ticketsBoughtByPlayer;&#13;
  mapping(uint256 =&gt; address[]) private rafflePlayers; // Keeping a seperate list for each raffle has it's benefits. &#13;
&#13;
  uint256 private constant RAFFLE_TICKET_BASE_PRICE = 10000;&#13;
&#13;
  // Current raffle info  &#13;
  uint256 private raffleEndTime;&#13;
  uint256 private raffleRareId;&#13;
  uint256 private raffleTicketsBought;&#13;
  address private raffleWinner; // Address of winner&#13;
  bool private raffleWinningTicketSelected;&#13;
  uint256 private raffleTicketThatWon;&#13;
&#13;
  // Raffle for rare items  &#13;
  function buyRaffleTicket(uint256 amount) external {&#13;
    require(raffleEndTime &gt;= block.timestamp);  //close it if need test&#13;
    require(amount &gt; 0);&#13;
        &#13;
    uint256 ticketsCost = SafeMath.mul(RAFFLE_TICKET_BASE_PRICE, amount);&#13;
    require(cards.balanceOf(msg.sender) &gt;= ticketsCost);&#13;
        &#13;
    // Update player's jade  &#13;
    cards.updatePlayersCoinByPurchase(msg.sender, ticketsCost);&#13;
        &#13;
    // Handle new tickets&#13;
    TicketPurchases storage purchases = ticketsBoughtByPlayer[msg.sender];&#13;
        &#13;
    // If we need to reset tickets from a previous raffle&#13;
    if (purchases.raffleRareId != raffleRareId) {&#13;
      purchases.numPurchases = 0;&#13;
      purchases.raffleRareId = raffleRareId;&#13;
      rafflePlayers[raffleRareId].push(msg.sender); // Add user to raffle&#13;
    }&#13;
        &#13;
    // Store new ticket purchase &#13;
    if (purchases.numPurchases == purchases.ticketsBought.length) {&#13;
      purchases.ticketsBought.length = SafeMath.add(purchases.ticketsBought.length,1);&#13;
    }&#13;
    purchases.ticketsBought[purchases.numPurchases++] = TicketPurchase(raffleTicketsBought, raffleTicketsBought + (amount - 1)); // (eg: buy 10, get id's 0-9)&#13;
        &#13;
    // Finally update ticket total&#13;
    raffleTicketsBought = SafeMath.add(raffleTicketsBought,amount);&#13;
    //event&#13;
    UnitBought(msg.sender,raffleRareId,amount);&#13;
  } &#13;
&#13;
  /// @dev start raffle&#13;
  function startRareRaffle(uint256 endTime, uint256 rareId) external onlyAdmin {&#13;
    require(rareId&gt;0);&#13;
    require(rare.getRareItemsOwner(rareId) == getRareAddress());&#13;
    require(block.timestamp &lt; endTime); //close it if need test&#13;
&#13;
    if (raffleRareId != 0) { // Sanity to assure raffle has ended before next one starts&#13;
      require(raffleWinner != 0);&#13;
    }&#13;
&#13;
    // Reset previous raffle info&#13;
    raffleWinningTicketSelected = false;&#13;
    raffleTicketThatWon = 0;&#13;
    raffleWinner = 0;&#13;
    raffleTicketsBought = 0;&#13;
        &#13;
    // Set current raffle info&#13;
    raffleEndTime = endTime;&#13;
    raffleRareId = rareId;&#13;
  }&#13;
&#13;
  function awardRafflePrize(address checkWinner, uint256 checkIndex) external { &#13;
    require(raffleEndTime &lt; block.timestamp);  //close it if need test&#13;
    require(raffleWinner == 0);&#13;
    require(rare.getRareItemsOwner(raffleRareId) == getRareAddress());&#13;
        &#13;
    if (!raffleWinningTicketSelected) {&#13;
      drawRandomWinner(); // Ideally do it in one call (gas limit cautious)&#13;
    }&#13;
        &#13;
  // Reduce gas by (optionally) offering an address to _check_ for winner&#13;
    if (checkWinner != 0) {&#13;
      TicketPurchases storage tickets = ticketsBoughtByPlayer[checkWinner];&#13;
      if (tickets.numPurchases &gt; 0 &amp;&amp; checkIndex &lt; tickets.numPurchases &amp;&amp; tickets.raffleRareId == raffleRareId) {&#13;
        TicketPurchase storage checkTicket = tickets.ticketsBought[checkIndex];&#13;
        if (raffleTicketThatWon &gt;= checkTicket.startId &amp;&amp; raffleTicketThatWon &lt;= checkTicket.endId) {&#13;
          assignRafflePrize(checkWinner); // WINNER!&#13;
          return;&#13;
        }&#13;
      }&#13;
    }&#13;
        &#13;
  // Otherwise just naively try to find the winner (will work until mass amounts of players)&#13;
    for (uint256 i = 0; i &lt; rafflePlayers[raffleRareId].length; i++) {&#13;
      address player = rafflePlayers[raffleRareId][i];&#13;
      TicketPurchases storage playersTickets = ticketsBoughtByPlayer[player];&#13;
            &#13;
      uint256 endIndex = playersTickets.numPurchases - 1;&#13;
      // Minor optimization to avoid checking every single player&#13;
      if (raffleTicketThatWon &gt;= playersTickets.ticketsBought[0].startId &amp;&amp; raffleTicketThatWon &lt;= playersTickets.ticketsBought[endIndex].endId) {&#13;
        for (uint256 j = 0; j &lt; playersTickets.numPurchases; j++) {&#13;
          TicketPurchase storage playerTicket = playersTickets.ticketsBought[j];&#13;
          if (raffleTicketThatWon &gt;= playerTicket.startId &amp;&amp; raffleTicketThatWon &lt;= playerTicket.endId) {&#13;
            assignRafflePrize(player); // WINNER!&#13;
            return;&#13;
          }&#13;
        }&#13;
      }&#13;
    }&#13;
  }&#13;
&#13;
  function assignRafflePrize(address winner) internal {&#13;
    raffleWinner = winner;&#13;
    uint256 newPrice = (rare.rareStartPrice() * 25) / 20;&#13;
    rare.transferTokenByContract(raffleRareId,winner);&#13;
    rare.setRarePrice(raffleRareId,newPrice);&#13;
       &#13;
    cards.updatePlayersCoinByOut(winner);&#13;
    uint256 upgradeClass;&#13;
    uint256 unitId;&#13;
    uint256 upgradeValue;&#13;
    (,,,,upgradeClass, unitId, upgradeValue) = rare.getRareInfo(raffleRareId);&#13;
    &#13;
    cards.upgradeUnitMultipliers(winner, upgradeClass, unitId, upgradeValue);&#13;
    //event&#13;
    RaffleSuccessful(winner);&#13;
  }&#13;
  &#13;
  // Random enough for small contests (Owner only to prevent trial &amp; error execution)&#13;
  function drawRandomWinner() public onlyAdmin {&#13;
    require(raffleEndTime &lt; block.timestamp); //close it if need to test&#13;
    require(!raffleWinningTicketSelected);&#13;
        &#13;
    uint256 seed = SafeMath.add(raffleTicketsBought , block.timestamp);&#13;
    raffleTicketThatWon = addmod(uint256(block.blockhash(block.number-1)), seed, raffleTicketsBought);&#13;
    raffleWinningTicketSelected = true;&#13;
  }  &#13;
&#13;
  // To allow clients to verify contestants&#13;
  function getRafflePlayers(uint256 raffleId) external constant returns (address[]) {&#13;
    return (rafflePlayers[raffleId]);&#13;
  }&#13;
&#13;
    // To allow clients to verify contestants&#13;
  function getPlayersTickets(address player) external constant returns (uint256[], uint256[]) {&#13;
    TicketPurchases storage playersTickets = ticketsBoughtByPlayer[player];&#13;
        &#13;
    if (playersTickets.raffleRareId == raffleRareId) {&#13;
      uint256[] memory startIds = new uint256[](playersTickets.numPurchases);&#13;
      uint256[] memory endIds = new uint256[](playersTickets.numPurchases);&#13;
            &#13;
      for (uint256 i = 0; i &lt; playersTickets.numPurchases; i++) {&#13;
        startIds[i] = playersTickets.ticketsBought[i].startId;&#13;
        endIds[i] = playersTickets.ticketsBought[i].endId;&#13;
      }&#13;
    }&#13;
        &#13;
    return (startIds, endIds);&#13;
  }&#13;
&#13;
&#13;
  // To display on website&#13;
  function getLatestRaffleInfo() external constant returns (uint256, uint256, uint256, address, uint256) {&#13;
    return (raffleEndTime, raffleRareId, raffleTicketsBought, raffleWinner, raffleTicketThatWon);&#13;
  }    &#13;
}&#13;
&#13;
library SafeMath {&#13;
&#13;
  /**&#13;
  * @dev Multiplies two numbers, throws on overflow.&#13;
  */&#13;
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
    if (a == 0) {&#13;
      return 0;&#13;
    }&#13;
    uint256 c = a * b;&#13;
    assert(c / a == b);&#13;
    return c;&#13;
  }&#13;
&#13;
  /**&#13;
  * @dev Integer division of two numbers, truncating the quotient.&#13;
  */&#13;
  function div(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
    // assert(b &gt; 0); // Solidity automatically throws when dividing by 0&#13;
    uint256 c = a / b;&#13;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold&#13;
    return c;&#13;
  }&#13;
&#13;
  /**&#13;
  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).&#13;
  */&#13;
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
    assert(b &lt;= a);&#13;
    return a - b;&#13;
  }&#13;
&#13;
  /**&#13;
  * @dev Adds two numbers, throws on overflow.&#13;
  */&#13;
  function add(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
    uint256 c = a + b;&#13;
    assert(c &gt;= a);&#13;
    return c;&#13;
  }&#13;
}