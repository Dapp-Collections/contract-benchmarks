pragma solidity ^0.4.13;
// **-----------------------------------------------
// [Assistive Reality ARX ERC20 token & crowdsale contract w/10% dev alloc]
// [https://aronline.io/icoinfo]
// [v3.2 final released 05/09/17 final masterARXsale32mainnet.sol]
// [Adapted from Ethereum standard crowdsale contract]
// [Contact <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="a1d2d5c0c7c7e1c0d3cecfcdc8cfc48fc8ce">[emailÂ protected]</a> for any queries]&#13;
// [Join us in changing the world]&#13;
// [aronline.io]&#13;
// **-----------------------------------------------&#13;
// ERC Token Standard #20 Interface&#13;
// https://github.com/ethereum/EIPs/issues/20&#13;
// -------------------------------------------------&#13;
// Security reviews completed 05/09/17 [passed OK]&#13;
// Functional reviews completed 05/09/17 [passed OK]&#13;
// Final code revision and regression test cycle complete 05/09/17 [passed]&#13;
// https://github.com/assistivereality/ico/blob/master/3.2crowdsaletestsARXmainnet.txt&#13;
// -------------------------------------------------&#13;
contract owned { // security reviewed 05/09/17&#13;
    address public owner;&#13;
&#13;
    function owned() {&#13;
        owner = msg.sender;&#13;
    }&#13;
    modifier onlyOwner {&#13;
        require(msg.sender == owner);&#13;
        _;&#13;
    }&#13;
    function transferOwnership(address newOwner) onlyOwner {&#13;
        owner = newOwner;&#13;
    }&#13;
}&#13;
&#13;
contract SafeMath { // security reviewed 05/09/17&#13;
  function safeMul(uint256 a, uint256 b) internal returns (uint256) {&#13;
    uint256 c = a * b;&#13;
    safeAssert(a == 0 || c / a == b);&#13;
    return c;&#13;
  }&#13;
&#13;
  function safeDiv(uint256 a, uint256 b) internal returns (uint256) {&#13;
    safeAssert(b &gt; 0);&#13;
    uint256 c = a / b;&#13;
    safeAssert(a == b * c + a % b);&#13;
    return c;&#13;
  }&#13;
&#13;
  function safeSub(uint256 a, uint256 b) internal returns (uint256) {&#13;
    safeAssert(b &lt;= a);&#13;
    return a - b;&#13;
  }&#13;
&#13;
  function safeAdd(uint256 a, uint256 b) internal returns (uint256) {&#13;
    uint256 c = a + b;&#13;
    safeAssert(c&gt;=a &amp;&amp; c&gt;=b);&#13;
    return c;&#13;
  }&#13;
&#13;
  function safeAssert(bool assertion) internal {&#13;
    if (!assertion) revert();&#13;
  }&#13;
}&#13;
&#13;
contract ERC20Interface is owned, SafeMath { // security reviewed 05/09/17&#13;
    function totalSupply() constant returns (uint256 tokenTotalSupply);&#13;
    function balanceOf(address _owner) constant returns (uint256 balance);&#13;
    function transfer(address _to, uint256 _value) returns (bool success);&#13;
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);&#13;
    function approve(address _spender, uint256 _value) returns (bool success);&#13;
    function allowance(address _owner, address _spender) constant returns (uint256 remaining);&#13;
    event Buy(address indexed _sender, uint256 _eth, uint256 _ARX);&#13;
    event Transfer(address indexed _from, address indexed _to, uint256 _value);&#13;
    event Burn(address _from, uint256 _value);&#13;
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);&#13;
    event Refund(address indexed _refunder, uint256 _value);&#13;
}&#13;
&#13;
contract ARXCrowdsale is ERC20Interface { // security reviewed 05/09/17&#13;
    // deployment variables for dynamic supply token&#13;
    string  public constant standard              = "ARX";&#13;
    string  public constant name                  = "ARX";&#13;
    string  public constant symbol                = "ARX";&#13;
    uint8   public constant decimals              = 18;&#13;
    uint256 _totalSupply                          = 0;&#13;
&#13;
    // multi-sig addresses and price variable&#13;
    address public admin = owner;                               // admin address&#13;
    address public beneficiaryMultiSig;                         // beneficiaryMultiSig (founder group) multi-sig wallet account&#13;
    address public foundationFundMultisig;                      // foundationFundMultisig multi-sig wallet address - Assistive Reality foundation fund&#13;
    uint256 public tokensPerEthPrice;                           // priceVar e.g. 2,000 tokens per Eth&#13;
&#13;
    // uint256 values for min,max,caps,tracking&#13;
    uint256 public amountRaisedInWei;                           // total amount raised in Wei e.g. 21 000 000 000 000 000 000 = 21 Eth&#13;
    uint256 public fundingMaxInWei;                             // funding max in Wei e.g. 21 000 000 000 000 000 000 = 21 Eth&#13;
    uint256 public fundingMinInWei;                             // funding min in Wei e.g. 11 000 000 000 000 000 000 = 11 Eth&#13;
    uint256 public fundingMaxInEth;                             // funding max in Eth (approx) e.g. 21 Eth&#13;
    uint256 public fundingMinInEth;                             // funding min in Eth (approx) e.g. 11 Eth&#13;
    uint256 public remainingCapInWei;                           // amount of cap remaining to raise in Wei e.g. 1 200 000 000 000 000 000 = 1.2 Eth remaining&#13;
    uint256 public remainingCapInEth;                           // amount of cap remaining to raise in Eth (approx) e.g. 1&#13;
    uint256 public foundationFundTokenCountInWei;               // 10% additional tokens generated and sent to foundationFundMultisig/Assistive Reality foundation, 18 decimals&#13;
&#13;
    // loop control, ICO startup and limiters&#13;
    string  public CurrentStatus                  = "";         // current crowdsale status&#13;
    uint256 public fundingStartBlock;                           // crowdsale start block#&#13;
    uint256 public fundingEndBlock;                             // crowdsale end block#&#13;
    bool    public isCrowdSaleFinished            = false;      // boolean for crowdsale completed or not&#13;
    bool    public isCrowdSaleSetup               = false;      // boolean for crowdsale setup&#13;
    bool    public halted                         = false;      // boolean for halted or not&#13;
    bool    public founderTokensAvailable         = false;      // variable to set false after generating founderTokens&#13;
&#13;
    // balance mapping and transfer allowance array&#13;
    mapping(address =&gt; uint256) balances;&#13;
    mapping(address =&gt; mapping (address =&gt; uint256)) allowed;&#13;
    event Buy(address indexed _sender, uint256 _eth, uint256 _ARX);&#13;
    event Transfer(address indexed _from, address indexed _to, uint256 _value);&#13;
    event Burn(address _from, uint256 _value);&#13;
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);&#13;
    event Refund(address indexed _refunder, uint256 _value);&#13;
&#13;
    // default function, map admin&#13;
    function ARXCrowdsale() onlyOwner {&#13;
      admin = msg.sender;&#13;
      CurrentStatus = "Crowdsale deployed to chain";&#13;
    }&#13;
&#13;
    // total number of tokens issued so far, normalised&#13;
    function totalSupply() constant returns (uint256 tokenTotalSupply) {&#13;
        tokenTotalSupply = safeDiv(_totalSupply,1 ether);&#13;
    }&#13;
&#13;
    // get the account balance&#13;
    function balanceOf(address _owner) constant returns (uint256 balance) {&#13;
        return balances[_owner];&#13;
    }&#13;
&#13;
    // returns approximate crowdsale max funding in Eth&#13;
    function fundingMaxInEth() constant returns (uint256 fundingMaximumInEth) {&#13;
      fundingMaximumInEth = safeDiv(fundingMaxInWei,1 ether);&#13;
    }&#13;
&#13;
    // returns approximate crowdsale min funding in Eth&#13;
    function fundingMinInEth() constant returns (uint256 fundingMinimumInEth) {&#13;
      fundingMinimumInEth = safeDiv(fundingMinInWei,1 ether);&#13;
    }&#13;
&#13;
    // returns approximate crowdsale progress (funds raised) in Eth&#13;
    function amountRaisedInEth() constant returns (uint256 amountRaisedSoFarInEth) {&#13;
      amountRaisedSoFarInEth = safeDiv(amountRaisedInWei,1 ether);&#13;
    }&#13;
&#13;
    // returns approximate crowdsale remaining cap (hardcap) in Eth&#13;
    function remainingCapInEth() constant returns (uint256 remainingHardCapInEth) {&#13;
      remainingHardCapInEth = safeDiv(remainingCapInWei,1 ether);&#13;
    }&#13;
&#13;
    // ERC20 token transfer function&#13;
    function transfer(address _to, uint256 _amount) returns (bool success) {&#13;
        require(!(_to == 0x0));&#13;
        if ((balances[msg.sender] &gt;= _amount)&#13;
        &amp;&amp; (_amount &gt; 0)&#13;
        &amp;&amp; ((safeAdd(balances[_to],_amount) &gt; balances[_to]))) {&#13;
            balances[msg.sender] = safeSub(balances[msg.sender], _amount);&#13;
            balances[_to] = safeAdd(balances[_to], _amount);&#13;
            Transfer(msg.sender, _to, _amount);&#13;
            return true;&#13;
        } else {&#13;
            return false;&#13;
        }&#13;
    }&#13;
&#13;
    // ERC20 token transferFrom function&#13;
    function transferFrom(&#13;
        address _from,&#13;
        address _to,&#13;
        uint256 _amount) returns (bool success) {&#13;
        require(!(_to == 0x0));&#13;
        if ((balances[_from] &gt;= _amount)&#13;
        &amp;&amp; (allowed[_from][msg.sender] &gt;= _amount)&#13;
        &amp;&amp; (_amount &gt; 0)&#13;
        &amp;&amp; (safeAdd(balances[_to],_amount) &gt; balances[_to])) {&#13;
            balances[_from] = safeSub(balances[_from], _amount);&#13;
            allowed[_from][msg.sender] = safeSub((allowed[_from][msg.sender]),_amount);&#13;
            balances[_to] = safeAdd(balances[_to], _amount);&#13;
            Transfer(_from, _to, _amount);&#13;
            return true;&#13;
        } else {&#13;
            return false;&#13;
        }&#13;
    }&#13;
&#13;
    // ERC20 allow _spender to withdraw, multiple times, up to the _value amount&#13;
    function approve(address _spender, uint256 _amount) returns (bool success) {&#13;
        allowed[msg.sender][_spender] = _amount;&#13;
        Approval(msg.sender, _spender, _amount);&#13;
        return true;&#13;
    }&#13;
&#13;
    // ERC20 return allowance for given owner spender pair&#13;
    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {&#13;
        return allowed[_owner][_spender];&#13;
    }&#13;
&#13;
    // setup the CrowdSale parameters&#13;
    function SetupCrowdsale(uint256 _fundingStartBlock, uint256 _fundingEndBlock) onlyOwner returns (bytes32 response) {&#13;
        if ((msg.sender == admin)&#13;
        &amp;&amp; (!(isCrowdSaleSetup))&#13;
        &amp;&amp; (!(beneficiaryMultiSig &gt; 0))&#13;
        &amp;&amp; (!(fundingMaxInWei &gt; 0))) {&#13;
            // mainnet values&#13;
            beneficiaryMultiSig = 0xd93333f8cb765397A5D0d0e0ba53A2899B48511f;&#13;
            foundationFundMultisig = 0x70A0bE1a5d8A9F39afED536Ec7b55d87067371aA;&#13;
&#13;
            // mainnet funding targets with 18 decimals&#13;
            fundingMaxInWei = 70000000000000000000000; //70 000 000 000 000 000 000 000 = 70,000 Eth (hard cap) - crowdsale no longer accepts Eth after this value&#13;
            fundingMinInWei = 7000000000000000000000;   //7 000 000 000 000 000 000 000 =  7,000 Eth (soft cap) - crowdsale is considered success after this value&#13;
&#13;
            // value of ARX token for mainnet. if hardcap is reached, this results in 280,000,000 ARX tokens in general supply (+28,000,000 in the foundationFundMultisig for a total supply of 308,000,000)&#13;
            tokensPerEthPrice = 4000; // 4,000 tokens per Eth&#13;
&#13;
            // update values&#13;
            fundingMaxInEth = safeDiv(fundingMaxInWei,1 ether); //approximate to 1 Eth due to resolution, provided for ease/viewing only&#13;
            fundingMinInEth = safeDiv(fundingMinInWei,1 ether); //approximate to 1 Eth due to resolution, provided for ease/viewing only&#13;
            remainingCapInWei = fundingMaxInWei;&#13;
            remainingCapInEth = safeDiv(remainingCapInWei,1 ether); //approximate to 1 Eth due to resolution, provided for ease/viewing only&#13;
            fundingStartBlock = _fundingStartBlock;&#13;
            fundingEndBlock = _fundingEndBlock;&#13;
&#13;
            // configure crowdsale&#13;
            isCrowdSaleSetup = true;&#13;
            CurrentStatus = "Crowdsale is setup";&#13;
            return "Crowdsale is setup";&#13;
        } else if (msg.sender != admin) {&#13;
            return "not authorized";&#13;
        } else  {&#13;
            return "campaign cannot be changed";&#13;
        }&#13;
    }&#13;
&#13;
    // default payable function when sending ether to this contract&#13;
    function () payable {&#13;
      require(msg.data.length == 0);&#13;
      BuyTokens();&#13;
    }&#13;
&#13;
    function BuyTokens() payable {&#13;
      // 0. conditions (length, crowdsale setup, zero check, exceed funding contrib check, contract valid check, within funding block range check, balance overflow check etc)&#13;
      require((!(msg.value == 0))&#13;
      &amp;&amp; (!(halted))&#13;
      &amp;&amp; (isCrowdSaleSetup)&#13;
      &amp;&amp; (!((safeAdd(amountRaisedInWei,msg.value)) &gt; fundingMaxInWei))&#13;
      &amp;&amp; (block.number &gt;= fundingStartBlock)&#13;
      &amp;&amp; (block.number &lt;= fundingEndBlock)&#13;
      &amp;&amp; (!(isCrowdSaleFinished)));&#13;
&#13;
      // 1. vars&#13;
      address recipient = msg.sender; // to simplify refunding&#13;
      uint256 amount = msg.value;&#13;
      uint256 rewardTransferAmount = 0;&#13;
&#13;
      // 2. effects&#13;
      amountRaisedInWei = safeAdd(amountRaisedInWei,amount);&#13;
      remainingCapInWei = safeSub(fundingMaxInWei,amountRaisedInWei);&#13;
      rewardTransferAmount = safeMul(amount,tokensPerEthPrice);&#13;
&#13;
      // 3. interaction&#13;
      balances[recipient] = safeAdd(balances[recipient], rewardTransferAmount);&#13;
      _totalSupply = safeAdd(_totalSupply, rewardTransferAmount);&#13;
      Transfer(this, recipient, rewardTransferAmount);&#13;
      Buy(recipient, amount, rewardTransferAmount);&#13;
    }&#13;
&#13;
    function AllocateFounderTokens() onlyOwner {&#13;
      require(isCrowdSaleFinished &amp;&amp; founderTokensAvailable &amp;&amp; (foundationFundTokenCountInWei == 0));&#13;
&#13;
      // calculate additional 10% tokens to allocate for foundation developer distributions&#13;
      foundationFundTokenCountInWei = safeMul((safeDiv(amountRaisedInWei,10)), tokensPerEthPrice);&#13;
&#13;
      // generate and send foundation developer token distributions&#13;
      balances[foundationFundMultisig] = safeAdd(balances[foundationFundMultisig], foundationFundTokenCountInWei);&#13;
&#13;
      _totalSupply = safeAdd(_totalSupply, foundationFundTokenCountInWei);&#13;
      Transfer(this, foundationFundMultisig, foundationFundTokenCountInWei);&#13;
      Buy(foundationFundMultisig, 0, foundationFundTokenCountInWei);&#13;
      founderTokensAvailable = false;&#13;
    }&#13;
&#13;
    function beneficiaryMultiSigWithdraw(uint256 _amount) onlyOwner {&#13;
      require(isCrowdSaleFinished &amp;&amp; (amountRaisedInWei &gt;= fundingMinInWei));&#13;
      beneficiaryMultiSig.transfer(_amount);&#13;
    }&#13;
&#13;
    function checkGoalReached() onlyOwner returns (bytes32 response) { // return crowdfund status to owner for each result case, update public constant&#13;
      require (!(halted) &amp;&amp; isCrowdSaleSetup);&#13;
&#13;
      if ((amountRaisedInWei &lt; fundingMinInWei) &amp;&amp; (block.number &lt;= fundingEndBlock &amp;&amp; block.number &gt;= fundingStartBlock)) { // ICO in progress, under softcap&#13;
        founderTokensAvailable = false;&#13;
        isCrowdSaleFinished = false;&#13;
        CurrentStatus = "In progress (Eth &lt; Softcap)";&#13;
        return "In progress (Eth &lt; Softcap)";&#13;
      } else if ((amountRaisedInWei &lt; fundingMinInWei) &amp;&amp; (block.number &lt; fundingStartBlock)) { // ICO has not started&#13;
        founderTokensAvailable = false;&#13;
        isCrowdSaleFinished = false;&#13;
        CurrentStatus = "Crowdsale is setup";&#13;
        return "Crowdsale is setup";&#13;
      } else if ((amountRaisedInWei &lt; fundingMinInWei) &amp;&amp; (block.number &gt; fundingEndBlock)) { // ICO ended, under softcap&#13;
        founderTokensAvailable = false;&#13;
        isCrowdSaleFinished = true;&#13;
        CurrentStatus = "Unsuccessful (Eth &lt; Softcap)";&#13;
        return "Unsuccessful (Eth &lt; Softcap)";&#13;
      } else if ((amountRaisedInWei &gt;= fundingMinInWei) &amp;&amp; (amountRaisedInWei &gt;= fundingMaxInWei)) { // ICO ended, at hardcap!&#13;
        if (foundationFundTokenCountInWei == 0) {&#13;
          founderTokensAvailable = true;&#13;
          isCrowdSaleFinished = true;&#13;
          CurrentStatus = "Successful (Eth &gt;= Hardcap)!";&#13;
          return "Successful (Eth &gt;= Hardcap)!";&#13;
        } else if (foundationFundTokenCountInWei &gt; 0) {&#13;
          founderTokensAvailable = false;&#13;
          isCrowdSaleFinished = true;&#13;
          CurrentStatus = "Successful (Eth &gt;= Hardcap)!";&#13;
          return "Successful (Eth &gt;= Hardcap)!";&#13;
        }&#13;
      } else if ((amountRaisedInWei &gt;= fundingMinInWei) &amp;&amp; (amountRaisedInWei &lt; fundingMaxInWei) &amp;&amp; (block.number &gt; fundingEndBlock)) { // ICO ended, over softcap!&#13;
        if (foundationFundTokenCountInWei == 0) {&#13;
          founderTokensAvailable = true;&#13;
          isCrowdSaleFinished = true;&#13;
          CurrentStatus = "Successful (Eth &gt;= Softcap)!";&#13;
          return "Successful (Eth &gt;= Softcap)!";&#13;
        } else if (foundationFundTokenCountInWei &gt; 0) {&#13;
          founderTokensAvailable = false;&#13;
          isCrowdSaleFinished = true;&#13;
          CurrentStatus = "Successful (Eth &gt;= Softcap)!";&#13;
          return "Successful (Eth &gt;= Softcap)!";&#13;
        }&#13;
      } else if ((amountRaisedInWei &gt;= fundingMinInWei) &amp;&amp; (amountRaisedInWei &lt; fundingMaxInWei) &amp;&amp; (block.number &lt;= fundingEndBlock)) { // ICO in progress, over softcap!&#13;
        founderTokensAvailable = false;&#13;
        isCrowdSaleFinished = false;&#13;
        CurrentStatus = "In progress (Eth &gt;= Softcap)!";&#13;
        return "In progress (Eth &gt;= Softcap)!";&#13;
      }&#13;
    }&#13;
&#13;
    function refund() { // any contributor can call this to have their Eth returned, if not halted, soft cap not reached and deadline expires&#13;
      require (!(halted)&#13;
      &amp;&amp; (amountRaisedInWei &lt; fundingMinInWei)&#13;
      &amp;&amp; (block.number &gt; fundingEndBlock)&#13;
      &amp;&amp; (balances[msg.sender] &gt; 0));&#13;
&#13;
      uint256 ARXbalance = balances[msg.sender];&#13;
      balances[msg.sender] = 0;&#13;
      _totalSupply = safeSub(_totalSupply, ARXbalance);&#13;
      uint256 ethValue = safeDiv(ARXbalance, tokensPerEthPrice);&#13;
      amountRaisedInWei = safeSub(amountRaisedInWei, ethValue);&#13;
      msg.sender.transfer(ethValue);&#13;
      Burn(msg.sender, ARXbalance);&#13;
      Refund(msg.sender, ethValue);&#13;
    }&#13;
&#13;
    function halt() onlyOwner { // halt the crowdsale&#13;
        halted = true;&#13;
        CurrentStatus = "Halted";&#13;
    }&#13;
&#13;
    function unhalt() onlyOwner { // resume the crowdsale&#13;
        halted = false;&#13;
        CurrentStatus = "Unhalted";&#13;
        checkGoalReached();&#13;
    }&#13;
}