pragma solidity ^0.4.18; // solhint-disable-line


/// @title Interface for contracts conforming to ERC-721: Non-Fungible Tokens
/// @author Dieter Shirley <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="c2a6a7b6a782a3baabadafb8a7aceca1ad">[emailÂ protected]</a>&gt; (https://github.com/dete)&#13;
contract ERC721 {&#13;
  // Required methods&#13;
  function approve(address _to, uint256 _tokenId) public;&#13;
  function balanceOf(address _owner) public view returns (uint256 balance);&#13;
  function implementsERC721() public pure returns (bool);&#13;
  // function ownerOf(uint256 _tokenId) public view returns (address addr);&#13;
  // function takeOwnership(uint256 _tokenId) public;&#13;
  function totalSupply() public view returns (uint256 total);&#13;
  // function transferFrom(address _from, address _to, uint256 _tokenId) public;&#13;
  // function transfer(address _to, uint256 _tokenId) public;&#13;
&#13;
  // event Transfer(address indexed from, address indexed to, uint256 tokenId);&#13;
  // event Approval(address indexed owner, address indexed approved, uint256 tokenId);&#13;
&#13;
  // Optional&#13;
  // function name() public view returns (string name);&#13;
  // function symbol() public view returns (string symbol);&#13;
  // function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256 tokenId);&#13;
  // function tokenMetadata(uint256 _tokenId) public view returns (string infoUrl);&#13;
}&#13;
&#13;
&#13;
contract DailyEtherToken is ERC721 {&#13;
&#13;
  /*** EVENTS ***/&#13;
&#13;
  /// @dev Birth event fired whenever a new token is created&#13;
  event Birth(uint256 tokenId, string name, address owner);&#13;
&#13;
  /// @dev TokenSold event fired whenever a token is sold&#13;
  event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, string name);&#13;
&#13;
  /// @dev Transfer event as defined in ERC721. Ownership is assigned, including births.&#13;
  event Transfer(address from, address to, uint256 tokenId);&#13;
&#13;
  /*** CONSTANTS ***/&#13;
&#13;
  /// @notice Name and symbol of the non fungible token, as defined in ERC721.&#13;
  string public constant NAME = "DailyEther"; // solhint-disable-line&#13;
  string public constant SYMBOL = "DailyEtherToken"; // solhint-disable-line&#13;
&#13;
  uint256 private ticketPrice = 0.2 ether;&#13;
  string private betTitle = "";     // Title of bet&#13;
  uint256 private answerID = 0;     // The correct answer id, set when the bet is closed&#13;
&#13;
  // A bet can have the following states:&#13;
  // Opened -- Accepting new bets&#13;
  // Locked -- Not accepting new bets, waiting for final results&#13;
  // Closed -- Bet completed, results announced and payout completed for winners&#13;
  bool isLocked = false;&#13;
  bool isClosed = false;&#13;
&#13;
  /*** STORAGE ***/&#13;
&#13;
  // Used to implement proper ERC721 implementation&#13;
  mapping (address =&gt; uint256) private addressToBetCount;&#13;
&#13;
  // Holds the number of participants who placed a bet on specific answer&#13;
  mapping (uint256 =&gt; uint256) private answerIdToParticipantsCount;&#13;
&#13;
  // Addresses of the accounts (or contracts) that can execute actions within each roles.&#13;
  address public roleAdminAddress;&#13;
&#13;
  /*** DATATYPES ***/&#13;
  struct Participant {&#13;
    address user_address;&#13;
    uint256 answer_id;&#13;
  }&#13;
  Participant[] private participants;&#13;
&#13;
  /*** ACCESS MODIFIERS ***/&#13;
&#13;
  /// @dev Access modifier for Admin-only&#13;
  modifier onlyAdmin() {&#13;
    require(msg.sender == roleAdminAddress);&#13;
    _;&#13;
  }&#13;
&#13;
  /*** CONSTRUCTOR ***/&#13;
&#13;
  function DailyEtherToken() public {&#13;
    roleAdminAddress = msg.sender;&#13;
  }&#13;
&#13;
  /*** PUBLIC FUNCTIONS ***/&#13;
&#13;
  /// @notice Grant another address the right to transfer token via takeOwnership() and transferFrom().&#13;
  /// @param _to The address to be granted transfer approval. Pass address(0) to&#13;
  ///  clear all approvals.&#13;
  /// @param _tokenId The ID of the Token that can be transferred if this call succeeds.&#13;
  /// @dev Required for ERC-721 compliance.&#13;
  function approve(&#13;
    address _to,&#13;
    uint256 _tokenId&#13;
  ) public {&#13;
    // Caller must own token.&#13;
    require(false);&#13;
  }&#13;
&#13;
  /// For querying balance of a particular account&#13;
  /// @param _owner The address for balance query&#13;
  /// @dev Required for ERC-721 compliance.&#13;
  function balanceOf(address _owner) public view returns (uint256 balance) {&#13;
    return addressToBetCount[_owner];&#13;
  }&#13;
&#13;
  function implementsERC721() public pure returns (bool) {&#13;
    return true;&#13;
  }&#13;
&#13;
  /// @dev Required for ERC-721 compliance.&#13;
  function name() public pure returns (string) {&#13;
    return NAME;&#13;
  }&#13;
&#13;
  function payout(address _to) public onlyAdmin {&#13;
    _payout(_to);&#13;
  }&#13;
&#13;
&#13;
  /// @notice Returns all the relevant information about a specific participant.&#13;
  function getParticipant(uint256 _index) public view returns (&#13;
    address participantAddress,&#13;
    uint256 participantAnswerId&#13;
  ) {&#13;
    Participant storage p = participants[_index];&#13;
    participantAddress = p.user_address;&#13;
    participantAnswerId = p.answer_id;&#13;
  }&#13;
&#13;
&#13;
  // Called to close the bet. Sets the correct bet answer and sends payouts to&#13;
  // the bet winners&#13;
  function closeBet(uint256 _answerId) public onlyAdmin {&#13;
&#13;
    // Make sure bet is Locked&#13;
    require(isLocked == true);&#13;
&#13;
    // Make sure bet was not closed already&#13;
    require(isClosed == false);&#13;
&#13;
    // Store correct answer id&#13;
    answerID = _answerId;&#13;
&#13;
    // Calculate total earnings to send winners&#13;
    uint256 totalPrize = uint256(SafeMath.div(SafeMath.mul((ticketPrice * participants.length), 94), 100));&#13;
&#13;
    // Calculate the prize we need to transfer per winner&#13;
    uint256 paymentPerParticipant = uint256(SafeMath.div(totalPrize, answerIdToParticipantsCount[_answerId]));&#13;
&#13;
    // Mark contract as closed so we won't close it again&#13;
    isClosed = true;&#13;
&#13;
    // Transfer the winning amount to each of the winners&#13;
    for(uint i=0; i&lt;participants.length; i++)&#13;
    {&#13;
        if (participants[i].answer_id == _answerId) {&#13;
            if (participants[i].user_address != address(this)) {&#13;
                participants[i].user_address.transfer(paymentPerParticipant);&#13;
            }&#13;
        }&#13;
    }&#13;
  }&#13;
&#13;
  // Allows someone to send ether and obtain the token&#13;
  function bet(uint256 _answerId) public payable {&#13;
&#13;
    // Make sure bet accepts new bets&#13;
    require(isLocked == false);&#13;
&#13;
    // Answer ID not allowed to be 0, check it is 1 or greater&#13;
    require(_answerId &gt;= 1);&#13;
&#13;
    // Making sure sent amount is greater than or equal to the sellingPrice&#13;
    require(msg.value &gt;= ticketPrice);&#13;
&#13;
    // Store new bet&#13;
    Participant memory _p = Participant({&#13;
      user_address: msg.sender,&#13;
      answer_id: _answerId&#13;
    });&#13;
    participants.push(_p);&#13;
&#13;
    addressToBetCount[msg.sender]++;&#13;
&#13;
    // Increase the count of participants who placed their bet on this answer&#13;
    answerIdToParticipantsCount[_answerId]++;&#13;
  }&#13;
&#13;
  // Returns the ticket price for the bet&#13;
  function getTicketPrice() public view returns (uint256 price) {&#13;
    return ticketPrice;&#13;
  }&#13;
&#13;
  // Returns the bet title&#13;
  function getBetTitle() public view returns (string title) {&#13;
    return betTitle;&#13;
  }&#13;
&#13;
  /// @dev Assigns a new address to act as the Admin&#13;
  /// @param _newAdmin The address of the new Admin&#13;
  function setAdmin(address _newAdmin) public onlyAdmin {&#13;
    require(_newAdmin != address(0));&#13;
    roleAdminAddress = _newAdmin;&#13;
  }&#13;
&#13;
  // Inits the bet data&#13;
  function initBet(uint256 _ticketPriceWei, string _betTitle) public onlyAdmin {&#13;
    ticketPrice = _ticketPriceWei;&#13;
    betTitle = _betTitle;&#13;
  }&#13;
&#13;
  // Called to lock bet, new participants can no longer join&#13;
  function lockBet() public onlyAdmin {&#13;
    isLocked = true;&#13;
  }&#13;
&#13;
  // Called to lock bet, new participants can no longer join&#13;
  function isBetLocked() public view returns (bool) {&#13;
    return isLocked;&#13;
  }&#13;
&#13;
  // Called to lock bet, new participants can no longer join&#13;
  function isBetClosed() public view returns (bool) {&#13;
    return isClosed;&#13;
  }&#13;
&#13;
  /// @dev Required for ERC-721 compliance.&#13;
  function symbol() public pure returns (string) {&#13;
    return SYMBOL;&#13;
  }&#13;
&#13;
  /// Returns the total of bets in contract&#13;
  function totalSupply() public view returns (uint256 total) {&#13;
    return participants.length;&#13;
  }&#13;
&#13;
&#13;
  /*** PRIVATE FUNCTIONS ***/&#13;
&#13;
  /// For paying out balance on contract&#13;
  function _payout(address _to) private {&#13;
    if (_to == address(0)) {&#13;
      roleAdminAddress.transfer(this.balance);&#13;
    } else {&#13;
      _to.transfer(this.balance);&#13;
    }&#13;
  }&#13;
&#13;
}&#13;
&#13;
library SafeMath {&#13;
&#13;
  /**&#13;
  * @dev Multiplies two numbers, throws on overflow.&#13;
  */&#13;
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
    if (a == 0) {&#13;
      return 0;&#13;
    }&#13;
    uint256 c = a * b;&#13;
    assert(c / a == b);&#13;
    return c;&#13;
  }&#13;
&#13;
  /**&#13;
  * @dev Integer division of two numbers, truncating the quotient.&#13;
  */&#13;
  function div(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
    // assert(b &gt; 0); // Solidity automatically throws when dividing by 0&#13;
    uint256 c = a / b;&#13;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold&#13;
    return c;&#13;
  }&#13;
&#13;
  /**&#13;
  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).&#13;
  */&#13;
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
    assert(b &lt;= a);&#13;
    return a - b;&#13;
  }&#13;
&#13;
  /**&#13;
  * @dev Adds two numbers, throws on overflow.&#13;
  */&#13;
  function add(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
    uint256 c = a + b;&#13;
    assert(c &gt;= a);&#13;
    return c;&#13;
  }&#13;
}