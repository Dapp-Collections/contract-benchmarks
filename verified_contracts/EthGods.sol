pragma solidity ^0.4.24;

contract EthGods {

    // imported contracts
    
    EthGodsName private eth_gods_name;
    function set_eth_gods_name_contract_address(address eth_gods_name_contract_address) public returns (bool) {
        require(msg.sender == admin);
        eth_gods_name = EthGodsName(eth_gods_name_contract_address);
        return true;
    }

    EthGodsDice private eth_gods_dice;
    function set_eth_gods_dice_contract_address(address eth_gods_dice_contract_address) public returns (bool) {
        require(msg.sender == admin);
        eth_gods_dice = EthGodsDice(eth_gods_dice_contract_address);
        return true;
    }
    
    // end of imported contracts
 
 
     // start of database
    
    //contract information & administration
    bool private contract_created; // in case constructor logic change in the future
    address private contract_address; //shown at the top of the home page
    string private contact_email = "<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="7b1e0f131c141f083b1c161a121755181416">[emailÂ protected]</a>";&#13;
    string private official_url = "swarm-gateways.net/bzz:/ethgods.eth";&#13;
&#13;
    address private  admin; // public when testing&#13;
    address private controller1 = 0xcA5A9Db0EF9a0Bf5C38Fc86fdE6CB897d9d86adD; // controller can change admin at once; &#13;
    address private controller2 = 0x8396D94046a099113E5fe5CBad7eC95e96c2B796; // controller can change admin at once; &#13;
&#13;
    address private v_god = 0xfB6916095ca1df60bB79Ce92cE3Ea74c37c5d359;&#13;
    uint private block_hash_duration = 255; // can't get block hash, after 256 blocks, adjustable&#13;
    &#13;
&#13;
    // god&#13;
    struct god {&#13;
        uint god_id;&#13;
        uint level;&#13;
        uint exp;&#13;
        uint pet_type;// 12 animals or zodiacs&#13;
        uint pet_level;   &#13;
        uint listed; // 0 not a god, 1 - ... rank_score in god list&#13;
        uint invite_price;&#13;
        uint blessing_player_id;&#13;
        bool hosted_pray; // auto waitlist, when enlisted. others can invite, once hosted pray&#13;
        uint bid_eth; // bid to host pray&#13;
        &#13;
        uint credit; // gained from the amulet invitation spending of invited fellows&#13;
        uint count_amulets_generated;&#13;
        uint first_amulet_generated;&#13;
        uint count_amulets_at_hand;&#13;
        uint count_amulets_selling;&#13;
        uint amulets_start_id;&#13;
        uint amulets_end_id;&#13;
        &#13;
        uint count_token_orders;&#13;
        uint first_active_token_order;&#13;
&#13;
        uint allowed_block; // allow another account to use my egst&#13;
        &#13;
        uint block_number; // for pray&#13;
        bytes32 gene;&#13;
        bool gene_created;&#13;
        bytes32 pray_hash; //hash created for each pray&#13;
&#13;
        uint inviter_id; // who invited this fellow to this world&#13;
        uint count_gods_invited; // gods invited to this game by this god.&#13;
        &#13;
    }&#13;
    uint private count_gods = 0; // Used when generating id for a new player, &#13;
    mapping(address =&gt; god) private gods; // everyone is a god&#13;
    mapping(uint =&gt; address) private gods_address; // gods' address =&gt; god_id&#13;
&#13;
    uint [] private listed_gods; // id of listed gods&#13;
    uint private max_listed_gods = 10000; // adjustable&#13;
&#13;
    uint private initial_invite_price = 0.02 ether; // grows with each invitation for this god&#13;
    uint private invite_price_increase = 0.02 ether; // grows by this amount with each invitation&#13;
    uint private max_invite_price = 1000 ether; // adjustable&#13;
    uint private max_extra_eth = 0.001 ether; // adjustable&#13;
&#13;
    uint private list_level = 10; // start from level 10&#13;
    uint private max_gas_price = 100000000000; // 100 gwei for invite and pray, adjustable&#13;
    &#13;
    // amulet&#13;
    struct amulet {&#13;
        uint god_id;&#13;
        address owner;&#13;
        uint level;&#13;
        uint bound_start_block;// can't sell, if just got&#13;
        // bool selling;&#13;
        uint start_selling_block; // can't bind &amp; use in pk, if selling&#13;
        uint price; // set to 0, when withdraw from selling or bought&#13;
        // uint order_id; // should be 0, if not selling&#13;
    }&#13;
    uint private count_amulets = 0; &#13;
    mapping(uint =&gt; amulet) private amulets; // public when testing&#13;
    uint private bound_duration = 9000; // once bought, wait a while before sell it again, adjustable&#13;
    uint private order_duration = 20000; // valid for about 3 days, then not to show to public in selling amulets/token orders, but still show in my_selling amulets/token orders. adjustable&#13;
&#13;
    // pray&#13;
    address private pray_host_god; // public when testing&#13;
    bool private pray_reward_top100; // if hosted by new god, reward top 100 gods egst&#13;
    uint private pray_start_block; // public when testing&#13;
    bool private rewarded_pray_winners = false;&#13;
&#13;
    uint private count_hosted_gods; // gods hosted pray (event started). If less than bidding gods, there are new gods waiting to host pray, &#13;
    mapping (uint =&gt; address) private bidding_gods; // every listed god and bid to host pray&#13;
    uint private initializer_reward = 36; // reward the god who burned gas to send pray rewards to community, adjustable&#13;
    &#13;
    mapping(uint =&gt; uint) private max_winners;  // max winners for each prize  &#13;
    uint private min_pray_interval = 2000; // 2000, 36 in CBT, 2 in dev, adjustable&#13;
    uint private min_pray_duration = 6000; // 6000, 600 in CBT, 60 in dev, adjustable&#13;
    uint private max_pray_duration = 9000; // 9000, 900 in CBT, 90 in dev, adjustable&#13;
&#13;
    uint private count_waiting_prayers;&#13;
    mapping (uint =&gt; address) private waiting_prayers; // uint is waiting sequence&#13;
    uint private waiting_prayer_index = 1; // waiting sequence of the prayer ready to draw lot&#13;
&#13;
    mapping(uint =&gt; uint) private pk_positions; // public when testing&#13;
    mapping(uint =&gt; uint) private count_listed_winners; // count for 5 prizes, public in testing&#13;
    mapping (uint =&gt; mapping(uint =&gt; address)) private listed_winners; // winners for 5 prizes&#13;
&#13;
    bool private reEntrancyMutex = false; // for sendnig eth to msg.sender&#13;
    &#13;
    uint private pray_egses = 0; // 10% from reward pool to top 3 winners in each round of pray events&#13;
    uint private pray_egst = 0;  // 10% from reward pool to 3rd &amp; 4th prize winners in each round of pray events&#13;
&#13;
    mapping(address =&gt; uint) egses_balances;&#13;
        &#13;
&#13;
    // eth_gods_token (EGST)&#13;
    string public name = "EthGodsToken";&#13;
    string public symbol = "EGST";&#13;
    uint8 public decimals = 18; //same as ethereum&#13;
    uint private _totalSupply;&#13;
    mapping(address =&gt; uint) balances; // bought or gained from pray or revenue share&#13;
    mapping(address =&gt; mapping(address =&gt; uint)) allowed;&#13;
    uint private allowed_use_CD = 20; // if used allowed amount, have to wait a while before approve new allowed amount again, prevent cheating, adjustable&#13;
    &#13;
&#13;
    struct token_order {&#13;
        uint id;&#13;
        uint start_selling_block;&#13;
        address seller;&#13;
        uint unit_price;&#13;
        uint egst_amount;&#13;
    }&#13;
    uint private count_token_orders = 0;&#13;
    mapping (uint =&gt; token_order) token_orders;&#13;
    uint private first_active_token_order = 0;&#13;
&#13;
    uint private min_unit_price = 20; // 1 egst min value is 0.0002 ether, adjustable&#13;
    uint private max_unit_price = 200; // 1 egst max value is 0.002 ether, adjustable&#13;
    uint private max_egst_amount = 1000000 ether; // for create_token_order, adjustable&#13;
    uint private min_egst_amount = 0.00001 ether; // for create_token_order, adjustable&#13;
 &#13;
 &#13;
    //logs&#13;
    uint private count_rounds = 0;&#13;
    &#13;
    struct winner_log { // win a prize and if pk&#13;
        uint god_block_number;&#13;
        bytes32 block_hash; &#13;
        address prayer;&#13;
        address previous_winner;&#13;
        uint prize;&#13;
        bool pk_result;&#13;
    }&#13;
    mapping (uint =&gt; uint) private count_rounds_winner_logs;&#13;
    mapping(uint =&gt; mapping(uint =&gt; winner_log)) private winner_logs;&#13;
    &#13;
    struct change_log {&#13;
        uint block_number;&#13;
        uint asset_type; // 1 egst, 2 eth_surplus&#13;
        &#13;
        // egses change reasons:  &#13;
            // 1 pray_reward, 2 god_reward for being invited, 3 inviter_reward,&#13;
            // 4 admin_deposit to reward_pool, 5 withdraw egses&#13;
            // 6 sell amulet, 7 sell egst, 8 withdraw bid&#13;
        &#13;
        // egst_change reasons: &#13;
            // 1 pray_reward, 2 top_gods_reward, &#13;
            // 3 create_token_order, 4 withdraw token_order, 5 buy token,  &#13;
            // 6 upgrade pet, 7 upgrade amulet, 8 admin_reward&#13;
        &#13;
        uint reason; // &gt; 10 is buy token unit_price&#13;
        uint change_amount;&#13;
        uint after_amount;&#13;
        address _from;&#13;
        address _to;&#13;
    }&#13;
    mapping (uint =&gt; uint) private count_rounds_change_logs;&#13;
    mapping(uint =&gt; mapping(uint =&gt; change_log)) private change_logs;&#13;
&#13;
    // end of database&#13;
  &#13;
    &#13;
    // start of constructor&#13;
    constructor () public {&#13;
        require (contract_created == false);&#13;
        contract_created = true;&#13;
        contract_address = address(this);&#13;
        admin = msg.sender;&#13;
&#13;
        create_god(admin, 0);&#13;
        create_god(v_god, 0);&#13;
        gods[v_god].level = 10;&#13;
        enlist_god(v_god);&#13;
        &#13;
        max_winners[1] = 1; // 1&#13;
        max_winners[2] = 2; // 2&#13;
        max_winners[3] = 8; // 8&#13;
        max_winners[4] = 16; // 16&#13;
        max_winners[5] = 100; // 100&#13;
&#13;
        _totalSupply = 6000000 ether;&#13;
        pray_egst = 1000 ether;&#13;
        balances[admin] = sub(_totalSupply, pray_egst);&#13;
  &#13;
        initialize_pray();&#13;
    }&#13;
    &#13;
    // destruct for testing contracts. can't destruct since round 3&#13;
    function finalize() public {&#13;
        require(msg.sender == admin &amp;&amp; count_rounds &lt;= 3);&#13;
        selfdestruct(admin); &#13;
    }&#13;
    &#13;
&#13;
    function () public payable {&#13;
        revert ();&#13;
    }   &#13;
    // end of constructor&#13;
     &#13;
         &#13;
    //start of contract information &amp; administration&#13;
    &#13;
    function get_controller () public view returns (address, address){&#13;
        require (msg.sender == admin || msg.sender == controller1  || msg.sender == controller2);&#13;
        return (controller1, controller2);&#13;
    }&#13;
    &#13;
    function set_controller (uint controller_index, address new_controller_address) public returns (bool){&#13;
        if (controller_index == 1){&#13;
            require(msg.sender == controller2);&#13;
            controller1 = new_controller_address;&#13;
        } else {&#13;
            require(msg.sender == controller1);&#13;
            controller2 = new_controller_address;            &#13;
        }&#13;
        return true;&#13;
    }&#13;
     &#13;
    function set_admin (address new_admin_address) public returns (bool) {&#13;
        require (msg.sender == controller1 || msg.sender == controller2);&#13;
        // admin don't have game attributes, such as level'&#13;
        // no need to transfer egses and egst to new_admin_address&#13;
        delete gods[admin];&#13;
        admin = new_admin_address;&#13;
        gods_address[0] = admin;&#13;
        gods[admin].god_id = 0;&#13;
        return true;&#13;
    }  &#13;
    &#13;
    // update system parameters&#13;
    function set_parameters (uint parameter_type, uint new_parameter) public returns (bool){&#13;
        require (msg.sender == admin);&#13;
        if (parameter_type == 1) {&#13;
            max_pray_duration = new_parameter;&#13;
        } else if (parameter_type == 2) {&#13;
            min_pray_duration = new_parameter;&#13;
        } else if (parameter_type == 3) {&#13;
            block_hash_duration = new_parameter;&#13;
        } else if (parameter_type == 4) {&#13;
            min_pray_interval = new_parameter;&#13;
        } else if (parameter_type == 5) {&#13;
            order_duration = new_parameter;&#13;
        } else if (parameter_type == 6) {&#13;
            bound_duration = new_parameter;&#13;
        } else if (parameter_type == 7) {&#13;
            initializer_reward = new_parameter;&#13;
        } else if (parameter_type == 8) {&#13;
            allowed_use_CD = new_parameter;&#13;
        } else if (parameter_type == 9) {&#13;
            min_unit_price = new_parameter;&#13;
        } else if (parameter_type == 10) {&#13;
            max_unit_price = new_parameter;&#13;
        } else if (parameter_type == 11) {&#13;
            max_listed_gods = new_parameter;&#13;
        } else if (parameter_type == 12) {&#13;
            max_gas_price = new_parameter;&#13;
        } else if (parameter_type == 13) {&#13;
            max_invite_price = new_parameter;&#13;
        } else if (parameter_type == 14) {&#13;
            min_egst_amount = new_parameter;&#13;
        } else if (parameter_type == 15) {&#13;
            max_egst_amount = new_parameter;&#13;
        } else if (parameter_type == 16) {&#13;
            max_extra_eth = new_parameter;&#13;
        }&#13;
        return true;&#13;
    }  &#13;
        &#13;
    function set_strings (uint string_type, string new_string) public returns (bool){&#13;
        require (msg.sender == admin);&#13;
        &#13;
        if (string_type == 1){&#13;
            official_url = new_string;&#13;
        } else if (string_type == 2){&#13;
            name = new_string; // egst name&#13;
        } else if (string_type == 3){&#13;
            symbol = new_string; // egst symbol&#13;
        }&#13;
        return true;&#13;
    }    &#13;
    &#13;
  &#13;
    // for basic information to show to players, and to update parameter in sub-contracts&#13;
    function query_contract () public view returns(uint, uint, address, uint, string, uint, uint){&#13;
        return (count_gods,&#13;
                listed_gods.length, &#13;
                admin,&#13;
                block_hash_duration,&#13;
                official_url,&#13;
                bound_duration,&#13;
                min_pray_interval&#13;
               );&#13;
    }&#13;
    &#13;
    &#13;
    function query_uints () public view returns (uint[7] uints){&#13;
        uints[0] = max_invite_price;&#13;
        uints[1] = list_level;&#13;
        uints[2] = max_pray_duration;&#13;
        uints[3] = min_pray_duration;&#13;
        uints[4] = initializer_reward;&#13;
        uints[5] = min_unit_price;&#13;
        uints[6] = max_unit_price;&#13;
        &#13;
        return uints;&#13;
    }&#13;
    &#13;
    &#13;
    function query_uints2 () public view returns (uint[6] uints){&#13;
        uints[0] = allowed_use_CD;&#13;
        uints[1] = max_listed_gods;&#13;
        uints[2] = max_gas_price;&#13;
        uints[3] = min_egst_amount;&#13;
        uints[4] = max_egst_amount;&#13;
        uints[5] = max_extra_eth;&#13;
&#13;
        return uints;&#13;
    }&#13;
  &#13;
    //end of contract information &amp; administration&#13;
&#13;
    &#13;
    // god related functions: register, create_god, upgrade_pet, add_exp, burn_gas, invite, enlist&#13;
    &#13;
    // if a new player comes when a round just completed, the new player may not want to initialize the next round&#13;
    function register_god (uint inviter_id) public returns (uint) {&#13;
        return create_god(msg.sender, inviter_id);&#13;
    }&#13;
    function create_god (address god_address, uint inviter_id) private returns(uint god_id){ // created by the contract // public when testing&#13;
        // check if the god is already created&#13;
        if (gods[god_address].credit == 0) { // create admin as god[0]&#13;
            gods[god_address].credit = 1; // give 1 credit, so we know this address has a god&#13;
            &#13;
            god_id = count_gods; // 1st god's id is admin 0&#13;
            count_gods = add(count_gods, 1) ;&#13;
            gods_address[god_id] = god_address;&#13;
            gods[god_address].god_id = god_id;&#13;
                        &#13;
            if (god_id &gt; 0){ // not admin&#13;
                add_exp(god_address, 100);&#13;
                set_inviter(inviter_id);&#13;
            }&#13;
            &#13;
            return god_id;&#13;
        }&#13;
    }&#13;
    &#13;
    function set_inviter (uint inviter_id) public returns (bool){&#13;
        if (inviter_id &gt; 0 &amp;&amp; gods_address[inviter_id] != address(0)&#13;
        &amp;&amp; gods[msg.sender].inviter_id == 0&#13;
        &amp;&amp; gods[gods_address[inviter_id]].inviter_id != gods[msg.sender].god_id){&#13;
            gods[msg.sender].inviter_id = inviter_id;&#13;
            address inviter_address = gods_address[inviter_id];&#13;
            gods[inviter_address].count_gods_invited = add(gods[inviter_address].count_gods_invited, 1);&#13;
            return true;&#13;
        }&#13;
    }&#13;
&#13;
    function add_exp (address god_address, uint exp_up) private returns(uint new_level, uint new_exp) { // public when testing&#13;
        if (god_address == admin){&#13;
            return (0,0);&#13;
        }&#13;
        if (gods[god_address].god_id == 0){&#13;
            uint inviter_id = gods[god_address].inviter_id;&#13;
            create_god(god_address, inviter_id);&#13;
        }&#13;
        new_exp = add(gods[god_address].exp, exp_up);&#13;
        uint current_god_level = gods[god_address].level;&#13;
        uint level_up_exp;&#13;
        new_level = current_god_level;&#13;
&#13;
        for (uint i=0;i&lt;10;i++){ // if still have extra exp, level up next time&#13;
            if (current_god_level &lt; 99){&#13;
                level_up_exp = mul(10, add(new_level, 1));&#13;
            } else {&#13;
                level_up_exp = 1000;&#13;
            }&#13;
            if (new_exp &gt;= level_up_exp){&#13;
                new_exp = sub(new_exp, level_up_exp);&#13;
                new_level = add(new_level, 1);&#13;
            } else {&#13;
                break;&#13;
            }&#13;
        }&#13;
&#13;
        gods[god_address].exp = new_exp;&#13;
&#13;
        if(new_level &gt; current_god_level) {&#13;
            gods[god_address].level = new_level;&#13;
            if (gods[god_address].listed &gt; 0) {&#13;
                if (listed_gods.length &gt; 1) {&#13;
                    sort_gods(gods[god_address].god_id);&#13;
                }&#13;
            } else if (new_level &gt;= list_level &amp;&amp; listed_gods.length &lt; max_listed_gods) {&#13;
                enlist_god(god_address);&#13;
            }&#13;
        }&#13;
        &#13;
        return (new_level, new_exp);&#13;
    }&#13;
&#13;
   &#13;
    function enlist_god (address god_address) private returns (uint) { // public when testing&#13;
        require(gods[god_address].level &gt;= list_level &amp;&amp; god_address != admin);&#13;
                &#13;
        // if the god is not listed yet, enlist and add level requirement for the next enlist&#13;
        if (gods[god_address].listed == 0) {&#13;
            uint god_id = gods[god_address].god_id;&#13;
            if (god_id == 0){&#13;
                god_id = create_god(god_address, 0); // get a god_id and set inviter as v god&#13;
            }&#13;
            gods[god_address].listed = listed_gods.push(god_id); // start from 1, 0 is not listed&#13;
            gods[god_address].invite_price = initial_invite_price;&#13;
&#13;
            list_level = add(list_level, 1);&#13;
            bidding_gods[listed_gods.length] = god_address;&#13;
            &#13;
        }&#13;
        return list_level;&#13;
    }&#13;
    &#13;
    function sort_gods_admin(uint god_id) public returns (bool){&#13;
        require (msg.sender == admin);&#13;
        sort_gods(god_id);&#13;
        return true;&#13;
    }&#13;
&#13;
&#13;
    // when a listed god level up and is not top 1 of the list, compare power with higher god, if higher than the higher god, swap position&#13;
    function sort_gods (uint god_id) private returns (uint){ &#13;
        require (god_id &gt; 0);&#13;
        uint list_length = listed_gods.length;&#13;
        if (list_length &gt; 1) {&#13;
            address god_address = gods_address[god_id];&#13;
            uint this_god_listed = gods[god_address].listed;&#13;
            if (this_god_listed &lt; list_length) {&#13;
                uint higher_god_listed = add(this_god_listed, 1);&#13;
                uint higher_god_id = listed_gods[sub(higher_god_listed, 1)];&#13;
                address higher_god = gods_address[higher_god_id];&#13;
                if(gods[god_address].level &gt; gods[higher_god].level&#13;
                || (gods[god_address].level == gods[higher_god].level&#13;
                    &amp;&amp; gods[god_address].exp &gt; gods[higher_god].exp)){&#13;
                        listed_gods[sub(this_god_listed, 1)] = higher_god_id;&#13;
                        listed_gods[sub(higher_god_listed, 1)] = god_id;&#13;
                        gods[higher_god].listed = this_god_listed;&#13;
                        gods[god_address].listed = higher_god_listed;&#13;
                }&#13;
            }&#13;
        }&#13;
        return gods[god_address].listed;&#13;
    }&#13;
&#13;
&#13;
    function burn_gas (uint god_id) public returns (uint god_new_level, uint god_new_exp) {&#13;
        address god_address = gods_address[god_id];&#13;
        require(god_id &gt; 0 &#13;
                &amp;&amp; god_id &lt;= count_gods&#13;
                &amp;&amp; gods[god_address].listed &gt; 0);&#13;
&#13;
        add_exp(god_address, 1);&#13;
        add_exp(msg.sender, 1);&#13;
        return (gods[god_address].level, gods[god_address].exp); // return bool, if out of gas&#13;
    }&#13;
&#13;
&#13;
    function invite (uint god_id) public payable returns (uint new_invite_price)  {&#13;
        address god_address = gods_address[god_id];&#13;
        require(god_id &gt; 0 &#13;
                &amp;&amp; god_id &lt;= count_gods&#13;
                &amp;&amp; gods[god_address].hosted_pray == true&#13;
                &amp;&amp; tx.gasprice &lt;= max_gas_price&#13;
                );&#13;
&#13;
        uint invite_price = gods[god_address].invite_price;&#13;
&#13;
        require(msg.value &gt;= invite_price); &#13;
&#13;
        if (gods[god_address].invite_price &lt; max_invite_price) {&#13;
            gods[god_address].invite_price = add(invite_price, invite_price_increase);&#13;
        }&#13;
        &#13;
        uint exp_up = div(invite_price, (10 ** 15)); // 1000 exp for each eth&#13;
        add_exp(god_address, exp_up);&#13;
        add_exp(msg.sender, exp_up);&#13;
       &#13;
        //generate a new amulet of this god for the inviter&#13;
        count_amulets ++;&#13;
        amulets[count_amulets].god_id = god_id;&#13;
        amulets[count_amulets].owner = msg.sender;&#13;
&#13;
        gods[god_address].count_amulets_generated = add(gods[god_address].count_amulets_generated, 1);&#13;
        if (gods[god_address].count_amulets_generated == 1){&#13;
            gods[god_address].first_amulet_generated = count_amulets;&#13;
        }&#13;
        gods[msg.sender].count_amulets_at_hand = add(gods[msg.sender].count_amulets_at_hand, 1);&#13;
        update_amulets_count(msg.sender, count_amulets, true);&#13;
&#13;
        // invite_price to egses: 60% to pray_egses, 20% to god, changed&#13;
        // pray_egses = add(pray_egses, div(mul(60, invite_price), 100));&#13;
        // egses_from_contract(gods_address[god_id], div(mul(20, invite_price), 100), 2); //2 reward god for being invited&#13;
        // reduce reward pool share from 60 to 50%, reduce god reward from 20% to 10%&#13;
        // add 20% share to blessing player (the last player invited this god)&#13;
        pray_egses = add(pray_egses, div(mul(50, invite_price), 100)); &#13;
        egses_from_contract(god_address, div(mul(10, invite_price), 100), 2); //2 reward god for being invited&#13;
        egses_from_contract(gods_address[gods[god_address].blessing_player_id], div(mul(20, invite_price), 100), 2); //2 reward god for being invited, no need to check if blessing player id is &gt; 0&#13;
        gods[god_address].blessing_player_id = gods[msg.sender].god_id;&#13;
&#13;
        reward_inviter(msg.sender, invite_price);&#13;
        emit invited_god (msg.sender, god_id);&#13;
&#13;
        return gods[god_address].invite_price;&#13;
    }&#13;
    event invited_god (address msg_sender, uint god_id);&#13;
    &#13;
&#13;
    function reward_inviter (address inviter_address, uint invite_price) private returns (bool){&#13;
        // the fellow spending eth also get credit and share&#13;
        uint previous_share = 0;&#13;
        uint inviter_share = 0;&#13;
        uint share_diff;&#13;
        // uint invite_credit = div(invite_price, 10 ** 15);&#13;
        &#13;
        for (uint i = 0; i &lt; 9; i++){ // max trace 9 layers of inviter&#13;
            if (inviter_address != address(0) &amp;&amp; inviter_address != admin){ // admin doesn't get reward or credit&#13;
                share_diff = 0;&#13;
                // gods[inviter_address].credit = add(gods[inviter_address].credit, invite_credit);&#13;
                gods[inviter_address].credit = add(gods[inviter_address].credit, invite_price);&#13;
                inviter_share = get_vip_level(inviter_address);&#13;
&#13;
                if (inviter_share &gt; previous_share) {&#13;
                    share_diff = sub(inviter_share, previous_share);&#13;
                    if (share_diff &gt; 18) {&#13;
                        share_diff = 18;&#13;
                    }&#13;
                    previous_share = inviter_share;&#13;
                }&#13;
                &#13;
                if (share_diff &gt; 0) {&#13;
                    egses_from_contract(inviter_address, div(mul(share_diff, invite_price), 100), 3); // 3 inviter_reward&#13;
                }&#13;
                &#13;
                inviter_address = gods_address[gods[inviter_address].inviter_id]; // get the address of inviter's inviter'&#13;
            } else{&#13;
                break;&#13;
            }&#13;
        }&#13;
        // invite_price to egses: sub(20%, previous_share) to admin&#13;
        share_diff = sub(20, inviter_share); &#13;
        egses_from_contract(admin, div(mul(share_diff, invite_price), 100), 2); // remaining goes to admin, 2 god_reward for being invited&#13;
        &#13;
        return true;&#13;
    }&#13;
    &#13;
&#13;
    function upgrade_pet () public returns(bool){&#13;
        //use egst to level up pet;&#13;
        uint egst_cost = mul(add(gods[msg.sender].pet_level, 1), 10 ether);&#13;
        egst_to_contract(msg.sender, egst_cost, 6);// 6 upgrade_pet&#13;
        gods[msg.sender].pet_level = add(gods[msg.sender].pet_level, 1);&#13;
        add_exp(msg.sender, div(egst_cost, 1 ether));&#13;
        pray_egst = add(pray_egst, egst_cost);&#13;
&#13;
        // pray_egst = add(pray_egst, div(egst_cost, 2));&#13;
        // egst_from_contract(admin, div(egst_cost, 2), 8); // 8 admin reward&#13;
        emit upgradeAmulet(msg.sender, 0, gods[msg.sender].pet_level);&#13;
        &#13;
        return true;&#13;
    }&#13;
    event upgradeAmulet (address owner, uint amulet_id, uint new_level);&#13;
&#13;
    function set_pet_type (uint new_type) public returns (bool){&#13;
        if (gods[msg.sender].pet_type != new_type) {&#13;
            gods[msg.sender].pet_type = new_type;&#13;
            return true;&#13;
        }&#13;
    }&#13;
  &#13;
      &#13;
    function get_vip_level (address god_address) public view returns (uint vip_level){&#13;
        uint inviter_credit = gods[god_address].credit;&#13;
        &#13;
        if (inviter_credit &gt; 500 ether){&#13;
            vip_level = 18;&#13;
        } else if (inviter_credit &gt; 200 ether){&#13;
            vip_level = 15;&#13;
        } else if (inviter_credit &gt; 100 ether){&#13;
            vip_level = 12;&#13;
        } else if (inviter_credit &gt; 50 ether){&#13;
            vip_level = 10;&#13;
        } else if (inviter_credit &gt; 20 ether){&#13;
            vip_level = 8;&#13;
        } else if (inviter_credit &gt; 10 ether){&#13;
            vip_level = 6;&#13;
        } else if (inviter_credit &gt; 5 ether){&#13;
            vip_level = 5;&#13;
        } else if (inviter_credit &gt; 2 ether){&#13;
            vip_level = 4;&#13;
        } else if (inviter_credit &gt; 1 ether){&#13;
            vip_level = 3;&#13;
        } else if (inviter_credit &gt; 0.5 ether){&#13;
            vip_level = 2;&#13;
        } else {&#13;
            vip_level = 1;&#13;
        }&#13;
        return vip_level;&#13;
    }&#13;
&#13;
&#13;
    // view god's information&#13;
    &#13;
    function get_god_id (address god_address) public view returns (uint god_id){&#13;
        return gods[god_address].god_id;&#13;
    }&#13;
    &#13;
    &#13;
    function get_god_address(uint god_id) public view returns (address){&#13;
        return gods_address[god_id];&#13;
    }&#13;
&#13;
&#13;
    function get_god (uint god_id) public view returns(uint, string, uint, uint, uint, uint, uint) {&#13;
        address god_address = gods_address[god_id];&#13;
        string memory god_name;&#13;
&#13;
        god_name = eth_gods_name.get_god_name(god_address);&#13;
        if (bytes(god_name).length == 0){&#13;
            god_name = "Unknown";&#13;
        }&#13;
&#13;
        return (gods[god_address].god_id,&#13;
                god_name,&#13;
                gods[god_address].level,&#13;
                gods[god_address].exp,&#13;
                gods[god_address].invite_price,&#13;
                gods[god_address].listed,&#13;
                gods[god_address].blessing_player_id&#13;
                );&#13;
    }&#13;
    &#13;
    &#13;
    function get_god_info (address god_address) public view returns (uint, bytes32, bool, uint, uint, uint, bytes32){&#13;
        return (gods[god_address].block_number,&#13;
                gods[god_address].gene,&#13;
                gods[god_address].gene_created,&#13;
                gods[god_address].pet_type,&#13;
                gods[god_address].pet_level,&#13;
                gods[god_address].bid_eth,&#13;
                gods[god_address].pray_hash&#13;
                );&#13;
    }&#13;
    &#13;
    &#13;
    function get_god_hosted_pray (uint god_id) public view returns (bool){&#13;
        return gods[gods_address[god_id]].hosted_pray;&#13;
    }&#13;
    &#13;
    &#13;
    function get_my_info () public view returns(uint, uint, uint, uint, uint, uint, uint) { //private information&#13;
&#13;
        return (gods[msg.sender].god_id,&#13;
                egses_balances[msg.sender], //egses&#13;
                balances[msg.sender], //egst&#13;
                get_vip_level(msg.sender),&#13;
                gods[msg.sender].credit, // inviter_credit&#13;
                gods[msg.sender].inviter_id,&#13;
                gods[msg.sender].count_gods_invited&#13;
                );&#13;
    }   &#13;
&#13;
    &#13;
    function get_listed_gods (uint page_number) public view returns (uint[]){&#13;
        &#13;
        uint count_listed_gods = listed_gods.length;&#13;
        require(count_listed_gods &lt;= mul(page_number, 20));&#13;
        &#13;
        uint[] memory tempArray = new uint[] (20);&#13;
&#13;
        if (page_number &lt; 1) {&#13;
            page_number = 1;&#13;
        } &#13;
&#13;
        for (uint i = 0; i &lt; 20; i++){&#13;
            if(count_listed_gods &gt; add(i, mul(20, sub(page_number, 1)))) {&#13;
                tempArray[i] = listed_gods[sub(sub(sub(count_listed_gods, i), 1), mul(20, sub(page_number, 1)))];&#13;
            } else {&#13;
                break;&#13;
            }&#13;
        }&#13;
        &#13;
        return tempArray;&#13;
    }&#13;
&#13;
&#13;
    // amulets&#13;
   &#13;
    function upgrade_amulet (uint amulet_id) public returns(uint){&#13;
        require(amulets[amulet_id].owner == msg.sender);&#13;
        uint egst_cost = mul(add(amulets[amulet_id].level, 1), 10 ether);&#13;
        egst_to_contract(msg.sender, egst_cost, 7);// reason 7, upgrade_amulet&#13;
        pray_egst = add(pray_egst, egst_cost);&#13;
        // pray_egst = add(pray_egst, div(egst_cost, 2));&#13;
        // egst_from_contract(admin, div(egst_cost, 2), 8); // 8 admin reward&#13;
        &#13;
        amulets[amulet_id].level = add(amulets[amulet_id].level, 1);&#13;
        add_exp(msg.sender, div(egst_cost, 1 ether));&#13;
        emit upgradeAmulet(msg.sender, amulet_id, amulets[amulet_id].level);&#13;
        &#13;
        return amulets[amulet_id].level;&#13;
    }&#13;
    &#13;
    &#13;
    function create_amulet_order (uint amulet_id, uint price) public returns (uint) {&#13;
        require(msg.sender == amulets[amulet_id].owner&#13;
                &amp;&amp; amulet_id &gt;= 1 &amp;&amp; amulet_id &lt;= count_amulets&#13;
                &amp;&amp; amulets[amulet_id].start_selling_block == 0&#13;
                &amp;&amp; add(amulets[amulet_id].bound_start_block, bound_duration) &lt; block.number&#13;
                &amp;&amp; price &gt; 0);&#13;
&#13;
        amulets[amulet_id].start_selling_block = block.number;&#13;
        amulets[amulet_id].price = price;&#13;
        gods[msg.sender].count_amulets_at_hand = sub(gods[msg.sender].count_amulets_at_hand, 1);&#13;
        gods[msg.sender].count_amulets_selling = add(gods[msg.sender].count_amulets_selling, 1);&#13;
        &#13;
        return gods[msg.sender].count_amulets_selling;&#13;
&#13;
    }&#13;
&#13;
    function buy_amulet (uint amulet_id) public payable returns (bool) {&#13;
        uint price = amulets[amulet_id].price;&#13;
        require(msg.value &gt;= price &amp;&amp; msg.value &lt; add(price, max_extra_eth)&#13;
        &amp;&amp; amulets[amulet_id].start_selling_block &gt; 0&#13;
        &amp;&amp; amulets[amulet_id].owner != msg.sender&#13;
        &amp;&amp; price &gt; 0);&#13;
        &#13;
        address seller = amulets[amulet_id].owner;&#13;
        amulets[amulet_id].owner = msg.sender;&#13;
        amulets[amulet_id].bound_start_block = block.number;&#13;
        amulets[amulet_id].start_selling_block = 0;&#13;
&#13;
        gods[msg.sender].count_amulets_at_hand++;&#13;
        update_amulets_count(msg.sender, amulet_id, true);&#13;
        gods[seller].count_amulets_selling--;&#13;
        update_amulets_count(seller, amulet_id, false);&#13;
&#13;
        egses_from_contract(seller, price, 6); // 6 sell amulet&#13;
&#13;
        return true;&#13;
    }&#13;
&#13;
    function withdraw_amulet_order (uint amulet_id) public returns (uint){&#13;
        // an amulet can only have one order_id, so withdraw amulet_id instead of withdraw order_id, since only amulet_id is shown in amulets_at_hand&#13;
        require(msg.sender == amulets[amulet_id].owner&#13;
                &amp;&amp; amulet_id &gt;= 1 &amp;&amp; amulet_id &lt;= count_amulets&#13;
                &amp;&amp; amulets[amulet_id].start_selling_block &gt; 0);&#13;
                &#13;
        amulets[amulet_id].start_selling_block = 0;&#13;
        gods[msg.sender].count_amulets_at_hand++;&#13;
        gods[msg.sender].count_amulets_selling--;&#13;
&#13;
        return gods[msg.sender].count_amulets_selling;&#13;
    }&#13;
    &#13;
    function update_amulets_count (address god_address, uint amulet_id, bool obtained) private returns (uint){&#13;
        if (obtained == true){&#13;
            if (amulet_id &lt; gods[god_address].amulets_start_id) {&#13;
                gods[god_address].amulets_start_id = amulet_id;&#13;
            }&#13;
        } else {&#13;
            if (amulet_id == gods[god_address].amulets_start_id){&#13;
                for (uint i = amulet_id; i &lt;= count_amulets; i++){&#13;
                    if (amulets[i].owner == god_address &amp;&amp; i &gt; amulet_id){&#13;
                        gods[god_address].amulets_start_id = i;&#13;
                        break;&#13;
                    }&#13;
                }&#13;
            }&#13;
        }&#13;
        return gods[god_address].amulets_start_id;&#13;
    }&#13;
    &#13;
&#13;
    function get_amulets_generated (uint god_id) public view returns (uint[]) {&#13;
        address god_address = gods_address[god_id];&#13;
        uint count_amulets_generated = gods[god_address].count_amulets_generated;&#13;
        &#13;
        uint [] memory temp_list = new uint[](count_amulets_generated);&#13;
        uint count_elements = 0;&#13;
        for (uint i = gods[god_address].first_amulet_generated; i &lt;= count_amulets; i++){&#13;
            if (amulets[i].god_id == god_id){&#13;
                temp_list [count_elements] = i;&#13;
                count_elements++;&#13;
                &#13;
                if (count_elements &gt;= count_amulets_generated){&#13;
                    break;&#13;
                }&#13;
            }&#13;
        }&#13;
        return temp_list;&#13;
    }&#13;
&#13;
    &#13;
    function get_amulets_at_hand (address god_address) public view returns (uint[]) {&#13;
        uint count_amulets_at_hand = gods[god_address].count_amulets_at_hand;&#13;
        uint [] memory temp_list = new uint[] (count_amulets_at_hand);&#13;
        uint count_elements = 0;&#13;
        for (uint i = gods[god_address].amulets_start_id; i &lt;= count_amulets; i++){&#13;
            if (amulets[i].owner == god_address &amp;&amp; amulets[i].start_selling_block == 0){&#13;
                temp_list[count_elements] = i;&#13;
                count_elements++;&#13;
                &#13;
                if (count_elements &gt;= count_amulets_at_hand){&#13;
                    break;&#13;
                }&#13;
            }&#13;
        }&#13;
&#13;
        return temp_list;&#13;
    }&#13;
    &#13;
    &#13;
    function get_my_amulets_selling () public view returns (uint[]){&#13;
&#13;
        uint count_amulets_selling = gods[msg.sender].count_amulets_selling;&#13;
        uint [] memory temp_list = new uint[] (count_amulets_selling);&#13;
        uint count_elements = 0;&#13;
        for (uint i = gods[msg.sender].amulets_start_id; i &lt;= count_amulets; i++){&#13;
            if (amulets[i].owner == msg.sender &#13;
            &amp;&amp; amulets[i].start_selling_block &gt; 0){&#13;
                temp_list[count_elements] = i;&#13;
                count_elements++;&#13;
                &#13;
                if (count_elements &gt;= count_amulets_selling){&#13;
                    break;&#13;
                }&#13;
            }&#13;
        }&#13;
&#13;
        return temp_list;&#13;
    }&#13;
&#13;
    // to calculate how many pages&#13;
    function get_amulet_orders_overview () public view returns(uint){&#13;
        uint count_amulets_selling = 0;&#13;
        for (uint i = 1; i &lt;= count_amulets; i++){&#13;
            if (add(amulets[i].start_selling_block, order_duration) &gt; block.number &amp;&amp; amulets[i].owner != msg.sender){&#13;
                count_amulets_selling ++;&#13;
            }&#13;
        }        &#13;
        &#13;
        return count_amulets_selling; // to show page numbers when getting amulet_orders&#13;
    }&#13;
&#13;
    function get_amulet_orders (uint page_number) public view returns (uint[]){&#13;
        uint[] memory temp_list = new uint[] (20);&#13;
        uint count_amulets_selling = 0;&#13;
        uint count_list_elements = 0;&#13;
&#13;
        if ((page_number &lt; 1)&#13;
            || count_amulets  &lt;= 20) {&#13;
            page_number = 1; // chose a page out of range&#13;
        }&#13;
        uint start_amulets_count = mul(sub(page_number, 1), 20);&#13;
&#13;
        for (uint i = 1; i &lt;= count_amulets; i++){&#13;
            if (add(amulets[i].start_selling_block, order_duration) &gt; block.number &amp;&amp; amulets[i].owner != msg.sender){&#13;
                &#13;
                if (count_amulets_selling &lt;= start_amulets_count) {&#13;
                    count_amulets_selling ++;&#13;
                }&#13;
                if (count_amulets_selling &gt; start_amulets_count){&#13;
                    &#13;
                    temp_list[count_list_elements] = i;&#13;
                    count_list_elements ++;&#13;
                    &#13;
                    if (count_list_elements &gt;= 20){&#13;
                        break;&#13;
                    }&#13;
                }&#13;
                &#13;
            }&#13;
        }&#13;
        &#13;
        return temp_list;&#13;
    }&#13;
    &#13;
    &#13;
    function get_amulet (uint amulet_id) public view returns(address, string, uint, uint, uint, uint, uint){&#13;
        uint god_id = amulets[amulet_id].god_id;&#13;
        // address god_address = gods_address[god_id];&#13;
        string memory god_name = eth_gods_name.get_god_name(gods_address[god_id]);&#13;
        uint god_level = gods[gods_address[god_id]].level;&#13;
        uint amulet_level = amulets[amulet_id].level;&#13;
        uint start_selling_block = amulets[amulet_id].start_selling_block;&#13;
        uint price = amulets[amulet_id].price;&#13;
&#13;
        return(amulets[amulet_id].owner,&#13;
                god_name,&#13;
                god_id,&#13;
                god_level,&#13;
                amulet_level,&#13;
                start_selling_block,&#13;
                price&#13;
              );&#13;
    }&#13;
&#13;
    function get_amulet2 (uint amulet_id) public view returns(uint){&#13;
        return amulets[amulet_id].bound_start_block;&#13;
    }&#13;
&#13;
    // end of amulet&#13;
    &#13;
    // start of pray&#13;
    function admin_deposit (uint egst_amount) public payable returns (bool) {&#13;
        require (msg.sender == admin);&#13;
        if (msg.value &gt; 0){&#13;
            pray_egses = add(pray_egses, msg.value);&#13;
            egses_from_contract(admin, msg.value, 4); // 4 admin_deposit to reward_pool&#13;
        }&#13;
        if (egst_amount &gt; 0){&#13;
            pray_egst = add(pray_egst, egst_amount);&#13;
            egst_to_contract(admin, egst_amount, 4); // 4 admin_deposit to reward_pool            &#13;
        }&#13;
        return true;&#13;
    }&#13;
        &#13;
    function initialize_pray () private returns (bool){&#13;
        if (pray_start_block &gt; 0) {&#13;
            require (check_event_completed() == true&#13;
            &amp;&amp; rewarded_pray_winners == true);&#13;
        }&#13;
        &#13;
        count_rounds = add(count_rounds, 1);&#13;
        count_rounds_winner_logs[count_rounds] = 0;&#13;
        pray_start_block = block.number;&#13;
        rewarded_pray_winners = false;&#13;
&#13;
        for (uint i = 1; i &lt;= 5; i++){&#13;
            pk_positions[i] = max_winners[i]; // pk start from the last slot&#13;
			count_listed_winners[i] = 0;&#13;
        }&#13;
        if (listed_gods.length &gt; count_hosted_gods) {&#13;
            // a new god's turn&#13;
            count_hosted_gods = add(count_hosted_gods, 1);&#13;
            pray_host_god = bidding_gods[count_hosted_gods];&#13;
            gods[pray_host_god].hosted_pray = true;&#13;
            pray_reward_top100 = true;&#13;
        } else {&#13;
            //choose highest bidder&#13;
            (uint highest_bid, address highest_bidder) = compare_bid_eth();&#13;
&#13;
            gods[highest_bidder].bid_eth = 0;&#13;
            pray_host_god = highest_bidder;&#13;
            pray_egses = add(pray_egses, highest_bid);&#13;
            pray_reward_top100 = false;&#13;
&#13;
        }&#13;
        return true;&#13;
&#13;
    }&#13;
&#13;
&#13;
    function bid_host () public payable returns (bool) {&#13;
        require (msg.value &gt; 0 &amp;&amp; gods[msg.sender].listed &gt; 0);&#13;
        gods[msg.sender].bid_eth = add (gods[msg.sender].bid_eth, msg.value);&#13;
&#13;
        return true;&#13;
    }&#13;
    &#13;
&#13;
    function withdraw_bid () public returns (bool) {&#13;
        require(gods[msg.sender].bid_eth &gt; 0);&#13;
        gods[msg.sender].bid_eth = 0;&#13;
        egses_from_contract(msg.sender, gods[msg.sender].bid_eth, 8); // 8  withdraw bid&#13;
        return true;&#13;
    }&#13;
    &#13;
    &#13;
    // if browser web3 didn't get god's credit, use pray_create in the pray button to create god_id first&#13;
    function pray_create (uint inviter_id) public returns (bool) {&#13;
        // when create a new god, set credit as 1, so credit &lt;= 0 means god_id not created yet&#13;
        create_god(msg.sender, inviter_id);&#13;
        pray();&#13;
    }&#13;
    &#13;
    // if browser web3 got god's credit, use pray in the pray button&#13;
    function pray () public returns (bool){&#13;
        require (add(gods[msg.sender].block_number, min_pray_interval) &lt; block.number&#13;
        &amp;&amp; tx.gasprice &lt;= max_gas_price&#13;
        &amp;&amp; check_event_completed() == false);&#13;
&#13;
        if (waiting_prayer_index &lt;= count_waiting_prayers) {&#13;
&#13;
            address waiting_prayer = waiting_prayers[waiting_prayer_index];&#13;
            uint god_block_number = gods[waiting_prayer].block_number;&#13;
            bytes32 block_hash;&#13;
            &#13;
            if ((add(god_block_number, 1)) &lt; block.number) {// can only get previous block hash&#13;
&#13;
                if (add(god_block_number, block_hash_duration) &lt; block.number) {// make sure this god has a valid block_number to generate block hash&#13;
                    gods[waiting_prayer].block_number = block.number; // refresh this god's expired block_id&#13;
                    // delete waiting_prayers[waiting_prayer_index];&#13;
                    count_waiting_prayers = add(count_waiting_prayers, 1);&#13;
                    waiting_prayers[count_waiting_prayers] = waiting_prayer;&#13;
                } else {// draw lottery and/or create gene for the waiting prayer&#13;
                    block_hash = keccak256(abi.encodePacked(blockhash(add(god_block_number, 1))));&#13;
                    if(gods[waiting_prayer].gene_created == false){&#13;
                        gods[waiting_prayer].gene = block_hash;&#13;
                        gods[waiting_prayer].gene_created = true;&#13;
                    }&#13;
                    gods[waiting_prayer].pray_hash = block_hash;&#13;
    &#13;
                    uint dice_result = eth_gods_dice.throw_dice (block_hash)[0];&#13;
&#13;
                    if (dice_result &gt;= 1 &amp;&amp; dice_result &lt;= 5){&#13;
                        set_winner(dice_result, waiting_prayer, block_hash, god_block_number);&#13;
                    }&#13;
                }&#13;
                waiting_prayer_index = add(waiting_prayer_index, 1);&#13;
            }&#13;
        }&#13;
        &#13;
        count_waiting_prayers = add(count_waiting_prayers, 1);&#13;
        waiting_prayers[count_waiting_prayers] = msg.sender;&#13;
&#13;
        gods[msg.sender].block_number = block.number;&#13;
        add_exp(msg.sender, 1);&#13;
        add_exp(pray_host_god, 1);&#13;
&#13;
        return true;&#13;
    }&#13;
&#13;
&#13;
    function set_winner (uint prize, address waiting_prayer, bytes32 block_hash, uint god_block_number) private returns (uint){&#13;
&#13;
        count_rounds_winner_logs[count_rounds] = add(count_rounds_winner_logs[count_rounds], 1);&#13;
        winner_logs[count_rounds][count_rounds_winner_logs[count_rounds]].god_block_number = god_block_number;&#13;
        winner_logs[count_rounds][count_rounds_winner_logs[count_rounds]].block_hash = block_hash;&#13;
        winner_logs[count_rounds][count_rounds_winner_logs[count_rounds]].prayer = waiting_prayer;&#13;
        winner_logs[count_rounds][count_rounds_winner_logs[count_rounds]].prize = prize;&#13;
&#13;
        if (count_listed_winners[prize] &gt;= max_winners[prize]){ // winner_list maxed, so the new prayer challenge previous winners&#13;
           	uint pk_position = pk_positions[prize];&#13;
        	address previous_winner = listed_winners[prize][pk_position];  &#13;
&#13;
            bool pk_result = pk(waiting_prayer, previous_winner, block_hash);&#13;
&#13;
			winner_logs[count_rounds][count_rounds_winner_logs[count_rounds]].pk_result = pk_result;&#13;
			winner_logs[count_rounds][count_rounds_winner_logs[count_rounds]].previous_winner = previous_winner;&#13;
            &#13;
            if (pk_result == true) {&#13;
                listed_winners[prize][pk_position] = waiting_prayer; // attacker defeat defender&#13;
            }&#13;
            if (prize &gt; 1) { // no need to change pk_pos for champion&#13;
                if (pk_positions[prize] &gt; 1){&#13;
                    pk_positions[prize] = sub(pk_positions[prize], 1);&#13;
                } else {&#13;
                    pk_positions[prize] = max_winners[prize];&#13;
                }               &#13;
            }&#13;
        } else {&#13;
            count_listed_winners[prize] = add(count_listed_winners[prize], 1);&#13;
            listed_winners[prize][count_listed_winners[prize]] = waiting_prayer;&#13;
        }&#13;
     &#13;
        return count_listed_winners[prize];&#13;
    }&#13;
&#13;
    function reward_pray_winners () public returns (bool){&#13;
        require (check_event_completed() == true);&#13;
&#13;
        uint this_reward_egses;&#13;
        uint reward_pool_egses = div(pray_egses, 10);&#13;
        pray_egses = sub(pray_egses, reward_pool_egses);&#13;
        uint this_reward_egst;&#13;
        uint reward_pool_egst = div(pray_egst, 10);&#13;
        pray_egst = sub(pray_egst, reward_pool_egst); // reduce sum for less calculation&#13;
        &#13;
        egst_from_contract(pray_host_god, mul(div(reward_pool_egst, 100), 60), 1); // 1 pray_reward for hosting event&#13;
        &#13;
        for (uint i = 1; i&lt;=5; i++){&#13;
            this_reward_egses = 0;&#13;
            this_reward_egst = 0;&#13;
            if (i == 1) {&#13;
                this_reward_egses = mul(div(reward_pool_egses, 100), 60);&#13;
            } else if (i == 2){&#13;
                this_reward_egses = mul(div(reward_pool_egses, 100), 20);&#13;
            } else if (i == 3){&#13;
                this_reward_egst = mul(div(reward_pool_egst, 100), 3);&#13;
            } else if (i == 4){&#13;
                this_reward_egst = div(reward_pool_egst, 100);&#13;
            } &#13;
            &#13;
            for (uint reward_i = 1; reward_i &lt;= count_listed_winners[i]; reward_i++){&#13;
                address rewarding_winner = listed_winners[i][reward_i];&#13;
&#13;
                if (this_reward_egses &gt; 0 ) {&#13;
                    egses_from_contract(rewarding_winner, this_reward_egses, 1); // 1 pray_reward&#13;
                } else if (this_reward_egst &gt; 0) {&#13;
                    egst_from_contract(rewarding_winner, this_reward_egst, 1); // 1 pray_reward&#13;
                }  &#13;
                &#13;
                add_exp(rewarding_winner, 6);&#13;
            }&#13;
        }&#13;
            &#13;
        &#13;
        if(pray_reward_top100 == true) {&#13;
            reward_top_gods();&#13;
        }&#13;
            &#13;
        // a small gift of exp &amp; egst to the god who burned gas to send rewards to the community&#13;
        egst_from_contract(msg.sender, mul(initializer_reward, 1 ether), 1); // 1 pray_reward&#13;
        _totalSupply = add(_totalSupply, mul(initializer_reward, 1 ether));  &#13;
        add_exp(msg.sender, initializer_reward);&#13;
&#13;
        rewarded_pray_winners = true;&#13;
        initialize_pray();&#13;
        return true;&#13;
    }&#13;
&#13;
&#13;
    // more listed gods, more reward to the top gods, highest reward 600 egst&#13;
    function reward_top_gods () private returns (bool){ // public when testing&#13;
        &#13;
        uint count_listed_gods = listed_gods.length;&#13;
        uint last_god_index;&#13;
        &#13;
        if (count_listed_gods &gt; 100) {&#13;
            last_god_index = sub(count_listed_gods, 100);&#13;
        } else {&#13;
            last_god_index = 0;&#13;
        }&#13;
        &#13;
        uint reward_egst = 0;&#13;
        uint base_reward = 6 ether;&#13;
        if (count_rounds == 6){&#13;
            base_reward = mul(base_reward, 6);&#13;
        }&#13;
        for (uint i = last_god_index; i &lt; count_listed_gods; i++) {&#13;
            reward_egst = mul(base_reward, sub(add(i, 1), last_god_index));&#13;
            egst_from_contract(gods_address[listed_gods[i]], reward_egst, 2);// 2 top_gods_reward&#13;
            _totalSupply = add(_totalSupply, reward_egst);   &#13;
            if (gods[gods_address[listed_gods[i]]].blessing_player_id &gt; 0){&#13;
                egst_from_contract(gods_address[gods[gods_address[listed_gods[i]]].blessing_player_id], reward_egst, 2);// 2 top_gods_reward&#13;
                _totalSupply = add(_totalSupply, reward_egst); &#13;
            }&#13;
        }&#13;
        &#13;
        return true;&#13;
    }&#13;
&#13;
&#13;
    function compare_bid_eth () private view returns (uint, address) {&#13;
        uint highest_bid = 0;&#13;
        address highest_bidder = v_god; // if no one bid, v god host this event&#13;
&#13;
        for (uint j = 1; j &lt;= listed_gods.length; j++){&#13;
            if (gods[bidding_gods[j]].bid_eth &gt; highest_bid){&#13;
                highest_bid = gods[bidding_gods[j]].bid_eth;&#13;
                highest_bidder = bidding_gods[j];&#13;
            }&#13;
        }&#13;
        return (highest_bid, highest_bidder);&#13;
    }&#13;
&#13;
&#13;
    function check_event_completed () public view returns (bool){&#13;
        // check min and max pray_event duration&#13;
        if (add(pray_start_block, max_pray_duration) &gt; block.number){&#13;
            if (add(pray_start_block, min_pray_duration) &lt; block.number){&#13;
                for (uint i = 1; i &lt;= 5; i++){&#13;
                    if(count_listed_winners[i] &lt; max_winners[i]){&#13;
                        return false;&#13;
                    }           &#13;
                }&#13;
                return true;&#13;
            } else {&#13;
                return false;&#13;
            }&#13;
            &#13;
        } else {&#13;
            return true;   &#13;
        }&#13;
    }&#13;
&#13;
&#13;
    function pk (address attacker, address defender, bytes32 block_hash) public view returns (bool pk_result){// make it public, view only, other contract may use it&#13;
&#13;
        (uint attacker_sum_god_levels, uint attacker_sum_amulet_levels) = get_sum_levels_pk(attacker);&#13;
        (uint defender_sum_god_levels, uint defender_sum_amulet_levels) = get_sum_levels_pk(defender);&#13;
    &#13;
        pk_result = eth_gods_dice.pk(block_hash, attacker_sum_god_levels, attacker_sum_amulet_levels, defender_sum_god_levels, defender_sum_amulet_levels);&#13;
        &#13;
        return pk_result;&#13;
    }&#13;
    &#13;
    &#13;
    function get_sum_levels_pk (address god_address) public view returns (uint sum_gods_level, uint sum_amulets_level){&#13;
             &#13;
        sum_gods_level =  gods[god_address].level;&#13;
        sum_amulets_level = gods[god_address].pet_level; // add pet level to the sum&#13;
		uint amulet_god_id;&#13;
        uint amulet_god_level;&#13;
        for (uint i = 1; i &lt;= count_amulets; i++){&#13;
            if (amulets[i].owner == god_address &amp;&amp; amulets[i].start_selling_block == 0){&#13;
                amulet_god_id = amulets[i].god_id;&#13;
                amulet_god_level = gods[gods_address[amulet_god_id]].level;&#13;
                sum_gods_level = add(sum_gods_level, amulet_god_level);&#13;
                sum_amulets_level = add(sum_amulets_level, amulets[i].level);&#13;
            }&#13;
        }&#13;
                &#13;
        return (sum_gods_level, sum_amulets_level);&#13;
    }&#13;
        &#13;
    //admin need this function&#13;
    function get_listed_winners (uint prize) public view returns (address[]){&#13;
        address [] memory temp_list = new address[] (count_listed_winners[prize]);&#13;
        for (uint i = 0; i &lt; count_listed_winners[prize]; i++){&#13;
            temp_list[i] = listed_winners[prize][add(i,1)];&#13;
        }&#13;
        return temp_list;&#13;
    }&#13;
&#13;
   &#13;
    function query_pray () public view returns (uint, uint, uint, address, address, uint, bool){&#13;
        (uint highest_bid, address highest_bidder) = compare_bid_eth();&#13;
        return (highest_bid, &#13;
                pray_egses, &#13;
                pray_egst, &#13;
                pray_host_god, &#13;
                highest_bidder,&#13;
                count_rounds,&#13;
                pray_reward_top100);&#13;
    }     &#13;
    &#13;
&#13;
 &#13;
    // end of pray&#13;
&#13;
    // start of egses&#13;
&#13;
    function egses_from_contract (address to, uint tokens, uint reason) private returns (bool) { // public when testing&#13;
        if (reason == 1) {&#13;
            require (pray_egses &gt; tokens);&#13;
            pray_egses = sub(pray_egses, tokens);&#13;
        }&#13;
&#13;
        egses_balances[to] = add(egses_balances[to], tokens);&#13;
&#13;
        create_change_log(1, reason, tokens, egses_balances[to], contract_address, to);&#13;
        return true;&#13;
    } &#13;
    &#13;
    function egses_withdraw () public returns (uint tokens){&#13;
        tokens = egses_balances[msg.sender];&#13;
        require (tokens &gt; 0 &amp;&amp; contract_address.balance &gt;= tokens &amp;&amp; reEntrancyMutex == false);&#13;
&#13;
        reEntrancyMutex = true; // if met problem, it will use up gas from msg.sender and roll back to false&#13;
        egses_balances[msg.sender] = 0;&#13;
        msg.sender.transfer(tokens);&#13;
        reEntrancyMutex = false;&#13;
        &#13;
        emit withdraw_egses(msg.sender, tokens);&#13;
        create_change_log(1, 5, tokens, 0, contract_address, msg.sender); // 5 withdraw egses&#13;
&#13;
        return tokens;&#13;
    }&#13;
    event withdraw_egses (address receiver, uint tokens);&#13;
&#13;
   // end of egses&#13;
   &#13;
&#13;
    // start of erc20 for egst&#13;
    function totalSupply () public view returns (uint){&#13;
        return _totalSupply;&#13;
    }&#13;
&#13;
&#13;
    function balanceOf (address tokenOwner) public view returns (uint){&#13;
        return balances[tokenOwner]; // will return 0 if doesn't exist&#13;
    }&#13;
&#13;
    function allowance (address tokenOwner, address spender) public view returns (uint) {&#13;
        return allowed[tokenOwner][spender];&#13;
    }&#13;
&#13;
    function transfer (address to, uint tokens) public returns (bool success){&#13;
        require (balances[msg.sender] &gt;= tokens);&#13;
        balances[msg.sender] = sub(balances[msg.sender], tokens);&#13;
        balances[to] = add(balances[to], tokens);&#13;
        emit Transfer(msg.sender, to, tokens);&#13;
        create_change_log(2, 9, tokens, balances[to], msg.sender, to);&#13;
        &#13;
        return true;    &#13;
    }&#13;
    event Transfer (address indexed from, address indexed to, uint tokens);&#13;
&#13;
&#13;
    function approve (address spender, uint tokens) public returns (bool success) {&#13;
        // if allowed amount used and owner tries to reset allowed amount within a short time,&#13;
        // the allowed account might be cheating the owner&#13;
        require (balances[msg.sender] &gt;= tokens);&#13;
        if (tokens &gt; 0){&#13;
            require (add(gods[msg.sender].allowed_block, allowed_use_CD) &lt; block.number);&#13;
        }&#13;
&#13;
        allowed[msg.sender][spender] = tokens;&#13;
        &#13;
        emit Approval(msg.sender, spender, tokens);&#13;
        return true;&#13;
    }&#13;
    event Approval (address indexed tokenOwner, address indexed spender, uint tokens);&#13;
&#13;
&#13;
    function transferFrom (address from, address to, uint tokens) public returns (bool success) {&#13;
        require (balances[from] &gt;= tokens);&#13;
        allowed[from][msg.sender] = sub(allowed[from][msg.sender], tokens);&#13;
        balances[from] = sub(balances[from], tokens);&#13;
        balances[to] = add(balances[to], tokens);&#13;
        gods[from].allowed_block = block.number;&#13;
        &#13;
        emit Transfer(from, to, tokens);&#13;
        create_change_log(2, 10, tokens, balances[to], from, to);&#13;
        return true;    &#13;
    }&#13;
&#13;
    // end of erc20 for egst&#13;
    &#13;
    &#13;
    // egst&#13;
  &#13;
    function egst_from_contract (address to, uint tokens, uint reason) private returns (bool) { // public when testing&#13;
        balances[to] = add(balances[to], tokens);&#13;
&#13;
        create_change_log(2, reason, tokens, balances[to], contract_address, to); &#13;
        return true;&#13;
    }&#13;
&#13;
    function egst_to_contract (address from, uint tokens, uint reason) private returns (bool) { // public when testing&#13;
        require (balances[from] &gt;= tokens);&#13;
        balances[from] = sub(balances[from], tokens);&#13;
        &#13;
&#13;
        emit spend_egst(from, tokens, reason);&#13;
        create_change_log(2, reason, tokens, balances[from], from, contract_address);&#13;
        return true;&#13;
    }&#13;
    event spend_egst (address from, uint tokens, uint reason);&#13;
&#13;
&#13;
    function create_token_order (uint unit_price, uint egst_amount) public returns (uint) {      &#13;
        require(unit_price &gt;= min_unit_price &amp;&amp; unit_price &lt;= max_unit_price &#13;
        &amp;&amp; balances[msg.sender] &gt;= egst_amount&#13;
        &amp;&amp; egst_amount &lt;= max_egst_amount&#13;
        &amp;&amp; egst_amount &gt;= min_egst_amount);&#13;
&#13;
        count_token_orders = add(count_token_orders, 1);&#13;
&#13;
        egst_to_contract(msg.sender, egst_amount, 3); // 3 create_token_order&#13;
        &#13;
        token_orders[count_token_orders].start_selling_block = block.number;    &#13;
        token_orders[count_token_orders].seller = msg.sender;&#13;
        token_orders[count_token_orders].unit_price = unit_price;&#13;
        token_orders[count_token_orders].egst_amount = egst_amount;&#13;
        gods[msg.sender].count_token_orders++;&#13;
        &#13;
        update_first_active_token_order(msg.sender);&#13;
&#13;
        return gods[msg.sender].count_token_orders++;&#13;
    }&#13;
&#13;
&#13;
    function withdraw_token_order (uint order_id) public returns (bool) { &#13;
        require (msg.sender == token_orders[order_id].seller&#13;
                &amp;&amp; token_orders[order_id].egst_amount &gt; 0);&#13;
&#13;
        uint egst_amount = token_orders[order_id].egst_amount;&#13;
        token_orders[order_id].start_selling_block = 0;&#13;
        token_orders[order_id].egst_amount = 0;&#13;
        // balances[msg.sender] = add(balances[msg.sender], tokens);&#13;
        egst_from_contract(msg.sender, egst_amount, 4); // 4  withdraw token_order&#13;
        gods[msg.sender].count_token_orders = sub(gods[msg.sender].count_token_orders, 1);&#13;
        &#13;
        update_first_active_token_order(msg.sender);&#13;
        emit WithdrawTokenOrder(msg.sender, order_id);&#13;
&#13;
        return true;&#13;
    }&#13;
    event WithdrawTokenOrder (address seller, uint order_id);&#13;
&#13;
    function buy_token (uint order_id, uint egst_amount) public payable returns (uint) { &#13;
&#13;
        require(order_id &gt;= first_active_token_order &#13;
                &amp;&amp; order_id &lt;= count_token_orders&#13;
                &amp;&amp; egst_amount &lt;= token_orders[order_id].egst_amount&#13;
                &amp;&amp; token_orders[order_id].egst_amount &gt; 0);&#13;
        &#13;
        // unit_price 100 means 1 egst = 0.001 ether&#13;
        uint eth_cost = div(mul(token_orders[order_id].unit_price, egst_amount), 100000);&#13;
        require(msg.value &gt;= eth_cost &amp;&amp; msg.value &lt; add(eth_cost, max_extra_eth) );&#13;
&#13;
        token_orders[order_id].egst_amount = sub(token_orders[order_id].egst_amount, egst_amount);&#13;
        egst_from_contract(msg.sender, egst_amount, token_orders[order_id].unit_price); // uint price (&gt; 10) will be recorded as reason in change log and translated by front end as buy token &amp; unit_price&#13;
        // balances[msg.sender] = add(balances[msg.sender], egst_amount);&#13;
        &#13;
        address seller = token_orders[order_id].seller;&#13;
        egses_from_contract(seller, eth_cost, 7); // 7 sell egst&#13;
        &#13;
        &#13;
        if (token_orders[order_id].egst_amount &lt;= 0){&#13;
            token_orders[order_id].start_selling_block = 0;&#13;
            gods[seller].count_token_orders = sub(gods[seller].count_token_orders, 1);&#13;
            update_first_active_token_order(seller);&#13;
        }&#13;
        &#13;
        emit BuyToken(msg.sender, order_id, egst_amount);&#13;
&#13;
        return token_orders[order_id].egst_amount;&#13;
    }&#13;
    event BuyToken (address buyer, uint order_id, uint egst_amount);&#13;
&#13;
  &#13;
    function update_first_active_token_order (address god_address) private returns (uint, uint){ // public when testing&#13;
        if (count_token_orders &gt; 0 &#13;
        &amp;&amp; first_active_token_order == 0){&#13;
            first_active_token_order = 1;&#13;
        } else {&#13;
            for (uint i = first_active_token_order; i &lt;= count_token_orders; i++) {&#13;
                if (add(token_orders[i].start_selling_block, order_duration) &gt; block.number){&#13;
                    // find the first active order and compare with the currect index&#13;
                    if (i &gt; first_active_token_order){&#13;
                        first_active_token_order = i;&#13;
                    }&#13;
                    break;&#13;
                }&#13;
            }    &#13;
        }&#13;
            &#13;
        if (gods[god_address].count_token_orders &gt; 0&#13;
        &amp;&amp; gods[god_address].first_active_token_order == 0){&#13;
            gods[god_address].first_active_token_order = 1; // may not be 1, but it will correct next time&#13;
        } else {&#13;
            for (uint j = gods[god_address].first_active_token_order; j &lt; count_token_orders; j++){&#13;
                if (token_orders[j].seller == god_address &#13;
                &amp;&amp; token_orders[j].start_selling_block &gt; 0){ // don't check duration, show it to selling, even if expired&#13;
                    // find the first active order and compare with the currect index&#13;
                    if(j &gt; gods[god_address].first_active_token_order){&#13;
                        gods[god_address].first_active_token_order = j;&#13;
                    }&#13;
                    break;&#13;
                }&#13;
            }&#13;
        }&#13;
        &#13;
        return (first_active_token_order, gods[msg.sender].first_active_token_order);&#13;
    }&#13;
&#13;
&#13;
    function get_token_order (uint order_id) public view returns(uint, address, uint, uint){&#13;
        require(order_id &gt;= 1 &amp;&amp; order_id &lt;= count_token_orders);&#13;
&#13;
        return(token_orders[order_id].start_selling_block,&#13;
               token_orders[order_id].seller,&#13;
               token_orders[order_id].unit_price,&#13;
               token_orders[order_id].egst_amount);&#13;
    }&#13;
&#13;
    // return total orders and lowest price to browser, browser query each active order and show at most three orders of lowest price&#13;
    function get_token_orders () public view returns(uint, uint, uint, uint, uint) {&#13;
        uint lowest_price = max_unit_price;&#13;
        for (uint i = first_active_token_order; i &lt;= count_token_orders; i++){&#13;
            if (token_orders[i].unit_price &lt; lowest_price &#13;
            &amp;&amp; token_orders[i].egst_amount &gt; 0&#13;
            &amp;&amp; add(token_orders[i].start_selling_block, order_duration) &gt; block.number){&#13;
                lowest_price = token_orders[i].unit_price;&#13;
            }&#13;
        }&#13;
        return (count_token_orders, first_active_token_order, order_duration, max_unit_price, lowest_price);&#13;
    }&#13;
    &#13;
&#13;
    function get_my_token_orders () public view returns(uint []) {&#13;
        uint my_count_token_orders = gods[msg.sender].count_token_orders;&#13;
        uint [] memory temp_list = new uint[] (my_count_token_orders);&#13;
        uint count_list_elements = 0;&#13;
        for (uint i = gods[msg.sender].first_active_token_order; i &lt;= count_token_orders; i++){&#13;
            if (token_orders[i].seller == msg.sender&#13;
            &amp;&amp; token_orders[i].start_selling_block &gt; 0){&#13;
                temp_list[count_list_elements] = i;&#13;
                count_list_elements++;&#13;
                &#13;
                if (count_list_elements &gt;= my_count_token_orders){&#13;
                    break;&#13;
                }&#13;
            }&#13;
        }&#13;
&#13;
        return temp_list;&#13;
    }&#13;
&#13;
&#13;
    // end of egst&#13;
    &#13;
   &#13;
    // logs&#13;
    function get_winner_log (uint pray_round, uint log_id) public view returns (uint, bytes32, address, address, uint, bool){&#13;
        require(log_id &gt;= 1 &amp;&amp; log_id &lt;= count_rounds_winner_logs[pray_round]);&#13;
        winner_log storage this_winner_log = winner_logs[pray_round][log_id];&#13;
        return (this_winner_log.god_block_number,&#13;
                this_winner_log.block_hash,&#13;
                this_winner_log.prayer,&#13;
                this_winner_log.previous_winner,&#13;
                this_winner_log.prize,&#13;
                this_winner_log.pk_result);&#13;
    }    &#13;
&#13;
    function get_count_rounds_winner_logs (uint pray_round) public view returns (uint){&#13;
        return count_rounds_winner_logs[pray_round];&#13;
    }&#13;
&#13;
&#13;
    // egses change reasons:  &#13;
        // 1 pray_reward, 2 god_reward for being invited, 3 inviter_reward,&#13;
        // 4 admin_deposit to reward_pool, 5 withdraw egses&#13;
        // 6 sell amulet, 7 sell egst, 8 withdraw bid&#13;
    &#13;
    // egst_change reasons: &#13;
        // 1 pray_reward, 2 top_gods_reward, &#13;
        // 3 create_token_order, 4 withdraw token_order, 5 buy token (&gt; 10),  &#13;
        // 6 upgrade pet, 7 upgrade amulet, 8 admin_reward, &#13;
        // 9 transfer, 10 transferFrom(owner &amp; receiver)&#13;
&#13;
        &#13;
    function create_change_log (uint asset_type, uint reason, uint change_amount, uint after_amount, address _from, address _to) private returns (uint) {&#13;
        count_rounds_change_logs[count_rounds] = add(count_rounds_change_logs[count_rounds], 1);&#13;
        uint log_id = count_rounds_change_logs[count_rounds];&#13;
 &#13;
        change_logs[count_rounds][log_id].block_number = block.number;&#13;
        change_logs[count_rounds][log_id].asset_type = asset_type;&#13;
        change_logs[count_rounds][log_id].reason = reason;&#13;
        change_logs[count_rounds][log_id].change_amount = change_amount;&#13;
        change_logs[count_rounds][log_id].after_amount = after_amount; &#13;
        change_logs[count_rounds][log_id]._from = _from;&#13;
        change_logs[count_rounds][log_id]._to = _to;&#13;
        &#13;
        return log_id;&#13;
    }&#13;
          &#13;
    function get_change_log (uint pray_round, uint log_id) public view returns (uint, uint, uint, uint, uint, address, address){ // public&#13;
        change_log storage this_log = change_logs[pray_round][log_id];&#13;
        return (this_log.block_number,&#13;
                this_log.asset_type,&#13;
                this_log.reason, // reason &gt; 10 is buy_token unit_price&#13;
                this_log.change_amount,&#13;
                this_log.after_amount, // god's after amount. transfer or transferFrom doesn't record log&#13;
                this_log._from,&#13;
                this_log._to);&#13;
        &#13;
    }&#13;
    &#13;
    function get_count_rounds_change_logs (uint pray_round) public view returns(uint){&#13;
        return count_rounds_change_logs[pray_round];&#13;
    }&#13;
    &#13;
    // end of logs&#13;
&#13;
&#13;
    // common functions&#13;
&#13;
     function add (uint a, uint b) internal pure returns (uint c) {&#13;
         c = a + b;&#13;
         require(c &gt;= a);&#13;
     }&#13;
     function sub (uint a, uint b) internal pure returns (uint c) {&#13;
        require(b &lt;= a);&#13;
         c = a - b;&#13;
     }&#13;
     function mul (uint a, uint b) internal pure returns (uint c) {&#13;
         c = a * b;&#13;
         require(a == 0 || c / a == b);&#13;
     }&#13;
     function div (uint a, uint b) internal pure returns (uint c) {&#13;
         require(b &gt; 0);&#13;
         c = a / b;&#13;
     }&#13;
&#13;
}&#13;
&#13;
&#13;
contract EthGodsDice {&#13;
    &#13;
    // ethgods&#13;
    EthGods private eth_gods;&#13;
    address private ethgods_contract_address = address(0);// publish ethgods first, then use that address in constructor &#13;
    function set_eth_gods_contract_address(address eth_gods_contract_address) public returns (bool){&#13;
        require (msg.sender == admin);&#13;
        &#13;
        ethgods_contract_address = eth_gods_contract_address;&#13;
        eth_gods = EthGods(ethgods_contract_address); &#13;
        return true;&#13;
    }&#13;
  &#13;
    address private admin; // manually update to ethgods' admin&#13;
    uint private block_hash_duration;&#13;
    function update_admin () public returns (bool){&#13;
        (,,address new_admin, uint new_block_hash_duration,,,) = eth_gods.query_contract();&#13;
        require (msg.sender == new_admin);&#13;
        admin = new_admin;&#13;
        block_hash_duration = new_block_hash_duration;&#13;
        return true;&#13;
    }&#13;
        &#13;
    //contract information &amp; administration&#13;
    bool private contract_created; // in case constructor logic change in the future&#13;
    address private contract_address; //shown at the top of the home page&#13;
    &#13;
    // start of constructor and destructor&#13;
    constructor () public {&#13;
        require (contract_created == false);&#13;
        contract_created = true;&#13;
        contract_address = address(this);&#13;
        admin = msg.sender;&#13;
&#13;
    }&#13;
&#13;
    function finalize () public {&#13;
        require (msg.sender == admin);&#13;
        selfdestruct(msg.sender); &#13;
    }&#13;
    &#13;
    function () public payable {&#13;
        revert();  // if received eth for no reason, reject&#13;
    }&#13;
    &#13;
    // end of constructor and destructor&#13;
&#13;
    function tell_fortune_blockhash () public view returns (bytes32){&#13;
        bytes32 block_hash;&#13;
        (uint god_block_number,,,,,,) = eth_gods.get_god_info(msg.sender);&#13;
        if (god_block_number &gt; 0&#13;
            &amp;&amp; add(god_block_number, 1) &lt; block.number&#13;
            &amp;&amp; add(god_block_number, block_hash_duration) &gt; block.number) {&#13;
            block_hash = keccak256(abi.encodePacked(blockhash(god_block_number + 1)));&#13;
        } else {&#13;
            block_hash = keccak256(abi.encodePacked(blockhash(block.number - 1)));&#13;
        }&#13;
        return block_hash;&#13;
    }&#13;
    &#13;
        &#13;
    function tell_fortune () public view returns (uint[]){&#13;
        bytes32 block_hash;&#13;
        (uint god_block_number,,,,,,) = eth_gods.get_god_info(msg.sender);&#13;
        if (god_block_number &gt; 0&#13;
            &amp;&amp; add(god_block_number, 1) &lt; block.number&#13;
            &amp;&amp; add(god_block_number, block_hash_duration) &gt; block.number) {&#13;
            block_hash = keccak256(abi.encodePacked(blockhash(god_block_number + 1)));&#13;
        } else {&#13;
            block_hash = keccak256(abi.encodePacked(blockhash(block.number - 1)));&#13;
        }&#13;
        return throw_dice (block_hash);&#13;
    }&#13;
&#13;
    &#13;
    function throw_dice (bytes32 block_hash) public pure returns (uint[]) {// 0 for prize, 1-6 for 6 numbers should be pure&#13;
        uint[] memory dice_numbers = new uint[](7);&#13;
        //uint [7] memory dice_numbers;&#13;
        uint hash_number;&#13;
        uint[] memory count_dice_numbers = new uint[](7);&#13;
        //uint [7] memory count_dice_numbers;   // how many times for each dice number&#13;
        uint i; // for loop&#13;
  &#13;
        for (i = 1; i &lt;= 6; i++) {&#13;
            hash_number = uint(block_hash[i]);&#13;
            // hash_number=1;&#13;
            if (hash_number &gt;= 214) { // 214&#13;
                dice_numbers[i] = 6;&#13;
            } else if (hash_number &gt;= 172) { // 172&#13;
                dice_numbers[i] = 5;&#13;
            } else if (hash_number &gt;= 129) { // 129&#13;
                dice_numbers[i] = 4;&#13;
            } else if (hash_number &gt;= 86) { // 86&#13;
                dice_numbers[i] = 3;&#13;
            } else if (hash_number &gt;= 43) { // 43&#13;
                dice_numbers[i] = 2;&#13;
            } else {&#13;
                dice_numbers[i] = 1;&#13;
            }&#13;
            count_dice_numbers[dice_numbers[i]] ++;&#13;
        }&#13;
&#13;
        bool won_super_prize = false;&#13;
        uint count_super_eth = 0;&#13;
        for (i = 1; i &lt;= 6; i++) {&#13;
            if (count_dice_numbers[i] &gt;= 5) {&#13;
                dice_numbers[0] = 1; //champion_eth&#13;
                won_super_prize = true;&#13;
                break;&#13;
            }else if (count_dice_numbers[i] == 4) {&#13;
                dice_numbers[0] = 3; // super_egst&#13;
                won_super_prize = true;&#13;
                break;&#13;
            }else if (count_dice_numbers[i] == 1) {&#13;
                count_super_eth ++;&#13;
                if (count_super_eth == 6) {&#13;
                    dice_numbers[0] = 2; // super_eth&#13;
                    won_super_prize = true;&#13;
                }&#13;
            } &#13;
        }&#13;
&#13;
        if (won_super_prize == false) {&#13;
            if (count_dice_numbers[6] &gt;= 2){&#13;
                dice_numbers[0] = 4; // primary_egst&#13;
            } else if (count_dice_numbers[6] == 1){&#13;
                dice_numbers[0] = 5; // lucky_star&#13;
            } &#13;
        }&#13;
        &#13;
        return dice_numbers;&#13;
    }&#13;
    &#13;
    function pk (bytes32 block_hash, uint attacker_sum_god_levels, uint attacker_sum_amulet_levels, uint defender_sum_god_levels, uint defender_sum_amulet_levels) public pure returns (bool){&#13;
     &#13;
        uint god_win_chance;&#13;
        attacker_sum_god_levels = add(attacker_sum_god_levels, 10);&#13;
        if (attacker_sum_god_levels &lt; defender_sum_god_levels){&#13;
            god_win_chance = 0;&#13;
        } else {&#13;
            god_win_chance = sub(attacker_sum_god_levels, defender_sum_god_levels);&#13;
            if (god_win_chance &gt; 20) {&#13;
                god_win_chance = 100;&#13;
            } else { // equal level, 50% chance to win&#13;
                god_win_chance = mul(god_win_chance, 5);&#13;
            }&#13;
        }        &#13;
        &#13;
        &#13;
        uint amulet_win_chance;&#13;
        attacker_sum_amulet_levels = add(attacker_sum_amulet_levels, 10);&#13;
        if (attacker_sum_amulet_levels &lt; defender_sum_amulet_levels){&#13;
            amulet_win_chance = 0;&#13;
        } else {&#13;
            amulet_win_chance = sub(attacker_sum_amulet_levels, defender_sum_amulet_levels);&#13;
            if (amulet_win_chance &gt; 20) {&#13;
                amulet_win_chance = 100;&#13;
            } else { // equal level, 50% chance to win&#13;
                amulet_win_chance = mul(amulet_win_chance, 5);&#13;
            }&#13;
        }&#13;
&#13;
        &#13;
        uint attacker_win_chance = div(add(god_win_chance, amulet_win_chance), 2);&#13;
        if (attacker_win_chance &gt;= div(mul(uint(block_hash[3]),2),5)){&#13;
            return true;&#13;
        } else {&#13;
            return false;&#13;
        }&#13;
        &#13;
    }&#13;
    &#13;
    &#13;
    // common functions&#13;
&#13;
     function add (uint a, uint b) internal pure returns (uint c) {&#13;
         c = a + b;&#13;
         require(c &gt;= a);&#13;
     }&#13;
     function sub (uint a, uint b) internal pure returns (uint c) {&#13;
        require(b &lt;= a);&#13;
         c = a - b;&#13;
     }&#13;
     function mul (uint a, uint b) internal pure returns (uint c) {&#13;
         c = a * b;&#13;
         require(a == 0 || c / a == b);&#13;
     }&#13;
     function div (uint a, uint b) internal pure returns (uint c) {&#13;
         require(b &gt; 0);&#13;
         c = a / b;&#13;
     }&#13;
        &#13;
}&#13;
&#13;
&#13;
contract EthGodsName {&#13;
&#13;
    // EthGods&#13;
    EthGods private eth_gods;&#13;
    address private ethgods_contract_address;   &#13;
    function set_eth_gods_contract_address (address eth_gods_contract_address) public returns (bool){&#13;
        require (msg.sender == admin);&#13;
        &#13;
        ethgods_contract_address = eth_gods_contract_address;&#13;
        eth_gods = EthGods(ethgods_contract_address); &#13;
        return true;&#13;
    }&#13;
  &#13;
    address private admin; // manually update to ethgods' admin&#13;
    function update_admin () public returns (bool){&#13;
        (,,address new_admin,,,,) = eth_gods.query_contract();&#13;
        require (msg.sender == new_admin);&#13;
        admin = new_admin;&#13;
        return true;&#13;
    }&#13;
&#13;
    //contract information &amp; administration&#13;
    bool private contract_created; // in case constructor logic change in the future&#13;
    address private contract_address; //shown at the top of the home page   &#13;
    &#13;
    string private invalid_chars = "\\\"";&#13;
    bytes private invalid_bytes = bytes(invalid_chars);&#13;
    function set_invalid_chars (string new_invalid_chars) public returns (bool) {&#13;
        require(msg.sender == admin);&#13;
        invalid_chars = new_invalid_chars;&#13;
        invalid_bytes = bytes(invalid_chars);&#13;
        return true;&#13;
    }&#13;
    &#13;
    uint private valid_length = 16;    &#13;
    function set_valid_length (uint new_valid_length) public returns (bool) {&#13;
        require(msg.sender == admin);&#13;
        valid_length = new_valid_length;&#13;
        return true;&#13;
    }&#13;
    &#13;
    struct god_name {&#13;
        string god_name;&#13;
        uint block_number;&#13;
        uint block_duration;&#13;
    }&#13;
    mapping (address =&gt; god_name) private gods_name;&#13;
&#13;
    // start of constructor and destructor&#13;
    &#13;
    constructor () public {    &#13;
        require (contract_created == false);&#13;
        contract_created = true;&#13;
        contract_address = address(this);&#13;
        admin = msg.sender;     &#13;
        address v_god = 0xfB6916095ca1df60bB79Ce92cE3Ea74c37c5d359;&#13;
        gods_name[v_god].god_name = "V";&#13;
    }&#13;
&#13;
    function () public payable {&#13;
        revert();  // if received eth for no reason, reject&#13;
    }&#13;
&#13;
    function finalize() public {&#13;
        require (msg.sender == admin);&#13;
        selfdestruct(msg.sender); &#13;
    }&#13;
    &#13;
    // end of constructor and destructor&#13;
    &#13;
    &#13;
    function set_god_name (string new_name) public returns (bool){&#13;
        address god_address = msg.sender;&#13;
        require (add(gods_name[god_address].block_number, gods_name[god_address].block_duration) &lt; block.number );&#13;
&#13;
        bytes memory bs = bytes(new_name);&#13;
        require (bs.length &lt;= valid_length);&#13;
        &#13;
        for (uint i = 0; i &lt; bs.length; i++){&#13;
            for (uint j = 0; j &lt; invalid_bytes.length; j++) {&#13;
                if (bs[i] == invalid_bytes[j]){&#13;
                    return false;&#13;
                } &#13;
            }&#13;
        }&#13;
&#13;
        gods_name[god_address].god_name = new_name;&#13;
        emit set_name(god_address, new_name);&#13;
        return true;&#13;
    }&#13;
    event set_name (address indexed god_address, string new_name);&#13;
&#13;
&#13;
    function get_god_name (address god_address) public view returns (string) {&#13;
        return gods_name[god_address].god_name;&#13;
    }&#13;
&#13;
    function block_god_name (address god_address, uint block_duration) public {&#13;
        require (msg.sender == admin);&#13;
        gods_name[god_address].god_name = "Unkown";&#13;
        gods_name[god_address].block_number = block.number;&#13;
        gods_name[god_address].block_duration = block_duration;&#13;
    }&#13;
    &#13;
    function add (uint a, uint b) internal pure returns (uint c) {&#13;
        c = a + b;&#13;
        require(c &gt;= a);&#13;
    }&#13;
}