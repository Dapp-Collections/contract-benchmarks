/*
   BURSA DEX              Source code available under GPLv2 license
                          2018  Michael Baynov <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="35581b57544c5b5a43755258545c591b565a58">[emailÂ protected]</a>&gt;&#13;
&#13;
   BURSA  is a new generation of decentralized exchanges based on&#13;
   state storage, not logs (events). It is designed to be used both&#13;
   with or without a frontend. A DAPP connected to BURSA contract&#13;
   will receive 30% share of trade fee. To have it, just pass the&#13;
   refund address as the last argument to buy() and sell() methods.&#13;
   Trading without a frontend gives you 30% descount.&#13;
   BURSA is recommended to be used with Parity Wallet.&#13;
&#13;
&#13;
   WANT TO TRADE ON BURSA? READ THE DOCS:&#13;
   https://github.com/termslang/bursadex&#13;
&#13;
&#13;
BURSA CONTRACT ABI:&#13;
[{"constant":false,"inputs":[{"name":"amount","type":"uint256"},{"name":"token","type":"address"},{"name":"price_each","type":"uint256"},{"name":"bid_order_spot","type":"uint256"}],"name":"willbuy","outputs":[{"name":"","type":"bool"}],"payable":true,"stateMutability":"payable","type":"function"},{"constant":true,"inputs":[],"name":"updateAvailable","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"name","outputs":[{"name":"","type":"string"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[{"name":"token","type":"address"},{"name":"min_trade_amount","type":"uint256"}],"name":"findBestBid","outputs":[{"name":"bid_order","type":"uint256"},{"name":"volume","type":"uint256"},{"name":"price","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"amount","type":"uint256"}],"name":"withdraw","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[{"name":"token","type":"address"},{"name":"user","type":"address"}],"name":"balanceApprovedForToken","outputs":[{"name":"amount","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[{"name":"user","type":"address"}],"name":"balanceOf","outputs":[{"name":"balance","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[{"name":"token","type":"address"},{"name":"ask_order","type":"uint256"}],"name":"willsellInfo","outputs":[{"name":"user","type":"address"},{"name":"price","type":"uint256"},{"name":"amount","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"amount","type":"uint256"},{"name":"token","type":"address"},{"name":"min_price_each","type":"uint256"},{"name":"bid_order","type":"uint256"},{"name":"frontend_refund","type":"address"}],"name":"sell","outputs":[{"name":"","type":"bool"}],"payable":true,"stateMutability":"payable","type":"function"},{"constant":true,"inputs":[{"name":"token","type":"address"},{"name":"min_trade_amount","type":"uint256"}],"name":"findBestAsk","outputs":[{"name":"ask_order","type":"uint256"},{"name":"volume","type":"uint256"},{"name":"price","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"amount","type":"uint256"},{"name":"token","type":"address"},{"name":"price_each","type":"uint256"},{"name":"ask_order_spot","type":"uint256"}],"name":"willsell","outputs":[{"name":"","type":"bool"}],"payable":true,"stateMutability":"payable","type":"function"},{"constant":true,"inputs":[{"name":"token","type":"address"},{"name":"bid_order","type":"uint256"}],"name":"willbuyInfo","outputs":[{"name":"user","type":"address"},{"name":"price","type":"uint256"},{"name":"amount","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[],"name":"deposit","outputs":[{"name":"","type":"bool"}],"payable":true,"stateMutability":"payable","type":"function"},{"constant":true,"inputs":[{"name":"token","type":"address"}],"name":"willsellFindSpot","outputs":[{"name":"ask_order_spot","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[{"name":"token","type":"address"}],"name":"willbuyFindSpot","outputs":[{"name":"bid_order_spot","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"amount","type":"uint256"},{"name":"token","type":"address"},{"name":"max_price_each","type":"uint256"},{"name":"ask_order","type":"uint256"},{"name":"frontend_refund","type":"address"}],"name":"buy","outputs":[{"name":"","type":"bool"}],"payable":true,"stateMutability":"payable","type":"function"},{"inputs":[],"payable":false,"stateMutability":"nonpayable","type":"constructor"},{"payable":true,"stateMutability":"payable","type":"fallback"},{"anonymous":false,"inputs":[{"indexed":false,"name":"amount","type":"uint256"},{"indexed":false,"name":"token","type":"address"},{"indexed":false,"name":"price_each","type":"uint256"},{"indexed":false,"name":"buyer","type":"address"},{"indexed":false,"name":"seller","type":"address"}],"name":"Trade","type":"event"}]&#13;
&#13;
*/&#13;
pragma solidity ^0.4.19;&#13;
contract Bursa {&#13;
&#13;
  address private ceo;&#13;
  address private admin;&#13;
  address public updateAvailable;&#13;
  mapping (address =&gt; mapping (uint256 =&gt; address)) private willsellUser;&#13;
  mapping (address =&gt; mapping (uint256 =&gt; uint256)) private willsellPrice;&#13;
  mapping (address =&gt; mapping (uint256 =&gt; uint256)) private willsellAmount;&#13;
  mapping (address =&gt; mapping (uint256 =&gt; address)) private willbuyUser;&#13;
  mapping (address =&gt; mapping (uint256 =&gt; uint256)) private willbuyPrice;&#13;
  mapping (address =&gt; mapping (uint256 =&gt; uint256)) private willbuyAmount;&#13;
  event Trade(uint256 amount, address token, uint256 price_each, address buyer, address seller);&#13;
&#13;
&#13;
  function Bursa() public {&#13;
    admin = msg.sender;&#13;
    ceo = msg.sender;&#13;
  }&#13;
  function() public payable {&#13;
    if (updateAvailable != 0) revert();&#13;
    funds[msg.sender] += msg.value;&#13;
  }&#13;
  function deposit() public payable returns (bool) {&#13;
    if (updateAvailable != 0) revert();&#13;
    funds[msg.sender] += msg.value;&#13;
    return true;&#13;
  }&#13;
&#13;
&#13;
  function buy(uint256 amount, address token, uint256 max_price_each, uint256 ask_order, address frontend_refund) public payable returns (bool) {&#13;
    if (msg.value != 0) funds[msg.sender] += msg.value;&#13;
    if ((willsellPrice[token][ask_order] &gt; max_price_each &amp;&amp; max_price_each != 0)&#13;
      || amount == 0&#13;
      || token == 0&#13;
      || token == address(this)&#13;
      || ask_order == 0&#13;
      || funds[msg.sender] &lt;= 1e15&#13;
    ) revert();&#13;
    address buyer = msg.sender;&#13;
    address seller = willsellUser[token][ask_order];&#13;
    // Cancel your own order&#13;
    if (buyer == seller) {&#13;
      if (amount &gt;= willsellAmount[token][ask_order]) {&#13;
        willsellAmount[token][ask_order] = 0;&#13;
        return true;&#13;
      }&#13;
      willsellAmount[token][ask_order] -= amount;&#13;
      return true;&#13;
    }&#13;
    // Validate amount&#13;
    uint256 volume = willsellVolume(token, ask_order);&#13;
    if (amount &gt; volume) {&#13;
      if (volume == 0) {&#13;
        willsellAmount[token][ask_order] = 0;&#13;
        return false;&#13;
      }&#13;
      amount = volume;&#13;
    }&#13;
    uint256 pay = willsellPrice[token][ask_order] * amount / 1e18;&#13;
    // Buyer pays the fee&#13;
    uint256 fee;&#13;
    if (pay &gt; 1e16 &amp;&amp; traded[msg.sender]) {&#13;
      if (frontend_refund == 0 || frontend_refund == msg.sender) {&#13;
        fee = 7e14;&#13;
      }&#13;
      else fee = 1e15;&#13;
    } // else fee = 0&#13;
    // Validate payout&#13;
    if (pay + fee &gt; funds[msg.sender]) {&#13;
      pay = funds[msg.sender] - fee;&#13;
      amount = pay * 1e18 / willsellPrice[token][ask_order];&#13;
    }&#13;
    // Trade&#13;
    if (!Bursa(token).transferFrom(seller, buyer, amount)) return false;&#13;
    funds[seller] = funds[seller] + pay;&#13;
    funds[buyer] = funds[buyer] - pay - fee;&#13;
    if (fee == 1e15) funds[frontend_refund] = funds[frontend_refund] + 3e14;&#13;
    if (traded[msg.sender] == false) {&#13;
      funds[ceo] = funds[ceo] + pay / 20;&#13;
      traded[msg.sender] = true;&#13;
    }&#13;
    // Drop uncovered order&#13;
    if (amount == volume) {&#13;
      willsellAmount[token][ask_order] = 0;&#13;
    }&#13;
    else willsellAmount[token][ask_order] -= amount;&#13;
    Trade(amount, token, willsellPrice[token][ask_order], buyer, seller);&#13;
    return true;&#13;
  }&#13;
&#13;
&#13;
  function sell(uint256 amount, address token, uint256 min_price_each, uint256 bid_order, address frontend_refund) public payable returns (bool) {&#13;
    if (msg.value != 0) funds[msg.sender] += msg.value;&#13;
    if (willbuyPrice[token][bid_order] &lt; min_price_each&#13;
      || amount == 0&#13;
      || token == 0&#13;
      || token == address(this)&#13;
      || bid_order == 0&#13;
    ) revert();&#13;
    address buyer = willbuyUser[token][bid_order];&#13;
    address seller = msg.sender;&#13;
    // Cancel your own order&#13;
    if (buyer == seller) {&#13;
      if (amount &gt;= willbuyAmount[token][bid_order]) {&#13;
        willbuyAmount[token][bid_order] = 0;&#13;
        return true;&#13;
      }&#13;
      willbuyAmount[token][bid_order] -= amount;&#13;
      return true;&#13;
    }&#13;
    // Validate amount&#13;
    uint256 volume = willbuyVolume(token, bid_order);&#13;
    if (amount &gt; volume) {&#13;
      if (volume == 0) {&#13;
        willbuyAmount[token][bid_order] = 0;&#13;
        return false;&#13;
      }&#13;
      amount = volume;&#13;
    }&#13;
    uint256 pay = willbuyPrice[token][bid_order] * amount / 1e18;&#13;
    // Seller pays the fee&#13;
    uint256 fee;&#13;
    if (pay &gt; 1e16 &amp;&amp; traded[msg.sender]) {&#13;
      if (frontend_refund == 0 || frontend_refund == msg.sender) {&#13;
        fee = 7e14;&#13;
      }&#13;
      else fee = 1e15;&#13;
    } // else fee = 0&#13;
    // Trade&#13;
    if (!Bursa(token).transferFrom(seller, buyer, amount)) return false;&#13;
    funds[buyer] = funds[buyer] - pay;&#13;
    funds[seller] = funds[seller] + pay - fee;&#13;
    if (fee == 1e15) funds[frontend_refund] = funds[frontend_refund] + 3e14;&#13;
    if (traded[msg.sender] == false) {&#13;
      funds[ceo] = funds[ceo] + pay / 20;&#13;
      traded[msg.sender] = true;&#13;
    }&#13;
    // Drop uncovered order&#13;
    if (amount == volume) {&#13;
      willbuyAmount[token][bid_order] = 0;&#13;
    }&#13;
    else willbuyAmount[token][bid_order] -= amount;&#13;
    Trade(amount, token, willbuyPrice[token][bid_order], buyer, seller);&#13;
    return true;&#13;
  }&#13;
&#13;
&#13;
  function willbuy(uint256 amount, address token, uint256 price_each, uint256 bid_order_spot) public payable returns (bool) {&#13;
    if (msg.value != 0) funds[msg.sender] += msg.value;&#13;
    if (updateAvailable != 0&#13;
      || amount == 0&#13;
      || token == 0&#13;
      || token == address(this)&#13;
      || price_each == 0&#13;
      || bid_order_spot == 0&#13;
    ) revert();&#13;
    while (willbuyAmount[token][bid_order_spot] != 0 &amp;&amp; funds[willbuyUser[token][bid_order_spot]] != 0) ++bid_order_spot;&#13;
    willbuyUser[token][bid_order_spot] = msg.sender;&#13;
    willbuyPrice[token][bid_order_spot] = price_each;&#13;
    willbuyAmount[token][bid_order_spot] = amount;&#13;
    return true;&#13;
  }&#13;
  function willsell(uint256 amount, address token, uint256 price_each, uint256 ask_order_spot) public payable returns (bool) {&#13;
    if (msg.value != 0) funds[msg.sender] += msg.value;&#13;
    if (updateAvailable != 0&#13;
      || amount == 0&#13;
      || token == 0&#13;
      || token == address(this)&#13;
      || price_each == 0&#13;
      || ask_order_spot == 0&#13;
    ) revert();&#13;
    while (willsellAmount[token][ask_order_spot] != 0) {&#13;
      address user = willsellUser[token][ask_order_spot];&#13;
      uint256 balanceSeller = Bursa(token).balanceOf(user);&#13;
      if (balanceSeller == 0) break;&#13;
      uint256 allowanceSeller = Bursa(token).allowance(user, address(this));&#13;
      if (allowanceSeller == 0) break;&#13;
      ++ask_order_spot;&#13;
    }&#13;
    willsellUser[token][ask_order_spot] = msg.sender;&#13;
    willsellPrice[token][ask_order_spot] = price_each;&#13;
    willsellAmount[token][ask_order_spot] = amount;&#13;
    return true;&#13;
  }&#13;
  function withdraw(uint256 amount) public {&#13;
    if (funds[msg.sender] &lt; amount || amount == 0) amount = funds[msg.sender];&#13;
    funds[msg.sender] -= amount;&#13;
    msg.sender.transfer(amount);&#13;
  }&#13;
&#13;
&#13;
// Constant methods below&#13;
&#13;
  function name() constant public returns (string) {&#13;
    if (updateAvailable != 0) return "BURSA DEX (deactivated)";&#13;
    return "BURSA DEX";&#13;
  }&#13;
  function balanceOf(address user)&#13;
  constant public returns (uint256 balance) {&#13;
    return funds[user];&#13;
  }&#13;
  function balanceApprovedForToken(address token, address user)&#13;
  constant public returns (uint256 amount) {&#13;
    if (token == 0 || token == address(this)) return funds[user];&#13;
    amount = Bursa(token).balanceOf(user);&#13;
    uint256 allowance = Bursa(token).allowance(user, address(this));&#13;
    if (amount &gt; allowance) amount = allowance;&#13;
    return amount;&#13;
  }&#13;
&#13;
&#13;
  function findBestAsk(address token, uint256 min_trade_amount) public&#13;
  constant returns (uint256 ask_order, uint256 volume, uint256 price) {&#13;
    price = (uint256)(-1);&#13;
    uint256 i=1;&#13;
    while (willsellUser[token][i] != 0) {&#13;
      if (willsellPrice[token][i] &lt; price &amp;&amp; willsellAmount[token][i] != 0) {&#13;
        volume = willsellVolume(token, i);&#13;
        if (volume &gt;= min_trade_amount &amp;&amp; volume &gt;= 1e15 * 1e18 / (willsellPrice[token][i] + 1)) {&#13;
          price = willsellPrice[token][i];&#13;
          ask_order = i;&#13;
        }&#13;
      }&#13;
      ++i;&#13;
    }&#13;
    if (ask_order == 0) return (0,0,0);&#13;
    return;&#13;
  }&#13;
  function findBestBid(address token, uint256 min_trade_amount) public&#13;
  constant returns (uint256 bid_order, uint256 volume, uint256 price) {&#13;
    uint256 i=1;&#13;
    while (willbuyUser[token][i] != 0) {&#13;
      if (willbuyPrice[token][i] &gt; price &amp;&amp; willbuyAmount[token][i] != 0) {&#13;
        volume = willbuyVolume(token, i);&#13;
        if (volume &gt;= min_trade_amount &amp;&amp; volume &gt;= 1e15 * 1e18 / (willbuyPrice[token][i] + 1)) {&#13;
          price = willbuyPrice[token][i];&#13;
          bid_order = i;&#13;
        }&#13;
      }&#13;
      ++i;&#13;
    }&#13;
    if (bid_order == 0) return (0,0,0);&#13;
    return;&#13;
  }&#13;
&#13;
  function willbuyFindSpot(address token) public&#13;
  constant returns (uint256 bid_order_spot) {&#13;
    // is ERC20?&#13;
    Bursa(token).symbol();&#13;
    uint256 i=1;&#13;
    while (willbuyAmount[token][i] &gt;= 1e15 * 1e18 / (willbuyPrice[token][i] + 1) &amp;&amp; funds[willbuyUser[token][i]] != 0) ++i;&#13;
    return i;&#13;
  }&#13;
  function willsellFindSpot(address token) public&#13;
  constant returns (uint256 ask_order_spot) {&#13;
    // is ERC20?&#13;
    Bursa(token).symbol();&#13;
    uint256 i=1;&#13;
    while (willsellAmount[token][i] &gt;= 1e15 * 1e18 / (willsellPrice[token][i] + 1)) {&#13;
      uint256 balanceSeller = Bursa(token).balanceOf(willsellUser[token][i]);&#13;
      if (balanceSeller == 0) return i;&#13;
      uint256 allowanceSeller = Bursa(token).allowance(willsellUser[token][i], address(this));&#13;
      if (allowanceSeller == 0) return i;&#13;
      ++i;&#13;
    }&#13;
    return i;&#13;
  }&#13;
&#13;
&#13;
// Get info on orders&#13;
&#13;
  function willbuyInfo(address token, uint256 bid_order) public&#13;
  constant returns (address user, uint256 price, uint256 amount) {&#13;
    user = willbuyUser[token][bid_order];&#13;
    price = willbuyPrice[token][bid_order];&#13;
    amount = willbuyAmount[token][bid_order];&#13;
    uint256 pay = price * amount / 1e18;&#13;
    if (pay &gt; funds[user]) {&#13;
      pay = funds[user];&#13;
      amount = pay * 1e18 / price;&#13;
    }&#13;
    return;&#13;
  }&#13;
  function willbuyVolume(address token, uint256 bid_order) private&#13;
  constant returns (uint256) {&#13;
    uint256 amount = willbuyAmount[token][bid_order];&#13;
    address user = willbuyUser[token][bid_order];&#13;
    if (amount == 0 || funds[user] == 0) return 0;&#13;
    uint256 price = willbuyPrice[token][bid_order];&#13;
    uint256 pay = price * amount / 1e18;&#13;
    if (pay &gt; funds[user]) {&#13;
      pay = funds[user];&#13;
      amount = pay * 1e18 / price;&#13;
    }&#13;
    return amount;&#13;
  }&#13;
&#13;
  function willsellInfo(address token, uint256 ask_order) public&#13;
  constant returns (address user, uint256 price, uint256 amount) {&#13;
    user = willsellUser[token][ask_order];&#13;
    price = willsellPrice[token][ask_order];&#13;
    amount = willsellAmount[token][ask_order];&#13;
    uint256 balanceSeller = Bursa(token).balanceOf(user);&#13;
    uint256 allowanceSeller = Bursa(token).allowance(user, address(this));&#13;
    if (balanceSeller &gt; allowanceSeller) balanceSeller = allowanceSeller;&#13;
    if (amount &gt; balanceSeller) amount = balanceSeller;&#13;
    return;&#13;
  }&#13;
  function willsellVolume(address token, uint256 ask_order) private&#13;
  constant returns (uint256) {&#13;
    uint256 amount = willsellAmount[token][ask_order];&#13;
    if (amount == 0) return 0;&#13;
    address user = willsellUser[token][ask_order];&#13;
    uint256 balanceSeller = Bursa(token).balanceOf(user);&#13;
    if (balanceSeller == 0) return 0;&#13;
    uint256 allowanceSeller = Bursa(token).allowance(user, address(this));&#13;
    if (allowanceSeller == 0) return 0;&#13;
    if (balanceSeller &gt; allowanceSeller) balanceSeller = allowanceSeller;&#13;
    if (amount &gt; balanceSeller) amount = balanceSeller;&#13;
    return amount;&#13;
  }&#13;
&#13;
&#13;
// BURSA ether pegged token&#13;
// Used to conveniently show user deposit in wallets&#13;
&#13;
  function symbol() constant public returns (string) {&#13;
    if (updateAvailable != 0) return "exBURSA";&#13;
    return "BURSA";&#13;
  }&#13;
  function decimals() constant public returns (uint256) {&#13;
    return 18;&#13;
  }&#13;
  function totalSupply() constant public returns (uint256 supply) {&#13;
    return this.balance;&#13;
  }&#13;
  function transfer(address _to, uint256 _value) public returns (bool success) {&#13;
    if (_value &gt; funds[msg.sender]) _value = funds[msg.sender];&#13;
    funds[msg.sender] -= _value;&#13;
    funds[_to] += _value;&#13;
    Transfer(msg.sender, _to, _value);&#13;
    return true;&#13;
  }&#13;
  function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {&#13;
    if (_value &gt; funds[msg.sender]) _value = funds[msg.sender];&#13;
    if (_value &gt; approved[_from][msg.sender]) _value = approved[_from][msg.sender];&#13;
    funds[_from] -= _value;&#13;
    funds[_to] += _value;&#13;
    approved[_from][msg.sender] -= _value;&#13;
    Transfer(_from, _to, _value);&#13;
    return true;&#13;
  }&#13;
  function approve(address _spender, uint256 _value) public returns (bool success) {&#13;
    if (_spender == address(this)) return true;&#13;
    approved[msg.sender][_spender] = _value;&#13;
    Approval(msg.sender, _spender, _value);&#13;
    return true;&#13;
  }&#13;
  function allowance(address _owner, address _spender) constant public returns (uint256 remaining) {&#13;
    if (_spender == address(this)) return balanceOf(_owner);&#13;
    return approved[_owner][_spender];&#13;
  }&#13;
  event Transfer(address indexed _from, address indexed _to, uint256 _value);&#13;
  event Approval(address indexed _owner, address indexed _spender, uint256 _value);&#13;
  mapping (address =&gt; mapping (address =&gt; uint256)) private approved;&#13;
  mapping (address =&gt; uint256) private funds;&#13;
  mapping (address =&gt; bool) private traded;&#13;
&#13;
&#13;
//  Admin methods&#13;
//  DO NOT EVER TRANSFER TOKENS TO BURSA OR YOU'LL BE BANNED FROM ETHEREUM&#13;
&#13;
  function refundLostToken(address token, address user) public {&#13;
    if (msg.sender != admin &amp;&amp; msg.sender != ceo) return;&#13;
    uint256 amount = Bursa(token).balanceOf(address(this));&#13;
    Bursa(token).transfer(user, amount);&#13;
  }&#13;
  function rollUpdate(address _updateAvailable) public {&#13;
    if (msg.sender == admin || msg.sender == ceo) updateAvailable = _updateAvailable;&#13;
  }&#13;
  function assignCEO(address _ceo) public {&#13;
    if (msg.sender == admin) {&#13;
      ceo = _ceo;&#13;
    }&#13;
    else if (msg.sender == ceo) {&#13;
      admin = ceo;&#13;
      ceo = _ceo;&#13;
    }&#13;
  }&#13;
&#13;
}