pragma solidity ^0.4.18;

/**
 *
 * Version D
 * @author  Pratyush Bhatt <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="c984b0babda0aa84a6a7baa6a6a789b9bba6bda6a7a4a8a0a5e7aaa6a4">[emailÂ protected]</a>&gt;&#13;
 *&#13;
 * Overview:&#13;
 * This is an implimentation of a simple sale token. The tokens do not pay any dividends -- they only exist&#13;
 * as a database of purchasers. A limited number of tokens are created on-the-fly as funds are deposited into the&#13;
 * contract. All of the funds are tranferred to the beneficiary at the end of the token-sale.&#13;
 */&#13;
&#13;
pragma solidity ^0.4.18;&#13;
&#13;
/*&#13;
    Overflow protected math functions&#13;
*/&#13;
contract SafeMath {&#13;
    /**&#13;
        constructor&#13;
    */&#13;
    function SafeMath() public {&#13;
    }&#13;
&#13;
    /**&#13;
        @dev returns the sum of _x and _y, asserts if the calculation overflows&#13;
&#13;
        @param _x   value 1&#13;
        @param _y   value 2&#13;
&#13;
        @return sum&#13;
    */&#13;
    function safeAdd(uint256 _x, uint256 _y) pure internal returns (uint256) {&#13;
        uint256 z = _x + _y;&#13;
        assert(z &gt;= _x);&#13;
        return z;&#13;
    }&#13;
&#13;
    /**&#13;
        @dev returns the difference of _x minus _y, asserts if the subtraction results in a negative number&#13;
&#13;
        @param _x   minuend&#13;
        @param _y   subtrahend&#13;
&#13;
        @return difference&#13;
    */&#13;
    function safeSub(uint256 _x, uint256 _y) pure internal returns (uint256) {&#13;
        assert(_x &gt;= _y);&#13;
        return _x - _y;&#13;
    }&#13;
&#13;
    /**&#13;
        @dev returns the product of multiplying _x by _y, asserts if the calculation overflows&#13;
&#13;
        @param _x   factor 1&#13;
        @param _y   factor 2&#13;
&#13;
        @return product&#13;
    */&#13;
    function safeMul(uint256 _x, uint256 _y) pure internal returns (uint256) {&#13;
        uint256 z = _x * _y;&#13;
        assert(_x == 0 || z / _x == _y);&#13;
        return z;&#13;
    }&#13;
}&#13;
&#13;
pragma solidity ^0.4.18;&#13;
&#13;
// Token standard API&#13;
// https://github.com/ethereum/EIPs/issues/20&#13;
&#13;
contract iERC20Token {&#13;
  function totalSupply() public constant returns (uint supply);&#13;
  function balanceOf( address who ) public constant returns (uint value);&#13;
  function allowance( address owner, address spender ) public constant returns (uint remaining);&#13;
&#13;
  function transfer( address to, uint value) public returns (bool ok);&#13;
  function transferFrom( address from, address to, uint value) public returns (bool ok);&#13;
  function approve( address spender, uint value ) public returns (bool ok);&#13;
&#13;
  event Transfer( address indexed from, address indexed to, uint value);&#13;
  event Approval( address indexed owner, address indexed spender, uint value);&#13;
}&#13;
&#13;
contract SimpleSaleToken is iERC20Token, SafeMath {&#13;
&#13;
  event PaymentEvent(address indexed from, uint amount);&#13;
  event TransferEvent(address indexed from, address indexed to, uint amount);&#13;
  event ApprovalEvent(address indexed from, address indexed to, uint amount);&#13;
&#13;
  string  public symbol;&#13;
  string  public name;&#13;
  bool    public isLocked;&#13;
  uint    public decimals;&#13;
  uint    public tokenPrice;&#13;
  uint           tokenSupply;&#13;
  uint           tokensRemaining;&#13;
  uint    public contractSendGas = 100000;&#13;
  address public owner;&#13;
  address public beneficiary;&#13;
  mapping (address =&gt; uint) balances;&#13;
  mapping (address =&gt; mapping (address =&gt; uint)) approvals;  //transfer approvals, from -&gt; to&#13;
&#13;
&#13;
  modifier ownerOnly {&#13;
    require(msg.sender == owner);&#13;
    _;&#13;
  }&#13;
&#13;
  modifier unlockedOnly {&#13;
    require(!isLocked);&#13;
    _;&#13;
  }&#13;
&#13;
  modifier duringSale {&#13;
    require(tokenPrice != 0 &amp;&amp; tokensRemaining &gt; 0);&#13;
    _;&#13;
  }&#13;
&#13;
  //this is to protect from short-address attack. use this to verify size of args, especially when an address arg preceeds&#13;
  //a value arg. see: https://www.reddit.com/r/ethereum/comments/63s917/worrysome_bug_exploit_with_erc20_token/dfwmhc3/&#13;
  modifier onlyPayloadSize(uint size) {&#13;
    assert(msg.data.length &gt;= size + 4);&#13;
    _;&#13;
  }&#13;
&#13;
  //&#13;
  //constructor&#13;
  //&#13;
  function SimpleSaleToken() public {&#13;
    owner = msg.sender;&#13;
    beneficiary = msg.sender;&#13;
  }&#13;
&#13;
&#13;
  //&#13;
  // ERC-20&#13;
  //&#13;
&#13;
  function totalSupply() public constant returns (uint supply) {&#13;
    //if tokenSupply was not limited then we would use safeAdd...&#13;
    supply = tokenSupply + tokensRemaining;&#13;
  }&#13;
&#13;
  function transfer(address _to, uint _value) public onlyPayloadSize(2*32) returns (bool success) {&#13;
    //prevent wrap&#13;
    if (balances[msg.sender] &gt;= _value &amp;&amp; balances[_to] + _value &gt; balances[_to]) {&#13;
      balances[msg.sender] -= _value;&#13;
      balances[_to] += _value;&#13;
      TransferEvent(msg.sender, _to, _value);&#13;
      return true;&#13;
    } else {&#13;
      return false;&#13;
    }&#13;
  }&#13;
&#13;
&#13;
  function transferFrom(address _from, address _to, uint _value) onlyPayloadSize(3*32) public returns (bool success) {&#13;
    //prevent wrap:&#13;
    if (balances[_from] &gt;= _value &amp;&amp; approvals[_from][msg.sender] &gt;= _value &amp;&amp; balances[_to] + _value &gt; balances[_to]) {&#13;
      balances[_from] -= _value;&#13;
      balances[_to] += _value;&#13;
      approvals[_from][msg.sender] -= _value;&#13;
      TransferEvent(_from, _to, _value);&#13;
      return true;&#13;
    } else {&#13;
      return false;&#13;
    }&#13;
  }&#13;
&#13;
&#13;
  function balanceOf(address _owner) public constant returns (uint balance) {&#13;
    balance = balances[_owner];&#13;
  }&#13;
&#13;
&#13;
  function approve(address _spender, uint _value) public onlyPayloadSize(2*32) returns (bool success) {&#13;
    approvals[msg.sender][_spender] = _value;&#13;
    ApprovalEvent(msg.sender, _spender, _value);&#13;
    return true;&#13;
  }&#13;
&#13;
&#13;
  function allowance(address _owner, address _spender) public constant returns (uint remaining) {&#13;
    return approvals[_owner][_spender];&#13;
  }&#13;
&#13;
  //&#13;
  // END ERC20&#13;
  //&#13;
&#13;
&#13;
  //&#13;
  // default payable function.&#13;
  //&#13;
  function () public payable duringSale {&#13;
    uint _quantity = msg.value / tokenPrice;&#13;
    if (_quantity &gt; tokensRemaining)&#13;
       _quantity = tokensRemaining;&#13;
    require(_quantity &gt;= 1);&#13;
    uint _cost = safeMul(_quantity, tokenPrice);&#13;
    uint _refund = safeSub(msg.value, _cost);&#13;
    balances[msg.sender] = safeAdd(balances[msg.sender], _quantity);&#13;
    tokenSupply = safeAdd(tokenSupply, _quantity);&#13;
    tokensRemaining = safeSub(tokensRemaining, _quantity);&#13;
    if (_refund &gt; 0)&#13;
        msg.sender.transfer(_refund);&#13;
    PaymentEvent(msg.sender, msg.value);&#13;
  }&#13;
&#13;
  function setName(string _name, string _symbol) public ownerOnly {&#13;
    name = _name;&#13;
    symbol = _symbol;&#13;
  }&#13;
&#13;
&#13;
  //if decimals = 3, and you want 1 ETH/token, then pass in _tokenPrice = 0.001 * (wei / ether)&#13;
  function setBeneficiary(address _beneficiary, uint _decimals, uint _tokenPrice, uint _tokensRemaining) public ownerOnly unlockedOnly {&#13;
    beneficiary = _beneficiary;&#13;
    decimals = _decimals;&#13;
    tokenPrice = _tokenPrice;&#13;
    tokensRemaining = _tokensRemaining;&#13;
  }&#13;
&#13;
  function lock() public ownerOnly {&#13;
    require(beneficiary != 0 &amp;&amp; tokenPrice != 0);&#13;
    isLocked = true;&#13;
  }&#13;
&#13;
  function endSale() public ownerOnly {&#13;
    require(beneficiary != 0);&#13;
    //beneficiary is most likely a contract...&#13;
    if (!beneficiary.call.gas(contractSendGas).value(this.balance)())&#13;
      revert();&#13;
    tokensRemaining = 0;&#13;
  }&#13;
&#13;
  function tune(uint _contractSendGas) public ownerOnly {&#13;
    contractSendGas = _contractSendGas;&#13;
  }&#13;
&#13;
  //for debug&#13;
  //only available before the contract is locked&#13;
  function haraKiri() public ownerOnly unlockedOnly {&#13;
    selfdestruct(owner);&#13;
  }&#13;
&#13;
}