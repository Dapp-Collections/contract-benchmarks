pragma solidity ^0.4.18;
// -------------------------------------------------
// ethPoker.io EPX token - ERC20 token smart contract
// contact <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="0160656c686f41647569716e6a64732f686e">[emailÂ protected]</a> for queries&#13;
// Revision 20b&#13;
// Full test suite 20r passed&#13;
// -------------------------------------------------&#13;
// ERC Token Standard #20 interface:&#13;
// https://github.com/ethereum/EIPs/issues/20&#13;
// EPX contract sources:&#13;
// https://github.com/EthPokerIO/ethpokerIO&#13;
// ------------------------------------------------&#13;
// 2018 improvements:&#13;
// - added transferAnyERC20Token function to capture airdropped tokens&#13;
// - added revert() rejection of any Eth sent to the token address itself&#13;
// - additional gas optimisation performed (round 3)&#13;
// -------------------------------------------------&#13;
// Security reviews passed - cycle 20r&#13;
// Functional reviews passed - cycle 20r&#13;
// Final code revision and regression test cycle passed - cycle 20r&#13;
// -------------------------------------------------&#13;
&#13;
contract owned {&#13;
  address public owner;&#13;
&#13;
  function owned() internal {&#13;
    owner = msg.sender;&#13;
  }&#13;
  modifier onlyOwner {&#13;
    require(msg.sender == owner);&#13;
    _;&#13;
  }&#13;
}&#13;
&#13;
contract safeMath {&#13;
  function safeMul(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
    uint256 c = a * b;&#13;
    safeAssert(a == 0 || c / a == b);&#13;
    return c;&#13;
  }&#13;
&#13;
  function safeDiv(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
    safeAssert(b &gt; 0);&#13;
    uint256 c = a / b;&#13;
    safeAssert(a == b * c + a % b);&#13;
    return c;&#13;
  }&#13;
&#13;
  function safeSub(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
    safeAssert(b &lt;= a);&#13;
    return a - b;&#13;
  }&#13;
&#13;
  function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
    uint256 c = a + b;&#13;
    safeAssert(c&gt;=a &amp;&amp; c&gt;=b);&#13;
    return c;&#13;
  }&#13;
&#13;
  function safeAssert(bool assertion) internal pure {&#13;
    if (!assertion) revert();&#13;
  }&#13;
}&#13;
&#13;
contract ERC20Interface is owned, safeMath {&#13;
  function balanceOf(address _owner) public constant returns (uint256 balance);&#13;
  function transfer(address _to, uint256 _value) public returns (bool success);&#13;
  function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);&#13;
  function approve(address _spender, uint256 _value) public returns (bool success);&#13;
  function increaseApproval (address _spender, uint _addedValue) public returns (bool success);&#13;
  function decreaseApproval (address _spender, uint _subtractedValue) public returns (bool success);&#13;
  function allowance(address _owner, address _spender) public constant returns (uint256 remaining);&#13;
  event Buy(address indexed _sender, uint256 _eth, uint256 _EPX);&#13;
  event Transfer(address indexed _from, address indexed _to, uint256 _value);&#13;
  event Approval(address indexed _owner, address indexed _spender, uint256 _value);&#13;
}&#13;
&#13;
contract EPXToken is ERC20Interface {&#13;
  // token setup variables&#13;
  string  public constant name                  = "EthPoker.io EPX";&#13;
  string  public constant standard              = "EPX";&#13;
  string  public constant symbol                = "EPX";&#13;
  uint8   public constant decimals              = 4;                               // 4 decimals for practicality&#13;
  uint256 private constant totalSupply          = 2800000000000;                   // 280 000 000 (total supply of EPX tokens is 280,000,000) + 4 decimal points (2800000000000)&#13;
&#13;
  // token mappings&#13;
  mapping (address =&gt; uint256) balances;&#13;
  mapping (address =&gt; mapping (address =&gt; uint256)) allowed;&#13;
&#13;
  // ERC20 standard token possible events, matched to ICO and preSale contracts&#13;
  event Buy(address indexed _sender, uint256 _eth, uint256 _EPX);&#13;
  event Transfer(address indexed _from, address indexed _to, uint256 _value);&#13;
  event Approval(address indexed _owner, address indexed _spender, uint256 _value);&#13;
&#13;
  // ERC20 token balanceOf query function&#13;
  function balanceOf(address _owner) public constant returns (uint256 balance) {&#13;
    return balances[_owner];&#13;
  }&#13;
&#13;
  // token balance normalised for display (4 decimals removed)&#13;
  function EPXtokenSupply() public pure returns (uint256 totalEPXtokenCount) {&#13;
    return safeDiv(totalSupply,10000); // div by 1,000 for display normalisation (4 decimals)&#13;
  }&#13;
&#13;
  // ERC20 token transfer function with additional safety&#13;
  function transfer(address _to, uint256 _amount) public returns (bool success) {&#13;
    require(!(_to == 0x0));&#13;
    if ((balances[msg.sender] &gt;= _amount)&#13;
    &amp;&amp; (_amount &gt; 0)&#13;
    &amp;&amp; ((safeAdd(balances[_to],_amount) &gt; balances[_to]))) {&#13;
      balances[msg.sender] = safeSub(balances[msg.sender], _amount);&#13;
      balances[_to] = safeAdd(balances[_to], _amount);&#13;
      Transfer(msg.sender, _to, _amount);&#13;
      return true;&#13;
    } else {&#13;
      return false;&#13;
    }&#13;
  }&#13;
&#13;
  // ERC20 token transferFrom function with additional safety&#13;
  function transferFrom(&#13;
    address _from,&#13;
    address _to,&#13;
    uint256 _amount) public returns (bool success) {&#13;
    require(!(_to == 0x0));&#13;
    if ((balances[_from] &gt;= _amount)&#13;
    &amp;&amp; (allowed[_from][msg.sender] &gt;= _amount)&#13;
    &amp;&amp; (_amount &gt; 0)&#13;
    &amp;&amp; (safeAdd(balances[_to],_amount) &gt; balances[_to])) {&#13;
      balances[_from] = safeSub(balances[_from], _amount);&#13;
      allowed[_from][msg.sender] = safeSub((allowed[_from][msg.sender]),_amount);&#13;
      balances[_to] = safeAdd(balances[_to], _amount);&#13;
      Transfer(_from, _to, _amount);&#13;
      return true;&#13;
    } else {&#13;
      return false;&#13;
    }&#13;
  }&#13;
&#13;
  // ERC20 allow _spender to withdraw, multiple times, up to the _value amount&#13;
  function approve(address _spender, uint256 _amount) public returns (bool success) {&#13;
    //Fix for known double-spend https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM/edit#&#13;
    //Input must either set allow amount to 0, or have 0 already set, to workaround issue&#13;
    require((_amount == 0) || (allowed[msg.sender][_spender] == 0));&#13;
    require((_amount == 0) || (allowed[msg.sender][_spender] == 0));&#13;
    allowed[msg.sender][_spender] = _amount;&#13;
    Approval(msg.sender, _spender, _amount);&#13;
    return true;&#13;
  }&#13;
&#13;
  // ERC20 return allowance for given owner spender pair&#13;
  function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {&#13;
    return allowed[_owner][_spender];&#13;
  }&#13;
&#13;
  // ERC20 Updated increase approval process (to prevent double-spend attack but remove need to zero allowance before setting)&#13;
  function increaseApproval (address _spender, uint _addedValue) public returns (bool success) {&#13;
    allowed[msg.sender][_spender] = safeAdd(allowed[msg.sender][_spender],_addedValue);&#13;
&#13;
    // report new approval amount&#13;
    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);&#13;
    return true;&#13;
  }&#13;
&#13;
  // ERC20 Updated decrease approval process (to prevent double-spend attack but remove need to zero allowance before setting)&#13;
  function decreaseApproval (address _spender, uint _subtractedValue) public returns (bool success) {&#13;
    uint oldValue = allowed[msg.sender][_spender];&#13;
&#13;
    if (_subtractedValue &gt; oldValue) {&#13;
      allowed[msg.sender][_spender] = 0;&#13;
    } else {&#13;
      allowed[msg.sender][_spender] = safeSub(oldValue,_subtractedValue);&#13;
    }&#13;
&#13;
    // report new approval amount&#13;
    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);&#13;
    return true;&#13;
  }&#13;
&#13;
  // ERC20 Standard default function to assign initial supply variables and send balance to creator for distribution to EPX presale and ICO contract&#13;
  function EPXToken() public onlyOwner {&#13;
    balances[msg.sender] = totalSupply;&#13;
  }&#13;
&#13;
  // Reject sent ETH&#13;
  function () public payable {&#13;
    revert();&#13;
  }&#13;
&#13;
  // Contract owner able to transfer any airdropped or ERC20 tokens that are sent to the token contract address (mistakenly or as part of airdrop campaign)&#13;
  function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {&#13;
    return ERC20Interface(tokenAddress).transfer(owner, tokens);&#13;
  }&#13;
}