pragma solidity ^0.4.20;

// JohnVerToken Made By PinkCherry - <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="5c35322f3d323528252f373d321c3b313d3530723f3331">[email protected]</a>&#13;
// JohnVerToken Request Question - <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="d4bfbba6b1b5b7bbbdbaa7bbb8a1a0bdbbba94b3b9b5bdb8fab7bbb9">[email protected]</a>&#13;
&#13;
library SafeMath&#13;
{&#13;
  	function mul(uint256 a, uint256 b) internal pure returns (uint256)&#13;
    {&#13;
		uint256 c = a * b;&#13;
		assert(a == 0 || c / a == b);&#13;
&#13;
		return c;&#13;
  	}&#13;
&#13;
  	function div(uint256 a, uint256 b) internal pure returns (uint256)&#13;
	{&#13;
		uint256 c = a / b;&#13;
&#13;
		return c;&#13;
  	}&#13;
&#13;
  	function sub(uint256 a, uint256 b) internal pure returns (uint256)&#13;
	{&#13;
		assert(b &lt;= a);&#13;
&#13;
		return a - b;&#13;
  	}&#13;
&#13;
  	function add(uint256 a, uint256 b) internal pure returns (uint256)&#13;
	{&#13;
		uint256 c = a + b;&#13;
		assert(c &gt;= a);&#13;
&#13;
		return c;&#13;
  	}&#13;
}&#13;
&#13;
&#13;
contract OwnerHelper&#13;
{&#13;
  	address public owner;&#13;
&#13;
  	event OwnerTransferPropose(address indexed _from, address indexed _to);&#13;
&#13;
  	modifier onlyOwner&#13;
	{&#13;
		require(msg.sender == owner);&#13;
		_;&#13;
  	}&#13;
&#13;
  	function OwnerHelper() public&#13;
	{&#13;
		owner = msg.sender;&#13;
  	}&#13;
&#13;
  	function transferOwnership(address _to) onlyOwner public&#13;
	{&#13;
        require(_to != owner);&#13;
		require(_to != address(0x0));&#13;
		owner = _to;&#13;
		OwnerTransferPropose(owner, _to);&#13;
  	}&#13;
&#13;
}&#13;
&#13;
&#13;
contract ERC20Interface&#13;
{&#13;
  	event Transfer(address indexed _from, address indexed _to, uint _value);&#13;
  	event Approval(address indexed _owner, address indexed _spender, uint _value);&#13;
&#13;
  	function totalSupply() public constant returns (uint);&#13;
  	function balanceOf(address _owner) public constant returns (uint balance);&#13;
  	function transfer(address _to, uint _value) public returns (bool success);&#13;
  	function transferFrom(address _from, address _to, uint _value) public returns (bool success);&#13;
  	function approve(address _spender, uint _value) public returns (bool success);&#13;
  	function allowance(address _owner, address _spender) public constant returns (uint remaining);&#13;
}&#13;
&#13;
&#13;
contract ERC20Token is ERC20Interface, OwnerHelper&#13;
{&#13;
  	using SafeMath for uint;&#13;
&#13;
  	uint public tokensIssuedTotal = 0;&#13;
  	address public constant burnAddress = 0;&#13;
&#13;
  	mapping(address =&gt; uint) balances;&#13;
  	mapping(address =&gt; mapping (address =&gt; uint)) allowed;&#13;
&#13;
  	function totalSupply() public constant returns (uint)&#13;
	{&#13;
		return tokensIssuedTotal;&#13;
  	}&#13;
&#13;
  	function balanceOf(address _owner) public constant returns (uint balance)&#13;
	{&#13;
		return balances[_owner];&#13;
  	}&#13;
&#13;
	function transfer(address _to, uint _amount) public returns (bool success)&#13;
	{&#13;
		require( balances[msg.sender] &gt;= _amount );&#13;
&#13;
	    balances[msg.sender] = balances[msg.sender].sub(_amount);&#13;
		balances[_to]        = balances[_to].add(_amount);&#13;
&#13;
		Transfer(msg.sender, _to, _amount);&#13;
    &#13;
		return true;&#13;
  	}&#13;
&#13;
  	function approve(address _spender, uint _amount) public returns (bool success)&#13;
	{&#13;
		require ( balances[msg.sender] &gt;= _amount );&#13;
&#13;
		allowed[msg.sender][_spender] = _amount;&#13;
    		&#13;
		Approval(msg.sender, _spender, _amount);&#13;
&#13;
		return true;&#13;
	}&#13;
&#13;
  	function transferFrom(address _from, address _to, uint _amount) public returns (bool success)&#13;
	{&#13;
		require( balances[_from] &gt;= _amount );&#13;
		require( allowed[_from][msg.sender] &gt;= _amount );&#13;
		balances[_from]            = balances[_from].sub(_amount);&#13;
		allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);&#13;
		balances[_to]              = balances[_to].add(_amount);&#13;
&#13;
		Transfer(_from, _to, _amount);&#13;
		return true;&#13;
  	}&#13;
&#13;
  	function allowance(address _owner, address _spender) public constant returns (uint remaining)&#13;
	{&#13;
		return allowed[_owner][_spender];&#13;
  	}&#13;
}&#13;
&#13;
contract JohnVerToken is ERC20Token&#13;
{&#13;
	uint constant E18 = 10**18;&#13;
&#13;
  	string public constant name 	= "JohnVerToken";&#13;
  	string public constant symbol 	= "JVT";&#13;
  	uint public constant decimals 	= 18;&#13;
&#13;
	address public wallet;&#13;
	address public adminWallet;&#13;
&#13;
	uint public constant totalTokenCap   = 7600000000 * E18;&#13;
	uint public constant icoTokenCap     = 4006662000 * E18;&#13;
	uint public constant mktTokenCap     = 3593338000 * E18;&#13;
&#13;
	uint public tokenPerEth = 3000000 * E18;&#13;
&#13;
	uint public constant privateSaleBonus	 = 50;&#13;
	uint public constant preSaleFirstBonus	 = 20;&#13;
	uint public constant preSaleSecondBonus  = 15;&#13;
	uint public constant mainSaleBonus  = 0;&#13;
	&#13;
  	uint public constant privateSaleEtherCap = 100 ether;&#13;
  	uint public constant preSaleFirstEtherCap = 200 ether;&#13;
  	uint public constant preSaleSecondEtherCap = 200 ether;&#13;
  	uint public constant mainSaleEtherCap = 7 ether;&#13;
  	&#13;
  	uint public constant dayToMinusToken = 3000 * E18;&#13;
	uint public constant dayToDate = 86400;&#13;
&#13;
  	uint public constant privateSaleStartDate = 1519344000; // 2018-02-23 00:00 UTC&#13;
  	uint public constant privateSaleEndDate   = 1519862400; // 2018-03-01 00:00 UTC&#13;
&#13;
  	uint public constant preSaleFirstStartDate = 1520208000; // 2018-03-05 00:00 UTC&#13;
  	uint public constant preSaleFirstEndDate   = 1520726400; // 2018-03-11 00:00 UTC&#13;
&#13;
  	uint public constant preSaleSecondStartDate = 1521158400; // 2018-03-16 00:00 UTC&#13;
  	uint public constant preSaleSecondEndDate   = 1521676800; // 2018-03-22 00:00 UTC&#13;
&#13;
  	uint public constant mainSaleStartDate = 1522022400; // 2018-03-26 00:00 UTC&#13;
  	uint public constant mainSaleEndDate   = 1531353600; // 2018-07-11 00:00 UTC&#13;
&#13;
	uint public constant privateSaleMinEth  = 3 ether / 10; // 0.3 Ether&#13;
	uint public constant preSaleMinEth      = 2 ether / 10; // 0.2 Ether&#13;
	uint public constant mainSaleMinEth     = 1 ether / 10; // 0.1 Ether&#13;
&#13;
  	uint public icoEtherReceivedTotal = 0;&#13;
  	uint public icoEtherReceivedPrivateSale = 0;&#13;
  	uint public icoEtherReceivedPreFirstSale = 0;&#13;
  	uint public icoEtherReceivedPreSecondSale = 0;&#13;
  	uint public icoEtherReceivedMainSale = 0;&#13;
	uint public icoEtherReceivedMainSaleDay = 0;&#13;
	&#13;
	uint public tokenIssuedToday = 0;&#13;
	&#13;
    uint public tokenIssuedTotal        = 0;&#13;
  	uint public tokenIssuedPrivateIco   = 0;&#13;
  	uint public tokenIssuedPreFirstIco  = 0;&#13;
  	uint public tokenIssuedPreSecondIco = 0;&#13;
  	uint public tokenIssuedMainSaleIco  = 0;&#13;
  	uint public tokenIssuedMkt          = 0;&#13;
	uint public tokenIssuedAirDrop      = 0;&#13;
	uint public tokenIssuedLockUp       = 0;&#13;
&#13;
  	mapping(address =&gt; uint) public icoEtherContributed;&#13;
  	mapping(address =&gt; uint) public icoTokenReceived;&#13;
  	mapping(address =&gt; bool) public refundClaimed;&#13;
  	&#13;
 	event WalletChange(address _newWallet);&#13;
  	event AdminWalletChange(address _newAdminWallet);&#13;
  	event TokenMinted(address indexed _owner, uint _tokens, uint _balance);&#13;
  	event TokenAirDroped(address indexed _owner, uint _tokens, uint _balance);&#13;
  	event TokenIssued(address indexed _owner, uint _tokens, uint _balance, uint _etherContributed);&#13;
  	event Refund(address indexed _owner, uint _amount, uint _tokens);&#13;
  	event LockRemove(address indexed _participant);&#13;
	event WithDraw(address indexed _to, uint _amount);&#13;
	event OwnerReclaim(address indexed _from, address indexed _owner, uint _amount);&#13;
&#13;
  	function JohnVerToken() public&#13;
	{&#13;
		require( icoTokenCap + mktTokenCap == totalTokenCap );&#13;
		wallet = owner;&#13;
		adminWallet = owner;&#13;
  	}&#13;
&#13;
  	function () payable public&#13;
	{&#13;
    	buyToken();&#13;
  	}&#13;
  	&#13;
  	function atNow() public constant returns (uint)&#13;
	{&#13;
		return now;&#13;
  	}&#13;
&#13;
  	function buyToken() private&#13;
	{&#13;
		uint nowTime = atNow();&#13;
&#13;
		uint saleTime = 0; // 1 : privateSale, 2 : preSaleFirst, 3 : preSaleSecond, 4 : mainSale&#13;
&#13;
		uint minEth = 0;&#13;
		uint maxEth = 0;&#13;
&#13;
		uint tokens = 0;&#13;
		uint tokenBonus = 0;&#13;
		uint tokenMinusPerEther = 0;&#13;
		uint etherCap = 0;&#13;
&#13;
		uint mainSaleDay = 0;&#13;
		&#13;
		if (nowTime &gt; privateSaleStartDate &amp;&amp; nowTime &lt; privateSaleEndDate)&#13;
		{&#13;
			saleTime = 1;&#13;
			minEth = privateSaleMinEth;&#13;
			tokenBonus = privateSaleBonus;&#13;
			etherCap = privateSaleEtherCap;&#13;
			maxEth = privateSaleEtherCap;&#13;
		}&#13;
&#13;
		if (nowTime &gt; preSaleFirstStartDate &amp;&amp; nowTime &lt; preSaleFirstEndDate)&#13;
		{&#13;
			saleTime = 2;&#13;
			minEth = preSaleMinEth;&#13;
			tokenBonus = preSaleFirstBonus;&#13;
			etherCap = preSaleFirstEtherCap;&#13;
			maxEth = preSaleFirstEtherCap;&#13;
		}&#13;
&#13;
		if (nowTime &gt; preSaleSecondStartDate &amp;&amp; nowTime &lt; preSaleSecondEndDate)&#13;
		{&#13;
			saleTime = 3;&#13;
			minEth = preSaleMinEth;&#13;
			tokenBonus = preSaleSecondBonus;&#13;
			etherCap = preSaleSecondEtherCap;&#13;
			maxEth = preSaleSecondEtherCap;&#13;
		}&#13;
&#13;
		if (nowTime &gt; mainSaleStartDate &amp;&amp; nowTime &lt; mainSaleEndDate)&#13;
		{&#13;
			saleTime = 4;&#13;
			minEth = mainSaleMinEth;&#13;
			uint dateStartTime = 0;&#13;
			uint dateEndTime = 0;&#13;
			&#13;
		    for (uint i = 1; i &lt;= 108; i++)&#13;
		    {&#13;
		        dateStartTime = 0;&#13;
		        dateStartTime = dateStartTime.add(i.sub(1));&#13;
		        dateStartTime = dateStartTime.mul(dayToDate);&#13;
		        dateStartTime = dateStartTime.add(mainSaleStartDate);&#13;
		        &#13;
		        dateEndTime = 0;&#13;
		        dateEndTime = dateEndTime.add(i.sub(1));&#13;
		        dateEndTime = dateEndTime.mul(dayToDate);&#13;
		        dateEndTime = dateEndTime.add(mainSaleEndDate);&#13;
		        &#13;
  			    if (nowTime &gt; dateStartTime &amp;&amp; nowTime &lt; dateEndTime) &#13;
			    {&#13;
			    	mainSaleDay = i;&#13;
			    }&#13;
		    }&#13;
		    &#13;
		    require( mainSaleDay != 0 );&#13;
		    &#13;
		    etherCap = mainSaleEtherCap;&#13;
		    maxEth = mainSaleEtherCap;&#13;
		    tokenMinusPerEther = tokenMinusPerEther.add(dayToMinusToken);&#13;
		    tokenMinusPerEther = tokenMinusPerEther.mul(mainSaleDay.sub(1));&#13;
		}&#13;
		&#13;
		require( saleTime &gt;= 1 &amp;&amp; saleTime &lt;= 4 );&#13;
		require( msg.value &gt;= minEth );&#13;
		require( icoEtherContributed[msg.sender].add(msg.value) &lt;= maxEth );&#13;
&#13;
		tokens = tokenPerEth.mul(msg.value) / 1 ether;&#13;
		tokenMinusPerEther = tokenMinusPerEther.mul(msg.value) / 1 ether;&#13;
      	tokens = tokens.mul(100 + tokenBonus) / 100;&#13;
      	tokens = tokens.sub(tokenMinusPerEther);&#13;
&#13;
		if(saleTime == 1)&#13;
		{&#13;
		    require( icoEtherReceivedPrivateSale.add(msg.value) &lt;= etherCap );&#13;
    &#13;
		    icoEtherReceivedPrivateSale = icoEtherReceivedPrivateSale.add(msg.value);&#13;
		    tokenIssuedPrivateIco = tokenIssuedPrivateIco.add(tokens);&#13;
		}&#13;
		else if(saleTime == 2)&#13;
		{&#13;
		    require( icoEtherReceivedPreFirstSale.add(msg.value) &lt;= etherCap );&#13;
    &#13;
		    icoEtherReceivedPreFirstSale = icoEtherReceivedPreFirstSale.add(msg.value);&#13;
		    tokenIssuedPreFirstIco = tokenIssuedPreFirstIco.add(tokens);&#13;
		}&#13;
		else if(saleTime == 3)&#13;
		{&#13;
		    require( icoEtherReceivedPreSecondSale.add(msg.value) &lt;= etherCap );&#13;
    &#13;
		    icoEtherReceivedPreSecondSale = icoEtherReceivedPreSecondSale.add(msg.value);&#13;
		    tokenIssuedPreSecondIco = tokenIssuedPreSecondIco.add(tokens);&#13;
		}&#13;
		else if(saleTime == 4)&#13;
		{&#13;
		    require( msg.value &lt;= etherCap );&#13;
		    &#13;
		    if(tokenIssuedToday &lt; mainSaleDay)&#13;
		    {&#13;
		        tokenIssuedToday = mainSaleDay;&#13;
		        icoEtherReceivedMainSaleDay = 0;&#13;
		    }&#13;
		    &#13;
		    require( icoEtherReceivedMainSaleDay.add(msg.value) &lt;= etherCap );&#13;
    &#13;
		    icoEtherReceivedMainSale = icoEtherReceivedMainSale.add(msg.value);&#13;
		    icoEtherReceivedMainSaleDay = icoEtherReceivedMainSaleDay.add(msg.value);&#13;
		    tokenIssuedMainSaleIco = tokenIssuedMainSaleIco.add(tokens);&#13;
		}&#13;
		&#13;
		balances[msg.sender]         = balances[msg.sender].add(tokens);&#13;
	    icoTokenReceived[msg.sender] = icoTokenReceived[msg.sender].add(tokens);&#13;
		tokensIssuedTotal            = tokensIssuedTotal.add(tokens);&#13;
		icoEtherContributed[msg.sender] = icoEtherContributed[msg.sender].add(msg.value);&#13;
    &#13;
		Transfer(0x0, msg.sender, tokens);&#13;
		TokenIssued(msg.sender, tokens, balances[msg.sender], msg.value);&#13;
&#13;
		wallet.transfer(this.balance);&#13;
  	}&#13;
&#13;
 	function isTransferable() public constant returns (bool transferable)&#13;
	{&#13;
		if ( atNow() &lt; preSaleSecondEndDate )&#13;
		{&#13;
			return false;&#13;
		}&#13;
&#13;
		return true;&#13;
  	}&#13;
&#13;
  	function changeWallet(address _wallet) onlyOwner public&#13;
	{&#13;
    		require( _wallet != address(0x0) );&#13;
    		wallet = _wallet;&#13;
    		WalletChange(wallet);&#13;
  	}&#13;
&#13;
  	function changeAdminWallet(address _wallet) onlyOwner public&#13;
	{&#13;
    		require( _wallet != address(0x0) );&#13;
    		adminWallet = _wallet;&#13;
    		AdminWalletChange(adminWallet);&#13;
  	}&#13;
&#13;
  	function mintMarketing(address _participant) onlyOwner public&#13;
	{&#13;
		uint tokens = mktTokenCap.sub(tokenIssuedAirDrop);&#13;
		&#13;
		balances[_participant] = balances[_participant].add(tokens);&#13;
		&#13;
		tokenIssuedMkt   = tokenIssuedMkt.add(tokens);&#13;
		tokenIssuedTotal = tokenIssuedTotal.add(tokens);&#13;
		&#13;
		Transfer(0x0, _participant, tokens);&#13;
		TokenMinted(_participant, tokens, balances[_participant]);&#13;
  	}&#13;
&#13;
  	function mintLockUpTokens(address _participant) onlyOwner public&#13;
	{&#13;
		require ( atNow() &gt;= mainSaleEndDate );&#13;
		&#13;
		uint tokens = totalTokenCap.sub(tokenIssuedTotal);&#13;
		&#13;
		balances[_participant] = balances[_participant].add(tokens);&#13;
		&#13;
		tokenIssuedLockUp = tokenIssuedLockUp.add(tokens);&#13;
		tokenIssuedTotal = tokenIssuedTotal.add(tokens);&#13;
		&#13;
		Transfer(0x0, _participant, tokens);&#13;
		TokenMinted(_participant, tokens, balances[_participant]);&#13;
  	}&#13;
&#13;
  	function airDropOne(address _address, uint _amount) onlyOwner public&#13;
  	{&#13;
  	    uint tokens = _amount * E18;&#13;
		       &#13;
		balances[_address] = balances[_address].add(tokens);&#13;
		&#13;
		tokenIssuedAirDrop = tokenIssuedAirDrop.add(tokens);&#13;
        tokenIssuedTotal = tokenIssuedTotal.add(tokens);&#13;
		&#13;
        Transfer(0x0, _address, tokens);&#13;
        TokenAirDroped(_address, tokens, balances[_address]);&#13;
  	}&#13;
&#13;
  	function airDropMultiple(address[] _addresses, uint[] _amounts) onlyOwner public&#13;
  	{&#13;
		require( _addresses.length == _amounts.length );&#13;
		&#13;
  	    uint tokens = 0;&#13;
  	    &#13;
		for (uint i = 0; i &lt; _addresses.length; i++)&#13;
		{&#13;
		        tokens = _amounts[i] * E18;&#13;
				&#13;
		        balances[_addresses[i]] = balances[_addresses[i]].add(tokens);&#13;
		&#13;
				tokenIssuedAirDrop = tokenIssuedAirDrop.add(tokens);&#13;
		        tokenIssuedTotal = tokenIssuedTotal.add(tokens);&#13;
		&#13;
		        Transfer(0x0, _addresses[i], tokens);&#13;
		        TokenAirDroped(_addresses[i], tokens, balances[_addresses[i]]);&#13;
		}&#13;
  	}&#13;
&#13;
  	function airDropMultipleSame(address[] _addresses, uint _amount) onlyOwner public&#13;
  	{&#13;
  	    uint tokens = _amount * E18;&#13;
  	    &#13;
		for (uint i = 0; i &lt; _addresses.length; i++)&#13;
		{&#13;
		        balances[_addresses[i]] = balances[_addresses[i]].add(tokens);&#13;
		&#13;
				tokenIssuedAirDrop = tokenIssuedAirDrop.add(tokens);&#13;
		        tokenIssuedTotal = tokenIssuedTotal.add(tokens);&#13;
		&#13;
		        Transfer(0x0, _addresses[i], tokens);&#13;
		        TokenAirDroped(_addresses[i], tokens, balances[_addresses[i]]);&#13;
		}&#13;
  	}&#13;
  	&#13;
  	function ownerWithdraw() external onlyOwner&#13;
	{&#13;
		uint amount = this.balance;&#13;
		wallet.transfer(amount);&#13;
		WithDraw(msg.sender, amount);&#13;
  	}&#13;
  	&#13;
  	function transferAnyERC20Token(address tokenAddress, uint amount) onlyOwner public returns (bool success)&#13;
	{&#13;
  		return ERC20Interface(tokenAddress).transfer(owner, amount);&#13;
  	}&#13;
  	&#13;
  	function transfer(address _to, uint _amount) public returns (bool success)&#13;
	{&#13;
		require( isTransferable() );&#13;
		&#13;
		return super.transfer(_to, _amount);&#13;
  	}&#13;
  	&#13;
  	function transferFrom(address _from, address _to, uint _amount) public returns (bool success)&#13;
	{&#13;
		require( isTransferable() );&#13;
		&#13;
		return super.transferFrom(_from, _to, _amount);&#13;
  	}&#13;
&#13;
  	function transferMultiple(address[] _addresses, uint[] _amounts) external&#13;
  	{&#13;
		require( isTransferable() );&#13;
		require( _addresses.length == _amounts.length );&#13;
		&#13;
		for (uint i = 0; i &lt; _addresses.length; i++)&#13;
		{&#13;
			super.transfer(_addresses[i], _amounts[i]);&#13;
		}&#13;
  	}&#13;
&#13;
  	function reclaimFunds() external&#13;
	{&#13;
		uint tokens;&#13;
		uint amount;&#13;
&#13;
		require( atNow() &gt; preSaleSecondEndDate );&#13;
		require( !refundClaimed[msg.sender] );&#13;
		require( icoEtherContributed[msg.sender] &gt; 0 );&#13;
&#13;
		tokens = icoTokenReceived[msg.sender];&#13;
		amount = icoEtherContributed[msg.sender];&#13;
&#13;
		balances[msg.sender] = balances[msg.sender].sub(tokens);&#13;
		tokensIssuedTotal    = tokensIssuedTotal.sub(tokens);&#13;
&#13;
		refundClaimed[msg.sender] = true;&#13;
&#13;
		msg.sender.transfer(amount);&#13;
&#13;
		Transfer(msg.sender, 0x0, tokens);&#13;
		Refund(msg.sender, amount, tokens);&#13;
  	}&#13;
  	&#13;
    function transferToOwner(address _from) onlyOwner public&#13;
    {&#13;
        uint amount = balanceOf(_from);&#13;
        &#13;
        balances[_from] = balances[_from].sub(amount);&#13;
        balances[owner] = balances[owner].add(amount);&#13;
        &#13;
        Transfer(_from, owner, amount);&#13;
        OwnerReclaim(_from, owner, amount);&#13;
    }&#13;
}