pragma solidity ^0.4.19;

// Hedgely - The Ethereum Inverted Market
// <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="3a485b5e5b57554959527a5d575b535614595557">[emailÂ protected]</a>&#13;
// Contract based investment game&#13;
&#13;
/**&#13;
 * @title Ownable&#13;
 * @dev The Ownable contract has an owner address, and provides basic authorization control&#13;
 * functions, this simplifies the implementation of "user permissions".&#13;
 */&#13;
contract Ownable {&#13;
&#13;
  address public owner;&#13;
&#13;
  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);&#13;
&#13;
&#13;
  /**&#13;
   * @dev The Ownable constructor sets the original `owner` of the contract to the sender&#13;
   * account.&#13;
   */&#13;
  function Ownable() public {&#13;
    owner = msg.sender;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Throws if called by any account other than the owner.&#13;
   */&#13;
  modifier onlyOwner() {&#13;
    require(msg.sender == owner);&#13;
    _;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Allows the current owner to transfer control of the contract to a newOwner.&#13;
   * @param newOwner The address to transfer ownership to.&#13;
   */&#13;
  function transferOwnership(address newOwner) public onlyOwner {&#13;
    require(newOwner != address(0));&#13;
    OwnershipTransferred(owner, newOwner);&#13;
    owner = newOwner;&#13;
  }&#13;
&#13;
}&#13;
&#13;
&#13;
&#13;
/**&#13;
 * @title Syndicate&#13;
 * @dev Syndicated profit sharing - for early adopters&#13;
 * Shares are not transferable -&#13;
 */&#13;
contract Syndicate is Ownable{&#13;
&#13;
    uint256 public totalSyndicateShares = 20000;&#13;
    uint256 public availableEarlyPlayerShares = 5000;&#13;
    uint256 public availableBuyInShares = 5000;&#13;
    uint256 public minimumBuyIn = 10;&#13;
    uint256 public buyInSharePrice = 500000000000000; // wei = 0.0005 ether&#13;
    uint256 public shareCycleSessionSize = 1000; // number of sessions in a share cycle&#13;
    uint256 public shareCycleIndex = 0; // current position in share cycle&#13;
    uint256 public currentSyndicateValue = 0; // total value of syndicate to be divided among members&#13;
    uint256 public numberSyndicateMembers = 0;&#13;
    uint256 public syndicatePrecision = 1000000000000000;&#13;
&#13;
    struct member {&#13;
        uint256 numShares;&#13;
        uint256 profitShare;&#13;
     }&#13;
&#13;
    address[] private syndicateMembers;&#13;
    mapping(address =&gt; member ) private members;&#13;
&#13;
    event ProfitShare(&#13;
          uint256 _currentSyndicateValue,&#13;
          uint256 _numberSyndicateMembers,&#13;
          uint256 _totalOwnedShares,&#13;
          uint256 _profitPerShare&#13;
    );&#13;
&#13;
    function Syndicate() public {&#13;
        members[msg.sender].numShares = 10000; // owner portion&#13;
        members[msg.sender].profitShare = 0;&#13;
        numberSyndicateMembers = 1;&#13;
        syndicateMembers.push(msg.sender);&#13;
    }&#13;
&#13;
    // initiates a dividend of necessary, sends&#13;
    function claimProfit() public {&#13;
      if (members[msg.sender].numShares==0) revert(); // only syndicate members.&#13;
      uint256 profitShare = members[msg.sender].profitShare;&#13;
      if (profitShare&gt;0){&#13;
        members[msg.sender].profitShare = 0;&#13;
        msg.sender.transfer(profitShare);&#13;
      }&#13;
    }&#13;
&#13;
    // distribute profit amonge syndicate members on a percentage share basis&#13;
    function distributeProfit() internal {&#13;
&#13;
      uint256 totalOwnedShares = totalSyndicateShares-(availableEarlyPlayerShares+availableBuyInShares);&#13;
      uint256 profitPerShare = SafeMath.div(currentSyndicateValue,totalOwnedShares);&#13;
&#13;
      // foreach member , calculate their profitshare&#13;
      for(uint i = 0; i&lt; numberSyndicateMembers; i++)&#13;
      {&#13;
        // do += so that acrues across share cycles.&#13;
        members[syndicateMembers[i]].profitShare+=SafeMath.mul(members[syndicateMembers[i]].numShares,profitPerShare);&#13;
      }&#13;
&#13;
      // emit a profit share event&#13;
      ProfitShare(currentSyndicateValue, numberSyndicateMembers, totalOwnedShares , profitPerShare);&#13;
&#13;
      currentSyndicateValue=0; // all the profit has been divided up&#13;
      shareCycleIndex = 0; // restart the share cycle count.&#13;
    }&#13;
&#13;
    // allocate syndicate shares up to the limit.&#13;
    function allocateEarlyPlayerShare() internal {&#13;
        if (availableEarlyPlayerShares==0) return;&#13;
		    availableEarlyPlayerShares--;&#13;
       	addMember(); // possibly add this member to the syndicate&#13;
        members[msg.sender].numShares+=1;&#13;
&#13;
    }&#13;
&#13;
    // add new member of syndicate&#13;
    function addMember() internal {&#13;
    	 if (members[msg.sender].numShares == 0){&#13;
		          syndicateMembers.push(msg.sender);&#13;
		          numberSyndicateMembers++;&#13;
		    }&#13;
    }&#13;
&#13;
    // buy into syndicate&#13;
    function buyIntoSyndicate() public payable  {&#13;
    		if(msg.value==0 || availableBuyInShares==0) revert();&#13;
      		if(msg.value &lt; minimumBuyIn*buyInSharePrice) revert();&#13;
&#13;
     		uint256 value = (msg.value/syndicatePrecision)*syndicatePrecision; // ensure precision&#13;
		    uint256 allocation = value/buyInSharePrice;&#13;
&#13;
		    if (allocation &gt;= availableBuyInShares){&#13;
		        allocation = availableBuyInShares; // limit hit&#13;
		    }&#13;
		    availableBuyInShares-=allocation;&#13;
		    addMember(); // possibly add this member to the syndicate&#13;
	      members[msg.sender].numShares+=allocation;&#13;
&#13;
    }&#13;
&#13;
    // how many shares?&#13;
    function memberShareCount() public  view returns (uint256) {&#13;
        return members[msg.sender].numShares;&#13;
    }&#13;
&#13;
    // how much profit?&#13;
    function memberProfitShare() public  view returns (uint256) {&#13;
        return members[msg.sender].profitShare;&#13;
    }&#13;
&#13;
}&#13;
&#13;
&#13;
/**&#13;
 * Core Hedgely Contract&#13;
 */&#13;
contract Hedgely is Ownable, Syndicate {&#13;
&#13;
   // Array of players&#13;
   address[] private players;&#13;
   mapping(address =&gt; bool) private activePlayers;&#13;
   uint256 numPlayers = 0;&#13;
&#13;
   // map each player address to their portfolio of investments&#13;
   mapping(address =&gt; uint256 [10] ) private playerPortfolio;&#13;
&#13;
   uint256 public totalHedgelyWinnings;&#13;
   uint256 public totalHedgelyInvested;&#13;
&#13;
   uint256[10] private marketOptions;&#13;
&#13;
   // The total amount of Ether bet for this current market&#13;
   uint256 public totalInvested;&#13;
   // The amount of Ether used to see the market&#13;
   uint256 private seedInvestment;&#13;
&#13;
   // The total number of investments the users have made&#13;
   uint256 public numberOfInvestments;&#13;
&#13;
   // The number that won the last game&#13;
   uint256 public numberWinner;&#13;
&#13;
   // current session information&#13;
   uint256 public startingBlock;&#13;
   uint256 public endingBlock;&#13;
   uint256 public sessionBlockSize;&#13;
   uint256 public sessionNumber;&#13;
   uint256 public currentLowest;&#13;
   uint256 public currentLowestCount; // should count the number of currentLowest to prevent a tie&#13;
&#13;
   uint256 public precision = 1000000000000000; // rounding to this will keep it to 1 finney resolution&#13;
   uint256 public minimumStake = 1 finney;&#13;
&#13;
     event Invest(&#13;
           address _from,&#13;
           uint256 _option,&#13;
           uint256 _value,&#13;
           uint256[10] _marketOptions,&#13;
           uint _blockNumber&#13;
     );&#13;
&#13;
     event EndSession(&#13;
           uint256 _sessionNumber,&#13;
           uint256 _winningOption,&#13;
           uint256[10] _marketOptions,&#13;
           uint256 _blockNumber&#13;
     );&#13;
&#13;
     event StartSession(&#13;
           uint256 _sessionNumber,&#13;
           uint256 _sessionBlockSize,&#13;
           uint256[10] _marketOptions,&#13;
           uint256 _blockNumber&#13;
     );&#13;
&#13;
    bool locked;&#13;
    modifier noReentrancy() {&#13;
        require(!locked);&#13;
        locked = true;&#13;
        _;&#13;
        locked = false;&#13;
    }&#13;
&#13;
   function Hedgely() public {&#13;
     owner = msg.sender;&#13;
     sessionBlockSize = 100;&#13;
     sessionNumber = 0;&#13;
     totalHedgelyWinnings = 0;&#13;
     totalHedgelyInvested = 0;&#13;
     numPlayers = 0;&#13;
     resetMarket();&#13;
   }&#13;
&#13;
    // the full amount invested in each option&#13;
   function getMarketOptions() public constant returns (uint256[10])&#13;
    {&#13;
        return marketOptions;&#13;
    }&#13;
&#13;
    // each player can get their own portfolio&#13;
   function getPlayerPortfolio() public constant returns (uint256[10])&#13;
    {&#13;
        return playerPortfolio[msg.sender];&#13;
    }&#13;
&#13;
    // the number of investors this session&#13;
    function numberOfInvestors() public constant returns(uint count) {&#13;
        return numPlayers;&#13;
    }&#13;
&#13;
    // generate a random number between 1 and 20 to seed a symbol&#13;
    function rand() internal returns (uint64) {&#13;
      return random(19)+1;&#13;
    }&#13;
&#13;
    // pseudo random - but does that matter?&#13;
    uint64 _seed = 0;&#13;
    function random(uint64 upper) private returns (uint64 randomNumber) {&#13;
       _seed = uint64(keccak256(keccak256(block.blockhash(block.number), _seed), now));&#13;
       return _seed % upper;&#13;
     }&#13;
&#13;
    // resets the market conditions&#13;
   function resetMarket() internal {&#13;
&#13;
    sessionNumber ++;&#13;
    startingBlock = block.number;&#13;
    endingBlock = startingBlock + sessionBlockSize; // approximately every 5 minutes - can play with this&#13;
    numPlayers = 0;&#13;
&#13;
    // randomize the initial market values&#13;
    uint256 sumInvested = 0;&#13;
    for(uint i=0;i&lt;10;i++)&#13;
    {&#13;
        uint256 num =  rand();&#13;
        marketOptions[i] =num * precision; // wei&#13;
        sumInvested+=  marketOptions[i];&#13;
    }&#13;
&#13;
     playerPortfolio[this] = marketOptions;&#13;
     totalInvested =  sumInvested;&#13;
     seedInvestment = sumInvested;&#13;
     insertPlayer(this);&#13;
     numPlayers=1;&#13;
     numberOfInvestments = 10;&#13;
&#13;
     currentLowest = findCurrentLowest();&#13;
     StartSession(sessionNumber, sessionBlockSize, marketOptions , startingBlock);&#13;
&#13;
   }&#13;
&#13;
&#13;
    // utility to round to the game precision&#13;
    function roundIt(uint256 amount) internal constant returns (uint256)&#13;
    {&#13;
        // round down to correct preicision&#13;
        uint256 result = (amount/precision)*precision;&#13;
        return result;&#13;
    }&#13;
&#13;
    // main entry point for investors/players&#13;
    function invest(uint256 optionNumber) public payable noReentrancy {&#13;
&#13;
      // Check that the number is within the range (uints are always&gt;=0 anyway)&#13;
      assert(optionNumber &lt;= 9);&#13;
      uint256 amount = roundIt(msg.value); // round to precision&#13;
      assert(amount &gt;= minimumStake);&#13;
&#13;
      uint256 holding = playerPortfolio[msg.sender][optionNumber];&#13;
      holding = SafeMath.add(holding, amount);&#13;
      playerPortfolio[msg.sender][optionNumber] = holding;&#13;
&#13;
      marketOptions[optionNumber] = SafeMath.add(marketOptions[optionNumber],amount);&#13;
&#13;
      numberOfInvestments += 1;&#13;
      totalInvested += amount;&#13;
      totalHedgelyInvested += amount;&#13;
      if (!activePlayers[msg.sender]){&#13;
                    insertPlayer(msg.sender);&#13;
                    activePlayers[msg.sender]=true;&#13;
       }&#13;
&#13;
      Invest(msg.sender, optionNumber, amount, marketOptions, block.number);&#13;
&#13;
      // possibly allocate syndicate shares&#13;
      allocateEarlyPlayerShare(); // allocate a single share per investment for early adopters&#13;
&#13;
      currentLowest = findCurrentLowest();&#13;
      if (block.number &gt;= endingBlock &amp;&amp; currentLowestCount==1) distributeWinnings();&#13;
&#13;
    } // end invest&#13;
&#13;
&#13;
    // find lowest option sets currentLowestCount&gt;1 if there are more than 1 lowest&#13;
    function findCurrentLowest() internal returns (uint lowestOption) {&#13;
&#13;
      uint winner = 0;&#13;
      uint lowestTotal = marketOptions[0];&#13;
      currentLowestCount = 0;&#13;
      for(uint i=0;i&lt;10;i++)&#13;
      {&#13;
          if (marketOptions [i]&lt;lowestTotal){&#13;
              winner = i;&#13;
              lowestTotal = marketOptions [i];&#13;
              currentLowestCount = 0;&#13;
          }&#13;
         if (marketOptions [i]==lowestTotal){currentLowestCount+=1;}&#13;
      }&#13;
      return winner;&#13;
    }&#13;
&#13;
    // distribute winnings at the end of a session&#13;
    function distributeWinnings() internal {&#13;
&#13;
      if (currentLowestCount&gt;1){&#13;
      return; // cannot end session because there is no lowest.&#13;
      }&#13;
&#13;
      numberWinner = currentLowest;&#13;
&#13;
      // record the end of session&#13;
      EndSession(sessionNumber, numberWinner, marketOptions , block.number);&#13;
&#13;
      uint256 sessionWinnings = 0;&#13;
      for(uint j=1;j&lt;numPlayers;j++)&#13;
      {&#13;
      if (playerPortfolio[players[j]][numberWinner]&gt;0){&#13;
        uint256 winningAmount =  playerPortfolio[players[j]][numberWinner];&#13;
        uint256 winnings = SafeMath.mul(8,winningAmount); // eight times the invested amount.&#13;
        totalHedgelyWinnings+=winnings;&#13;
        sessionWinnings+=winnings;&#13;
        players[j].transfer(winnings); // don't throw here&#13;
      }&#13;
&#13;
      playerPortfolio[players[j]] = [0,0,0,0,0,0,0,0,0,0];&#13;
      activePlayers[players[j]]=false;&#13;
&#13;
      }&#13;
&#13;
      uint256 playerInvestments = totalInvested-seedInvestment;&#13;
&#13;
      if (sessionWinnings&gt;playerInvestments){&#13;
        uint256 loss = sessionWinnings-playerInvestments; // this is a loss&#13;
        if (currentSyndicateValue&gt;=loss){&#13;
          currentSyndicateValue-=loss;&#13;
        }else{&#13;
          currentSyndicateValue = 0;&#13;
        }&#13;
      }&#13;
&#13;
      if (playerInvestments&gt;sessionWinnings){&#13;
        currentSyndicateValue+=playerInvestments-sessionWinnings; // this is a gain&#13;
      }&#13;
&#13;
      // check if share cycle is complete and if required distribute profits&#13;
      shareCycleIndex+=1;&#13;
      if (shareCycleIndex &gt;= shareCycleSessionSize){&#13;
        distributeProfit();&#13;
      }&#13;
&#13;
      resetMarket();&#13;
    } // end distribute winnings&#13;
&#13;
&#13;
    // convenience to manage a growing array&#13;
    function insertPlayer(address value) internal {&#13;
        if(numPlayers == players.length) {&#13;
            players.length += 1;&#13;
        }&#13;
        players[numPlayers++] = value;&#13;
    }&#13;
&#13;
   // We might vary this at some point&#13;
    function setsessionBlockSize (uint256 blockCount) public onlyOwner {&#13;
        sessionBlockSize = blockCount;&#13;
    }&#13;
&#13;
    // ----- admin functions in event of an issue --&#13;
&#13;
    function withdraw(uint256 amount) public onlyOwner {&#13;
        require(amount&lt;=this.balance);&#13;
        if (amount==0){&#13;
            amount=this.balance;&#13;
        }&#13;
        owner.transfer(amount);&#13;
    }&#13;
&#13;
&#13;
   // In the event of catastrophe&#13;
    function kill()  public onlyOwner {&#13;
         if(msg.sender == owner)&#13;
            selfdestruct(owner);&#13;
    }&#13;
&#13;
    // donations, funding, replenish&#13;
     function() public payable {}&#13;
&#13;
&#13;
}&#13;
&#13;
/**&#13;
 * @title SafeMath&#13;
 * @dev Math operations with safety checks that throw on error&#13;
 */&#13;
library SafeMath {&#13;
&#13;
  /**&#13;
  * @dev Multiplies two numbers, throws on overflow.&#13;
  */&#13;
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
    if (a == 0) {&#13;
      return 0;&#13;
    }&#13;
    uint256 c = a * b;&#13;
    assert(c / a == b);&#13;
    return c;&#13;
  }&#13;
&#13;
  /**&#13;
  * @dev Integer division of two numbers, truncating the quotient.&#13;
  */&#13;
  function div(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
    // assert(b &gt; 0); // Solidity automatically throws when dividing by 0&#13;
    uint256 c = a / b;&#13;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold&#13;
    return c;&#13;
  }&#13;
&#13;
  /**&#13;
  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).&#13;
  */&#13;
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
    assert(b &lt;= a);&#13;
    return a - b;&#13;
  }&#13;
&#13;
  /**&#13;
  * @dev Adds two numbers, throws on overflow.&#13;
  */&#13;
  function add(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
    uint256 c = a + b;&#13;
    assert(c &gt;= a);&#13;
    return c;&#13;
  }&#13;
}