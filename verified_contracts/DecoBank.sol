/*

Copyright (c) 2017 Esperite Ltd. <<span class="__cf_email__" data-cfemail="2f434a484e436f4a5c5f4a5d465b4a014c40014155">[emailÂ protected]</span>&gt;&#13;
&#13;
THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES&#13;
WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF&#13;
MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR&#13;
ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES&#13;
WHATSOEVER RESULTING FROM LOSS OF USE, PROCUREMENT OF SUBSTITUTE GOODS OR&#13;
SERVICES, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE&#13;
OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR&#13;
PERFORMANCE OF THIS SOFTWARE.&#13;
&#13;
*/&#13;
&#13;
pragma solidity ^0.4.13;&#13;
&#13;
library SafeMath {&#13;
  function mul(uint256 a, uint256 b) internal constant returns (uint256) {&#13;
    uint256 c = a * b;&#13;
    assert(a == 0 || c / a == b);&#13;
    return c;&#13;
  }&#13;
&#13;
  function div(uint256 a, uint256 b) internal constant returns (uint256) {&#13;
    uint256 c = a / b;&#13;
    return c;&#13;
  }&#13;
&#13;
  function sub(uint256 a, uint256 b) internal constant returns (uint256) {&#13;
    assert(b &lt;= a);&#13;
    return a - b;&#13;
  }&#13;
&#13;
  function add(uint256 a, uint256 b) internal constant returns (uint256) {&#13;
    uint256 c = a + b;&#13;
    assert(c &gt;= a);&#13;
    return c;&#13;
  }&#13;
}&#13;
&#13;
contract ERC223ReceivingContract {&#13;
    function tokenFallback(address _from, uint256 _value, bytes _data) public;&#13;
}&#13;
&#13;
contract ERC20ERC223 {&#13;
  uint256 public totalSupply;&#13;
  function balanceOf(address _owner) public constant returns (uint256);&#13;
  function transfer(address _to, uint256 _value) public returns (bool);&#13;
  function transfer(address _to, uint256 _value, bytes _data) public returns (bool);&#13;
  function transferFrom(address _from, address _to, uint256 _value) public returns (bool);&#13;
  function approve(address _spender, uint256 _value) public returns (bool success);&#13;
  function allowance(address _owner, address _spender) public constant returns (uint256 remaining);&#13;
  &#13;
  event Transfer(address indexed _from, address indexed _to, uint256 indexed _value);&#13;
  event Transfer(address indexed _from, address indexed _to, uint256 indexed _value, bytes _data);&#13;
  event Approval(address indexed _owner, address indexed _spender, uint256 _value);&#13;
}&#13;
&#13;
contract Deco is ERC20ERC223 {&#13;
&#13;
  using SafeMath for uint256;&#13;
&#13;
  string public constant name = "Deco";&#13;
  string public constant symbol = "DEC";&#13;
  uint8 public constant decimals = 18;&#13;
  &#13;
  uint256 public constant totalSupply = 6*10**26; // 600,000,000. 000,000,000,000,000,000 units&#13;
    &#13;
  // Accounts&#13;
  &#13;
  mapping(address =&gt; Account) private accounts;&#13;
  &#13;
  struct Account {&#13;
    uint256 balance;&#13;
    mapping(address =&gt; uint256) allowed;&#13;
    mapping(address =&gt; bool) isAllowanceAuthorized;&#13;
  }  &#13;
  &#13;
  // Fix for the ERC20 short address attack.&#13;
  // http://vessenes.com/the-erc20-short-address-attack-explained/&#13;
  modifier onlyPayloadSize(uint256 size) {&#13;
    require(msg.data.length &gt;= size + 4);&#13;
     _;&#13;
  }&#13;
&#13;
  // Initialization&#13;
&#13;
  function Deco() {&#13;
    accounts[msg.sender].balance = totalSupply;&#13;
    Transfer(this, msg.sender, totalSupply);&#13;
  }&#13;
&#13;
  // Balance&#13;
&#13;
  function balanceOf(address _owner) constant returns (uint256) {&#13;
    return accounts[_owner].balance;&#13;
  }&#13;
&#13;
  // Transfers&#13;
&#13;
  function transfer(address _to, uint256 _value) onlyPayloadSize(2 * 32) returns (bool) {&#13;
    performTransfer(msg.sender, _to, _value, "");&#13;
    Transfer(msg.sender, _to, _value);&#13;
    return true;&#13;
  }&#13;
&#13;
  function transfer(address _to, uint256 _value, bytes _data) onlyPayloadSize(2 * 32) returns (bool) {&#13;
    performTransfer(msg.sender, _to, _value, _data);&#13;
    Transfer(msg.sender, _to, _value, _data);&#13;
    return true;&#13;
  }&#13;
&#13;
  function transferFrom(address _from, address _to, uint256 _value) onlyPayloadSize(3 * 32) returns (bool) {&#13;
    require(hasApproval(_from, msg.sender));&#13;
    uint256 _allowed = accounts[_from].allowed[msg.sender];    &#13;
    performTransfer(_from, _to, _value, "");    &#13;
    accounts[_from].allowed[msg.sender] = _allowed.sub(_value);&#13;
    Transfer(_from, _to, _value);&#13;
    return true;&#13;
  }&#13;
&#13;
  function performTransfer(address _from, address _to, uint256 _value, bytes _data) private returns (bool) {&#13;
    require(_to != 0x0);&#13;
    accounts[_from].balance = accounts[_from].balance.sub(_value);    &#13;
    accounts[_to].balance = accounts[_to].balance.add(_value);&#13;
    if (isContract(_to)) {&#13;
      ERC223ReceivingContract receiver = ERC223ReceivingContract(_to);&#13;
      receiver.tokenFallback(_from, _value, _data);&#13;
    }    &#13;
    return true;&#13;
  }&#13;
&#13;
  function isContract(address _to) private constant returns (bool) {&#13;
    uint256 codeLength;&#13;
    assembly {&#13;
      codeLength := extcodesize(_to)&#13;
    }&#13;
    return codeLength &gt; 0;&#13;
  }&#13;
&#13;
  // Approval &amp; Allowance&#13;
  &#13;
  function approve(address _spender, uint256 _value) returns (bool) {&#13;
    require(msg.sender != _spender);&#13;
    // https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729&#13;
    if ((_value != 0) &amp;&amp; (accounts[msg.sender].allowed[_spender] != 0)) {&#13;
      revert();&#13;
      return false;&#13;
    }&#13;
    accounts[msg.sender].allowed[_spender] = _value;&#13;
    accounts[msg.sender].isAllowanceAuthorized[_spender] = true;&#13;
    Approval(msg.sender, _spender, _value);&#13;
    return true;&#13;
  }&#13;
&#13;
  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {&#13;
    return accounts[_owner].allowed[_spender];&#13;
  }&#13;
&#13;
  function hasApproval(address _owner, address _spender) constant returns (bool) {        &#13;
    return accounts[_owner].isAllowanceAuthorized[_spender];&#13;
  }&#13;
&#13;
  function removeApproval(address _spender) {    &#13;
    delete(accounts[msg.sender].allowed[_spender]);&#13;
    accounts[msg.sender].isAllowanceAuthorized[_spender] = false;&#13;
  }&#13;
&#13;
}&#13;
&#13;
contract DecoBank {&#13;
  &#13;
  using SafeMath for uint256;&#13;
&#13;
  Deco public token;  &#13;
  &#13;
  address private crowdsaleWallet;&#13;
  address private decoReserveWallet;&#13;
  uint256 public weiRaised;&#13;
&#13;
  uint256 public constant totalSupplyUnits = 6*10**26;&#13;
  uint256 private constant MINIMUM_WEI = 10**16;&#13;
  uint256 private constant BASE = 10**18;&#13;
  uint256 public originalRate = 3000;&#13;
&#13;
  uint256 public crowdsaleDistributedUnits = 0;&#13;
  uint256 public issuerDistributedUnits = 0;&#13;
&#13;
  // Presale&#13;
  uint256 public presaleStartTime;&#13;
  uint256 public presaleEndTime;&#13;
  uint256 private presaleDiscount = 50;&#13;
  uint256 private presalePercentage = 5;&#13;
&#13;
  uint256 public issuerReservedMaximumPercentage = 5;&#13;
&#13;
  // Sale&#13;
  uint256 public saleStartTime;&#13;
  uint256 public saleEndTime;&#13;
  uint256 private saleDiscount = 25;&#13;
&#13;
  // Rewards&#13;
  uint256 public rewardDistributionStart;&#13;
  uint256 public rewardDistributedUnits = 0;  &#13;
&#13;
  // Contributors&#13;
  mapping(address =&gt; Contributor) private contributors;&#13;
&#13;
  struct Contributor {    &#13;
    uint256 contributedWei;&#13;
    uint256 decoUnits;&#13;
    uint256 rewardDistributedDecoUnits;&#13;
  }&#13;
&#13;
  uint256 public contributorsCount = 0;&#13;
&#13;
  // Events&#13;
  event TokenPurchase(address indexed beneficiary, uint256 value, uint256 amount);&#13;
  event RewardDistributed(address indexed beneficiary, uint256 amount);&#13;
  event RemainingRewardOwnershipChanged(address indexed from, address indexed to);  &#13;
&#13;
  address private contractCreator = msg.sender;&#13;
&#13;
  function DecoBank() {&#13;
    token = new Deco();&#13;
&#13;
    presaleStartTime = 1506816000; // Sunday, October 1, 2017 12:00:00 AM&#13;
    presaleEndTime = presaleStartTime + 30 days;&#13;
&#13;
    saleStartTime = presaleEndTime + 1 days;&#13;
    saleEndTime = saleStartTime + 180 days;&#13;
&#13;
    rewardDistributionStart = saleEndTime + 1 days;&#13;
&#13;
    crowdsaleWallet = 0xEaC4ff9Aa8342d8B5c59370Ac04a55367A788B30;&#13;
    decoReserveWallet = 0xDA01fDeEF573b5cC51D0Ddc2600F476aaC71A600;&#13;
  }&#13;
&#13;
  // Sale events&#13;
&#13;
  modifier validPurchase() {&#13;
    require(isValidPurchase());&#13;
    _;&#13;
  }&#13;
  &#13;
  function isValidPurchase() private returns (bool) {&#13;
    bool minimumContribution = msg.value &gt;= MINIMUM_WEI;&#13;
    return minimumContribution &amp;&amp; (presaleActive() || saleActive());&#13;
  }  &#13;
&#13;
  function() payable validPurchase {&#13;
    require(msg.sender != 0x0);&#13;
    buyTokens(msg.sender);&#13;
  }&#13;
&#13;
  function buyTokens(address beneficiary) private {    &#13;
    uint256 weiAmount = msg.value;    &#13;
    uint256 tokens = weiAmount.mul(currentRate());&#13;
    uint256 issuerReserveTokens = unitsForIssuerReserve(tokens);&#13;
    &#13;
    require(crowdsaleDistributedUnits.add(tokens).add(issuerReserveTokens) &lt;= totalSupplyUnits);&#13;
&#13;
    incrementContributorsCount(beneficiary);&#13;
&#13;
    contributors[beneficiary].decoUnits = contributors[beneficiary].decoUnits.add(tokens);&#13;
    contributors[beneficiary].contributedWei = contributors[beneficiary].contributedWei.add(weiAmount);&#13;
&#13;
    issuerDistributedUnits = issuerDistributedUnits.add(issuerReserveTokens);&#13;
    crowdsaleDistributedUnits = crowdsaleDistributedUnits.add(tokens).add(issuerReserveTokens);&#13;
    weiRaised = weiRaised.add(weiAmount);&#13;
            &#13;
    TokenPurchase(beneficiary, weiAmount, tokens);&#13;
    &#13;
    crowdsaleWallet.transfer(weiAmount);&#13;
    token.transfer(beneficiary, tokens);&#13;
    if (issuerReserveTokens != 0) {&#13;
      token.transfer(decoReserveWallet, issuerReserveTokens);&#13;
    }            &#13;
  }&#13;
&#13;
  function incrementContributorsCount(address _address) private {&#13;
    if (contributors[_address].contributedWei == 0) {&#13;
      contributorsCount = contributorsCount.add(1);&#13;
    }&#13;
  }&#13;
&#13;
  function contributedWei(address _address) constant public returns (uint256) {&#13;
    return contributors[_address].contributedWei;&#13;
  }&#13;
&#13;
  function distibutedDecoUnits(address _address) constant public returns (uint256) {&#13;
    return contributors[_address].decoUnits;&#13;
  }&#13;
&#13;
  function circulatingSupply() constant public returns (uint256) {&#13;
    return crowdsaleDistributedUnits.add(rewardDistributedUnits);&#13;
  }&#13;
&#13;
  function currentDiscountPercentage() public constant returns (uint256) {&#13;
    if (presaleStartTime &gt; now) { return presaleDiscount; }&#13;
    if (presaleActive()) { return presaleDiscount; }&#13;
    uint256 discountSub = saleStage().mul(5);&#13;
    uint256 discount = saleDiscount.sub(discountSub);&#13;
    return discount;&#13;
  }&#13;
&#13;
  function currentRate() public constant returns (uint256) {&#13;
    uint256 x = (BASE.mul(100).sub(currentDiscountPercentage().mul(BASE))).div(100);&#13;
    return originalRate.mul(BASE).div(x);&#13;
  }&#13;
&#13;
  // Presale&#13;
&#13;
  function presaleLimitUnits() public constant returns (uint256) {&#13;
    return totalSupplyUnits.div(100).mul(presalePercentage);&#13;
  }&#13;
&#13;
  function shouldEndPresale() private constant returns (bool) {&#13;
    if ((crowdsaleDistributedUnits.sub(issuerDistributedUnits) &gt;= presaleLimitUnits()) || (now &gt;= presaleEndTime)) {&#13;
      return true;&#13;
    } else {&#13;
      return false;&#13;
    }&#13;
  }&#13;
&#13;
  function presaleActive() public constant returns (bool) {&#13;
    bool inRange = now &gt;= presaleStartTime &amp;&amp; now &lt; presaleEndTime;&#13;
    return inRange &amp;&amp; shouldEndPresale() == false;&#13;
  }&#13;
&#13;
  // Sale&#13;
&#13;
  function unitsLimitForCurrentSaleStage() public constant returns (uint256) {&#13;
    return totalSupplyUnits.div(100).mul(currentMaximumSalePercentage());&#13;
  }&#13;
&#13;
  function maximumSaleLimitUnits() public constant returns (uint256) {&#13;
    return totalSupplyUnits.div(100).mul(50);&#13;
  }&#13;
&#13;
  function currentMaximumSalePercentage() public constant returns (uint256) {&#13;
    return saleStage().mul(8).add(10);&#13;
  }&#13;
&#13;
  function saleLimitReachedForCurrentStage() public constant returns (bool) {&#13;
    return (crowdsaleDistributedUnits.sub(issuerDistributedUnits) &gt;= unitsLimitForCurrentSaleStage());&#13;
  }&#13;
&#13;
  function currentSaleStage() constant public returns (uint256) {&#13;
    return saleStage().add(1);&#13;
  }&#13;
&#13;
  function saleStage() private returns (uint256) {&#13;
    uint256 delta = saleEndTime.sub(saleStartTime);&#13;
    uint256 stageStep = delta.div(6);&#13;
    int256 stageDelta = int256(now - saleStartTime);&#13;
    if ((stageDelta &lt;= 0) || (stageStep == 0)) {&#13;
      return 0;&#13;
    } else {&#13;
      uint256 reminder = uint256(stageDelta) % stageStep;&#13;
      uint256 dividableDelta = uint256(stageDelta).sub(reminder);&#13;
      uint256 stage = dividableDelta.div(stageStep);&#13;
      if (stage &lt;= 5) {&#13;
        return stage;&#13;
      } else {&#13;
        return 5;&#13;
      }&#13;
    }&#13;
  }&#13;
&#13;
  function saleActive() public constant returns (bool) {&#13;
    bool inRange = now &gt;= saleStartTime &amp;&amp; now &lt; saleEndTime;        &#13;
    return inRange &amp;&amp; saleLimitReachedForCurrentStage() == false;&#13;
  }&#13;
&#13;
  // Issuer Reserve&#13;
&#13;
  function unitsForIssuerReserve(uint256 _tokensForDistribution) private returns (uint256) {&#13;
    uint256 residue = maximumIssuerReservedUnits().sub(issuerDistributedUnits);&#13;
    uint256 toIssuer = _tokensForDistribution.div(100).mul(10);&#13;
    if (residue &gt; toIssuer) {&#13;
      return toIssuer;&#13;
    } else {&#13;
      return residue;&#13;
    }&#13;
  }&#13;
&#13;
  function maximumIssuerReservedUnits() public constant returns (uint256) {&#13;
    return totalSupplyUnits.div(100).mul(issuerReservedMaximumPercentage);&#13;
  }&#13;
&#13;
  // Reward distribution&#13;
&#13;
  modifier afterSale() {&#13;
    require(rewardDistributionStarted());&#13;
    _;&#13;
  }&#13;
&#13;
  function rewardDistributionStarted() public constant returns (bool) {&#13;
    return now &gt;= rewardDistributionStart;&#13;
  }&#13;
&#13;
  function requestReward() afterSale external {&#13;
    if ((msg.sender == contractCreator) &amp;&amp; (rewardDistributionEnded())) {&#13;
      sendNotDistributedUnits();&#13;
    } else {&#13;
      rewardDistribution(msg.sender);&#13;
    }    &#13;
  }&#13;
&#13;
  function rewardDistribution(address _address) private {&#13;
    require(contributors[_address].contributedWei &gt; 0);    &#13;
    uint256 reward = payableReward(_address);&#13;
    require(reward &gt; 0);&#13;
    sendReward(_address, reward);&#13;
  }&#13;
&#13;
  function sendNotDistributedUnits() private {&#13;
    require(msg.sender == contractCreator);&#13;
    uint256 balance = token.balanceOf(this);&#13;
    RewardDistributed(contractCreator, balance);&#13;
    sendReward(contractCreator, balance);&#13;
  }&#13;
&#13;
  function payableReward(address _address) afterSale constant public returns (uint256) {&#13;
    uint256 unitsLeft = totalUnitsLeft();&#13;
    if (unitsLeft &lt; 10**4) {&#13;
      return unitsLeft;&#13;
    }&#13;
    uint256 totalReward = contributorTotalReward(_address);&#13;
    uint256 paidBonus = contributors[_address].rewardDistributedDecoUnits;&#13;
    uint256 totalRewardLeft = totalReward.sub(paidBonus);&#13;
    uint256 bonusPerDay = totalReward.div(rewardDays());&#13;
    if ((totalRewardLeft &gt; 0) &amp;&amp; ((bonusPerDay == 0) || (rewardDaysLeft() == 0))) {&#13;
      return totalRewardLeft;&#13;
    }&#13;
    uint256 totalPayable = rewardPayableDays().mul(bonusPerDay);&#13;
    uint256 reward = totalPayable.sub(paidBonus);&#13;
    return reward;&#13;
  }&#13;
&#13;
  function sendReward(address _address, uint256 _value) private {&#13;
    contributors[_address].rewardDistributedDecoUnits = contributors[_address].rewardDistributedDecoUnits.add(_value);&#13;
    rewardDistributedUnits = rewardDistributedUnits.add(_value); &#13;
    RewardDistributed(_address, _value);&#13;
    token.transfer(_address, _value);&#13;
  }&#13;
&#13;
  function rewardPayableDays() constant public returns (uint256) {&#13;
    uint256 payableDays = rewardDays().sub(rewardDaysLeft());&#13;
    if (payableDays == 0) {&#13;
      payableDays = 1;&#13;
    }&#13;
    if (payableDays &gt; rewardDays()) {&#13;
      payableDays = rewardDays();&#13;
    }&#13;
    return payableDays;&#13;
  }&#13;
&#13;
  function rewardDays() constant public returns (uint256) {&#13;
    uint256 rate = rewardUnitsRatePerYear();&#13;
    if (rate == 0) {&#13;
      return 80 * 365; // Initial assumption&#13;
    }&#13;
    uint256 daysToComplete = (totalSupplyUnits.sub(crowdsaleDistributedUnits)).mul(365).div(rate);&#13;
    return daysToComplete;&#13;
  }&#13;
&#13;
  function rewardUnitsRatePerYear() constant public returns (uint256) {&#13;
    return crowdsaleDistributedUnits.div(100);&#13;
  }&#13;
&#13;
  function currentRewardReleasePercentageRatePerYear() afterSale constant external returns (uint256) {&#13;
    return rewardUnitsRatePerYear().mul(10**18).div(circulatingSupply()).mul(100); // Divide by 10**18 to get the actual decimal % value&#13;
  }&#13;
&#13;
  function rewardDistributionEnd() constant public returns (uint256) {&#13;
    uint256 secondsToComplete = rewardDays().mul(1 days);&#13;
    return rewardDistributionStart.add(secondsToComplete);&#13;
  }&#13;
&#13;
  function changeRemainingDecoRewardOwner(address _newOwner, string _confirmation) afterSale external {&#13;
    require(_newOwner != 0x0);&#13;
    require(sha3(_confirmation) == sha3("CONFIRM"));&#13;
    require(_newOwner != address(this));&#13;
    require(_newOwner != address(token));    &#13;
    require(contributors[_newOwner].decoUnits == 0);&#13;
    require(contributors[msg.sender].decoUnits &gt; 0);&#13;
    require(token.balanceOf(_newOwner) &gt; 0); // The new owner must have some number of DECO tokens. It proofs that _newOwner address is real.&#13;
    contributors[_newOwner] = contributors[msg.sender];&#13;
    delete(contributors[msg.sender]);&#13;
    RemainingRewardOwnershipChanged(msg.sender, _newOwner);&#13;
  }  &#13;
&#13;
  function totalUnitsLeft() constant public returns (uint256) {&#13;
    int256 units = int256(totalSupplyUnits) - int256((rewardDistributedUnits.add(crowdsaleDistributedUnits))); &#13;
    if (units &lt; 0) {&#13;
      return token.balanceOf(this);&#13;
    }&#13;
    return uint256(units);&#13;
  }&#13;
&#13;
  function rewardDaysLeft() constant public returns (uint256) {&#13;
    if (now &lt; rewardDistributionStart) {&#13;
      return rewardDays();&#13;
    }&#13;
    int256 left = (int256(rewardDistributionEnd()) - int256(now)) / 1 days;&#13;
    if (left &lt; 0) {&#13;
      left = 0;&#13;
    }&#13;
    return uint256(left);&#13;
  }&#13;
&#13;
  function contributorTotalReward(address _address) constant public returns (uint256) {&#13;
    uint256 proportion = contributors[_address].decoUnits.mul(10**32).div(crowdsaleDistributedUnits.sub(issuerDistributedUnits));&#13;
    uint256 leftForBonuses = totalSupplyUnits.sub(crowdsaleDistributedUnits);&#13;
    uint256 reward = leftForBonuses.mul(proportion).div(10**32);&#13;
    uint256 totalLeft = totalSupplyUnits - (rewardDistributedUnits.add(reward).add(crowdsaleDistributedUnits));&#13;
    if (totalLeft &lt; 10**4) {&#13;
      reward = reward.add(totalLeft);&#13;
    }    &#13;
    return reward;&#13;
  }&#13;
&#13;
  function contributorDistributedReward(address _address) constant public returns (uint256) {&#13;
    return contributors[_address].rewardDistributedDecoUnits;&#13;
  }  &#13;
&#13;
  function rewardDistributionEnded() public constant returns (bool) {&#13;
    return now &gt; rewardDistributionEnd();&#13;
  }&#13;
&#13;
}