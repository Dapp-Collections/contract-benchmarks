pragma solidity ^0.4.16;
/**
* @title UNR ICO CONTRACT
* @dev ERC-20 Token Standard Compliant
* @author Fares A. Akel C. <span class="__cf_email__" data-cfemail="60064e010e140f0e090f4e010b050c20070d01090c4e030f0d">[emailÂ protected]</span>&#13;
*/&#13;
&#13;
/**&#13;
 * @title SafeMath by OpenZeppelin&#13;
 * @dev Math operations with safety checks that throw on error&#13;
 */&#13;
library SafeMath {&#13;
&#13;
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
        uint256 c = a * b;&#13;
        assert(a == 0 || c / a == b);&#13;
        return c;&#13;
    }&#13;
&#13;
    function div(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
    uint256 c = a / b;&#13;
    return c;&#13;
    }&#13;
&#13;
&#13;
    function add(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
        uint256 c = a + b;&#13;
        assert(c &gt;= a);&#13;
        return c;&#13;
    }&#13;
}&#13;
&#13;
contract token {&#13;
&#13;
    function balanceOf(address _owner) public constant returns (uint256 balance);&#13;
    function transfer(address _to, uint256 _value) public returns (bool success);&#13;
&#13;
    }&#13;
&#13;
/**&#13;
 * @title admined&#13;
 * @notice This contract is administered&#13;
 */&#13;
contract admined {&#13;
    address public admin; //Admin address is public&#13;
    &#13;
    /**&#13;
    * @dev This contructor takes the msg.sender as the first administer&#13;
    */&#13;
    function admined() internal {&#13;
        admin = msg.sender; //Set initial admin to contract creator&#13;
        Admined(admin);&#13;
    }&#13;
&#13;
    /**&#13;
    * @dev This modifier limits function execution to the admin&#13;
    */&#13;
    modifier onlyAdmin() { //A modifier to define admin-only functions&#13;
        require(msg.sender == admin);&#13;
        _;&#13;
    }&#13;
&#13;
    /**&#13;
    * @notice This function transfer the adminship of the contract to _newAdmin&#13;
    * @param _newAdmin The new admin of the contract&#13;
    */&#13;
    function transferAdminship(address _newAdmin) onlyAdmin public { //Admin can be transfered&#13;
        admin = _newAdmin;&#13;
        TransferAdminship(admin);&#13;
    }&#13;
&#13;
    /**&#13;
    * @dev Log Events&#13;
    */&#13;
    event TransferAdminship(address newAdminister);&#13;
    event Admined(address administer);&#13;
&#13;
}&#13;
&#13;
&#13;
contract UNRICO is admined {&#13;
    using SafeMath for uint256;&#13;
    //This ico have 3 stages&#13;
    enum State {&#13;
        Ongoin,&#13;
        Successful&#13;
    }&#13;
    //public variables&#13;
    uint256 public priceOfEthOnUSD;&#13;
    State public state = State.Ongoin; //Set initial stage&#13;
    uint256 public startTime = now; //block-time when it was deployed&#13;
    uint256[5] public price;&#13;
    uint256 public HardCap;&#13;
    uint256 public totalRaised; //eth in wei&#13;
    uint256 public totalDistributed; //tokens&#13;
    uint256 public ICOdeadline = startTime.add(27 days);//27 days deadline&#13;
    uint256 public completedAt;&#13;
    token public tokenReward;&#13;
    address public creator;&#13;
    address public beneficiary;&#13;
    string public campaignUrl;&#13;
    uint8 constant version = 1;&#13;
&#13;
    //events for log&#13;
    event LogFundingReceived(address _addr, uint _amount, uint _currentTotal);&#13;
    event LogBeneficiaryPaid(address _beneficiaryAddress);&#13;
    event LogFundingSuccessful(uint _totalRaised);&#13;
    event LogFunderInitialized(&#13;
        address _creator,&#13;
        address _beneficiary,&#13;
        string _url,&#13;
        uint256 _ICOdeadline);&#13;
    event LogContributorsPayout(address _addr, uint _amount);&#13;
    event PriceUpdate(uint256 _newPrice);&#13;
&#13;
    modifier notFinished() {&#13;
        require(state != State.Successful);&#13;
        _;&#13;
    }&#13;
    /**&#13;
    * @notice ICO constructor&#13;
    * @param _campaignUrl is the ICO _url&#13;
    * @param _addressOfTokenUsedAsReward is the token totalDistributed&#13;
    * @param _initialUsdPriceOfEth is the current price in USD for a single ether&#13;
    */&#13;
    function UNRICO (string _campaignUrl, token _addressOfTokenUsedAsReward, uint256 _initialUsdPriceOfEth) public {&#13;
        creator = msg.sender;&#13;
        beneficiary = msg.sender;&#13;
        campaignUrl = _campaignUrl;&#13;
        tokenReward = token(_addressOfTokenUsedAsReward);&#13;
        priceOfEthOnUSD = _initialUsdPriceOfEth;&#13;
        HardCap = SafeMath.div(7260000*10**18,priceOfEthOnUSD); //7,260,000$&#13;
        price[0] = SafeMath.div(1 * 10 ** 15, priceOfEthOnUSD.mul(1666666));&#13;
        price[1] = SafeMath.div(1 * 10 ** 11, priceOfEthOnUSD.mul(125));&#13;
        price[2] = SafeMath.div(1 * 10 ** 15, priceOfEthOnUSD.mul(1111111));&#13;
        price[3] = SafeMath.div(1 * 10 ** 15, priceOfEthOnUSD.mul(1052631));&#13;
        price[4] = SafeMath.div(1 * 10 ** 10, priceOfEthOnUSD.mul(10));&#13;
&#13;
        LogFunderInitialized(&#13;
            creator,&#13;
            beneficiary,&#13;
            campaignUrl,&#13;
            ICOdeadline);&#13;
        PriceUpdate(priceOfEthOnUSD);&#13;
    }&#13;
&#13;
    function updatePriceOfEth(uint256 _newPrice) onlyAdmin public {&#13;
        priceOfEthOnUSD = _newPrice;&#13;
        price[0] = SafeMath.div(1 * 10 ** 15, priceOfEthOnUSD.mul(1666666));&#13;
        price[1] = SafeMath.div(1 * 10 ** 11, priceOfEthOnUSD.mul(125));&#13;
        price[2] = SafeMath.div(1 * 10 ** 15, priceOfEthOnUSD.mul(1111111));&#13;
        price[3] = SafeMath.div(1 * 10 ** 15, priceOfEthOnUSD.mul(1052631));&#13;
        price[4] = SafeMath.div(1 * 10 ** 10, priceOfEthOnUSD.mul(10));&#13;
        HardCap = SafeMath.div(7260000*10**18,priceOfEthOnUSD); //7,260,000$&#13;
        PriceUpdate(_newPrice);&#13;
    }&#13;
&#13;
    /**&#13;
    * @notice contribution handler&#13;
    */&#13;
    function contribute() public notFinished payable {&#13;
&#13;
        uint256 tokenBought;&#13;
        uint256 required;&#13;
        totalRaised = totalRaised.add(msg.value);&#13;
&#13;
        if(totalDistributed &lt; 2000000 * (10 ** 8)){&#13;
            tokenBought = msg.value.div(price[0]);&#13;
            required = SafeMath.div(10000,6);&#13;
            require(tokenBought &gt;= required);&#13;
        }&#13;
        else if (totalDistributed &lt; 20000000 * (10 ** 8)){&#13;
            tokenBought = msg.value.div(price[1]);&#13;
            required = SafeMath.div(10000,8);&#13;
            require(tokenBought &gt;= required);&#13;
        }&#13;
        else if (totalDistributed &lt; 40000000 * (10 ** 8)){&#13;
            tokenBought = msg.value.div(price[2]);&#13;
            required = SafeMath.div(10000,9);&#13;
            require(tokenBought &gt;= required);&#13;
        }&#13;
        else if (totalDistributed &lt; 60000000 * (10 ** 8)){&#13;
            tokenBought = msg.value.div(price[3]);&#13;
            required = SafeMath.div(100000,95);&#13;
            require(tokenBought &gt;= required);&#13;
        }&#13;
        else if (totalDistributed &lt; 80000000 * (10 ** 8)){&#13;
            tokenBought = msg.value.div(price[4]);&#13;
            required = 1000;&#13;
            require(tokenBought &gt;= required);&#13;
&#13;
        }&#13;
&#13;
&#13;
        totalDistributed = totalDistributed.add(tokenBought);&#13;
        tokenReward.transfer(msg.sender, tokenBought);&#13;
        &#13;
        LogFundingReceived(msg.sender, msg.value, totalRaised);&#13;
        LogContributorsPayout(msg.sender, tokenBought);&#13;
        &#13;
        checkIfFundingCompleteOrExpired();&#13;
    }&#13;
&#13;
    /**&#13;
    * @notice check status&#13;
    */&#13;
    function checkIfFundingCompleteOrExpired() public {&#13;
        &#13;
        if(now &lt; ICOdeadline &amp;&amp; state!=State.Successful){ //if we are on ICO period and its not Successful&#13;
            if(state == State.Ongoin &amp;&amp; totalRaised &gt;= HardCap){ //if we are Ongoin and we pass the HardCap&#13;
                state = State.Successful; //We are on Successful state&#13;
                completedAt = now; //ICO is complete&#13;
            }&#13;
        }&#13;
        else if(now &gt; ICOdeadline &amp;&amp; state!=State.Successful ) { //if we reach ico deadline and its not Successful yet&#13;
            state = State.Successful; //ico becomes Successful&#13;
            completedAt = now; //ICO is complete&#13;
            LogFundingSuccessful(totalRaised); //we log the finish&#13;
            finished(); //and execute closure&#13;
        }&#13;
    }&#13;
&#13;
    function payOut() public {&#13;
        require(msg.sender == beneficiary);&#13;
        require(beneficiary.send(this.balance));&#13;
        LogBeneficiaryPaid(beneficiary);&#13;
    }&#13;
&#13;
   /**&#13;
    * @notice closure handler&#13;
    */&#13;
    function finished() public { //When finished eth are transfered to beneficiary&#13;
        require(state == State.Successful);&#13;
        uint256 remanent = tokenReward.balanceOf(this);&#13;
&#13;
        require(beneficiary.send(this.balance));&#13;
        tokenReward.transfer(beneficiary,remanent);&#13;
&#13;
        LogBeneficiaryPaid(beneficiary);&#13;
        LogContributorsPayout(beneficiary, remanent);&#13;
    }&#13;
&#13;
    function () public payable {&#13;
        contribute();&#13;
    }&#13;
}