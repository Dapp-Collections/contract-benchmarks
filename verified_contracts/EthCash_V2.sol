pragma solidity ^0.4.24;

/*
*
* EthCash_V2 Contract Source
*~~~~~~~~~~~~~~~~~~~~~~~
* Web: ethcash.online
* Web mirrors: ethcash.global | ethcash.club
* Email: <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="b4dbdad8dddad1f4d1c0dcd7d5c7dc9adbdad8dddad1">[emailÂ protected]</a>&#13;
* Telergam: ETHCash_Online&#13;
*~~~~~~~~~~~~~~~~~~~~~~~&#13;
*  - GAIN 3,50% PER 24 HOURS&#13;
*  - Life-long payments&#13;
*  - Minimal 0.03 ETH&#13;
*  - Can payouts yourself every 30 minutes - send 0 eth (&gt; 0.001 ETH must accumulate on balance)&#13;
*  - Affiliate 7.00%&#13;
*    -- 3.50% Cashback (first payment with ref adress DATA)&#13;
*~~~~~~~~~~~~~~~~~~~~~~~&#13;
* RECOMMENDED GAS LIMIT: 250000&#13;
* RECOMMENDED GAS PRICE: ethgasstation.info&#13;
*&#13;
*/&#13;
&#13;
library SafeMath {&#13;
    function mul(uint256 a, uint256 b) internal pure returns(uint256) {&#13;
        if(a == 0) {&#13;
            return 0;&#13;
        }&#13;
&#13;
        uint256 c = a * b;&#13;
        require(c / a == b);&#13;
&#13;
        return c;&#13;
    }&#13;
&#13;
    function div(uint256 a, uint256 b) internal pure returns(uint256) {&#13;
        require(b &gt; 0);&#13;
        uint256 c = a / b;&#13;
&#13;
        return c;&#13;
    }&#13;
&#13;
    function sub(uint256 a, uint256 b) internal pure returns(uint256) {&#13;
        require(b &lt;= a);&#13;
        uint256 c = a - b;&#13;
&#13;
        return c;&#13;
    }&#13;
&#13;
    function add(uint256 a, uint256 b) internal pure returns(uint256) {&#13;
        uint256 c = a + b;&#13;
        require(c &gt;= a);&#13;
&#13;
        return c;&#13;
    }&#13;
&#13;
    function mod(uint256 a, uint256 b) internal pure returns(uint256) {&#13;
        require(b != 0);&#13;
&#13;
        return a % b;&#13;
    }&#13;
}&#13;
&#13;
contract EthCash_V2 {&#13;
    using SafeMath for uint;&#13;
&#13;
    struct Investor {&#13;
        uint id;&#13;
        uint deposit;&#13;
        uint deposits;&#13;
        uint date;&#13;
        address referrer;&#13;
    }&#13;
&#13;
    uint private MIN_INVEST = 0.03 ether;&#13;
    uint private OWN_COMMISSION_PERCENT = 15;&#13;
    uint private COMPENSATION_COMMISSION_PERCENT = 5;&#13;
    uint private REF_BONUS_PERCENT = 7;&#13;
    uint private CASHBACK_PERCENT = 35;&#13;
    uint private PAYOUT_INTERVAL = 10 minutes;&#13;
    uint private PAYOUT_SELF_INTERVAL = 30 minutes;&#13;
    uint private INTEREST = 35;&#13;
&#13;
    address constant public ADMIN_COMMISSION_ADDRESS = 0x54E14eaaCffF244c82a1EDc3778F9A0391E7e615;&#13;
    address constant public COMPENSATION_COMMISSION_ADDRESS = 0x8e30A300c73CD8107280f5Af04E90C1F815086E1;&#13;
    uint public depositAmount;&#13;
    uint public payoutDate;&#13;
    uint public paymentDate;&#13;
&#13;
    address[] public addresses;&#13;
    mapping(address =&gt; Investor) public investors;&#13;
&#13;
    event Invest(address holder, uint amount);&#13;
    event ReferrerBonus(address holder, uint amount);&#13;
    event Cashback(address holder, uint amount);&#13;
    event PayoutCumulative(uint amount, uint txs);&#13;
    event PayoutSelf(address addr, uint amount);&#13;
&#13;
    constructor() public {&#13;
        payoutDate = now;&#13;
    }&#13;
&#13;
    function() payable public {&#13;
&#13;
        if (0 == msg.value) {&#13;
            payoutSelf();&#13;
            return;&#13;
        }&#13;
&#13;
        require(msg.value &gt;= MIN_INVEST, "Too small amount");&#13;
&#13;
        Investor storage user = investors[msg.sender];&#13;
&#13;
        if(user.id == 0) {&#13;
            user.id = addresses.length + 1;&#13;
            addresses.push(msg.sender);&#13;
&#13;
            address ref = bytesToAddress(msg.data);&#13;
            if(investors[ref].deposit &gt; 0 &amp;&amp; ref != msg.sender) {&#13;
                user.referrer = ref;&#13;
            }&#13;
        }&#13;
&#13;
        user.deposit = user.deposit.add(msg.value);&#13;
        user.deposits = user.deposits.add(1);&#13;
        user.date = now;&#13;
        emit Invest(msg.sender, msg.value);&#13;
&#13;
        paymentDate = now;&#13;
        depositAmount = depositAmount.add(msg.value);&#13;
&#13;
        uint own_com = msg.value.div(100).mul(OWN_COMMISSION_PERCENT);&#13;
        uint com_com = msg.value.div(100).mul(COMPENSATION_COMMISSION_PERCENT);&#13;
        ADMIN_COMMISSION_ADDRESS.transfer(own_com);&#13;
        COMPENSATION_COMMISSION_ADDRESS.transfer(com_com);&#13;
&#13;
        if(user.referrer != address(0)) {&#13;
            uint bonus = msg.value.div(100).mul(REF_BONUS_PERCENT);&#13;
            user.referrer.transfer(bonus);&#13;
            emit ReferrerBonus(user.referrer, bonus);&#13;
&#13;
            if(user.deposits == 1) {&#13;
                uint cashback = msg.value.div(1000).mul(CASHBACK_PERCENT);&#13;
                msg.sender.transfer(cashback);&#13;
                emit Cashback(msg.sender, cashback);&#13;
            }&#13;
        }&#13;
    }&#13;
&#13;
    function payout(uint limit) public {&#13;
&#13;
        require(now &gt;= payoutDate + PAYOUT_INTERVAL, "Too fast payout request");&#13;
&#13;
        uint sum;&#13;
        uint txs;&#13;
&#13;
        for(uint i = addresses.length ; i &gt; 0; i--) {&#13;
            address addr = addresses[i - 1];&#13;
&#13;
            if(investors[addr].date + 20 hours &gt; now) continue;&#13;
&#13;
            uint amount = getInvestorUnPaidAmount(addr);&#13;
            investors[addr].date = now;&#13;
&#13;
            if(address(this).balance &lt; amount) {&#13;
                return;&#13;
            }&#13;
&#13;
            addr.transfer(amount);&#13;
&#13;
            sum = sum.add(amount);&#13;
&#13;
            if(++txs &gt;= limit) break;&#13;
        }&#13;
&#13;
        payoutDate = now;&#13;
&#13;
        emit PayoutCumulative(sum, txs);&#13;
    }&#13;
&#13;
    function payoutSelf() public {&#13;
        address addr = msg.sender;&#13;
&#13;
        require(investors[addr].deposit &gt; 0, "Deposit not found");&#13;
        require(now &gt;= investors[addr].date + PAYOUT_SELF_INTERVAL, "Too fast payout request");&#13;
&#13;
        uint amount = getInvestorUnPaidAmount(addr);&#13;
        require(amount &gt;= 1 finney, "Too small unpaid amount");&#13;
&#13;
        investors[addr].date = now;&#13;
&#13;
        if(address(this).balance &lt; amount) {&#13;
            return;&#13;
        }&#13;
&#13;
        addr.transfer(amount);&#13;
&#13;
        emit PayoutSelf(addr, amount);&#13;
    }&#13;
&#13;
    function bytesToAddress(bytes bys) private pure returns(address addr) {&#13;
        assembly {&#13;
            addr := mload(add(bys, 20))&#13;
        }&#13;
    }&#13;
&#13;
    function getInvestorUnPaidAmount(address addr) public view returns(uint) {&#13;
        return investors[addr].deposit.div(1000).mul(INTEREST).div(100).mul(now.sub(investors[addr].date).mul(100)).div(1 days);&#13;
    }&#13;
&#13;
    function getInvestorCount() public view returns(uint) { return addresses.length; }&#13;
}