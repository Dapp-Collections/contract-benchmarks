/*
This file is part of the BREMP Contract.

The BREMP Contract is free software: you can redistribute it and/or
modify it under the terms of the GNU lesser General Public License as published
by the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

The BREMP Contract is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU lesser General Public License for more details.

You should have received a copy of the GNU lesser General Public License
along with the BREMP Contract. If not, see <http://www.gnu.org/licenses/>.

@author Ilya Svirin <<span class="__cf_email__" data-cfemail="6b0245181d021902052b0504190f0a1d02050f45191e">[emailÂ protected]</span>&gt;&#13;
IF YOU ARE ENJOYED IT DONATE TO 0x3Ad38D1060d1c350aF29685B2b8Ec3eDE527452B ! :)&#13;
*/&#13;
&#13;
&#13;
pragma solidity ^0.4.0;&#13;
&#13;
contract NeuroDAO {&#13;
    function balanceOf(address who) constant returns (uint);&#13;
    function freezedBalanceOf(address _who) constant returns(uint);&#13;
}&#13;
&#13;
contract owned {&#13;
&#13;
    address public owner;&#13;
    address public newOwner;&#13;
&#13;
    function owned() payable {&#13;
        owner = msg.sender;&#13;
    }&#13;
    &#13;
    modifier onlyOwner {&#13;
        require(owner == msg.sender);&#13;
        _;&#13;
    }&#13;
&#13;
    function changeOwner(address _owner) onlyOwner public {&#13;
        require(_owner != 0);&#13;
        newOwner = _owner;&#13;
    }&#13;
    &#13;
    function confirmOwner() public {&#13;
        require(newOwner == msg.sender);&#13;
        owner = newOwner;&#13;
        delete newOwner;&#13;
    }&#13;
}&#13;
&#13;
contract Crowdsale is owned {&#13;
&#13;
    uint constant totalTokens    = 25000000;&#13;
    uint constant neurodaoTokens = 1250000;&#13;
    uint constant totalLimitUSD  = 500000;&#13;
    &#13;
    uint                         public totalSupply;&#13;
    mapping (address =&gt; uint256) public balanceOf;&#13;
    address                      public neurodao;&#13;
    uint                         public etherPrice;&#13;
&#13;
    mapping (address =&gt; bool)    public holders;&#13;
    mapping (uint =&gt; address)    public holdersIter;&#13;
    uint                         public numberOfHolders;&#13;
    &#13;
    uint                         public collectedUSD;&#13;
    address                      public presaleOwner;&#13;
    uint                         public collectedNDAO;&#13;
    &#13;
    mapping (address =&gt; bool)    public gotBonus;&#13;
    &#13;
    enum State {Disabled, Presale, Bonuses, Enabled}&#13;
    State                        public state;&#13;
&#13;
    modifier enabledState {&#13;
        require(state == State.Enabled);&#13;
        _;&#13;
    }&#13;
&#13;
    event NewState(State _state);&#13;
    event Transfer(address indexed from, address indexed to, uint value);&#13;
&#13;
    function Crowdsale(address _neurodao, uint _etherPrice) payable owned() {&#13;
        neurodao = _neurodao;&#13;
        etherPrice = _etherPrice;&#13;
        totalSupply = totalTokens;&#13;
        balanceOf[owner] = neurodaoTokens;&#13;
        balanceOf[this] = totalSupply - balanceOf[owner];&#13;
        Transfer(this, owner, balanceOf[owner]);&#13;
    }&#13;
&#13;
    function setEtherPrice(uint _etherPrice) public {&#13;
        require(presaleOwner == msg.sender || owner == msg.sender);&#13;
        etherPrice = _etherPrice;&#13;
    }&#13;
&#13;
    function startPresale(address _presaleOwner) public onlyOwner {&#13;
        require(state == State.Disabled);&#13;
        presaleOwner = _presaleOwner;&#13;
        state = State.Presale;&#13;
        NewState(state);&#13;
    }&#13;
    &#13;
    function startBonuses() public onlyOwner {&#13;
        require(state == State.Presale);&#13;
        state = State.Bonuses;&#13;
        NewState(state);&#13;
    }&#13;
    &#13;
    function finishCrowdsale() public onlyOwner {&#13;
        require(state == State.Bonuses);&#13;
        state = State.Enabled;&#13;
        NewState(state);&#13;
    }&#13;
&#13;
    function () payable {&#13;
        uint tokens;&#13;
        address tokensSource;&#13;
        if (state == State.Presale) {&#13;
            require(balanceOf[this] &gt; 0);&#13;
            require(collectedUSD &lt; totalLimitUSD);&#13;
            uint valueWei = msg.value;&#13;
            uint valueUSD = valueWei * etherPrice / 1 ether;&#13;
            if (collectedUSD + valueUSD &gt; totalLimitUSD) {&#13;
                valueUSD = totalLimitUSD - collectedUSD;&#13;
                valueWei = valueUSD * 1 ether / etherPrice;&#13;
                require(msg.sender.call.gas(3000000).value(msg.value - valueWei)());&#13;
                collectedUSD = totalLimitUSD;&#13;
            } else {&#13;
                collectedUSD += valueUSD;&#13;
            }&#13;
            uint centsForToken;&#13;
            if (now &lt;= 1506815999) {        // 30/09/2017 11:59pm (UTC)&#13;
                centsForToken = 50;&#13;
            } else if (now &lt;= 1507247999) { // 05/10/2017 11:59pm (UTC)&#13;
                centsForToken = 50;&#13;
            } else if (now &lt;= 1507766399) { // 11/10/2017 11:59pm (UTC)&#13;
                centsForToken = 65;&#13;
            } else {&#13;
                centsForToken = 70;&#13;
            }&#13;
            tokens = valueUSD * 100 / centsForToken;&#13;
            if (NeuroDAO(neurodao).balanceOf(msg.sender) &gt;= 1000) {&#13;
                collectedNDAO += tokens;&#13;
            }&#13;
            tokensSource = this;&#13;
        } else if (state == State.Bonuses) {&#13;
            require(gotBonus[msg.sender] != true);&#13;
            gotBonus[msg.sender] = true;&#13;
            uint freezedBalance = NeuroDAO(neurodao).freezedBalanceOf(msg.sender);&#13;
            if (freezedBalance &gt;= 1000) {&#13;
                tokens = (neurodaoTokens / 10) * freezedBalance / 21000000 + (9 * neurodaoTokens / 10) * balanceOf[msg.sender] / collectedNDAO;                &#13;
            }&#13;
            tokensSource = owner;&#13;
        }        &#13;
        require(tokens &gt; 0);&#13;
        require(balanceOf[msg.sender] + tokens &gt; balanceOf[msg.sender]);&#13;
        require(balanceOf[tokensSource] &gt;= tokens);        &#13;
        if (holders[msg.sender] != true) {&#13;
            holders[msg.sender] = true;&#13;
            holdersIter[numberOfHolders++] = msg.sender;&#13;
        }&#13;
        balanceOf[msg.sender] += tokens;&#13;
        balanceOf[tokensSource] -= tokens;&#13;
        Transfer(tokensSource, msg.sender, tokens);&#13;
    }&#13;
}&#13;
&#13;
contract Token is Crowdsale {&#13;
    &#13;
    string  public standard    = 'Token 0.1';&#13;
    string  public name        = 'BREMP';&#13;
    string  public symbol      = "BREMP";&#13;
    uint8   public decimals    = 0;&#13;
&#13;
    mapping (address =&gt; mapping (address =&gt; uint)) public allowed;&#13;
    event Approval(address indexed owner, address indexed spender, uint value);&#13;
&#13;
    // Fix for the ERC20 short address attack&#13;
    modifier onlyPayloadSize(uint size) {&#13;
        require(msg.data.length &gt;= size + 4);&#13;
        _;&#13;
    }&#13;
&#13;
    function Token(address _neurodao, uint _etherPrice)&#13;
        payable Crowdsale(_neurodao, _etherPrice) {}&#13;
&#13;
    function transfer(address _to, uint256 _value)&#13;
        public enabledState onlyPayloadSize(2 * 32) {&#13;
        require(balanceOf[msg.sender] &gt;= _value);&#13;
        require(balanceOf[_to] + _value &gt;= balanceOf[_to]);&#13;
        if (holders[_to] != true) {&#13;
            holders[_to] = true;&#13;
            holdersIter[numberOfHolders++] = _to;&#13;
        }&#13;
        balanceOf[msg.sender] -= _value;&#13;
        balanceOf[_to] += _value;&#13;
        Transfer(msg.sender, _to, _value);&#13;
    }&#13;
    &#13;
    function transferFrom(address _from, address _to, uint _value)&#13;
        public enabledState onlyPayloadSize(3 * 32) {&#13;
        require(balanceOf[_from] &gt;= _value);&#13;
        require(balanceOf[_to] + _value &gt;= balanceOf[_to]); // overflow&#13;
        require(allowed[_from][msg.sender] &gt;= _value);&#13;
        if (holders[_to] != true) {&#13;
            holders[_to] = true;&#13;
            holdersIter[numberOfHolders++] = _to;&#13;
        }&#13;
        balanceOf[_from] -= _value;&#13;
        balanceOf[_to] += _value;&#13;
        allowed[_from][msg.sender] -= _value;&#13;
        Transfer(_from, _to, _value);&#13;
    }&#13;
&#13;
    function approve(address _spender, uint _value) public enabledState {&#13;
        allowed[msg.sender][_spender] = _value;&#13;
        Approval(msg.sender, _spender, _value);&#13;
    }&#13;
&#13;
    function allowance(address _owner, address _spender) public constant enabledState&#13;
        returns (uint remaining) {&#13;
        return allowed[_owner][_spender];&#13;
    }&#13;
}&#13;
&#13;
contract PresaleBREMP is Token {&#13;
    &#13;
    function PresaleBREMP(address _neurodao, uint _etherPrice)&#13;
        payable Token(_neurodao, _etherPrice) {}&#13;
    &#13;
    function withdraw() public {&#13;
        require(presaleOwner == msg.sender || owner == msg.sender);&#13;
        msg.sender.transfer(this.balance);&#13;
    }&#13;
    &#13;
    function killMe() public onlyOwner {&#13;
        presaleOwner.transfer(this.balance);&#13;
        selfdestruct(owner);&#13;
    }&#13;
}