/*
  Copyright 2017 Loopring Project Ltd (Loopring Foundation).
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*/
pragma solidity 0.4.21;
/// @title Utility Functions for address
/// @author Daniel Wang - <<span class="__cf_email__" data-cfemail="573336393e323b173b383827253e393079382530">[email protected]</span>&gt;&#13;
library AddressUtil {&#13;
    function isContract(address addr)&#13;
        internal&#13;
        view&#13;
        returns (bool)&#13;
    {&#13;
        if (addr == 0x0) {&#13;
            return false;&#13;
        } else {&#13;
            uint size;&#13;
            assembly { size := extcodesize(addr) }&#13;
            return size &gt; 0;&#13;
        }&#13;
    }&#13;
}&#13;
/*&#13;
  Copyright 2017 Loopring Project Ltd (Loopring Foundation).&#13;
  Licensed under the Apache License, Version 2.0 (the "License");&#13;
  you may not use this file except in compliance with the License.&#13;
  You may obtain a copy of the License at&#13;
  http://www.apache.org/licenses/LICENSE-2.0&#13;
  Unless required by applicable law or agreed to in writing, software&#13;
  distributed under the License is distributed on an "AS IS" BASIS,&#13;
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#13;
  See the License for the specific language governing permissions and&#13;
  limitations under the License.&#13;
*/&#13;
/*&#13;
    Copyright 2017 Loopring Project Ltd (Loopring Foundation).&#13;
    Licensed under the Apache License, Version 2.0 (the "License");&#13;
    you may not use this file except in compliance with the License.&#13;
    You may obtain a copy of the License at&#13;
    http://www.apache.org/licenses/LICENSE-2.0&#13;
    Unless required by applicable law or agreed to in writing, software&#13;
    distributed under the License is distributed on an "AS IS" BASIS,&#13;
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#13;
    See the License for the specific language governing permissions and&#13;
    limitations under the License.&#13;
*/&#13;
/*&#13;
  Copyright 2017 Loopring Project Ltd (Loopring Foundation).&#13;
  Licensed under the Apache License, Version 2.0 (the "License");&#13;
  you may not use this file except in compliance with the License.&#13;
  You may obtain a copy of the License at&#13;
  http://www.apache.org/licenses/LICENSE-2.0&#13;
  Unless required by applicable law or agreed to in writing, software&#13;
  distributed under the License is distributed on an "AS IS" BASIS,&#13;
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#13;
  See the License for the specific language governing permissions and&#13;
  limitations under the License.&#13;
*/&#13;
/// @title ERC20 Token Interface&#13;
/// @dev see https://github.com/ethereum/EIPs/issues/20&#13;
/// @author Daniel Wang - &lt;<span class="__cf_email__" data-cfemail="2145404f48444d614d4e4e5153484f460f4e5346">[email protected]</span>&gt;&#13;
contract ERC20 {&#13;
    function balanceOf(address who) view public returns (uint256);&#13;
    function allowance(address owner, address spender) view public returns (uint256);&#13;
    function transfer(address to, uint256 value) public returns (bool);&#13;
    function transferFrom(address from, address to, uint256 value) public returns (bool);&#13;
    function approve(address spender, uint256 value) public returns (bool);&#13;
}&#13;
/*&#13;
  Copyright 2017 Loopring Project Ltd (Loopring Foundation).&#13;
  Licensed under the Apache License, Version 2.0 (the "License");&#13;
  you may not use this file except in compliance with the License.&#13;
  You may obtain a copy of the License at&#13;
  http://www.apache.org/licenses/LICENSE-2.0&#13;
  Unless required by applicable law or agreed to in writing, software&#13;
  distributed under the License is distributed on an "AS IS" BASIS,&#13;
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#13;
  See the License for the specific language governing permissions and&#13;
  limitations under the License.&#13;
*/&#13;
/// @title Utility Functions for uint&#13;
/// @author Daniel Wang - &lt;<span class="__cf_email__" data-cfemail="bdd9dcd3d4d8d1fdd1d2d2cdcfd4d3da93d2cfda">[email protected]</span>&gt;&#13;
library MathUint {&#13;
    function mul(uint a, uint b) internal pure returns (uint c) {&#13;
        c = a * b;&#13;
        require(a == 0 || c / a == b);&#13;
    }&#13;
    function sub(uint a, uint b) internal pure returns (uint) {&#13;
        require(b &lt;= a);&#13;
        return a - b;&#13;
    }&#13;
    function add(uint a, uint b) internal pure returns (uint c) {&#13;
        c = a + b;&#13;
        require(c &gt;= a);&#13;
    }&#13;
    function tolerantSub(uint a, uint b) internal pure returns (uint c) {&#13;
        return (a &gt;= b) ? a - b : 0;&#13;
    }&#13;
    /// @dev calculate the square of Coefficient of Variation (CV)&#13;
    /// https://en.wikipedia.org/wiki/Coefficient_of_variation&#13;
    function cvsquare(&#13;
        uint[] arr,&#13;
        uint scale&#13;
        )&#13;
        internal&#13;
        pure&#13;
        returns (uint)&#13;
    {&#13;
        uint len = arr.length;&#13;
        require(len &gt; 1);&#13;
        require(scale &gt; 0);&#13;
        uint avg = 0;&#13;
        for (uint i = 0; i &lt; len; i++) {&#13;
            avg += arr[i];&#13;
        }&#13;
        avg = avg / len;&#13;
        if (avg == 0) {&#13;
            return 0;&#13;
        }&#13;
        uint cvs = 0;&#13;
        uint s;&#13;
        uint item;&#13;
        for (i = 0; i &lt; len; i++) {&#13;
            item = arr[i];&#13;
            s = item &gt; avg ? item - avg : avg - item;&#13;
            cvs += mul(s, s);&#13;
        }&#13;
        return ((mul(mul(cvs, scale), scale) / avg) / avg) / (len - 1);&#13;
    }&#13;
}&#13;
/// @title ERC20 Token Implementation&#13;
/// @dev see https://github.com/ethereum/EIPs/issues/20&#13;
///      This ERC20 token will give the designated tokenTransferDelegate a max allowance.&#13;
/// @author Daniel Wang - &lt;<span class="__cf_email__" data-cfemail="d3b7b2bdbab6bf93bfbcbca3a1babdb4fdbca1b4">[email protected]</span>&gt;&#13;
contract ERC20Token is ERC20 {&#13;
    using MathUint for uint;&#13;
    using AddressUtil for address;&#13;
    string  public name;&#13;
    string  public symbol;&#13;
    uint8   public decimals;&#13;
    uint    public totalSupply_;&#13;
    address public tokenTransferDelegate;&#13;
    mapping (address =&gt; uint256) balances;&#13;
    mapping (address =&gt; mapping (address =&gt; uint256)) internal allowed;&#13;
    event Transfer(address indexed from, address indexed to, uint256 value);&#13;
    event Approval(address indexed owner, address indexed spender, uint256 value);&#13;
    function ERC20Token(&#13;
        string  _name,&#13;
        string  _symbol,&#13;
        uint8   _decimals,&#13;
        uint    _totalSupply,&#13;
        address _firstHolder,&#13;
        address _tokenTransferDelegate&#13;
        )&#13;
        public&#13;
    {&#13;
        require(bytes(_name).length &gt; 0);&#13;
        require(bytes(_symbol).length &gt; 0);&#13;
        require(_totalSupply &gt; 0);&#13;
        require(_firstHolder != 0x0);&#13;
        require(_tokenTransferDelegate.isContract());&#13;
        name = _name;&#13;
        symbol = _symbol;&#13;
        decimals = _decimals;&#13;
        totalSupply_ = _totalSupply;&#13;
        tokenTransferDelegate = _tokenTransferDelegate;&#13;
        balances[_firstHolder] = totalSupply_;&#13;
    }&#13;
    function () payable public&#13;
    {&#13;
        revert();&#13;
    }&#13;
    /**&#13;
    * @dev total number of tokens in existence&#13;
    */&#13;
    function totalSupply() public view returns (uint256) {&#13;
        return totalSupply_;&#13;
    }&#13;
    /**&#13;
    * @dev transfer token for a specified address&#13;
    * @param _to The address to transfer to.&#13;
    * @param _value The amount to be transferred.&#13;
    */&#13;
    function transfer(&#13;
        address _to,&#13;
        uint256 _value&#13;
        )&#13;
        public&#13;
        returns (bool)&#13;
    {&#13;
        require(_to != address(0));&#13;
        require(_value &lt;= balances[msg.sender]);&#13;
        // SafeMath.sub will throw if there is not enough balance.&#13;
        balances[msg.sender] = balances[msg.sender].sub(_value);&#13;
        balances[_to] = balances[_to].add(_value);&#13;
        emit Transfer(msg.sender, _to, _value);&#13;
        return true;&#13;
    }&#13;
    /**&#13;
    * @dev Gets the balance of the specified address.&#13;
    * @param _owner The address to query the the balance of.&#13;
    * @return An uint256 representing the amount owned by the passed address.&#13;
    */&#13;
    function balanceOf(address _owner)&#13;
        public&#13;
        view&#13;
        returns (uint256 balance)&#13;
    {&#13;
        return balances[_owner];&#13;
    }&#13;
    /**&#13;
     * @dev Transfer tokens from one address to another&#13;
     * @param _from address The address which you want to send tokens from&#13;
     * @param _to address The address which you want to transfer to&#13;
     * @param _value uint256 the amount of tokens to be transferred&#13;
     */&#13;
    function transferFrom(&#13;
        address _from,&#13;
        address _to,&#13;
        uint256 _value&#13;
        )&#13;
        public&#13;
        returns (bool)&#13;
    {&#13;
        require(_to != address(0));&#13;
        require(_value &lt;= balances[_from]);&#13;
        require(_value &lt;= allowed[_from][msg.sender]);&#13;
        balances[_from] = balances[_from].sub(_value);&#13;
        balances[_to] = balances[_to].add(_value);&#13;
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);&#13;
        emit Transfer(_from, _to, _value);&#13;
        return true;&#13;
    }&#13;
    /**&#13;
     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.&#13;
     *&#13;
     * Beware that changing an allowance with this method brings the risk that someone may use both the old&#13;
     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this&#13;
     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:&#13;
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729&#13;
     * @param _spender The address which will spend the funds.&#13;
     * @param _value The amount of tokens to be spent.&#13;
     */&#13;
    function approve(&#13;
        address _spender,&#13;
        uint256 _value&#13;
        )&#13;
        public&#13;
        returns (bool)&#13;
    {&#13;
        allowed[msg.sender][_spender] = _value;&#13;
        emit Approval(msg.sender, _spender, _value);&#13;
        return true;&#13;
    }&#13;
    /**&#13;
     * @dev Function to check the amount of tokens that an owner allowed to a spender.&#13;
     * @param _owner address The address which owns the funds.&#13;
     * @param _spender address The address which will spend the funds.&#13;
     * @return A uint256 specifying the amount of tokens still available for the spender.&#13;
     */&#13;
    function allowance(&#13;
        address _owner,&#13;
        address _spender)&#13;
        public&#13;
        view&#13;
        returns (uint256)&#13;
    {&#13;
        if (_spender == tokenTransferDelegate) {&#13;
            return totalSupply_;&#13;
        } else {&#13;
            return allowed[_owner][_spender];&#13;
        }&#13;
    }&#13;
    /**&#13;
     * @dev Increase the amount of tokens that an owner allowed to a spender.&#13;
     *&#13;
     * approve should be called when allowed[_spender] == 0. To increment&#13;
     * allowed value is better to use this function to avoid 2 calls (and wait until&#13;
     * the first transaction is mined)&#13;
     * From MonolithDAO Token.sol&#13;
     * @param _spender The address which will spend the funds.&#13;
     * @param _addedValue The amount of tokens to increase the allowance by.&#13;
     */&#13;
    function increaseApproval(&#13;
        address _spender,&#13;
        uint _addedValue&#13;
        )&#13;
        public&#13;
        returns (bool)&#13;
    {&#13;
        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);&#13;
        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);&#13;
        return true;&#13;
    }&#13;
    /**&#13;
     * @dev Decrease the amount of tokens that an owner allowed to a spender.&#13;
     *&#13;
     * approve should be called when allowed[_spender] == 0. To decrement&#13;
     * allowed value is better to use this function to avoid 2 calls (and wait until&#13;
     * the first transaction is mined)&#13;
     * From MonolithDAO Token.sol&#13;
     * @param _spender The address which will spend the funds.&#13;
     * @param _subtractedValue The amount of tokens to decrease the allowance by.&#13;
     */&#13;
    function decreaseApproval(&#13;
        address _spender,&#13;
        uint _subtractedValue&#13;
        )&#13;
        public&#13;
        returns (bool)&#13;
    {&#13;
        uint oldValue = allowed[msg.sender][_spender];&#13;
        if (_subtractedValue &gt; oldValue) {&#13;
            allowed[msg.sender][_spender] = 0;&#13;
        } else {&#13;
            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);&#13;
        }&#13;
        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);&#13;
        return true;&#13;
    }&#13;
}&#13;
/*&#13;
  Copyright 2017 Loopring Project Ltd (Loopring Foundation).&#13;
  Licensed under the Apache License, Version 2.0 (the "License");&#13;
  you may not use this file except in compliance with the License.&#13;
  You may obtain a copy of the License at&#13;
  http://www.apache.org/licenses/LICENSE-2.0&#13;
  Unless required by applicable law or agreed to in writing, software&#13;
  distributed under the License is distributed on an "AS IS" BASIS,&#13;
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#13;
  See the License for the specific language governing permissions and&#13;
  limitations under the License.&#13;
*/&#13;
/*&#13;
  Copyright 2017 Loopring Project Ltd (Loopring Foundation).&#13;
  Licensed under the Apache License, Version 2.0 (the "License");&#13;
  you may not use this file except in compliance with the License.&#13;
  You may obtain a copy of the License at&#13;
  http://www.apache.org/licenses/LICENSE-2.0&#13;
  Unless required by applicable law or agreed to in writing, software&#13;
  distributed under the License is distributed on an "AS IS" BASIS,&#13;
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#13;
  See the License for the specific language governing permissions and&#13;
  limitations under the License.&#13;
*/&#13;
/*&#13;
  Copyright 2017 Loopring Project Ltd (Loopring Foundation).&#13;
  Licensed under the Apache License, Version 2.0 (the "License");&#13;
  you may not use this file except in compliance with the License.&#13;
  You may obtain a copy of the License at&#13;
  http://www.apache.org/licenses/LICENSE-2.0&#13;
  Unless required by applicable law or agreed to in writing, software&#13;
  distributed under the License is distributed on an "AS IS" BASIS,&#13;
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#13;
  See the License for the specific language governing permissions and&#13;
  limitations under the License.&#13;
*/&#13;
/// @title Ownable&#13;
/// @dev The Ownable contract has an owner address, and provides basic&#13;
///      authorization control functions, this simplifies the implementation of&#13;
///      "user permissions".&#13;
contract Ownable {&#13;
    address public owner;&#13;
    event OwnershipTransferred(&#13;
        address indexed previousOwner,&#13;
        address indexed newOwner&#13;
    );&#13;
    /// @dev The Ownable constructor sets the original `owner` of the contract&#13;
    ///      to the sender.&#13;
    function Ownable() public {&#13;
        owner = msg.sender;&#13;
    }&#13;
    /// @dev Throws if called by any account other than the owner.&#13;
    modifier onlyOwner() {&#13;
        require(msg.sender == owner);&#13;
        _;&#13;
    }&#13;
    /// @dev Allows the current owner to transfer control of the contract to a&#13;
    ///      newOwner.&#13;
    /// @param newOwner The address to transfer ownership to.&#13;
    function transferOwnership(address newOwner) onlyOwner public {&#13;
        require(newOwner != 0x0);&#13;
        emit OwnershipTransferred(owner, newOwner);&#13;
        owner = newOwner;&#13;
    }&#13;
}&#13;
/// @title Claimable&#13;
/// @dev Extension for the Ownable contract, where the ownership needs&#13;
///      to be claimed. This allows the new owner to accept the transfer.&#13;
contract Claimable is Ownable {&#13;
    address public pendingOwner;&#13;
    /// @dev Modifier throws if called by any account other than the pendingOwner.&#13;
    modifier onlyPendingOwner() {&#13;
        require(msg.sender == pendingOwner);&#13;
        _;&#13;
    }&#13;
    /// @dev Allows the current owner to set the pendingOwner address.&#13;
    /// @param newOwner The address to transfer ownership to.&#13;
    function transferOwnership(address newOwner) onlyOwner public {&#13;
        require(newOwner != 0x0 &amp;&amp; newOwner != owner);&#13;
        pendingOwner = newOwner;&#13;
    }&#13;
    /// @dev Allows the pendingOwner address to finalize the transfer.&#13;
    function claimOwnership() onlyPendingOwner public {&#13;
        emit OwnershipTransferred(owner, pendingOwner);&#13;
        owner = pendingOwner;&#13;
        pendingOwner = 0x0;&#13;
    }&#13;
}&#13;
/// @title Token Register Contract&#13;
/// @dev This contract maintains a list of tokens the Protocol supports.&#13;
/// @author Kongliang Zhong - &lt;<span class="__cf_email__" data-cfemail="c8a3a7a6afa4a1a9a6af88a4a7a7b8baa1a6afe6a7baaf">[email protected]</span>&gt;,&#13;
/// @author Daniel Wang - &lt;<span class="__cf_email__" data-cfemail="086c6966616d6448646767787a61666f26677a6f">[email protected]</span>&gt;.&#13;
contract TokenRegistry is Claimable {&#13;
    using AddressUtil for address;&#13;
    address tokenMintAddr;&#13;
    address[] public addresses;&#13;
    mapping (address =&gt; TokenInfo) addressMap;&#13;
    mapping (string =&gt; address) symbolMap;&#13;
    ////////////////////////////////////////////////////////////////////////////&#13;
    /// Structs                                                              ///&#13;
    ////////////////////////////////////////////////////////////////////////////&#13;
    struct TokenInfo {&#13;
        uint   pos;      // 0 mens unregistered; if &gt; 0, pos + 1 is the&#13;
                         // token's position in `addresses`.&#13;
        string symbol;   // Symbol of the token&#13;
    }&#13;
    ////////////////////////////////////////////////////////////////////////////&#13;
    /// Events                                                               ///&#13;
    ////////////////////////////////////////////////////////////////////////////&#13;
    event TokenRegistered(address addr, string symbol);&#13;
    event TokenUnregistered(address addr, string symbol);&#13;
    ////////////////////////////////////////////////////////////////////////////&#13;
    /// Public Functions                                                     ///&#13;
    ////////////////////////////////////////////////////////////////////////////&#13;
    /// @dev Disable default function.&#13;
    function () payable public {&#13;
        revert();&#13;
    }&#13;
    function TokenRegistry(address _tokenMintAddr) public&#13;
    {&#13;
        require(_tokenMintAddr.isContract());&#13;
        tokenMintAddr = _tokenMintAddr;&#13;
    }&#13;
    function registerToken(&#13;
        address addr,&#13;
        string  symbol&#13;
        )&#13;
        external&#13;
        onlyOwner&#13;
    {&#13;
        registerTokenInternal(addr, symbol);&#13;
    }&#13;
    function registerMintedToken(&#13;
        address addr,&#13;
        string  symbol&#13;
        )&#13;
        external&#13;
    {&#13;
        require(msg.sender == tokenMintAddr);&#13;
        registerTokenInternal(addr, symbol);&#13;
    }&#13;
    function unregisterToken(&#13;
        address addr,&#13;
        string  symbol&#13;
        )&#13;
        external&#13;
        onlyOwner&#13;
    {&#13;
        require(addr != 0x0);&#13;
        require(symbolMap[symbol] == addr);&#13;
        delete symbolMap[symbol];&#13;
        uint pos = addressMap[addr].pos;&#13;
        require(pos != 0);&#13;
        delete addressMap[addr];&#13;
        // We will replace the token we need to unregister with the last token&#13;
        // Only the pos of the last token will need to be updated&#13;
        address lastToken = addresses[addresses.length - 1];&#13;
        // Don't do anything if the last token is the one we want to delete&#13;
        if (addr != lastToken) {&#13;
            // Swap with the last token and update the pos&#13;
            addresses[pos - 1] = lastToken;&#13;
            addressMap[lastToken].pos = pos;&#13;
        }&#13;
        addresses.length--;&#13;
        emit TokenUnregistered(addr, symbol);&#13;
    }&#13;
    function areAllTokensRegistered(address[] addressList)&#13;
        external&#13;
        view&#13;
        returns (bool)&#13;
    {&#13;
        for (uint i = 0; i &lt; addressList.length; i++) {&#13;
            if (addressMap[addressList[i]].pos == 0) {&#13;
                return false;&#13;
            }&#13;
        }&#13;
        return true;&#13;
    }&#13;
    function getAddressBySymbol(string symbol)&#13;
        external&#13;
        view&#13;
        returns (address)&#13;
    {&#13;
        return symbolMap[symbol];&#13;
    }&#13;
    function isTokenRegisteredBySymbol(string symbol)&#13;
        public&#13;
        view&#13;
        returns (bool)&#13;
    {&#13;
        return symbolMap[symbol] != 0x0;&#13;
    }&#13;
    function isTokenRegistered(address addr)&#13;
        public&#13;
        view&#13;
        returns (bool)&#13;
    {&#13;
        return addressMap[addr].pos != 0;&#13;
    }&#13;
    function getTokens(&#13;
        uint start,&#13;
        uint count&#13;
        )&#13;
        public&#13;
        view&#13;
        returns (address[] addressList)&#13;
    {&#13;
        uint num = addresses.length;&#13;
        if (start &gt;= num) {&#13;
            return;&#13;
        }&#13;
        uint end = start + count;&#13;
        if (end &gt; num) {&#13;
            end = num;&#13;
        }&#13;
        if (start == num) {&#13;
            return;&#13;
        }&#13;
        addressList = new address[](end - start);&#13;
        for (uint i = start; i &lt; end; i++) {&#13;
            addressList[i - start] = addresses[i];&#13;
        }&#13;
    }&#13;
    function registerTokenInternal(&#13;
        address addr,&#13;
        string  symbol&#13;
        )&#13;
        internal&#13;
    {&#13;
        require(0x0 != addr);&#13;
        require(bytes(symbol).length &gt; 0);&#13;
        require(0x0 == symbolMap[symbol]);&#13;
        require(0 == addressMap[addr].pos);&#13;
        addresses.push(addr);&#13;
        symbolMap[symbol] = addr;&#13;
        addressMap[addr] = TokenInfo(addresses.length, symbol);&#13;
        emit TokenRegistered(addr, symbol);&#13;
    }&#13;
}&#13;
/// @title ERC20 Token Mint&#13;
/// @dev This contract deploys ERC20 token contract and registered the contract&#13;
///      so the token can be traded with Loopring Protocol.&#13;
/// @author Kongliang Zhong - &lt;<span class="__cf_email__" data-cfemail="b8d3d7d6dfd4d1d9d6dff8d4">[email protected]</span>oopring.org&gt;,&#13;
/// @author Daniel Wang - &lt;<span class="__cf_email__" data-cfemail="6004010e09050c200c0f0f1012090e074e0f1207">[email protected]</span>&gt;.&#13;
contract TokenCreator {&#13;
    using AddressUtil for address;&#13;
    address[] public tokens;&#13;
    address   public tokenRegistry;&#13;
    address   public tokenTransferDelegate;&#13;
    event TokenCreated(&#13;
        address indexed addr,&#13;
        string  name,&#13;
        string  symbol,&#13;
        uint8   decimals,&#13;
        uint    totalSupply,&#13;
        address firstHolder,&#13;
        address tokenTransferDelegate&#13;
    );&#13;
    /// @dev Disable default function.&#13;
    function () payable public&#13;
    {&#13;
        revert();&#13;
    }&#13;
    /// @dev Initialize TokenRegistry address.&#13;
    ///      This method sjhall be called immediately upon deployment.&#13;
    function initialize(&#13;
        address _tokenRegistry,&#13;
        address _tokenTransferDelegate&#13;
        )&#13;
        public&#13;
    {&#13;
        require(tokenRegistry == 0x0 &amp;&amp; _tokenRegistry.isContract());&#13;
        tokenRegistry = _tokenRegistry;&#13;
        require(tokenTransferDelegate == 0x0 &amp;&amp; _tokenTransferDelegate.isContract());&#13;
        tokenTransferDelegate = _tokenTransferDelegate;&#13;
    }&#13;
    /// @dev Deploy an ERC20 token contract, register it with TokenRegistry,&#13;
    ///      and returns the new token's address.&#13;
    /// @param name The name of the token&#13;
    /// @param symbol The symbol of the token.&#13;
    /// @param decimals The decimals of the token.&#13;
    /// @param totalSupply The total supply of the token.&#13;
    function createToken(&#13;
        string  name,&#13;
        string  symbol,&#13;
        uint8   decimals,&#13;
        uint    totalSupply&#13;
        )&#13;
        public&#13;
        returns (address addr)&#13;
    {&#13;
        require(tokenRegistry != 0x0);&#13;
        require(tokenTransferDelegate != 0x0);&#13;
        ERC20Token token = new ERC20Token(&#13;
            name,&#13;
            symbol,&#13;
            decimals,&#13;
            totalSupply,&#13;
            tx.origin,&#13;
            tokenTransferDelegate&#13;
        );&#13;
        addr = address(token);&#13;
        TokenRegistry(tokenRegistry).registerMintedToken(addr, symbol);&#13;
        tokens.push(addr);&#13;
        emit TokenCreated(&#13;
            addr,&#13;
            name,&#13;
            symbol,&#13;
            decimals,&#13;
            totalSupply,&#13;
            tx.origin,&#13;
            tokenTransferDelegate&#13;
        );&#13;
    }&#13;
}