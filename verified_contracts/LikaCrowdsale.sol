pragma solidity ^0.4.18;

//Contract By Yoav Taieb. <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="ef96808e99c186809c8b8a99af88828e8683c18c8082">[emailÂ protected]</a>&#13;
&#13;
library SafeMath {&#13;
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
    uint256 c = a * b;&#13;
    assert(a == 0 || c / a == b);&#13;
    return c;&#13;
  }&#13;
&#13;
  function div(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
    uint256 c = a / b;&#13;
    return c;&#13;
  }&#13;
&#13;
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
    assert(b &lt;= a);&#13;
    return a - b;&#13;
  }&#13;
&#13;
  function add(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
    uint256 c = a + b;&#13;
    assert(c &gt;= a);&#13;
    return c;&#13;
  }&#13;
}&#13;
&#13;
interface LikaToken {&#13;
    function setLock(bool _newLockState) external returns (bool success);&#13;
    function mint(address _for, uint256 _amount) external returns (bool success);&#13;
    function demint(address _for, uint256 _amount) external returns (bool success);&#13;
    function decimals() view external returns (uint8 decDigits);&#13;
    function totalSupply() view external returns (uint256 supply);&#13;
    function balanceOf(address _owner) view external returns (uint256 balance);&#13;
}&#13;
&#13;
contract LikaCrowdsale {&#13;
    using SafeMath for uint256;&#13;
    //global definisions&#13;
    enum ICOStateEnum {NotStarted, Started, Refunded, Successful}&#13;
&#13;
    address public owner = msg.sender;&#13;
&#13;
    LikaToken public managedTokenLedger;&#13;
&#13;
    string public name = "Lika";&#13;
    string public symbol = "LIK";&#13;
&#13;
    bool public halted = false;&#13;
&#13;
    uint256 public minTokensToBuy = 100;&#13;
&#13;
    uint256 public ICOcontributors = 0;&#13;
&#13;
    uint256 public ICOstart = 1526947200; //17 May 1018 00:00:00 GMT&#13;
    uint256 public ICOend = 1529884800; // 17 June 2018 00:00:00 GMT&#13;
    uint256 public Hardcap = 2000 ether;&#13;
    uint256 public ICOcollected = 0;&#13;
    uint256 public Softcap = 200 ether;&#13;
    uint256 public ICOtokensSold = 0;&#13;
    uint256 public TakedFunds = 0;&#13;
&#13;
    uint256 public bonusState = 0;&#13;
&#13;
    ICOStateEnum public ICOstate = ICOStateEnum.NotStarted;&#13;
&#13;
    uint8 public decimals = 18;&#13;
    uint256 public DECIMAL_MULTIPLIER = 10**uint256(decimals);&#13;
&#13;
    uint256 public ICOprice = uint256(12 ether).div(100000);&#13;
    uint256[4] public ICOamountBonusLimits = [5 ether, 20 ether, 50 ether, 200 ether];&#13;
    uint256[4] public ICOamountBonusMultipierInPercent = [103, 105, 107, 110]; // count bonus&#13;
    uint256[5] public ICOweekBonus = [152, 117, 110, 105, 102]; // time bonus&#13;
&#13;
    mapping(address =&gt; uint256) public weiForRefundICO;&#13;
&#13;
    mapping(address =&gt; uint256) public weiToRecoverICO;&#13;
&#13;
    mapping(address =&gt; uint256) public balancesForICO;&#13;
&#13;
    event Purchased(address indexed _from, uint256 _value);&#13;
&#13;
    function advanceState() public returns (bool success) {&#13;
        transitionState();&#13;
        return true;&#13;
    }&#13;
&#13;
    function transitionState() internal {&#13;
&#13;
      if (now &gt;= ICOstart) {&#13;
            if (ICOstate == ICOStateEnum.NotStarted) {&#13;
                ICOstate = ICOStateEnum.Started;&#13;
            }&#13;
            if (Hardcap &gt; 0 &amp;&amp; ICOcollected &gt;= Hardcap) {&#13;
                ICOstate = ICOStateEnum.Successful;&#13;
            }&#13;
        } if (now &gt;= ICOend) {&#13;
            if (ICOstate == ICOStateEnum.Started) {&#13;
                if (ICOcollected &gt;= Softcap) {&#13;
                    ICOstate = ICOStateEnum.Successful;&#13;
                } else {&#13;
                    ICOstate = ICOStateEnum.Refunded;&#13;
                }&#13;
             }&#13;
         }&#13;
     }&#13;
&#13;
    modifier stateTransition() {&#13;
        transitionState();&#13;
        _;&#13;
        transitionState();&#13;
    }&#13;
&#13;
    modifier notHalted() {&#13;
        require(!halted);&#13;
        _;&#13;
    }&#13;
&#13;
    // Ownership&#13;
&#13;
    event OwnershipTransferred(address indexed viousOwner, address indexed newOwner);&#13;
&#13;
    modifier onlyOwner() {&#13;
        require(msg.sender == owner);&#13;
        _;&#13;
    }&#13;
&#13;
    function transferOwnership(address newOwner) public onlyOwner {&#13;
        require(newOwner != address(0));&#13;
        emit OwnershipTransferred(owner, newOwner);&#13;
        owner = newOwner;&#13;
    }&#13;
&#13;
    function balanceOf(address _owner) view public returns (uint256 balance) {&#13;
        return managedTokenLedger.balanceOf(_owner);&#13;
    }&#13;
&#13;
    function totalSupply() view public returns (uint256 balance) {&#13;
        return managedTokenLedger.totalSupply();&#13;
    }&#13;
&#13;
&#13;
    constructor(address _newLedgerAddress) public {&#13;
        require(_newLedgerAddress != address(0));&#13;
        managedTokenLedger = LikaToken(_newLedgerAddress);&#13;
    }&#13;
&#13;
    function setNameAndTicker(string _name, string _symbol) onlyOwner public returns (bool success) {&#13;
        require(bytes(_name).length &gt; 1);&#13;
        require(bytes(_symbol).length &gt; 1);&#13;
        name = _name;&#13;
        symbol = _symbol;&#13;
        return true;&#13;
    }&#13;
&#13;
    function setBonusState(uint256 _newState) onlyOwner public returns (bool success){&#13;
       bonusState = _newState;&#13;
       return true;&#13;
    }&#13;
&#13;
&#13;
    function setLedger(address _newLedgerAddress) onlyOwner public returns (bool success) {&#13;
        require(_newLedgerAddress != address(0));&#13;
        managedTokenLedger = LikaToken(_newLedgerAddress);&#13;
        return true;&#13;
    }&#13;
&#13;
&#13;
    function () public payable stateTransition notHalted {&#13;
        require(msg.value &gt; 0);&#13;
        require(ICOstate == ICOStateEnum.Started);&#13;
        assert(ICOBuy());&#13;
    }&#13;
&#13;
    function finalize() stateTransition public returns (bool success) {&#13;
        require(ICOstate == ICOStateEnum.Successful);&#13;
        owner.transfer(ICOcollected - TakedFunds);&#13;
        return true;&#13;
    }&#13;
&#13;
    function setHalt(bool _halt) onlyOwner public returns (bool success) {&#13;
        halted = _halt;&#13;
        return true;&#13;
    }&#13;
&#13;
    function calculateAmountBoughtICO(uint256 _weisSentScaled, uint256 _amountBonusMultiplier)&#13;
        view internal returns (uint256 _tokensToBuyScaled, uint256 _weisLeftScaled) {&#13;
        uint256 value = _weisSentScaled;&#13;
        uint256 totalPurchased = 0;&#13;
&#13;
      totalPurchased = value.div(ICOprice);&#13;
	    uint256 weekbonus = getWeekBonus(totalPurchased).sub(totalPurchased);&#13;
	    uint256 forThisRate = totalPurchased.mul(_amountBonusMultiplier).div(100).sub(totalPurchased);&#13;
	    value = _weisSentScaled.sub(totalPurchased.mul(ICOprice));&#13;
      totalPurchased = totalPurchased.add(forThisRate).add(weekbonus);&#13;
&#13;
      return (totalPurchased, value);&#13;
    }&#13;
&#13;
    function getBonusMultipierInPercents(uint256 _sentAmount) public view returns (uint256 _multi) {&#13;
        uint256 bonusMultiplier = 100;&#13;
        for (uint8 i = 0; i &lt; ICOamountBonusLimits.length; i++) {&#13;
            if (_sentAmount &lt; ICOamountBonusLimits[i]) {&#13;
                break;&#13;
            } else {&#13;
                bonusMultiplier = ICOamountBonusMultipierInPercent[i];&#13;
            }&#13;
        }&#13;
        return bonusMultiplier;&#13;
    }&#13;
&#13;
    function getWeekBonus(uint256 amountTokens) internal view returns(uint256 count) {&#13;
        uint256 countCoints = 0;&#13;
        uint256 bonusMultiplier = 100;&#13;
&#13;
        //You can check the current Bonus State on www.LikaCoin.io&#13;
&#13;
        if (bonusState == 0) {&#13;
           countCoints = amountTokens.mul(ICOweekBonus[0]);&#13;
        } else if (bonusState == 1) {&#13;
           countCoints = amountTokens.mul(ICOweekBonus[1] );&#13;
        } else if (bonusState == 2) {&#13;
          countCoints = amountTokens.mul(ICOweekBonus[2] );&#13;
        } else if (bonusState == 3) {&#13;
          countCoints = amountTokens.mul(ICOweekBonus[3] );&#13;
        }else {&#13;
          countCoints = amountTokens.mul(ICOweekBonus[3] );&#13;
        }&#13;
&#13;
        return countCoints.div(bonusMultiplier);&#13;
    }&#13;
&#13;
    function ICOBuy() internal notHalted returns (bool success) {&#13;
        uint256 weisSentScaled = msg.value.mul(DECIMAL_MULTIPLIER);&#13;
        address _for = msg.sender;&#13;
        uint256 amountBonus = getBonusMultipierInPercents(msg.value);&#13;
        uint256 tokensBought;&#13;
        uint256 fundsLeftScaled;&#13;
        (tokensBought, fundsLeftScaled) = calculateAmountBoughtICO(weisSentScaled, amountBonus);&#13;
        if (tokensBought &lt; minTokensToBuy.mul(DECIMAL_MULTIPLIER)) {&#13;
            revert();&#13;
        }&#13;
        uint256 fundsLeft = fundsLeftScaled.div(DECIMAL_MULTIPLIER);&#13;
        uint256 totalSpent = msg.value.sub(fundsLeft);&#13;
        if (balanceOf(_for) == 0) {&#13;
            ICOcontributors = ICOcontributors + 1;&#13;
        }&#13;
        managedTokenLedger.mint(_for, tokensBought);&#13;
        balancesForICO[_for] = balancesForICO[_for].add(tokensBought);&#13;
        weiForRefundICO[_for] = weiForRefundICO[_for].add(totalSpent);&#13;
        weiToRecoverICO[_for] = weiToRecoverICO[_for].add(fundsLeft);&#13;
        emit Purchased(_for, tokensBought);&#13;
        ICOcollected = ICOcollected.add(totalSpent);&#13;
        ICOtokensSold = ICOtokensSold.add(tokensBought);&#13;
        return true;&#13;
   }&#13;
&#13;
    function recoverLeftoversICO() stateTransition notHalted public returns (bool success) {&#13;
        require(ICOstate != ICOStateEnum.NotStarted);&#13;
        uint256 value = weiToRecoverICO[msg.sender];&#13;
        delete weiToRecoverICO[msg.sender];&#13;
        msg.sender.transfer(value);&#13;
        return true;&#13;
    }&#13;
&#13;
    function refundICO(address refundAdress) stateTransition notHalted onlyOwner public returns (bool success) {&#13;
        require(ICOstate == ICOStateEnum.Refunded);&#13;
        uint256 value = weiForRefundICO[refundAdress];&#13;
        delete weiForRefundICO[refundAdress];&#13;
        uint256 tokenValue = balancesForICO[refundAdress];&#13;
        delete balancesForICO[refundAdress];&#13;
        managedTokenLedger.demint(refundAdress, tokenValue);&#13;
        refundAdress.transfer(value);&#13;
        return true;&#13;
    }&#13;
&#13;
    function withdrawFunds() onlyOwner public returns (bool success) {&#13;
        require(Softcap &lt;= ICOcollected);&#13;
        owner.transfer(ICOcollected - TakedFunds);&#13;
        TakedFunds = ICOcollected;&#13;
        return true;&#13;
    }&#13;
&#13;
    function setSoftCap(uint256 _newSoftCap) onlyOwner public returns (bool success) {&#13;
       Softcap = _newSoftCap;&#13;
       return true;&#13;
    }&#13;
&#13;
    function setHardCap(uint256 _newHardCap) onlyOwner public returns (bool success) {&#13;
       Hardcap = _newHardCap;&#13;
       return true;&#13;
    }&#13;
&#13;
    function setEndDate(uint256 _newEndDate) onlyOwner public returns (bool success) {&#13;
          ICOend = _newEndDate;&#13;
          return true;&#13;
    }&#13;
&#13;
&#13;
    function manualSendTokens(address rAddress, uint256 amount) onlyOwner public returns (bool success) {&#13;
        managedTokenLedger.mint(rAddress, amount);&#13;
        balancesForICO[rAddress] = balancesForICO[rAddress].add(amount);&#13;
        emit Purchased(rAddress, amount);&#13;
        ICOtokensSold = ICOtokensSold.add(amount);&#13;
        return true;&#13;
    }&#13;
&#13;
}