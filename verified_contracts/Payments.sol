/**
 * Copyright (c) 2018 blockimmo AG <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="036f6a60666d706643616f6c60686a6e6e6c2d606b">[emailÂ protected]</a>&#13;
 * Non-Profit Open Software License 3.0 (NPOSL-3.0)&#13;
 * https://opensource.org/licenses/NPOSL-3.0&#13;
 */&#13;
 &#13;
&#13;
pragma solidity 0.4.25; &#13;
&#13;
&#13;
/**&#13;
 * @title SafeMath&#13;
 * @dev Math operations with safety checks that throw on error&#13;
 */&#13;
library SafeMath {&#13;
&#13;
  /**&#13;
  * @dev Multiplies two numbers, throws on overflow.&#13;
  */&#13;
  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {&#13;
    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the&#13;
    // benefit is lost if 'b' is also tested.&#13;
    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522&#13;
    if (_a == 0) {&#13;
      return 0;&#13;
    }&#13;
&#13;
    c = _a * _b;&#13;
    assert(c / _a == _b);&#13;
    return c;&#13;
  }&#13;
&#13;
  /**&#13;
  * @dev Integer division of two numbers, truncating the quotient.&#13;
  */&#13;
  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {&#13;
    // assert(_b &gt; 0); // Solidity automatically throws when dividing by 0&#13;
    // uint256 c = _a / _b;&#13;
    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold&#13;
    return _a / _b;&#13;
  }&#13;
&#13;
  /**&#13;
  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).&#13;
  */&#13;
  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {&#13;
    assert(_b &lt;= _a);&#13;
    return _a - _b;&#13;
  }&#13;
&#13;
  /**&#13;
  * @dev Adds two numbers, throws on overflow.&#13;
  */&#13;
  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {&#13;
    c = _a + _b;&#13;
    assert(c &gt;= _a);&#13;
    return c;&#13;
  }&#13;
}&#13;
&#13;
&#13;
/**&#13;
 * @title Ownable&#13;
 * @dev The Ownable contract has an owner address, and provides basic authorization control&#13;
 * functions, this simplifies the implementation of "user permissions".&#13;
 */&#13;
contract Ownable {&#13;
  address public owner;&#13;
&#13;
&#13;
  event OwnershipRenounced(address indexed previousOwner);&#13;
  event OwnershipTransferred(&#13;
    address indexed previousOwner,&#13;
    address indexed newOwner&#13;
  );&#13;
&#13;
&#13;
  /**&#13;
   * @dev The Ownable constructor sets the original `owner` of the contract to the sender&#13;
   * account.&#13;
   */&#13;
  constructor() public {&#13;
    owner = msg.sender;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Throws if called by any account other than the owner.&#13;
   */&#13;
  modifier onlyOwner() {&#13;
    require(msg.sender == owner);&#13;
    _;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Allows the current owner to relinquish control of the contract.&#13;
   * @notice Renouncing to ownership will leave the contract without an owner.&#13;
   * It will not be possible to call the functions with the `onlyOwner`&#13;
   * modifier anymore.&#13;
   */&#13;
  function renounceOwnership() public onlyOwner {&#13;
    emit OwnershipRenounced(owner);&#13;
    owner = address(0);&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Allows the current owner to transfer control of the contract to a newOwner.&#13;
   * @param _newOwner The address to transfer ownership to.&#13;
   */&#13;
  function transferOwnership(address _newOwner) public onlyOwner {&#13;
    _transferOwnership(_newOwner);&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Transfers control of the contract to a newOwner.&#13;
   * @param _newOwner The address to transfer ownership to.&#13;
   */&#13;
  function _transferOwnership(address _newOwner) internal {&#13;
    require(_newOwner != address(0));&#13;
    emit OwnershipTransferred(owner, _newOwner);&#13;
    owner = _newOwner;&#13;
  }&#13;
}&#13;
&#13;
&#13;
/**&#13;
 * @title SplitPayment&#13;
 * @dev Base contract that supports multiple payees claiming funds sent to this contract&#13;
 * according to the proportion they own.&#13;
 */&#13;
contract SplitPayment {&#13;
  using SafeMath for uint256;&#13;
&#13;
  uint256 public totalShares = 0;&#13;
  uint256 public totalReleased = 0;&#13;
&#13;
  mapping(address =&gt; uint256) public shares;&#13;
  mapping(address =&gt; uint256) public released;&#13;
  address[] public payees;&#13;
&#13;
  /**&#13;
   * @dev Constructor&#13;
   */&#13;
  constructor(address[] _payees, uint256[] _shares) public payable {&#13;
    require(_payees.length == _shares.length);&#13;
&#13;
    for (uint256 i = 0; i &lt; _payees.length; i++) {&#13;
      addPayee(_payees[i], _shares[i]);&#13;
    }&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev payable fallback&#13;
   */&#13;
  function () external payable {}&#13;
&#13;
  /**&#13;
   * @dev Claim your share of the balance.&#13;
   */&#13;
  function claim() public {&#13;
    address payee = msg.sender;&#13;
&#13;
    require(shares[payee] &gt; 0);&#13;
&#13;
    uint256 totalReceived = address(this).balance.add(totalReleased);&#13;
    uint256 payment = totalReceived.mul(&#13;
      shares[payee]).div(&#13;
        totalShares).sub(&#13;
          released[payee]&#13;
    );&#13;
&#13;
    require(payment != 0);&#13;
    require(address(this).balance &gt;= payment);&#13;
&#13;
    released[payee] = released[payee].add(payment);&#13;
    totalReleased = totalReleased.add(payment);&#13;
&#13;
    payee.transfer(payment);&#13;
  }&#13;
&#13;
&#13;
  /**&#13;
   * @dev Add a new payee to the contract.&#13;
   * @param _payee The address of the payee to add.&#13;
   * @param _shares The number of shares owned by the payee.&#13;
   */&#13;
  function addPayee(address _payee, uint256 _shares) internal {&#13;
    require(_payee != address(0));&#13;
    require(_shares &gt; 0);&#13;
    require(shares[_payee] == 0);&#13;
&#13;
    payees.push(_payee);&#13;
    shares[_payee] = _shares;&#13;
    totalShares = totalShares.add(_shares);&#13;
  }&#13;
}&#13;
&#13;
&#13;
contract Payments is Ownable, SplitPayment {&#13;
  constructor() public SplitPayment(new address[](0), new uint256[](0)) { }&#13;
&#13;
  function addPayment(address _payee, uint256 _amount) public onlyOwner {&#13;
    addPayee(_payee, _amount);&#13;
  }&#13;
}