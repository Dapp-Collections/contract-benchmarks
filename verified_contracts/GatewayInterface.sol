pragma solidity ^0.4.17;

/*

 * source       https://github.com/blockbitsio/

 * @name        Application Entity Generic Contract
 * @package     BlockBitsIO
 * @author      Micky Socaci <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="92fffbf1f9ebd2fcfde5fefbe4f7bce0fd">[email protected]</a>&gt;&#13;
&#13;
    Used for the ABI interface when assets need to call Application Entity.&#13;
&#13;
    This is required, otherwise we end up loading the assets themselves when we load the ApplicationEntity contract&#13;
    and end up in a loop&#13;
*/&#13;
&#13;
&#13;
&#13;
contract ApplicationEntityABI {&#13;
&#13;
    address public ProposalsEntity;&#13;
    address public FundingEntity;&#13;
    address public MilestonesEntity;&#13;
    address public MeetingsEntity;&#13;
    address public BountyManagerEntity;&#13;
    address public TokenManagerEntity;&#13;
    address public ListingContractEntity;&#13;
    address public FundingManagerEntity;&#13;
    address public NewsContractEntity;&#13;
&#13;
    bool public _initialized = false;&#13;
    bool public _locked = false;&#13;
    uint8 public CurrentEntityState;&#13;
    uint8 public AssetCollectionNum;&#13;
    address public GatewayInterfaceAddress;&#13;
    address public deployerAddress;&#13;
    address testAddressAllowUpgradeFrom;&#13;
    mapping (bytes32 =&gt; uint8) public EntityStates;&#13;
    mapping (bytes32 =&gt; address) public AssetCollection;&#13;
    mapping (uint8 =&gt; bytes32) public AssetCollectionIdToName;&#13;
    mapping (bytes32 =&gt; uint256) public BylawsUint256;&#13;
    mapping (bytes32 =&gt; bytes32) public BylawsBytes32;&#13;
&#13;
    function ApplicationEntity() public;&#13;
    function getEntityState(bytes32 name) public view returns (uint8);&#13;
    function linkToGateway( address _GatewayInterfaceAddress, bytes32 _sourceCodeUrl ) external;&#13;
    function setUpgradeState(uint8 state) public ;&#13;
    function addAssetProposals(address _assetAddresses) external;&#13;
    function addAssetFunding(address _assetAddresses) external;&#13;
    function addAssetMilestones(address _assetAddresses) external;&#13;
    function addAssetMeetings(address _assetAddresses) external;&#13;
    function addAssetBountyManager(address _assetAddresses) external;&#13;
    function addAssetTokenManager(address _assetAddresses) external;&#13;
    function addAssetFundingManager(address _assetAddresses) external;&#13;
    function addAssetListingContract(address _assetAddresses) external;&#13;
    function addAssetNewsContract(address _assetAddresses) external;&#13;
    function getAssetAddressByName(bytes32 _name) public view returns (address);&#13;
    function setBylawUint256(bytes32 name, uint256 value) public;&#13;
    function getBylawUint256(bytes32 name) public view returns (uint256);&#13;
    function setBylawBytes32(bytes32 name, bytes32 value) public;&#13;
    function getBylawBytes32(bytes32 name) public view returns (bytes32);&#13;
    function initialize() external returns (bool);&#13;
    function getParentAddress() external view returns(address);&#13;
    function createCodeUpgradeProposal( address _newAddress, bytes32 _sourceCodeUrl ) external returns (uint256);&#13;
    function acceptCodeUpgradeProposal(address _newAddress) external;&#13;
    function initializeAssetsToThisApplication() external returns (bool);&#13;
    function transferAssetsToNewApplication(address _newAddress) external returns (bool);&#13;
    function lock() external returns (bool);&#13;
    function canInitiateCodeUpgrade(address _sender) public view returns(bool);&#13;
    function doStateChanges() public;&#13;
    function hasRequiredStateChanges() public view returns (bool);&#13;
    function anyAssetHasChanges() public view returns (bool);&#13;
    function extendedAnyAssetHasChanges() internal view returns (bool);&#13;
    function getRequiredStateChanges() public view returns (uint8, uint8);&#13;
    function getTimestamp() view public returns (uint256);&#13;
&#13;
}&#13;
&#13;
/*&#13;
&#13;
 * source       https://github.com/blockbitsio/&#13;
&#13;
 * @name        Gateway Interface Contract&#13;
 * @package     BlockBitsIO&#13;
 * @author      Micky Socaci &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="f895919b9381b896978f94918e9dd68a97">[email protected]</a>&gt;&#13;
&#13;
 Used as a resolver to retrieve the latest deployed version of the Application&#13;
&#13;
 ENS: gateway.main.blockbits.eth will point directly to this contract.&#13;
&#13;
    ADD ENS domain ownership / transfer methods&#13;
&#13;
*/&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
contract GatewayInterface {&#13;
&#13;
    event EventGatewayNewLinkRequest ( address indexed newAddress );&#13;
    event EventGatewayNewAddress ( address indexed newAddress );&#13;
&#13;
    address public currentApplicationEntityAddress;&#13;
    ApplicationEntityABI private currentApp;&#13;
&#13;
    address public deployerAddress;&#13;
&#13;
    function GatewayInterface() public {&#13;
        deployerAddress = msg.sender;&#13;
    }&#13;
&#13;
    /**&#13;
    @notice Get current ApplicationEntity Contract address&#13;
    @return {&#13;
        "currentApplicationEntityAddress": Currently bound application address&#13;
    }&#13;
    */&#13;
    function getApplicationAddress() external view returns (address) {&#13;
        return currentApplicationEntityAddress;&#13;
    }&#13;
&#13;
&#13;
    /**&#13;
    @notice ApplicationEntity Contract requests to be linked&#13;
    @dev modifier validCodeUpgradeInitiator&#13;
    @param _newAddress address, The address of the application contract&#13;
    @param _sourceCodeUrl bytes32, The url of the application source code on etherscan&#13;
    @return {&#13;
        "bool": TRUE if successfully processed&#13;
    }&#13;
    */&#13;
    function requestCodeUpgrade( address _newAddress, bytes32 _sourceCodeUrl )&#13;
        external&#13;
        validCodeUpgradeInitiator&#13;
        returns (bool)&#13;
    {&#13;
        require(_newAddress != address(0x0));&#13;
&#13;
        EventGatewayNewLinkRequest ( _newAddress );&#13;
&#13;
        /*&#13;
            case 1 - Newly Deployed Gateway and Application&#13;
&#13;
            gateway links to app and initializes&#13;
        */&#13;
        if(currentApplicationEntityAddress == address(0x0)) {&#13;
&#13;
            if(!ApplicationEntityABI(_newAddress).initializeAssetsToThisApplication()) {&#13;
                revert();&#13;
            }&#13;
            link(_newAddress);&#13;
            return true;&#13;
        } else {&#13;
            /*&#13;
                case 2 - Actual Code Upgrade Request&#13;
&#13;
                - Current app should exist already&#13;
                - Current app&#13;
                    - Create a proposal&#13;
                    - Vote on result&#13;
                    - Get Result&#13;
                    - Approve Result&#13;
            */&#13;
            currentApp.createCodeUpgradeProposal(_newAddress, _sourceCodeUrl);&#13;
        }&#13;
    }&#13;
&#13;
    /**&#13;
    @notice ApplicationEntity Contract approves code Upgrade&#13;
    @dev modifier onlyCurrentApplicationEntity&#13;
    @param _newAddress address, The address of the new application contract&#13;
    @return {&#13;
        "bool": TRUE if successfully processed&#13;
    }&#13;
    */&#13;
    function approveCodeUpgrade( address _newAddress ) external returns (bool) {&#13;
        require(msg.sender == currentApplicationEntityAddress);&#13;
        uint8 atState = currentApp.CurrentEntityState();&#13;
        lockCurrentApp();&#13;
        if(!currentApp.transferAssetsToNewApplication(_newAddress)) {&#13;
            revert();&#13;
        }&#13;
        link(_newAddress);&#13;
        currentApp.setUpgradeState( atState );&#13;
        return true;&#13;
    }&#13;
&#13;
    /**&#13;
    @notice Locks current application entity&#13;
    @dev Internally used by gateway to lock current application entity before switching to the new one&#13;
    */&#13;
    function lockCurrentApp() internal {&#13;
        if(!currentApp.lock()) {&#13;
            revert();&#13;
        }&#13;
    }&#13;
&#13;
    /**&#13;
    @notice Link to new Application Entity&#13;
    @param _newAddress address, The address of the new application contract&#13;
    @return {&#13;
        "bool": TRUE if successfully processed&#13;
    }&#13;
    */&#13;
    function link( address _newAddress ) internal returns (bool) {&#13;
&#13;
        currentApplicationEntityAddress = _newAddress;&#13;
        currentApp = ApplicationEntityABI(currentApplicationEntityAddress);&#13;
        if( !currentApp.initialize() ) {&#13;
            revert();&#13;
        }&#13;
        EventGatewayNewAddress(currentApplicationEntityAddress);&#13;
        return true;&#13;
    }&#13;
&#13;
&#13;
    /**&#13;
    @notice Get current News Contract address&#13;
    @return {&#13;
        "address": 0x address of the News Contract&#13;
    }&#13;
    */&#13;
    function getNewsContractAddress() external view returns (address) {&#13;
        return currentApp.NewsContractEntity();&#13;
    }&#13;
&#13;
    /**&#13;
    @notice Get current Listing Contract address&#13;
    @return {&#13;
        "address": 0x address of the Listing Contract&#13;
    }&#13;
    */&#13;
    function getListingContractAddress() external view returns (address) {&#13;
        return currentApp.ListingContractEntity();&#13;
    }&#13;
&#13;
    /*&#13;
    * Validates if new application's deployer is allowed to upgrade current app&#13;
    */&#13;
&#13;
    /**&#13;
    @notice Validates if new application's deployer is allowed to upgrade current app&#13;
    */&#13;
    modifier validCodeUpgradeInitiator() {&#13;
        bool valid = false;&#13;
&#13;
        ApplicationEntityABI newDeployedApp = ApplicationEntityABI(msg.sender);&#13;
        address newDeployer = newDeployedApp.deployerAddress();&#13;
&#13;
        if(newDeployer == deployerAddress) {&#13;
            valid = true;&#13;
        } else {&#13;
            if(currentApplicationEntityAddress != address(0x0)) {&#13;
                currentApp = ApplicationEntityABI(currentApplicationEntityAddress);&#13;
                if(currentApp.canInitiateCodeUpgrade(newDeployer)) {&#13;
                    valid = true;&#13;
                }&#13;
            }&#13;
        }&#13;
&#13;
        // ok if current app accepts newDeployer as a token holder that can do a code upgrade&#13;
        // ok if newDeployer is oldDeployer&#13;
        require( valid == true );&#13;
        _;&#13;
    }&#13;
}