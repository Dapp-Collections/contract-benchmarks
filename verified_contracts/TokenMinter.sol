/**
 * TokenMinter.sol
 * MPS Token (Mt Pelerin Share) token minter.

 * More info about MPS : https://github.com/MtPelerin/MtPelerin-share-MPS

 * The unflattened code is available through this github tag:
 * https://github.com/MtPelerin/MtPelerin-protocol/tree/etherscan-verify-batch-1

 * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved

 * @notice All matters regarding the intellectual property of this code 
 * @notice or software are subject to Swiss Law without reference to its 
 * @notice conflicts of law rules.

 * @notice License for each contract is available in the respective file
 * @notice or in the LICENSE.md file.
 * @notice https://github.com/MtPelerin/

 * @notice Code by OpenZeppelin is copyrighted and licensed on their repository:
 * @notice https://github.com/OpenZeppelin/openzeppelin-solidity
 */


pragma solidity ^0.4.24;

// File: contracts/zeppelin/ownership/Ownable.sol

/**
 * @title Ownable
 * @dev The Ownable contract has an owner address, and provides basic authorization control
 * functions, this simplifies the implementation of "user permissions".
 */
contract Ownable {
  address public owner;


  event OwnershipRenounced(address indexed previousOwner);
  event OwnershipTransferred(
    address indexed previousOwner,
    address indexed newOwner
  );


  /**
   * @dev The Ownable constructor sets the original `owner` of the contract to the sender
   * account.
   */
  constructor() public {
    owner = msg.sender;
  }

  /**
   * @dev Throws if called by any account other than the owner.
   */
  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }

  /**
   * @dev Allows the current owner to relinquish control of the contract.
   */
  function renounceOwnership() public onlyOwner {
    emit OwnershipRenounced(owner);
    owner = address(0);
  }

  /**
   * @dev Allows the current owner to transfer control of the contract to a newOwner.
   * @param _newOwner The address to transfer ownership to.
   */
  function transferOwnership(address _newOwner) public onlyOwner {
    _transferOwnership(_newOwner);
  }

  /**
   * @dev Transfers control of the contract to a newOwner.
   * @param _newOwner The address to transfer ownership to.
   */
  function _transferOwnership(address _newOwner) internal {
    require(_newOwner != address(0));
    emit OwnershipTransferred(owner, _newOwner);
    owner = _newOwner;
  }
}

// File: contracts/zeppelin/math/SafeMath.sol

/**
 * @title SafeMath
 * @dev Math operations with safety checks that throw on error
 */
library SafeMath {

  /**
  * @dev Multiplies two numbers, throws on overflow.
  */
  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {
    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the
    // benefit is lost if 'b' is also tested.
    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
    if (a == 0) {
      return 0;
    }

    c = a * b;
    assert(c / a == b);
    return c;
  }

  /**
  * @dev Integer division of two numbers, truncating the quotient.
  */
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    // assert(b > 0); // Solidity automatically throws when dividing by 0
    // uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return a / b;
  }

  /**
  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).
  */
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  /**
  * @dev Adds two numbers, throws on overflow.
  */
  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
    c = a + b;
    assert(c >= a);
    return c;
  }
}

// File: contracts/interface/IMintable.sol

/**
 * @title Mintable interface
 *
 * @author Cyril Lapinte - <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="61021813080d4f0d0011080f1504210c1511040d0413080f4f020e0c">[email protected]</a>&gt;&#13;
 *&#13;
 * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved&#13;
 * @notice Please refer to the top of this file for the license.&#13;
 */&#13;
contract IMintable {&#13;
  function mintingFinished() public view returns (bool);&#13;
&#13;
  function mint(address _to, uint256 _amount) public returns (bool);&#13;
  function finishMinting() public returns (bool);&#13;
 &#13;
  event Mint(address indexed to, uint256 amount);&#13;
  event MintFinished();&#13;
}&#13;
&#13;
// File: contracts/interface/IMintableByLot.sol&#13;
&#13;
/**&#13;
 * @title MintableByLot interface&#13;
 *&#13;
 * @author Cyril Lapinte - &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="ea8993988386c4868b9a83849e8faa879e9a8f868f988384c4898587">[email protected]</a>&gt;&#13;
 *&#13;
 * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved&#13;
 * @notice Please refer to the top of this file for the license.&#13;
 */&#13;
contract IMintableByLot is IMintable {&#13;
  function minterLotId(address _minter) public view returns (uint256);&#13;
}&#13;
&#13;
// File: contracts/zeppelin/token/ERC20/ERC20Basic.sol&#13;
&#13;
/**&#13;
 * @title ERC20Basic&#13;
 * @dev Simpler version of ERC20 interface&#13;
 * @dev see https://github.com/ethereum/EIPs/issues/179&#13;
 */&#13;
contract ERC20Basic {&#13;
  function totalSupply() public view returns (uint256);&#13;
  function balanceOf(address who) public view returns (uint256);&#13;
  function transfer(address to, uint256 value) public returns (bool);&#13;
  event Transfer(address indexed from, address indexed to, uint256 value);&#13;
}&#13;
&#13;
// File: contracts/zeppelin/token/ERC20/BasicToken.sol&#13;
&#13;
/**&#13;
 * @title Basic token&#13;
 * @dev Basic version of StandardToken, with no allowances.&#13;
 */&#13;
contract BasicToken is ERC20Basic {&#13;
  using SafeMath for uint256;&#13;
&#13;
  mapping(address =&gt; uint256) balances;&#13;
&#13;
  uint256 totalSupply_;&#13;
&#13;
  /**&#13;
  * @dev total number of tokens in existence&#13;
  */&#13;
  function totalSupply() public view returns (uint256) {&#13;
    return totalSupply_;&#13;
  }&#13;
&#13;
  /**&#13;
  * @dev transfer token for a specified address&#13;
  * @param _to The address to transfer to.&#13;
  * @param _value The amount to be transferred.&#13;
  */&#13;
  function transfer(address _to, uint256 _value) public returns (bool) {&#13;
    require(_to != address(0));&#13;
    require(_value &lt;= balances[msg.sender]);&#13;
&#13;
    balances[msg.sender] = balances[msg.sender].sub(_value);&#13;
    balances[_to] = balances[_to].add(_value);&#13;
    emit Transfer(msg.sender, _to, _value);&#13;
    return true;&#13;
  }&#13;
&#13;
  /**&#13;
  * @dev Gets the balance of the specified address.&#13;
  * @param _owner The address to query the the balance of.&#13;
  * @return An uint256 representing the amount owned by the passed address.&#13;
  */&#13;
  function balanceOf(address _owner) public view returns (uint256) {&#13;
    return balances[_owner];&#13;
  }&#13;
&#13;
}&#13;
&#13;
// File: contracts/interface/ISeizable.sol&#13;
&#13;
/**&#13;
 * @title ISeizable&#13;
 * @dev ISeizable interface&#13;
 * @author Cyril Lapinte - &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="2a495358434604464b5a43445e4f6a475e5a4f464f58434404494547">[email protected]</a>&gt;&#13;
 *&#13;
 * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved&#13;
 * @notice Please refer to the top of this file for the license.&#13;
 **/&#13;
contract ISeizable {&#13;
  function seize(address _account, uint256 _value) public;&#13;
  event Seize(address account, uint256 amount);&#13;
}&#13;
&#13;
// File: contracts/Authority.sol&#13;
&#13;
/**&#13;
 * @title Authority&#13;
 * @dev The Authority contract has an authority address, and provides basic authorization control&#13;
 * functions, this simplifies the implementation of "user permissions".&#13;
 * Authority means to represent a legal entity that is entitled to specific rights&#13;
 *&#13;
 * @author Cyril Lapinte - &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="50332922393c7e3c3120393e2435103d2420353c3522393e7e333f3d">[email protected]</a>&gt;&#13;
 *&#13;
 * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved&#13;
 * @notice Please refer to the top of this file for the license.&#13;
 *&#13;
 * Error messages&#13;
 * AU01: Message sender must be an authority&#13;
 */&#13;
contract Authority is Ownable {&#13;
&#13;
  address authority;&#13;
&#13;
  /**&#13;
   * @dev Throws if called by any account other than the authority.&#13;
   */&#13;
  modifier onlyAuthority {&#13;
    require(msg.sender == authority, "AU01");&#13;
    _;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev return the address associated to the authority&#13;
   */&#13;
  function authorityAddress() public view returns (address) {&#13;
    return authority;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev rdefines an authority&#13;
   * @param _name the authority name&#13;
   * @param _address the authority address.&#13;
   */&#13;
  function defineAuthority(string _name, address _address) public onlyOwner {&#13;
    emit AuthorityDefined(_name, _address);&#13;
    authority = _address;&#13;
  }&#13;
&#13;
  event AuthorityDefined(&#13;
    string name,&#13;
    address _address&#13;
  );&#13;
}&#13;
&#13;
// File: contracts/token/component/SeizableToken.sol&#13;
&#13;
/**&#13;
 * @title SeizableToken&#13;
 * @dev BasicToken contract which allows owner to seize accounts&#13;
 * @author Cyril Lapinte - &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="31524843585d1f5d5041585f4554715c4541545d5443585f1f525e5c">[email protected]</a>&gt;&#13;
 *&#13;
 * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved&#13;
 * @notice Please refer to the top of this file for the license.&#13;
 *&#13;
 * Error messages&#13;
 * ST01: Owner cannot seize itself&#13;
*/&#13;
contract SeizableToken is BasicToken, Authority, ISeizable {&#13;
  using SafeMath for uint256;&#13;
&#13;
  // Although very unlikely, the value below may overflow.&#13;
  // This contract and its children should expect it to happened and consider&#13;
  // this value as only the first 256 bits of the complete value.&#13;
  uint256 public allTimeSeized = 0; // overflow may happend&#13;
&#13;
  /**&#13;
   * @dev called by the owner to seize value from the account&#13;
   */&#13;
  function seize(address _account, uint256 _value)&#13;
    public onlyAuthority&#13;
  {&#13;
    require(_account != owner, "ST01");&#13;
&#13;
    balances[_account] = balances[_account].sub(_value);&#13;
    balances[authority] = balances[authority].add(_value);&#13;
&#13;
    allTimeSeized += _value;&#13;
    emit Seize(_account, _value);&#13;
  }&#13;
}&#13;
&#13;
// File: contracts/zeppelin/token/ERC20/ERC20.sol&#13;
&#13;
/**&#13;
 * @title ERC20 interface&#13;
 * @dev see https://github.com/ethereum/EIPs/issues/20&#13;
 */&#13;
contract ERC20 is ERC20Basic {&#13;
  function allowance(address owner, address spender)&#13;
    public view returns (uint256);&#13;
&#13;
  function transferFrom(address from, address to, uint256 value)&#13;
    public returns (bool);&#13;
&#13;
  function approve(address spender, uint256 value) public returns (bool);&#13;
  event Approval(&#13;
    address indexed owner,&#13;
    address indexed spender,&#13;
    uint256 value&#13;
  );&#13;
}&#13;
&#13;
// File: contracts/zeppelin/token/ERC20/StandardToken.sol&#13;
&#13;
/**&#13;
 * @title Standard ERC20 token&#13;
 *&#13;
 * @dev Implementation of the basic standard token.&#13;
 * @dev https://github.com/ethereum/EIPs/issues/20&#13;
 * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol&#13;
 */&#13;
contract StandardToken is ERC20, BasicToken {&#13;
&#13;
  mapping (address =&gt; mapping (address =&gt; uint256)) internal allowed;&#13;
&#13;
&#13;
  /**&#13;
   * @dev Transfer tokens from one address to another&#13;
   * @param _from address The address which you want to send tokens from&#13;
   * @param _to address The address which you want to transfer to&#13;
   * @param _value uint256 the amount of tokens to be transferred&#13;
   */&#13;
  function transferFrom(&#13;
    address _from,&#13;
    address _to,&#13;
    uint256 _value&#13;
  )&#13;
    public&#13;
    returns (bool)&#13;
  {&#13;
    require(_to != address(0));&#13;
    require(_value &lt;= balances[_from]);&#13;
    require(_value &lt;= allowed[_from][msg.sender]);&#13;
&#13;
    balances[_from] = balances[_from].sub(_value);&#13;
    balances[_to] = balances[_to].add(_value);&#13;
    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);&#13;
    emit Transfer(_from, _to, _value);&#13;
    return true;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.&#13;
   *&#13;
   * Beware that changing an allowance with this method brings the risk that someone may use both the old&#13;
   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this&#13;
   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:&#13;
   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729&#13;
   * @param _spender The address which will spend the funds.&#13;
   * @param _value The amount of tokens to be spent.&#13;
   */&#13;
  function approve(address _spender, uint256 _value) public returns (bool) {&#13;
    allowed[msg.sender][_spender] = _value;&#13;
    emit Approval(msg.sender, _spender, _value);&#13;
    return true;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Function to check the amount of tokens that an owner allowed to a spender.&#13;
   * @param _owner address The address which owns the funds.&#13;
   * @param _spender address The address which will spend the funds.&#13;
   * @return A uint256 specifying the amount of tokens still available for the spender.&#13;
   */&#13;
  function allowance(&#13;
    address _owner,&#13;
    address _spender&#13;
   )&#13;
    public&#13;
    view&#13;
    returns (uint256)&#13;
  {&#13;
    return allowed[_owner][_spender];&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Increase the amount of tokens that an owner allowed to a spender.&#13;
   *&#13;
   * approve should be called when allowed[_spender] == 0. To increment&#13;
   * allowed value is better to use this function to avoid 2 calls (and wait until&#13;
   * the first transaction is mined)&#13;
   * From MonolithDAO Token.sol&#13;
   * @param _spender The address which will spend the funds.&#13;
   * @param _addedValue The amount of tokens to increase the allowance by.&#13;
   */&#13;
  function increaseApproval(&#13;
    address _spender,&#13;
    uint _addedValue&#13;
  )&#13;
    public&#13;
    returns (bool)&#13;
  {&#13;
    allowed[msg.sender][_spender] = (&#13;
      allowed[msg.sender][_spender].add(_addedValue));&#13;
    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);&#13;
    return true;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Decrease the amount of tokens that an owner allowed to a spender.&#13;
   *&#13;
   * approve should be called when allowed[_spender] == 0. To decrement&#13;
   * allowed value is better to use this function to avoid 2 calls (and wait until&#13;
   * the first transaction is mined)&#13;
   * From MonolithDAO Token.sol&#13;
   * @param _spender The address which will spend the funds.&#13;
   * @param _subtractedValue The amount of tokens to decrease the allowance by.&#13;
   */&#13;
  function decreaseApproval(&#13;
    address _spender,&#13;
    uint _subtractedValue&#13;
  )&#13;
    public&#13;
    returns (bool)&#13;
  {&#13;
    uint oldValue = allowed[msg.sender][_spender];&#13;
    if (_subtractedValue &gt; oldValue) {&#13;
      allowed[msg.sender][_spender] = 0;&#13;
    } else {&#13;
      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);&#13;
    }&#13;
    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);&#13;
    return true;&#13;
  }&#13;
&#13;
}&#13;
&#13;
// File: contracts/interface/IProvableOwnership.sol&#13;
&#13;
/**&#13;
 * @title IProvableOwnership&#13;
 * @dev IProvableOwnership interface which describe proof of ownership.&#13;
 * @author Cyril Lapinte - &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="690a101b00054705081900071d0c29041d190c050c1b0007470a0604">[email protected]</a>&gt;&#13;
 *&#13;
 * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved&#13;
 * @notice Please refer to the top of this file for the license.&#13;
 **/&#13;
contract IProvableOwnership {&#13;
  function proofLength(address _holder) public view returns (uint256);&#13;
  function proofAmount(address _holder, uint256 _proofId)&#13;
    public view returns (uint256);&#13;
&#13;
  function proofDateFrom(address _holder, uint256 _proofId)&#13;
    public view returns (uint256);&#13;
&#13;
  function proofDateTo(address _holder, uint256 _proofId)&#13;
    public view returns (uint256);&#13;
&#13;
  function createProof(address _holder) public;&#13;
  function checkProof(address _holder, uint256 _proofId, uint256 _at)&#13;
    public view returns (uint256);&#13;
&#13;
  function transferWithProofs(&#13;
    address _to,&#13;
    uint256 _value,&#13;
    bool _proofFrom,&#13;
    bool _proofTo&#13;
    ) public returns (bool);&#13;
&#13;
  function transferFromWithProofs(&#13;
    address _from,&#13;
    address _to,&#13;
    uint256 _value,&#13;
    bool _proofFrom,&#13;
    bool _proofTo&#13;
    ) public returns (bool);&#13;
&#13;
  event ProofOfOwnership(address indexed holder, uint256 proofId);&#13;
}&#13;
&#13;
// File: contracts/interface/IAuditableToken.sol&#13;
&#13;
/**&#13;
 * @title IAuditableToken&#13;
 * @dev IAuditableToken interface describing the audited data&#13;
 * @author Cyril Lapinte - &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="c0a3b9b2a9aceeaca1b0a9aeb4a580adb4b0a5aca5b2a9aeeea3afad">[email protected]</a>&gt;&#13;
 *&#13;
 * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved&#13;
 * @notice Please refer to the top of this file for the license.&#13;
 **/&#13;
contract IAuditableToken {&#13;
  function lastTransactionAt(address _address) public view returns (uint256);&#13;
  function lastReceivedAt(address _address) public view returns (uint256);&#13;
  function lastSentAt(address _address) public view returns (uint256);&#13;
  function transactionCount(address _address) public view returns (uint256);&#13;
  function receivedCount(address _address) public view returns (uint256);&#13;
  function sentCount(address _address) public view returns (uint256);&#13;
  function totalReceivedAmount(address _address) public view returns (uint256);&#13;
  function totalSentAmount(address _address) public view returns (uint256);&#13;
}&#13;
&#13;
// File: contracts/token/component/AuditableToken.sol&#13;
&#13;
/**&#13;
 * @title AuditableToken&#13;
 * @dev AuditableToken contract&#13;
 * AuditableToken provides transaction data which can be used&#13;
 * in other smart contracts&#13;
 *&#13;
 * @author Cyril Lapinte - &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="82e1fbf0ebeeaceee3f2ebecf6e7c2eff6f2e7eee7f0ebecace1edef">[email protected]</a>&gt;&#13;
 *&#13;
 * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved&#13;
 * @notice Please refer to the top of this file for the license.&#13;
 **/&#13;
contract AuditableToken is IAuditableToken, StandardToken {&#13;
&#13;
   // Although very unlikely, the following values below may overflow:&#13;
   //   receivedCount, sentCount, totalReceivedAmount, totalSentAmount&#13;
   // This contract and its children should expect it to happen and consider&#13;
   // these values as only the first 256 bits of the complete value.&#13;
  struct Audit {&#13;
    uint256 createdAt;&#13;
    uint256 lastReceivedAt;&#13;
    uint256 lastSentAt;&#13;
    uint256 receivedCount; // potential overflow&#13;
    uint256 sentCount; // poential overflow&#13;
    uint256 totalReceivedAmount; // potential overflow&#13;
    uint256 totalSentAmount; // potential overflow&#13;
  }&#13;
  mapping(address =&gt; Audit) internal audits;&#13;
&#13;
  /**&#13;
   * @dev Time of the creation of the audit struct&#13;
   */&#13;
  function auditCreatedAt(address _address) public view returns (uint256) {&#13;
    return audits[_address].createdAt;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Time of the last transaction&#13;
   */&#13;
  function lastTransactionAt(address _address) public view returns (uint256) {&#13;
    return ( audits[_address].lastReceivedAt &gt; audits[_address].lastSentAt ) ?&#13;
      audits[_address].lastReceivedAt : audits[_address].lastSentAt;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Time of the last received transaction&#13;
   */&#13;
  function lastReceivedAt(address _address) public view returns (uint256) {&#13;
    return audits[_address].lastReceivedAt;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Time of the last sent transaction&#13;
   */&#13;
  function lastSentAt(address _address) public view returns (uint256) {&#13;
    return audits[_address].lastSentAt;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Count of transactions&#13;
   */&#13;
  function transactionCount(address _address) public view returns (uint256) {&#13;
    return audits[_address].receivedCount + audits[_address].sentCount;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Count of received transactions&#13;
   */&#13;
  function receivedCount(address _address) public view returns (uint256) {&#13;
    return audits[_address].receivedCount;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Count of sent transactions&#13;
   */&#13;
  function sentCount(address _address) public view returns (uint256) {&#13;
    return audits[_address].sentCount;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev All time received&#13;
   */&#13;
  function totalReceivedAmount(address _address)&#13;
    public view returns (uint256)&#13;
  {&#13;
    return audits[_address].totalReceivedAmount;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev All time sent&#13;
   */&#13;
  function totalSentAmount(address _address) public view returns (uint256) {&#13;
    return audits[_address].totalSentAmount;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Overriden transfer function&#13;
   */&#13;
  function transfer(address _to, uint256 _value) public returns (bool) {&#13;
    if (!super.transfer(_to, _value)) {&#13;
      return false;&#13;
    }&#13;
    updateAudit(msg.sender, _to, _value);&#13;
    return true;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Overriden transferFrom function&#13;
   */&#13;
  function transferFrom(address _from, address _to, uint256 _value)&#13;
    public returns (bool)&#13;
  {&#13;
    if (!super.transferFrom(_from, _to, _value)) {&#13;
      return false;&#13;
    }&#13;
&#13;
    updateAudit(_from, _to, _value);&#13;
    return true;&#13;
  }&#13;
&#13;
 /**&#13;
   * @dev currentTime()&#13;
   */&#13;
  function currentTime() internal view returns (uint256) {&#13;
    // solium-disable-next-line security/no-block-members&#13;
    return now;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Update audit data&#13;
   */&#13;
  function updateAudit(address _sender, address _receiver, uint256 _value)&#13;
    private returns (uint256)&#13;
  {&#13;
    Audit storage senderAudit = audits[_sender];&#13;
    senderAudit.lastSentAt = currentTime();&#13;
    senderAudit.sentCount++;&#13;
    senderAudit.totalSentAmount += _value;&#13;
    if (senderAudit.createdAt == 0) {&#13;
      senderAudit.createdAt = currentTime();&#13;
    }&#13;
&#13;
    Audit storage receiverAudit = audits[_receiver];&#13;
    receiverAudit.lastReceivedAt = currentTime();&#13;
    receiverAudit.receivedCount++;&#13;
    receiverAudit.totalReceivedAmount += _value;&#13;
    if (receiverAudit.createdAt == 0) {&#13;
      receiverAudit.createdAt = currentTime();&#13;
    }&#13;
  }&#13;
}&#13;
&#13;
// File: contracts/token/component/ProvableOwnershipToken.sol&#13;
&#13;
/**&#13;
 * @title ProvableOwnershipToken&#13;
 * @dev ProvableOwnershipToken is a StandardToken&#13;
 * with ability to record a proof of ownership&#13;
 *&#13;
 * When desired a proof of ownership can be generated.&#13;
 * The proof is stored within the contract.&#13;
 * A proofId is then returned.&#13;
 * The proof can later be used to retrieve the amount needed.&#13;
 *&#13;
 * @author Cyril Lapinte - &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="187b616a71743674796871766c7d58756c687d747d6a7176367b7775">[email protected]</a>&gt;&#13;
 *&#13;
 * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved&#13;
 * @notice Please refer to the top of this file for the license.&#13;
 **/&#13;
contract ProvableOwnershipToken is IProvableOwnership, AuditableToken, Ownable {&#13;
  struct Proof {&#13;
    uint256 amount;&#13;
    uint256 dateFrom;&#13;
    uint256 dateTo;&#13;
  }&#13;
  mapping(address =&gt; mapping(uint256 =&gt; Proof)) internal proofs;&#13;
  mapping(address =&gt; uint256) internal proofLengths;&#13;
&#13;
  /**&#13;
   * @dev number of proof stored in the contract&#13;
   */&#13;
  function proofLength(address _holder) public view returns (uint256) {&#13;
    return proofLengths[_holder];&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev amount contains for the proofId reccord&#13;
   */&#13;
  function proofAmount(address _holder, uint256 _proofId)&#13;
    public view returns (uint256)&#13;
  {&#13;
    return proofs[_holder][_proofId].amount;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev date from which the proof is valid&#13;
   */&#13;
  function proofDateFrom(address _holder, uint256 _proofId)&#13;
    public view returns (uint256)&#13;
  {&#13;
    return proofs[_holder][_proofId].dateFrom;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev date until the proof is valid&#13;
   */&#13;
  function proofDateTo(address _holder, uint256 _proofId)&#13;
    public view returns (uint256)&#13;
  {&#13;
    return proofs[_holder][_proofId].dateTo;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev called to challenge a proof at a point in the past&#13;
   * Return the amount tokens owned by the proof owner at that time&#13;
   */&#13;
  function checkProof(address _holder, uint256 _proofId, uint256 _at)&#13;
    public view returns (uint256)&#13;
  {&#13;
    if (_proofId &lt; proofLengths[_holder]) {&#13;
      Proof storage proof = proofs[_holder][_proofId];&#13;
&#13;
      if (proof.dateFrom &lt;= _at &amp;&amp; _at &lt;= proof.dateTo) {&#13;
        return proof.amount;&#13;
      }&#13;
    }&#13;
    return 0;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev called to create a proof of token ownership&#13;
   */&#13;
  function createProof(address _holder) public {&#13;
    createProofInternal(&#13;
      _holder,&#13;
      balanceOf(_holder),&#13;
      lastTransactionAt(_holder)&#13;
    );&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev transfer function with also create a proof of ownership to any of the participants&#13;
   * @param _proofSender if true a proof will be created for the sender&#13;
   * @param _proofReceiver if true a proof will be created for the receiver&#13;
   */&#13;
  function transferWithProofs(&#13;
    address _to,&#13;
    uint256 _value,&#13;
    bool _proofSender,&#13;
    bool _proofReceiver&#13;
  ) public returns (bool)&#13;
  {&#13;
    uint256 balanceBeforeFrom = balanceOf(msg.sender);&#13;
    uint256 beforeFrom = lastTransactionAt(msg.sender);&#13;
    uint256 balanceBeforeTo = balanceOf(_to);&#13;
    uint256 beforeTo = lastTransactionAt(_to);&#13;
&#13;
    if (!super.transfer(_to, _value)) {&#13;
      return false;&#13;
    }&#13;
&#13;
    transferPostProcessing(&#13;
      msg.sender,&#13;
      balanceBeforeFrom,&#13;
      beforeFrom,&#13;
      _proofSender&#13;
    );&#13;
    transferPostProcessing(&#13;
      _to,&#13;
      balanceBeforeTo,&#13;
      beforeTo,&#13;
      _proofReceiver&#13;
    );&#13;
    return true;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev transfer function with also create a proof of ownership to any of the participants&#13;
   * @param _proofSender if true a proof will be created for the sender&#13;
   * @param _proofReceiver if true a proof will be created for the receiver&#13;
   */&#13;
  function transferFromWithProofs(&#13;
    address _from,&#13;
    address _to, &#13;
    uint256 _value,&#13;
    bool _proofSender, bool _proofReceiver)&#13;
    public returns (bool)&#13;
  {&#13;
    uint256 balanceBeforeFrom = balanceOf(_from);&#13;
    uint256 beforeFrom = lastTransactionAt(_from);&#13;
    uint256 balanceBeforeTo = balanceOf(_to);&#13;
    uint256 beforeTo = lastTransactionAt(_to);&#13;
&#13;
    if (!super.transferFrom(_from, _to, _value)) {&#13;
      return false;&#13;
    }&#13;
&#13;
    transferPostProcessing(&#13;
      _from,&#13;
      balanceBeforeFrom,&#13;
      beforeFrom,&#13;
      _proofSender&#13;
    );&#13;
    transferPostProcessing(&#13;
      _to,&#13;
      balanceBeforeTo,&#13;
      beforeTo,&#13;
      _proofReceiver&#13;
    );&#13;
    return true;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev can be used to force create a proof (with a fake amount potentially !)&#13;
   * Only usable by child contract internaly&#13;
   */&#13;
  function createProofInternal(&#13;
    address _holder, uint256 _amount, uint256 _from) internal&#13;
  {&#13;
    uint proofId = proofLengths[_holder];&#13;
    // solium-disable-next-line security/no-block-members&#13;
    proofs[_holder][proofId] = Proof(_amount, _from, currentTime());&#13;
    proofLengths[_holder] = proofId+1;&#13;
    emit ProofOfOwnership(_holder, proofId);&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev private function updating contract state after a transfer operation&#13;
   */&#13;
  function transferPostProcessing(&#13;
    address _holder,&#13;
    uint256 _balanceBefore,&#13;
    uint256 _before,&#13;
    bool _proof) private&#13;
  {&#13;
    if (_proof) {&#13;
      createProofInternal(_holder, _balanceBefore, _before);&#13;
    }&#13;
  }&#13;
&#13;
  event ProofOfOwnership(address indexed holder, uint256 proofId);&#13;
}&#13;
&#13;
// File: contracts/interface/IClaimable.sol&#13;
&#13;
/**&#13;
 * @title IClaimable&#13;
 * @dev IClaimable interface&#13;
 * @author Cyril Lapinte - &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="5f3c262d363371333e2f36312b3a1f322b2f3a333a2d3631713c3032">[email protected]</a>&gt;&#13;
 *&#13;
 * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved&#13;
 * @notice Please refer to the top of this file for the license.&#13;
 **/&#13;
interface IClaimable {&#13;
  function hasClaimsSince(address _address, uint256 at)&#13;
    external view returns (bool);&#13;
}&#13;
&#13;
// File: contracts/interface/IWithClaims.sol&#13;
&#13;
/**&#13;
 * @title IWithClaims&#13;
 * @dev IWithClaims interface&#13;
 * @author Cyril Lapinte - &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="f6958f849f9ad89a97869f988293b69b8286939a93849f98d895999b">[email protected]</a>&gt;&#13;
 *&#13;
 * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved&#13;
 * @notice Please refer to the top of this file for the license.&#13;
 **/&#13;
contract IWithClaims {&#13;
  function claimableLength() public view returns (uint256);&#13;
  function claimable(uint256 _claimableId) public view returns (IClaimable);&#13;
  function hasClaims(address _holder) public view returns (bool);&#13;
  function defineClaimables(IClaimable[] _claimables) public;&#13;
&#13;
  event ClaimablesDefined(uint256 count);&#13;
}&#13;
&#13;
// File: contracts/token/component/TokenWithClaims.sol&#13;
&#13;
/**&#13;
 * @title TokenWithClaims&#13;
 * @dev TokenWithClaims contract&#13;
 * TokenWithClaims is a token that will create a&#13;
 * proofOfOwnership during transfers if a claim can be made.&#13;
 * Holder may ask for the claim later using the proofOfOwnership&#13;
 * @author Cyril Lapinte - &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="f99a808b9095d795988990978d9cb9948d899c959c8b9097d79a9694">[email protected]</a>&gt;&#13;
 *&#13;
 * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved&#13;
 * @notice Please refer to the top of this file for the license.&#13;
 *&#13;
 * Error messages&#13;
 * E01: Claimable address must be defined&#13;
 * E02: Claimables parameter must not be empty&#13;
 * E03: Claimable does not exist&#13;
**/&#13;
contract TokenWithClaims is IWithClaims, ProvableOwnershipToken {&#13;
&#13;
  IClaimable[] claimables;&#13;
&#13;
  /**&#13;
   * @dev Constructor&#13;
   */&#13;
  constructor(IClaimable[] _claimables) public {&#13;
    claimables = _claimables;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Returns the number of claimables&#13;
   */&#13;
  function claimableLength() public view returns (uint256) {&#13;
    return claimables.length;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Returns the Claimable associated to the specified claimableId&#13;
   */&#13;
  function claimable(uint256 _claimableId) public view returns (IClaimable) {&#13;
    return claimables[_claimableId];&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Returns true if there are any claims associated to this token&#13;
   * to be made at this time for the _holder&#13;
   */&#13;
  function hasClaims(address _holder) public view returns (bool) {&#13;
    uint256 lastTransaction = lastTransactionAt(_holder);&#13;
    for (uint256 i = 0; i &lt; claimables.length; i++) {&#13;
      if (claimables[i].hasClaimsSince(_holder, lastTransaction)) {&#13;
        return true;&#13;
      }&#13;
    }&#13;
    return false;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Override the transfer function with transferWithProofs&#13;
   * A proof of ownership will be made if any claims can be made by the participants&#13;
   */&#13;
  function transfer(address _to, uint256 _value) public returns (bool) {&#13;
    bool proofFrom = hasClaims(msg.sender);&#13;
    bool proofTo = hasClaims(_to);&#13;
&#13;
    return super.transferWithProofs(&#13;
      _to,&#13;
      _value,&#13;
      proofFrom,&#13;
      proofTo&#13;
    );&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Override the transfer function with transferWithProofs&#13;
   * A proof of ownership will be made if any claims can be made by the participants&#13;
   */&#13;
  function transferFrom(address _from, address _to, uint256 _value)&#13;
    public returns (bool)&#13;
  {&#13;
    bool proofFrom = hasClaims(_from);&#13;
    bool proofTo = hasClaims(_to);&#13;
&#13;
    return super.transferFromWithProofs(&#13;
      _from,&#13;
      _to,&#13;
      _value,&#13;
      proofFrom,&#13;
      proofTo&#13;
    );&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev transfer with proofs&#13;
   */&#13;
  function transferWithProofs(&#13;
    address _to,&#13;
    uint256 _value,&#13;
    bool _proofFrom,&#13;
    bool _proofTo&#13;
  ) public returns (bool)&#13;
  {&#13;
    bool proofFrom = _proofFrom || hasClaims(msg.sender);&#13;
    bool proofTo = _proofTo || hasClaims(_to);&#13;
&#13;
    return super.transferWithProofs(&#13;
      _to,&#13;
      _value,&#13;
      proofFrom,&#13;
      proofTo&#13;
    );&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev transfer from with proofs&#13;
   */&#13;
  function transferFromWithProofs(&#13;
    address _from,&#13;
    address _to,&#13;
    uint256 _value,&#13;
    bool _proofFrom,&#13;
    bool _proofTo&#13;
  ) public returns (bool)&#13;
  {&#13;
    bool proofFrom = _proofFrom || hasClaims(_from);&#13;
    bool proofTo = _proofTo || hasClaims(_to);&#13;
&#13;
    return super.transferFromWithProofs(&#13;
      _from,&#13;
      _to,&#13;
      _value,&#13;
      proofFrom,&#13;
      proofTo&#13;
    );&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev define claimables contract to this token&#13;
   */&#13;
  function defineClaimables(IClaimable[] _claimables) public onlyOwner {&#13;
    claimables = _claimables;&#13;
    emit ClaimablesDefined(claimables.length);&#13;
  }&#13;
}&#13;
&#13;
// File: contracts/interface/IRule.sol&#13;
&#13;
/**&#13;
 * @title IRule&#13;
 * @dev IRule interface&#13;
 * @author Cyril Lapinte - &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="97f4eee5fefbb9fbf6e7fef9e3f2d7fae3e7f2fbf2e5fef9b9f4f8fa">[email protected]</a>&gt;&#13;
 *&#13;
 * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved&#13;
 * @notice Please refer to the top of this file for the license.&#13;
 **/&#13;
interface IRule {&#13;
  function isAddressValid(address _address) external view returns (bool);&#13;
  function isTransferValid(address _from, address _to, uint256 _amount)&#13;
    external view returns (bool);&#13;
}&#13;
&#13;
// File: contracts/interface/IWithRules.sol&#13;
&#13;
/**&#13;
 * @title IWithRules&#13;
 * @dev IWithRules interface&#13;
 * @author Cyril Lapinte - &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="284b515a41440644495841465c4d68455c584d444d5a4146064b4745">[email protected]</a>&gt;&#13;
 *&#13;
 * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved&#13;
 * @notice Please refer to the top of this file for the license.&#13;
 **/&#13;
contract IWithRules {&#13;
  function ruleLength() public view returns (uint256);&#13;
  function rule(uint256 _ruleId) public view returns (IRule);&#13;
  function validateAddress(address _address) public view returns (bool);&#13;
  function validateTransfer(address _from, address _to, uint256 _amount)&#13;
    public view returns (bool);&#13;
&#13;
  function defineRules(IRule[] _rules) public;&#13;
&#13;
  event RulesDefined(uint256 count);&#13;
}&#13;
&#13;
// File: contracts/rule/WithRules.sol&#13;
&#13;
/**&#13;
 * @title WithRules&#13;
 * @dev WithRules contract allows inheriting contract to use a set of validation rules&#13;
 * @dev contract owner may add or remove rules&#13;
 *&#13;
 * @author Cyril Lapinte - &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="80e3f9f2e9ecaeece1f0e9eef4e5c0edf4f0e5ece5f2e9eeaee3efed">[email protected]</a>&gt;&#13;
 *&#13;
 * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved&#13;
 * @notice Please refer to the top of this file for the license.&#13;
 *&#13;
 * Error messages&#13;
 * WR01: The rules rejected this address&#13;
 * WR02: The rules rejected the transfer&#13;
 **/&#13;
contract WithRules is IWithRules, Ownable {&#13;
&#13;
  IRule[] internal rules;&#13;
&#13;
  /**&#13;
   * @dev Constructor&#13;
   */&#13;
  constructor(IRule[] _rules) public {&#13;
    rules = _rules;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Returns the number of rules&#13;
   */&#13;
  function ruleLength() public view returns (uint256) {&#13;
    return rules.length;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Returns the Rule associated to the specified ruleId&#13;
   */&#13;
  function rule(uint256 _ruleId) public view returns (IRule) {&#13;
    return rules[_ruleId];&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Check if the rules are valid for an address&#13;
   */&#13;
  function validateAddress(address _address) public view returns (bool) {&#13;
    for (uint256 i = 0; i &lt; rules.length; i++) {&#13;
      if (!rules[i].isAddressValid(_address)) {&#13;
        return false;&#13;
      }&#13;
    }&#13;
    return true;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Check if the rules are valid&#13;
   */&#13;
  function validateTransfer(address _from, address _to, uint256 _amount)&#13;
    public view returns (bool)&#13;
  {&#13;
    for (uint256 i = 0; i &lt; rules.length; i++) {&#13;
      if (!rules[i].isTransferValid(_from, _to, _amount)) {&#13;
        return false;&#13;
      }&#13;
    }&#13;
    return true;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Modifier to make functions callable&#13;
   * only when participants follow rules&#13;
   */&#13;
  modifier whenAddressRulesAreValid(address _address) {&#13;
    require(validateAddress(_address), "WR01");&#13;
    _;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Modifier to make transfer functions callable&#13;
   * only when participants follow rules&#13;
   */&#13;
  modifier whenTransferRulesAreValid(&#13;
    address _from,&#13;
    address _to,&#13;
    uint256 _amount)&#13;
  {&#13;
    require(validateTransfer(_from, _to, _amount), "WR02");&#13;
    _;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Define rules to the token&#13;
   */&#13;
  function defineRules(IRule[] _rules) public onlyOwner {&#13;
    rules = _rules;&#13;
    emit RulesDefined(rules.length);&#13;
  }&#13;
}&#13;
&#13;
// File: contracts/token/component/TokenWithRules.sol&#13;
&#13;
/**&#13;
 * @title TokenWithRules&#13;
 * @dev TokenWithRules contract&#13;
 * TokenWithRules is a token that will apply&#13;
 * rules restricting transferability&#13;
 *&#13;
 * @author Cyril Lapinte - &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="15766c677c793b7974657c7b617055786165707970677c7b3b767a78">[email protected]</a>&gt;&#13;
 *&#13;
 * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved&#13;
 * @notice Please refer to the top of this file for the license.&#13;
 *&#13;
 **/&#13;
contract TokenWithRules is StandardToken, WithRules {&#13;
&#13;
  /**&#13;
   * @dev Constructor&#13;
   */&#13;
  constructor(IRule[] _rules) public WithRules(_rules) { }&#13;
&#13;
  /**&#13;
   * @dev Overriden transfer function&#13;
   */&#13;
  function transfer(address _to, uint256 _value)&#13;
    public whenTransferRulesAreValid(msg.sender, _to, _value)&#13;
    returns (bool)&#13;
  {&#13;
    return super.transfer(_to, _value);&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Overriden transferFrom function&#13;
   */&#13;
  function transferFrom(address _from, address _to, uint256 _value)&#13;
    public whenTransferRulesAreValid(_from, _to, _value)&#13;
    whenAddressRulesAreValid(msg.sender)&#13;
    returns (bool)&#13;
  {&#13;
    return super.transferFrom(_from, _to, _value);&#13;
  }&#13;
}&#13;
&#13;
// File: contracts/token/BridgeToken.sol&#13;
&#13;
/**&#13;
 * @title BridgeToken&#13;
 * @dev BridgeToken contract&#13;
 * @author Cyril Lapinte - &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="8fecf6fde6e3a1e3eeffe6e1fbeacfe2fbffeae3eafde6e1a1ece0e2">[email protected]</a>&gt;&#13;
 *&#13;
 * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved&#13;
 * @notice Please refer to the top of this file for the license.&#13;
 */&#13;
contract BridgeToken is TokenWithRules, TokenWithClaims, SeizableToken {&#13;
  string public name;&#13;
  string public symbol;&#13;
&#13;
  /**&#13;
   * @dev constructor&#13;
   */&#13;
  constructor(string _name, string _symbol) &#13;
    TokenWithRules(new IRule[](0))&#13;
    TokenWithClaims(new IClaimable[](0)) public&#13;
  {&#13;
    name = _name;&#13;
    symbol = _symbol;&#13;
  }&#13;
}&#13;
&#13;
// File: contracts/token/component/MintableToken.sol&#13;
&#13;
/**&#13;
 * @title MintableToken&#13;
 * @dev MintableToken contract&#13;
 * @author Cyril Lapinte - &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="33504a415a5f1d5f52435a5d4756735e4743565f56415a5d1d505c5e">[email protected]</a>&gt;&#13;
 *&#13;
 * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved&#13;
 * @notice Please refer to the top of this file for the license.&#13;
 *&#13;
 * Error messages&#13;
 * MT01: Minting is already finished.&#13;
*/&#13;
contract MintableToken is StandardToken, Ownable, IMintable {&#13;
&#13;
  bool public mintingFinished = false;&#13;
&#13;
  function mintingFinished() public view returns (bool) {&#13;
    return mintingFinished;&#13;
  }&#13;
&#13;
  modifier canMint() {&#13;
    require(!mintingFinished, "MT01");&#13;
    _;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Function to mint tokens&#13;
   * @param _to The address that will receive the minted tokens.&#13;
   * @param _amount The amount of tokens to mint.&#13;
   * @return A boolean that indicates if the operation was successful.&#13;
   */&#13;
  function mint(&#13;
    address _to,&#13;
    uint256 _amount&#13;
  ) public canMint onlyOwner returns (bool)&#13;
  {&#13;
    totalSupply_ = totalSupply_.add(_amount);&#13;
    balances[_to] = balances[_to].add(_amount);&#13;
    emit Mint(_to, _amount);&#13;
    emit Transfer(address(0), _to, _amount);&#13;
    return true;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Function to stop minting new tokens.&#13;
   * @return True if the operation was successful.&#13;
   */&#13;
  function finishMinting() public canMint onlyOwner returns (bool) {&#13;
    mintingFinished = true;&#13;
    emit MintFinished();&#13;
    return true;&#13;
  }&#13;
&#13;
  event Mint(address indexed to, uint256 amount);&#13;
  event MintFinished();&#13;
}&#13;
&#13;
// File: contracts/token/MintableBridgeToken.sol&#13;
&#13;
/**&#13;
 * @title MintableBridgeToken&#13;
 * @dev MintableBridgeToken contract&#13;
 * @author Cyril Lapinte - &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="4a293338232664262b3a23243e2f0a273e3a2f262f38232464292527">[email protected]</a>&gt;&#13;
 *&#13;
 * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved&#13;
 * @notice Please refer to the top of this file for the license.&#13;
 */&#13;
contract MintableBridgeToken is BridgeToken, MintableToken {&#13;
&#13;
  string public name;&#13;
  string public symbol;&#13;
&#13;
  /**&#13;
   * @dev constructor&#13;
   */&#13;
  constructor(string _name, string _symbol)&#13;
    BridgeToken(_name, _symbol) public&#13;
  {&#13;
    name = _name;&#13;
    symbol = _symbol;&#13;
  }&#13;
}&#13;
&#13;
// File: contracts/interface/ISaleConfig.sol&#13;
&#13;
/**&#13;
 * @title ISaleConfig interface&#13;
 *&#13;
 * @author Cyril Lapinte - &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="c8abb1baa1a4e6a4a9b8a1a6bcad88a5bcb8ada4adbaa1a6e6aba7a5">[email protected]</a>&gt;&#13;
 *&#13;
 * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved&#13;
 * @notice Please refer to the top of this file for the license.&#13;
 */&#13;
contract ISaleConfig {&#13;
&#13;
  struct Tokensale {&#13;
    uint256 lotId;&#13;
    uint256 tokenPriceCHFCent;&#13;
  }&#13;
&#13;
  function tokenSupply() public pure returns (uint256);&#13;
  function tokensaleLotSupplies() public view returns (uint256[]);&#13;
&#13;
  function tokenizedSharePercent() public pure returns (uint256); &#13;
  function tokenPriceCHF() public pure returns (uint256);&#13;
&#13;
  function minimalCHFInvestment() public pure returns (uint256);&#13;
  function maximalCHFInvestment() public pure returns (uint256);&#13;
&#13;
  function tokensalesCount() public view returns (uint256);&#13;
  function lotId(uint256 _tokensaleId) public view returns (uint256);&#13;
  function tokenPriceCHFCent(uint256 _tokensaleId)&#13;
    public view returns (uint256);&#13;
}&#13;
&#13;
// File: contracts/tokensale/TokenMinter.sol&#13;
&#13;
/**&#13;
 * @title TokenMinter&#13;
 * @dev TokenMinter contract&#13;
 * The contract explicit the minting process of the Bridge Token&#13;
 *&#13;
 * @author Cyril Lapinte - &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="9efde7ecf7f2b0f2ffeef7f0eafbdef3eaeefbf2fbecf7f0b0fdf1f3">[email protected]</a>&gt;&#13;
 *&#13;
 * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved&#13;
 * @notice Please refer to the top of this file for the license.&#13;
 *&#13;
 * Error messages&#13;
 * TM01: Configuration must be defined&#13;
 * TM02: Final token owner must be defined&#13;
 * TM03: There should be at least one lot&#13;
 * TM04: Must have one vault per lot&#13;
 * TM05: Each vault must be defined&#13;
 * TM06: Token must be defined&#13;
 * TM07: Token has already been defined&#13;
 * TM08: Minter must be the token owner&#13;
 * TM09: There should be no token supply&#13;
 * TM10: Token minting must not be finished&#13;
 * TM11: Minters must match tokensale configuration&#13;
 * TM12: Tokensale configuration must match lot definition&#13;
 * TM13: Minter is not already configured for the lot&#13;
 * TM14: Token must be defined&#13;
 * TM15: Amount to mint must be greater than 0&#13;
 * TM16: Mintable supply must be greater than amount to mint&#13;
 * TM17: Can only finish minting for active minters&#13;
 * TM18: No active minters expected for the lot&#13;
 * TM19: There should be some remaining supply in the lot&#13;
 * TM20: Minting must be successfull&#13;
 * TM21: Token minting must not be finished&#13;
 * TM22: There should be some unfinished lot(s)&#13;
 * TM23: All minting must be processed&#13;
 * TM24: Token minting must not be finished&#13;
 * TM25: Finish minting must be successful&#13;
 * TM26: Token minting must be finished&#13;
*/&#13;
contract TokenMinter is IMintableByLot, Ownable {&#13;
  using SafeMath for uint256;&#13;
&#13;
  struct MintableLot {&#13;
    uint256 mintableSupply;&#13;
    address vault;&#13;
    mapping(address =&gt; bool) minters;&#13;
    uint8 activeMinters;&#13;
  }&#13;
&#13;
  MintableLot[] private mintableLots;&#13;
  mapping(address =&gt; uint256) public minterLotIds;&#13;
&#13;
  uint256 public totalMintableSupply;&#13;
  address public finalTokenOwner;&#13;
&#13;
  uint8 public activeLots;&#13;
&#13;
  ISaleConfig public config;&#13;
  MintableBridgeToken public token;&#13;
&#13;
  /**&#13;
   * @dev constructor&#13;
   */&#13;
  constructor(&#13;
    ISaleConfig _config,&#13;
    address _finalTokenOwner,&#13;
    address[] _vaults) public&#13;
  {&#13;
    require(address(_config) != 0, "TM01");&#13;
    require(_finalTokenOwner != 0, "TM02");&#13;
&#13;
    uint256[] memory lots = _config.tokensaleLotSupplies();&#13;
    require(lots.length &gt; 0, "TM03");&#13;
    require(_vaults.length == lots.length, "TM04");&#13;
&#13;
    config = _config;&#13;
    finalTokenOwner = _finalTokenOwner;&#13;
&#13;
    for (uint256 i = 0; i &lt; lots.length; i++) {&#13;
      require(_vaults[i] != 0, "TM05");&#13;
      uint256 mintableSupply = lots[i];&#13;
      mintableLots.push(MintableLot(mintableSupply, _vaults[i], 0));&#13;
      totalMintableSupply = totalMintableSupply.add(mintableSupply);&#13;
      activeLots++;&#13;
      emit LotCreated(i+1, mintableSupply);&#13;
    }&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev minter lotId&#13;
   */&#13;
  function minterLotId(address _minter) public view returns (uint256) {&#13;
    return minterLotIds[_minter];&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev lot mintable supply&#13;
   */&#13;
  function lotMintableSupply(uint256 _lotId) public view returns (uint256) {&#13;
    return mintableLots[_lotId].mintableSupply;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev lot vault&#13;
   */&#13;
  function lotVault(uint256 _lotId) public view returns (address) {&#13;
    return mintableLots[_lotId].vault;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev is lot minter&#13;
   */&#13;
  function isLotMinter(uint256 _lotId, address _minter)&#13;
    public view returns (bool)&#13;
  {&#13;
    return mintableLots[_lotId].minters[_minter];&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev lot active minters&#13;
   */&#13;
  function lotActiveMinters(uint256 _lotId) public view returns (uint256) {&#13;
    return mintableLots[_lotId].activeMinters;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev implement IMintable interface&#13;
   */&#13;
  function mintingFinished() public view returns (bool) {&#13;
    return token.mintingFinished();&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev setup token and minters&#13;
   **/&#13;
  function setup(MintableBridgeToken _token, address[] _minters)&#13;
    public onlyOwner&#13;
  {&#13;
    require(address(_token) != 0, "TM06");&#13;
    require(address(token) == 0, "TM07");&#13;
    // Ensure it has full ownership over the token to ensure&#13;
    // that only this contract will be allowed to mint&#13;
    require(_token.owner() == address(this), "TM08");&#13;
    token = _token;&#13;
    &#13;
    // Ensure that the token has not been premint&#13;
    require(token.totalSupply() == 0, "TM09");&#13;
    require(!token.mintingFinished(), "TM10");&#13;
    &#13;
    require(_minters.length == config.tokensalesCount(), "TM11");&#13;
    for (uint256 i = 0; i &lt; _minters.length; i++) {&#13;
      if (_minters[i] != address(0)) {&#13;
        setupMinter(_minters[i], i);&#13;
      }&#13;
    }&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev setup minter&#13;
   */&#13;
  function setupMinter(address _minter, uint256 _tokensaleId)&#13;
    public onlyOwner&#13;
  {&#13;
    uint256 lotId = config.lotId(_tokensaleId);&#13;
    require(lotId &lt; mintableLots.length, "TM12");&#13;
    MintableLot storage lot = mintableLots[lotId];&#13;
    require(!lot.minters[_minter], "TM13");&#13;
    lot.minters[_minter] = true;&#13;
    lot.activeMinters++;&#13;
    minterLotIds[_minter] = lotId;&#13;
    emit MinterAdded(lotId, _minter);&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev mint the token from the corresponding lot&#13;
   */&#13;
  function mint(address _to, uint256 _amount)&#13;
    public returns (bool)&#13;
  {&#13;
    require(address(token) != 0, "TM14");&#13;
    require(_amount &gt; 0, "TM15");&#13;
    &#13;
    uint256 lotId = minterLotIds[msg.sender];&#13;
    MintableLot storage lot = mintableLots[lotId];&#13;
&#13;
    require(lot.mintableSupply &gt;= _amount, "TM16");&#13;
&#13;
    lot.mintableSupply = lot.mintableSupply.sub(_amount);&#13;
    totalMintableSupply = totalMintableSupply.sub(_amount);&#13;
    return token.mint(_to, _amount);&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev update this contract minting to finish&#13;
   */&#13;
  function finishMinting() public returns (bool) {&#13;
    return finishMintingInternal(msg.sender);&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev update this contract minting to finish&#13;
   */&#13;
  function finishMintingRestricted(address _minter)&#13;
    public onlyOwner returns (bool)&#13;
  {&#13;
    return finishMintingInternal(_minter);&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev update this contract minting to finish&#13;
   */&#13;
  function finishMintingInternal(address _minter)&#13;
    public returns (bool)&#13;
  {&#13;
    uint256 lotId = minterLotIds[_minter];&#13;
    MintableLot storage lot = mintableLots[lotId];&#13;
    require(lot.minters[_minter], "TM17");&#13;
&#13;
    lot.minters[_minter] = false;&#13;
    lot.activeMinters--;&#13;
&#13;
    if (lot.activeMinters == 0 &amp;&amp; lot.mintableSupply == 0) {&#13;
      finishLotMintingPrivate(lotId);&#13;
    }&#13;
    return true;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev mint remaining non distributed tokens for a lot&#13;
   */&#13;
  function mintRemainingLot(uint256 _lotId)&#13;
    public returns (bool)&#13;
  {&#13;
    MintableLot storage lot = mintableLots[_lotId];&#13;
    require(lot.activeMinters == 0, "TM18");&#13;
    require(lot.mintableSupply &gt; 0, "TM19");&#13;
&#13;
    require(token.mint(lot.vault, lot.mintableSupply), "TM20");&#13;
    totalMintableSupply = totalMintableSupply.sub(lot.mintableSupply);&#13;
    lot.mintableSupply = 0;&#13;
 &#13;
    finishLotMintingPrivate(_lotId);&#13;
    return true;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev mint remaining non distributed tokens&#13;
   * If some tokens remain unminted (unsold or rounding approximations)&#13;
   * they must be minted before the minting can be finished&#13;
   **/&#13;
  function mintAllRemaining() public onlyOwner returns (bool) {&#13;
    require(!token.mintingFinished(), "TM21");&#13;
    require(activeLots &gt; 0, "TM22");&#13;
   &#13;
    if (totalMintableSupply &gt; 0) {&#13;
      for (uint256 i = 0; i &lt; mintableLots.length; i++) {&#13;
        MintableLot storage lot = mintableLots[i];&#13;
        if (lot.mintableSupply &gt; 0) {&#13;
          mintRemainingLot(i);&#13;
        }&#13;
      }&#13;
    }&#13;
    return true;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev finish token minting&#13;
   */&#13;
  function finishTokenMinting() public onlyOwner returns (bool) {&#13;
    require(totalMintableSupply == 0, "TM23");&#13;
    require(!token.mintingFinished(), "TM24");&#13;
    require(token.finishMinting(), "TM25");&#13;
    &#13;
    require(token.mintingFinished(), "TM26");&#13;
    token.transferOwnership(finalTokenOwner);&#13;
    emit TokenReleased();&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev finish lot minting&#13;
   */&#13;
  function finishLotMintingPrivate(uint256 _lotId) private {&#13;
    activeLots--;&#13;
    emit LotMinted(_lotId);&#13;
  }&#13;
&#13;
  event LotCreated(uint256 lotId, uint256 tokenSupply);&#13;
  event MinterAdded(uint256 lotId, address minter);&#13;
  event LotMinted(uint256 lotId);&#13;
  event TokenReleased();&#13;
}