pragma solidity ^0.4.20;
// produced by the Solididy File Flattener (c) David Appleton 2018
// contact : <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="187c796e7d58797377757a79367b7775">[emailÂ protected]</a>&#13;
// released under Apache 2.0 licence&#13;
library safeMath&#13;
{&#13;
  function mul(uint256 a, uint256 b) internal pure returns (uint256)&#13;
  {&#13;
    uint256 c = a * b;&#13;
    assert(a == 0 || c / a == b);&#13;
    return c;&#13;
  }&#13;
  function add(uint256 a, uint256 b) internal pure returns (uint256)&#13;
  {&#13;
    uint256 c = a + b;&#13;
    assert(c &gt;= a);&#13;
    return c;&#13;
  }&#13;
}&#13;
&#13;
contract Event&#13;
{&#13;
  event Transfer(address indexed from, address indexed to, uint256 value);&#13;
  event Deposit(address indexed sender, uint256 amount , string status);&#13;
  event TokenBurn(address indexed from, uint256 value);&#13;
  event TokenAdd(address indexed from, uint256 value);&#13;
  event Set_Status(string changedStatus);&#13;
  event Set_TokenReward(uint256 changedTokenReward);&#13;
  event Set_TimeStamp(uint256 ICO_startingTime, uint256 ICO_closingTime);&#13;
  event WithdrawETH(uint256 amount);&#13;
  event BlockedAddress(address blockedAddress);&#13;
  event TempLockedAddress(address tempLockAddress, uint256 unlockTime);&#13;
}&#13;
&#13;
contract Variable&#13;
{&#13;
  string public name;&#13;
  string public symbol;&#13;
  uint256 public decimals;&#13;
  uint256 public totalSupply;&#13;
  address public owner;&#13;
  string public status;&#13;
&#13;
  uint256 internal _decimals;&#13;
  uint256 internal tokenReward;&#13;
  uint256 internal ICO_startingTime;&#13;
  uint256 internal ICO_closingTime;&#13;
  bool internal transferLock;&#13;
  bool internal depositLock;&#13;
  mapping (address =&gt; bool) public allowedAddress;&#13;
  mapping (address =&gt; bool) public blockedAddress;&#13;
  mapping (address =&gt; uint256) public tempLockedAddress;&#13;
&#13;
  address withdraw_wallet;&#13;
  mapping (address =&gt; uint256) public balanceOf;&#13;
&#13;
&#13;
  constructor() public&#13;
  {&#13;
    name = "GMB";&#13;
    symbol = "GMB";&#13;
    decimals = 18;&#13;
    _decimals = 10 ** uint256(decimals);&#13;
    tokenReward = 0;&#13;
    totalSupply = _decimals * 5000000000;&#13;
    status = "";&#13;
    ICO_startingTime = 0;// 18.01.01 00:00:00 1514732400;&#13;
    ICO_closingTime = 0;// 18.12.31 23.59.59 1546268399;&#13;
    transferLock = true;&#13;
    depositLock = true;&#13;
    owner =  0xEfe9f7A61083ffE83Cbf833EeE61Eb1757Dd17BB;&#13;
    balanceOf[owner] = totalSupply;&#13;
    allowedAddress[owner] = true;&#13;
    withdraw_wallet = 0x7f7e8355A4c8fA72222DC66Bbb3E701779a2808F;&#13;
  }&#13;
}&#13;
&#13;
contract Modifiers is Variable&#13;
{&#13;
  modifier isOwner&#13;
  {&#13;
    assert(owner == msg.sender);&#13;
    _;&#13;
  }&#13;
&#13;
  modifier isValidAddress&#13;
  {&#13;
    assert(0x0 != msg.sender);&#13;
    _;&#13;
  }&#13;
}&#13;
&#13;
contract Set is Variable, Modifiers, Event&#13;
{&#13;
  function setStatus(string _status) public isOwner returns(bool success)&#13;
  {&#13;
    status = _status;&#13;
    emit Set_Status(status);&#13;
    return true;&#13;
  }&#13;
  function setTokenReward(uint256 _tokenReward) public isOwner returns(bool success)&#13;
  {&#13;
    tokenReward = _tokenReward;&#13;
    emit Set_TokenReward(tokenReward);&#13;
    return true;&#13;
  }&#13;
  function setTimeStamp(uint256 _ICO_startingTime,uint256 _ICO_closingTime) public isOwner returns(bool success)&#13;
  {&#13;
    ICO_startingTime = _ICO_startingTime;&#13;
    ICO_closingTime = _ICO_closingTime;&#13;
&#13;
    emit Set_TimeStamp(ICO_startingTime, ICO_closingTime);&#13;
    return true;&#13;
  }&#13;
  function setTransferLock(bool _transferLock) public isOwner returns(bool success)&#13;
  {&#13;
    transferLock = _transferLock;&#13;
    return true;&#13;
  }&#13;
  function setDepositLock(bool _depositLock) public isOwner returns(bool success)&#13;
  {&#13;
    depositLock = _depositLock;&#13;
    return true;&#13;
  }&#13;
  function setTimeStampStatus(uint256 _ICO_startingTime, uint256 _ICO_closingTime, string _status) public isOwner returns(bool success)&#13;
  {&#13;
    ICO_startingTime = _ICO_startingTime;&#13;
    ICO_closingTime = _ICO_closingTime;&#13;
    status = _status;&#13;
    emit Set_TimeStamp(ICO_startingTime,ICO_closingTime);&#13;
    emit Set_Status(status);&#13;
    return true;&#13;
  }&#13;
}&#13;
&#13;
contract manageAddress is Variable, Modifiers, Event&#13;
{&#13;
&#13;
  function add_allowedAddress(address _address) public isOwner&#13;
  {&#13;
    allowedAddress[_address] = true;&#13;
  }&#13;
&#13;
  function add_blockedAddress(address _address) public isOwner&#13;
  {&#13;
    require(_address != owner);&#13;
    blockedAddress[_address] = true;&#13;
    emit BlockedAddress(_address);&#13;
  }&#13;
&#13;
  function delete_allowedAddress(address _address) public isOwner&#13;
  {&#13;
    require(_address != owner);&#13;
    allowedAddress[_address] = false;&#13;
  }&#13;
&#13;
  function delete_blockedAddress(address _address) public isOwner&#13;
  {&#13;
    blockedAddress[_address] = false;&#13;
  }&#13;
}&#13;
&#13;
contract Get is Variable, Modifiers&#13;
{&#13;
  function get_tokenTime() public view returns(uint256 start, uint256 stop)&#13;
  {&#13;
    return (ICO_startingTime,ICO_closingTime);&#13;
  }&#13;
  function get_transferLock() public view returns(bool)&#13;
  {&#13;
    return transferLock;&#13;
  }&#13;
  function get_depositLock() public view returns(bool)&#13;
  {&#13;
    return depositLock;&#13;
  }&#13;
  function get_tokenReward() public view returns(uint256)&#13;
  {&#13;
    return tokenReward;&#13;
  }&#13;
&#13;
}&#13;
&#13;
contract Admin is Variable, Modifiers, Event&#13;
{&#13;
  function admin_transfer_tempLockAddress(address _to, uint256 _value, uint256 _unlockTime) public isOwner returns(bool success)&#13;
  {&#13;
    require(balanceOf[msg.sender] &gt;= _value);&#13;
    require(balanceOf[_to] + (_value ) &gt;= balanceOf[_to]);&#13;
    balanceOf[msg.sender] -= _value;&#13;
    balanceOf[_to] += _value;&#13;
    tempLockedAddress[_to] = _unlockTime;&#13;
    emit Transfer(msg.sender, _to, _value);&#13;
    emit TempLockedAddress(_to, _unlockTime);&#13;
    return true;&#13;
  }&#13;
  function admin_transferFrom(address _from, address _to, uint256 _value) public isOwner returns(bool success)&#13;
  {&#13;
    require(balanceOf[_from] &gt;= _value);&#13;
    require(balanceOf[_to] + (_value ) &gt;= balanceOf[_to]);&#13;
    balanceOf[_from] -= _value;&#13;
    balanceOf[_to] += _value;&#13;
    emit Transfer(_from, _to, _value);&#13;
    return true;&#13;
  }&#13;
  function admin_tokenBurn(uint256 _value) public isOwner returns(bool success)&#13;
  {&#13;
    require(balanceOf[msg.sender] &gt;= _value);&#13;
    balanceOf[msg.sender] -= _value;&#13;
    totalSupply -= _value;&#13;
    emit TokenBurn(msg.sender, _value);&#13;
    return true;&#13;
  }&#13;
  function admin_tokenAdd(uint256 _value) public isOwner returns(bool success)&#13;
  {&#13;
    balanceOf[msg.sender] += _value;&#13;
    totalSupply += _value;&#13;
    emit TokenAdd(msg.sender, _value);&#13;
    return true;&#13;
  }&#13;
  function admin_renewLockedAddress(address _address, uint256 _unlockTime) public isOwner returns(bool success)&#13;
  {&#13;
    tempLockedAddress[_address] = _unlockTime;&#13;
    emit TempLockedAddress(_address, _unlockTime);&#13;
    return true;&#13;
  }&#13;
}&#13;
&#13;
contract GMB is Variable, Event, Get, Set, Admin, manageAddress&#13;
{&#13;
  using safeMath for uint256;&#13;
&#13;
  function() payable public&#13;
  {&#13;
    require(ICO_startingTime &lt; block.timestamp &amp;&amp; ICO_closingTime &gt; block.timestamp);&#13;
    require(!depositLock);&#13;
    uint256 tokenValue;&#13;
    tokenValue = (msg.value).mul(tokenReward);&#13;
    require(balanceOf[owner] &gt;= tokenValue);&#13;
    require(balanceOf[msg.sender].add(tokenValue) &gt;= balanceOf[msg.sender]);&#13;
    emit Deposit(msg.sender, msg.value, status);&#13;
    balanceOf[owner] -= tokenValue;&#13;
    balanceOf[msg.sender] += tokenValue;&#13;
    emit Transfer(owner, msg.sender, tokenValue);&#13;
  }&#13;
  function transfer(address _to, uint256 _value) public isValidAddress&#13;
  {&#13;
    require(allowedAddress[msg.sender] || transferLock == false);&#13;
    require(tempLockedAddress[msg.sender] &lt; block.timestamp);&#13;
    require(!blockedAddress[msg.sender] &amp;&amp; !blockedAddress[_to]);&#13;
    require(balanceOf[msg.sender] &gt;= _value);&#13;
    require((balanceOf[_to].add(_value)) &gt;= balanceOf[_to]);&#13;
    balanceOf[msg.sender] -= _value;&#13;
    balanceOf[_to] += _value;&#13;
    emit Transfer(msg.sender, _to, _value);&#13;
  }&#13;
  function ETH_withdraw(uint256 amount) public isOwner returns(bool)&#13;
  {&#13;
    withdraw_wallet.transfer(amount);&#13;
    emit WithdrawETH(amount);&#13;
    return true;&#13;
  }&#13;
}