pragma solidity ^0.4.23;

/*
* Author:  Konstantin G...
* Telegram: @bunnygame (en)
* talk : https://bitcointalk.org/index.php?topic=5025885.0
* discord : https://discordapp.com/invite/G2jt4Fw
* email: <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="6b02050d042b091e05051208040205450804">[email protected]</a>&#13;
* site : http://bunnycoin.co &#13;
*/&#13;
&#13;
/**&#13;
* @title Ownable&#13;
* @dev The Ownable contract has an owner address, and provides basic authorization control&#13;
* functions, this simplifies the implementation of "user permissions".&#13;
*/&#13;
contract Ownable {&#13;
    &#13;
    address ownerCEO;&#13;
    address ownerMoney;  &#13;
    address privAddress; &#13;
    address addressAdmixture;&#13;
    &#13;
    /**&#13;
    * @dev The Ownable constructor sets the original `owner` of the contract to the sender&#13;
    * account.&#13;
    */&#13;
    constructor() public { &#13;
        ownerCEO = msg.sender; &#13;
        ownerMoney = msg.sender;&#13;
    }&#13;
 &#13;
  /**&#13;
   * @dev Throws if called by any account other than the owner.&#13;
   */&#13;
    modifier onlyOwner() {&#13;
        require(msg.sender == ownerCEO);&#13;
        _;&#13;
    }&#13;
   &#13;
    function transferOwnership(address add) public onlyOwner {&#13;
        if (add != address(0)) {&#13;
            ownerCEO = add;&#13;
        }&#13;
    }&#13;
 &#13;
    function transferOwnerMoney(address _ownerMoney) public  onlyOwner {&#13;
        if (_ownerMoney != address(0)) {&#13;
            ownerMoney = _ownerMoney;&#13;
        }&#13;
    }&#13;
 &#13;
    function getOwnerMoney() public view onlyOwner returns(address) {&#13;
        return ownerMoney;&#13;
    } &#13;
    /**&#13;
    *  @dev private contract&#13;
     */&#13;
    function getPrivAddress() public view onlyOwner returns(address) {&#13;
        return privAddress;&#13;
    }&#13;
    function getAddressAdmixture() public view onlyOwner returns(address) {&#13;
        return addressAdmixture;&#13;
    }&#13;
} &#13;
&#13;
&#13;
/**&#13;
 * @title Whitelist&#13;
 * @dev The Whitelist contract has a whitelist of addresses, and provides basic authorization control functions.&#13;
 * @dev This simplifies the implementation of "user permissions".&#13;
 */&#13;
contract Whitelist is Ownable {&#13;
    mapping(address =&gt; bool) public whitelist;&#13;
&#13;
    mapping(uint  =&gt; address)   whitelistCheck;&#13;
    uint public countAddress = 0;&#13;
&#13;
    event WhitelistedAddressAdded(address addr);&#13;
    event WhitelistedAddressRemoved(address addr);&#13;
 &#13;
  /**&#13;
   * @dev Throws if called by any account that's not whitelisted.&#13;
   */&#13;
    modifier onlyWhitelisted() {&#13;
        require(whitelist[msg.sender]);&#13;
        _;&#13;
    }&#13;
&#13;
    constructor() public {&#13;
            whitelist[msg.sender] = true;  &#13;
            whitelist[this] = true;  &#13;
    }&#13;
&#13;
  /**&#13;
   * @dev add an address to the whitelist&#13;
   * @param addr address&#13;
   * @return true if the address was added to the whitelist, false if the address was already in the whitelist&#13;
   */&#13;
    function addAddressToWhitelist(address addr) onlyWhitelisted public returns(bool success) {&#13;
        if (!whitelist[addr]) {&#13;
            whitelist[addr] = true;&#13;
&#13;
            countAddress = countAddress + 1;&#13;
            whitelistCheck[countAddress] = addr;&#13;
&#13;
            emit WhitelistedAddressAdded(addr);&#13;
            success = true;&#13;
        }&#13;
    }&#13;
&#13;
    function getWhitelistCheck(uint key) onlyWhitelisted view public returns(address) {&#13;
        return whitelistCheck[key];&#13;
    }&#13;
&#13;
&#13;
    function getInWhitelist(address addr) public view returns(bool) {&#13;
        return whitelist[addr];&#13;
    }&#13;
    function getOwnerCEO() public onlyWhitelisted view returns(address) {&#13;
        return ownerCEO;&#13;
    }&#13;
 &#13;
    /**&#13;
    * @dev add addresses to the whitelist&#13;
    * @param addrs addresses&#13;
    * @return true if at least one address was added to the whitelist,&#13;
    * false if all addresses were already in the whitelist&#13;
    */&#13;
    function addAddressesToWhitelist(address[] addrs) onlyOwner public returns(bool success) {&#13;
        for (uint256 i = 0; i &lt; addrs.length; i++) {&#13;
            if (addAddressToWhitelist(addrs[i])) {&#13;
                success = true;&#13;
            }&#13;
        }&#13;
    }&#13;
&#13;
    /**&#13;
    * @dev remove an address from the whitelist&#13;
    * @param addr address&#13;
    * @return true if the address was removed from the whitelist,&#13;
    * false if the address wasn't in the whitelist in the first place&#13;
    */&#13;
    function removeAddressFromWhitelist(address addr) onlyOwner public returns(bool success) {&#13;
        if (whitelist[addr]) {&#13;
            whitelist[addr] = false;&#13;
            emit WhitelistedAddressRemoved(addr);&#13;
            success = true;&#13;
        }&#13;
    }&#13;
&#13;
    /**&#13;
    * @dev remove addresses from the whitelist&#13;
    * @param addrs addresses&#13;
    * @return true if at least one address was removed from the whitelist,&#13;
    * false if all addresses weren't in the whitelist in the first place&#13;
    */&#13;
    function removeAddressesFromWhitelist(address[] addrs) onlyOwner public returns(bool success) {&#13;
        for (uint256 i = 0; i &lt; addrs.length; i++) {&#13;
            if (removeAddressFromWhitelist(addrs[i])) {&#13;
                success = true;&#13;
            }&#13;
        }&#13;
    }&#13;
}&#13;
&#13;
library SafeMath {&#13;
&#13;
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
        if (a == 0) {&#13;
            return 0;&#13;
        }&#13;
        uint c = a * b;&#13;
        assert(c / a == b);&#13;
        return c;&#13;
    }&#13;
&#13;
    function div(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
        // assert(b &gt; 0); // Solidity automatically throws when dividing by 0&#13;
        uint256 c = a / b;&#13;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold&#13;
        return c;&#13;
    }&#13;
&#13;
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
        assert(b &lt;= a);&#13;
        return a - b;&#13;
    }&#13;
&#13;
    function add(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
        uint256 c = a + b;&#13;
        assert(c &gt;= a);&#13;
        return c;&#13;
    }&#13;
  &#13;
}&#13;
 &#13;
&#13;
contract BaseRabbit  is Whitelist {&#13;
    event EmotherCount(uint32 mother, uint summ);&#13;
    event SalaryBunny(uint32 bunnyId, uint cost);&#13;
    event CreateChildren(uint32 matron, uint32 sire, uint32 child);&#13;
    event BunnyDescription(uint32 bunnyId, string name);&#13;
    event CoolduwnMother(uint32 bunnyId, uint num);&#13;
    event Referral(address from, uint32 matronID, uint32 childID, uint currentTime);&#13;
    event Approval(address owner, address approved, uint32 tokenId);&#13;
    event Transfer(address from, address to, uint32 tokenId);&#13;
    event NewBunny(uint32 bunnyId, uint dnk, uint256 blocknumber, uint breed);&#13;
 &#13;
&#13;
    using SafeMath for uint256;&#13;
    bool pauseSave = false;&#13;
    &#13;
    // ID the last seal&#13;
    // ID the last seal&#13;
    bool public promoPause = false;&#13;
&#13;
&#13;
&#13;
&#13;
    function setPromoPause() public onlyWhitelisted() {&#13;
        promoPause = !promoPause;&#13;
    }&#13;
&#13;
&#13;
 // &#13;
    // внешняя функция сколько заработала мамочка&#13;
    mapping(uint32 =&gt; uint) public totalSalaryBunny;&#13;
    // кто мамочка у ребёнка&#13;
    mapping(uint32 =&gt; uint32[5]) public rabbitMother;&#13;
    // сколько раз стала мамочка текущий кролик&#13;
    mapping(uint32 =&gt; uint) public motherCount;&#13;
    // сколько стоит скрещивание у кролика&#13;
    mapping(uint32 =&gt; uint)  public rabbitSirePrice;&#13;
    // разрешено ли менять кролику пол&#13;
    mapping(uint32 =&gt; bool)  public allowedChangeSex;&#13;
    // сколько мужиков с текущим геном&#13;
   // mapping(uint =&gt; uint32[]) public sireGenom;&#13;
    mapping (uint32 =&gt; uint) mapDNK;&#13;
   &#13;
    mapping (uint32 =&gt; bool) giffblock; &#13;
    /**&#13;
    * Where we will store information about rabbits&#13;
    */&#13;
  //  Rabbit[]  public rabbits;&#13;
    mapping (uint32 =&gt; Rabbit)  tokenBunny; &#13;
     &#13;
    uint public tokenBunnyTotal;&#13;
    /**&#13;
    * who owns the rabbit&#13;
    */&#13;
    mapping (uint32 =&gt; address) public rabbitToOwner; &#13;
    mapping (address =&gt; uint32[]) public ownerBunnies;&#13;
    mapping (address =&gt; bool) ownerGennezise;&#13;
&#13;
    struct Rabbit { &#13;
         // parents&#13;
        uint32 mother;&#13;
        uint32 sire; &#13;
        // block in which a rabbit was born&#13;
        uint birthblock;&#13;
         // number of births or how many times were offspring&#13;
        uint birthCount;&#13;
         // The time when Rabbit last gave birth&#13;
        uint birthLastTime;&#13;
        //indexGenome   &#13;
        uint genome; &#13;
    }&#13;
}&#13;
&#13;
&#13;
/// @title Interface for contracts conforming to ERC-721: Non-Fungible Tokens&#13;
/// @author Dieter Shirley &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="630706170623021b0a0c0e19060d4d000c">[email protected]</a>&gt; (https://github.com/dete)&#13;
contract ERC721 {&#13;
    // Required methods &#13;
&#13;
    function ownerOf(uint32 _tokenId) public view returns (address owner);&#13;
    function approve(address _to, uint32 _tokenId) public returns (bool success);&#13;
    function transfer(address _to, uint32 _tokenId) public;&#13;
    function transferFrom(address _from, address _to, uint32 _tokenId) public returns (bool);&#13;
    function totalSupply() public view returns (uint total);&#13;
    function balanceOf(address _owner) public view returns (uint balance);&#13;
&#13;
}&#13;
&#13;
/// @title Interface new rabbits address&#13;
contract PrivateRabbitInterface {&#13;
    function getNewRabbit(address from)  public view returns (uint);&#13;
    function mixDNK(uint dnkmother, uint dnksire, uint genome)  public view returns (uint);&#13;
    function isUIntPrivate() public pure returns (bool);&#13;
}&#13;
&#13;
&#13;
contract Rabbit is BaseRabbit, ERC721 {&#13;
    uint public totalBunny = 0;&#13;
    string public constant name = "CryptoRabbits";&#13;
    string public constant symbol = "CRB";&#13;
&#13;
    function ownerOf(uint32 _tokenId) public view returns (address owner) {&#13;
        return rabbitToOwner[_tokenId];&#13;
    }&#13;
&#13;
    function approve(address _to, uint32 _tokenId) public returns (bool) { &#13;
        _to;&#13;
        _tokenId;&#13;
        return false;&#13;
    }&#13;
&#13;
&#13;
    function removeTokenList(address _owner, uint32 _tokenId) internal { &#13;
        require(isPauseSave());&#13;
        uint count = ownerBunnies[_owner].length;&#13;
        for (uint256 i = 0; i &lt; count; i++) {&#13;
            if(ownerBunnies[_owner][i] == _tokenId)&#13;
            { &#13;
                delete ownerBunnies[_owner][i];&#13;
                if(count &gt; 0 &amp;&amp; count != (i-1)){&#13;
                    ownerBunnies[_owner][i] = ownerBunnies[_owner][(count-1)];&#13;
                    delete ownerBunnies[_owner][(count-1)];&#13;
                } &#13;
                ownerBunnies[_owner].length--;&#13;
                return;&#13;
            } &#13;
        }&#13;
    }&#13;
&#13;
&#13;
    /**&#13;
    * @dev add a new bunny in the storage&#13;
     */&#13;
    function addTokenList(address owner,  uint32 _tokenId) internal {&#13;
        ownerBunnies[owner].push( _tokenId);&#13;
        rabbitToOwner[_tokenId] = owner; &#13;
    }&#13;
 &#13;
&#13;
    function transfer(address _to, uint32 _tokenId) public {&#13;
        require(isPauseSave());&#13;
        address currentOwner = msg.sender;&#13;
        address oldOwner = rabbitToOwner[_tokenId];&#13;
        require(rabbitToOwner[_tokenId] == msg.sender);&#13;
        require(currentOwner != _to);&#13;
        require(_to != address(0));&#13;
        removeTokenList(oldOwner, _tokenId);&#13;
        addTokenList(_to, _tokenId);&#13;
        emit Transfer(oldOwner, _to, _tokenId);&#13;
    }&#13;
    &#13;
    function transferFrom(address _from, address _to, uint32 _tokenId) public onlyWhitelisted() returns(bool) {&#13;
        require(isPauseSave());&#13;
        address oldOwner = rabbitToOwner[_tokenId];&#13;
        require(oldOwner == _from); &#13;
        require(oldOwner != _to);&#13;
        require(_to != address(0));&#13;
        removeTokenList(oldOwner, _tokenId);&#13;
        addTokenList(_to, _tokenId); &#13;
        setAllowedChangeSex(_tokenId, false);&#13;
        emit Transfer (oldOwner, _to, _tokenId);&#13;
        return true;&#13;
    }  &#13;
     &#13;
&#13;
    function isPauseSave() public view returns(bool) {&#13;
        return !pauseSave;&#13;
    }&#13;
    &#13;
    function isPromoPause() public view returns(bool) {&#13;
        if (getInWhitelist(msg.sender)) {&#13;
            return true;&#13;
        } else {&#13;
            return !promoPause;&#13;
        } &#13;
    }&#13;
&#13;
    function setPauseSave() public onlyWhitelisted() returns(bool) {&#13;
        return pauseSave = !pauseSave;&#13;
    }&#13;
&#13;
    function setTotalBunny() internal onlyWhitelisted() returns(uint) {&#13;
        require(isPauseSave());&#13;
        return totalBunny = totalBunny.add(1);&#13;
    }&#13;
     &#13;
&#13;
    function setTotalBunny_id(uint _totalBunny) external onlyWhitelisted() {&#13;
        require(isPauseSave());&#13;
        totalBunny = _totalBunny;&#13;
    }&#13;
&#13;
&#13;
    function setTokenBunny(uint32 mother, uint32  sire, uint birthblock, uint birthCount, uint birthLastTime, uint genome, address _owner, uint DNK) &#13;
        external onlyWhitelisted() returns(uint32) {&#13;
            uint32 id = uint32(setTotalBunny());&#13;
            tokenBunny[id] = Rabbit(mother, sire, birthblock, birthCount, birthLastTime, genome);&#13;
            mapDNK[id] = DNK;&#13;
            addTokenList(_owner, id); &#13;
&#13;
            emit NewBunny(id, DNK, block.number, 0);&#13;
            emit CreateChildren(mother, sire, id);&#13;
            setMotherCount(id, 0);&#13;
        return id;&#13;
    }&#13;
    &#13;
    &#13;
    // correction of mistakes with parents&#13;
    function relocateToken(&#13;
        uint32 id, &#13;
        uint32 mother, &#13;
        uint32 sire, &#13;
        uint birthblock, &#13;
        uint birthCount, &#13;
        uint birthLastTime, &#13;
        uint genome, &#13;
        address _owner, &#13;
        uint DNK&#13;
         ) external onlyWhitelisted(){&#13;
        //    if(mapDNK[id] != 0){ &#13;
                tokenBunny[id] = Rabbit(mother, sire, birthblock, birthCount, birthLastTime, genome);&#13;
                mapDNK[id] = DNK;&#13;
                addTokenList(_owner, id);&#13;
       //     }&#13;
    }&#13;
&#13;
    &#13;
    &#13;
    function setDNK( uint32 _bunny, uint dnk) external onlyWhitelisted() {&#13;
        require(isPauseSave());&#13;
        mapDNK[_bunny] = dnk;&#13;
    }&#13;
    &#13;
    &#13;
    function setMotherCount( uint32 _bunny, uint count) public onlyWhitelisted() {&#13;
        require(isPauseSave()); &#13;
        motherCount[_bunny] = count;&#13;
    }&#13;
    &#13;
    function setRabbitSirePrice( uint32 _bunny, uint count) external onlyWhitelisted() {&#13;
        require(isPauseSave()); &#13;
        rabbitSirePrice[_bunny] = count;&#13;
    }&#13;
  &#13;
    function setAllowedChangeSex( uint32 _bunny, bool canBunny) public onlyWhitelisted() {&#13;
        require(isPauseSave()); &#13;
        allowedChangeSex[_bunny] = canBunny;&#13;
    }&#13;
    &#13;
    function setTotalSalaryBunny( uint32 _bunny, uint count) external onlyWhitelisted() {&#13;
        require(isPauseSave()); &#13;
        totalSalaryBunny[_bunny] = count;&#13;
    }  &#13;
&#13;
    function setRabbitMother(uint32 children, uint32[5] _m) external onlyWhitelisted() { &#13;
             rabbitMother[children] = _m;&#13;
    }&#13;
&#13;
    function setGenome(uint32 _bunny, uint genome)  external onlyWhitelisted(){ &#13;
        tokenBunny[_bunny].genome = genome;&#13;
    }&#13;
&#13;
    function setParent(uint32 _bunny, uint32 mother, uint32 sire)  external onlyWhitelisted() { &#13;
        tokenBunny[_bunny].mother = mother;&#13;
        tokenBunny[_bunny].sire = sire;&#13;
    }&#13;
&#13;
    function setBirthLastTime(uint32 _bunny, uint birthLastTime) external onlyWhitelisted() { &#13;
        tokenBunny[_bunny].birthLastTime = birthLastTime;&#13;
    }&#13;
&#13;
    function setBirthCount(uint32 _bunny, uint birthCount) external onlyWhitelisted() { &#13;
        tokenBunny[_bunny].birthCount = birthCount;&#13;
    }&#13;
&#13;
    function setBirthblock(uint32 _bunny, uint birthblock) external onlyWhitelisted() { &#13;
        tokenBunny[_bunny].birthblock = birthblock;&#13;
    }&#13;
&#13;
    function setGiffBlock(uint32 _bunny, bool blocked) external onlyWhitelisted() { &#13;
        giffblock[_bunny] = blocked;&#13;
    }&#13;
&#13;
&#13;
    function setOwnerGennezise(address _to, bool canYou) external onlyWhitelisted() { &#13;
        ownerGennezise[_to] = canYou;&#13;
    }&#13;
&#13;
&#13;
 &#13;
&#13;
    ////// getters&#13;
 &#13;
    function getOwnerGennezise(address _to) public view returns(bool) { &#13;
        return ownerGennezise[_to];&#13;
    }&#13;
    function getGiffBlock(uint32 _bunny) public view returns(bool) { &#13;
        return !giffblock[_bunny];&#13;
    }&#13;
&#13;
    function getAllowedChangeSex(uint32 _bunny) public view returns(bool) {&#13;
        return !allowedChangeSex[_bunny];&#13;
    } &#13;
 &#13;
    function getRabbitSirePrice(uint32 _bunny) public view returns(uint) {&#13;
        return rabbitSirePrice[_bunny];&#13;
    } &#13;
&#13;
    function getTokenOwner(address owner) public view returns(uint total, uint32[] list) {&#13;
        total = ownerBunnies[owner].length;&#13;
        list = ownerBunnies[owner];&#13;
    } &#13;
&#13;
    function totalSupply() public view returns (uint total) {&#13;
        return totalBunny;&#13;
    }&#13;
&#13;
    function balanceOf(address _owner) public view returns (uint) {&#13;
        return ownerBunnies[_owner].length;&#13;
    }&#13;
&#13;
     function getMotherCount(uint32 _mother) public view returns(uint) { //internal&#13;
        return  motherCount[_mother];&#13;
    }&#13;
&#13;
     function getTotalSalaryBunny(uint32 _bunny) public view returns(uint) { //internal&#13;
        return  totalSalaryBunny[_bunny];&#13;
    }&#13;
&#13;
    function getRabbitMother( uint32 mother) public view returns(uint32[5]) {&#13;
        return rabbitMother[mother];&#13;
    }&#13;
&#13;
     function getRabbitMotherSumm(uint32 mother) public view returns(uint count) { //internal&#13;
        for (uint m = 0; m &lt; 5 ; m++) {&#13;
            if(rabbitMother[mother][m] != 0 ) { &#13;
                count++;&#13;
            }&#13;
        }&#13;
    }&#13;
    function getDNK(uint32 bunnyid) public view returns(uint) { &#13;
        return mapDNK[bunnyid];&#13;
    }&#13;
&#13;
&#13;
    function getTokenBunny(uint32 _bunny) public &#13;
    view returns(uint32 mother, uint32 sire, uint birthblock, uint birthCount, uint birthLastTime, uint genome) { &#13;
        mother = tokenBunny[_bunny].mother;&#13;
        sire = tokenBunny[_bunny].sire;&#13;
        birthblock = tokenBunny[_bunny].birthblock;&#13;
        birthCount = tokenBunny[_bunny].birthCount;&#13;
        birthLastTime = tokenBunny[_bunny].birthLastTime;&#13;
        genome = tokenBunny[_bunny].genome;&#13;
    }&#13;
&#13;
    function isUIntPublic() public view returns(bool) {&#13;
        require(isPauseSave());&#13;
        return true;&#13;
    }&#13;
&#13;
    function getSex(uint32 _bunny) public view returns(bool) {&#13;
        if(getRabbitSirePrice(_bunny) &gt; 0) {&#13;
            return true;&#13;
        }&#13;
        return false;&#13;
    }&#13;
&#13;
    function getGenome(uint32 _bunny) public view returns( uint) { &#13;
        return tokenBunny[_bunny].genome;&#13;
    }&#13;
&#13;
    function getParent(uint32 _bunny) public view returns(uint32 mother, uint32 sire) { &#13;
        mother = tokenBunny[_bunny].mother;&#13;
        sire = tokenBunny[_bunny].sire;&#13;
    }&#13;
&#13;
    function getBirthLastTime(uint32 _bunny) public view returns(uint) { &#13;
        return tokenBunny[_bunny].birthLastTime;&#13;
    }&#13;
&#13;
    function getBirthCount(uint32 _bunny) public view returns(uint) { &#13;
        return tokenBunny[_bunny].birthCount;&#13;
    }&#13;
&#13;
    function getBirthblock(uint32 _bunny) public view returns(uint) { &#13;
        return tokenBunny[_bunny].birthblock;&#13;
    }&#13;
  &#13;
&#13;
    function getBunnyInfo(uint32 _bunny) public view returns(&#13;
        uint32 mother,&#13;
        uint32 sire,&#13;
        uint birthblock,&#13;
        uint birthCount,&#13;
        uint birthLastTime,&#13;
        bool role, &#13;
        uint genome,&#13;
        bool interbreed,&#13;
        uint leftTime,&#13;
        uint lastTime,&#13;
        uint price,&#13;
        uint motherSumm&#13;
        ) { &#13;
            role = getSex(_bunny);&#13;
            mother = tokenBunny[_bunny].mother;&#13;
            sire = tokenBunny[_bunny].sire;&#13;
            birthblock = tokenBunny[_bunny].birthblock;&#13;
            birthCount = tokenBunny[_bunny].birthCount;&#13;
            birthLastTime = tokenBunny[_bunny].birthLastTime;&#13;
            genome = tokenBunny[_bunny].genome;&#13;
            motherSumm = getMotherCount(_bunny);&#13;
            price = getRabbitSirePrice(_bunny);&#13;
            lastTime = lastTime.add(birthLastTime);&#13;
            if(lastTime &lt;= now) {&#13;
                interbreed = true;&#13;
            } else {&#13;
                leftTime = lastTime.sub(now);&#13;
            }&#13;
    }&#13;
}