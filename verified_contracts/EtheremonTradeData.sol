pragma solidity ^0.4.16;

// copyright <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="27444849534644536762534f4255424a48490944484a">[emailÂ protected]</a>&#13;
&#13;
contract SafeMath {&#13;
&#13;
    /* function assert(bool assertion) internal { */&#13;
    /*   if (!assertion) { */&#13;
    /*     throw; */&#13;
    /*   } */&#13;
    /* }      // assert no longer needed once solidity is on 0.4.10 */&#13;
&#13;
    function safeAdd(uint256 x, uint256 y) pure internal returns(uint256) {&#13;
      uint256 z = x + y;&#13;
      assert((z &gt;= x) &amp;&amp; (z &gt;= y));&#13;
      return z;&#13;
    }&#13;
&#13;
    function safeSubtract(uint256 x, uint256 y) pure internal returns(uint256) {&#13;
      assert(x &gt;= y);&#13;
      uint256 z = x - y;&#13;
      return z;&#13;
    }&#13;
&#13;
    function safeMult(uint256 x, uint256 y) pure internal returns(uint256) {&#13;
      uint256 z = x * y;&#13;
      assert((x == 0)||(z/x == y));&#13;
      return z;&#13;
    }&#13;
&#13;
}&#13;
&#13;
contract BasicAccessControl {&#13;
    address public owner;&#13;
    // address[] public moderators;&#13;
    uint16 public totalModerators = 0;&#13;
    mapping (address =&gt; bool) public moderators;&#13;
    bool public isMaintaining = false;&#13;
&#13;
    function BasicAccessControl() public {&#13;
        owner = msg.sender;&#13;
    }&#13;
&#13;
    modifier onlyOwner {&#13;
        require(msg.sender == owner);&#13;
        _;&#13;
    }&#13;
&#13;
    modifier onlyModerators() {&#13;
        require(msg.sender == owner || moderators[msg.sender] == true);&#13;
        _;&#13;
    }&#13;
&#13;
    modifier isActive {&#13;
        require(!isMaintaining);&#13;
        _;&#13;
    }&#13;
&#13;
    function ChangeOwner(address _newOwner) onlyOwner public {&#13;
        if (_newOwner != address(0)) {&#13;
            owner = _newOwner;&#13;
        }&#13;
    }&#13;
&#13;
&#13;
    function AddModerator(address _newModerator) onlyOwner public {&#13;
        if (moderators[_newModerator] == false) {&#13;
            moderators[_newModerator] = true;&#13;
            totalModerators += 1;&#13;
        }&#13;
    }&#13;
    &#13;
    function RemoveModerator(address _oldModerator) onlyOwner public {&#13;
        if (moderators[_oldModerator] == true) {&#13;
            moderators[_oldModerator] = false;&#13;
            totalModerators -= 1;&#13;
        }&#13;
    }&#13;
&#13;
    function UpdateMaintaining(bool _isMaintaining) onlyOwner public {&#13;
        isMaintaining = _isMaintaining;&#13;
    }&#13;
}&#13;
&#13;
contract EtheremonEnum {&#13;
&#13;
    enum ResultCode {&#13;
        SUCCESS,&#13;
        ERROR_CLASS_NOT_FOUND,&#13;
        ERROR_LOW_BALANCE,&#13;
        ERROR_SEND_FAIL,&#13;
        ERROR_NOT_TRAINER,&#13;
        ERROR_NOT_ENOUGH_MONEY,&#13;
        ERROR_INVALID_AMOUNT,&#13;
        ERROR_OBJ_NOT_FOUND,&#13;
        ERROR_OBJ_INVALID_OWNERSHIP&#13;
    }&#13;
    &#13;
    enum ArrayType {&#13;
        CLASS_TYPE,&#13;
        STAT_STEP,&#13;
        STAT_START,&#13;
        STAT_BASE,&#13;
        OBJ_SKILL&#13;
    }&#13;
}&#13;
&#13;
contract EtheremonDataBase is EtheremonEnum, BasicAccessControl, SafeMath {&#13;
    &#13;
    uint64 public totalMonster;&#13;
    uint32 public totalClass;&#13;
    &#13;
    // write&#13;
    function addElementToArrayType(ArrayType _type, uint64 _id, uint8 _value) onlyModerators public returns(uint);&#13;
    function removeElementOfArrayType(ArrayType _type, uint64 _id, uint8 _value) onlyModerators public returns(uint);&#13;
    function setMonsterClass(uint32 _classId, uint256 _price, uint256 _returnPrice, bool _catchable) onlyModerators public returns(uint32);&#13;
    function addMonsterObj(uint32 _classId, address _trainer, string _name) onlyModerators public returns(uint64);&#13;
    function setMonsterObj(uint64 _objId, string _name, uint32 _exp, uint32 _createIndex, uint32 _lastClaimIndex) onlyModerators public;&#13;
    function increaseMonsterExp(uint64 _objId, uint32 amount) onlyModerators public;&#13;
    function decreaseMonsterExp(uint64 _objId, uint32 amount) onlyModerators public;&#13;
    function removeMonsterIdMapping(address _trainer, uint64 _monsterId) onlyModerators public;&#13;
    function addMonsterIdMapping(address _trainer, uint64 _monsterId) onlyModerators public;&#13;
    function clearMonsterReturnBalance(uint64 _monsterId) onlyModerators public returns(uint256 amount);&#13;
    function collectAllReturnBalance(address _trainer) onlyModerators public returns(uint256 amount);&#13;
    function transferMonster(address _from, address _to, uint64 _monsterId) onlyModerators public returns(ResultCode);&#13;
    function addExtraBalance(address _trainer, uint256 _amount) onlyModerators public returns(uint256);&#13;
    function deductExtraBalance(address _trainer, uint256 _amount) onlyModerators public returns(uint256);&#13;
    function setExtraBalance(address _trainer, uint256 _amount) onlyModerators public;&#13;
    &#13;
    // read&#13;
    function getSizeArrayType(ArrayType _type, uint64 _id) constant public returns(uint);&#13;
    function getElementInArrayType(ArrayType _type, uint64 _id, uint _index) constant public returns(uint8);&#13;
    function getMonsterClass(uint32 _classId) constant public returns(uint32 classId, uint256 price, uint256 returnPrice, uint32 total, bool catchable);&#13;
    function getMonsterObj(uint64 _objId) constant public returns(uint64 objId, uint32 classId, address trainer, uint32 exp, uint32 createIndex, uint32 lastClaimIndex, uint createTime);&#13;
    function getMonsterName(uint64 _objId) constant public returns(string name);&#13;
    function getExtraBalance(address _trainer) constant public returns(uint256);&#13;
    function getMonsterDexSize(address _trainer) constant public returns(uint);&#13;
    function getMonsterObjId(address _trainer, uint index) constant public returns(uint64);&#13;
    function getExpectedBalance(address _trainer) constant public returns(uint256);&#13;
    function getMonsterReturn(uint64 _objId) constant public returns(uint256 current, uint256 total);&#13;
}&#13;
&#13;
interface EtheremonBattleInterface {&#13;
    function isOnBattle(uint64 _objId) constant external returns(bool) ;&#13;
}&#13;
&#13;
interface EtheremonMonsterNFTInterface {&#13;
   function triggerTransferEvent(address _from, address _to, uint _tokenId) external;&#13;
   function getMonsterCP(uint64 _monsterId) constant external returns(uint cp);&#13;
}&#13;
&#13;
contract EtheremonTradeData is BasicAccessControl {&#13;
    struct BorrowItem {&#13;
        uint index;&#13;
        address owner;&#13;
        address borrower;&#13;
        uint price;&#13;
        bool lent;&#13;
        uint releaseTime;&#13;
        uint createTime;&#13;
    }&#13;
    &#13;
    struct SellingItem {&#13;
        uint index;&#13;
        uint price;&#13;
        uint createTime;&#13;
    }&#13;
&#13;
    mapping(uint =&gt; SellingItem) public sellingDict; // monster id =&gt; item&#13;
    uint[] public sellingList; // monster id&#13;
    &#13;
    mapping(uint =&gt; BorrowItem) public borrowingDict;&#13;
    uint[] public borrowingList;&#13;
&#13;
    mapping(address =&gt; uint[]) public lendingList;&#13;
    &#13;
    function removeSellingItem(uint _itemId) onlyModerators external {&#13;
        SellingItem storage item = sellingDict[_itemId];&#13;
        if (item.index == 0)&#13;
            return;&#13;
        &#13;
        if (item.index &lt;= sellingList.length) {&#13;
            // Move an existing element into the vacated key slot.&#13;
            sellingDict[sellingList[sellingList.length-1]].index = item.index;&#13;
            sellingList[item.index-1] = sellingList[sellingList.length-1];&#13;
            sellingList.length -= 1;&#13;
            delete sellingDict[_itemId];&#13;
        }&#13;
    }&#13;
    &#13;
    function addSellingItem(uint _itemId, uint _price, uint _createTime) onlyModerators external {&#13;
        SellingItem storage item = sellingDict[_itemId];&#13;
        item.price = _price;&#13;
        item.createTime = _createTime;&#13;
        &#13;
        if (item.index == 0) {&#13;
            item.index = ++sellingList.length;&#13;
            sellingList[item.index - 1] = _itemId;&#13;
        }&#13;
    }&#13;
    &#13;
    function removeBorrowingItem(uint _itemId) onlyModerators external {&#13;
        BorrowItem storage item = borrowingDict[_itemId];&#13;
        if (item.index == 0)&#13;
            return;&#13;
        &#13;
        if (item.index &lt;= borrowingList.length) {&#13;
            // Move an existing element into the vacated key slot.&#13;
            borrowingDict[borrowingList[borrowingList.length-1]].index = item.index;&#13;
            borrowingList[item.index-1] = borrowingList[borrowingList.length-1];&#13;
            borrowingList.length -= 1;&#13;
            delete borrowingDict[_itemId];&#13;
        }&#13;
    }&#13;
&#13;
    function addBorrowingItem(address _owner, uint _itemId, uint _price, address _borrower, bool _lent, uint _releaseTime, uint _createTime) onlyModerators external {&#13;
        BorrowItem storage item = borrowingDict[_itemId];&#13;
        item.owner = _owner;&#13;
        item.borrower = _borrower;&#13;
        item.price = _price;&#13;
        item.lent = _lent;&#13;
        item.releaseTime = _releaseTime;&#13;
        item.createTime = _createTime;&#13;
        &#13;
        if (item.index == 0) {&#13;
            item.index = ++borrowingList.length;&#13;
            borrowingList[item.index - 1] = _itemId;&#13;
        }&#13;
    }&#13;
    &#13;
    function addItemLendingList(address _trainer, uint _objId) onlyModerators external {&#13;
        lendingList[_trainer].push(_objId);&#13;
    }&#13;
    &#13;
    function removeItemLendingList(address _trainer, uint _objId) onlyModerators external {&#13;
        uint foundIndex = 0;&#13;
        uint[] storage objList = lendingList[_trainer];&#13;
        for (; foundIndex &lt; objList.length; foundIndex++) {&#13;
            if (objList[foundIndex] == _objId) {&#13;
                break;&#13;
            }&#13;
        }&#13;
        if (foundIndex &lt; objList.length) {&#13;
            objList[foundIndex] = objList[objList.length-1];&#13;
            delete objList[objList.length-1];&#13;
            objList.length--;&#13;
        }&#13;
    }&#13;
&#13;
    // read access&#13;
    function isOnBorrow(uint _objId) constant external returns(bool) {&#13;
        return (borrowingDict[_objId].index &gt; 0);&#13;
    }&#13;
    &#13;
    function isOnSell(uint _objId) constant external returns(bool) {&#13;
        return (sellingDict[_objId].index &gt; 0);&#13;
    }&#13;
    &#13;
    function isOnLent(uint _objId) constant external returns(bool) {&#13;
        return borrowingDict[_objId].lent;&#13;
    }&#13;
    &#13;
    function getSellPrice(uint _objId) constant external returns(uint) {&#13;
        return sellingDict[_objId].price;&#13;
    }&#13;
    &#13;
    function isOnTrade(uint _objId) constant external returns(bool) {&#13;
        return ((borrowingDict[_objId].index &gt; 0) || (sellingDict[_objId].index &gt; 0)); &#13;
    }&#13;
    &#13;
    function getBorrowBasicInfo(uint _objId) constant external returns(address owner, bool lent) {&#13;
        BorrowItem storage borrowItem = borrowingDict[_objId];&#13;
        return (borrowItem.owner, borrowItem.lent);&#13;
    }&#13;
    &#13;
    function getBorrowInfo(uint _objId) constant external returns(uint index, address owner, address borrower, uint price, bool lent, uint createTime, uint releaseTime) {&#13;
        BorrowItem storage borrowItem = borrowingDict[_objId];&#13;
        return (borrowItem.index, borrowItem.owner, borrowItem.borrower, borrowItem.price, borrowItem.lent, borrowItem.createTime, borrowItem.releaseTime);&#13;
    }&#13;
    &#13;
    function getSellInfo(uint _objId) constant external returns(uint index, uint price, uint createTime) {&#13;
        SellingItem storage item = sellingDict[_objId];&#13;
        return (item.index, item.price, item.createTime);&#13;
    }&#13;
    &#13;
    function getTotalSellingItem() constant external returns(uint) {&#13;
        return sellingList.length;&#13;
    }&#13;
    &#13;
    function getTotalBorrowingItem() constant external returns(uint) {&#13;
        return borrowingList.length;&#13;
    }&#13;
    &#13;
    function getTotalLendingItem(address _trainer) constant external returns(uint) {&#13;
        return lendingList[_trainer].length;&#13;
    }&#13;
    &#13;
    function getSellingInfoByIndex(uint _index) constant external returns(uint objId, uint price, uint createTime) {&#13;
        objId = sellingList[_index];&#13;
        SellingItem storage item = sellingDict[objId];&#13;
        price = item.price;&#13;
        createTime = item.createTime;&#13;
    }&#13;
    &#13;
    function getBorrowInfoByIndex(uint _index) constant external returns(uint objId, address owner, address borrower, uint price, bool lent, uint createTime, uint releaseTime) {&#13;
        objId = borrowingList[_index];&#13;
        BorrowItem storage borrowItem = borrowingDict[objId];&#13;
        return (objId, borrowItem.owner, borrowItem.borrower, borrowItem.price, borrowItem.lent, borrowItem.createTime, borrowItem.releaseTime);&#13;
    }&#13;
    &#13;
    function getLendingObjId(address _trainer, uint _index) constant external returns(uint) {&#13;
        return lendingList[_trainer][_index];&#13;
    }&#13;
    &#13;
    function getLendingInfo(address _trainer, uint _index) constant external returns(uint objId, address owner, address borrower, uint price, bool lent, uint createTime, uint releaseTime) {&#13;
        objId = lendingList[_trainer][_index];&#13;
        BorrowItem storage borrowItem = borrowingDict[objId];&#13;
        return (objId, borrowItem.owner, borrowItem.borrower, borrowItem.price, borrowItem.lent, borrowItem.createTime, borrowItem.releaseTime);&#13;
    }&#13;
    &#13;
    function getTradingInfo(uint _objId) constant external returns(uint sellingPrice, uint lendingPrice, bool lent, uint releaseTime, address owner, address borrower) {&#13;
        SellingItem storage item = sellingDict[_objId];&#13;
        sellingPrice = item.price;&#13;
        BorrowItem storage borrowItem = borrowingDict[_objId];&#13;
        lendingPrice = borrowItem.price;&#13;
        lent = borrowItem.lent;&#13;
        releaseTime = borrowItem.releaseTime;&#13;
        owner = borrowItem.owner;&#13;
        borrower = borrower;&#13;
    }&#13;
}