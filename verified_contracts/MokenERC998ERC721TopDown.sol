pragma solidity 0.4.24;
pragma experimental "v0.5.0";
/******************************************************************************\
* Author: Nick Mudge, <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="e48a8d878fa4898b8f818a97ca8d8b">[emailÂ protected]</a>&#13;
* Mokens&#13;
* Copyright (c) 2018&#13;
*&#13;
* Implements ERC998ERC721TopDown.&#13;
/******************************************************************************/&#13;
///////////////////////////////////////////////////////////////////////////////////&#13;
//Storage contracts&#13;
////////////&#13;
//Some delegate contracts are listed with storage contracts they inherit.&#13;
///////////////////////////////////////////////////////////////////////////////////&#13;
&#13;
///////////////////////////////////////////////////////////////////////////////////&#13;
//Mokens&#13;
///////////////////////////////////////////////////////////////////////////////////&#13;
contract Storage0 {&#13;
    // funcId =&gt; delegate contract&#13;
    mapping(bytes4 =&gt; address) internal delegates;&#13;
}&#13;
///////////////////////////////////////////////////////////////////////////////////&#13;
//MokenUpdates&#13;
//MokenOwner&#13;
//QueryMokenDelegates&#13;
///////////////////////////////////////////////////////////////////////////////////&#13;
contract Storage1 is Storage0 {&#13;
    address internal contractOwner;&#13;
    bytes[] internal funcSignatures;&#13;
    // signature =&gt; index+1&#13;
    mapping(bytes =&gt; uint256) internal funcSignatureToIndex;&#13;
}&#13;
///////////////////////////////////////////////////////////////////////////////////&#13;
//MokensSupportsInterfaces&#13;
///////////////////////////////////////////////////////////////////////////////////&#13;
contract Storage2 is Storage1 {&#13;
    mapping(bytes4 =&gt; bool) internal supportedInterfaces;&#13;
}&#13;
///////////////////////////////////////////////////////////////////////////////////&#13;
//MokenRootOwnerOf&#13;
//MokenERC721Metadata&#13;
///////////////////////////////////////////////////////////////////////////////////&#13;
contract Storage3 is Storage2 {&#13;
    struct Moken {&#13;
        string name;&#13;
        uint256 data;&#13;
        uint256 parentTokenId;&#13;
    }&#13;
    //tokenId =&gt; moken&#13;
    mapping(uint256 =&gt; Moken) internal mokens;&#13;
    uint256 internal mokensLength;&#13;
    // child address =&gt; child tokenId =&gt; tokenId+1&#13;
    mapping(address =&gt; mapping(uint256 =&gt; uint256)) internal childTokenOwner;&#13;
}&#13;
///////////////////////////////////////////////////////////////////////////////////&#13;
//MokenERC721Enumerable&#13;
//MokenLinkHash&#13;
///////////////////////////////////////////////////////////////////////////////////&#13;
contract Storage4 is Storage3 {&#13;
    // root token owner address =&gt; (tokenId =&gt; approved address)&#13;
    mapping(address =&gt; mapping(uint256 =&gt; address)) internal rootOwnerAndTokenIdToApprovedAddress;&#13;
    // token owner =&gt; (operator address =&gt; bool)&#13;
    mapping(address =&gt; mapping(address =&gt; bool)) internal tokenOwnerToOperators;&#13;
    // Mapping from owner to list of owned token IDs&#13;
    mapping(address =&gt; uint32[]) internal ownedTokens;&#13;
}&#13;
///////////////////////////////////////////////////////////////////////////////////&#13;
//MokenERC998ERC721TopDown&#13;
//MokenERC998ERC721TopDownBatch&#13;
//MokenERC721&#13;
//MokenERC721Batch&#13;
///////////////////////////////////////////////////////////////////////////////////&#13;
contract Storage5 is Storage4 {&#13;
    // tokenId =&gt; (child address =&gt; array of child tokens)&#13;
    mapping(uint256 =&gt; mapping(address =&gt; uint256[])) internal childTokens;&#13;
    // tokenId =&gt; (child address =&gt; (child token =&gt; child index)&#13;
    mapping(uint256 =&gt; mapping(address =&gt; mapping(uint256 =&gt; uint256))) internal childTokenIndex;&#13;
    // tokenId =&gt; (child address =&gt; contract index)&#13;
    mapping(uint256 =&gt; mapping(address =&gt; uint256)) internal childContractIndex;&#13;
    // tokenId =&gt; child contract&#13;
    mapping(uint256 =&gt; address[]) internal childContracts;&#13;
}&#13;
&#13;
contract RootOwnerOfHelper is Storage3 {&#13;
&#13;
    bytes32 constant ERC998_MAGIC_VALUE = 0xcd740db5;&#13;
&#13;
    // Use Cases handled:&#13;
    // Case 1: Token owner is this contract and token&#13;
    // Case 2: Token owner is this contract and top-down composable.&#13;
    // Case 3: Token owner is top-down composable&#13;
    // Case 4: Token owner is an unknown contract&#13;
    // Case 5: Token owner is a user&#13;
    // Case 6: Token owner is a bottom-up composable&#13;
    // Case 7: Token owner is ERC721 token owned by top-down token&#13;
    // Case 8: Token owner is ERC721 token owned by unknown contract&#13;
    // Case 9: Token owner is ERC721 token owned by user&#13;
    function rootOwnerOf_(uint256 _tokenId) internal view returns (bytes32 rootOwner) {&#13;
        address rootOwnerAddress = address(mokens[_tokenId].data);&#13;
        require(rootOwnerAddress != address(0), "tokenId not found.");&#13;
        uint256 parentTokenId;&#13;
        bool isParent;&#13;
&#13;
        while (rootOwnerAddress == address(this)) {&#13;
            parentTokenId = mokens[_tokenId].parentTokenId;&#13;
            isParent = parentTokenId &gt; 0;&#13;
            if (isParent) {&#13;
                // Case 1: Token owner is this contract and token&#13;
                _tokenId = parentTokenId - 1;&#13;
            }&#13;
            else {&#13;
                // Case 2: Token owner is this contract and top-down composable.&#13;
                _tokenId = childTokenOwner[rootOwnerAddress][_tokenId] - 1;&#13;
            }&#13;
            rootOwnerAddress = address(mokens[_tokenId].data);&#13;
        }&#13;
&#13;
        parentTokenId = mokens[_tokenId].parentTokenId;&#13;
        isParent = parentTokenId &gt; 0;&#13;
        if (isParent) {&#13;
            parentTokenId--;&#13;
        }&#13;
&#13;
        bytes memory calldata;&#13;
        bool callSuccess;&#13;
&#13;
        if (isParent == false) {&#13;
&#13;
            // success if this token is owned by a top-down token&#13;
            // 0xed81cdda == rootOwnerOfChild(address,uint256)&#13;
            calldata = abi.encodeWithSelector(0xed81cdda, address(this), _tokenId);&#13;
            assembly {&#13;
                callSuccess := staticcall(gas, rootOwnerAddress, add(calldata, 0x20), mload(calldata), calldata, 0x20)&#13;
                if callSuccess {&#13;
                    rootOwner := mload(calldata)&#13;
                }&#13;
            }&#13;
            if (callSuccess == true &amp;&amp; rootOwner &gt;&gt; 224 == ERC998_MAGIC_VALUE) {&#13;
                // Case 3: Token owner is top-down composable&#13;
                return rootOwner;&#13;
            }&#13;
            else {&#13;
                // Case 4: Token owner is an unknown contract&#13;
                // Or&#13;
                // Case 5: Token owner is a user&#13;
                return ERC998_MAGIC_VALUE &lt;&lt; 224 | bytes32(rootOwnerAddress);&#13;
            }&#13;
        }&#13;
        else {&#13;
&#13;
            // 0x43a61a8e == rootOwnerOf(uint256)&#13;
            calldata = abi.encodeWithSelector(0x43a61a8e, parentTokenId);&#13;
            assembly {&#13;
                callSuccess := staticcall(gas, rootOwnerAddress, add(calldata, 0x20), mload(calldata), calldata, 0x20)&#13;
                if callSuccess {&#13;
                    rootOwner := mload(calldata)&#13;
                }&#13;
            }&#13;
            if (callSuccess == true &amp;&amp; rootOwner &gt;&gt; 224 == ERC998_MAGIC_VALUE) {&#13;
                // Case 6: Token owner is a bottom-up composable&#13;
                // Or&#13;
                // Case 2: Token owner is top-down composable&#13;
                return rootOwner;&#13;
            }&#13;
            else {&#13;
                // token owner is ERC721&#13;
                address childContract = rootOwnerAddress;&#13;
                //0x6352211e == "ownerOf(uint256)"&#13;
                calldata = abi.encodeWithSelector(0x6352211e, parentTokenId);&#13;
                assembly {&#13;
                    callSuccess := staticcall(gas, rootOwnerAddress, add(calldata, 0x20), mload(calldata), calldata, 0x20)&#13;
                    if callSuccess {&#13;
                        rootOwnerAddress := mload(calldata)&#13;
                    }&#13;
                }&#13;
                require(callSuccess, "Call to ownerOf failed");&#13;
&#13;
                // 0xed81cdda == rootOwnerOfChild(address,uint256)&#13;
                calldata = abi.encodeWithSelector(0xed81cdda, childContract, parentTokenId);&#13;
                assembly {&#13;
                    callSuccess := staticcall(gas, rootOwnerAddress, add(calldata, 0x20), mload(calldata), calldata, 0x20)&#13;
                    if callSuccess {&#13;
                        rootOwner := mload(calldata)&#13;
                    }&#13;
                }&#13;
                if (callSuccess == true &amp;&amp; rootOwner &gt;&gt; 224 == ERC998_MAGIC_VALUE) {&#13;
                    // Case 7: Token owner is ERC721 token owned by top-down token&#13;
                    return rootOwner;&#13;
                }&#13;
                else {&#13;
                    // Case 8: Token owner is ERC721 token owned by unknown contract&#13;
                    // Or&#13;
                    // Case 9: Token owner is ERC721 token owned by user&#13;
                    return ERC998_MAGIC_VALUE &lt;&lt; 224 | bytes32(rootOwnerAddress);&#13;
                }&#13;
            }&#13;
        }&#13;
    }&#13;
}&#13;
&#13;
contract MokenHelpers is Storage4, RootOwnerOfHelper {&#13;
&#13;
    bytes4 constant ERC721_RECEIVED_NEW = 0x150b7a02;&#13;
&#13;
    uint256 constant UINT16_MASK = 0x000000000000000000000000000000000000000000000000000000000000ffff;&#13;
    uint256 constant MAX_OWNER_MOKENS = 65536;&#13;
&#13;
    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);&#13;
    event Approval(address indexed tokenOwner, address indexed approved, uint256 indexed tokenId);&#13;
&#13;
    function childApproved(address _from, uint256 _tokenId) internal {&#13;
        address approvedAddress = rootOwnerAndTokenIdToApprovedAddress[_from][_tokenId];&#13;
        if(msg.sender != _from) {&#13;
            bytes32 tokenOwner;&#13;
            bool callSuccess;&#13;
            // 0xeadb80b8 == ownerOfChild(address,uint256)&#13;
            bytes memory calldata = abi.encodeWithSelector(0xed81cdda, address(this), _tokenId);&#13;
            assembly {&#13;
                callSuccess := staticcall(gas, _from, add(calldata, 0x20), mload(calldata), calldata, 0x20)&#13;
                if callSuccess {&#13;
                    tokenOwner := mload(calldata)&#13;
                }&#13;
            }&#13;
            if(callSuccess == true) {&#13;
                require(tokenOwner &gt;&gt; 224 != ERC998_MAGIC_VALUE, "Token is child of top down composable");&#13;
            }&#13;
            require(tokenOwnerToOperators[_from][msg.sender] || approvedAddress == msg.sender, "msg.sender not _from/operator/approved.");&#13;
        }&#13;
        if (approvedAddress != address(0)) {&#13;
            delete rootOwnerAndTokenIdToApprovedAddress[_from][_tokenId];&#13;
            emit Approval(_from, address(0), _tokenId);&#13;
        }&#13;
    }&#13;
&#13;
    function _transferFrom(uint256 data, address _to, uint256 _tokenId) internal {&#13;
        address _from = address(data);&#13;
        //removing the tokenId&#13;
        // 1. We replace _tokenId in ownedTokens[_from] with the last token id&#13;
        //    in ownedTokens[_from]&#13;
        uint256 lastTokenIndex = ownedTokens[_from].length - 1;&#13;
        uint256 lastTokenId = ownedTokens[_from][lastTokenIndex];&#13;
        if (lastTokenId != _tokenId) {&#13;
            uint256 tokenIndex = data &gt;&gt; 160 &amp; UINT16_MASK;&#13;
            ownedTokens[_from][tokenIndex] = uint32(lastTokenId);&#13;
            // 2. We set lastTokeId to point to its new position in ownedTokens[_from]&#13;
            mokens[lastTokenId].data = mokens[lastTokenId].data &amp; 0xffffffffffffffffffff0000ffffffffffffffffffffffffffffffffffffffff | tokenIndex &lt;&lt; 160;&#13;
        }&#13;
        // 3. We remove lastTokenId from the end of ownedTokens[_from]&#13;
        ownedTokens[_from].length--;&#13;
&#13;
        //adding the tokenId&#13;
        uint256 ownedTokensIndex = ownedTokens[_to].length;&#13;
        // prevents 16 bit overflow&#13;
        require(ownedTokensIndex &lt; MAX_OWNER_MOKENS, "A token owner address cannot possess more than 65,536 mokens.");&#13;
        mokens[_tokenId].data = data &amp; 0xffffffffffffffffffff00000000000000000000000000000000000000000000 | ownedTokensIndex &lt;&lt; 160 | uint256(_to);&#13;
        ownedTokens[_to].push(uint32(_tokenId));&#13;
&#13;
        emit Transfer(_from, _to, _tokenId);&#13;
    }&#13;
&#13;
    function isContract(address addr) internal view returns (bool) {&#13;
        uint256 size;&#13;
        assembly {size := extcodesize(addr)}&#13;
        return size &gt; 0;&#13;
    }&#13;
}&#13;
&#13;
interface ERC721 {&#13;
    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);&#13;
    event Approval(address indexed tokenOwner, address indexed approved, uint256 indexed tokenId);&#13;
    event ApprovalForAll(address indexed tokenOwner, address indexed operator, bool approved);&#13;
&#13;
    function balanceOf(address _tokenOwner) external view returns (uint256 _balance);&#13;
    function ownerOf(uint256 _tokenId) external view returns (address _tokenOwner);&#13;
    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes _data) external;&#13;
    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external;&#13;
    function transferFrom(address _from, address _to, uint256 _tokenId) external;&#13;
    function approve(address _to, uint256 _tokenId) external;&#13;
    function setApprovalForAll(address _operator, bool _approved) external;&#13;
    function getApproved(uint256 _tokenId) external view returns (address _operator);&#13;
    function isApprovedForAll(address _tokenOwner, address _operator) external view returns (bool);&#13;
}&#13;
&#13;
interface ERC998ERC721BottomUp {&#13;
    function transferToParent(address _from, address _toContract, uint256 _toTokenId, uint256 _tokenId, bytes _data) external;&#13;
&#13;
}&#13;
&#13;
contract MokenERC998ERC721TopDown is Storage5, RootOwnerOfHelper {&#13;
&#13;
    event ReceivedChild(address indexed from, uint256 indexed tokenId, address indexed childContract, uint256 childTokenId);&#13;
    event TransferChild(uint256 indexed tokenId, address indexed to, address indexed childContract, uint256 childTokenId);&#13;
&#13;
    bytes4 constant ERC721_RECEIVED_OLD = 0xf0b9e5ba;&#13;
    bytes4 constant ERC721_RECEIVED_NEW = 0x150b7a02;&#13;
&#13;
    function removeChild(uint256 _fromTokenId, address _childContract, uint256 _childTokenId) internal {&#13;
        // remove child token&#13;
        uint256 lastTokenIndex = childTokens[_fromTokenId][_childContract].length - 1;&#13;
        uint256 lastToken = childTokens[_fromTokenId][_childContract][lastTokenIndex];&#13;
        if (_childTokenId != lastToken) {&#13;
            uint256 tokenIndex = childTokenIndex[_fromTokenId][_childContract][_childTokenId];&#13;
            childTokens[_fromTokenId][_childContract][tokenIndex] = lastToken;&#13;
            childTokenIndex[_fromTokenId][_childContract][lastToken] = tokenIndex;&#13;
        }&#13;
        childTokens[_fromTokenId][_childContract].length--;&#13;
        delete childTokenIndex[_fromTokenId][_childContract][_childTokenId];&#13;
        delete childTokenOwner[_childContract][_childTokenId];&#13;
&#13;
        // remove contract&#13;
        if (lastTokenIndex == 0) {&#13;
            uint256 lastContractIndex = childContracts[_fromTokenId].length - 1;&#13;
            address lastContract = childContracts[_fromTokenId][lastContractIndex];&#13;
            if (_childContract != lastContract) {&#13;
                uint256 contractIndex = childContractIndex[_fromTokenId][_childContract];&#13;
                childContracts[_fromTokenId][contractIndex] = lastContract;&#13;
                childContractIndex[_fromTokenId][lastContract] = contractIndex;&#13;
            }&#13;
            childContracts[_fromTokenId].length--;&#13;
            delete childContractIndex[_fromTokenId][_childContract];&#13;
        }&#13;
    }&#13;
&#13;
    function safeTransferChild(uint256 _fromTokenId, address _to, address _childContract, uint256 _childTokenId) external {&#13;
        uint256 tokenId = childTokenOwner[_childContract][_childTokenId];&#13;
        require(tokenId != 0, "Child token does not exist");&#13;
        require(_fromTokenId == tokenId - 1, "_fromTokenId does not own the child token.");&#13;
        require(_to != address(0), "_to cannot be 0 address.");&#13;
        address rootOwner = address(rootOwnerOf_(_fromTokenId));&#13;
        require(rootOwner == msg.sender || tokenOwnerToOperators[rootOwner][msg.sender] ||&#13;
        rootOwnerAndTokenIdToApprovedAddress[rootOwner][_fromTokenId] == msg.sender, "msg.sender not rootOwner/operator/approved.");&#13;
        removeChild(_fromTokenId, _childContract, _childTokenId);&#13;
        ERC721(_childContract).safeTransferFrom(this, _to, _childTokenId);&#13;
        emit TransferChild(_fromTokenId, _to, _childContract, _childTokenId);&#13;
    }&#13;
&#13;
    function safeTransferChild(uint256 _fromTokenId, address _to, address _childContract, uint256 _childTokenId, bytes _data) external {&#13;
        uint256 tokenId = childTokenOwner[_childContract][_childTokenId];&#13;
        require(tokenId != 0, "Child token does not exist");&#13;
        require(_fromTokenId == tokenId - 1, "_fromTokenId does not own the child token.");&#13;
        require(_to != address(0), "_to cannot be 0 address.");&#13;
        address rootOwner = address(rootOwnerOf_(_fromTokenId));&#13;
        require(rootOwner == msg.sender || tokenOwnerToOperators[rootOwner][msg.sender] ||&#13;
        rootOwnerAndTokenIdToApprovedAddress[rootOwner][_fromTokenId] == msg.sender, "msg.sender not rootOwner/operator/approved.");&#13;
        removeChild(_fromTokenId, _childContract, _childTokenId);&#13;
        ERC721(_childContract).safeTransferFrom(this, _to, _childTokenId, _data);&#13;
        emit TransferChild(_fromTokenId, _to, _childContract, _childTokenId);&#13;
    }&#13;
&#13;
    function transferChild(uint256 _fromTokenId, address _to, address _childContract, uint256 _childTokenId) external {&#13;
        uint256 tokenId = childTokenOwner[_childContract][_childTokenId];&#13;
        require(tokenId != 0, "Child token does not exist");&#13;
        require(_fromTokenId == tokenId - 1, "_fromTokenId does not own the child token.");&#13;
        require(_to != address(0), "_to cannot be 0 address.");&#13;
        address rootOwner = address(rootOwnerOf_(_fromTokenId));&#13;
        require(rootOwner == msg.sender || tokenOwnerToOperators[rootOwner][msg.sender] ||&#13;
        rootOwnerAndTokenIdToApprovedAddress[rootOwner][_fromTokenId] == msg.sender, "msg.sender not rootOwner/operator/approved.");&#13;
        removeChild(_fromTokenId, _childContract, _childTokenId);&#13;
        //this is here to be compatible with cryptokitties and other old contracts that require being owner and approved&#13;
        // before transferring.&#13;
        //It is not required by current standard , so we let it fail if it fails&#13;
        //0x095ea7b3 == "approve(address,uint256)"&#13;
        bytes memory calldata = abi.encodeWithSelector(0x095ea7b3, this, _childTokenId);&#13;
        assembly {&#13;
            let success := call(gas, _childContract, 0, add(calldata, 0x20), mload(calldata), calldata, 0)&#13;
        }&#13;
        ERC721(_childContract).transferFrom(this, _to, _childTokenId);&#13;
        emit TransferChild(_fromTokenId, _to, _childContract, _childTokenId);&#13;
    }&#13;
&#13;
    function transferChildToParent(uint256 _fromTokenId, address _toContract, uint256 _toTokenId, address _childContract, uint256 _childTokenId, bytes _data) external {&#13;
        uint256 tokenId = childTokenOwner[_childContract][_childTokenId];&#13;
        require(tokenId != 0, "Child token does not exist");&#13;
        require(_fromTokenId == tokenId - 1, "_fromTokenId does not own the child token.");&#13;
        require(_toContract != address(0), "_toContract cannot be 0 address.");&#13;
        address rootOwner = address(rootOwnerOf_(_fromTokenId));&#13;
        require(rootOwner == msg.sender || tokenOwnerToOperators[rootOwner][msg.sender] ||&#13;
        rootOwnerAndTokenIdToApprovedAddress[rootOwner][_fromTokenId] == msg.sender, "msg.sender not rootOwner/operator/approved.");&#13;
        removeChild(_fromTokenId, _childContract, _childTokenId);&#13;
        ERC998ERC721BottomUp(_childContract).transferToParent(address(this), _toContract, _toTokenId, _childTokenId, _data);&#13;
        emit TransferChild(_fromTokenId, _toContract, _childContract, _childTokenId);&#13;
    }&#13;
&#13;
    function receiveChild(address _from, uint256 _toTokenId, address _childContract, uint256 _childTokenId) internal {&#13;
        require(address(mokens[_toTokenId].data) != address(0), "_tokenId does not exist.");&#13;
        require(childTokenOwner[_childContract][_childTokenId] == 0, "Child token already received.");&#13;
        uint256 childTokensLength = childTokens[_toTokenId][_childContract].length;&#13;
        if (childTokensLength == 0) {&#13;
            childContractIndex[_toTokenId][_childContract] = childContracts[_toTokenId].length;&#13;
            childContracts[_toTokenId].push(_childContract);&#13;
        }&#13;
        childTokenIndex[_toTokenId][_childContract][_childTokenId] = childTokensLength;&#13;
        childTokens[_toTokenId][_childContract].push(_childTokenId);&#13;
        childTokenOwner[_childContract][_childTokenId] = _toTokenId + 1;&#13;
        emit ReceivedChild(_from, _toTokenId, _childContract, _childTokenId);&#13;
    }&#13;
&#13;
    // this contract has to be approved first in _childContract&#13;
    function getChild(address _from, uint256 _toTokenId, address _childContract, uint256 _childTokenId) external {&#13;
        receiveChild(_from, _toTokenId, _childContract, _childTokenId);&#13;
        require(_from == msg.sender ||&#13;
        ERC721(_childContract).getApproved(_childTokenId) == msg.sender ||&#13;
        ERC721(_childContract).isApprovedForAll(_from, msg.sender), "msg.sender is not owner/operator/approved for child token.");&#13;
        ERC721(_childContract).transferFrom(_from, this, _childTokenId);&#13;
    }&#13;
&#13;
    function onERC721Received(address _from, uint256 _childTokenId, bytes _data) external returns (bytes4) {&#13;
        require(_data.length &gt; 0, "_data must contain the uint256 tokenId to transfer the child token to.");&#13;
        // convert up to 32 bytes of_data to uint256, owner nft tokenId passed as uint in bytes&#13;
        uint256 toTokenId;&#13;
        assembly {toTokenId := calldataload(132)}&#13;
        if (_data.length &lt; 32) {&#13;
            toTokenId = toTokenId &gt;&gt; 256 - _data.length * 8;&#13;
        }&#13;
        receiveChild(_from, toTokenId, msg.sender, _childTokenId);&#13;
        require(ERC721(msg.sender).ownerOf(_childTokenId) != address(0), "Child token not owned.");&#13;
        return ERC721_RECEIVED_OLD;&#13;
    }&#13;
&#13;
    function onERC721Received(address _operator, address _from, uint256 _childTokenId, bytes _data) external returns (bytes4) {&#13;
        require(_data.length &gt; 0, "_data must contain the uint256 tokenId to transfer the child token to.");&#13;
        // convert up to 32 bytes of_data to uint256, owner nft tokenId passed as uint in bytes&#13;
        uint256 toTokenId;&#13;
        assembly {toTokenId := calldataload(164)}&#13;
        if (_data.length &lt; 32) {&#13;
            toTokenId = toTokenId &gt;&gt; 256 - _data.length * 8;&#13;
        }&#13;
        receiveChild(_from, toTokenId, msg.sender, _childTokenId);&#13;
        require(ERC721(msg.sender).ownerOf(_childTokenId) != address(0), "Child token not owned.");&#13;
        return ERC721_RECEIVED_NEW;&#13;
    }&#13;
&#13;
    function ownerOfChild(address _childContract, uint256 _childTokenId) external view returns (bytes32 parentTokenOwner, uint256 parentTokenId) {&#13;
        parentTokenId = childTokenOwner[_childContract][_childTokenId];&#13;
        require(parentTokenId != 0, "ERC721 token is not a child in this contract.");&#13;
        parentTokenId--;&#13;
        return (ERC998_MAGIC_VALUE &lt;&lt; 224 | bytes32(address(mokens[parentTokenId].data)), parentTokenId);&#13;
    }&#13;
&#13;
    function childExists(address _childContract, uint256 _childTokenId) external view returns (bool) {&#13;
        return childTokenOwner[_childContract][_childTokenId] != 0;&#13;
    }&#13;
&#13;
    function totalChildContracts(uint256 _tokenId) external view returns (uint256) {&#13;
        return childContracts[_tokenId].length;&#13;
    }&#13;
&#13;
    function childContractByIndex(uint256 _tokenId, uint256 _index) external view returns (address childContract) {&#13;
        require(_index &lt; childContracts[_tokenId].length, "Contract address does not exist for this token and index.");&#13;
        return childContracts[_tokenId][_index];&#13;
    }&#13;
&#13;
    function totalChildTokens(uint256 _tokenId, address _childContract) external view returns (uint256) {&#13;
        return childTokens[_tokenId][_childContract].length;&#13;
    }&#13;
&#13;
    function childTokenByIndex(uint256 _tokenId, address _childContract, uint256 _index) external view returns (uint256 childTokenId) {&#13;
        require(_index &lt; childTokens[_tokenId][_childContract].length, "Token does not own a child token at contract address and index.");&#13;
        return childTokens[_tokenId][_childContract][_index];&#13;
    }&#13;
}