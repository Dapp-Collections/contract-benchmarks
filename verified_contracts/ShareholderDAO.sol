/**
 * Copyright (c) 2018 blockimmo AG <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="2a4643494f44594f6a484645494143474745044942">[emailÂ protected]</a>&#13;
 * Non-Profit Open Software License 3.0 (NPOSL-3.0)&#13;
 * https://opensource.org/licenses/NPOSL-3.0&#13;
 */&#13;
&#13;
&#13;
pragma solidity 0.4.25;&#13;
&#13;
&#13;
/**&#13;
 * @title SafeMath&#13;
 * @dev Math operations with safety checks that throw on error&#13;
 */&#13;
library SafeMath {&#13;
&#13;
  /**&#13;
  * @dev Multiplies two numbers, throws on overflow.&#13;
  */&#13;
  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {&#13;
    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the&#13;
    // benefit is lost if 'b' is also tested.&#13;
    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522&#13;
    if (_a == 0) {&#13;
      return 0;&#13;
    }&#13;
&#13;
    c = _a * _b;&#13;
    assert(c / _a == _b);&#13;
    return c;&#13;
  }&#13;
&#13;
  /**&#13;
  * @dev Integer division of two numbers, truncating the quotient.&#13;
  */&#13;
  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {&#13;
    // assert(_b &gt; 0); // Solidity automatically throws when dividing by 0&#13;
    // uint256 c = _a / _b;&#13;
    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold&#13;
    return _a / _b;&#13;
  }&#13;
&#13;
  /**&#13;
  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).&#13;
  */&#13;
  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {&#13;
    assert(_b &lt;= _a);&#13;
    return _a - _b;&#13;
  }&#13;
&#13;
  /**&#13;
  * @dev Adds two numbers, throws on overflow.&#13;
  */&#13;
  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {&#13;
    c = _a + _b;&#13;
    assert(c &gt;= _a);&#13;
    return c;&#13;
  }&#13;
}&#13;
&#13;
&#13;
contract LandRegistryProxyInterface {&#13;
  function owner() public view returns (address);&#13;
}&#13;
&#13;
&#13;
contract TokenizedPropertyInterface {&#13;
  function balanceOf(address _who) public view returns (uint256);&#13;
  function emitGenericProposal(string _generic) public;&#13;
  function lastTransferBlock(address _account) public view returns (uint256);&#13;
  function registryProxy() public view returns (LandRegistryProxyInterface);&#13;
  function setManagementCompany(string _managementCompany) public;&#13;
  function totalSupply() public view returns (uint256);&#13;
  function transferOwnership(address _newOwner) public;&#13;
  function untokenize() public;&#13;
}&#13;
&#13;
&#13;
/**&#13;
 * @title ShareholderDAO&#13;
 * @dev A simple DAO attached to a `TokenizedProperty` (ownership of the property is transferred to `this`).&#13;
 *&#13;
 * The token holders of a property `extend` and `vote` on `Proposal`s which are either executed (over 50% consensus) or rejected.&#13;
 * Proposals are `Executed` or `Rejected` at or after their `closingTime`, when a token holder or blockimmo calls `finalize` on the proposal.&#13;
 * Generic information related to a proposal can be included in the `_generic` string (ie the configuration details of an outright sale's `TokenSale`).&#13;
 * `Generic` proposals can also be extended. A property's management company and / or blockimmo will try to take these as suggestions.&#13;
 *&#13;
 * There are only a few decisions that token holders (investors in a property) can (and need) to make.&#13;
 * No need to be general. We keep it simple and minimal here, enabling our users to accomplish the necessary tasks.&#13;
 * - nothing more, nothing less.&#13;
 *&#13;
 * Just like in the real world, for commercial investment properties a `managementCompany` makes all decisions / actions involving a property.&#13;
 * Investors only need to `SetManagementCompany` - a suggestion blockimmo will always take (if possible).&#13;
 *&#13;
 * Aside from that, the only decisions investors need to make are:&#13;
 *&#13;
 * `TransferOwnership` enables `this` to be easily and reliably upgraded if consensus is reached on this proposal (ie a different form of DAO or a BDFL).&#13;
 *&#13;
 * Upgrading:&#13;
 *   1. A token holder deploys a new `ShareholderDAO`&#13;
 *   2. The token holder extends a proposal to `transferOwnership` of `TokenizedProperty` to the new DAO (1).&#13;
 *&#13;
 * See `TokenizedProperty`'s documentation for info on `Untokenize` and how / why this is used.&#13;
 */&#13;
contract ShareholderDAO {&#13;
  using SafeMath for uint256;&#13;
&#13;
  enum Actions { SetManagementCompany, TransferOwnership, Untokenize, Generic }&#13;
  enum Outcomes { Pend, Accept, Reject }&#13;
  enum ProposalStatus { Null, Executed, Open, Rejected }&#13;
  enum VoteStatus { Null, For, Against}&#13;
&#13;
  struct Vote {&#13;
    VoteStatus status;&#13;
    uint256 clout;&#13;
  }&#13;
&#13;
  struct Proposal {&#13;
    Actions action;&#13;
    uint256 closingTime;&#13;
&#13;
    string managementCompany;&#13;
    address owner;&#13;
    string generic;&#13;
&#13;
    address proposer;&#13;
&#13;
    ProposalStatus status;&#13;
    uint256 tallyFor;&#13;
    uint256 tallyAgainst;&#13;
    uint256 blockNumber;&#13;
&#13;
    mapping (address =&gt; Vote) voters;&#13;
  }&#13;
&#13;
  mapping(bytes32 =&gt; Proposal) private proposals;&#13;
  TokenizedPropertyInterface public property;&#13;
&#13;
  event ProposalRejected(bytes32 indexed proposal);&#13;
  event ProposalExecuted(bytes32 indexed proposal);&#13;
  event ProposalExtended(bytes32 indexed proposal, Actions indexed action, uint256 closingTime, string managementCompany, address owner, string generic, address indexed proposer);&#13;
&#13;
  event Voted(bytes32 indexed proposal, address indexed voter, uint256 clout);&#13;
  event VoteRescinded(bytes32 indexed proposal, address indexed voter, uint256 clout);&#13;
&#13;
  constructor(TokenizedPropertyInterface _property) public {&#13;
    property = _property;&#13;
  }&#13;
&#13;
  modifier isAuthorized {&#13;
    require(getClout(msg.sender) &gt; 0 || msg.sender == property.registryProxy().owner(), "must be blockimmo or tokenholder to perform this action");  // allow blockimmo to extend proposals for all properties&#13;
    _;&#13;
  }&#13;
&#13;
  function extendProposal(Actions _action, uint256 _closingTime, string _managementCompany, address _owner, string _description) public isAuthorized {&#13;
    require(block.timestamp &lt; _closingTime, "_closingTime must be in the future");&#13;
&#13;
    bytes32 hash = keccak256(abi.encodePacked(_action, _closingTime, _managementCompany, _description, _owner));&#13;
    require(proposals[hash].status == ProposalStatus.Null, "proposal is not unique");&#13;
&#13;
    proposals[hash] = Proposal(_action, _closingTime, _managementCompany, _owner, _description, msg.sender, ProposalStatus.Open, 0, 0, block.number);&#13;
    emit ProposalExtended(hash, _action, _closingTime, _managementCompany, _owner, _description, msg.sender);&#13;
  }&#13;
&#13;
  function vote(bytes32 _hash, bool _isFor) public isAuthorized {&#13;
    Proposal storage p = proposals[_hash];&#13;
    Vote storage v = p.voters[msg.sender];&#13;
&#13;
    require(p.status == ProposalStatus.Open, "vote requires proposal is open");&#13;
    require(block.timestamp &lt; p.closingTime, "vote requires proposal voting period is open");&#13;
    require(p.voters[msg.sender].status == VoteStatus.Null, "voter has voted");&#13;
    require(p.blockNumber &gt; property.lastTransferBlock(msg.sender), "voter ineligible due to transfer in voting period");&#13;
&#13;
    uint256 clout = getClout(msg.sender);&#13;
    v.clout = clout;&#13;
    if (_isFor) {&#13;
      v.status = VoteStatus.For;&#13;
      p.tallyFor = p.tallyFor.add(clout);&#13;
    } else {&#13;
      v.status = VoteStatus.Against;&#13;
      p.tallyAgainst = p.tallyAgainst.add(clout);&#13;
    }&#13;
&#13;
    emit Voted(_hash, msg.sender, clout);&#13;
  }&#13;
&#13;
  function rescindVote(bytes32 _hash) public isAuthorized {&#13;
    Proposal storage p = proposals[_hash];&#13;
    Vote storage v = p.voters[msg.sender];&#13;
&#13;
    require(p.status == ProposalStatus.Open, "rescindVote requires proposal is open");&#13;
    require(block.timestamp &lt; p.closingTime, "rescindVote requires proposal voting period is open");&#13;
    require(v.status != VoteStatus.Null, "voter has not voted");&#13;
&#13;
    uint256 clout = v.clout;&#13;
    if (v.status == VoteStatus.For) {&#13;
      p.tallyFor = p.tallyFor.sub(clout);&#13;
    } else if (v.status == VoteStatus.Against) {&#13;
      p.tallyAgainst = p.tallyAgainst.sub(clout);&#13;
    }&#13;
&#13;
    v.status = VoteStatus.Null;&#13;
    v.clout = 0;&#13;
&#13;
    emit VoteRescinded(_hash, msg.sender, clout);&#13;
  }&#13;
&#13;
  function finalize(bytes32 _hash) public isAuthorized {&#13;
    Proposal storage p = proposals[_hash];&#13;
&#13;
    require(p.status == ProposalStatus.Open, "finalize requires proposal is open");&#13;
    require(block.timestamp &gt;= p.closingTime, "finalize requires proposal voting period is closed");&#13;
&#13;
    Outcomes outcome = tallyVotes(p.tallyFor);&#13;
    if (outcome == Outcomes.Accept) {&#13;
      executeProposal(_hash);&#13;
    } else if (outcome == Outcomes.Reject) {&#13;
      p.status = ProposalStatus.Rejected;&#13;
      emit ProposalRejected(_hash);&#13;
    }&#13;
  }&#13;
&#13;
  function getClout(address _who) internal view returns (uint256 clout) {&#13;
    clout = property.balanceOf(_who);&#13;
  }&#13;
&#13;
  function tallyVotes(uint256 _tallyFor) internal view returns (Outcomes outcome) {&#13;
    if (_tallyFor &gt; property.totalSupply() / 2) {&#13;
      outcome = Outcomes.Accept;&#13;
    } else {&#13;
      outcome = Outcomes.Reject;&#13;
    }&#13;
  }&#13;
&#13;
  function executeProposal(bytes32 _hash) internal {&#13;
    Proposal storage p = proposals[_hash];&#13;
&#13;
    if (p.action == Actions.SetManagementCompany) {&#13;
      property.setManagementCompany(p.managementCompany);&#13;
    } else if (p.action == Actions.TransferOwnership) {&#13;
      property.transferOwnership(p.owner);&#13;
    } else if (p.action == Actions.Untokenize) {&#13;
      property.untokenize();&#13;
    } else if (p.action == Actions.Generic) {&#13;
      property.emitGenericProposal(p.generic);&#13;
    }&#13;
&#13;
    p.status = ProposalStatus.Executed;&#13;
    emit ProposalExecuted(_hash);&#13;
  }&#13;
}