/* 
MicroDAO V0.0.2 - <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="d0bdb590a4b8bfa2a3a4b5befdaabfb5a2beb5a2feb3bfbd">[emailÂ protected]</a>&gt;&#13;
===========================================================&#13;
Simplified DAO allowing to do initial funding.&#13;
- Funders are able to specify how long to keep funds in.&#13;
- If funding is not closed by this time fundes returned&#13;
- Close funding is a manual taken by the director&#13;
&#13;
Single Director&#13;
- Has the possibility to file SpendingRequest&#13;
- allowed to change fundamental parameters&#13;
- allowed to move directorship forward&#13;
- deadman switch prevents lost DAO.&#13;
&#13;
Each Spending needs to be approved by share holders (Vote)&#13;
- spendings have a time to vote&#13;
- spendings require to be executed in a given number of days&#13;
&#13;
- Checked for recursive withdraw bug (DAO Hack) &#13;
*/&#13;
&#13;
contract SpendingRequest {&#13;
	string public name="SpendingRequest 4 MicroDAO";&#13;
	 address public creator;&#13;
	 string public description;&#13;
	 uint256 public request_until;&#13;
	 uint256 public vote_until;&#13;
		&#13;
	 option[] public  options;&#13;
 	 address public dao;&#13;
	 mapping(address=&gt;bool) public voted;&#13;
	 bool public voting_started;&#13;
	 bool public executed;&#13;
	 address public result_payto;&#13;
	 uint256 public result_amount;&#13;
	 uint256 public result_votes;&#13;
	&#13;
	struct option {&#13;
		string description;&#13;
		address payout_to;&#13;
		uint256 eth_amount;		&#13;
		uint256 votes_pro;&#13;
		uint256 votes_veto;&#13;
	}&#13;
	&#13;
	function SpendingRequest () {&#13;
		creator=msg.sender;&#13;
	}&#13;
	&#13;
	function setDescription(string _description) {&#13;
		if(voting_started) throw;&#13;
		description=_description;		&#13;
	}&#13;
	&#13;
	function setDAO(address _dao) {&#13;
		if(msg.sender!=creator) throw;&#13;
		if(voting_started) throw;&#13;
 		if(dao!=0) throw;&#13;
		MicroDAO d = MicroDAO(_dao);&#13;
		if(d.balanceOf(creator)&lt;1) throw;&#13;
		dao=_dao;		&#13;
	}&#13;
	&#13;
	function execute(){&#13;
		if(vote_until&gt;now) return;&#13;
		if(request_until&lt;now) return;&#13;
		if((msg.sender!=dao)&amp;&amp;(msg.sender!=creator)) throw;&#13;
		for(var i=0;i&lt;options.length;i++) {&#13;
			if(options[i].votes_pro-options[i].votes_veto&gt;result_votes) {&#13;
				result_payto=options[i].payout_to;&#13;
				result_amount=options[i].eth_amount;&#13;
				if(options[i].votes_veto&gt;options[i].votes_pro) result_votes=0; else &#13;
				result_votes=options[i].votes_pro-options[i].votes_veto;&#13;
			}&#13;
		}&#13;
		executed=true;		&#13;
	}&#13;
	&#13;
	function vote(uint256 option,bool veto) {		&#13;
		if(voted[msg.sender]) throw;&#13;
		if(now&lt;vote_until) throw;&#13;
		voting_started=true;&#13;
		MicroDAO d = MicroDAO(dao);&#13;
		if(!veto) options[option].votes_pro+=d.balanceOf(msg.sender);	else options[option].votes_veto+=d.balanceOf(msg.sender);&#13;
		&#13;
		d.blockTransfer(msg.sender,vote_until);&#13;
	}&#13;
	function setRequestUntil(uint8 days_from_now) {&#13;
		if(msg.sender!=creator) throw;&#13;
		if(voting_started) throw;&#13;
		request_until=now+(86400*days_from_now);		&#13;
	}&#13;
	function setVotetUntil(uint8 days_from_now) {&#13;
		if(msg.sender!=creator) throw;&#13;
		if(voting_started) throw;&#13;
		vote_until=now+(86400*days_from_now);		&#13;
	}&#13;
	function addOption(string _description,address _payout_to,uint256 _amount) {&#13;
		if(msg.sender!=creator) throw;&#13;
		if(voting_started) throw;&#13;
		options.push(option(_description,_payout_to,_amount,0,0));&#13;
	}	&#13;
}&#13;
contract MicroDAO&#13;
{&#13;
	string public directorNode;&#13;
	address public director;&#13;
	string public directorName;&#13;
	string public directorJurisdication;&#13;
	bool public initialFunding;	&#13;
	uint256 public sharesRaised;&#13;
	uint public lockInDays;	&#13;
	string public name ="MicroDAO";&#13;
	string public symbol ="E/";&#13;
	uint256 public fundingGoal;&#13;
	uint256 public balanceFinney;&#13;
	uint256 public directorLockUntil;&#13;
	uint256 public directorLockDays;&#13;
	uint256 public directorTransferShareRequired;&#13;
	mapping (address =&gt; uint256) public balanceOf;		&#13;
	mapping (address =&gt; uint256) public fundsExpire;&#13;
	mapping (address =&gt; uint256) public blockedtransfer;&#13;
	&#13;
	&#13;
	address[] public funders;&#13;
	SpendingRequest[]  public allowances;&#13;
	struct booking {&#13;
		uint256 time;&#13;
		uint256 funding;&#13;
		uint256 spending;&#13;
		address counterpart;&#13;
		string text;&#13;
	}&#13;
	booking[] public bookings;&#13;
	&#13;
	event Transfer(address indexed from, address indexed to, uint256 value);&#13;
	&#13;
	function MicroDAO() {&#13;
		initialFunding=true;&#13;
		director=msg.sender;	&#13;
		directorLockUntil=now+(86400*30);		&#13;
	}&#13;
	function setDirectorNode(string node) {&#13;
		if(msg.sender!=director) throw;&#13;
		directorNode=node;&#13;
		directorLockUntil=now+(86400*directorLockDays);&#13;
	} &#13;
	&#13;
	function blockTransfer(address a,uint256 until) {&#13;
		bool found=false;&#13;
		for(var i=0;((i&lt;allowances.length)&amp;&amp;(found==false));i++) {&#13;
			if(allowances[i]==msg.sender) found=true;&#13;
		}&#13;
		if(found) {&#13;
			if(blockedtransfer[a]&gt;until) {&#13;
				blockedtransfer[a]=until;&#13;
			}&#13;
		}&#13;
	}&#13;
	&#13;
	function setDirectorLock(uint256 number_of_days,uint256 requiredShares) {&#13;
		if(msg.sender!=director) throw; &#13;
		if(requiredShares&gt;sharesRaised) throw;&#13;
		if(number_of_days&gt;365) number_of_days=365;&#13;
		&#13;
		&#13;
		directorLockDays=number_of_days;&#13;
		directorTransferShareRequired=requiredShares;&#13;
	}&#13;
	&#13;
	function transferDirector(address director) {&#13;
		// Dead Director check ...		&#13;
		if(msg.sender==director) {&#13;
			director=director;&#13;
			directorName="";&#13;
			directorJurisdication="";&#13;
			initialFunding=true;&#13;
		} else if((now&gt;directorLockUntil)&amp;&amp;(balanceOf[msg.sender]&gt;directorTransferShareRequired)) {&#13;
			director=msg.sender;&#13;
			directorName="";&#13;
			directorJurisdication="";&#13;
			initialFunding=true;&#13;
		}&#13;
	}&#13;
	function setdirectorName(string name) {&#13;
		if(msg.sender!=director) throw;&#13;
		if(!initialFunding) throw;&#13;
		directorName=name;&#13;
	}&#13;
	&#13;
	function setFundingGoal(uint256 goal) {&#13;
		if(msg.sender!=director) throw;&#13;
		fundingGoal=goal;&#13;
	}&#13;
	&#13;
	function setInitialLockinDays(uint number_of_days) {&#13;
		if(msg.sender!=director) throw;&#13;
		lockInDays=number_of_days;&#13;
	}&#13;
	&#13;
	&#13;
	function setJurisdication(string juri) {&#13;
		if(msg.sender!=director) throw;&#13;
		if(!initialFunding) throw;&#13;
		directorJurisdication=juri;&#13;
	}&#13;
	&#13;
	function addSpendingRequest(address spendingRequest) {&#13;
		if(msg.sender!=director) throw;	&#13;
		SpendingRequest s = SpendingRequest(spendingRequest);		&#13;
		if(s.executed()) throw;&#13;
		if(s.vote_until()&lt;now) throw; &#13;
		allowances.push(s);		&#13;
	}&#13;
	&#13;
	function executeSpendingRequests() {&#13;
		for(var i=0;i&lt;allowances.length;i++) {&#13;
			SpendingRequest s =SpendingRequest(allowances[i]);&#13;
			if(!s.executed()) {&#13;
				if((s.vote_until()&lt;now)&amp;&amp;(s.request_until()&gt;now)) {&#13;
					s.execute();&#13;
					directorLockUntil=now+(86400*directorLockDays);&#13;
					if(s.result_amount()&gt;0) {&#13;
						if(s.result_payto()!=0) {&#13;
							s.result_payto().send(s.result_amount()*1 ether);&#13;
							bookings.push(booking(now,0,s.result_amount()*1 ether,s.result_payto(),"Executed SpendingRequest"));&#13;
						}&#13;
					}&#13;
				}&#13;
			}&#13;
		}&#13;
	}&#13;
	&#13;
	function myFundsExpireIn(uint256 number_of_days) {&#13;
		var exp=now+(86400*number_of_days);&#13;
		if(exp&gt;fundsExpire[msg.sender]) fundsExpire[msg.sender]=exp; else throw;&#13;
	}&#13;
		&#13;
	function closeFunding() {&#13;
		if(msg.sender!=director) throw;&#13;
		initialFunding=false;		&#13;
		checkExpiredfunds();		&#13;
	}&#13;
	&#13;
	function checkExpiredfunds() {&#13;
		if(!initialFunding) return;&#13;
		for(var i=0;i&lt;funders.length;i++) {&#13;
			if((fundsExpire[funders[i]]&gt;0)&amp;&amp;((fundsExpire[funders[i]]&lt;now))) {&#13;
				var amount=balanceOf[funders[i]]*1 finney;				&#13;
				Transfer(funders[i],this,balanceOf[funders[i]]);&#13;
				sharesRaised-=balanceOf[funders[i]];&#13;
				balanceOf[funders[i]]=0;&#13;
				funders[i].send(amount);				&#13;
			}&#13;
		}&#13;
	}&#13;
	&#13;
	function transfer(address _to, uint256 _value) {&#13;
		if(blockedtransfer[msg.sender]&gt;now) throw;&#13;
		if (balanceOf[msg.sender] &lt; _value) throw;           // Check if the sender has enough&#13;
        if (balanceOf[_to] + _value &lt; balanceOf[_to]) throw; // Check for overflows&#13;
        balanceOf[msg.sender] -= _value;                     // Subtract from the sender&#13;
        balanceOf[_to] += _value;                            // Add the same to the recipient&#13;
		if(balanceOf[_to]==0) {&#13;
			funders.push(_to);&#13;
		}&#13;
        Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place&#13;
    }&#13;
	&#13;
	function() {	&#13;
		 var funding_type="Incomming";			&#13;
			var finneys=msg.value/1 finney;&#13;
			if(initialFunding) {&#13;
				&#13;
				if(balanceOf[msg.sender]==0) {&#13;
					funders.push(msg.sender);&#13;
				}		&#13;
				if(msg.value&lt;100 finney) throw;&#13;
				&#13;
				fundsExpire[msg.sender]=now+(lockInDays*86400);&#13;
				balanceOf[msg.sender]+=finneys;&#13;
				Transfer(this,msg.sender,finneys);&#13;
				sharesRaised+=finneys;&#13;
				funding_type="Initial Funding";&#13;
			}&#13;
			bookings.push(booking(now,msg.value,0,msg.sender,funding_type));&#13;
			balanceFinney=this.balance/1 finney;&#13;
	}&#13;
}