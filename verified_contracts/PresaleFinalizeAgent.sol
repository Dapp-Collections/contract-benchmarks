pragma solidity ^0.4.15;

/**
 * @title Ownable
 * @dev The Ownable contract has an owner address, and provides basic authorization control
 * functions, this simplifies the implementation of "user permissions".
 */
contract Ownable {
  address public owner;


  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);


  /**
   * @dev The Ownable constructor sets the original `owner` of the contract to the sender
   * account.
   */
  function Ownable() {
    owner = msg.sender;
  }


  /**
   * @dev Throws if called by any account other than the owner.
   */
  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }


  /**
   * @dev Allows the current owner to transfer control of the contract to a newOwner.
   * @param newOwner The address to transfer ownership to.
   */
  function transferOwnership(address newOwner) onlyOwner public {
    require(newOwner != address(0));
    OwnershipTransferred(owner, newOwner);
    owner = newOwner;
  }

}

/**
 * @title Contracts that should not own Ether
 * @author Remco Bloemen <<span class="__cf_email__" data-cfemail="2c5e49414f436c1e">[email protected]</span>π.com&gt;&#13;
 * @dev This tries to block incoming ether to prevent accidental loss of Ether. Should Ether end up&#13;
 * in the contract, it will allow the owner to reclaim this ether.&#13;
 * @notice Ether can still be send to this contract by:&#13;
 * calling functions labeled `payable`&#13;
 * `selfdestruct(contract_address)`&#13;
 * mining directly to the contract address&#13;
*/&#13;
contract HasNoEther is Ownable {&#13;
&#13;
  /**&#13;
  * @dev Constructor that rejects incoming Ether&#13;
  * @dev The `payable` flag is added so we can access `msg.value` without compiler warning. If we&#13;
  * leave out payable, then Solidity will allow inheriting contracts to implement a payable&#13;
  * constructor. By doing it this way we prevent a payable constructor from working. Alternatively&#13;
  * we could use assembly to access msg.value.&#13;
  */&#13;
  function HasNoEther() payable {&#13;
    require(msg.value == 0);&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Disallows direct send by settings a default function without the `payable` flag.&#13;
   */&#13;
  function() external {&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Transfer all Ether held by the contract to the owner.&#13;
   */&#13;
  function reclaimEther() external onlyOwner {&#13;
    assert(owner.send(this.balance));&#13;
  }&#13;
}&#13;
&#13;
/**&#13;
 * @title SafeMath&#13;
 * @dev Math operations with safety checks that throw on error&#13;
 */&#13;
library SafeMath {&#13;
  function mul(uint256 a, uint256 b) internal constant returns (uint256) {&#13;
    uint256 c = a * b;&#13;
    assert(a == 0 || c / a == b);&#13;
    return c;&#13;
  }&#13;
&#13;
  function div(uint256 a, uint256 b) internal constant returns (uint256) {&#13;
    // assert(b &gt; 0); // Solidity automatically throws when dividing by 0&#13;
    uint256 c = a / b;&#13;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold&#13;
    return c;&#13;
  }&#13;
&#13;
  function sub(uint256 a, uint256 b) internal constant returns (uint256) {&#13;
    assert(b &lt;= a);&#13;
    return a - b;&#13;
  }&#13;
&#13;
  function add(uint256 a, uint256 b) internal constant returns (uint256) {&#13;
    uint256 c = a + b;&#13;
    assert(c &gt;= a);&#13;
    return c;&#13;
  }&#13;
}&#13;
&#13;
/**&#13;
 * @title Pausable&#13;
 * @dev Base contract which allows children to implement an emergency stop mechanism.&#13;
 */&#13;
contract Pausable is Ownable {&#13;
  event Pause();&#13;
  event Unpause();&#13;
&#13;
  bool public paused = false;&#13;
&#13;
&#13;
  /**&#13;
   * @dev Modifier to make a function callable only when the contract is not paused.&#13;
   */&#13;
  modifier whenNotPaused() {&#13;
    require(!paused);&#13;
    _;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Modifier to make a function callable only when the contract is paused.&#13;
   */&#13;
  modifier whenPaused() {&#13;
    require(paused);&#13;
    _;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev called by the owner to pause, triggers stopped state&#13;
   */&#13;
  function pause() onlyOwner whenNotPaused public {&#13;
    paused = true;&#13;
    Pause();&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev called by the owner to unpause, returns to normal state&#13;
   */&#13;
  function unpause() onlyOwner whenPaused public {&#13;
    paused = false;&#13;
    Unpause();&#13;
  }&#13;
}&#13;
&#13;
contract RNTMultiSigWallet {&#13;
    /*&#13;
     *  Events&#13;
     */&#13;
    event Confirmation(address indexed sender, uint indexed transactionId);&#13;
&#13;
    event Revocation(address indexed sender, uint indexed transactionId);&#13;
&#13;
    event Submission(uint indexed transactionId);&#13;
&#13;
    event Execution(uint indexed transactionId);&#13;
&#13;
    event ExecutionFailure(uint indexed transactionId);&#13;
&#13;
    event Deposit(address indexed sender, uint value);&#13;
&#13;
    event OwnerAddition(address indexed owner);&#13;
&#13;
    event OwnerRemoval(address indexed owner);&#13;
&#13;
    event RequirementChange(uint required);&#13;
&#13;
    event Pause();&#13;
&#13;
    event Unpause();&#13;
&#13;
    /*&#13;
     *  Constants&#13;
     */&#13;
    uint constant public MAX_OWNER_COUNT = 10;&#13;
&#13;
    uint constant public ADMINS_COUNT = 2;&#13;
&#13;
    /*&#13;
     *  Storage&#13;
     */&#13;
    mapping (uint =&gt; WalletTransaction) public transactions;&#13;
&#13;
    mapping (uint =&gt; mapping (address =&gt; bool)) public confirmations;&#13;
&#13;
    mapping (address =&gt; bool) public isOwner;&#13;
&#13;
    mapping (address =&gt; bool) public isAdmin;&#13;
&#13;
    address[] public owners;&#13;
&#13;
    address[] public admins;&#13;
&#13;
    uint public required;&#13;
&#13;
    uint public transactionCount;&#13;
&#13;
    bool public paused = false;&#13;
&#13;
    struct WalletTransaction {&#13;
    address sender;&#13;
    address destination;&#13;
    uint value;&#13;
    bytes data;&#13;
    bool executed;&#13;
    }&#13;
&#13;
    /*&#13;
     *  Modifiers&#13;
     */&#13;
&#13;
    /// @dev Modifier to make a function callable only when the contract is not paused.&#13;
    modifier whenNotPaused() {&#13;
        require(!paused);&#13;
        _;&#13;
    }&#13;
&#13;
    /// @dev Modifier to make a function callable only when the contract is paused.&#13;
    modifier whenPaused() {&#13;
        require(paused);&#13;
        _;&#13;
    }&#13;
&#13;
    modifier onlyWallet() {&#13;
        require(msg.sender == address(this));&#13;
        _;&#13;
    }&#13;
&#13;
    modifier ownerDoesNotExist(address owner) {&#13;
        require(!isOwner[owner]);&#13;
        _;&#13;
    }&#13;
&#13;
    modifier ownerExists(address owner) {&#13;
        require(isOwner[owner]);&#13;
        _;&#13;
    }&#13;
&#13;
    modifier adminExists(address admin) {&#13;
        require(isAdmin[admin]);&#13;
        _;&#13;
    }&#13;
&#13;
    modifier adminDoesNotExist(address admin) {&#13;
        require(!isAdmin[admin]);&#13;
        _;&#13;
    }&#13;
&#13;
    modifier transactionExists(uint transactionId) {&#13;
        require(transactions[transactionId].destination != 0);&#13;
        _;&#13;
    }&#13;
&#13;
    modifier confirmed(uint transactionId, address owner) {&#13;
        require(confirmations[transactionId][owner]);&#13;
        _;&#13;
    }&#13;
&#13;
    modifier notConfirmed(uint transactionId, address owner) {&#13;
        require(!confirmations[transactionId][owner]);&#13;
        _;&#13;
    }&#13;
&#13;
    modifier notExecuted(uint transactionId) {&#13;
        if (transactions[transactionId].executed)&#13;
        require(false);&#13;
        _;&#13;
    }&#13;
&#13;
    modifier notNull(address _address) {&#13;
        require(_address != 0);&#13;
        _;&#13;
    }&#13;
&#13;
    modifier validRequirement(uint ownerCount, uint _required) {&#13;
        if (ownerCount &gt; MAX_OWNER_COUNT&#13;
        || _required &gt; ownerCount&#13;
        || _required == 0&#13;
        || ownerCount == 0) {&#13;
            require(false);&#13;
        }&#13;
        _;&#13;
    }&#13;
&#13;
    modifier validAdminsCount(uint adminsCount) {&#13;
        require(adminsCount == ADMINS_COUNT);&#13;
        _;&#13;
    }&#13;
&#13;
    /// @dev Fallback function allows to deposit ether.&#13;
    function()&#13;
    whenNotPaused&#13;
    payable&#13;
    {&#13;
        if (msg.value &gt; 0)&#13;
        Deposit(msg.sender, msg.value);&#13;
    }&#13;
&#13;
    /*&#13;
     * Public functions&#13;
     */&#13;
    /// @dev Contract constructor sets initial admins and required number of confirmations.&#13;
    /// @param _admins List of initial owners.&#13;
    /// @param _required Number of required confirmations.&#13;
    function RNTMultiSigWallet(address[] _admins, uint _required)&#13;
    public&#13;
        //    validAdminsCount(_admins.length)&#13;
        //    validRequirement(_admins.length, _required)&#13;
    {&#13;
        for (uint i = 0; i &lt; _admins.length; i++) {&#13;
            require(_admins[i] != 0 &amp;&amp; !isOwner[_admins[i]] &amp;&amp; !isAdmin[_admins[i]]);&#13;
            isAdmin[_admins[i]] = true;&#13;
            isOwner[_admins[i]] = true;&#13;
        }&#13;
&#13;
        admins = _admins;&#13;
        owners = _admins;&#13;
        required = _required;&#13;
    }&#13;
&#13;
    /// @dev called by the owner to pause, triggers stopped state&#13;
    function pause() adminExists(msg.sender) whenNotPaused public {&#13;
        paused = true;&#13;
        Pause();&#13;
    }&#13;
&#13;
    /// @dev called by the owner to unpause, returns to normal state&#13;
    function unpause() adminExists(msg.sender) whenPaused public {&#13;
        paused = false;&#13;
        Unpause();&#13;
    }&#13;
&#13;
    /// @dev Allows to add a new owner. Transaction has to be sent by wallet.&#13;
    /// @param owner Address of new owner.&#13;
    function addOwner(address owner)&#13;
    public&#13;
    whenNotPaused&#13;
    adminExists(msg.sender)&#13;
    ownerDoesNotExist(owner)&#13;
    notNull(owner)&#13;
    validRequirement(owners.length + 1, required)&#13;
    {&#13;
        isOwner[owner] = true;&#13;
        owners.push(owner);&#13;
        OwnerAddition(owner);&#13;
    }&#13;
&#13;
    /// @dev Allows to remove an owner. Transaction has to be sent by wallet.&#13;
    /// @param owner Address of owner.&#13;
    function removeOwner(address owner)&#13;
    public&#13;
    whenNotPaused&#13;
    adminExists(msg.sender)&#13;
    adminDoesNotExist(owner)&#13;
    ownerExists(owner)&#13;
    {&#13;
        isOwner[owner] = false;&#13;
        for (uint i = 0; i &lt; owners.length - 1; i++)&#13;
        if (owners[i] == owner) {&#13;
            owners[i] = owners[owners.length - 1];&#13;
            break;&#13;
        }&#13;
        owners.length -= 1;&#13;
        if (required &gt; owners.length)&#13;
        changeRequirement(owners.length);&#13;
        OwnerRemoval(owner);&#13;
    }&#13;
&#13;
    /// @dev Allows to replace an owner with a new owner. Transaction has to be sent by wallet.&#13;
    /// @param owner Address of owner to be replaced.&#13;
    /// @param newOwner Address of new owner.&#13;
    function replaceOwner(address owner, address newOwner)&#13;
    public&#13;
    whenNotPaused&#13;
    adminExists(msg.sender)&#13;
    adminDoesNotExist(owner)&#13;
    ownerExists(owner)&#13;
    ownerDoesNotExist(newOwner)&#13;
    {&#13;
        for (uint i = 0; i &lt; owners.length; i++)&#13;
        if (owners[i] == owner) {&#13;
            owners[i] = newOwner;&#13;
            break;&#13;
        }&#13;
        isOwner[owner] = false;&#13;
        isOwner[newOwner] = true;&#13;
        OwnerRemoval(owner);&#13;
        OwnerAddition(newOwner);&#13;
    }&#13;
&#13;
    /// @dev Allows to change the number of required confirmations. Transaction has to be sent by wallet.&#13;
    /// @param _required Number of required confirmations.&#13;
    function changeRequirement(uint _required)&#13;
    public&#13;
    whenNotPaused&#13;
    adminExists(msg.sender)&#13;
    validRequirement(owners.length, _required)&#13;
    {&#13;
        required = _required;&#13;
        RequirementChange(_required);&#13;
    }&#13;
&#13;
    /// @dev Allows an owner to submit and confirm a transaction.&#13;
    /// @param destination Transaction target address.&#13;
    /// @param value Transaction ether value.&#13;
    /// @param data Transaction data payload.&#13;
    /// @return Returns transaction ID.&#13;
    function submitTransaction(address destination, uint value, bytes data)&#13;
    public&#13;
    whenNotPaused&#13;
    ownerExists(msg.sender)&#13;
    returns (uint transactionId)&#13;
    {&#13;
        transactionId = addTransaction(destination, value, data);&#13;
        confirmTransaction(transactionId);&#13;
    }&#13;
&#13;
    /// @dev Allows an owner to confirm a transaction.&#13;
    /// @param transactionId Transaction ID.&#13;
    function confirmTransaction(uint transactionId)&#13;
    public&#13;
    whenNotPaused&#13;
    ownerExists(msg.sender)&#13;
    transactionExists(transactionId)&#13;
    notConfirmed(transactionId, msg.sender)&#13;
    {&#13;
        confirmations[transactionId][msg.sender] = true;&#13;
        Confirmation(msg.sender, transactionId);&#13;
        executeTransaction(transactionId);&#13;
    }&#13;
&#13;
    /// @dev Allows an owner to revoke a confirmation for a transaction.&#13;
    /// @param transactionId Transaction ID.&#13;
    function revokeConfirmation(uint transactionId)&#13;
    public&#13;
    whenNotPaused&#13;
    ownerExists(msg.sender)&#13;
    confirmed(transactionId, msg.sender)&#13;
    notExecuted(transactionId)&#13;
    {&#13;
        confirmations[transactionId][msg.sender] = false;&#13;
        Revocation(msg.sender, transactionId);&#13;
    }&#13;
&#13;
    /// @dev Allows anyone to execute a confirmed transaction.&#13;
    /// @param transactionId Transaction ID.&#13;
    function executeTransaction(uint transactionId)&#13;
    public&#13;
    whenNotPaused&#13;
    ownerExists(msg.sender)&#13;
    confirmed(transactionId, msg.sender)&#13;
    notExecuted(transactionId)&#13;
    {&#13;
        if (isConfirmed(transactionId)) {&#13;
            WalletTransaction storage walletTransaction = transactions[transactionId];&#13;
            walletTransaction.executed = true;&#13;
            if (walletTransaction.destination.call.value(walletTransaction.value)(walletTransaction.data))&#13;
            Execution(transactionId);&#13;
            else {&#13;
                ExecutionFailure(transactionId);&#13;
                walletTransaction.executed = false;&#13;
            }&#13;
        }&#13;
    }&#13;
&#13;
    /// @dev Returns the confirmation status of a transaction.&#13;
    /// @param transactionId Transaction ID.&#13;
    /// @return Confirmation status.&#13;
    function isConfirmed(uint transactionId)&#13;
    public&#13;
    constant&#13;
    returns (bool)&#13;
    {&#13;
        uint count = 0;&#13;
        for (uint i = 0; i &lt; owners.length; i++) {&#13;
            if (confirmations[transactionId][owners[i]])&#13;
            count += 1;&#13;
            if (count == required)&#13;
            return true;&#13;
        }&#13;
    }&#13;
&#13;
    /*&#13;
     * Internal functions&#13;
     */&#13;
    /// @dev Adds a new transaction to the transaction mapping, if transaction does not exist yet.&#13;
    /// @param destination Transaction target address.&#13;
    /// @param value Transaction ether value.&#13;
    /// @param data Transaction data payload.&#13;
    /// @return Returns transaction ID.&#13;
    function addTransaction(address destination, uint value, bytes data)&#13;
    internal&#13;
    notNull(destination)&#13;
    returns (uint transactionId)&#13;
    {&#13;
        transactionId = transactionCount;&#13;
        transactions[transactionId] = WalletTransaction({&#13;
        sender : msg.sender,&#13;
        destination : destination,&#13;
        value : value,&#13;
        data : data,&#13;
        executed : false&#13;
        });&#13;
        transactionCount += 1;&#13;
        Submission(transactionId);&#13;
    }&#13;
&#13;
    /*&#13;
     * Web3 call functions&#13;
     */&#13;
    /// @dev Returns number of confirmations of a transaction.&#13;
    /// @param transactionId Transaction ID.&#13;
    /// @return Number of confirmations.&#13;
    function getConfirmationCount(uint transactionId)&#13;
    public&#13;
    constant&#13;
    returns (uint count)&#13;
    {&#13;
        for (uint i = 0; i &lt; owners.length; i++)&#13;
        if (confirmations[transactionId][owners[i]])&#13;
        count += 1;&#13;
    }&#13;
&#13;
    /// @dev Returns total number of transactions after filers are applied.&#13;
    /// @param pending Include pending transactions.&#13;
    /// @param executed Include executed transactions.&#13;
    /// @return Total number of transactions after filters are applied.&#13;
    function getTransactionCount(bool pending, bool executed)&#13;
    public&#13;
    constant&#13;
    returns (uint count)&#13;
    {&#13;
        for (uint i = 0; i &lt; transactionCount; i++)&#13;
        if (pending &amp;&amp; !transactions[i].executed&#13;
        || executed &amp;&amp; transactions[i].executed)&#13;
        count += 1;&#13;
    }&#13;
&#13;
    /// @dev Returns list of owners.&#13;
    /// @return List of owner addresses.&#13;
    function getOwners()&#13;
    public&#13;
    constant&#13;
    returns (address[])&#13;
    {&#13;
        return owners;&#13;
    }&#13;
&#13;
    // @dev Returns list of admins.&#13;
    // @return List of admin addresses&#13;
    function getAdmins()&#13;
    public&#13;
    constant&#13;
    returns (address[])&#13;
    {&#13;
        return admins;&#13;
    }&#13;
&#13;
    /// @dev Returns array with owner addresses, which confirmed transaction.&#13;
    /// @param transactionId Transaction ID.&#13;
    /// @return Returns array of owner addresses.&#13;
    function getConfirmations(uint transactionId)&#13;
    public&#13;
    constant&#13;
    returns (address[] _confirmations)&#13;
    {&#13;
        address[] memory confirmationsTemp = new address[](owners.length);&#13;
        uint count = 0;&#13;
        uint i;&#13;
        for (i = 0; i &lt; owners.length; i++)&#13;
        if (confirmations[transactionId][owners[i]]) {&#13;
            confirmationsTemp[count] = owners[i];&#13;
            count += 1;&#13;
        }&#13;
        _confirmations = new address[](count);&#13;
        for (i = 0; i &lt; count; i++)&#13;
        _confirmations[i] = confirmationsTemp[i];&#13;
    }&#13;
&#13;
    /// @dev Returns list of transaction IDs in defined range.&#13;
    /// @param from Index start position of transaction array.&#13;
    /// @param to Index end position of transaction array.&#13;
    /// @param pending Include pending transactions.&#13;
    /// @param executed Include executed transactions.&#13;
    /// @return Returns array of transaction IDs.&#13;
    function getTransactionIds(uint from, uint to, bool pending, bool executed)&#13;
    public&#13;
    constant&#13;
    returns (uint[] _transactionIds)&#13;
    {&#13;
        uint[] memory transactionIdsTemp = new uint[](transactionCount);&#13;
        uint count = 0;&#13;
        uint i;&#13;
        for (i = 0; i &lt; transactionCount; i++)&#13;
        if (pending &amp;&amp; !transactions[i].executed&#13;
        || executed &amp;&amp; transactions[i].executed)&#13;
        {&#13;
            transactionIdsTemp[count] = i;&#13;
            count += 1;&#13;
        }&#13;
        _transactionIds = new uint[](to - from);&#13;
        for (i = from; i &lt; to; i++)&#13;
        _transactionIds[i - from] = transactionIdsTemp[i];&#13;
    }&#13;
}&#13;
&#13;
contract RntPresaleEthereumDeposit is Pausable {&#13;
    using SafeMath for uint256;&#13;
&#13;
    uint256 public overallTakenEther = 0;&#13;
&#13;
    mapping (address =&gt; uint256) public receivedEther;&#13;
&#13;
    struct Donator {&#13;
        address addr;&#13;
        uint256 donated;&#13;
    }&#13;
&#13;
    Donator[] donators;&#13;
&#13;
    RNTMultiSigWallet public wallet;&#13;
&#13;
    function RntPresaleEthereumDeposit(address _walletAddress) {&#13;
        wallet = RNTMultiSigWallet(_walletAddress);&#13;
    }&#13;
&#13;
    function updateDonator(address _address) internal {&#13;
        bool isFound = false;&#13;
        for (uint i = 0; i &lt; donators.length; i++) {&#13;
            if (donators[i].addr == _address) {&#13;
                donators[i].donated =  receivedEther[_address];&#13;
                isFound = true;&#13;
                break;&#13;
            }&#13;
        }&#13;
        if (!isFound) {&#13;
            donators.push(Donator(_address, receivedEther[_address]));&#13;
        }&#13;
    }&#13;
&#13;
    function getDonatorsNumber() external constant returns(uint256) {&#13;
        return donators.length;&#13;
    }&#13;
&#13;
    function getDonator(uint pos) external constant returns(address, uint256) {&#13;
        return (donators[pos].addr, donators[pos].donated);&#13;
    }&#13;
&#13;
    /*&#13;
     * Fallback function for sending ether to wallet and update donators info&#13;
     */&#13;
    function() whenNotPaused payable {&#13;
        wallet.transfer(msg.value);&#13;
&#13;
        overallTakenEther = overallTakenEther.add(msg.value);&#13;
        receivedEther[msg.sender] = receivedEther[msg.sender].add(msg.value);&#13;
&#13;
        updateDonator(msg.sender);&#13;
    }&#13;
&#13;
    function receivedEtherFrom(address _from) whenNotPaused constant public returns(uint256) {&#13;
        return receivedEther[_from];&#13;
    }&#13;
&#13;
    function myEther() whenNotPaused constant public returns(uint256) {&#13;
        return receivedEther[msg.sender];&#13;
    }&#13;
}&#13;
&#13;
contract PresaleFinalizeAgent is HasNoEther {&#13;
    using SafeMath for uint256;&#13;
&#13;
    RntPresaleEthereumDeposit public deposit;&#13;
&#13;
    address public crowdsaleAddress;&#13;
&#13;
    mapping (address =&gt; uint256) public tokensForAddress;&#13;
&#13;
    uint256 public weiPerToken = 0;&#13;
&#13;
    bool public sane = true;&#13;
&#13;
    function PresaleFinalizeAgent(address _deposit, address _crowdsale){&#13;
        deposit = RntPresaleEthereumDeposit(_deposit);&#13;
        crowdsaleAddress = _crowdsale;&#13;
    }&#13;
&#13;
    modifier onlyCrowdsale() {&#13;
        require(msg.sender == crowdsaleAddress);&#13;
        _;&#13;
    }&#13;
&#13;
    function isSane() public constant returns (bool) {&#13;
        return sane;&#13;
    }&#13;
&#13;
    function setCrowdsaleAddress(address _address) onlyOwner public {&#13;
        crowdsaleAddress = _address;&#13;
    }&#13;
&#13;
    function finalizePresale(uint256 presaleTokens) onlyCrowdsale public {&#13;
        require(sane);&#13;
        uint256 overallEther = deposit.overallTakenEther();&#13;
        uint256 multiplier = 10 ** 18;&#13;
        overallEther = overallEther.mul(multiplier);&#13;
        weiPerToken = overallEther.div(presaleTokens);&#13;
        require(weiPerToken &gt; 0);&#13;
        sane = false;&#13;
    }&#13;
}