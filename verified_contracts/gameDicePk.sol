/*
 ______   _________  ___   ___   _______    _______             ________  ______      
/_____/\ /________/\/__/\ /__/\ /______/\  /______/\           /_______/\/_____/\     
\::::_\/_\__.::.__\/\::\ \\  \ \\::::__\/__\::::__\/__         \__.::._\/\:::_ \ \    
 \:\/___/\  \::\ \   \::\/_\ .\ \\:\ /____/\\:\ /____/\  ___      \::\ \  \:\ \ \ \   
  \::___\/_  \::\ \   \:: ___::\ \\:\\_  _\/ \:\\_  _\/ /__/\     _\::\ \__\:\ \ \ \  
   \:\____/\  \::\ \   \: \ \\::\ \\:\_\ \ \  \:\_\ \ \ \::\ \   /__\::\__/\\:\_\ \ \ 
    \_____\/   \__\/    \__\/ \::\/ \_____\/   \_____\/  \:_\/   \________\/ \_____\/ 
  ______ _______ _    _    _____  ____   ____  _____     _____          __  __ ______  _____ 
 |  ____|__   __| |  | |  / ____|/ __ \ / __ \|  __ \   / ____|   /\   |  \/  |  ____|/ ____|
 | |__     | |  | |__| | | |  __| |  | | |  | | |  | | | |  __   /  \  | \  / | |__  | (___  
 |  __|    | |  |  __  | | | |_ | |  | | |  | | |  | | | | |_ | / /\ \ | |\/| |  __|  \___ \ 
 | |____   | |  | |  | | | |__| | |__| | |__| | |__| | | |__| |/ ____ \| |  | | |____ ____) |
 |______|  |_|  |_|  |_|  \_____|\____/ \____/|_____/   \_____/_/    \_\_|  |_|______|_____/ 
                                                                                             
                                                         BY : <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="d29ebfa181b9ab9295bfb3bbbefcb1bdbf">[emailÂ protected]</a>&#13;
*/                            &#13;
pragma solidity ^0.4.25;&#13;
contract OraclizeI {&#13;
    address public cbAddress;&#13;
    function query(uint _timestamp, string _datasource, string _arg) external payable returns (bytes32 _id);&#13;
    function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) external payable returns (bytes32 _id);&#13;
    function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) public payable returns (bytes32 _id);&#13;
    function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) external payable returns (bytes32 _id);&#13;
    function queryN(uint _timestamp, string _datasource, bytes _argN) public payable returns (bytes32 _id);&#13;
    function queryN_withGasLimit(uint _timestamp, string _datasource, bytes _argN, uint _gaslimit) external payable returns (bytes32 _id);&#13;
    function getPrice(string _datasource) public returns (uint _dsprice);&#13;
    function getPrice(string _datasource, uint gaslimit) public returns (uint _dsprice);&#13;
    function setProofType(byte _proofType) external;&#13;
    function setCustomGasPrice(uint _gasPrice) external;&#13;
    function randomDS_getSessionPubKeyHash() external constant returns(bytes32);&#13;
}&#13;
&#13;
contract OraclizeAddrResolverI {&#13;
    function getAddress() public returns (address _addr);&#13;
}&#13;
&#13;
/*&#13;
Begin solidity-cborutils&#13;
&#13;
https://github.com/smartcontractkit/solidity-cborutils&#13;
&#13;
MIT License&#13;
&#13;
Copyright (c) 2018 SmartContract ChainLink, Ltd.&#13;
&#13;
Permission is hereby granted, free of charge, to any person obtaining a copy&#13;
of this software and associated documentation files (the "Software"), to deal&#13;
in the Software without restriction, including without limitation the rights&#13;
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell&#13;
copies of the Software, and to permit persons to whom the Software is&#13;
furnished to do so, subject to the following conditions:&#13;
&#13;
The above copyright notice and this permission notice shall be included in all&#13;
copies or substantial portions of the Software.&#13;
&#13;
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR&#13;
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,&#13;
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE&#13;
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER&#13;
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,&#13;
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE&#13;
SOFTWARE.&#13;
 */&#13;
&#13;
library Buffer {&#13;
    struct buffer {&#13;
        bytes buf;&#13;
        uint capacity;&#13;
    }&#13;
&#13;
    function init(buffer memory buf, uint _capacity) internal pure {&#13;
        uint capacity = _capacity;&#13;
        if(capacity % 32 != 0) capacity += 32 - (capacity % 32);&#13;
        // Allocate space for the buffer data&#13;
        buf.capacity = capacity;&#13;
        assembly {&#13;
            let ptr := mload(0x40)&#13;
            mstore(buf, ptr)&#13;
            mstore(ptr, 0)&#13;
            mstore(0x40, add(ptr, capacity))&#13;
        }&#13;
    }&#13;
&#13;
    function resize(buffer memory buf, uint capacity) private pure {&#13;
        bytes memory oldbuf = buf.buf;&#13;
        init(buf, capacity);&#13;
        append(buf, oldbuf);&#13;
    }&#13;
&#13;
    function max(uint a, uint b) private pure returns(uint) {&#13;
        if(a &gt; b) {&#13;
            return a;&#13;
        }&#13;
        return b;&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Appends a byte array to the end of the buffer. Resizes if doing so&#13;
     *      would exceed the capacity of the buffer.&#13;
     * @param buf The buffer to append to.&#13;
     * @param data The data to append.&#13;
     * @return The original buffer.&#13;
     */&#13;
    function append(buffer memory buf, bytes data) internal pure returns(buffer memory) {&#13;
        if(data.length + buf.buf.length &gt; buf.capacity) {&#13;
            resize(buf, max(buf.capacity, data.length) * 2);&#13;
        }&#13;
&#13;
        uint dest;&#13;
        uint src;&#13;
        uint len = data.length;&#13;
        assembly {&#13;
            // Memory address of the buffer data&#13;
            let bufptr := mload(buf)&#13;
            // Length of existing buffer data&#13;
            let buflen := mload(bufptr)&#13;
            // Start address = buffer address + buffer length + sizeof(buffer length)&#13;
            dest := add(add(bufptr, buflen), 32)&#13;
            // Update buffer length&#13;
            mstore(bufptr, add(buflen, mload(data)))&#13;
            src := add(data, 32)&#13;
        }&#13;
&#13;
        // Copy word-length chunks while possible&#13;
        for(; len &gt;= 32; len -= 32) {&#13;
            assembly {&#13;
                mstore(dest, mload(src))&#13;
            }&#13;
            dest += 32;&#13;
            src += 32;&#13;
        }&#13;
&#13;
        // Copy remaining bytes&#13;
        uint mask = 256 ** (32 - len) - 1;&#13;
        assembly {&#13;
            let srcpart := and(mload(src), not(mask))&#13;
            let destpart := and(mload(dest), mask)&#13;
            mstore(dest, or(destpart, srcpart))&#13;
        }&#13;
&#13;
        return buf;&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Appends a byte to the end of the buffer. Resizes if doing so would&#13;
     * exceed the capacity of the buffer.&#13;
     * @param buf The buffer to append to.&#13;
     * @param data The data to append.&#13;
     * @return The original buffer.&#13;
     */&#13;
    function append(buffer memory buf, uint8 data) internal pure {&#13;
        if(buf.buf.length + 1 &gt; buf.capacity) {&#13;
            resize(buf, buf.capacity * 2);&#13;
        }&#13;
&#13;
        assembly {&#13;
            // Memory address of the buffer data&#13;
            let bufptr := mload(buf)&#13;
            // Length of existing buffer data&#13;
            let buflen := mload(bufptr)&#13;
            // Address = buffer address + buffer length + sizeof(buffer length)&#13;
            let dest := add(add(bufptr, buflen), 32)&#13;
            mstore8(dest, data)&#13;
            // Update buffer length&#13;
            mstore(bufptr, add(buflen, 1))&#13;
        }&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Appends a byte to the end of the buffer. Resizes if doing so would&#13;
     * exceed the capacity of the buffer.&#13;
     * @param buf The buffer to append to.&#13;
     * @param data The data to append.&#13;
     * @return The original buffer.&#13;
     */&#13;
    function appendInt(buffer memory buf, uint data, uint len) internal pure returns(buffer memory) {&#13;
        if(len + buf.buf.length &gt; buf.capacity) {&#13;
            resize(buf, max(buf.capacity, len) * 2);&#13;
        }&#13;
&#13;
        uint mask = 256 ** len - 1;&#13;
        assembly {&#13;
            // Memory address of the buffer data&#13;
            let bufptr := mload(buf)&#13;
            // Length of existing buffer data&#13;
            let buflen := mload(bufptr)&#13;
            // Address = buffer address + buffer length + sizeof(buffer length) + len&#13;
            let dest := add(add(bufptr, buflen), len)&#13;
            mstore(dest, or(and(mload(dest), not(mask)), data))&#13;
            // Update buffer length&#13;
            mstore(bufptr, add(buflen, len))&#13;
        }&#13;
        return buf;&#13;
    }&#13;
}&#13;
&#13;
library CBOR {&#13;
    using Buffer for Buffer.buffer;&#13;
&#13;
    uint8 private constant MAJOR_TYPE_INT = 0;&#13;
    uint8 private constant MAJOR_TYPE_NEGATIVE_INT = 1;&#13;
    uint8 private constant MAJOR_TYPE_BYTES = 2;&#13;
    uint8 private constant MAJOR_TYPE_STRING = 3;&#13;
    uint8 private constant MAJOR_TYPE_ARRAY = 4;&#13;
    uint8 private constant MAJOR_TYPE_MAP = 5;&#13;
    uint8 private constant MAJOR_TYPE_CONTENT_FREE = 7;&#13;
&#13;
    function encodeType(Buffer.buffer memory buf, uint8 major, uint value) private pure {&#13;
        if(value &lt;= 23) {&#13;
            buf.append(uint8((major &lt;&lt; 5) | value));&#13;
        } else if(value &lt;= 0xFF) {&#13;
            buf.append(uint8((major &lt;&lt; 5) | 24));&#13;
            buf.appendInt(value, 1);&#13;
        } else if(value &lt;= 0xFFFF) {&#13;
            buf.append(uint8((major &lt;&lt; 5) | 25));&#13;
            buf.appendInt(value, 2);&#13;
        } else if(value &lt;= 0xFFFFFFFF) {&#13;
            buf.append(uint8((major &lt;&lt; 5) | 26));&#13;
            buf.appendInt(value, 4);&#13;
        } else if(value &lt;= 0xFFFFFFFFFFFFFFFF) {&#13;
            buf.append(uint8((major &lt;&lt; 5) | 27));&#13;
            buf.appendInt(value, 8);&#13;
        }&#13;
    }&#13;
&#13;
    function encodeIndefiniteLengthType(Buffer.buffer memory buf, uint8 major) private pure {&#13;
        buf.append(uint8((major &lt;&lt; 5) | 31));&#13;
    }&#13;
&#13;
    function encodeUInt(Buffer.buffer memory buf, uint value) internal pure {&#13;
        encodeType(buf, MAJOR_TYPE_INT, value);&#13;
    }&#13;
&#13;
    function encodeInt(Buffer.buffer memory buf, int value) internal pure {&#13;
        if(value &gt;= 0) {&#13;
            encodeType(buf, MAJOR_TYPE_INT, uint(value));&#13;
        } else {&#13;
            encodeType(buf, MAJOR_TYPE_NEGATIVE_INT, uint(-1 - value));&#13;
        }&#13;
    }&#13;
&#13;
    function encodeBytes(Buffer.buffer memory buf, bytes value) internal pure {&#13;
        encodeType(buf, MAJOR_TYPE_BYTES, value.length);&#13;
        buf.append(value);&#13;
    }&#13;
&#13;
    function encodeString(Buffer.buffer memory buf, string value) internal pure {&#13;
        encodeType(buf, MAJOR_TYPE_STRING, bytes(value).length);&#13;
        buf.append(bytes(value));&#13;
    }&#13;
&#13;
    function startArray(Buffer.buffer memory buf) internal pure {&#13;
        encodeIndefiniteLengthType(buf, MAJOR_TYPE_ARRAY);&#13;
    }&#13;
&#13;
    function startMap(Buffer.buffer memory buf) internal pure {&#13;
        encodeIndefiniteLengthType(buf, MAJOR_TYPE_MAP);&#13;
    }&#13;
&#13;
    function endSequence(Buffer.buffer memory buf) internal pure {&#13;
        encodeIndefiniteLengthType(buf, MAJOR_TYPE_CONTENT_FREE);&#13;
    }&#13;
}&#13;
&#13;
/*&#13;
End solidity-cborutils&#13;
 */&#13;
&#13;
contract usingOraclize {&#13;
    uint constant day = 60*60*24;&#13;
    uint constant week = 60*60*24*7;&#13;
    uint constant month = 60*60*24*30;&#13;
    byte constant proofType_NONE = 0x00;&#13;
    byte constant proofType_TLSNotary = 0x10;&#13;
    byte constant proofType_Ledger = 0x30;&#13;
    byte constant proofType_Android = 0x40;&#13;
    byte constant proofType_Native = 0xF0;&#13;
    byte constant proofStorage_IPFS = 0x01;&#13;
    uint8 constant networkID_auto = 0;&#13;
    uint8 constant networkID_mainnet = 1;&#13;
    uint8 constant networkID_testnet = 2;&#13;
    uint8 constant networkID_morden = 2;&#13;
    uint8 constant networkID_consensys = 161;&#13;
&#13;
    OraclizeAddrResolverI OAR;&#13;
&#13;
    OraclizeI oraclize;&#13;
    modifier oraclizeAPI {&#13;
        if((address(OAR)==0)||(getCodeSize(address(OAR))==0))&#13;
            oraclize_setNetwork(networkID_auto);&#13;
&#13;
        if(address(oraclize) != OAR.getAddress())&#13;
            oraclize = OraclizeI(OAR.getAddress());&#13;
&#13;
        _;&#13;
    }&#13;
    modifier coupon(string code){&#13;
        oraclize = OraclizeI(OAR.getAddress());&#13;
        _;&#13;
    }&#13;
&#13;
    function oraclize_setNetwork(uint8 networkID) internal returns(bool){&#13;
      return oraclize_setNetwork();&#13;
      networkID; // silence the warning and remain backwards compatible&#13;
    }&#13;
    function oraclize_setNetwork() internal returns(bool){&#13;
        if (getCodeSize(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed)&gt;0){ //mainnet&#13;
            OAR = OraclizeAddrResolverI(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed);&#13;
            oraclize_setNetworkName("eth_mainnet");&#13;
            return true;&#13;
        }&#13;
        if (getCodeSize(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1)&gt;0){ //ropsten testnet&#13;
            OAR = OraclizeAddrResolverI(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1);&#13;
            oraclize_setNetworkName("eth_ropsten3");&#13;
            return true;&#13;
        }&#13;
        if (getCodeSize(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e)&gt;0){ //kovan testnet&#13;
            OAR = OraclizeAddrResolverI(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e);&#13;
            oraclize_setNetworkName("eth_kovan");&#13;
            return true;&#13;
        }&#13;
        if (getCodeSize(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48)&gt;0){ //rinkeby testnet&#13;
            OAR = OraclizeAddrResolverI(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48);&#13;
            oraclize_setNetworkName("eth_rinkeby");&#13;
            return true;&#13;
        }&#13;
        if (getCodeSize(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475)&gt;0){ //ethereum-bridge&#13;
            OAR = OraclizeAddrResolverI(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475);&#13;
            return true;&#13;
        }&#13;
        if (getCodeSize(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF)&gt;0){ //ether.camp ide&#13;
            OAR = OraclizeAddrResolverI(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF);&#13;
            return true;&#13;
        }&#13;
        if (getCodeSize(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA)&gt;0){ //browser-solidity&#13;
            OAR = OraclizeAddrResolverI(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA);&#13;
            return true;&#13;
        }&#13;
        return false;&#13;
    }&#13;
&#13;
    function __callback(bytes32 myid, string result) public {&#13;
        __callback(myid, result, new bytes(0));&#13;
    }&#13;
    function __callback(bytes32 myid, string result, bytes proof) public {&#13;
      return;&#13;
      myid; result; proof; // Silence compiler warnings&#13;
    }&#13;
&#13;
    function oraclize_getPrice(string datasource) oraclizeAPI internal returns (uint){&#13;
        return oraclize.getPrice(datasource);&#13;
    }&#13;
&#13;
    function oraclize_getPrice(string datasource, uint gaslimit) oraclizeAPI internal returns (uint){&#13;
        return oraclize.getPrice(datasource, gaslimit);&#13;
    }&#13;
&#13;
    function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){&#13;
        uint price = oraclize.getPrice(datasource);&#13;
        if (price &gt; 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price&#13;
        return oraclize.query.value(price)(0, datasource, arg);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){&#13;
        uint price = oraclize.getPrice(datasource);&#13;
        if (price &gt; 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price&#13;
        return oraclize.query.value(price)(timestamp, datasource, arg);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){&#13;
        uint price = oraclize.getPrice(datasource, gaslimit);&#13;
        if (price &gt; 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price&#13;
        return oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){&#13;
        uint price = oraclize.getPrice(datasource, gaslimit);&#13;
        if (price &gt; 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price&#13;
        return oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){&#13;
        uint price = oraclize.getPrice(datasource);&#13;
        if (price &gt; 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price&#13;
        return oraclize.query2.value(price)(0, datasource, arg1, arg2);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){&#13;
        uint price = oraclize.getPrice(datasource);&#13;
        if (price &gt; 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price&#13;
        return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){&#13;
        uint price = oraclize.getPrice(datasource, gaslimit);&#13;
        if (price &gt; 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price&#13;
        return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){&#13;
        uint price = oraclize.getPrice(datasource, gaslimit);&#13;
        if (price &gt; 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price&#13;
        return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, string[] argN) oraclizeAPI internal returns (bytes32 id){&#13;
        uint price = oraclize.getPrice(datasource);&#13;
        if (price &gt; 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price&#13;
        bytes memory args = stra2cbor(argN);&#13;
        return oraclize.queryN.value(price)(0, datasource, args);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, string[] argN) oraclizeAPI internal returns (bytes32 id){&#13;
        uint price = oraclize.getPrice(datasource);&#13;
        if (price &gt; 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price&#13;
        bytes memory args = stra2cbor(argN);&#13;
        return oraclize.queryN.value(price)(timestamp, datasource, args);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, string[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){&#13;
        uint price = oraclize.getPrice(datasource, gaslimit);&#13;
        if (price &gt; 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price&#13;
        bytes memory args = stra2cbor(argN);&#13;
        return oraclize.queryN_withGasLimit.value(price)(timestamp, datasource, args, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, string[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){&#13;
        uint price = oraclize.getPrice(datasource, gaslimit);&#13;
        if (price &gt; 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price&#13;
        bytes memory args = stra2cbor(argN);&#13;
        return oraclize.queryN_withGasLimit.value(price)(0, datasource, args, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, string[1] args) oraclizeAPI internal returns (bytes32 id) {&#13;
        string[] memory dynargs = new string[](1);&#13;
        dynargs[0] = args[0];&#13;
        return oraclize_query(datasource, dynargs);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, string[1] args) oraclizeAPI internal returns (bytes32 id) {&#13;
        string[] memory dynargs = new string[](1);&#13;
        dynargs[0] = args[0];&#13;
        return oraclize_query(timestamp, datasource, dynargs);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, string[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {&#13;
        string[] memory dynargs = new string[](1);&#13;
        dynargs[0] = args[0];&#13;
        return oraclize_query(timestamp, datasource, dynargs, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, string[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {&#13;
        string[] memory dynargs = new string[](1);&#13;
        dynargs[0] = args[0];&#13;
        return oraclize_query(datasource, dynargs, gaslimit);&#13;
    }&#13;
&#13;
    function oraclize_query(string datasource, string[2] args) oraclizeAPI internal returns (bytes32 id) {&#13;
        string[] memory dynargs = new string[](2);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        return oraclize_query(datasource, dynargs);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, string[2] args) oraclizeAPI internal returns (bytes32 id) {&#13;
        string[] memory dynargs = new string[](2);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        return oraclize_query(timestamp, datasource, dynargs);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, string[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {&#13;
        string[] memory dynargs = new string[](2);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        return oraclize_query(timestamp, datasource, dynargs, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, string[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {&#13;
        string[] memory dynargs = new string[](2);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        return oraclize_query(datasource, dynargs, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, string[3] args) oraclizeAPI internal returns (bytes32 id) {&#13;
        string[] memory dynargs = new string[](3);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        return oraclize_query(datasource, dynargs);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, string[3] args) oraclizeAPI internal returns (bytes32 id) {&#13;
        string[] memory dynargs = new string[](3);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        return oraclize_query(timestamp, datasource, dynargs);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, string[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {&#13;
        string[] memory dynargs = new string[](3);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        return oraclize_query(timestamp, datasource, dynargs, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, string[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {&#13;
        string[] memory dynargs = new string[](3);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        return oraclize_query(datasource, dynargs, gaslimit);&#13;
    }&#13;
&#13;
    function oraclize_query(string datasource, string[4] args) oraclizeAPI internal returns (bytes32 id) {&#13;
        string[] memory dynargs = new string[](4);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        dynargs[3] = args[3];&#13;
        return oraclize_query(datasource, dynargs);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, string[4] args) oraclizeAPI internal returns (bytes32 id) {&#13;
        string[] memory dynargs = new string[](4);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        dynargs[3] = args[3];&#13;
        return oraclize_query(timestamp, datasource, dynargs);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, string[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {&#13;
        string[] memory dynargs = new string[](4);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        dynargs[3] = args[3];&#13;
        return oraclize_query(timestamp, datasource, dynargs, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, string[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {&#13;
        string[] memory dynargs = new string[](4);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        dynargs[3] = args[3];&#13;
        return oraclize_query(datasource, dynargs, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, string[5] args) oraclizeAPI internal returns (bytes32 id) {&#13;
        string[] memory dynargs = new string[](5);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        dynargs[3] = args[3];&#13;
        dynargs[4] = args[4];&#13;
        return oraclize_query(datasource, dynargs);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, string[5] args) oraclizeAPI internal returns (bytes32 id) {&#13;
        string[] memory dynargs = new string[](5);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        dynargs[3] = args[3];&#13;
        dynargs[4] = args[4];&#13;
        return oraclize_query(timestamp, datasource, dynargs);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, string[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {&#13;
        string[] memory dynargs = new string[](5);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        dynargs[3] = args[3];&#13;
        dynargs[4] = args[4];&#13;
        return oraclize_query(timestamp, datasource, dynargs, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, string[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {&#13;
        string[] memory dynargs = new string[](5);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        dynargs[3] = args[3];&#13;
        dynargs[4] = args[4];&#13;
        return oraclize_query(datasource, dynargs, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, bytes[] argN) oraclizeAPI internal returns (bytes32 id){&#13;
        uint price = oraclize.getPrice(datasource);&#13;
        if (price &gt; 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price&#13;
        bytes memory args = ba2cbor(argN);&#13;
        return oraclize.queryN.value(price)(0, datasource, args);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, bytes[] argN) oraclizeAPI internal returns (bytes32 id){&#13;
        uint price = oraclize.getPrice(datasource);&#13;
        if (price &gt; 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price&#13;
        bytes memory args = ba2cbor(argN);&#13;
        return oraclize.queryN.value(price)(timestamp, datasource, args);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, bytes[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){&#13;
        uint price = oraclize.getPrice(datasource, gaslimit);&#13;
        if (price &gt; 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price&#13;
        bytes memory args = ba2cbor(argN);&#13;
        return oraclize.queryN_withGasLimit.value(price)(timestamp, datasource, args, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, bytes[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){&#13;
        uint price = oraclize.getPrice(datasource, gaslimit);&#13;
        if (price &gt; 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price&#13;
        bytes memory args = ba2cbor(argN);&#13;
        return oraclize.queryN_withGasLimit.value(price)(0, datasource, args, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, bytes[1] args) oraclizeAPI internal returns (bytes32 id) {&#13;
        bytes[] memory dynargs = new bytes[](1);&#13;
        dynargs[0] = args[0];&#13;
        return oraclize_query(datasource, dynargs);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, bytes[1] args) oraclizeAPI internal returns (bytes32 id) {&#13;
        bytes[] memory dynargs = new bytes[](1);&#13;
        dynargs[0] = args[0];&#13;
        return oraclize_query(timestamp, datasource, dynargs);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, bytes[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {&#13;
        bytes[] memory dynargs = new bytes[](1);&#13;
        dynargs[0] = args[0];&#13;
        return oraclize_query(timestamp, datasource, dynargs, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, bytes[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {&#13;
        bytes[] memory dynargs = new bytes[](1);&#13;
        dynargs[0] = args[0];&#13;
        return oraclize_query(datasource, dynargs, gaslimit);&#13;
    }&#13;
&#13;
    function oraclize_query(string datasource, bytes[2] args) oraclizeAPI internal returns (bytes32 id) {&#13;
        bytes[] memory dynargs = new bytes[](2);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        return oraclize_query(datasource, dynargs);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, bytes[2] args) oraclizeAPI internal returns (bytes32 id) {&#13;
        bytes[] memory dynargs = new bytes[](2);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        return oraclize_query(timestamp, datasource, dynargs);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, bytes[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {&#13;
        bytes[] memory dynargs = new bytes[](2);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        return oraclize_query(timestamp, datasource, dynargs, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, bytes[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {&#13;
        bytes[] memory dynargs = new bytes[](2);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        return oraclize_query(datasource, dynargs, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, bytes[3] args) oraclizeAPI internal returns (bytes32 id) {&#13;
        bytes[] memory dynargs = new bytes[](3);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        return oraclize_query(datasource, dynargs);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, bytes[3] args) oraclizeAPI internal returns (bytes32 id) {&#13;
        bytes[] memory dynargs = new bytes[](3);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        return oraclize_query(timestamp, datasource, dynargs);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, bytes[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {&#13;
        bytes[] memory dynargs = new bytes[](3);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        return oraclize_query(timestamp, datasource, dynargs, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, bytes[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {&#13;
        bytes[] memory dynargs = new bytes[](3);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        return oraclize_query(datasource, dynargs, gaslimit);&#13;
    }&#13;
&#13;
    function oraclize_query(string datasource, bytes[4] args) oraclizeAPI internal returns (bytes32 id) {&#13;
        bytes[] memory dynargs = new bytes[](4);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        dynargs[3] = args[3];&#13;
        return oraclize_query(datasource, dynargs);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, bytes[4] args) oraclizeAPI internal returns (bytes32 id) {&#13;
        bytes[] memory dynargs = new bytes[](4);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        dynargs[3] = args[3];&#13;
        return oraclize_query(timestamp, datasource, dynargs);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, bytes[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {&#13;
        bytes[] memory dynargs = new bytes[](4);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        dynargs[3] = args[3];&#13;
        return oraclize_query(timestamp, datasource, dynargs, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, bytes[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {&#13;
        bytes[] memory dynargs = new bytes[](4);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        dynargs[3] = args[3];&#13;
        return oraclize_query(datasource, dynargs, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, bytes[5] args) oraclizeAPI internal returns (bytes32 id) {&#13;
        bytes[] memory dynargs = new bytes[](5);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        dynargs[3] = args[3];&#13;
        dynargs[4] = args[4];&#13;
        return oraclize_query(datasource, dynargs);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, bytes[5] args) oraclizeAPI internal returns (bytes32 id) {&#13;
        bytes[] memory dynargs = new bytes[](5);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        dynargs[3] = args[3];&#13;
        dynargs[4] = args[4];&#13;
        return oraclize_query(timestamp, datasource, dynargs);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, bytes[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {&#13;
        bytes[] memory dynargs = new bytes[](5);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        dynargs[3] = args[3];&#13;
        dynargs[4] = args[4];&#13;
        return oraclize_query(timestamp, datasource, dynargs, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, bytes[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {&#13;
        bytes[] memory dynargs = new bytes[](5);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        dynargs[3] = args[3];&#13;
        dynargs[4] = args[4];&#13;
        return oraclize_query(datasource, dynargs, gaslimit);&#13;
    }&#13;
&#13;
    function oraclize_cbAddress() oraclizeAPI internal returns (address){&#13;
        return oraclize.cbAddress();&#13;
    }&#13;
    function oraclize_setProof(byte proofP) oraclizeAPI internal {&#13;
        return oraclize.setProofType(proofP);&#13;
    }&#13;
    function oraclize_setCustomGasPrice(uint gasPrice) oraclizeAPI internal {&#13;
        return oraclize.setCustomGasPrice(gasPrice);&#13;
    }&#13;
&#13;
    function oraclize_randomDS_getSessionPubKeyHash() oraclizeAPI internal returns (bytes32){&#13;
        return oraclize.randomDS_getSessionPubKeyHash();&#13;
    }&#13;
&#13;
    function getCodeSize(address _addr) constant internal returns(uint _size) {&#13;
        assembly {&#13;
            _size := extcodesize(_addr)&#13;
        }&#13;
    }&#13;
&#13;
    function parseAddr(string _a) internal pure returns (address){&#13;
        bytes memory tmp = bytes(_a);&#13;
        uint160 iaddr = 0;&#13;
        uint160 b1;&#13;
        uint160 b2;&#13;
        for (uint i=2; i&lt;2+2*20; i+=2){&#13;
            iaddr *= 256;&#13;
            b1 = uint160(tmp[i]);&#13;
            b2 = uint160(tmp[i+1]);&#13;
            if ((b1 &gt;= 97)&amp;&amp;(b1 &lt;= 102)) b1 -= 87;&#13;
            else if ((b1 &gt;= 65)&amp;&amp;(b1 &lt;= 70)) b1 -= 55;&#13;
            else if ((b1 &gt;= 48)&amp;&amp;(b1 &lt;= 57)) b1 -= 48;&#13;
            if ((b2 &gt;= 97)&amp;&amp;(b2 &lt;= 102)) b2 -= 87;&#13;
            else if ((b2 &gt;= 65)&amp;&amp;(b2 &lt;= 70)) b2 -= 55;&#13;
            else if ((b2 &gt;= 48)&amp;&amp;(b2 &lt;= 57)) b2 -= 48;&#13;
            iaddr += (b1*16+b2);&#13;
        }&#13;
        return address(iaddr);&#13;
    }&#13;
&#13;
    function strCompare(string _a, string _b) internal pure returns (int) {&#13;
        bytes memory a = bytes(_a);&#13;
        bytes memory b = bytes(_b);&#13;
        uint minLength = a.length;&#13;
        if (b.length &lt; minLength) minLength = b.length;&#13;
        for (uint i = 0; i &lt; minLength; i ++)&#13;
            if (a[i] &lt; b[i])&#13;
                return -1;&#13;
            else if (a[i] &gt; b[i])&#13;
                return 1;&#13;
        if (a.length &lt; b.length)&#13;
            return -1;&#13;
        else if (a.length &gt; b.length)&#13;
            return 1;&#13;
        else&#13;
            return 0;&#13;
    }&#13;
&#13;
    function indexOf(string _haystack, string _needle) internal pure returns (int) {&#13;
        bytes memory h = bytes(_haystack);&#13;
        bytes memory n = bytes(_needle);&#13;
        if(h.length &lt; 1 || n.length &lt; 1 || (n.length &gt; h.length))&#13;
            return -1;&#13;
        else if(h.length &gt; (2**128 -1))&#13;
            return -1;&#13;
        else&#13;
        {&#13;
            uint subindex = 0;&#13;
            for (uint i = 0; i &lt; h.length; i ++)&#13;
            {&#13;
                if (h[i] == n[0])&#13;
                {&#13;
                    subindex = 1;&#13;
                    while(subindex &lt; n.length &amp;&amp; (i + subindex) &lt; h.length &amp;&amp; h[i + subindex] == n[subindex])&#13;
                    {&#13;
                        subindex++;&#13;
                    }&#13;
                    if(subindex == n.length)&#13;
                        return int(i);&#13;
                }&#13;
            }&#13;
            return -1;&#13;
        }&#13;
    }&#13;
&#13;
    function strConcat(string _a, string _b, string _c, string _d, string _e) internal pure returns (string) {&#13;
        bytes memory _ba = bytes(_a);&#13;
        bytes memory _bb = bytes(_b);&#13;
        bytes memory _bc = bytes(_c);&#13;
        bytes memory _bd = bytes(_d);&#13;
        bytes memory _be = bytes(_e);&#13;
        string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);&#13;
        bytes memory babcde = bytes(abcde);&#13;
        uint k = 0;&#13;
        for (uint i = 0; i &lt; _ba.length; i++) babcde[k++] = _ba[i];&#13;
        for (i = 0; i &lt; _bb.length; i++) babcde[k++] = _bb[i];&#13;
        for (i = 0; i &lt; _bc.length; i++) babcde[k++] = _bc[i];&#13;
        for (i = 0; i &lt; _bd.length; i++) babcde[k++] = _bd[i];&#13;
        for (i = 0; i &lt; _be.length; i++) babcde[k++] = _be[i];&#13;
        return string(babcde);&#13;
    }&#13;
&#13;
    function strConcat(string _a, string _b, string _c, string _d) internal pure returns (string) {&#13;
        return strConcat(_a, _b, _c, _d, "");&#13;
    }&#13;
&#13;
    function strConcat(string _a, string _b, string _c) internal pure returns (string) {&#13;
        return strConcat(_a, _b, _c, "", "");&#13;
    }&#13;
&#13;
    function strConcat(string _a, string _b) internal pure returns (string) {&#13;
        return strConcat(_a, _b, "", "", "");&#13;
    }&#13;
&#13;
    // parseInt&#13;
    function parseInt(string _a) internal pure returns (uint) {&#13;
        return parseInt(_a, 0);&#13;
    }&#13;
&#13;
    // parseInt(parseFloat*10^_b)&#13;
    function parseInt(string _a, uint _b) internal pure returns (uint) {&#13;
        bytes memory bresult = bytes(_a);&#13;
        uint mint = 0;&#13;
        bool decimals = false;&#13;
        for (uint i=0; i&lt;bresult.length; i++){&#13;
            if ((bresult[i] &gt;= 48)&amp;&amp;(bresult[i] &lt;= 57)){&#13;
                if (decimals){&#13;
                   if (_b == 0) break;&#13;
                    else _b--;&#13;
                }&#13;
                mint *= 10;&#13;
                mint += uint(bresult[i]) - 48;&#13;
            } else if (bresult[i] == 46) decimals = true;&#13;
        }&#13;
        if (_b &gt; 0) mint *= 10**_b;&#13;
        return mint;&#13;
    }&#13;
&#13;
    function uint2str(uint i) internal pure returns (string){&#13;
        if (i == 0) return "0";&#13;
        uint j = i;&#13;
        uint len;&#13;
        while (j != 0){&#13;
            len++;&#13;
            j /= 10;&#13;
        }&#13;
        bytes memory bstr = new bytes(len);&#13;
        uint k = len - 1;&#13;
        while (i != 0){&#13;
            bstr[k--] = byte(48 + i % 10);&#13;
            i /= 10;&#13;
        }&#13;
        return string(bstr);&#13;
    }&#13;
&#13;
    using CBOR for Buffer.buffer;&#13;
    function stra2cbor(string[] arr) internal pure returns (bytes) {&#13;
        safeMemoryCleaner();&#13;
        Buffer.buffer memory buf;&#13;
        Buffer.init(buf, 1024);&#13;
        buf.startArray();&#13;
        for (uint i = 0; i &lt; arr.length; i++) {&#13;
            buf.encodeString(arr[i]);&#13;
        }&#13;
        buf.endSequence();&#13;
        return buf.buf;&#13;
    }&#13;
&#13;
    function ba2cbor(bytes[] arr) internal pure returns (bytes) {&#13;
        safeMemoryCleaner();&#13;
        Buffer.buffer memory buf;&#13;
        Buffer.init(buf, 1024);&#13;
        buf.startArray();&#13;
        for (uint i = 0; i &lt; arr.length; i++) {&#13;
            buf.encodeBytes(arr[i]);&#13;
        }&#13;
        buf.endSequence();&#13;
        return buf.buf;&#13;
    }&#13;
&#13;
    string oraclize_network_name;&#13;
    function oraclize_setNetworkName(string _network_name) internal {&#13;
        oraclize_network_name = _network_name;&#13;
    }&#13;
&#13;
    function oraclize_getNetworkName() internal view returns (string) {&#13;
        return oraclize_network_name;&#13;
    }&#13;
&#13;
    function oraclize_newRandomDSQuery(uint _delay, uint _nbytes, uint _customGasLimit) internal returns (bytes32){&#13;
        require((_nbytes &gt; 0) &amp;&amp; (_nbytes &lt;= 32));&#13;
        // Convert from seconds to ledger timer ticks&#13;
        _delay *= 10;&#13;
        bytes memory nbytes = new bytes(1);&#13;
        nbytes[0] = byte(_nbytes);&#13;
        bytes memory unonce = new bytes(32);&#13;
        bytes memory sessionKeyHash = new bytes(32);&#13;
        bytes32 sessionKeyHash_bytes32 = oraclize_randomDS_getSessionPubKeyHash();&#13;
        assembly {&#13;
            mstore(unonce, 0x20)&#13;
            // the following variables can be relaxed&#13;
            // check relaxed random contract under ethereum-examples repo&#13;
            // for an idea on how to override and replace comit hash vars&#13;
            mstore(add(unonce, 0x20), xor(blockhash(sub(number, 1)), xor(coinbase, timestamp)))&#13;
            mstore(sessionKeyHash, 0x20)&#13;
            mstore(add(sessionKeyHash, 0x20), sessionKeyHash_bytes32)&#13;
        }&#13;
        bytes memory delay = new bytes(32);&#13;
        assembly {&#13;
            mstore(add(delay, 0x20), _delay)&#13;
        }&#13;
&#13;
        bytes memory delay_bytes8 = new bytes(8);&#13;
        copyBytes(delay, 24, 8, delay_bytes8, 0);&#13;
&#13;
        bytes[4] memory args = [unonce, nbytes, sessionKeyHash, delay];&#13;
        bytes32 queryId = oraclize_query("random", args, _customGasLimit);&#13;
&#13;
        bytes memory delay_bytes8_left = new bytes(8);&#13;
&#13;
        assembly {&#13;
            let x := mload(add(delay_bytes8, 0x20))&#13;
            mstore8(add(delay_bytes8_left, 0x27), div(x, 0x100000000000000000000000000000000000000000000000000000000000000))&#13;
            mstore8(add(delay_bytes8_left, 0x26), div(x, 0x1000000000000000000000000000000000000000000000000000000000000))&#13;
            mstore8(add(delay_bytes8_left, 0x25), div(x, 0x10000000000000000000000000000000000000000000000000000000000))&#13;
            mstore8(add(delay_bytes8_left, 0x24), div(x, 0x100000000000000000000000000000000000000000000000000000000))&#13;
            mstore8(add(delay_bytes8_left, 0x23), div(x, 0x1000000000000000000000000000000000000000000000000000000))&#13;
            mstore8(add(delay_bytes8_left, 0x22), div(x, 0x10000000000000000000000000000000000000000000000000000))&#13;
            mstore8(add(delay_bytes8_left, 0x21), div(x, 0x100000000000000000000000000000000000000000000000000))&#13;
            mstore8(add(delay_bytes8_left, 0x20), div(x, 0x1000000000000000000000000000000000000000000000000))&#13;
&#13;
        }&#13;
&#13;
        oraclize_randomDS_setCommitment(queryId, keccak256(delay_bytes8_left, args[1], sha256(args[0]), args[2]));&#13;
        return queryId;&#13;
    }&#13;
&#13;
    function oraclize_randomDS_setCommitment(bytes32 queryId, bytes32 commitment) internal {&#13;
        oraclize_randomDS_args[queryId] = commitment;&#13;
    }&#13;
&#13;
    mapping(bytes32=&gt;bytes32) oraclize_randomDS_args;&#13;
    mapping(bytes32=&gt;bool) oraclize_randomDS_sessionKeysHashVerified;&#13;
&#13;
    function verifySig(bytes32 tosignh, bytes dersig, bytes pubkey) internal returns (bool){&#13;
        bool sigok;&#13;
        address signer;&#13;
&#13;
        bytes32 sigr;&#13;
        bytes32 sigs;&#13;
&#13;
        bytes memory sigr_ = new bytes(32);&#13;
        uint offset = 4+(uint(dersig[3]) - 0x20);&#13;
        sigr_ = copyBytes(dersig, offset, 32, sigr_, 0);&#13;
        bytes memory sigs_ = new bytes(32);&#13;
        offset += 32 + 2;&#13;
        sigs_ = copyBytes(dersig, offset+(uint(dersig[offset-1]) - 0x20), 32, sigs_, 0);&#13;
&#13;
        assembly {&#13;
            sigr := mload(add(sigr_, 32))&#13;
            sigs := mload(add(sigs_, 32))&#13;
        }&#13;
&#13;
&#13;
        (sigok, signer) = safer_ecrecover(tosignh, 27, sigr, sigs);&#13;
        if (address(keccak256(pubkey)) == signer) return true;&#13;
        else {&#13;
            (sigok, signer) = safer_ecrecover(tosignh, 28, sigr, sigs);&#13;
            return (address(keccak256(pubkey)) == signer);&#13;
        }&#13;
    }&#13;
&#13;
    function oraclize_randomDS_proofVerify__sessionKeyValidity(bytes proof, uint sig2offset) internal returns (bool) {&#13;
        bool sigok;&#13;
&#13;
        // Step 6: verify the attestation signature, APPKEY1 must sign the sessionKey from the correct ledger app (CODEHASH)&#13;
        bytes memory sig2 = new bytes(uint(proof[sig2offset+1])+2);&#13;
        copyBytes(proof, sig2offset, sig2.length, sig2, 0);&#13;
&#13;
        bytes memory appkey1_pubkey = new bytes(64);&#13;
        copyBytes(proof, 3+1, 64, appkey1_pubkey, 0);&#13;
&#13;
        bytes memory tosign2 = new bytes(1+65+32);&#13;
        tosign2[0] = byte(1); //role&#13;
        copyBytes(proof, sig2offset-65, 65, tosign2, 1);&#13;
        bytes memory CODEHASH = hex"fd94fa71bc0ba10d39d464d0d8f465efeef0a2764e3887fcc9df41ded20f505c";&#13;
        copyBytes(CODEHASH, 0, 32, tosign2, 1+65);&#13;
        sigok = verifySig(sha256(tosign2), sig2, appkey1_pubkey);&#13;
&#13;
        if (sigok == false) return false;&#13;
&#13;
&#13;
        // Step 7: verify the APPKEY1 provenance (must be signed by Ledger)&#13;
        bytes memory LEDGERKEY = hex"7fb956469c5c9b89840d55b43537e66a98dd4811ea0a27224272c2e5622911e8537a2f8e86a46baec82864e98dd01e9ccc2f8bc5dfc9cbe5a91a290498dd96e4";&#13;
&#13;
        bytes memory tosign3 = new bytes(1+65);&#13;
        tosign3[0] = 0xFE;&#13;
        copyBytes(proof, 3, 65, tosign3, 1);&#13;
&#13;
        bytes memory sig3 = new bytes(uint(proof[3+65+1])+2);&#13;
        copyBytes(proof, 3+65, sig3.length, sig3, 0);&#13;
&#13;
        sigok = verifySig(sha256(tosign3), sig3, LEDGERKEY);&#13;
&#13;
        return sigok;&#13;
    }&#13;
&#13;
    modifier oraclize_randomDS_proofVerify(bytes32 _queryId, string _result, bytes _proof) {&#13;
        // Step 1: the prefix has to match 'LP\x01' (Ledger Proof version 1)&#13;
        require((_proof[0] == "L") &amp;&amp; (_proof[1] == "P") &amp;&amp; (_proof[2] == 1));&#13;
&#13;
        bool proofVerified = oraclize_randomDS_proofVerify__main(_proof, _queryId, bytes(_result), oraclize_getNetworkName());&#13;
        require(proofVerified);&#13;
&#13;
        _;&#13;
    }&#13;
&#13;
    function oraclize_randomDS_proofVerify__returnCode(bytes32 _queryId, string _result, bytes _proof) internal returns (uint8){&#13;
        // Step 1: the prefix has to match 'LP\x01' (Ledger Proof version 1)&#13;
        if ((_proof[0] != "L")||(_proof[1] != "P")||(_proof[2] != 1)) return 1;&#13;
&#13;
        bool proofVerified = oraclize_randomDS_proofVerify__main(_proof, _queryId, bytes(_result), oraclize_getNetworkName());&#13;
        if (proofVerified == false) return 2;&#13;
&#13;
        return 0;&#13;
    }&#13;
&#13;
    function matchBytes32Prefix(bytes32 content, bytes prefix, uint n_random_bytes) internal pure returns (bool){&#13;
        bool match_ = true;&#13;
&#13;
        require(prefix.length == n_random_bytes);&#13;
&#13;
        for (uint256 i=0; i&lt; n_random_bytes; i++) {&#13;
            if (content[i] != prefix[i]) match_ = false;&#13;
        }&#13;
&#13;
        return match_;&#13;
    }&#13;
&#13;
    function oraclize_randomDS_proofVerify__main(bytes proof, bytes32 queryId, bytes result, string context_name) internal returns (bool){&#13;
&#13;
        // Step 2: the unique keyhash has to match with the sha256 of (context name + queryId)&#13;
        uint ledgerProofLength = 3+65+(uint(proof[3+65+1])+2)+32;&#13;
        bytes memory keyhash = new bytes(32);&#13;
        copyBytes(proof, ledgerProofLength, 32, keyhash, 0);&#13;
        if (!(keccak256(keyhash) == keccak256(sha256(context_name, queryId)))) return false;&#13;
&#13;
        bytes memory sig1 = new bytes(uint(proof[ledgerProofLength+(32+8+1+32)+1])+2);&#13;
        copyBytes(proof, ledgerProofLength+(32+8+1+32), sig1.length, sig1, 0);&#13;
&#13;
        // Step 3: we assume sig1 is valid (it will be verified during step 5) and we verify if 'result' is the prefix of sha256(sig1)&#13;
        if (!matchBytes32Prefix(sha256(sig1), result, uint(proof[ledgerProofLength+32+8]))) return false;&#13;
&#13;
        // Step 4: commitment match verification, keccak256(delay, nbytes, unonce, sessionKeyHash) == commitment in storage.&#13;
        // This is to verify that the computed args match with the ones specified in the query.&#13;
        bytes memory commitmentSlice1 = new bytes(8+1+32);&#13;
        copyBytes(proof, ledgerProofLength+32, 8+1+32, commitmentSlice1, 0);&#13;
&#13;
        bytes memory sessionPubkey = new bytes(64);&#13;
        uint sig2offset = ledgerProofLength+32+(8+1+32)+sig1.length+65;&#13;
        copyBytes(proof, sig2offset-64, 64, sessionPubkey, 0);&#13;
&#13;
        bytes32 sessionPubkeyHash = sha256(sessionPubkey);&#13;
        if (oraclize_randomDS_args[queryId] == keccak256(commitmentSlice1, sessionPubkeyHash)){ //unonce, nbytes and sessionKeyHash match&#13;
            delete oraclize_randomDS_args[queryId];&#13;
        } else return false;&#13;
&#13;
&#13;
        // Step 5: validity verification for sig1 (keyhash and args signed with the sessionKey)&#13;
        bytes memory tosign1 = new bytes(32+8+1+32);&#13;
        copyBytes(proof, ledgerProofLength, 32+8+1+32, tosign1, 0);&#13;
        if (!verifySig(sha256(tosign1), sig1, sessionPubkey)) return false;&#13;
&#13;
        // verify if sessionPubkeyHash was verified already, if not.. let's do it!&#13;
        if (oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash] == false){&#13;
            oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash] = oraclize_randomDS_proofVerify__sessionKeyValidity(proof, sig2offset);&#13;
        }&#13;
&#13;
        return oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash];&#13;
    }&#13;
&#13;
    // the following function has been written by Alex Beregszaszi (@axic), use it under the terms of the MIT license&#13;
    function copyBytes(bytes from, uint fromOffset, uint length, bytes to, uint toOffset) internal pure returns (bytes) {&#13;
        uint minLength = length + toOffset;&#13;
&#13;
        // Buffer too small&#13;
        require(to.length &gt;= minLength); // Should be a better way?&#13;
&#13;
        // NOTE: the offset 32 is added to skip the `size` field of both bytes variables&#13;
        uint i = 32 + fromOffset;&#13;
        uint j = 32 + toOffset;&#13;
&#13;
        while (i &lt; (32 + fromOffset + length)) {&#13;
            assembly {&#13;
                let tmp := mload(add(from, i))&#13;
                mstore(add(to, j), tmp)&#13;
            }&#13;
            i += 32;&#13;
            j += 32;&#13;
        }&#13;
&#13;
        return to;&#13;
    }&#13;
&#13;
    // the following function has been written by Alex Beregszaszi (@axic), use it under the terms of the MIT license&#13;
    // Duplicate Solidity's ecrecover, but catching the CALL return value&#13;
    function safer_ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal returns (bool, address) {&#13;
        // We do our own memory management here. Solidity uses memory offset&#13;
        // 0x40 to store the current end of memory. We write past it (as&#13;
        // writes are memory extensions), but don't update the offset so&#13;
        // Solidity will reuse it. The memory used here is only needed for&#13;
        // this context.&#13;
&#13;
        // FIXME: inline assembly can't access return values&#13;
        bool ret;&#13;
        address addr;&#13;
&#13;
        assembly {&#13;
            let size := mload(0x40)&#13;
            mstore(size, hash)&#13;
            mstore(add(size, 32), v)&#13;
            mstore(add(size, 64), r)&#13;
            mstore(add(size, 96), s)&#13;
&#13;
            // NOTE: we can reuse the request memory because we deal with&#13;
            //       the return code&#13;
            ret := call(3000, 1, 0, size, 128, size, 32)&#13;
            addr := mload(size)&#13;
        }&#13;
&#13;
        return (ret, addr);&#13;
    }&#13;
&#13;
    // the following function has been written by Alex Beregszaszi (@axic), use it under the terms of the MIT license&#13;
    function ecrecovery(bytes32 hash, bytes sig) internal returns (bool, address) {&#13;
        bytes32 r;&#13;
        bytes32 s;&#13;
        uint8 v;&#13;
&#13;
        if (sig.length != 65)&#13;
          return (false, 0);&#13;
&#13;
        // The signature format is a compact form of:&#13;
        //   {bytes32 r}{bytes32 s}{uint8 v}&#13;
        // Compact means, uint8 is not padded to 32 bytes.&#13;
        assembly {&#13;
            r := mload(add(sig, 32))&#13;
            s := mload(add(sig, 64))&#13;
&#13;
            // Here we are loading the last 32 bytes. We exploit the fact that&#13;
            // 'mload' will pad with zeroes if we overread.&#13;
            // There is no 'mload8' to do this, but that would be nicer.&#13;
            v := byte(0, mload(add(sig, 96)))&#13;
&#13;
            // Alternative solution:&#13;
            // 'byte' is not working due to the Solidity parser, so lets&#13;
            // use the second best option, 'and'&#13;
            // v := and(mload(add(sig, 65)), 255)&#13;
        }&#13;
&#13;
        // albeit non-transactional signatures are not specified by the YP, one would expect it&#13;
        // to match the YP range of [27, 28]&#13;
        //&#13;
        // geth uses [0, 1] and some clients have followed. This might change, see:&#13;
        //  https://github.com/ethereum/go-ethereum/issues/2053&#13;
        if (v &lt; 27)&#13;
          v += 27;&#13;
&#13;
        if (v != 27 &amp;&amp; v != 28)&#13;
            return (false, 0);&#13;
&#13;
        return safer_ecrecover(hash, v, r, s);&#13;
    }&#13;
&#13;
    function safeMemoryCleaner() internal pure {&#13;
        assembly {&#13;
            let fmem := mload(0x40)&#13;
            codecopy(fmem, codesize, sub(msize, fmem))&#13;
        }&#13;
    }&#13;
&#13;
}&#13;
contract safeApi{&#13;
    &#13;
   modifier safe(){&#13;
        address _addr = msg.sender;&#13;
        require (_addr == tx.origin,'Error Action!');&#13;
        uint256 _codeLength;&#13;
        assembly {_codeLength := extcodesize(_addr)}&#13;
        require(_codeLength == 0, "Sender not authorized!");&#13;
            _;&#13;
    }&#13;
&#13;
&#13;
    &#13;
 function toBytes(uint256 _num) internal returns (bytes _ret) {&#13;
   assembly {&#13;
        _ret := mload(0x10)&#13;
        mstore(_ret, 0x20)&#13;
        mstore(add(_ret, 0x20), _num)&#13;
    }&#13;
}&#13;
&#13;
function subStr(string _s, uint start, uint end) internal pure returns (string){&#13;
        bytes memory s = bytes(_s);&#13;
        string memory copy = new string(end - start);&#13;
//        string memory copy = new string(5);&#13;
          uint k = 0;&#13;
        for (uint i = start; i &lt; end; i++){ &#13;
            bytes(copy)[k++] = bytes(_s)[i];&#13;
        }&#13;
        return copy;&#13;
    }&#13;
     &#13;
&#13;
 function safePercent(uint256 a,uint256 b) &#13;
      internal&#13;
      constant&#13;
      returns(uint256)&#13;
      {&#13;
        assert(a&gt;0 &amp;&amp; a &lt;=100);&#13;
        return  div(mul(b,a),100);&#13;
      }&#13;
      &#13;
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
    uint256 c = a * b;&#13;
    assert(a == 0 || c / a == b);&#13;
    return c;&#13;
  }&#13;
 &#13;
  function div(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
    // assert(b &gt; 0); // Solidity automatically throws when dividing by 0â&#13;
    uint256 c = a / b;&#13;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold&#13;
    return c;&#13;
  }&#13;
 &#13;
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
    assert(b &lt;= a);&#13;
    return a - b;&#13;
  }&#13;
 &#13;
  function add(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
    uint256 c = a + b;&#13;
    assert(c &gt;= a);&#13;
    return c;&#13;
  }&#13;
&#13;
}&#13;
contract gameDicePk is safeApi,usingOraclize{&#13;
mapping(bytes32=&gt;uint256) private validQueryId;&#13;
    struct player&#13;
    {&#13;
        uint256 id;&#13;
        uint256 balance;//wei&#13;
        uint256 timeStamp;&#13;
        address addr;&#13;
    }&#13;
&#13;
    struct  gameConfig&#13;
    {&#13;
        uint256 buyDrawScale;&#13;
        uint256 minBetWei;&#13;
        uint256 maxBetWei;&#13;
        uint256 countdown;&#13;
        uint256 pushWei;&#13;
        uint8 cancelFeePct;&#13;
        uint8 winnerFeePct;&#13;
    }&#13;
&#13;
    struct  table&#13;
    {&#13;
        uint256 betAmount;&#13;
        uint256 endTime;&#13;
        uint8  openIndex;&#13;
        uint8  status;//1 has opened the table, 2 has started, 3 is waiting for the draw, 4 has been completed, 5 canceled&#13;
        uint8   diceA;&#13;
        uint8   diceB;&#13;
        mapping(uint8=&gt;uint256) position;&#13;
    }&#13;
   &#13;
   event Bet(&#13;
       address indexed _addr,&#13;
       uint256 _tableId,&#13;
       uint256 _amount, &#13;
       uint8 _position,&#13;
       uint8 indexed _status,&#13;
       uint8 _posStatus,&#13;
       uint256 _endTime&#13;
     );&#13;
&#13;
  event Cancel( uint256 indexed _tableId);&#13;
&#13;
  event Finish(&#13;
        uint256 _tableId,&#13;
        uint256 _amount,&#13;
        uint256 indexed pos1,&#13;
        uint256 indexed pos2,&#13;
        uint256 indexed pos3,&#13;
        uint8 _position,//Marked position is occupied 1 1-2, 2 2-3, 3 1-3, 4,123&#13;
        uint8 _diceA,&#13;
        uint8 _diceB&#13;
      );&#13;
&#13;
    mapping (uint256 =&gt; player) public player_;&#13;
    mapping (address =&gt; uint256) public playAddr_;&#13;
    mapping (uint256 =&gt; uint256) public playAff_;&#13;
    mapping(uint256 =&gt; table) private tables_;&#13;
     uint256[200] openTable_;//Maximum free table number 200&#13;
     gameConfig public gameConfig_;&#13;
     address public admin__;&#13;
     uint256 private autoPlayId_=123456;&#13;
     uint256 private autoTableId_=0;&#13;
     uint32 private  CUSTOM_GASLIMIT =150000;//Cost of payment calculation gas&#13;
    &#13;
     constructor() public {&#13;
            admin__ = msg.sender;&#13;
            uint256 gasPrice=10100000000;//10.1GWEI&#13;
            oraclize_setCustomGasPrice(gasPrice);//Sent to the draw absenteeism Gwei&#13;
            gameConfig_=gameConfig(&#13;
          3,//Buy a draw bid 1/3&#13;
          60000000000000000,//0.06 eth Minimum &#13;
          12000000000000000000,//12 eth Maximum&#13;
           300 seconds,//Delayed Draw 5 minutes&#13;
          gasPrice*CUSTOM_GASLIMIT,//Total cost of Mining to be paid&#13;
          3//Cancellation fees% - Partially used to pay the Mining fee&#13;
          ,6//Winner handling Fee% - Partially used to pay the Mining fee&#13;
         );&#13;
        getPlayId(admin__);&#13;
    }&#13;
 &#13;
&#13;
 function withdraw(uint256 pid) safe() external{&#13;
        require(playAddr_[msg.sender] == pid,'Error Action');&#13;
        require(player_[pid].addr == msg.sender,'Error Action');&#13;
        require(player_[pid].balance &gt;0,'Insufficient balance');&#13;
        uint256 balance =player_[pid].balance;&#13;
        player_[pid].balance=0;&#13;
        return player_[pid].addr.transfer(balance);&#13;
    }&#13;
    &#13;
    //Lottery callback&#13;
    function __callback(bytes32 myid, string result) public  {&#13;
            require (validQueryId[myid] &gt; 0,'Error!');&#13;
            uint256 _tableId=validQueryId[myid];&#13;
            delete validQueryId[myid];&#13;
            require(msg.sender == oraclize_cbAddress(),'Error 1');&#13;
            __lottery(_tableId,result);&#13;
    }&#13;
     &#13;
     &#13;
     //Lottery program core code   &#13;
      function __lottery(uint256 _tableId,string strNumber) private safe(){&#13;
                table storage _t=tables_[_tableId];&#13;
                require(_t.status==2 || _t.status==3,'Error 2');&#13;
                require(now &gt; _t.endTime,'Error3');&#13;
                uint256  diceA=parseInt(subStr(strNumber,0,1));&#13;
                require(diceA &gt;=1 &amp;&amp; diceA &lt;=6,'Error4');&#13;
                uint256  diceB=parseInt(subStr(strNumber,2,3));&#13;
                require(diceB &gt;=1 &amp;&amp; diceB &lt;=6,'Error5');&#13;
                _t.status=4;&#13;
                _t.diceA=uint8(diceA);&#13;
                _t.diceB=uint8(diceB);&#13;
               &#13;
                openTable_[_t.openIndex]=0;//Mark the table as free&#13;
              &#13;
            winnerTransfer(_tableId,_t);&#13;
            &#13;
            emit Finish(&#13;
            _tableId,_t.betAmount,&#13;
            tables_[_tableId].position[1],&#13;
            tables_[_tableId].position[2],&#13;
            tables_[_tableId].position[3],&#13;
            getPosStatus(_tableId),_t.diceA,_t.diceB&#13;
            );&#13;
      }&#13;
      &#13;
      //Transfer eth to the winner&#13;
      function winnerTransfer(uint256 _tableId,table storage _t) private{&#13;
          &#13;
            uint8 winPos=0;&#13;
              //Verification winner&#13;
              if(_t.diceA&gt;_t.diceB){&#13;
                  winPos=1;&#13;
              }else if(_t.diceB&gt;_t.diceA){&#13;
                  winPos=2;&#13;
              }else{&#13;
                  winPos=3;&#13;
              }&#13;
              &#13;
              //The total prize ETH &#13;
              uint256 _balance=0;&#13;
                &#13;
              if(_t.position[1]&gt;0){&#13;
                  _balance=_t.betAmount;&#13;
              }&#13;
              if(_t.position[2]&gt;0){&#13;
                   _balance=add(_balance,_t.betAmount);&#13;
              }&#13;
              if(_t.position[3]&gt;0){&#13;
                     _balance=add(_balance,div(_t.betAmount,gameConfig_.buyDrawScale));&#13;
              }&#13;
              //winner player&#13;
              uint256 _winPid=_t.position[winPos];&#13;
              uint256 _systemFee=0;&#13;
         &#13;
              //Give the winner ETH&#13;
              if(_winPid&gt;0){&#13;
               _systemFee=safePercent(gameConfig_.winnerFeePct,_balance);&#13;
               player_[_winPid].balance=add(player_[_winPid].balance,sub(_balance,_systemFee));&#13;
              }else{&#13;
                //No winners, return ETH&#13;
                 uint256 _fee=0;&#13;
              if(_t.position[1]&gt;0){&#13;
                 uint256 _pos1Pid=_t.position[1];&#13;
                _fee=safePercent(gameConfig_.cancelFeePct,_t.betAmount);&#13;
                 _systemFee=_fee;&#13;
                 player_[_pos1Pid].balance=add(player_[_pos1Pid].balance,sub(_t.betAmount,_fee));&#13;
              }&#13;
              if(_t.position[2]&gt;0){&#13;
                 uint256 _pos2Pid=_t.position[2];&#13;
                 _fee=safePercent(gameConfig_.cancelFeePct,_t.betAmount);&#13;
                 _systemFee=add(_systemFee,_fee);&#13;
                 player_[_pos2Pid].balance=add(player_[_pos2Pid].balance,sub(_t.betAmount,_fee));&#13;
              }&#13;
              &#13;
              if(_t.position[3]&gt;0){&#13;
                 uint256 _pos3Pid=_t.position[3];&#13;
                 uint256 _pos3Amount=div(_t.betAmount,gameConfig_.buyDrawScale);&#13;
                 _fee=safePercent(gameConfig_.cancelFeePct,_pos3Amount);&#13;
                 _systemFee=add(_systemFee,_fee);&#13;
                 player_[_pos3Pid].balance=add(player_[_pos3Pid].balance,sub(_pos3Amount,_fee));&#13;
              }&#13;
           }&#13;
              uint256 _adminId=playAddr_[admin__];&#13;
              _systemFee=sub(_systemFee,gameConfig_.pushWei);//The admin bears the Fees of the mining&#13;
              player_[_adminId].balance= add(player_[_adminId].balance,_systemFee);&#13;
      }&#13;
      &#13;
      //Marked position is occupied&#13;
      function getPosStatus(uint256 _tableId) private view returns(uint8){&#13;
           table storage  _t=tables_[_tableId];&#13;
            if(_t.status==1)&#13;
                    return 0;&#13;
                uint8 _posStatus=3;&#13;
                // 1 1-2, 2 2-3, 3 1-3, 4 123&#13;
                if(_t.position[1]&gt;0 &amp;&amp; _t.position[2]&gt;0 &amp;&amp; _t.position[3]&gt;0){&#13;
                    _posStatus=4;&#13;
                }else if(_t.position[1]&gt;0 &amp;&amp; _t.position[2]&gt;0){&#13;
                      _posStatus=1;&#13;
                }else if(_t.position[2]&gt;0 &amp;&amp; _t.position[3]&gt;0){&#13;
                       _posStatus=2;&#13;
                }&#13;
          return _posStatus;&#13;
      }&#13;
&#13;
    //Considering the failure of the draw HTTP request, there will be a table with no results to manually cancel the return to ETH&#13;
    function closeTable(uint256 _tableId) safe() external{&#13;
            require(msg.sender == admin__,'Error 1');&#13;
             table storage _t=tables_[_tableId];&#13;
             //Must have passed the draw time&#13;
             require(now &gt; _t.endTime,'Error 2');&#13;
             require(_t.status&gt;=1 &amp;&amp; _t.status &lt;=3,'Error 3');&#13;
          &#13;
                 _t.status=5;//Set to cancel&#13;
                openTable_[_t.openIndex]=0;&#13;
      &#13;
                uint256 _fee=0;&#13;
                uint256 _systemFee=0;&#13;
              if(_t.position[1]&gt;0){&#13;
                 uint256 _pos1Pid=_t.position[1];&#13;
                _fee=safePercent(gameConfig_.cancelFeePct,_t.betAmount);&#13;
                 _systemFee=_fee;&#13;
                 player_[_pos1Pid].balance=add(player_[_pos1Pid].balance,sub(_t.betAmount,_fee));&#13;
              }&#13;
           &#13;
              if(_t.position[2]&gt;0){&#13;
                 uint256 _pos2Pid=_t.position[2];&#13;
                 _fee=safePercent(gameConfig_.cancelFeePct,_t.betAmount);&#13;
                 _systemFee=add(_systemFee,_fee);&#13;
                 player_[_pos2Pid].balance=add(player_[_pos2Pid].balance,sub(_t.betAmount,_fee));&#13;
              }&#13;
              &#13;
              if(_t.position[3]&gt;0){&#13;
                 uint256 _pos3Pid=_t.position[3];&#13;
                 uint256 _pos3Amount=div(_t.betAmount,gameConfig_.buyDrawScale);&#13;
                 _fee=safePercent(gameConfig_.cancelFeePct,_pos3Amount);&#13;
                 _systemFee=add(_systemFee,_fee);&#13;
                 player_[_pos3Pid].balance=add(player_[_pos3Pid].balance,sub(_pos3Amount,_fee));&#13;
              }&#13;
              require(_systemFee&gt;=gameConfig_.pushWei,'Error 4');&#13;
              uint256 _adminId=playAddr_[admin__];&#13;
              _systemFee=sub(_systemFee,gameConfig_.pushWei);//The admin bears the lottery fee&#13;
              player_[_adminId].balance= add(player_[_adminId].balance,_systemFee);&#13;
              emit Cancel(_tableId);&#13;
    }&#13;
    &#13;
       function bet(uint256 _tableId,uint8 _position) safe() external payable{&#13;
        uint256 _value=msg.value;&#13;
        uint256 _valueTemp=_value;&#13;
        require(_position &gt;=1 &amp;&amp; _position&lt;=3,'Error1');   &#13;
        uint256 _tid=_tableId;&#13;
        table storage _t=tables_[_tid];&#13;
        uint256 _now=now;&#13;
        &#13;
        //If the location is already or has already won the prize or the number is full, reopen the table. &#13;
        // If there are already 2 people, judge whether the purchase time is exceeded.&#13;
         uint256 _pid= getPlayId(msg.sender);&#13;
        if(_tid==0 || _tableId&gt;autoTableId_ ||  _t.position[_position] &gt;0  || _t.status &gt;=3 || (_t.status==2 &amp;&amp; _now &gt; _t.endTime)){&#13;
            //The bid for a draw is 1/3;&#13;
            _valueTemp= _position==3?mul(_value,gameConfig_.buyDrawScale):_value;&#13;
            require(_valueTemp &gt;=gameConfig_.minBetWei &amp;&amp; &#13;
            _valueTemp&lt;=gameConfig_.maxBetWei,'The amount of bet is in the range of 0.06-12 ETH');   &#13;
            require(_valueTemp%gameConfig_.minBetWei==0,'The amount of bet is in the range of 0.06-12 ETH');&#13;
            autoTableId_++;&#13;
            _tid=autoTableId_;&#13;
            _t=tables_[_tid];&#13;
           &#13;
           //The first person to bet determines the ETH of the bet&#13;
           _t.betAmount=_valueTemp;&#13;
           uint8 openIndex= getOpenTableIndex();&#13;
           require(openIndex&lt;200,'Error 8');&#13;
           openTable_[openIndex]=_tid;&#13;
           _t.openIndex=openIndex;&#13;
            &#13;
       }else{&#13;
        //Only one bet is allowed per table per person&#13;
        require(_t.position[1]!=_pid &amp;&amp;  _t.position[2]!=_pid  &amp;&amp; _t.position[3]!=_pid,'Error7'); &#13;
              //Buy flat bid validation&#13;
              if(_position==3){&#13;
                require (_value == div(_t.betAmount,gameConfig_.buyDrawScale),'Error5');&#13;
              }else{&#13;
                //Buy a winning bid&#13;
                require (_value ==_t.betAmount,'Error6');&#13;
              }&#13;
       }&#13;
       _t.status++;&#13;
        //A 2-person game starts the countdown.&#13;
      if(_t.status==2){&#13;
         _t.endTime=add(_now,gameConfig_.countdown);&#13;
         &#13;
      //Verify that the balance is sufficient for the draw absenteeism lottery&#13;
      require(address(this).balance&gt;=gameConfig_.pushWei,'Oraclize query was NOT sent, please add some ETH to cover for the query fee');&#13;
      //Countdown Draw&#13;
      bytes32 queryId =&#13;
        oraclize_query(gameConfig_.countdown, "URL", &#13;
        "html(https://www.random.org/dice/?num=2).xpath(concat((//p/img[@alt&gt;0]/@alt)[1],'|',(//p/img[@alt&gt;0]/@alt)[last()]))",&#13;
        CUSTOM_GASLIMIT);&#13;
       validQueryId[queryId]=_tid;&#13;
     }&#13;
        _t.position[_position]=_pid;//Put the user on the seat&#13;
        emit Bet(msg.sender,_tid,_value,_position,_t.status,getPosStatus(_tid),_t.endTime);&#13;
}&#13;
    &#13;
    &#13;
    function getTableInfo(uint256 _tableId) view external  returns(&#13;
        uint256,uint256,uint256,uint256,uint8,uint8,uint8,uint256&#13;
        ){&#13;
         table storage _t=tables_[_tableId];&#13;
          return (&#13;
             _t.betAmount,&#13;
           _t.position[1],&#13;
           _t.position[2],&#13;
           _t.position[3],&#13;
            _t.status,&#13;
            _t.diceA,&#13;
            _t.diceB,&#13;
           _t.endTime&#13;
         );&#13;
    }&#13;
    &#13;
&#13;
  function getOpenTableIndex() view private returns(uint8){&#13;
       for(uint8 i=0;i&lt;openTable_.length;i++){&#13;
           if(openTable_[i]==0)&#13;
            return i;&#13;
       }&#13;
       return 201;&#13;
   }&#13;
   &#13;
   //Get a list of available tables&#13;
    function getOpenTableList() external view  returns(uint256[200]){&#13;
       return openTable_;&#13;
   }&#13;
     //2020.01.01 Close Game Used to update the game&#13;
   function closeGame() external safe() {&#13;
        uint256 closeTime=1577808000;&#13;
        require(now &gt; closeTime,'Time has not arrived');&#13;
        require(msg.sender == admin__,'Error');&#13;
        selfdestruct(admin__);&#13;
    }&#13;
   &#13;
    function getPlayId(address addr) private returns(uint256){&#13;
        require (address(0)!=addr,'Error Addr');&#13;
        if(playAddr_[addr] &gt;0){&#13;
         return playAddr_[addr];&#13;
        }&#13;
              autoPlayId_++;&#13;
              playAddr_[addr]=autoPlayId_;&#13;
              player memory _p;&#13;
              _p.id=autoPlayId_;&#13;
              _p.addr=addr;&#13;
              _p.timeStamp=now;&#13;
              player_[autoPlayId_]=_p;&#13;
              return autoPlayId_;&#13;
   }&#13;
&#13;
}