pragma solidity ^0.4.18;

// Etheremon ERC721

// copyright <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="dcbfb3b2a8bdbfa89c99a8b4b9aeb9b1b3b2f2bfb3b1">[emailÂ protected]</a>&#13;
&#13;
contract SafeMath {&#13;
&#13;
    /* function assert(bool assertion) internal { */&#13;
    /*   if (!assertion) { */&#13;
    /*     throw; */&#13;
    /*   } */&#13;
    /* }      // assert no longer needed once solidity is on 0.4.10 */&#13;
&#13;
    function safeAdd(uint256 x, uint256 y) pure internal returns(uint256) {&#13;
      uint256 z = x + y;&#13;
      assert((z &gt;= x) &amp;&amp; (z &gt;= y));&#13;
      return z;&#13;
    }&#13;
&#13;
    function safeSubtract(uint256 x, uint256 y) pure internal returns(uint256) {&#13;
      assert(x &gt;= y);&#13;
      uint256 z = x - y;&#13;
      return z;&#13;
    }&#13;
&#13;
    function safeMult(uint256 x, uint256 y) pure internal returns(uint256) {&#13;
      uint256 z = x * y;&#13;
      assert((x == 0)||(z/x == y));&#13;
      return z;&#13;
    }&#13;
&#13;
}&#13;
&#13;
contract BasicAccessControl {&#13;
    address public owner;&#13;
    // address[] public moderators;&#13;
    uint16 public totalModerators = 0;&#13;
    mapping (address =&gt; bool) public moderators;&#13;
    bool public isMaintaining = true;&#13;
&#13;
    function BasicAccessControl() public {&#13;
        owner = msg.sender;&#13;
    }&#13;
&#13;
    modifier onlyOwner {&#13;
        require(msg.sender == owner);&#13;
        _;&#13;
    }&#13;
&#13;
    modifier onlyModerators() {&#13;
        require(moderators[msg.sender] == true);&#13;
        _;&#13;
    }&#13;
&#13;
    modifier isActive {&#13;
        require(!isMaintaining);&#13;
        _;&#13;
    }&#13;
&#13;
    function ChangeOwner(address _newOwner) onlyOwner public {&#13;
        if (_newOwner != address(0)) {&#13;
            owner = _newOwner;&#13;
        }&#13;
    }&#13;
&#13;
    function AddModerator(address _newModerator) onlyOwner public {&#13;
        if (moderators[_newModerator] == false) {&#13;
            moderators[_newModerator] = true;&#13;
            totalModerators += 1;&#13;
        }&#13;
    }&#13;
    &#13;
    function RemoveModerator(address _oldModerator) onlyOwner public {&#13;
        if (moderators[_oldModerator] == true) {&#13;
            moderators[_oldModerator] = false;&#13;
            totalModerators -= 1;&#13;
        }&#13;
    }&#13;
    &#13;
    function UpdateMaintaining(bool _isMaintaining) onlyOwner public {&#13;
        isMaintaining = _isMaintaining;&#13;
    }&#13;
}&#13;
&#13;
&#13;
contract EtheremonEnum {&#13;
&#13;
    enum ResultCode {&#13;
        SUCCESS,&#13;
        ERROR_CLASS_NOT_FOUND,&#13;
        ERROR_LOW_BALANCE,&#13;
        ERROR_SEND_FAIL,&#13;
        ERROR_NOT_TRAINER,&#13;
        ERROR_NOT_ENOUGH_MONEY,&#13;
        ERROR_INVALID_AMOUNT&#13;
    }&#13;
    &#13;
    enum ArrayType {&#13;
        CLASS_TYPE,&#13;
        STAT_STEP,&#13;
        STAT_START,&#13;
        STAT_BASE,&#13;
        OBJ_SKILL&#13;
    }&#13;
    &#13;
    enum PropertyType {&#13;
        ANCESTOR,&#13;
        XFACTOR&#13;
    }&#13;
}&#13;
&#13;
contract EtheremonDataBase is EtheremonEnum, BasicAccessControl, SafeMath {&#13;
    &#13;
    uint64 public totalMonster;&#13;
    uint32 public totalClass;&#13;
    &#13;
    // write&#13;
    function withdrawEther(address _sendTo, uint _amount) onlyOwner public returns(ResultCode);&#13;
    function addElementToArrayType(ArrayType _type, uint64 _id, uint8 _value) onlyModerators public returns(uint);&#13;
    function updateIndexOfArrayType(ArrayType _type, uint64 _id, uint _index, uint8 _value) onlyModerators public returns(uint);&#13;
    function setMonsterClass(uint32 _classId, uint256 _price, uint256 _returnPrice, bool _catchable) onlyModerators public returns(uint32);&#13;
    function addMonsterObj(uint32 _classId, address _trainer, string _name) onlyModerators public returns(uint64);&#13;
    function setMonsterObj(uint64 _objId, string _name, uint32 _exp, uint32 _createIndex, uint32 _lastClaimIndex) onlyModerators public;&#13;
    function increaseMonsterExp(uint64 _objId, uint32 amount) onlyModerators public;&#13;
    function decreaseMonsterExp(uint64 _objId, uint32 amount) onlyModerators public;&#13;
    function removeMonsterIdMapping(address _trainer, uint64 _monsterId) onlyModerators public;&#13;
    function addMonsterIdMapping(address _trainer, uint64 _monsterId) onlyModerators public;&#13;
    function clearMonsterReturnBalance(uint64 _monsterId) onlyModerators public returns(uint256 amount);&#13;
    function collectAllReturnBalance(address _trainer) onlyModerators public returns(uint256 amount);&#13;
    function transferMonster(address _from, address _to, uint64 _monsterId) onlyModerators public returns(ResultCode);&#13;
    function addExtraBalance(address _trainer, uint256 _amount) onlyModerators public returns(uint256);&#13;
    function deductExtraBalance(address _trainer, uint256 _amount) onlyModerators public returns(uint256);&#13;
    function setExtraBalance(address _trainer, uint256 _amount) onlyModerators public;&#13;
    &#13;
    // read&#13;
    function getSizeArrayType(ArrayType _type, uint64 _id) constant public returns(uint);&#13;
    function getElementInArrayType(ArrayType _type, uint64 _id, uint _index) constant public returns(uint8);&#13;
    function getMonsterClass(uint32 _classId) constant public returns(uint32 classId, uint256 price, uint256 returnPrice, uint32 total, bool catchable);&#13;
    function getMonsterObj(uint64 _objId) constant public returns(uint64 objId, uint32 classId, address trainer, uint32 exp, uint32 createIndex, uint32 lastClaimIndex, uint createTime);&#13;
    function getMonsterName(uint64 _objId) constant public returns(string name);&#13;
    function getExtraBalance(address _trainer) constant public returns(uint256);&#13;
    function getMonsterDexSize(address _trainer) constant public returns(uint);&#13;
    function getMonsterObjId(address _trainer, uint index) constant public returns(uint64);&#13;
    function getExpectedBalance(address _trainer) constant public returns(uint256);&#13;
    function getMonsterReturn(uint64 _objId) constant public returns(uint256 current, uint256 total);&#13;
}&#13;
&#13;
&#13;
interface EtheremonBattle {&#13;
    function isOnBattle(uint64 _objId) constant external returns(bool);&#13;
}&#13;
&#13;
interface EtheremonTradeInterface {&#13;
    function isOnTrading(uint64 _objId) constant external returns(bool);&#13;
}&#13;
&#13;
contract ERC721 {&#13;
    // ERC20 compatible functions&#13;
    // function name() constant returns (string name);&#13;
    // function symbol() constant returns (string symbol);&#13;
    function totalSupply() public constant returns (uint256 supply);&#13;
    function balanceOf(address _owner) public constant returns (uint256 balance);&#13;
    // Functions that define ownership&#13;
    function ownerOf(uint256 _tokenId) public constant returns (address owner);&#13;
    function approve(address _to, uint256 _tokenId) external;&#13;
    function takeOwnership(uint256 _tokenId) external;&#13;
    function transfer(address _to, uint256 _tokenId) external;&#13;
    function transferFrom(address _from, address _to, uint256 _tokenId) external;&#13;
    function tokenOfOwnerByIndex(address _owner, uint256 _index) public constant returns (uint tokenId);&#13;
    // Token metadata&#13;
    //function tokenMetadata(uint256 _tokenId) constant returns (string infoUrl);&#13;
&#13;
    // Events&#13;
    event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);&#13;
    event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);&#13;
}&#13;
&#13;
contract EtheremonAsset is BasicAccessControl, ERC721 {&#13;
    string public constant name = "EtheremonAsset";&#13;
    string public constant symbol = "EMONA";&#13;
    &#13;
    mapping (address =&gt; mapping (uint256 =&gt; address)) public allowed;&#13;
    &#13;
    // data contract&#13;
    address public dataContract;&#13;
    address public battleContract;&#13;
    address public tradeContract;&#13;
    &#13;
    // helper struct&#13;
    struct MonsterClassAcc {&#13;
        uint32 classId;&#13;
        uint256 price;&#13;
        uint256 returnPrice;&#13;
        uint32 total;&#13;
        bool catchable;&#13;
    }&#13;
&#13;
    struct MonsterObjAcc {&#13;
        uint64 monsterId;&#13;
        uint32 classId;&#13;
        address trainer;&#13;
        string name;&#13;
        uint32 exp;&#13;
        uint32 createIndex;&#13;
        uint32 lastClaimIndex;&#13;
        uint createTime;&#13;
    }&#13;
&#13;
    // modifier&#13;
    &#13;
    modifier requireDataContract {&#13;
        require(dataContract != address(0));&#13;
        _;&#13;
    }&#13;
    &#13;
    modifier requireBattleContract {&#13;
        require(battleContract != address(0));&#13;
        _;&#13;
    }&#13;
    &#13;
    modifier requireTradeContract {&#13;
        require(tradeContract != address(0));&#13;
        _;        &#13;
    }&#13;
    &#13;
    function EtheremonAsset(address _dataContract, address _battleContract, address _tradeContract) public {&#13;
        dataContract = _dataContract;&#13;
        battleContract = _battleContract;&#13;
        tradeContract = _tradeContract;&#13;
    }&#13;
&#13;
    function setContract(address _dataContract, address _battleContract, address _tradeContract) onlyModerators external {&#13;
        dataContract = _dataContract;&#13;
        battleContract = _battleContract;&#13;
        tradeContract = _tradeContract;&#13;
    }&#13;
    &#13;
    &#13;
    // public&#13;
    &#13;
    function totalSupply() public constant requireDataContract returns (uint256 supply){&#13;
        EtheremonDataBase data = EtheremonDataBase(dataContract);&#13;
        return data.totalMonster();&#13;
    }&#13;
    &#13;
    function balanceOf(address _owner) public constant requireDataContract returns (uint balance) {&#13;
        EtheremonDataBase data = EtheremonDataBase(dataContract);&#13;
        return data.getMonsterDexSize(_owner);&#13;
    }&#13;
    &#13;
    function ownerOf(uint256 _tokenId) public constant requireDataContract returns (address owner) {&#13;
        EtheremonDataBase data = EtheremonDataBase(dataContract);&#13;
        MonsterObjAcc memory obj;&#13;
        (obj.monsterId, obj.classId, obj.trainer, obj.exp, obj.createIndex, obj.lastClaimIndex, obj.createTime) = data.getMonsterObj(uint64(_tokenId));&#13;
        require(obj.monsterId == uint64(_tokenId));&#13;
        return obj.trainer;&#13;
    }&#13;
    &#13;
    function approve(address _to, uint256 _tokenId) isActive external {&#13;
        require(msg.sender == ownerOf(_tokenId));&#13;
        require(msg.sender != _to);&#13;
        allowed[msg.sender][_tokenId] = _to;&#13;
        Approval(msg.sender, _to, _tokenId);&#13;
    }&#13;
    &#13;
    function takeOwnership(uint256 _tokenId) requireDataContract requireBattleContract requireTradeContract isActive external {&#13;
        EtheremonDataBase data = EtheremonDataBase(dataContract);&#13;
        MonsterObjAcc memory obj;&#13;
        (obj.monsterId, obj.classId, obj.trainer, obj.exp, obj.createIndex, obj.lastClaimIndex, obj.createTime) = data.getMonsterObj(uint64(_tokenId));&#13;
        &#13;
        require(obj.monsterId == uint64(_tokenId));&#13;
        require(msg.sender != obj.trainer);&#13;
        &#13;
        require(allowed[obj.trainer][_tokenId] == msg.sender);&#13;
        &#13;
        // check battle &amp; trade contract &#13;
        EtheremonBattle battle = EtheremonBattle(battleContract);&#13;
        EtheremonTradeInterface trade = EtheremonTradeInterface(tradeContract);&#13;
        if (battle.isOnBattle(obj.monsterId) || trade.isOnTrading(obj.monsterId))&#13;
            revert();&#13;
        &#13;
        // remove allowed&#13;
        allowed[obj.trainer][_tokenId] = address(0);&#13;
&#13;
        // transfer owner&#13;
        data.removeMonsterIdMapping(obj.trainer, obj.monsterId);&#13;
        data.addMonsterIdMapping(msg.sender, obj.monsterId);&#13;
        &#13;
        Transfer(obj.trainer, msg.sender, _tokenId);&#13;
    }&#13;
    &#13;
    function transfer(address _to, uint256 _tokenId) requireDataContract isActive external {&#13;
        EtheremonDataBase data = EtheremonDataBase(dataContract);&#13;
        MonsterObjAcc memory obj;&#13;
        (obj.monsterId, obj.classId, obj.trainer, obj.exp, obj.createIndex, obj.lastClaimIndex, obj.createTime) = data.getMonsterObj(uint64(_tokenId));&#13;
        &#13;
        require(obj.monsterId == uint64(_tokenId));&#13;
        require(obj.trainer == msg.sender);&#13;
        require(msg.sender != _to);&#13;
        require(_to != address(0));&#13;
        &#13;
        // check battle &amp; trade contract &#13;
        EtheremonBattle battle = EtheremonBattle(battleContract);&#13;
        EtheremonTradeInterface trade = EtheremonTradeInterface(tradeContract);&#13;
        if (battle.isOnBattle(obj.monsterId) || trade.isOnTrading(obj.monsterId))&#13;
            revert();&#13;
        &#13;
        // remove allowed&#13;
        allowed[obj.trainer][_tokenId] = address(0);&#13;
        &#13;
        // transfer owner&#13;
        data.removeMonsterIdMapping(obj.trainer, obj.monsterId);&#13;
        data.addMonsterIdMapping(msg.sender, obj.monsterId);&#13;
        &#13;
        Transfer(obj.trainer, _to, _tokenId);&#13;
    }&#13;
    &#13;
    function transferFrom(address _from, address _to, uint256 _tokenId) requireDataContract requireBattleContract requireTradeContract external {&#13;
        EtheremonDataBase data = EtheremonDataBase(dataContract);&#13;
        MonsterObjAcc memory obj;&#13;
        (obj.monsterId, obj.classId, obj.trainer, obj.exp, obj.createIndex, obj.lastClaimIndex, obj.createTime) = data.getMonsterObj(uint64(_tokenId));&#13;
        &#13;
        require(obj.monsterId == uint64(_tokenId));&#13;
        require(obj.trainer == _from);&#13;
        require(_to != address(0));&#13;
        require(_to != _from);&#13;
        require(allowed[_from][_tokenId] == msg.sender);&#13;
    &#13;
        // check battle &amp; trade contract &#13;
        EtheremonBattle battle = EtheremonBattle(battleContract);&#13;
        EtheremonTradeInterface trade = EtheremonTradeInterface(tradeContract);&#13;
        if (battle.isOnBattle(obj.monsterId) || trade.isOnTrading(obj.monsterId))&#13;
            revert();&#13;
        &#13;
        // remove allowed&#13;
        allowed[_from][_tokenId] = address(0);&#13;
&#13;
        // transfer owner&#13;
        data.removeMonsterIdMapping(obj.trainer, obj.monsterId);&#13;
        data.addMonsterIdMapping(_to, obj.monsterId);&#13;
        &#13;
        Transfer(obj.trainer, _to, _tokenId);&#13;
    }&#13;
    &#13;
    function tokenOfOwnerByIndex(address _owner, uint256 _index) public constant requireDataContract returns (uint tokenId) {&#13;
        EtheremonDataBase data = EtheremonDataBase(dataContract);&#13;
        return data.getMonsterObjId(_owner, _index);&#13;
    }&#13;
}