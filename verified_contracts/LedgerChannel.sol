pragma solidity ^0.4.23;
// produced by the Solididy File Flattener (c) David Appleton 2018
// contact : <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="690d081f0c29080206040b08470a0604">[emailÂ protected]</a>&#13;
// released under Apache 2.0 licence&#13;
contract Token {&#13;
    /* This is a slight change to the ERC20 base standard.&#13;
    function totalSupply() constant returns (uint256 supply);&#13;
    is replaced with:&#13;
    uint256 public totalSupply;&#13;
    This automatically creates a getter function for the totalSupply.&#13;
    This is moved to the base contract since public getter functions are not&#13;
    currently recognised as an implementation of the matching abstract&#13;
    function by the compiler.&#13;
    */&#13;
    /// total amount of tokens&#13;
    uint256 public totalSupply;&#13;
&#13;
    /// @param _owner The address from which the balance will be retrieved&#13;
    /// @return The balance&#13;
    function balanceOf(address _owner) public constant returns (uint256 balance);&#13;
&#13;
    /// @notice send `_value` token to `_to` from `msg.sender`&#13;
    /// @param _to The address of the recipient&#13;
    /// @param _value The amount of token to be transferred&#13;
    /// @return Whether the transfer was successful or not&#13;
    function transfer(address _to, uint256 _value) public returns (bool success);&#13;
&#13;
    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`&#13;
    /// @param _from The address of the sender&#13;
    /// @param _to The address of the recipient&#13;
    /// @param _value The amount of token to be transferred&#13;
    /// @return Whether the transfer was successful or not&#13;
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);&#13;
&#13;
    /// @notice `msg.sender` approves `_spender` to spend `_value` tokens&#13;
    /// @param _spender The address of the account able to transfer the tokens&#13;
    /// @param _value The amount of tokens to be approved for transfer&#13;
    /// @return Whether the approval was successful or not&#13;
    function approve(address _spender, uint256 _value) public returns (bool success);&#13;
&#13;
    /// @param _owner The address of the account owning tokens&#13;
    /// @param _spender The address of the account able to transfer the tokens&#13;
    /// @return Amount of remaining tokens allowed to spent&#13;
    function allowance(address _owner, address _spender) public constant returns (uint256 remaining);&#13;
&#13;
    event Transfer(address indexed _from, address indexed _to, uint256 _value);&#13;
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);&#13;
}&#13;
&#13;
library ECTools {&#13;
&#13;
    // @dev Recovers the address which has signed a message&#13;
    // @thanks https://gist.github.com/axic/5b33912c6f61ae6fd96d6c4a47afde6d&#13;
    function recoverSigner(bytes32 _hashedMsg, string _sig) public pure returns (address) {&#13;
        require(_hashedMsg != 0x00);&#13;
&#13;
        // need this for test RPC&#13;
        bytes memory prefix = "\x19Ethereum Signed Message:\n32";&#13;
        bytes32 prefixedHash = keccak256(abi.encodePacked(prefix, _hashedMsg));&#13;
&#13;
        if (bytes(_sig).length != 132) {&#13;
            return 0x0;&#13;
        }&#13;
        bytes32 r;&#13;
        bytes32 s;&#13;
        uint8 v;&#13;
        bytes memory sig = hexstrToBytes(substring(_sig, 2, 132));&#13;
        assembly {&#13;
            r := mload(add(sig, 32))&#13;
            s := mload(add(sig, 64))&#13;
            v := byte(0, mload(add(sig, 96)))&#13;
        }&#13;
        if (v &lt; 27) {&#13;
            v += 27;&#13;
        }&#13;
        if (v &lt; 27 || v &gt; 28) {&#13;
            return 0x0;&#13;
        }&#13;
        return ecrecover(prefixedHash, v, r, s);&#13;
    }&#13;
&#13;
    // @dev Verifies if the message is signed by an address&#13;
    function isSignedBy(bytes32 _hashedMsg, string _sig, address _addr) public pure returns (bool) {&#13;
        require(_addr != 0x0);&#13;
&#13;
        return _addr == recoverSigner(_hashedMsg, _sig);&#13;
    }&#13;
&#13;
    // @dev Converts an hexstring to bytes&#13;
    function hexstrToBytes(string _hexstr) public pure returns (bytes) {&#13;
        uint len = bytes(_hexstr).length;&#13;
        require(len % 2 == 0);&#13;
&#13;
        bytes memory bstr = bytes(new string(len / 2));&#13;
        uint k = 0;&#13;
        string memory s;&#13;
        string memory r;&#13;
        for (uint i = 0; i &lt; len; i += 2) {&#13;
            s = substring(_hexstr, i, i + 1);&#13;
            r = substring(_hexstr, i + 1, i + 2);&#13;
            uint p = parseInt16Char(s) * 16 + parseInt16Char(r);&#13;
            bstr[k++] = uintToBytes32(p)[31];&#13;
        }&#13;
        return bstr;&#13;
    }&#13;
&#13;
    // @dev Parses a hexchar, like 'a', and returns its hex value, in this case 10&#13;
    function parseInt16Char(string _char) public pure returns (uint) {&#13;
        bytes memory bresult = bytes(_char);&#13;
        // bool decimals = false;&#13;
        if ((bresult[0] &gt;= 48) &amp;&amp; (bresult[0] &lt;= 57)) {&#13;
            return uint(bresult[0]) - 48;&#13;
        } else if ((bresult[0] &gt;= 65) &amp;&amp; (bresult[0] &lt;= 70)) {&#13;
            return uint(bresult[0]) - 55;&#13;
        } else if ((bresult[0] &gt;= 97) &amp;&amp; (bresult[0] &lt;= 102)) {&#13;
            return uint(bresult[0]) - 87;&#13;
        } else {&#13;
            revert();&#13;
        }&#13;
    }&#13;
&#13;
    // @dev Converts a uint to a bytes32&#13;
    // @thanks https://ethereum.stackexchange.com/questions/4170/how-to-convert-a-uint-to-bytes-in-solidity&#13;
    function uintToBytes32(uint _uint) public pure returns (bytes b) {&#13;
        b = new bytes(32);&#13;
        assembly {mstore(add(b, 32), _uint)}&#13;
    }&#13;
&#13;
    // @dev Hashes the signed message&#13;
    // @ref https://github.com/ethereum/go-ethereum/issues/3731#issuecomment-293866868&#13;
    function toEthereumSignedMessage(string _msg) public pure returns (bytes32) {&#13;
        uint len = bytes(_msg).length;&#13;
        require(len &gt; 0);&#13;
        bytes memory prefix = "\x19Ethereum Signed Message:\n";&#13;
        return keccak256(abi.encodePacked(prefix, uintToString(len), _msg));&#13;
    }&#13;
&#13;
    // @dev Converts a uint in a string&#13;
    function uintToString(uint _uint) public pure returns (string str) {&#13;
        uint len = 0;&#13;
        uint m = _uint + 0;&#13;
        while (m != 0) {&#13;
            len++;&#13;
            m /= 10;&#13;
        }&#13;
        bytes memory b = new bytes(len);&#13;
        uint i = len - 1;&#13;
        while (_uint != 0) {&#13;
            uint remainder = _uint % 10;&#13;
            _uint = _uint / 10;&#13;
            b[i--] = byte(48 + remainder);&#13;
        }&#13;
        str = string(b);&#13;
    }&#13;
&#13;
&#13;
    // @dev extract a substring&#13;
    // @thanks https://ethereum.stackexchange.com/questions/31457/substring-in-solidity&#13;
    function substring(string _str, uint _startIndex, uint _endIndex) public pure returns (string) {&#13;
        bytes memory strBytes = bytes(_str);&#13;
        require(_startIndex &lt;= _endIndex);&#13;
        require(_startIndex &gt;= 0);&#13;
        require(_endIndex &lt;= strBytes.length);&#13;
&#13;
        bytes memory result = new bytes(_endIndex - _startIndex);&#13;
        for (uint i = _startIndex; i &lt; _endIndex; i++) {&#13;
            result[i - _startIndex] = strBytes[i];&#13;
        }&#13;
        return string(result);&#13;
    }&#13;
}&#13;
contract StandardToken is Token {&#13;
&#13;
    function transfer(address _to, uint256 _value) public returns (bool success) {&#13;
        //Default assumes totalSupply can't be over max (2^256 - 1).&#13;
        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.&#13;
        //Replace the if with this one instead.&#13;
        //require(balances[msg.sender] &gt;= _value &amp;&amp; balances[_to] + _value &gt; balances[_to]);&#13;
        require(balances[msg.sender] &gt;= _value);&#13;
        balances[msg.sender] -= _value;&#13;
        balances[_to] += _value;&#13;
        emit Transfer(msg.sender, _to, _value);&#13;
        return true;&#13;
    }&#13;
&#13;
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {&#13;
        //same as above. Replace this line with the following if you want to protect against wrapping uints.&#13;
        //require(balances[_from] &gt;= _value &amp;&amp; allowed[_from][msg.sender] &gt;= _value &amp;&amp; balances[_to] + _value &gt; balances[_to]);&#13;
        require(balances[_from] &gt;= _value &amp;&amp; allowed[_from][msg.sender] &gt;= _value);&#13;
        balances[_to] += _value;&#13;
        balances[_from] -= _value;&#13;
        allowed[_from][msg.sender] -= _value;&#13;
        emit Transfer(_from, _to, _value);&#13;
        return true;&#13;
    }&#13;
&#13;
    function balanceOf(address _owner) public constant returns (uint256 balance) {&#13;
        return balances[_owner];&#13;
    }&#13;
&#13;
    function approve(address _spender, uint256 _value) public returns (bool success) {&#13;
        allowed[msg.sender][_spender] = _value;&#13;
        emit Approval(msg.sender, _spender, _value);&#13;
        return true;&#13;
    }&#13;
&#13;
    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {&#13;
      return allowed[_owner][_spender];&#13;
    }&#13;
&#13;
    mapping (address =&gt; uint256) balances;&#13;
    mapping (address =&gt; mapping (address =&gt; uint256)) allowed;&#13;
}&#13;
&#13;
contract HumanStandardToken is StandardToken {&#13;
&#13;
    /* Public variables of the token */&#13;
&#13;
    /*&#13;
    NOTE:&#13;
    The following variables are OPTIONAL vanities. One does not have to include them.&#13;
    They allow one to customise the token contract &amp; in no way influences the core functionality.&#13;
    Some wallets/interfaces might not even bother to look at this information.&#13;
    */&#13;
    string public name;                   //fancy name: eg Simon Bucks&#13;
    uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.&#13;
    string public symbol;                 //An identifier: eg SBX&#13;
    string public version = 'H0.1';       //human 0.1 standard. Just an arbitrary versioning scheme.&#13;
&#13;
    constructor(&#13;
        uint256 _initialAmount,&#13;
        string _tokenName,&#13;
        uint8 _decimalUnits,&#13;
        string _tokenSymbol&#13;
        ) public {&#13;
        balances[msg.sender] = _initialAmount;               // Give the creator all initial tokens&#13;
        totalSupply = _initialAmount;                        // Update total supply&#13;
        name = _tokenName;                                   // Set the name for display purposes&#13;
        decimals = _decimalUnits;                            // Amount of decimals for display purposes&#13;
        symbol = _tokenSymbol;                               // Set the symbol for display purposes&#13;
    }&#13;
&#13;
    /* Approves and then calls the receiving contract */&#13;
    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {&#13;
        allowed[msg.sender][_spender] = _value;&#13;
        emit Approval(msg.sender, _spender, _value);&#13;
&#13;
        //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.&#13;
        //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)&#13;
        //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.&#13;
        require(_spender.call(bytes4(bytes32(keccak256("receiveApproval(address,uint256,address,bytes)"))), msg.sender, _value, this, _extraData));&#13;
        return true;&#13;
    }&#13;
}&#13;
&#13;
contract LedgerChannel {&#13;
&#13;
    string public constant NAME = "Ledger Channel";&#13;
    string public constant VERSION = "0.0.1";&#13;
&#13;
    uint256 public numChannels = 0;&#13;
&#13;
    event DidLCOpen (&#13;
        bytes32 indexed channelId,&#13;
        address indexed partyA,&#13;
        address indexed partyI,&#13;
        uint256 ethBalanceA,&#13;
        address token,&#13;
        uint256 tokenBalanceA,&#13;
        uint256 LCopenTimeout&#13;
    );&#13;
&#13;
    event DidLCJoin (&#13;
        bytes32 indexed channelId,&#13;
        uint256 ethBalanceI,&#13;
        uint256 tokenBalanceI&#13;
    );&#13;
&#13;
    event DidLCDeposit (&#13;
        bytes32 indexed channelId,&#13;
        address indexed recipient,&#13;
        uint256 deposit,&#13;
        bool isToken&#13;
    );&#13;
&#13;
    event DidLCUpdateState (&#13;
        bytes32 indexed channelId, &#13;
        uint256 sequence, &#13;
        uint256 numOpenVc, &#13;
        uint256 ethBalanceA,&#13;
        uint256 tokenBalanceA,&#13;
        uint256 ethBalanceI,&#13;
        uint256 tokenBalanceI,&#13;
        bytes32 vcRoot,&#13;
        uint256 updateLCtimeout&#13;
    );&#13;
&#13;
    event DidLCClose (&#13;
        bytes32 indexed channelId,&#13;
        uint256 sequence,&#13;
        uint256 ethBalanceA,&#13;
        uint256 tokenBalanceA,&#13;
        uint256 ethBalanceI,&#13;
        uint256 tokenBalanceI&#13;
    );&#13;
&#13;
    event DidVCInit (&#13;
        bytes32 indexed lcId, &#13;
        bytes32 indexed vcId, &#13;
        bytes proof, &#13;
        uint256 sequence, &#13;
        address partyA, &#13;
        address partyB, &#13;
        uint256 balanceA, &#13;
        uint256 balanceB &#13;
    );&#13;
&#13;
    event DidVCSettle (&#13;
        bytes32 indexed lcId, &#13;
        bytes32 indexed vcId,&#13;
        uint256 updateSeq, &#13;
        uint256 updateBalA, &#13;
        uint256 updateBalB,&#13;
        address challenger,&#13;
        uint256 updateVCtimeout&#13;
    );&#13;
&#13;
    event DidVCClose(&#13;
        bytes32 indexed lcId, &#13;
        bytes32 indexed vcId, &#13;
        uint256 balanceA, &#13;
        uint256 balanceB&#13;
    );&#13;
&#13;
    struct Channel {&#13;
        //TODO: figure out if it's better just to split arrays by balances/deposits instead of eth/erc20&#13;
        address[2] partyAddresses; // 0: partyA 1: partyI&#13;
        uint256[4] ethBalances; // 0: balanceA 1:balanceI 2:depositedA 3:depositedI&#13;
        uint256[4] erc20Balances; // 0: balanceA 1:balanceI 2:depositedA 3:depositedI&#13;
        uint256[2] initialDeposit; // 0: eth 1: tokens&#13;
        uint256 sequence;&#13;
        uint256 confirmTime;&#13;
        bytes32 VCrootHash;&#13;
        uint256 LCopenTimeout;&#13;
        uint256 updateLCtimeout; // when update LC times out&#13;
        bool isOpen; // true when both parties have joined&#13;
        bool isUpdateLCSettling;&#13;
        uint256 numOpenVC;&#13;
        HumanStandardToken token;&#13;
    }&#13;
&#13;
    // virtual-channel state&#13;
    struct VirtualChannel {&#13;
        bool isClose;&#13;
        bool isInSettlementState;&#13;
        uint256 sequence;&#13;
        address challenger; // Initiator of challenge&#13;
        uint256 updateVCtimeout; // when update VC times out&#13;
        // channel state&#13;
        address partyA; // VC participant A&#13;
        address partyB; // VC participant B&#13;
        address partyI; // LC hub&#13;
        uint256[2] ethBalances;&#13;
        uint256[2] erc20Balances;&#13;
        uint256[2] bond;&#13;
        HumanStandardToken token;&#13;
    }&#13;
&#13;
    mapping(bytes32 =&gt; VirtualChannel) public virtualChannels;&#13;
    mapping(bytes32 =&gt; Channel) public Channels;&#13;
&#13;
    function createChannel(&#13;
        bytes32 _lcID,&#13;
        address _partyI,&#13;
        uint256 _confirmTime,&#13;
        address _token,&#13;
        uint256[2] _balances // [eth, token]&#13;
    ) &#13;
        public&#13;
        payable &#13;
    {&#13;
        require(Channels[_lcID].partyAddresses[0] == address(0), "Channel has already been created.");&#13;
        require(_partyI != 0x0, "No partyI address provided to LC creation");&#13;
        require(_balances[0] &gt;= 0 &amp;&amp; _balances[1] &gt;= 0, "Balances cannot be negative");&#13;
        // Set initial ledger channel state&#13;
        // Alice must execute this and we assume the initial state &#13;
        // to be signed from this requirement&#13;
        // Alternative is to check a sig as in joinChannel&#13;
        Channels[_lcID].partyAddresses[0] = msg.sender;&#13;
        Channels[_lcID].partyAddresses[1] = _partyI;&#13;
&#13;
        if(_balances[0] != 0) {&#13;
            require(msg.value == _balances[0], "Eth balance does not match sent value");&#13;
            Channels[_lcID].ethBalances[0] = msg.value;&#13;
        } &#13;
        if(_balances[1] != 0) {&#13;
            Channels[_lcID].token = HumanStandardToken(_token);&#13;
            require(Channels[_lcID].token.transferFrom(msg.sender, this, _balances[1]),"CreateChannel: token transfer failure");&#13;
            Channels[_lcID].erc20Balances[0] = _balances[1];&#13;
        }&#13;
&#13;
        Channels[_lcID].sequence = 0;&#13;
        Channels[_lcID].confirmTime = _confirmTime;&#13;
        // is close flag, lc state sequence, number open vc, vc root hash, partyA... &#13;
        //Channels[_lcID].stateHash = keccak256(uint256(0), uint256(0), uint256(0), bytes32(0x0), bytes32(msg.sender), bytes32(_partyI), balanceA, balanceI);&#13;
        Channels[_lcID].LCopenTimeout = now + _confirmTime;&#13;
        Channels[_lcID].initialDeposit = _balances;&#13;
&#13;
        emit DidLCOpen(_lcID, msg.sender, _partyI, _balances[0], _token, _balances[1], Channels[_lcID].LCopenTimeout);&#13;
    }&#13;
&#13;
    function LCOpenTimeout(bytes32 _lcID) public {&#13;
        require(msg.sender == Channels[_lcID].partyAddresses[0] &amp;&amp; Channels[_lcID].isOpen == false);&#13;
        require(now &gt; Channels[_lcID].LCopenTimeout);&#13;
&#13;
        if(Channels[_lcID].initialDeposit[0] != 0) {&#13;
            Channels[_lcID].partyAddresses[0].transfer(Channels[_lcID].ethBalances[0]);&#13;
        } &#13;
        if(Channels[_lcID].initialDeposit[1] != 0) {&#13;
            require(Channels[_lcID].token.transfer(Channels[_lcID].partyAddresses[0], Channels[_lcID].erc20Balances[0]),"CreateChannel: token transfer failure");&#13;
        }&#13;
&#13;
        emit DidLCClose(_lcID, 0, Channels[_lcID].ethBalances[0], Channels[_lcID].erc20Balances[0], 0, 0);&#13;
&#13;
        // only safe to delete since no action was taken on this channel&#13;
        delete Channels[_lcID];&#13;
    }&#13;
&#13;
    function joinChannel(bytes32 _lcID, uint256[2] _balances) public payable {&#13;
        // require the channel is not open yet&#13;
        require(Channels[_lcID].isOpen == false);&#13;
        require(msg.sender == Channels[_lcID].partyAddresses[1]);&#13;
&#13;
        if(_balances[0] != 0) {&#13;
            require(msg.value == _balances[0], "state balance does not match sent value");&#13;
            Channels[_lcID].ethBalances[1] = msg.value;&#13;
        } &#13;
        if(_balances[1] != 0) {&#13;
            require(Channels[_lcID].token.transferFrom(msg.sender, this, _balances[1]),"joinChannel: token transfer failure");&#13;
            Channels[_lcID].erc20Balances[1] = _balances[1];          &#13;
        }&#13;
&#13;
        Channels[_lcID].initialDeposit[0]+=_balances[0];&#13;
        Channels[_lcID].initialDeposit[1]+=_balances[1];&#13;
        // no longer allow joining functions to be called&#13;
        Channels[_lcID].isOpen = true;&#13;
        numChannels++;&#13;
&#13;
        emit DidLCJoin(_lcID, _balances[0], _balances[1]);&#13;
    }&#13;
&#13;
&#13;
    // additive updates of monetary state&#13;
    // TODO check this for attack vectors&#13;
    function deposit(bytes32 _lcID, address recipient, uint256 _balance, bool isToken) public payable {&#13;
        require(Channels[_lcID].isOpen == true, "Tried adding funds to a closed channel");&#13;
        require(recipient == Channels[_lcID].partyAddresses[0] || recipient == Channels[_lcID].partyAddresses[1]);&#13;
&#13;
        //if(Channels[_lcID].token)&#13;
&#13;
        if (Channels[_lcID].partyAddresses[0] == recipient) {&#13;
            if(isToken) {&#13;
                require(Channels[_lcID].token.transferFrom(msg.sender, this, _balance),"deposit: token transfer failure");&#13;
                Channels[_lcID].erc20Balances[2] += _balance;&#13;
            } else {&#13;
                require(msg.value == _balance, "state balance does not match sent value");&#13;
                Channels[_lcID].ethBalances[2] += msg.value;&#13;
            }&#13;
        }&#13;
&#13;
        if (Channels[_lcID].partyAddresses[1] == recipient) {&#13;
            if(isToken) {&#13;
                require(Channels[_lcID].token.transferFrom(msg.sender, this, _balance),"deposit: token transfer failure");&#13;
                Channels[_lcID].erc20Balances[3] += _balance;&#13;
            } else {&#13;
                require(msg.value == _balance, "state balance does not match sent value");&#13;
                Channels[_lcID].ethBalances[3] += msg.value; &#13;
            }&#13;
        }&#13;
        &#13;
        emit DidLCDeposit(_lcID, recipient, _balance, isToken);&#13;
    }&#13;
&#13;
    // TODO: Check there are no open virtual channels, the client should have cought this before signing a close LC state update&#13;
    function consensusCloseChannel(&#13;
        bytes32 _lcID, &#13;
        uint256 _sequence, &#13;
        uint256[4] _balances, // 0: ethBalanceA 1:ethBalanceI 2:tokenBalanceA 3:tokenBalanceI&#13;
        string _sigA, &#13;
        string _sigI&#13;
    ) &#13;
        public &#13;
    {&#13;
        // assume num open vc is 0 and root hash is 0x0&#13;
        //require(Channels[_lcID].sequence &lt; _sequence);&#13;
        require(Channels[_lcID].isOpen == true);&#13;
        uint256 totalEthDeposit = Channels[_lcID].initialDeposit[0] + Channels[_lcID].ethBalances[2] + Channels[_lcID].ethBalances[3];&#13;
        uint256 totalTokenDeposit = Channels[_lcID].initialDeposit[1] + Channels[_lcID].erc20Balances[2] + Channels[_lcID].erc20Balances[3];&#13;
        require(totalEthDeposit == _balances[0] + _balances[1]);&#13;
        require(totalTokenDeposit == _balances[2] + _balances[3]);&#13;
&#13;
        bytes32 _state = keccak256(&#13;
            abi.encodePacked(&#13;
                _lcID,&#13;
                true,&#13;
                _sequence,&#13;
                uint256(0),&#13;
                bytes32(0x0),&#13;
                Channels[_lcID].partyAddresses[0], &#13;
                Channels[_lcID].partyAddresses[1], &#13;
                _balances[0], &#13;
                _balances[1],&#13;
                _balances[2],&#13;
                _balances[3]&#13;
            )&#13;
        );&#13;
&#13;
        require(Channels[_lcID].partyAddresses[0] == ECTools.recoverSigner(_state, _sigA));&#13;
        require(Channels[_lcID].partyAddresses[1] == ECTools.recoverSigner(_state, _sigI));&#13;
&#13;
        Channels[_lcID].isOpen = false;&#13;
&#13;
        if(_balances[0] != 0 || _balances[1] != 0) {&#13;
            Channels[_lcID].partyAddresses[0].transfer(_balances[0]);&#13;
            Channels[_lcID].partyAddresses[1].transfer(_balances[1]);&#13;
        }&#13;
&#13;
        if(_balances[2] != 0 || _balances[3] != 0) {&#13;
            require(Channels[_lcID].token.transfer(Channels[_lcID].partyAddresses[0], _balances[2]),"happyCloseChannel: token transfer failure");&#13;
            require(Channels[_lcID].token.transfer(Channels[_lcID].partyAddresses[1], _balances[3]),"happyCloseChannel: token transfer failure");          &#13;
        }&#13;
&#13;
        numChannels--;&#13;
&#13;
        emit DidLCClose(_lcID, _sequence, _balances[0], _balances[1], _balances[2], _balances[3]);&#13;
    }&#13;
&#13;
    // Byzantine functions&#13;
&#13;
    function updateLCstate(&#13;
        bytes32 _lcID, &#13;
        uint256[6] updateParams, // [sequence, numOpenVc, ethbalanceA, ethbalanceI, tokenbalanceA, tokenbalanceI]&#13;
        bytes32 _VCroot, &#13;
        string _sigA, &#13;
        string _sigI&#13;
    ) &#13;
        public &#13;
    {&#13;
        Channel storage channel = Channels[_lcID];&#13;
        require(channel.isOpen);&#13;
        require(channel.sequence &lt; updateParams[0]); // do same as vc sequence check&#13;
        require(channel.ethBalances[0] + channel.ethBalances[1] &gt;= updateParams[2] + updateParams[3]);&#13;
        require(channel.erc20Balances[0] + channel.erc20Balances[1] &gt;= updateParams[4] + updateParams[5]);&#13;
&#13;
        if(channel.isUpdateLCSettling == true) { &#13;
            require(channel.updateLCtimeout &gt; now);&#13;
        }&#13;
      &#13;
        bytes32 _state = keccak256(&#13;
            abi.encodePacked(&#13;
                _lcID,&#13;
                false, &#13;
                updateParams[0], &#13;
                updateParams[1], &#13;
                _VCroot, &#13;
                channel.partyAddresses[0], &#13;
                channel.partyAddresses[1], &#13;
                updateParams[2], &#13;
                updateParams[3],&#13;
                updateParams[4], &#13;
                updateParams[5]&#13;
            )&#13;
        );&#13;
&#13;
        require(channel.partyAddresses[0] == ECTools.recoverSigner(_state, _sigA));&#13;
        require(channel.partyAddresses[1] == ECTools.recoverSigner(_state, _sigI));&#13;
&#13;
        // update LC state&#13;
        channel.sequence = updateParams[0];&#13;
        channel.numOpenVC = updateParams[1];&#13;
        channel.ethBalances[0] = updateParams[2];&#13;
        channel.ethBalances[1] = updateParams[3];&#13;
        channel.erc20Balances[0] = updateParams[4];&#13;
        channel.erc20Balances[1] = updateParams[5];&#13;
        channel.VCrootHash = _VCroot;&#13;
        channel.isUpdateLCSettling = true;&#13;
        channel.updateLCtimeout = now + channel.confirmTime;&#13;
&#13;
        // make settlement flag&#13;
&#13;
        emit DidLCUpdateState (&#13;
            _lcID, &#13;
            updateParams[0], &#13;
            updateParams[1], &#13;
            updateParams[2], &#13;
            updateParams[3],&#13;
            updateParams[4],&#13;
            updateParams[5], &#13;
            _VCroot,&#13;
            channel.updateLCtimeout&#13;
        );&#13;
    }&#13;
&#13;
    // supply initial state of VC to "prime" the force push game  &#13;
    function initVCstate(&#13;
        bytes32 _lcID, &#13;
        bytes32 _vcID, &#13;
        bytes _proof, &#13;
        address _partyA, &#13;
        address _partyB, &#13;
        uint256[2] _bond,&#13;
        uint256[4] _balances, // 0: ethBalanceA 1:ethBalanceI 2:tokenBalanceA 3:tokenBalanceI&#13;
        string sigA&#13;
    ) &#13;
        public &#13;
    {&#13;
        require(Channels[_lcID].isOpen, "LC is closed.");&#13;
        // sub-channel must be open&#13;
        require(!virtualChannels[_vcID].isClose, "VC is closed.");&#13;
        // Check time has passed on updateLCtimeout and has not passed the time to store a vc state&#13;
        require(Channels[_lcID].updateLCtimeout &lt; now, "LC timeout not over.");&#13;
        // prevent rentry of initializing vc state&#13;
        require(virtualChannels[_vcID].updateVCtimeout == 0);&#13;
        // partyB is now Ingrid&#13;
        bytes32 _initState = keccak256(&#13;
            abi.encodePacked(_vcID, uint256(0), _partyA, _partyB, _bond[0], _bond[1], _balances[0], _balances[1], _balances[2], _balances[3])&#13;
        );&#13;
&#13;
        // Make sure Alice has signed initial vc state (A/B in oldState)&#13;
        require(_partyA == ECTools.recoverSigner(_initState, sigA));&#13;
&#13;
        // Check the oldState is in the root hash&#13;
        require(_isContained(_initState, _proof, Channels[_lcID].VCrootHash) == true);&#13;
&#13;
        virtualChannels[_vcID].partyA = _partyA; // VC participant A&#13;
        virtualChannels[_vcID].partyB = _partyB; // VC participant B&#13;
        virtualChannels[_vcID].sequence = uint256(0);&#13;
        virtualChannels[_vcID].ethBalances[0] = _balances[0];&#13;
        virtualChannels[_vcID].ethBalances[1] = _balances[1];&#13;
        virtualChannels[_vcID].erc20Balances[0] = _balances[2];&#13;
        virtualChannels[_vcID].erc20Balances[1] = _balances[3];&#13;
        virtualChannels[_vcID].bond = _bond;&#13;
        virtualChannels[_vcID].updateVCtimeout = now + Channels[_lcID].confirmTime;&#13;
        virtualChannels[_vcID].isInSettlementState = true;&#13;
&#13;
        emit DidVCInit(_lcID, _vcID, _proof, uint256(0), _partyA, _partyB, _balances[0], _balances[1]);&#13;
    }&#13;
&#13;
    //TODO: verify state transition since the hub did not agree to this state&#13;
    // make sure the A/B balances are not beyond ingrids bonds  &#13;
    // Params: vc init state, vc final balance, vcID&#13;
    function settleVC(&#13;
        bytes32 _lcID, &#13;
        bytes32 _vcID, &#13;
        uint256 updateSeq, &#13;
        address _partyA, &#13;
        address _partyB,&#13;
        uint256[4] updateBal, // [ethupdateBalA, ethupdateBalB, tokenupdateBalA, tokenupdateBalB]&#13;
        string sigA&#13;
    ) &#13;
        public &#13;
    {&#13;
        require(Channels[_lcID].isOpen, "LC is closed.");&#13;
        // sub-channel must be open&#13;
        require(!virtualChannels[_vcID].isClose, "VC is closed.");&#13;
        require(virtualChannels[_vcID].sequence &lt; updateSeq, "VC sequence is higher than update sequence.");&#13;
        require(&#13;
            virtualChannels[_vcID].ethBalances[1] &lt; updateBal[1] &amp;&amp; virtualChannels[_vcID].erc20Balances[1] &lt; updateBal[3],&#13;
            "State updates may only increase recipient balance."&#13;
        );&#13;
        require(&#13;
            virtualChannels[_vcID].bond[0] == updateBal[0] + updateBal[1] &amp;&amp;&#13;
            virtualChannels[_vcID].bond[1] == updateBal[2] + updateBal[3], &#13;
            "Incorrect balances for bonded amount");&#13;
        // Check time has passed on updateLCtimeout and has not passed the time to store a vc state&#13;
        // virtualChannels[_vcID].updateVCtimeout should be 0 on uninitialized vc state, and this should&#13;
        // fail if initVC() isn't called first&#13;
        // require(Channels[_lcID].updateLCtimeout &lt; now &amp;&amp; now &lt; virtualChannels[_vcID].updateVCtimeout);&#13;
        require(Channels[_lcID].updateLCtimeout &lt; now); // for testing!&#13;
&#13;
        bytes32 _updateState = keccak256(&#13;
            abi.encodePacked(&#13;
                _vcID, &#13;
                updateSeq, &#13;
                _partyA, &#13;
                _partyB, &#13;
                virtualChannels[_vcID].bond[0], &#13;
                virtualChannels[_vcID].bond[1], &#13;
                updateBal[0], &#13;
                updateBal[1], &#13;
                updateBal[2], &#13;
                updateBal[3]&#13;
            )&#13;
        );&#13;
&#13;
        // Make sure Alice has signed a higher sequence new state&#13;
        require(virtualChannels[_vcID].partyA == ECTools.recoverSigner(_updateState, sigA));&#13;
&#13;
        // store VC data&#13;
        // we may want to record who is initiating on-chain settles&#13;
        virtualChannels[_vcID].challenger = msg.sender;&#13;
        virtualChannels[_vcID].sequence = updateSeq;&#13;
&#13;
        // channel state&#13;
        virtualChannels[_vcID].ethBalances[0] = updateBal[0];&#13;
        virtualChannels[_vcID].ethBalances[1] = updateBal[1];&#13;
        virtualChannels[_vcID].erc20Balances[0] = updateBal[2];&#13;
        virtualChannels[_vcID].erc20Balances[1] = updateBal[3];&#13;
&#13;
        virtualChannels[_vcID].updateVCtimeout = now + Channels[_lcID].confirmTime;&#13;
&#13;
        emit DidVCSettle(_lcID, _vcID, updateSeq, updateBal[0], updateBal[1], msg.sender, virtualChannels[_vcID].updateVCtimeout);&#13;
    }&#13;
&#13;
    function closeVirtualChannel(bytes32 _lcID, bytes32 _vcID) public {&#13;
        // require(updateLCtimeout &gt; now)&#13;
        require(Channels[_lcID].isOpen, "LC is closed.");&#13;
        require(virtualChannels[_vcID].isInSettlementState, "VC is not in settlement state.");&#13;
        require(virtualChannels[_vcID].updateVCtimeout &lt; now, "Update vc timeout has not elapsed.");&#13;
        require(!virtualChannels[_vcID].isClose, "VC is already closed");&#13;
        // reduce the number of open virtual channels stored on LC&#13;
        Channels[_lcID].numOpenVC--;&#13;
        // close vc flags&#13;
        virtualChannels[_vcID].isClose = true;&#13;
        // re-introduce the balances back into the LC state from the settled VC&#13;
        // decide if this lc is alice or bob in the vc&#13;
        if(virtualChannels[_vcID].partyA == Channels[_lcID].partyAddresses[0]) {&#13;
            Channels[_lcID].ethBalances[0] += virtualChannels[_vcID].ethBalances[0];&#13;
            Channels[_lcID].ethBalances[1] += virtualChannels[_vcID].ethBalances[1];&#13;
&#13;
            Channels[_lcID].erc20Balances[0] += virtualChannels[_vcID].erc20Balances[0];&#13;
            Channels[_lcID].erc20Balances[1] += virtualChannels[_vcID].erc20Balances[1];&#13;
        } else if (virtualChannels[_vcID].partyB == Channels[_lcID].partyAddresses[0]) {&#13;
            Channels[_lcID].ethBalances[0] += virtualChannels[_vcID].ethBalances[1];&#13;
            Channels[_lcID].ethBalances[1] += virtualChannels[_vcID].ethBalances[0];&#13;
&#13;
            Channels[_lcID].erc20Balances[0] += virtualChannels[_vcID].erc20Balances[1];&#13;
            Channels[_lcID].erc20Balances[1] += virtualChannels[_vcID].erc20Balances[0];&#13;
        }&#13;
&#13;
        emit DidVCClose(_lcID, _vcID, virtualChannels[_vcID].erc20Balances[0], virtualChannels[_vcID].erc20Balances[1]);&#13;
    }&#13;
&#13;
&#13;
    // todo: allow ethier lc.end-user to nullify the settled LC state and return to off-chain&#13;
    function byzantineCloseChannel(bytes32 _lcID) public {&#13;
        Channel storage channel = Channels[_lcID];&#13;
&#13;
        // check settlement flag&#13;
        require(channel.isOpen, "Channel is not open");&#13;
        require(channel.isUpdateLCSettling == true);&#13;
        require(channel.numOpenVC == 0);&#13;
        require(channel.updateLCtimeout &lt; now, "LC timeout over.");&#13;
&#13;
        // if off chain state update didnt reblance deposits, just return to deposit owner&#13;
        uint256 totalEthDeposit = channel.initialDeposit[0] + channel.ethBalances[2] + channel.ethBalances[3];&#13;
        uint256 totalTokenDeposit = channel.initialDeposit[1] + channel.erc20Balances[2] + channel.erc20Balances[3];&#13;
&#13;
        uint256 possibleTotalEthBeforeDeposit = channel.ethBalances[0] + channel.ethBalances[1]; &#13;
        uint256 possibleTotalTokenBeforeDeposit = channel.erc20Balances[0] + channel.erc20Balances[1];&#13;
&#13;
        if(possibleTotalEthBeforeDeposit &lt; totalEthDeposit) {&#13;
            channel.ethBalances[0]+=channel.ethBalances[2];&#13;
            channel.ethBalances[1]+=channel.ethBalances[3];&#13;
        } else {&#13;
            require(possibleTotalEthBeforeDeposit == totalEthDeposit);&#13;
        }&#13;
&#13;
        if(possibleTotalTokenBeforeDeposit &lt; totalTokenDeposit) {&#13;
            channel.erc20Balances[0]+=channel.erc20Balances[2];&#13;
            channel.erc20Balances[1]+=channel.erc20Balances[3];&#13;
        } else {&#13;
            require(possibleTotalTokenBeforeDeposit == totalTokenDeposit);&#13;
        }&#13;
&#13;
        // reentrancy&#13;
        uint256 ethbalanceA = channel.ethBalances[0];&#13;
        uint256 ethbalanceI = channel.ethBalances[1];&#13;
        uint256 tokenbalanceA = channel.erc20Balances[0];&#13;
        uint256 tokenbalanceI = channel.erc20Balances[1];&#13;
&#13;
        channel.ethBalances[0] = 0;&#13;
        channel.ethBalances[1] = 0;&#13;
        channel.erc20Balances[0] = 0;&#13;
        channel.erc20Balances[1] = 0;&#13;
&#13;
        if(ethbalanceA != 0 || ethbalanceI != 0) {&#13;
            channel.partyAddresses[0].transfer(ethbalanceA);&#13;
            channel.partyAddresses[1].transfer(ethbalanceI);&#13;
        }&#13;
&#13;
        if(tokenbalanceA != 0 || tokenbalanceI != 0) {&#13;
            require(&#13;
                channel.token.transfer(channel.partyAddresses[0], tokenbalanceA),&#13;
                "byzantineCloseChannel: token transfer failure"&#13;
            );&#13;
            require(&#13;
                channel.token.transfer(channel.partyAddresses[1], tokenbalanceI),&#13;
                "byzantineCloseChannel: token transfer failure"&#13;
            );          &#13;
        }&#13;
&#13;
        channel.isOpen = false;&#13;
        numChannels--;&#13;
&#13;
        emit DidLCClose(_lcID, channel.sequence, ethbalanceA, ethbalanceI, tokenbalanceA, tokenbalanceI);&#13;
    }&#13;
&#13;
    function _isContained(bytes32 _hash, bytes _proof, bytes32 _root) internal pure returns (bool) {&#13;
        bytes32 cursor = _hash;&#13;
        bytes32 proofElem;&#13;
&#13;
        for (uint256 i = 64; i &lt;= _proof.length; i += 32) {&#13;
            assembly { proofElem := mload(add(_proof, i)) }&#13;
&#13;
            if (cursor &lt; proofElem) {&#13;
                cursor = keccak256(abi.encodePacked(cursor, proofElem));&#13;
            } else {&#13;
                cursor = keccak256(abi.encodePacked(proofElem, cursor));&#13;
            }&#13;
        }&#13;
&#13;
        return cursor == _root;&#13;
    }&#13;
&#13;
    //Struct Getters&#13;
    function getChannel(bytes32 id) public view returns (&#13;
        address[2],&#13;
        uint256[4],&#13;
        uint256[4],&#13;
        uint256[2],&#13;
        uint256,&#13;
        uint256,&#13;
        bytes32,&#13;
        uint256,&#13;
        uint256,&#13;
        bool,&#13;
        bool,&#13;
        uint256&#13;
    ) {&#13;
        Channel memory channel = Channels[id];&#13;
        return (&#13;
            channel.partyAddresses,&#13;
            channel.ethBalances,&#13;
            channel.erc20Balances,&#13;
            channel.initialDeposit,&#13;
            channel.sequence,&#13;
            channel.confirmTime,&#13;
            channel.VCrootHash,&#13;
            channel.LCopenTimeout,&#13;
            channel.updateLCtimeout,&#13;
            channel.isOpen,&#13;
            channel.isUpdateLCSettling,&#13;
            channel.numOpenVC&#13;
        );&#13;
    }&#13;
&#13;
    function getVirtualChannel(bytes32 id) public view returns(&#13;
        bool,&#13;
        bool,&#13;
        uint256,&#13;
        address,&#13;
        uint256,&#13;
        address,&#13;
        address,&#13;
        address,&#13;
        uint256[2],&#13;
        uint256[2],&#13;
        uint256[2]&#13;
    ) {&#13;
        VirtualChannel memory virtualChannel = virtualChannels[id];&#13;
        return(&#13;
            virtualChannel.isClose,&#13;
            virtualChannel.isInSettlementState,&#13;
            virtualChannel.sequence,&#13;
            virtualChannel.challenger,&#13;
            virtualChannel.updateVCtimeout,&#13;
            virtualChannel.partyA,&#13;
            virtualChannel.partyB,&#13;
            virtualChannel.partyI,&#13;
            virtualChannel.ethBalances,&#13;
            virtualChannel.erc20Balances,&#13;
            virtualChannel.bond&#13;
        );&#13;
    }&#13;
}