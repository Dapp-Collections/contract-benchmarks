pragma solidity 0.4.19;

/**
 * @title SafeMath
 * @dev Math operations with safety checks that throw on error
 */
library SafeMath {

  /**
  * @dev Multiplies two numbers, throws on overflow.
  */
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }

  /**
  * @dev Integer division of two numbers, truncating the quotient.
  */
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    // assert(b > 0); // Solidity automatically throws when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return c;
  }

  /**
  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).
  */
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  /**
  * @dev Adds two numbers, throws on overflow.
  */
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }
}

/**
 * @title Helps contracts guard agains reentrancy attacks.
 * @author Remco Bloemen <<span class="__cf_email__" data-cfemail="f5879098969ab5c7">[email protected]</span>π.com&gt;&#13;
 * @notice If you mark a function `nonReentrant`, you should also&#13;
 * mark it `external`.&#13;
 */&#13;
contract ReentrancyGuard {&#13;
&#13;
  /**&#13;
   * @dev We use a single lock for the whole contract.&#13;
   */&#13;
  bool private reentrancy_lock = false;&#13;
&#13;
  /**&#13;
   * @dev Prevents a contract from calling itself, directly or indirectly.&#13;
   * @notice If you mark a function `nonReentrant`, you should also&#13;
   * mark it `external`. Calling one nonReentrant function from&#13;
   * another is not supported. Instead, you can implement a&#13;
   * `private` function doing the actual work, and a `external`&#13;
   * wrapper marked as `nonReentrant`.&#13;
   */&#13;
  modifier nonReentrant() {&#13;
    require(!reentrancy_lock);&#13;
    reentrancy_lock = true;&#13;
    _;&#13;
    reentrancy_lock = false;&#13;
  }&#13;
&#13;
}&#13;
&#13;
/**&#13;
 * @title Ownable&#13;
 * @dev The Ownable contract has an owner address, and provides basic authorization control&#13;
 * functions, this simplifies the implementation of "user permissions".&#13;
 */&#13;
contract Ownable {&#13;
  address public owner;&#13;
&#13;
  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);&#13;
&#13;
  /**&#13;
   * @dev The Ownable constructor sets the original `owner` of the contract to the sender&#13;
   * account.&#13;
   */&#13;
  function Ownable() public {&#13;
    owner = msg.sender;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Throws if called by any account other than the owner.&#13;
   */&#13;
  modifier onlyOwner() {&#13;
    require(msg.sender == owner);&#13;
    _;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Allows the current owner to transfer control of the contract to a newOwner.&#13;
   * @param newOwner The address to transfer ownership to.&#13;
   */&#13;
  function transferOwnership(address newOwner) public onlyOwner {&#13;
    require(newOwner != address(0));&#13;
    OwnershipTransferred(owner, newOwner);&#13;
    owner = newOwner;&#13;
  }&#13;
&#13;
}&#13;
&#13;
/**&#13;
 * EtherButton&#13;
 *&#13;
 * A game of financial hot potato. Players pay to click EtherButton.&#13;
 * Each player is given 105% of their payment by each subsequent player.&#13;
 * A seven hour timer resets after every click. The round advances once the timer reaches zero.&#13;
 * &#13;
 * Bonus:&#13;
 *  For every player payout, an additional 1% is stored as an end-of-round bonus.&#13;
 *  Each player is entitled to their bonus if they click EtherButton during the *next* round.&#13;
 *  0.500 ETH is given to the last player of every round and their bonus is unlocked immediately.&#13;
 *  Unclaimed bonuses are rolled into future rounds.&#13;
 **/&#13;
contract EtherButton is Ownable, ReentrancyGuard {&#13;
  // Use basic math operators which have integer overflow protection built into them.&#13;
  // Simplifies code greatly by reducing the need to constantly check inputs for overflow.&#13;
  using SafeMath for uint;&#13;
&#13;
  // Best practices say to prefix events with Log to avoid confusion.&#13;
  // https://consensys.github.io/smart-contract-best-practices/recommendations/#differentiate-functions-and-events&#13;
  event LogClick(&#13;
    uint _id,&#13;
    uint _price,&#13;
    uint _previousPrice,&#13;
    uint _endTime,&#13;
    uint _clickCount,&#13;
    uint _totalBonus,&#13;
    address _activePlayer,&#13;
    uint _activePlayerClickCount,&#13;
    uint _previousRoundTotalBonus&#13;
  );&#13;
  event LogClaimBonus(address _recipient, uint _bonus);&#13;
  event LogPlayerPayout(address _recipient, uint _amount);&#13;
  event LogSendPaymentFailure(address _recipient, uint _amount);&#13;
&#13;
  // Represent fractions as numerator/denominator because Solidity doesn't support decimals.&#13;
  // It's okay to use ".5 ether" because it converts to "500000000000000000 wei"&#13;
  uint public constant INITIAL_PRICE = .5 ether;&#13;
  uint public constant ROUND_DURATION = 7 hours;&#13;
  // 5% price increase is allocated to the player.&#13;
  uint private constant PLAYER_PROFIT_NUMERATOR = 5;&#13;
  uint private constant PLAYER_PROFIT_DENOMINATOR = 100;&#13;
  // 1% price increase is allocated to player bonuses.&#13;
  uint private constant BONUS_NUMERATOR = 1;&#13;
  uint private constant BONUS_DENOMINATOR = 100; &#13;
  // 2.5% price increase is allocated to the owner.&#13;
  uint private constant OWNER_FEE_NUMERATOR = 25;&#13;
  uint private constant OWNER_FEE_DENOMINATOR = 1000;&#13;
&#13;
  // EtherButton is comprised of many rounds. Each round contains&#13;
  // an isolated instance of game state.&#13;
  struct Round {&#13;
    uint id;&#13;
    uint price;&#13;
    uint previousPrice;&#13;
    uint endTime;&#13;
    uint clickCount;&#13;
    uint totalBonus;&#13;
    uint claimedBonus;&#13;
    address activePlayer;&#13;
    mapping (address =&gt; uint) playerClickCounts;&#13;
    mapping (address =&gt; bool) bonusClaimedList;&#13;
  }&#13;
&#13;
  // A list of all the rounds which have been played as well as&#13;
  // the id of the current (active) round.&#13;
  mapping (uint =&gt; Round) public Rounds;&#13;
  uint public RoundId;&#13;
&#13;
  /**&#13;
   * Create the contract with an initial 'Round 0'. This round has already expired which will cause the first&#13;
   * player interaction to start Round 1. This is simpler than introducing athe concept of a 'paused' round.&#13;
  **/&#13;
  function EtherButton() public {&#13;
    initializeRound();&#13;
    Rounds[RoundId].endTime = now.sub(1);&#13;
  }&#13;
&#13;
  /**&#13;
   * Performs a single 'click' of EtherButton.&#13;
   *&#13;
   * Advances the round if the previous round's endTime has passed. This needs to be done&#13;
   * just-in-time because code isn't able to execute on a timer - it needs funding.&#13;
   *&#13;
   * Refunds the player any extra money they may have sent. Pays the last player and the owner.&#13;
   * Marks the player as the active player so that they're next to be paid.&#13;
   *&#13;
   * Emits an event showing the current state of EtherButton and returns the state, too.&#13;
  **/&#13;
  function click() nonReentrant external payable {&#13;
    // Owner is not allowed to play.&#13;
    require(msg.sender != owner);&#13;
&#13;
    // There's no way to advance the round exactly at a specific time because the contract only runs&#13;
    // when value is sent to it. So, round advancement must be done just-in-time whenever a player pays to click.&#13;
    // Only advance the round when a player clicks because the next round's timer will begin immediately.&#13;
    if (getIsRoundOver(RoundId)) {&#13;
      advanceRound(); &#13;
    }&#13;
&#13;
    Round storage round = Rounds[RoundId];&#13;
&#13;
    // Safe-guard against spam clicks from a single player.&#13;
    require(msg.sender != round.activePlayer);&#13;
    // Safe-guard against underpayment.&#13;
    require(msg.value &gt;= round.price);&#13;
&#13;
    // Refund player extra value beyond price. If EtherButton is very popular then its price may&#13;
    // attempt to increase multiple times in a single block. In this situation, the first attempt&#13;
    // would be successful, but subsequent attempts would fail due to insufficient funding. &#13;
    // To combat this issue, a player may send more value than necessary to&#13;
    // increase the chance of the price being payable with the amount of value they sent.&#13;
    if (msg.value &gt; round.price) {&#13;
      sendPayment(msg.sender, msg.value.sub(round.price));&#13;
    }&#13;
&#13;
    // Pay the active player and owner for each click past the first.&#13;
    if (round.activePlayer != address(0)) {&#13;
      // Pay the player first because that seems respectful.&#13;
      // Log the player payouts to show on the website.&#13;
      uint playerPayout = getPlayerPayout(round.previousPrice);&#13;
      sendPayment(round.activePlayer, playerPayout);&#13;
      LogPlayerPayout(round.activePlayer, playerPayout);&#13;
&#13;
      // Pay the contract owner as fee for game creation. Thank you! &lt;3&#13;
      sendPayment(owner, getOwnerFee(round.previousPrice));&#13;
&#13;
      // Keep track of bonuses collected at same time as sending payouts to ensure financial consistency.&#13;
      round.totalBonus = round.totalBonus.add(getBonusFee(round.previousPrice));&#13;
    }&#13;
&#13;
    // Update round state to reflect the additional click&#13;
    round.activePlayer = msg.sender;&#13;
    round.playerClickCounts[msg.sender] = round.playerClickCounts[msg.sender].add(1);&#13;
    round.clickCount = round.clickCount.add(1);&#13;
    round.previousPrice = round.price;&#13;
    // Increment the price by 8.50%&#13;
    round.price = getNextPrice(round.price);&#13;
    // Reset the round timer&#13;
    round.endTime = now.add(ROUND_DURATION);&#13;
    &#13;
    // Log an event with relevant information from the round's state.&#13;
    LogClick(&#13;
      round.id,&#13;
      round.price,&#13;
      round.previousPrice,&#13;
      round.endTime,&#13;
      round.clickCount,&#13;
      round.totalBonus,&#13;
      msg.sender,&#13;
      round.playerClickCounts[msg.sender],&#13;
      Rounds[RoundId.sub(1)].totalBonus&#13;
    );&#13;
  }&#13;
&#13;
  /**&#13;
   * Provides bonus payments to players who wish to claim them.&#13;
   * Bonuses accrue over the course of a round for those playing in the round.&#13;
   * Bonuses may be claimed once the next round starts, but will remain locked until&#13;
   * players participate in that round. The last active player of the previous round&#13;
   * has their bonus unlocked immediately without need to play in the next round.&#13;
   **/&#13;
  function claimBonus() nonReentrant external {&#13;
    // NOTE: The only way to advance the round is to run the 'click' method. When a round is over, it will have expired,&#13;
    // but RoundId will not have (yet) incremented. So, claimBonus needs to check the previous round. This allows EtherButton&#13;
    // to never enter a 'paused' state, which is less code (aka more reliable) but it does have some edge cases.&#13;
    uint roundId = getIsRoundOver(RoundId) ? RoundId.add(1) : RoundId;&#13;
    uint previousRoundId = roundId.sub(1);&#13;
    bool isBonusClaimed = getIsBonusClaimed(previousRoundId, msg.sender);&#13;
&#13;
    // If player has already claimed their bonus exit early to keep code simple and cheap to run.&#13;
    if (isBonusClaimed) {&#13;
      return;&#13;
    }&#13;
&#13;
    // If a player can't claim their bonus because they haven't played during the current round&#13;
    // and they were not the last player in the previous round then exit as they're not authorized.&#13;
    bool isBonusUnlockExempt = getIsBonusUnlockExempt(previousRoundId, msg.sender);&#13;
    bool isBonusUnlocked = getPlayerClickCount(roundId, msg.sender) &gt; 0;&#13;
    if (!isBonusUnlockExempt &amp;&amp; !isBonusUnlocked) {&#13;
      return;&#13;
    }&#13;
&#13;
    // If player is owed money from participation in previous round - send it.&#13;
    Round storage previousRound = Rounds[previousRoundId];&#13;
    uint playerClickCount = previousRound.playerClickCounts[msg.sender];&#13;
    uint roundClickCount = previousRound.clickCount;&#13;
    // NOTE: Be sure to multiply first to avoid decimal precision math.&#13;
    uint bonus = previousRound.totalBonus.mul(playerClickCount).div(roundClickCount);&#13;
&#13;
    // If the current player is owed a refund from previous round fulfill that now.&#13;
    // This is better than forcing the player to make a separate requests for&#13;
    // bonuses and refund payouts.&#13;
    if (previousRound.activePlayer == msg.sender) {&#13;
      bonus = bonus.add(INITIAL_PRICE);&#13;
    }&#13;
&#13;
    previousRound.bonusClaimedList[msg.sender] = true;&#13;
    previousRound.claimedBonus = previousRound.claimedBonus.add(bonus);&#13;
    sendPayment(msg.sender, bonus);&#13;
&#13;
    // Let the EtherButton website know a bonus was claimed successfully so it may update.&#13;
    LogClaimBonus(msg.sender, bonus);&#13;
  }&#13;
&#13;
  /**&#13;
   * Returns true once the given player has claimed their bonus for the given round.&#13;
   * Bonuses are only able to be claimed once per round per player.&#13;
   **/&#13;
  function getIsBonusClaimed(uint roundId, address player) public view returns (bool) {&#13;
    return Rounds[roundId].bonusClaimedList[player];&#13;
  }&#13;
&#13;
  /**&#13;
   * Returns the number of times the given player has clicked EtherButton during the given round.&#13;
   **/&#13;
  function getPlayerClickCount(uint roundId, address player) public view returns (uint) {&#13;
    return Rounds[roundId].playerClickCounts[player];&#13;
  }&#13;
&#13;
  /**&#13;
   * Returns true if the given player does not need to be unlocked to claim their bonus.&#13;
   * This is true when they were the last player to click EtherButton in the previous round.&#13;
   * That player deserves freebies for losing. So, they get their bonus unlocked early.&#13;
   **/&#13;
  function getIsBonusUnlockExempt(uint roundId, address player) public view returns (bool) {&#13;
    return Rounds[roundId].activePlayer == player;&#13;
  }&#13;
&#13;
  /**&#13;
   * Returns true if enough time has elapsed since the active player clicked the&#13;
   * button to consider the given round complete.&#13;
   **/&#13;
  function getIsRoundOver(uint roundId) private view returns (bool) {&#13;
    return now &gt; Rounds[roundId].endTime;&#13;
  }&#13;
&#13;
  /**&#13;
   * Signal the completion of a round and the start of the next by moving RoundId forward one.&#13;
   * As clean-up before the round change occurs, join all unclaimed player bonuses together and move them&#13;
   * forward one round. Just-in-time initialize the next round's state once RoundId is pointing to it because&#13;
   * an unknown number of rounds may be played. So, it's impossible to initialize all rounds at contract creation.&#13;
   **/&#13;
  function advanceRound() private {&#13;
    if (RoundId &gt; 1) {&#13;
      // Take all of the previous rounds unclaimed bonuses and roll them forward.&#13;
      Round storage previousRound = Rounds[RoundId.sub(1)];      &#13;
      // If the active player of the previous round didn't claim their refund then they lose the ability to claim it.&#13;
      // Their refund is also rolled into the bonuses for the next round.&#13;
      uint remainingBonus = previousRound.totalBonus.add(INITIAL_PRICE).sub(previousRound.claimedBonus);&#13;
      Rounds[RoundId].totalBonus = Rounds[RoundId].totalBonus.add(remainingBonus);&#13;
    }&#13;
&#13;
    RoundId = RoundId.add(1);&#13;
    initializeRound();&#13;
  }&#13;
&#13;
  /**&#13;
   * Sets the current round's default values. Initialize the price to 0.500 ETH,&#13;
   * the endTime to 7 hours past the current time and sets the round id. The round is&#13;
   * also started as the endTime is now ticking down.&#13;
   **/&#13;
  function initializeRound() private {&#13;
    Rounds[RoundId].id = RoundId;&#13;
    Rounds[RoundId].endTime = block.timestamp.add(ROUND_DURATION);&#13;
    Rounds[RoundId].price = INITIAL_PRICE;&#13;
  }&#13;
&#13;
  /**&#13;
   * Sends an amount of Ether to the recipient. Returns true if it was successful.&#13;
   * Logs payment failures to provide documentation on attacks against the contract.&#13;
   **/&#13;
  function sendPayment(address recipient, uint amount) private returns (bool) {&#13;
    assert(recipient != address(0));&#13;
    assert(amount &gt; 0);&#13;
&#13;
    // It's considered good practice to require users to pull payments rather than pushing&#13;
    // payments to them. Since EtherButton pays the previous player immediately, it has to mitigate&#13;
    // a denial-of-service attack. A malicious contract might always reject money which is sent to it.&#13;
    // This contract could be used to disrupt EtherButton if an assumption is made that money will&#13;
    // always be sent successfully.&#13;
    // https://github.com/ConsenSys/smart-contract-best-practices/blob/master/docs/recommendations.md#favor-pull-over-push-for-external-calls&#13;
    // Intentionally not using recipient.transfer to prevent this DOS attack vector.&#13;
    bool result = recipient.send(amount);&#13;
&#13;
    // NOTE: Initially, this was written to allow users to reclaim funds on failure.&#13;
    // This was removed due to concerns of allowing attackers to retrieve their funds. It is&#13;
    // not possible for a regular wallet to reject a payment.&#13;
    if (!result) {&#13;
      // Log the failure so attempts to compromise the contract are documented.&#13;
      LogSendPaymentFailure(recipient, amount);&#13;
    }&#13;
&#13;
    return result;&#13;
  }&#13;
&#13;
  /**&#13;
    Returns the next price to click EtherButton. The returned value should be &#13;
    8.50% larger than the current price:&#13;
      - 5.00% is paid to the player.&#13;
      - 1.00% is paid as bonuses.&#13;
      - 2.50% is paid to the owner.&#13;
   **/&#13;
  function getNextPrice(uint price) private pure returns (uint) {&#13;
    uint playerFee = getPlayerFee(price);&#13;
    assert(playerFee &gt; 0);&#13;
&#13;
    uint bonusFee = getBonusFee(price);&#13;
    assert(bonusFee &gt; 0);&#13;
&#13;
    uint ownerFee = getOwnerFee(price);&#13;
    assert(ownerFee &gt; 0);&#13;
&#13;
    return price.add(playerFee).add(bonusFee).add(ownerFee);&#13;
  }&#13;
&#13;
  /**&#13;
   * Returns 1.00% of the given price. Be sure to multiply before dividing to avoid decimals.&#13;
   **/&#13;
  function getBonusFee(uint price) private pure returns (uint) {&#13;
    return price.mul(BONUS_NUMERATOR).div(BONUS_DENOMINATOR);&#13;
  }&#13;
&#13;
  /**&#13;
   * Returns 2.50% of the given price. Be sure to multiply before dividing to avoid decimals.&#13;
   **/&#13;
  function getOwnerFee(uint price) private pure returns (uint) {&#13;
    return price.mul(OWNER_FEE_NUMERATOR).div(OWNER_FEE_DENOMINATOR);&#13;
  }&#13;
&#13;
  /**&#13;
   * Returns 5.00% of the given price. Be sure to multiply before dividing to avoid decimals.&#13;
   **/&#13;
  function getPlayerFee(uint price) private pure returns (uint) {&#13;
    return price.mul(PLAYER_PROFIT_NUMERATOR).div(PLAYER_PROFIT_DENOMINATOR);&#13;
  }&#13;
&#13;
  /**&#13;
   * Returns the total amount of Ether the active player will receive. This is&#13;
   * 105.00% of their initial price paid.&#13;
   **/&#13;
  function getPlayerPayout(uint price) private pure returns (uint) {&#13;
    return price.add(getPlayerFee(price));&#13;
  }&#13;
}