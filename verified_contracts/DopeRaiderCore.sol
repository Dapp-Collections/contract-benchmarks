pragma solidity ^0.4.19;

// DopeRaider Narcos Contract
// by gasmasters.io
// contact: <span class="__cf_email__" data-cfemail="7c08191d113c18130c190e1d1518190e521f1311">[emailÂ protected]</span>&#13;
&#13;
contract DistrictsCoreInterface {&#13;
  // callable by other contracts to control economy&#13;
  function isDopeRaiderDistrictsCore() public pure returns (bool);&#13;
  function increaseDistrictWeed(uint256 _district, uint256 _quantity) public;&#13;
  function increaseDistrictCoke(uint256 _district, uint256 _quantity) public;&#13;
  function distributeRevenue(uint256 _district , uint8 _splitW, uint8 _splitC) public payable;&#13;
  function getNarcoLocation(uint256 _narcoId) public view returns (uint8 location);&#13;
}&#13;
&#13;
/// @title sale clock auction interface&#13;
contract SaleClockAuction {&#13;
  function isSaleClockAuction() public pure returns (bool);&#13;
  function createAuction(uint256 _tokenId,  uint256 _startingPrice,uint256 _endingPrice,uint256 _duration,address _seller)public;&#13;
  function withdrawBalance() public;&#13;
  function averageGen0SalePrice() public view returns (uint256);&#13;
&#13;
}&#13;
&#13;
&#13;
//// @title A facet of NarcoCore that manages special access privileges.&#13;
contract NarcoAccessControl {&#13;
    /// @dev Emited when contract is upgraded&#13;
    event ContractUpgrade(address newContract);&#13;
&#13;
    address public ceoAddress;&#13;
    address public cooAddress;&#13;
&#13;
    // @dev Keeps track whether the contract is paused. When that is true, most actions are blocked&#13;
    bool public paused = false;&#13;
&#13;
    modifier onlyCEO() {&#13;
        require(msg.sender == ceoAddress);&#13;
        _;&#13;
    }&#13;
&#13;
    modifier onlyCLevel() {&#13;
        require(&#13;
            msg.sender == cooAddress ||&#13;
            msg.sender == ceoAddress&#13;
        );&#13;
        _;&#13;
    }&#13;
&#13;
    function setCEO(address _newCEO) public onlyCEO {&#13;
        require(_newCEO != address(0));&#13;
&#13;
        ceoAddress = _newCEO;&#13;
    }&#13;
&#13;
    function setCOO(address _newCOO) public onlyCEO {&#13;
        require(_newCOO != address(0));&#13;
&#13;
        cooAddress = _newCOO;&#13;
    }&#13;
&#13;
    function withdrawBalance() external onlyCLevel {&#13;
        msg.sender.transfer(address(this).balance);&#13;
    }&#13;
&#13;
&#13;
    /*** Pausable functionality adapted from OpenZeppelin ***/&#13;
&#13;
    /// @dev Modifier to allow actions only when the contract IS NOT paused&#13;
    modifier whenNotPaused() {&#13;
        require(!paused);&#13;
        _;&#13;
    }&#13;
&#13;
    /// @dev Modifier to allow actions only when the contract IS paused&#13;
    modifier whenPaused {&#13;
        require(paused);&#13;
        _;&#13;
    }&#13;
&#13;
    function pause() public onlyCLevel whenNotPaused {&#13;
        paused = true;&#13;
    }&#13;
&#13;
    function unpause() public onlyCLevel whenPaused {&#13;
        // can't unpause if contract was upgraded&#13;
        paused = false;&#13;
    }&#13;
&#13;
    /// @dev The address of the calling contract&#13;
    address public districtContractAddress;&#13;
&#13;
    DistrictsCoreInterface public districtsCore;&#13;
&#13;
    function setDistrictAddress(address _address) public onlyCLevel {&#13;
        _setDistrictAddresss(_address);&#13;
    }&#13;
&#13;
    function _setDistrictAddresss(address _address) internal {&#13;
      DistrictsCoreInterface candidateContract = DistrictsCoreInterface(_address);&#13;
      require(candidateContract.isDopeRaiderDistrictsCore());&#13;
      districtsCore = candidateContract;&#13;
      districtContractAddress = _address;&#13;
    }&#13;
&#13;
&#13;
    modifier onlyDopeRaiderContract() {&#13;
        require(msg.sender == districtContractAddress);&#13;
        _;&#13;
    }&#13;
&#13;
&#13;
&#13;
&#13;
}&#13;
&#13;
/// @title Base contract for DopeRaider. Holds all common structs, events and base variables.&#13;
contract NarcoBase is NarcoAccessControl {&#13;
    /*** EVENTS ***/&#13;
&#13;
    event NarcoCreated(address indexed owner, uint256 narcoId, string genes);&#13;
&#13;
    /// @dev Transfer event as defined in current draft of ERC721. Emitted every time a narcos&#13;
    ///  ownership is assigned, including newly created narcos.&#13;
    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);&#13;
&#13;
&#13;
 /*** DATA TYPES ***/&#13;
&#13;
    // consumable indexes&#13;
    /*&#13;
    uint constant gasIndex = 0;&#13;
    uint constant seedsIndex = 1;&#13;
    uint constant chemicalsIndex = 2;&#13;
    uint constant ammoIndex = 3;&#13;
&#13;
    // skills indexes  - each skill can range from 1 - 10 in level&#13;
    uint constant speedIndex = 0; // speed of travel&#13;
    uint constant growIndex = 1; // speed/yield of grow&#13;
    uint constant refineIndex = 2; // refine coke&#13;
    uint constant attackIndex = 3; // attack&#13;
    uint constant defenseIndex = 4; // defense&#13;
    uint constant capacityIndex = 5; // how many items can be carried.&#13;
&#13;
    // stat indexes&#13;
    uint constant dealsCompleted = 0; // dealsCompleted&#13;
    uint constant weedGrowCompleted = 1; // weedGrowCompleted&#13;
    uint constant cokeRefineCompleted = 2; // refineCompleted&#13;
    uint constant attacksSucceeded = 3; // attacksSucceeded&#13;
    uint constant defendedSuccessfully = 4; defendedSuccessfully&#13;
    uint constant raidsCompleted = 5; // raidsCompleted&#13;
    uint constant escapeHijack = 6; // escapeHijack&#13;
    uint constant travelling = 7; // traveller&#13;
    uint constant recruited = 8; // recruitment&#13;
*/&#13;
&#13;
&#13;
    /// @dev The main Narco struct. Every narco in DopeRaider is represented by a copy&#13;
    ///  of this structure.&#13;
    struct Narco {&#13;
        // The Narco's genetic code is packed into these 256-bits.&#13;
        string genes; // represents his avatar&#13;
        string narcoName;&#13;
        // items making level&#13;
        uint16 [9] stats;&#13;
        // inventory totals&#13;
        uint16 weedTotal;&#13;
        uint16 cokeTotal;&#13;
        uint8 [4] consumables; // gas, seeds, chemicals, ammo&#13;
        uint16 [6] skills;   // travel time, grow, refine, attack, defend carry&#13;
        uint256 [6] cooldowns; // skill cooldown periods speed, grow, refine, attack, others if needed&#13;
        uint8 homeLocation;&#13;
    }&#13;
&#13;
    /*** STORAGE ***/&#13;
&#13;
    /// @dev An array containing the Narco struct for all Narcos in existence. The ID&#13;
    ///  of each narco is actually an index into this array.&#13;
    Narco[] narcos;&#13;
&#13;
    /// @dev A mapping from  narco IDs to the address that owns them. All  narcos have&#13;
    ///  some valid owner address, even gen0  narcos are created with a non-zero owner.&#13;
    mapping (uint256 =&gt; address) public narcoIndexToOwner;&#13;
&#13;
    // @dev A mapping from owner address to count of tokens that address owns.&#13;
    //  Used internally inside balanceOf() to resolve ownership count.&#13;
    mapping (address =&gt; uint256) ownershipTokenCount;&#13;
&#13;
    /// @dev A mapping from NarcoIDs to an address that has been approved to call&#13;
    ///  transferFrom(). A zero value means no approval is outstanding.&#13;
    mapping (uint256 =&gt; address) public  narcoIndexToApproved;&#13;
&#13;
    function _transfer(address _from, address _to, uint256 _tokenId) internal {&#13;
        // since the number of  narcos is capped to 2^32&#13;
        // there is no way to overflow this&#13;
        ownershipTokenCount[_to]++;&#13;
        narcoIndexToOwner[_tokenId] = _to;&#13;
&#13;
        if (_from != address(0)) {&#13;
            ownershipTokenCount[_from]--;&#13;
            delete narcoIndexToApproved[_tokenId];&#13;
        }&#13;
&#13;
        Transfer(_from, _to, _tokenId);&#13;
    }&#13;
&#13;
    // Will generate a new Narco and generate the event&#13;
    function _createNarco(&#13;
        string _genes,&#13;
        string _name,&#13;
        address _owner&#13;
    )&#13;
        internal&#13;
        returns (uint)&#13;
    {&#13;
&#13;
        uint16[6] memory randomskills= [&#13;
            uint16(random(9)+1),&#13;
            uint16(random(9)+1),&#13;
            uint16(random(9)+1),&#13;
            uint16(random(9)+1),&#13;
            uint16(random(9)+1),&#13;
            uint16(random(9)+31)&#13;
        ];&#13;
&#13;
        uint256[6] memory cools;&#13;
        uint16[9] memory nostats;&#13;
&#13;
        Narco memory _narco = Narco({&#13;
            genes: _genes,&#13;
            narcoName: _name,&#13;
            cooldowns: cools,&#13;
            stats: nostats,&#13;
            weedTotal: 0,&#13;
            cokeTotal: 0,&#13;
            consumables: [4,6,2,1],&#13;
            skills: randomskills,&#13;
            homeLocation: uint8(random(6)+1)&#13;
        });&#13;
&#13;
        uint256 newNarcoId = narcos.push(_narco) - 1;&#13;
        require(newNarcoId &lt;= 4294967295);&#13;
&#13;
        // raid character (token 0) live in 7 and have random special skills&#13;
        if (newNarcoId==0){&#13;
            narcos[0].homeLocation=7; // in vice island&#13;
            narcos[0].skills[4]=800; // defense&#13;
            narcos[0].skills[5]=65535; // carry&#13;
        }&#13;
&#13;
        NarcoCreated(_owner, newNarcoId, _narco.genes);&#13;
        _transfer(0, _owner, newNarcoId);&#13;
&#13;
&#13;
        return newNarcoId;&#13;
    }&#13;
&#13;
    function subToZero(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
        if (b &lt;= a){&#13;
          return a - b;&#13;
        }else{&#13;
          return 0;&#13;
        }&#13;
      }&#13;
&#13;
    function getRemainingCapacity(uint256 _narcoId) public view returns (uint16 capacity){&#13;
        uint256 usedCapacity = narcos[_narcoId].weedTotal + narcos[_narcoId].cokeTotal + narcos[_narcoId].consumables[0]+narcos[_narcoId].consumables[1]+narcos[_narcoId].consumables[2]+narcos[_narcoId].consumables[3];&#13;
        capacity = uint16(subToZero(uint256(narcos[_narcoId].skills[5]), usedCapacity));&#13;
    }&#13;
&#13;
    // respect it's called now&#13;
    function getLevel(uint256 _narcoId) public view returns (uint16 rank){&#13;
&#13;
    /*&#13;
      dealsCompleted = 0; // dealsCompleted&#13;
      weedGrowCompleted = 1; // weedGrowCompleted&#13;
      cokeRefineCompleted = 2; // refineCompleted&#13;
      attacksSucceeded = 3; // attacksSucceeded&#13;
      defendedSuccessfully = 4; defendedSuccessfully&#13;
      raidsCompleted = 5; // raidsCompleted&#13;
      escapeHijack = 6; // escapeHijack&#13;
      travel = 7; // travelling&#13;
    */&#13;
&#13;
        rank =  (narcos[_narcoId].stats[0]/12)+&#13;
                 (narcos[_narcoId].stats[1]/4)+&#13;
                 (narcos[_narcoId].stats[2]/4)+&#13;
                 (narcos[_narcoId].stats[3]/6)+&#13;
                 (narcos[_narcoId].stats[4]/6)+&#13;
                 (narcos[_narcoId].stats[5]/1)+&#13;
                 (narcos[_narcoId].stats[7]/12)&#13;
                 ;&#13;
    }&#13;
&#13;
    // pseudo random - but does that matter?&#13;
    uint64 _seed = 0;&#13;
    function random(uint64 upper) private returns (uint64 randomNumber) {&#13;
       _seed = uint64(keccak256(keccak256(block.blockhash(block.number-1), _seed), now));&#13;
       return _seed % upper;&#13;
     }&#13;
&#13;
&#13;
    // never call this from a contract&#13;
    /// @param _owner The owner whose tokens we are interested in.&#13;
    function narcosByOwner(address _owner) public view returns(uint256[] ownedNarcos) {&#13;
       uint256 tokenCount = ownershipTokenCount[_owner];&#13;
        uint256 totalNarcos = narcos.length - 1;&#13;
        uint256[] memory result = new uint256[](tokenCount);&#13;
        uint256 narcoId;&#13;
        uint256 resultIndex=0;&#13;
        for (narcoId = 0; narcoId &lt;= totalNarcos; narcoId++) {&#13;
          if (narcoIndexToOwner[narcoId] == _owner) {&#13;
            result[resultIndex] = narcoId;&#13;
            resultIndex++;&#13;
          }&#13;
        }&#13;
        return result;&#13;
    }&#13;
&#13;
&#13;
}&#13;
&#13;
&#13;
/// @title Interface for contracts conforming to ERC-721: Non-Fungible Tokens&#13;
contract ERC721 {&#13;
    function implementsERC721() public pure returns (bool);&#13;
    function totalSupply() public view returns (uint256 total);&#13;
    function balanceOf(address _owner) public view returns (uint256 balance);&#13;
    function ownerOf(uint256 _tokenId) public view returns (address owner);&#13;
    function approve(address _to, uint256 _tokenId) public;&#13;
    function transferFrom(address _from, address _to, uint256 _tokenId) public;&#13;
    function transfer(address _to, uint256 _tokenId) public;&#13;
    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);&#13;
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);&#13;
&#13;
    // Optional&#13;
    // function name() public view returns (string name);&#13;
    // function symbol() public view returns (string symbol);&#13;
    // function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256 tokenId);&#13;
    // function tokenMetadata(uint256 _tokenId) public view returns (string infoUrl);&#13;
}&#13;
&#13;
/// @title The facet of the DopeRaider core contract that manages ownership, ERC-721 (draft) compliant.&#13;
contract NarcoOwnership is NarcoBase, ERC721 {&#13;
    string public name = "DopeRaider";&#13;
    string public symbol = "DOPR";&#13;
&#13;
    function implementsERC721() public pure returns (bool)&#13;
    {&#13;
        return true;&#13;
    }&#13;
&#13;
    /// @dev Checks if a given address is the current owner of a particular narco.&#13;
    /// @param _claimant the address we are validating against.&#13;
    /// @param _tokenId narco id, only valid when &gt; 0&#13;
    function _owns(address _claimant, uint256 _tokenId) internal view returns (bool) {&#13;
        return narcoIndexToOwner[_tokenId] == _claimant;&#13;
    }&#13;
&#13;
    /// @dev Checks if a given address currently has transferApproval for a particular narco.&#13;
    /// @param _claimant the address we are confirming narco is approved for.&#13;
    /// @param _tokenId narco id, only valid when &gt; 0&#13;
    function _approvedFor(address _claimant, uint256 _tokenId) internal view returns (bool) {&#13;
        return narcoIndexToApproved[_tokenId] == _claimant;&#13;
    }&#13;
&#13;
    /// @dev Marks an address as being approved for transferFrom(), overwriting any previous&#13;
    ///  approval. Setting _approved to address(0) clears all transfer approval.&#13;
    ///  NOTE: _approve() does NOT send the Approval event.&#13;
    function _approve(uint256 _tokenId, address _approved) internal {&#13;
        narcoIndexToApproved[_tokenId] = _approved;&#13;
    }&#13;
&#13;
&#13;
    /// @notice Returns the number of narcos owned by a specific address.&#13;
    /// @param _owner The owner address to check.&#13;
    function balanceOf(address _owner) public view returns (uint256 count) {&#13;
        return ownershipTokenCount[_owner];&#13;
    }&#13;
&#13;
    /// @notice Transfers a narco to another address. If transferring to a smart&#13;
    ///  contract be VERY CAREFUL to ensure that it is aware of ERC-721 (or&#13;
    ///  DopeRaider specifically) or your narco may be lost forever. Seriously.&#13;
    /// @param _to The address of the recipient, can be a user or contract.&#13;
    /// @param _tokenId The ID of the narco to transfer.&#13;
    function transfer(&#13;
        address _to,&#13;
        uint256 _tokenId&#13;
    )&#13;
        public&#13;
&#13;
    {&#13;
        require(_to != address(0));&#13;
        require(_owns(msg.sender, _tokenId));&#13;
&#13;
        _transfer(msg.sender, _to, _tokenId);&#13;
    }&#13;
&#13;
    /// @notice Grant another address the right to transfer a specific narco via&#13;
    ///  transferFrom(). This is the preferred flow for transfering NFTs to contracts.&#13;
    /// @param _to The address to be granted transfer approval. Pass address(0) to&#13;
    ///  clear all approvals.&#13;
    /// @param _tokenId The ID of the narco that can be transferred if this call succeeds.&#13;
    function approve(&#13;
        address _to,&#13;
        uint256 _tokenId&#13;
    )&#13;
        public&#13;
&#13;
    {&#13;
        require(_owns(msg.sender, _tokenId));&#13;
&#13;
        _approve(_tokenId, _to);&#13;
&#13;
        Approval(msg.sender, _to, _tokenId);&#13;
    }&#13;
&#13;
    /// @notice Transfer a narco owned by another address, for which the calling address&#13;
    ///  has previously been granted transfer approval by the owner.&#13;
    /// @param _from The address that owns the narco to be transfered.&#13;
    /// @param _to The address that should take ownership of the narco. Can be any address,&#13;
    ///  including the caller.&#13;
    /// @param _tokenId The ID of the narco to be transferred.&#13;
    function transferFrom(&#13;
        address _from,&#13;
        address _to,&#13;
        uint256 _tokenId&#13;
    )&#13;
        public&#13;
&#13;
    {&#13;
        require(_approvedFor(msg.sender, _tokenId));&#13;
        require(_owns(_from, _tokenId));&#13;
        require(_to != address(0));&#13;
&#13;
        _transfer(_from, _to, _tokenId);&#13;
    }&#13;
&#13;
    function totalSupply() public view returns (uint) {&#13;
        return narcos.length - 1;&#13;
    }&#13;
&#13;
    function ownerOf(uint256 _tokenId)&#13;
        public&#13;
        view&#13;
        returns (address owner)&#13;
    {&#13;
        owner = narcoIndexToOwner[_tokenId];&#13;
&#13;
        require(owner != address(0));&#13;
    }&#13;
&#13;
&#13;
&#13;
}&#13;
&#13;
&#13;
// this helps with district functionality&#13;
// it gives the ability to an external contract to do the following:&#13;
// * update narcos stats&#13;
contract NarcoUpdates is NarcoOwnership {&#13;
&#13;
    function updateWeedTotal(uint256 _narcoId, bool _add, uint16 _total) public onlyDopeRaiderContract {&#13;
      if(_add==true){&#13;
        narcos[_narcoId].weedTotal+= _total;&#13;
      }else{&#13;
        narcos[_narcoId].weedTotal-= _total;&#13;
      }&#13;
    }&#13;
&#13;
    function updateCokeTotal(uint256 _narcoId, bool _add, uint16 _total) public onlyDopeRaiderContract {&#13;
       if(_add==true){&#13;
        narcos[_narcoId].cokeTotal+= _total;&#13;
      }else{&#13;
        narcos[_narcoId].cokeTotal-= _total;&#13;
      }&#13;
    }&#13;
&#13;
    function updateConsumable(uint256 _narcoId, uint256 _index, uint8 _new) public onlyDopeRaiderContract  {&#13;
      narcos[_narcoId].consumables[_index] = _new;&#13;
    }&#13;
&#13;
    function updateSkill(uint256 _narcoId, uint256 _index, uint16 _new) public onlyDopeRaiderContract  {&#13;
      narcos[_narcoId].skills[_index] = _new;&#13;
    }&#13;
&#13;
    function incrementStat(uint256 _narcoId , uint256 _index) public onlyDopeRaiderContract  {&#13;
      narcos[_narcoId].stats[_index]++;&#13;
    }&#13;
&#13;
    function setCooldown(uint256 _narcoId , uint256 _index , uint256 _new) public onlyDopeRaiderContract  {&#13;
      narcos[_narcoId].cooldowns[_index]=_new;&#13;
    }&#13;
&#13;
}&#13;
&#13;
/// @title Handles creating auctions for sale of narcos.&#13;
///  This wrapper of ReverseAuction exists only so that users can create&#13;
///  auctions with only one transaction.&#13;
contract NarcoAuction is NarcoUpdates {&#13;
    SaleClockAuction public saleAuction;&#13;
&#13;
    function setSaleAuctionAddress(address _address) public onlyCLevel {&#13;
        SaleClockAuction candidateContract = SaleClockAuction(_address);&#13;
        require(candidateContract.isSaleClockAuction());&#13;
        saleAuction = candidateContract;&#13;
    }&#13;
&#13;
    function createSaleAuction(&#13;
        uint256 _narcoId,&#13;
        uint256 _startingPrice,&#13;
        uint256 _endingPrice,&#13;
        uint256 _duration&#13;
    )&#13;
        public&#13;
        whenNotPaused&#13;
    {&#13;
        // Auction contract checks input sizes&#13;
        // If narco is already on any auction, this will throw&#13;
        // because it will be owned by the auction contract&#13;
        require(_owns(msg.sender, _narcoId));&#13;
        _approve(_narcoId, saleAuction);&#13;
        // Sale auction throws if inputs are invalid and clears&#13;
        // transfer approval after escrowing the narco.&#13;
        saleAuction.createAuction(&#13;
            _narcoId,&#13;
            _startingPrice,&#13;
            _endingPrice,&#13;
            _duration,&#13;
            msg.sender&#13;
        );&#13;
    }&#13;
&#13;
    /// @dev Transfers the balance of the sale auction contract&#13;
    /// to the DopeRaiderCore contract. We use two-step withdrawal to&#13;
    /// prevent two transfer calls in the auction bid function.&#13;
    function withdrawAuctionBalances() external onlyCLevel {&#13;
        saleAuction.withdrawBalance();&#13;
    }&#13;
}&#13;
&#13;
&#13;
/// @title all functions related to creating narcos&#13;
contract NarcoMinting is NarcoAuction {&#13;
&#13;
    // Limits the number of narcos the contract owner can ever create.&#13;
    uint256 public promoCreationLimit = 200;&#13;
    uint256 public gen0CreationLimit = 5000;&#13;
&#13;
    // Constants for gen0 auctions.&#13;
    uint256 public gen0StartingPrice = 1 ether;&#13;
    uint256 public gen0EndingPrice = 20 finney;&#13;
    uint256 public gen0AuctionDuration = 1 days;&#13;
&#13;
    // Counts the number of narcos the contract owner has created.&#13;
    uint256 public promoCreatedCount;&#13;
    uint256 public gen0CreatedCount;&#13;
&#13;
    /// @dev we can create promo narco, up to a limit&#13;
    function createPromoNarco(&#13;
        string _genes,&#13;
        string _name,&#13;
        address _owner&#13;
    ) public onlyCLevel {&#13;
        if (_owner == address(0)) {&#13;
             _owner = cooAddress;&#13;
        }&#13;
        require(promoCreatedCount &lt; promoCreationLimit);&#13;
        require(gen0CreatedCount &lt; gen0CreationLimit);&#13;
&#13;
        promoCreatedCount++;&#13;
        gen0CreatedCount++;&#13;
&#13;
        _createNarco(_genes, _name, _owner);&#13;
    }&#13;
&#13;
    /// @dev Creates a new gen0 narco with the given genes and&#13;
    ///  creates an auction for it.&#13;
    function createGen0Auction(&#13;
       string _genes,&#13;
        string _name&#13;
    ) public onlyCLevel {&#13;
        require(gen0CreatedCount &lt; gen0CreationLimit);&#13;
&#13;
        uint256 narcoId = _createNarco(_genes,_name,address(this));&#13;
&#13;
        _approve(narcoId, saleAuction);&#13;
&#13;
        saleAuction.createAuction(&#13;
            narcoId,&#13;
            _computeNextGen0Price(),&#13;
            gen0EndingPrice,&#13;
            gen0AuctionDuration,&#13;
            address(this)&#13;
        );&#13;
&#13;
        gen0CreatedCount++;&#13;
    }&#13;
&#13;
    /// @dev Computes the next gen0 auction starting price, given&#13;
    ///  the average of the past 4 prices + 50%.&#13;
    function _computeNextGen0Price() internal view returns (uint256) {&#13;
        uint256 avePrice = saleAuction.averageGen0SalePrice();&#13;
&#13;
        // sanity check to ensure we don't overflow arithmetic (this big number is 2^128-1).&#13;
        require(avePrice &lt; 340282366920938463463374607431768211455);&#13;
&#13;
        uint256 nextPrice = avePrice + (avePrice / 2);&#13;
&#13;
        // We never auction for less than starting price&#13;
        if (nextPrice &lt; gen0StartingPrice) {&#13;
            nextPrice = gen0StartingPrice;&#13;
        }&#13;
&#13;
        return nextPrice;&#13;
    }&#13;
}&#13;
&#13;
&#13;
/// @title DopeRaider: Collectible, narcos on the Ethereum blockchain.&#13;
/// @dev The main DopeRaider contract&#13;
contract DopeRaiderCore is NarcoMinting {&#13;
&#13;
    // This is the main DopeRaider contract. We have several seperately-instantiated  contracts&#13;
    // that handle auctions, districts and the creation of new narcos. By keeping&#13;
    // them in their own contracts, we can upgrade them without disrupting the main contract that tracks&#13;
    // narco ownership.&#13;
    //&#13;
    //      - NarcoBase: This is where we define the most fundamental code shared throughout the core&#13;
    //             functionality. This includes our main data storage, constants and data types, plus&#13;
    //             internal functions for managing these items.&#13;
    //&#13;
    //      - NarcoAccessControl: This contract manages the various addresses and constraints for operations&#13;
    //             that can be executed only by specific roles. Namely CEO, CFO and COO.&#13;
    //&#13;
    //      - NarcoOwnership: This provides the methods required for basic non-fungible token&#13;
    //             transactions, following the draft ERC-721 spec (https://github.com/ethereum/EIPs/issues/721).&#13;
    //&#13;
    //      - NarcoUpdates: This file contains the methods necessary to allow a separate contract to update narco stats&#13;
    //&#13;
    //      - NarcoAuction: Here we have the public methods for auctioning or bidding on narcos.&#13;
    //             The actual auction functionality is handled in a sibling sales contract,&#13;
    //             while auction creation and bidding is mostly mediated through this facet of the core contract.&#13;
    //&#13;
    //      - NarcoMinting: This final facet contains the functionality we use for creating new gen0 narcos.&#13;
    //             We can make up to 4096 "promo" narcos&#13;
&#13;
    // Set in case the core contract is broken and an upgrade is required&#13;
    address public newContractAddress;&#13;
&#13;
    bool public gamePaused = true;&#13;
&#13;
    modifier whenGameNotPaused() {&#13;
        require(!gamePaused);&#13;
        _;&#13;
    }&#13;
&#13;
    /// @dev Modifier to allow actions only when the contract IS paused&#13;
    modifier whenGamePaused {&#13;
        require(gamePaused);&#13;
        _;&#13;
    }&#13;
&#13;
    function pause() public onlyCLevel whenGameNotPaused {&#13;
        gamePaused = true;&#13;
    }&#13;
&#13;
    function unpause() public onlyCLevel whenGamePaused {&#13;
        // can't unpause if contract was upgraded&#13;
        gamePaused = false;&#13;
    }&#13;
&#13;
&#13;
    // EVENTS&#13;
    event GrowWeedCompleted(uint256 indexed narcoId, uint yield);&#13;
    event RefineCokeCompleted(uint256 indexed narcoId, uint yield);&#13;
&#13;
    function DopeRaiderCore() public {&#13;
        ceoAddress = msg.sender;&#13;
        cooAddress = msg.sender;&#13;
    }&#13;
&#13;
    /// @dev Used to mark the smart contract as upgraded, in case there is a serious&#13;
    ///  breaking bug. This method does nothing but keep track of the new contract and&#13;
    ///  emit a message indicating that the new address is set. It's up to clients of this&#13;
    ///  contract to update to the new contract address in that case. (This contract will&#13;
    ///  be paused indefinitely if such an upgrade takes place.)&#13;
    /// @param _v2Address new address&#13;
    function setNewAddress(address _v2Address) public onlyCLevel whenPaused {&#13;
        newContractAddress = _v2Address;&#13;
        ContractUpgrade(_v2Address);&#13;
    }&#13;
&#13;
    /// @notice No tipping!&#13;
    /// @dev Reject all Ether from being sent here, unless it's from one of the&#13;
    ///  two auction contracts. (Hopefully, we can prevent user accidents.)&#13;
    function() external payable {&#13;
        require(msg.sender == address(saleAuction));&#13;
    }&#13;
&#13;
    /// @param _id The ID of the narco of interest.&#13;
&#13;
   function getNarco(uint256 _id)&#13;
        public&#13;
        view&#13;
        returns (&#13;
        string  narcoName,&#13;
        uint256 weedTotal,&#13;
        uint256 cokeTotal,&#13;
        uint16[6] skills,&#13;
        uint8[4] consumables,&#13;
        string genes,&#13;
        uint8 homeLocation,&#13;
        uint16 level,&#13;
        uint256[6] cooldowns,&#13;
        uint256 id,&#13;
        uint16 [9] stats&#13;
    ) {&#13;
        Narco storage narco = narcos[_id];&#13;
        narcoName = narco.narcoName;&#13;
        weedTotal = narco.weedTotal;&#13;
        cokeTotal = narco.cokeTotal;&#13;
        skills = narco.skills;&#13;
        consumables = narco.consumables;&#13;
        genes = narco.genes;&#13;
        homeLocation = narco.homeLocation;&#13;
        level = getLevel(_id);&#13;
        cooldowns = narco.cooldowns;&#13;
        id = _id;&#13;
        stats = narco.stats;&#13;
    }&#13;
&#13;
    uint256 public changeIdentityNarcoRespect = 30;&#13;
    function setChangeIdentityNarcoRespect(uint256 _respect) public onlyCLevel {&#13;
      changeIdentityNarcoRespect=_respect;&#13;
    }&#13;
&#13;
    uint256 public personalisationCost = 0.01 ether; // pimp my narco&#13;
    function setPersonalisationCost(uint256 _cost) public onlyCLevel {&#13;
      personalisationCost=_cost;&#13;
    }&#13;
    function updateNarco(uint256 _narcoId, string _genes, string _name) public payable whenGameNotPaused {&#13;
       require(getLevel(_narcoId)&gt;=changeIdentityNarcoRespect); // minimum level to recruit a narco&#13;
       require(msg.sender==narcoIndexToOwner[_narcoId]); // can't be moving other peoples narcos about&#13;
       require(msg.value&gt;=personalisationCost);&#13;
       narcos[_narcoId].genes = _genes;&#13;
       narcos[_narcoId].narcoName = _name;&#13;
    }&#13;
&#13;
    uint256 public respectRequiredToRecruit = 150;&#13;
&#13;
    function setRespectRequiredToRecruit(uint256 _respect) public onlyCLevel {&#13;
      respectRequiredToRecruit=_respect;&#13;
    }&#13;
&#13;
    function recruitNarco(uint256 _narcoId, string _genes, string _name) public whenGameNotPaused {&#13;
       require(msg.sender==narcoIndexToOwner[_narcoId]); // can't be moving other peoples narcos about&#13;
       require(getLevel(_narcoId)&gt;=respectRequiredToRecruit); // minimum level to recruit a narco&#13;
       require(narcos[_narcoId].stats[8]&lt;getLevel(_narcoId)/respectRequiredToRecruit); // must have recruited &lt; respect / required reqpect (times)&#13;
      _createNarco(_genes,_name, msg.sender);&#13;
      narcos[_narcoId].stats[8]+=1; // increase number recruited&#13;
    }&#13;
&#13;
   // crafting section&#13;
    uint256 public growCost = 0.003 ether;&#13;
    function setGrowCost(uint256 _cost) public onlyCLevel{&#13;
      growCost=_cost;&#13;
    }&#13;
&#13;
    function growWeed(uint256 _narcoId) public payable whenGameNotPaused{&#13;
         require(msg.sender==narcoIndexToOwner[_narcoId]); // can't be moving other peoples narcos about&#13;
         require(msg.value&gt;=growCost);&#13;
         require(now&gt;narcos[_narcoId].cooldowns[1]); //cooldown must have expired&#13;
         uint16 growSkillLevel = narcos[_narcoId].skills[1]; // grow&#13;
         uint16 maxYield = 9 + growSkillLevel; // max amount can be grown based on skill&#13;
         uint yield = min(narcos[_narcoId].consumables[1],maxYield);&#13;
         require(yield&gt;0); // gotta produce something&#13;
&#13;
         // must be home location&#13;
         uint8 district = districtsCore.getNarcoLocation(_narcoId);&#13;
         require(district==narcos[_narcoId].homeLocation);&#13;
&#13;
         // do the crafting&#13;
         uint256 cooldown = now + ((910-(10*growSkillLevel))* 1 seconds); //calculate cooldown switch to minutes later&#13;
&#13;
         narcos[_narcoId].cooldowns[1]=cooldown;&#13;
         // use all available  - for now , maybe later make optional&#13;
         narcos[_narcoId].consumables[1]=uint8(subToZero(uint256(narcos[_narcoId].consumables[1]),yield));&#13;
         narcos[_narcoId].weedTotal+=uint8(yield);&#13;
&#13;
         narcos[_narcoId].stats[1]+=1; // update the statistic for grow&#13;
         districtsCore.increaseDistrictWeed(district , yield);&#13;
         districtsCore.distributeRevenue.value(growCost)(uint256(district),50,50); // distribute the revenue to districts pots&#13;
         GrowWeedCompleted(_narcoId, yield); // notification event&#13;
    }&#13;
&#13;
&#13;
    uint256 public refineCost = 0.003 ether;&#13;
    function setRefineCost(uint256 _cost) public onlyCLevel{&#13;
      refineCost=_cost;&#13;
    }&#13;
&#13;
    function refineCoke(uint256 _narcoId) public payable whenGameNotPaused{&#13;
         require(msg.sender==narcoIndexToOwner[_narcoId]); // can't be moving other peoples narcos about&#13;
         require(msg.value&gt;=refineCost);&#13;
         require(now&gt;narcos[_narcoId].cooldowns[2]); //cooldown must have expired&#13;
         uint16 refineSkillLevel = narcos[_narcoId].skills[2]; // refine&#13;
         uint16 maxYield = 3+(refineSkillLevel/3); // max amount can be grown based on skill&#13;
         uint yield = min(narcos[_narcoId].consumables[2],maxYield);&#13;
         require(yield&gt;0); // gotta produce something&#13;
&#13;
         // must be home location&#13;
         uint8 district = districtsCore.getNarcoLocation(_narcoId);&#13;
         require(district==narcos[_narcoId].homeLocation);&#13;
&#13;
         // do the crafting&#13;
        // uint256 cooldown = now + min(3 minutes,((168-(2*refineSkillLevel))* 1 seconds)); // calculate cooldown&#13;
         uint256 cooldown = now + ((910-(10*refineSkillLevel))* 1 seconds); // calculate cooldown&#13;
&#13;
         narcos[_narcoId].cooldowns[2]=cooldown;&#13;
         // use all available  - for now , maybe later make optional&#13;
         narcos[_narcoId].consumables[2]=uint8(subToZero(uint256(narcos[_narcoId].consumables[2]),yield));&#13;
         narcos[_narcoId].cokeTotal+=uint8(yield);&#13;
&#13;
         narcos[_narcoId].stats[2]+=1;&#13;
         districtsCore.increaseDistrictCoke(district, yield);&#13;
         districtsCore.distributeRevenue.value(refineCost)(uint256(district),50,50); // distribute the revenue to districts pots&#13;
         RefineCokeCompleted(_narcoId, yield); // notification event&#13;
&#13;
    }&#13;
&#13;
&#13;
    function min(uint a, uint b) private pure returns (uint) {&#13;
             return a &lt; b ? a : b;&#13;
    }&#13;
&#13;
}