pragma solidity 0.4.24;
// produced by the Solididy File Flattener (c) David Appleton 2018
// contact : <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="a3c7c2d5c6e3c2c8cccec1c28dc0ccce">[emailÂ protected]</a>&#13;
// released under Apache 2.0 licence&#13;
contract ERC20Basic {&#13;
  function totalSupply() public view returns (uint256);&#13;
  function balanceOf(address who) public view returns (uint256);&#13;
  function transfer(address to, uint256 value) public returns (bool);&#13;
  event Transfer(address indexed from, address indexed to, uint256 value);&#13;
}&#13;
&#13;
contract Ownable {&#13;
  address public owner;&#13;
&#13;
&#13;
  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);&#13;
&#13;
&#13;
  /**&#13;
   * @dev The Ownable constructor sets the original `owner` of the contract to the sender&#13;
   * account.&#13;
   */&#13;
  function Ownable() public {&#13;
    owner = msg.sender;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Throws if called by any account other than the owner.&#13;
   */&#13;
  modifier onlyOwner() {&#13;
    require(msg.sender == owner);&#13;
    _;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Allows the current owner to transfer control of the contract to a newOwner.&#13;
   * @param newOwner The address to transfer ownership to.&#13;
   */&#13;
  function transferOwnership(address newOwner) public onlyOwner {&#13;
    require(newOwner != address(0));&#13;
    OwnershipTransferred(owner, newOwner);&#13;
    owner = newOwner;&#13;
  }&#13;
&#13;
}&#13;
&#13;
library SafeMath {&#13;
&#13;
  /**&#13;
  * @dev Multiplies two numbers, throws on overflow.&#13;
  */&#13;
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
    if (a == 0) {&#13;
      return 0;&#13;
    }&#13;
    uint256 c = a * b;&#13;
    assert(c / a == b);&#13;
    return c;&#13;
  }&#13;
&#13;
  /**&#13;
  * @dev Integer division of two numbers, truncating the quotient.&#13;
  */&#13;
  function div(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
    // assert(b &gt; 0); // Solidity automatically throws when dividing by 0&#13;
    uint256 c = a / b;&#13;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold&#13;
    return c;&#13;
  }&#13;
&#13;
  /**&#13;
  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).&#13;
  */&#13;
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
    assert(b &lt;= a);&#13;
    return a - b;&#13;
  }&#13;
&#13;
  /**&#13;
  * @dev Adds two numbers, throws on overflow.&#13;
  */&#13;
  function add(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
    uint256 c = a + b;&#13;
    assert(c &gt;= a);&#13;
    return c;&#13;
  }&#13;
}&#13;
&#13;
contract ERC20 is ERC20Basic {&#13;
  function allowance(address owner, address spender) public view returns (uint256);&#13;
  function transferFrom(address from, address to, uint256 value) public returns (bool);&#13;
  function approve(address spender, uint256 value) public returns (bool);&#13;
  event Approval(address indexed owner, address indexed spender, uint256 value);&#13;
}&#13;
&#13;
contract BasicToken is ERC20Basic {&#13;
  using SafeMath for uint256;&#13;
&#13;
  mapping(address =&gt; uint256) balances;&#13;
&#13;
  uint256 totalSupply_;&#13;
&#13;
  /**&#13;
  * @dev total number of tokens in existence&#13;
  */&#13;
  function totalSupply() public view returns (uint256) {&#13;
    return totalSupply_;&#13;
  }&#13;
&#13;
  /**&#13;
  * @dev transfer token for a specified address&#13;
  * @param _to The address to transfer to.&#13;
  * @param _value The amount to be transferred.&#13;
  */&#13;
  function transfer(address _to, uint256 _value) public returns (bool) {&#13;
    require(_to != address(0));&#13;
    require(_value &lt;= balances[msg.sender]);&#13;
&#13;
    // SafeMath.sub will throw if there is not enough balance.&#13;
    balances[msg.sender] = balances[msg.sender].sub(_value);&#13;
    balances[_to] = balances[_to].add(_value);&#13;
    Transfer(msg.sender, _to, _value);&#13;
    return true;&#13;
  }&#13;
&#13;
  /**&#13;
  * @dev Gets the balance of the specified address.&#13;
  * @param _owner The address to query the the balance of.&#13;
  * @return An uint256 representing the amount owned by the passed address.&#13;
  */&#13;
  function balanceOf(address _owner) public view returns (uint256 balance) {&#13;
    return balances[_owner];&#13;
  }&#13;
&#13;
}&#13;
&#13;
contract Pausable is Ownable {&#13;
  event Pause();&#13;
  event Unpause();&#13;
&#13;
  bool public paused = false;&#13;
&#13;
&#13;
  /**&#13;
   * @dev Modifier to make a function callable only when the contract is not paused.&#13;
   */&#13;
  modifier whenNotPaused() {&#13;
    require(!paused);&#13;
    _;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Modifier to make a function callable only when the contract is paused.&#13;
   */&#13;
  modifier whenPaused() {&#13;
    require(paused);&#13;
    _;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev called by the owner to pause, triggers stopped state&#13;
   */&#13;
  function pause() onlyOwner whenNotPaused public {&#13;
    paused = true;&#13;
    Pause();&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev called by the owner to unpause, returns to normal state&#13;
   */&#13;
  function unpause() onlyOwner whenPaused public {&#13;
    paused = false;&#13;
    Unpause();&#13;
  }&#13;
}&#13;
&#13;
contract Relay is Ownable {&#13;
    address public licenseSalesContractAddress;&#13;
    address public registryContractAddress;&#13;
    address public apiRegistryContractAddress;&#13;
    address public apiCallsContractAddress;&#13;
    uint public version;&#13;
&#13;
    // ------------------------------------------------------------------------&#13;
    // Constructor, establishes ownership because contract is owned&#13;
    // ------------------------------------------------------------------------&#13;
    constructor() public {&#13;
        version = 4;&#13;
    }&#13;
&#13;
    // ------------------------------------------------------------------------&#13;
    // Owner can transfer out any accidentally sent ERC20 tokens (just in case)&#13;
    // ------------------------------------------------------------------------&#13;
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {&#13;
        return ERC20(tokenAddress).transfer(owner, tokens);&#13;
    }&#13;
&#13;
    // ------------------------------------------------------------------------&#13;
    // Sets the license sales contract address&#13;
    // ------------------------------------------------------------------------&#13;
    function setLicenseSalesContractAddress(address newAddress) public onlyOwner {&#13;
        require(newAddress != address(0));&#13;
        licenseSalesContractAddress = newAddress;&#13;
    }&#13;
&#13;
    // ------------------------------------------------------------------------&#13;
    // Sets the registry contract address&#13;
    // ------------------------------------------------------------------------&#13;
    function setRegistryContractAddress(address newAddress) public onlyOwner {&#13;
        require(newAddress != address(0));&#13;
        registryContractAddress = newAddress;&#13;
    }&#13;
&#13;
    // ------------------------------------------------------------------------&#13;
    // Sets the api registry contract address&#13;
    // ------------------------------------------------------------------------&#13;
    function setApiRegistryContractAddress(address newAddress) public onlyOwner {&#13;
        require(newAddress != address(0));&#13;
        apiRegistryContractAddress = newAddress;&#13;
    }&#13;
&#13;
    // ------------------------------------------------------------------------&#13;
    // Sets the api calls contract address&#13;
    // ------------------------------------------------------------------------&#13;
    function setApiCallsContractAddress(address newAddress) public onlyOwner {&#13;
        require(newAddress != address(0));&#13;
        apiCallsContractAddress = newAddress;&#13;
    }&#13;
}&#13;
contract APIRegistry is Ownable {&#13;
&#13;
    struct APIForSale {&#13;
        uint pricePerCall;&#13;
        bytes32 sellerUsername;&#13;
        bytes32 apiName;&#13;
        address sellerAddress;&#13;
        string hostname;&#13;
        string docsUrl;&#13;
    }&#13;
&#13;
    mapping(string =&gt; uint) internal apiIds;&#13;
    mapping(uint =&gt; APIForSale) public apis;&#13;
&#13;
    uint public numApis;&#13;
    uint public version;&#13;
&#13;
    // ------------------------------------------------------------------------&#13;
    // Constructor, establishes ownership because contract is owned&#13;
    // ------------------------------------------------------------------------&#13;
    constructor() public {&#13;
        numApis = 0;&#13;
        version = 1;&#13;
    }&#13;
&#13;
    // ------------------------------------------------------------------------&#13;
    // Owner can transfer out any accidentally sent ERC20 tokens (just in case)&#13;
    // ------------------------------------------------------------------------&#13;
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {&#13;
        return ERC20(tokenAddress).transfer(owner, tokens);&#13;
    }&#13;
&#13;
    // ------------------------------------------------------------------------&#13;
    // Lets a user list an API to sell&#13;
    // ------------------------------------------------------------------------&#13;
    function listApi(uint pricePerCall, bytes32 sellerUsername, bytes32 apiName, string hostname, string docsUrl) public {&#13;
        // make sure input params are valid&#13;
        require(pricePerCall != 0 &amp;&amp; sellerUsername != "" &amp;&amp; apiName != "" &amp;&amp; bytes(hostname).length != 0);&#13;
        &#13;
        // make sure the name isn't already taken&#13;
        require(apiIds[hostname] == 0);&#13;
&#13;
        numApis += 1;&#13;
        apiIds[hostname] = numApis;&#13;
&#13;
        APIForSale storage api = apis[numApis];&#13;
&#13;
        api.pricePerCall = pricePerCall;&#13;
        api.sellerUsername = sellerUsername;&#13;
        api.apiName = apiName;&#13;
        api.sellerAddress = msg.sender;&#13;
        api.hostname = hostname;&#13;
        api.docsUrl = docsUrl;&#13;
    }&#13;
&#13;
    // ------------------------------------------------------------------------&#13;
    // Get the ID number of an API given it's hostname&#13;
    // ------------------------------------------------------------------------&#13;
    function getApiId(string hostname) public view returns (uint) {&#13;
        return apiIds[hostname];&#13;
    }&#13;
&#13;
    // ------------------------------------------------------------------------&#13;
    // Get info stored for the API but without the dynamic members, because solidity can't return dynamics to other smart contracts yet&#13;
    // ------------------------------------------------------------------------&#13;
    function getApiByIdWithoutDynamics(&#13;
        uint apiId&#13;
    ) &#13;
        public&#13;
        view &#13;
        returns (&#13;
            uint pricePerCall, &#13;
            bytes32 sellerUsername,&#13;
            bytes32 apiName, &#13;
            address sellerAddress&#13;
        ) &#13;
    {&#13;
        APIForSale storage api = apis[apiId];&#13;
&#13;
        pricePerCall = api.pricePerCall;&#13;
        sellerUsername = api.sellerUsername;&#13;
        apiName = api.apiName;&#13;
        sellerAddress = api.sellerAddress;&#13;
    }&#13;
&#13;
    // ------------------------------------------------------------------------&#13;
    // Get info stored for an API by id&#13;
    // ------------------------------------------------------------------------&#13;
    function getApiById(&#13;
        uint apiId&#13;
    ) &#13;
        public &#13;
        view &#13;
        returns (&#13;
            uint pricePerCall, &#13;
            bytes32 sellerUsername, &#13;
            bytes32 apiName, &#13;
            address sellerAddress, &#13;
            string hostname, &#13;
            string docsUrl&#13;
        ) &#13;
    {&#13;
        APIForSale storage api = apis[apiId];&#13;
&#13;
        pricePerCall = api.pricePerCall;&#13;
        sellerUsername = api.sellerUsername;&#13;
        apiName = api.apiName;&#13;
        sellerAddress = api.sellerAddress;&#13;
        hostname = api.hostname;&#13;
        docsUrl = api.docsUrl;&#13;
    }&#13;
&#13;
    // ------------------------------------------------------------------------&#13;
    // Get info stored for an API by hostname&#13;
    // ------------------------------------------------------------------------&#13;
    function getApiByName(&#13;
        string _hostname&#13;
    ) &#13;
        public &#13;
        view &#13;
        returns (&#13;
            uint pricePerCall, &#13;
            bytes32 sellerUsername, &#13;
            bytes32 apiName, &#13;
            address sellerAddress, &#13;
            string hostname, &#13;
            string docsUrl&#13;
        ) &#13;
    {&#13;
        uint apiId = apiIds[_hostname];&#13;
        if (apiId == 0) {&#13;
            return;&#13;
        }&#13;
        APIForSale storage api = apis[apiId];&#13;
&#13;
        pricePerCall = api.pricePerCall;&#13;
        sellerUsername = api.sellerUsername;&#13;
        apiName = api.apiName;&#13;
        sellerAddress = api.sellerAddress;&#13;
        hostname = api.hostname;&#13;
        docsUrl = api.docsUrl;&#13;
    }&#13;
&#13;
    // ------------------------------------------------------------------------&#13;
    // Edit an API listing&#13;
    // ------------------------------------------------------------------------&#13;
    function editApi(uint apiId, uint pricePerCall, address sellerAddress, string docsUrl) public {&#13;
        require(apiId != 0 &amp;&amp; pricePerCall != 0 &amp;&amp; sellerAddress != address(0));&#13;
&#13;
        APIForSale storage api = apis[apiId];&#13;
&#13;
        // prevent editing an empty api (effectively listing an api)&#13;
        require(&#13;
            api.pricePerCall != 0 &amp;&amp; api.sellerUsername != "" &amp;&amp; api.apiName != "" &amp;&amp;  bytes(api.hostname).length != 0 &amp;&amp; api.sellerAddress != address(0)&#13;
        );&#13;
&#13;
        // require that sender is the original api lister, or the contract owner&#13;
        // the contract owner clause lets us recover a api listing if a dev loses access to their privkey&#13;
        require(msg.sender == api.sellerAddress || msg.sender == owner);&#13;
&#13;
        api.pricePerCall = pricePerCall;&#13;
        api.sellerAddress = sellerAddress;&#13;
        api.docsUrl = docsUrl;&#13;
    }&#13;
}&#13;
contract StandardToken is ERC20, BasicToken {&#13;
&#13;
  mapping (address =&gt; mapping (address =&gt; uint256)) internal allowed;&#13;
&#13;
&#13;
  /**&#13;
   * @dev Transfer tokens from one address to another&#13;
   * @param _from address The address which you want to send tokens from&#13;
   * @param _to address The address which you want to transfer to&#13;
   * @param _value uint256 the amount of tokens to be transferred&#13;
   */&#13;
  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {&#13;
    require(_to != address(0));&#13;
    require(_value &lt;= balances[_from]);&#13;
    require(_value &lt;= allowed[_from][msg.sender]);&#13;
&#13;
    balances[_from] = balances[_from].sub(_value);&#13;
    balances[_to] = balances[_to].add(_value);&#13;
    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);&#13;
    Transfer(_from, _to, _value);&#13;
    return true;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.&#13;
   *&#13;
   * Beware that changing an allowance with this method brings the risk that someone may use both the old&#13;
   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this&#13;
   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:&#13;
   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729&#13;
   * @param _spender The address which will spend the funds.&#13;
   * @param _value The amount of tokens to be spent.&#13;
   */&#13;
  function approve(address _spender, uint256 _value) public returns (bool) {&#13;
    allowed[msg.sender][_spender] = _value;&#13;
    Approval(msg.sender, _spender, _value);&#13;
    return true;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Function to check the amount of tokens that an owner allowed to a spender.&#13;
   * @param _owner address The address which owns the funds.&#13;
   * @param _spender address The address which will spend the funds.&#13;
   * @return A uint256 specifying the amount of tokens still available for the spender.&#13;
   */&#13;
  function allowance(address _owner, address _spender) public view returns (uint256) {&#13;
    return allowed[_owner][_spender];&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Increase the amount of tokens that an owner allowed to a spender.&#13;
   *&#13;
   * approve should be called when allowed[_spender] == 0. To increment&#13;
   * allowed value is better to use this function to avoid 2 calls (and wait until&#13;
   * the first transaction is mined)&#13;
   * From MonolithDAO Token.sol&#13;
   * @param _spender The address which will spend the funds.&#13;
   * @param _addedValue The amount of tokens to increase the allowance by.&#13;
   */&#13;
  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {&#13;
    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);&#13;
    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);&#13;
    return true;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Decrease the amount of tokens that an owner allowed to a spender.&#13;
   *&#13;
   * approve should be called when allowed[_spender] == 0. To decrement&#13;
   * allowed value is better to use this function to avoid 2 calls (and wait until&#13;
   * the first transaction is mined)&#13;
   * From MonolithDAO Token.sol&#13;
   * @param _spender The address which will spend the funds.&#13;
   * @param _subtractedValue The amount of tokens to decrease the allowance by.&#13;
   */&#13;
  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {&#13;
    uint oldValue = allowed[msg.sender][_spender];&#13;
    if (_subtractedValue &gt; oldValue) {&#13;
      allowed[msg.sender][_spender] = 0;&#13;
    } else {&#13;
      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);&#13;
    }&#13;
    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);&#13;
    return true;&#13;
  }&#13;
&#13;
}&#13;
&#13;
contract DeconetToken is StandardToken, Ownable, Pausable {&#13;
    // token naming etc&#13;
    string public constant symbol = "DCO";&#13;
    string public constant name = "Deconet Token";&#13;
    uint8 public constant decimals = 18;&#13;
&#13;
    // contract version&#13;
    uint public constant version = 4;&#13;
&#13;
    // ------------------------------------------------------------------------&#13;
    // Constructor&#13;
    // ------------------------------------------------------------------------&#13;
    constructor() public {&#13;
        // 1 billion tokens (1,000,000,000)&#13;
        totalSupply_ = 1000000000 * 10**uint(decimals);&#13;
&#13;
        // transfer initial supply to msg.sender who is also contract owner&#13;
        balances[msg.sender] = totalSupply_;&#13;
        Transfer(address(0), msg.sender, totalSupply_);&#13;
&#13;
        // pause contract until we're ready to allow transfers&#13;
        paused = true;&#13;
    }&#13;
&#13;
    // ------------------------------------------------------------------------&#13;
    // Owner can transfer out any accidentally sent ERC20 tokens (just in case)&#13;
    // ------------------------------------------------------------------------&#13;
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {&#13;
        return ERC20(tokenAddress).transfer(owner, tokens);&#13;
    }&#13;
&#13;
    // ------------------------------------------------------------------------&#13;
    // Modifier to make a function callable only when called by the contract owner&#13;
    // or if the contract is not paused.&#13;
    // ------------------------------------------------------------------------&#13;
    modifier whenOwnerOrNotPaused() {&#13;
        require(msg.sender == owner || !paused);&#13;
        _;&#13;
    }&#13;
&#13;
    // ------------------------------------------------------------------------&#13;
    // overloaded openzepplin method to add whenOwnerOrNotPaused modifier&#13;
    // ------------------------------------------------------------------------&#13;
    function transfer(address _to, uint256 _value) public whenOwnerOrNotPaused returns (bool) {&#13;
        return super.transfer(_to, _value);&#13;
    }&#13;
&#13;
    // ------------------------------------------------------------------------&#13;
    // overloaded openzepplin method to add whenOwnerOrNotPaused modifier&#13;
    // ------------------------------------------------------------------------&#13;
    function transferFrom(address _from, address _to, uint256 _value) public whenOwnerOrNotPaused returns (bool) {&#13;
        return super.transferFrom(_from, _to, _value);&#13;
    }&#13;
&#13;
    // ------------------------------------------------------------------------&#13;
    // overloaded openzepplin method to add whenOwnerOrNotPaused modifier&#13;
    // ------------------------------------------------------------------------&#13;
    function approve(address _spender, uint256 _value) public whenOwnerOrNotPaused returns (bool) {&#13;
        return super.approve(_spender, _value);&#13;
    }&#13;
&#13;
    // ------------------------------------------------------------------------&#13;
    // overloaded openzepplin method to add whenOwnerOrNotPaused modifier&#13;
    // ------------------------------------------------------------------------&#13;
    function increaseApproval(address _spender, uint _addedValue) public whenOwnerOrNotPaused returns (bool success) {&#13;
        return super.increaseApproval(_spender, _addedValue);&#13;
    }&#13;
&#13;
    // ------------------------------------------------------------------------&#13;
    // overloaded openzepplin method to add whenOwnerOrNotPaused modifier&#13;
    // ------------------------------------------------------------------------&#13;
    function decreaseApproval(address _spender, uint _subtractedValue) public whenOwnerOrNotPaused returns (bool success) {&#13;
        return super.decreaseApproval(_spender, _subtractedValue);&#13;
    }&#13;
}&#13;
&#13;
contract APICalls is Ownable {&#13;
    using SafeMath for uint;&#13;
&#13;
    // the amount rewarded to a seller for selling api calls per buyer&#13;
    uint public tokenReward;&#13;
&#13;
    // the fee this contract takes from every sale.  expressed as percent.  so a value of 3 indicates a 3% txn fee&#13;
    uint public saleFee;&#13;
&#13;
    // if the buyer has never paid, we need to pick a date for when they probably started using the API.  &#13;
    // This is in seconds and will be subtracted from "now"&#13;
    uint public defaultBuyerLastPaidAt;&#13;
&#13;
    // address of the relay contract which holds the address of the registry contract.&#13;
    address public relayContractAddress;&#13;
&#13;
    // the token address&#13;
    address public tokenContractAddress;&#13;
&#13;
    // this contract version&#13;
    uint public version;&#13;
&#13;
    // the amount that can be safely withdrawn from the contract&#13;
    uint public safeWithdrawAmount;&#13;
&#13;
    // the address that is authorized to withdraw eth&#13;
    address private withdrawAddress;&#13;
&#13;
    // the address that is authorized to report usage on behalf of deconet&#13;
    address private usageReportingAddress;&#13;
&#13;
    // maps apiId to a APIBalance which stores how much each address owes&#13;
    mapping(uint =&gt; APIBalance) internal owed;&#13;
&#13;
    // maps buyer addresses to whether or not accounts are overdrafted and more&#13;
    mapping(address =&gt; BuyerInfo) internal buyers;&#13;
&#13;
    // Stores amounts owed and when buyers last paid on a per-api and per-user basis&#13;
    struct APIBalance {&#13;
        // maps address -&gt; amount owed in wei&#13;
        mapping(address =&gt; uint) amounts;&#13;
        // basically a list of keys for the above map&#13;
        address[] nonzeroAddresses;&#13;
        // maps address -&gt; tiemstamp of when buyer last paid&#13;
        mapping(address =&gt; uint) buyerLastPaidAt;&#13;
    }&#13;
&#13;
    // Stores basic info about a buyer including their lifetime stats and reputation info&#13;
    struct BuyerInfo {&#13;
        // whether or not the account is overdrafted or not&#13;
        bool overdrafted;&#13;
        // total number of overdrafts, ever&#13;
        uint lifetimeOverdraftCount;&#13;
        // credits on file with this contract (wei)&#13;
        uint credits;&#13;
        // total amount of credits used / spent, ever (wei)&#13;
        uint lifetimeCreditsUsed;&#13;
        // maps apiId to approved spending balance for each API per second.&#13;
        mapping(uint =&gt; uint) approvedAmounts;&#13;
        // maps apiId to whether or not the user has exceeded their approved amount&#13;
        mapping(uint =&gt; bool) exceededApprovedAmount;&#13;
        // total number of times exceededApprovedAmount has happened&#13;
        uint lifetimeExceededApprovalAmountCount;&#13;
    }&#13;
&#13;
    // Logged when API call usage is reported&#13;
    event LogAPICallsMade(&#13;
        uint apiId,&#13;
        address indexed sellerAddress,&#13;
        address indexed buyerAddress,&#13;
        uint pricePerCall,&#13;
        uint numCalls,&#13;
        uint totalPrice,&#13;
        address reportingAddress&#13;
    );&#13;
&#13;
    // Logged when seller is paid for API calls&#13;
    event LogAPICallsPaid(&#13;
        uint apiId,&#13;
        address indexed sellerAddress,&#13;
        uint totalPrice,&#13;
        uint rewardedTokens,&#13;
        uint networkFee&#13;
    );&#13;
&#13;
    // Logged when the credits from a specific buyer are spent on a specific api&#13;
    event LogSpendCredits(&#13;
        address indexed buyerAddress,&#13;
        uint apiId,&#13;
        uint amount,&#13;
        bool causedAnOverdraft&#13;
    );&#13;
&#13;
    // Logged when a buyer deposits credits&#13;
    event LogDepositCredits(&#13;
        address indexed buyerAddress,&#13;
        uint amount&#13;
    );&#13;
&#13;
    // Logged whena  buyer withdraws credits&#13;
    event LogWithdrawCredits(&#13;
        address indexed buyerAddress,&#13;
        uint amount&#13;
    );&#13;
&#13;
    // ------------------------------------------------------------------------&#13;
    // Constructor&#13;
    // ------------------------------------------------------------------------&#13;
    constructor() public {&#13;
        version = 1;&#13;
&#13;
        // default token reward of 100 tokens.  &#13;
        // token has 18 decimal places so that's why 100 * 10^18&#13;
        tokenReward = 100 * 10**18;&#13;
&#13;
        // default saleFee of 10%&#13;
        saleFee = 10;&#13;
&#13;
        // 604,800 seconds = 1 week.  this is the default for when a user started using an api (1 week ago)&#13;
        defaultBuyerLastPaidAt = 604800;&#13;
&#13;
        // default withdrawAddress is owner&#13;
        withdrawAddress = msg.sender;&#13;
        usageReportingAddress = msg.sender;&#13;
    }&#13;
&#13;
    // ------------------------------------------------------------------------&#13;
    // Owner can transfer out any accidentally sent ERC20 tokens (just in case)&#13;
    // ------------------------------------------------------------------------&#13;
    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {&#13;
        return ERC20(tokenAddress).transfer(owner, tokens);&#13;
    }&#13;
&#13;
    // ------------------------------------------------------------------------&#13;
    // Owner can transfer out any ETH&#13;
    // ------------------------------------------------------------------------&#13;
    function withdrawEther(uint amount) public {&#13;
        require(msg.sender == withdrawAddress);&#13;
        require(amount &lt;= this.balance);&#13;
        require(amount &lt;= safeWithdrawAmount);&#13;
        safeWithdrawAmount = safeWithdrawAmount.sub(amount);&#13;
        withdrawAddress.transfer(amount);&#13;
    }&#13;
&#13;
    // ------------------------------------------------------------------------&#13;
    // Owner can set address of who can withdraw&#13;
    // ------------------------------------------------------------------------&#13;
    function setWithdrawAddress(address _withdrawAddress) public onlyOwner {&#13;
        require(_withdrawAddress != address(0));&#13;
        withdrawAddress = _withdrawAddress;&#13;
    }&#13;
&#13;
    // ------------------------------------------------------------------------&#13;
    // Owner can set address of who can report usage&#13;
    // ------------------------------------------------------------------------&#13;
    function setUsageReportingAddress(address _usageReportingAddress) public onlyOwner {&#13;
        require(_usageReportingAddress != address(0));&#13;
        usageReportingAddress = _usageReportingAddress;&#13;
    }&#13;
&#13;
    // ------------------------------------------------------------------------&#13;
    // Owner can set address of relay contract&#13;
    // ------------------------------------------------------------------------&#13;
    function setRelayContractAddress(address _relayContractAddress) public onlyOwner {&#13;
        require(_relayContractAddress != address(0));&#13;
        relayContractAddress = _relayContractAddress;&#13;
    }&#13;
&#13;
    // ------------------------------------------------------------------------&#13;
    // Owner can set address of token contract&#13;
    // ------------------------------------------------------------------------&#13;
    function setTokenContractAddress(address _tokenContractAddress) public onlyOwner {&#13;
        require(_tokenContractAddress != address(0));&#13;
        tokenContractAddress = _tokenContractAddress;&#13;
    }&#13;
&#13;
    // ------------------------------------------------------------------------&#13;
    // Owner can set token reward&#13;
    // ------------------------------------------------------------------------&#13;
    function setTokenReward(uint _tokenReward) public onlyOwner {&#13;
        tokenReward = _tokenReward;&#13;
    }&#13;
&#13;
    // ------------------------------------------------------------------------&#13;
    // Owner can set the sale fee&#13;
    // ------------------------------------------------------------------------&#13;
    function setSaleFee(uint _saleFee) public onlyOwner {&#13;
        saleFee = _saleFee;&#13;
    }&#13;
&#13;
    // ------------------------------------------------------------------------&#13;
    // Owner can set the default buyer last paid at&#13;
    // ------------------------------------------------------------------------&#13;
    function setDefaultBuyerLastPaidAt(uint _defaultBuyerLastPaidAt) public onlyOwner {&#13;
        defaultBuyerLastPaidAt = _defaultBuyerLastPaidAt;&#13;
    }&#13;
&#13;
    // ------------------------------------------------------------------------&#13;
    // The API owner or the authorized deconet usage reporting address may report usage&#13;
    // ------------------------------------------------------------------------&#13;
    function reportUsage(uint apiId, uint numCalls, address buyerAddress) public {&#13;
        // look up the registry address from relay contract&#13;
        Relay relay = Relay(relayContractAddress);&#13;
        address apiRegistryAddress = relay.apiRegistryContractAddress();&#13;
&#13;
        // get the module info from registry&#13;
        APIRegistry apiRegistry = APIRegistry(apiRegistryAddress);&#13;
&#13;
        uint pricePerCall;&#13;
        bytes32 sellerUsername;&#13;
        bytes32 apiName;&#13;
        address sellerAddress;&#13;
&#13;
        (pricePerCall, sellerUsername, apiName, sellerAddress) = apiRegistry.getApiByIdWithoutDynamics(apiId);&#13;
&#13;
        // make sure the caller is either the api owner or the deconet reporting address&#13;
        require(sellerAddress != address(0));&#13;
        require(msg.sender == sellerAddress || msg.sender == usageReportingAddress);&#13;
&#13;
        // make sure the api is actually valid&#13;
        require(sellerUsername != "" &amp;&amp; apiName != "");&#13;
&#13;
        uint totalPrice = pricePerCall.mul(numCalls);&#13;
&#13;
        require(totalPrice &gt; 0);&#13;
&#13;
        APIBalance storage apiBalance = owed[apiId];&#13;
&#13;
        if (apiBalance.amounts[buyerAddress] == 0) {&#13;
            // add buyerAddress to list of addresses with nonzero balance for this api&#13;
            apiBalance.nonzeroAddresses.push(buyerAddress);&#13;
        }&#13;
&#13;
        apiBalance.amounts[buyerAddress] = apiBalance.amounts[buyerAddress].add(totalPrice);&#13;
&#13;
        emit LogAPICallsMade(&#13;
            apiId,&#13;
            sellerAddress,&#13;
            buyerAddress,&#13;
            pricePerCall,&#13;
            numCalls,&#13;
            totalPrice,&#13;
            msg.sender&#13;
        );&#13;
    }&#13;
&#13;
    // ------------------------------------------------------------------------&#13;
    // Function to pay the seller for a single API buyer.  &#13;
    // Settles reported usage according to credits and approved amounts.&#13;
    // ------------------------------------------------------------------------&#13;
    function paySellerForBuyer(uint apiId, address buyerAddress) public {&#13;
        // look up the registry address from relay contract&#13;
        Relay relay = Relay(relayContractAddress);&#13;
        address apiRegistryAddress = relay.apiRegistryContractAddress();&#13;
&#13;
        // get the module info from registry&#13;
        APIRegistry apiRegistry = APIRegistry(apiRegistryAddress);&#13;
&#13;
        uint pricePerCall;&#13;
        bytes32 sellerUsername;&#13;
        bytes32 apiName;&#13;
        address sellerAddress;&#13;
&#13;
        (pricePerCall, sellerUsername, apiName, sellerAddress) = apiRegistry.getApiByIdWithoutDynamics(apiId);&#13;
&#13;
        // make sure it's a legit real api&#13;
        require(pricePerCall != 0 &amp;&amp; sellerUsername != "" &amp;&amp; apiName != "" &amp;&amp; sellerAddress != address(0));&#13;
&#13;
        uint buyerPaid = processSalesForSingleBuyer(apiId, buyerAddress);&#13;
&#13;
        if (buyerPaid == 0) {&#13;
            return; // buyer paid nothing, we are done.&#13;
        }&#13;
&#13;
        // calculate fee and payout&#13;
        uint fee = buyerPaid.mul(saleFee).div(100);&#13;
        uint payout = buyerPaid.sub(fee);&#13;
&#13;
        // log that we stored the fee so we know we can take it out later&#13;
        safeWithdrawAmount += fee;&#13;
&#13;
        emit LogAPICallsPaid(&#13;
            apiId,&#13;
            sellerAddress,&#13;
            buyerPaid,&#13;
            tokenReward,&#13;
            fee&#13;
        );&#13;
&#13;
        // give seller some tokens for the sale&#13;
        rewardTokens(sellerAddress, tokenReward);&#13;
&#13;
        // transfer seller the eth&#13;
        sellerAddress.transfer(payout);&#13;
    }&#13;
&#13;
    // ------------------------------------------------------------------------&#13;
    // Function to pay the seller for all buyers with nonzero balance.  &#13;
    // Settles reported usage according to credits and approved amounts.&#13;
    // ------------------------------------------------------------------------&#13;
    function paySeller(uint apiId) public {&#13;
        // look up the registry address from relay contract&#13;
        Relay relay = Relay(relayContractAddress);&#13;
        address apiRegistryAddress = relay.apiRegistryContractAddress();&#13;
&#13;
        // get the module info from registry&#13;
        APIRegistry apiRegistry = APIRegistry(apiRegistryAddress);&#13;
&#13;
        uint pricePerCall;&#13;
        bytes32 sellerUsername;&#13;
        bytes32 apiName;&#13;
        address sellerAddress;&#13;
&#13;
        (pricePerCall, sellerUsername, apiName, sellerAddress) = apiRegistry.getApiByIdWithoutDynamics(apiId);&#13;
&#13;
        // make sure it's a legit real api&#13;
        require(pricePerCall != 0 &amp;&amp; sellerUsername != "" &amp;&amp; apiName != "" &amp;&amp; sellerAddress != address(0));&#13;
&#13;
        // calculate totalPayable for the api&#13;
        uint totalPayable = 0;&#13;
        uint totalBuyers = 0;&#13;
        (totalPayable, totalBuyers) = processSalesForAllBuyers(apiId);&#13;
&#13;
        if (totalPayable == 0) {&#13;
            return; // if there's nothing to pay, we are done here.&#13;
        }&#13;
&#13;
        // calculate fee and payout&#13;
        uint fee = totalPayable.mul(saleFee).div(100);&#13;
        uint payout = totalPayable.sub(fee);&#13;
&#13;
        // log that we stored the fee so we know we can take it out later&#13;
        safeWithdrawAmount += fee;&#13;
&#13;
        // we reward token reward on a "per buyer" basis.  so multiply the reward to give by the number of actual buyers&#13;
        uint totalTokenReward = tokenReward.mul(totalBuyers);&#13;
&#13;
        emit LogAPICallsPaid(&#13;
            apiId,&#13;
            sellerAddress,&#13;
            totalPayable,&#13;
            totalTokenReward,&#13;
            fee&#13;
        );&#13;
&#13;
        // give seller some tokens for the sale&#13;
        rewardTokens(sellerAddress, totalTokenReward);&#13;
&#13;
        // transfer seller the eth&#13;
        sellerAddress.transfer(payout);&#13;
    } &#13;
&#13;
    // ------------------------------------------------------------------------&#13;
    // Let anyone see when the buyer last paid for a given API&#13;
    // ------------------------------------------------------------------------&#13;
    function buyerLastPaidAt(uint apiId, address buyerAddress) public view returns (uint) {&#13;
        APIBalance storage apiBalance = owed[apiId];&#13;
        return apiBalance.buyerLastPaidAt[buyerAddress];&#13;
    }   &#13;
&#13;
    // ------------------------------------------------------------------------&#13;
    // Get buyer info struct for a specific buyer address&#13;
    // ------------------------------------------------------------------------&#13;
    function buyerInfoOf(address addr) &#13;
        public &#13;
        view &#13;
        returns (&#13;
            bool overdrafted, &#13;
            uint lifetimeOverdraftCount, &#13;
            uint credits, &#13;
            uint lifetimeCreditsUsed, &#13;
            uint lifetimeExceededApprovalAmountCount&#13;
        ) &#13;
    {&#13;
        BuyerInfo storage buyer = buyers[addr];&#13;
        overdrafted = buyer.overdrafted;&#13;
        lifetimeOverdraftCount = buyer.lifetimeOverdraftCount;&#13;
        credits = buyer.credits;&#13;
        lifetimeCreditsUsed = buyer.lifetimeCreditsUsed;&#13;
        lifetimeExceededApprovalAmountCount = buyer.lifetimeExceededApprovalAmountCount;&#13;
    }&#13;
&#13;
    // ------------------------------------------------------------------------&#13;
    // Gets the credits balance of a buyer&#13;
    // ------------------------------------------------------------------------&#13;
    function creditsBalanceOf(address addr) public view returns (uint) {&#13;
        BuyerInfo storage buyer = buyers[addr];&#13;
        return buyer.credits;&#13;
    }&#13;
&#13;
    // ------------------------------------------------------------------------&#13;
    // Lets a buyer add credits&#13;
    // ------------------------------------------------------------------------&#13;
    function addCredits(address to) public payable {&#13;
        BuyerInfo storage buyer = buyers[to];&#13;
        buyer.credits = buyer.credits.add(msg.value);&#13;
        emit LogDepositCredits(to, msg.value);&#13;
    }&#13;
&#13;
    // ------------------------------------------------------------------------&#13;
    // Lets a buyer withdraw credits&#13;
    // ------------------------------------------------------------------------&#13;
    function withdrawCredits(uint amount) public {&#13;
        BuyerInfo storage buyer = buyers[msg.sender];&#13;
        require(buyer.credits &gt;= amount);&#13;
        buyer.credits = buyer.credits.sub(amount);&#13;
        msg.sender.transfer(amount);&#13;
        emit LogWithdrawCredits(msg.sender, amount);&#13;
    }&#13;
&#13;
    // ------------------------------------------------------------------------&#13;
    // Get the length of array of buyers who have a nonzero balance for a given API&#13;
    // ------------------------------------------------------------------------&#13;
    function nonzeroAddressesElementForApi(uint apiId, uint index) public view returns (address) {&#13;
        APIBalance storage apiBalance = owed[apiId];&#13;
        return apiBalance.nonzeroAddresses[index];&#13;
    }&#13;
&#13;
    // ------------------------------------------------------------------------&#13;
    // Get an element from the array of buyers who have a nonzero balance for a given API&#13;
    // ------------------------------------------------------------------------&#13;
    function nonzeroAddressesLengthForApi(uint apiId) public view returns (uint) {&#13;
        APIBalance storage apiBalance = owed[apiId];&#13;
        return apiBalance.nonzeroAddresses.length;&#13;
    }&#13;
&#13;
    // ------------------------------------------------------------------------&#13;
    // Get the amount owed for a specific api for a specific buyer&#13;
    // ------------------------------------------------------------------------&#13;
    function amountOwedForApiForBuyer(uint apiId, address buyerAddress) public view returns (uint) {&#13;
        APIBalance storage apiBalance = owed[apiId];&#13;
        return apiBalance.amounts[buyerAddress];&#13;
    }&#13;
&#13;
    // ------------------------------------------------------------------------&#13;
    // Get the total owed for an entire api for all nonzero buyers&#13;
    // ------------------------------------------------------------------------&#13;
    function totalOwedForApi(uint apiId) public view returns (uint) {&#13;
        APIBalance storage apiBalance = owed[apiId];&#13;
&#13;
        uint totalOwed = 0;&#13;
        for (uint i = 0; i &lt; apiBalance.nonzeroAddresses.length; i++) {&#13;
            address buyerAddress = apiBalance.nonzeroAddresses[i];&#13;
            uint buyerOwes = apiBalance.amounts[buyerAddress];&#13;
            totalOwed = totalOwed.add(buyerOwes);&#13;
        }&#13;
&#13;
        return totalOwed;&#13;
    }&#13;
&#13;
    // ------------------------------------------------------------------------&#13;
    // Gets the amount of wei per second a buyer has approved for a specific api&#13;
    // ------------------------------------------------------------------------&#13;
    function approvedAmount(uint apiId, address buyerAddress) public view returns (uint) {&#13;
        return buyers[buyerAddress].approvedAmounts[apiId];&#13;
    }&#13;
&#13;
    // ------------------------------------------------------------------------&#13;
    // Let the buyer set an approved amount of wei per second for a specific api&#13;
    // ------------------------------------------------------------------------&#13;
    function approveAmount(uint apiId, address buyerAddress, uint newAmount) public {&#13;
        require(buyerAddress != address(0) &amp;&amp; apiId != 0);&#13;
&#13;
        // only the buyer or the usage reporing system can change the buyers approval amount&#13;
        require(msg.sender == buyerAddress || msg.sender == usageReportingAddress);&#13;
&#13;
        BuyerInfo storage buyer = buyers[buyerAddress];&#13;
        buyer.approvedAmounts[apiId] = newAmount;&#13;
    }&#13;
&#13;
    // ------------------------------------------------------------------------&#13;
    // function to let the buyer set their approved amount of wei per second for an api&#13;
    // this function also lets the buyer set the time they last paid for an API if they've never paid that API before.  &#13;
    // this is important because the total amount approved for a given transaction is based on a wei per second spending limit&#13;
    // but the smart contract doesn't know when the buyer started using the API&#13;
    // so with this function, a buyer can et the time they first used the API and the approved amount calculations will be accurate when the seller requests payment.&#13;
    // ------------------------------------------------------------------------&#13;
    function approveAmountAndSetFirstUseTime(&#13;
        uint apiId, &#13;
        address buyerAddress, &#13;
        uint newAmount, &#13;
        uint firstUseTime&#13;
    ) &#13;
        public &#13;
    {&#13;
        require(buyerAddress != address(0) &amp;&amp; apiId != 0);&#13;
&#13;
        // only the buyer or the usage reporing system can change the buyers approval amount&#13;
        require(msg.sender == buyerAddress || msg.sender == usageReportingAddress);&#13;
&#13;
        APIBalance storage apiBalance = owed[apiId];&#13;
        require(apiBalance.buyerLastPaidAt[buyerAddress] == 0);&#13;
&#13;
        apiBalance.buyerLastPaidAt[buyerAddress] = firstUseTime;&#13;
        &#13;
        BuyerInfo storage buyer = buyers[buyerAddress];&#13;
        buyer.approvedAmounts[apiId] = newAmount;&#13;
&#13;
    }&#13;
&#13;
    // ------------------------------------------------------------------------&#13;
    // Gets whether or not a buyer exceeded their approved amount in the last seller payout&#13;
    // ------------------------------------------------------------------------&#13;
    function buyerExceededApprovedAmount(uint apiId, address buyerAddress) public view returns (bool) {&#13;
        return buyers[buyerAddress].exceededApprovedAmount[apiId];&#13;
    }&#13;
&#13;
    // ------------------------------------------------------------------------&#13;
    // Reward user with tokens IF the contract has them in it's allowance&#13;
    // ------------------------------------------------------------------------&#13;
    function rewardTokens(address toReward, uint amount) private {&#13;
        DeconetToken token = DeconetToken(tokenContractAddress);&#13;
        address tokenOwner = token.owner();&#13;
&#13;
        // check balance of tokenOwner&#13;
        uint tokenOwnerBalance = token.balanceOf(tokenOwner);&#13;
        uint tokenOwnerAllowance = token.allowance(tokenOwner, address(this));&#13;
        if (tokenOwnerBalance &gt;= amount &amp;&amp; tokenOwnerAllowance &gt;= amount) {&#13;
            token.transferFrom(tokenOwner, toReward, amount);&#13;
        }&#13;
    }&#13;
&#13;
    // ------------------------------------------------------------------------&#13;
    // Process and settle balances for a single buyer for a specific api&#13;
    // ------------------------------------------------------------------------&#13;
    function processSalesForSingleBuyer(uint apiId, address buyerAddress) private returns (uint) {&#13;
        APIBalance storage apiBalance = owed[apiId];&#13;
&#13;
        uint buyerOwes = apiBalance.amounts[buyerAddress];&#13;
        uint buyerLastPaidAtTime = apiBalance.buyerLastPaidAt[buyerAddress];&#13;
        if (buyerLastPaidAtTime == 0) {&#13;
            // if buyer has never paid, assume they paid a week ago.  or whatever now - defaultBuyerLastPaidAt is.&#13;
            buyerLastPaidAtTime = now - defaultBuyerLastPaidAt; // default is 604,800 = 7 days of seconds&#13;
        }&#13;
        uint elapsedSecondsSinceLastPayout = now - buyerLastPaidAtTime;&#13;
        uint buyerNowOwes = buyerOwes;&#13;
        uint buyerPaid = 0;&#13;
        bool overdrafted = false;&#13;
&#13;
        (buyerPaid, overdrafted) = chargeBuyer(apiId, buyerAddress, elapsedSecondsSinceLastPayout, buyerOwes);&#13;
&#13;
        buyerNowOwes = buyerOwes.sub(buyerPaid);&#13;
        apiBalance.amounts[buyerAddress] = buyerNowOwes;&#13;
&#13;
        // if the buyer now owes zero, then remove them from nonzeroAddresses&#13;
        if (buyerNowOwes != 0) {&#13;
            removeAddressFromNonzeroBalancesArray(apiId, buyerAddress);&#13;
        }&#13;
        // if the buyer paid nothing, we are done here.&#13;
        if (buyerPaid == 0) {&#13;
            return 0;&#13;
        }&#13;
&#13;
        // log the event&#13;
        emit LogSpendCredits(buyerAddress, apiId, buyerPaid, overdrafted);&#13;
&#13;
        // log that they paid&#13;
        apiBalance.buyerLastPaidAt[buyerAddress] = now;&#13;
        &#13;
        return buyerPaid;&#13;
    }&#13;
&#13;
    // ------------------------------------------------------------------------&#13;
    // Process and settle balances for all buyers with a nonzero balance for a specific api&#13;
    // ------------------------------------------------------------------------&#13;
    function processSalesForAllBuyers(uint apiId) private returns (uint totalPayable, uint totalBuyers) {&#13;
        APIBalance storage apiBalance = owed[apiId];&#13;
&#13;
        uint currentTime = now;&#13;
        address[] memory oldNonzeroAddresses = apiBalance.nonzeroAddresses;&#13;
        apiBalance.nonzeroAddresses = new address[](0);&#13;
&#13;
        for (uint i = 0; i &lt; oldNonzeroAddresses.length; i++) {&#13;
            address buyerAddress = oldNonzeroAddresses[i];&#13;
            uint buyerOwes = apiBalance.amounts[buyerAddress];&#13;
            uint buyerLastPaidAtTime = apiBalance.buyerLastPaidAt[buyerAddress];&#13;
            if (buyerLastPaidAtTime == 0) {&#13;
                // if buyer has never paid, assume they paid a week ago.  or whatever now - defaultBuyerLastPaidAt is.&#13;
                buyerLastPaidAtTime = now - defaultBuyerLastPaidAt; // default is 604,800 = 7 days of seconds&#13;
            }&#13;
            uint elapsedSecondsSinceLastPayout = currentTime - buyerLastPaidAtTime;&#13;
            uint buyerNowOwes = buyerOwes;&#13;
            uint buyerPaid = 0;&#13;
            bool overdrafted = false;&#13;
&#13;
            (buyerPaid, overdrafted) = chargeBuyer(apiId, buyerAddress, elapsedSecondsSinceLastPayout, buyerOwes);&#13;
&#13;
            totalPayable = totalPayable.add(buyerPaid);&#13;
            buyerNowOwes = buyerOwes.sub(buyerPaid);&#13;
            apiBalance.amounts[buyerAddress] = buyerNowOwes;&#13;
&#13;
            // if the buyer still owes something, make sure we keep them in the nonzeroAddresses array&#13;
            if (buyerNowOwes != 0) {&#13;
                apiBalance.nonzeroAddresses.push(buyerAddress);&#13;
            }&#13;
            // if the buyer paid more than 0, log the spend.&#13;
            if (buyerPaid != 0) {&#13;
                // log the event&#13;
                emit LogSpendCredits(buyerAddress, apiId, buyerPaid, overdrafted);&#13;
&#13;
                // log that they paid&#13;
                apiBalance.buyerLastPaidAt[buyerAddress] = now;&#13;
&#13;
                // add to total buyer count&#13;
                totalBuyers += 1;&#13;
            }&#13;
        }&#13;
    }&#13;
&#13;
    // ------------------------------------------------------------------------&#13;
    // given a specific buyer, api, and the amount they owe, we need to figure out how much to pay&#13;
    // the final amount paid is based on the chart below:&#13;
    // if credits &gt;= approved &gt;= owed then pay owed&#13;
    // if credits &gt;= owed &gt; approved then pay approved and mark as exceeded approved amount&#13;
    // if owed &gt; credits &gt;= approved then pay approved and mark as overdrafted&#13;
    // if owed &gt; approved &gt; credits then pay credits and mark as overdrafted&#13;
    // ------------------------------------------------------------------------&#13;
    function chargeBuyer(&#13;
        uint apiId, &#13;
        address buyerAddress, &#13;
        uint elapsedSecondsSinceLastPayout, &#13;
        uint buyerOwes&#13;
    ) &#13;
        private &#13;
        returns (&#13;
            uint paid, &#13;
            bool overdrafted&#13;
        ) &#13;
    {&#13;
        BuyerInfo storage buyer = buyers[buyerAddress];&#13;
        uint approvedAmountPerSecond = buyer.approvedAmounts[apiId];&#13;
        uint approvedAmountSinceLastPayout = approvedAmountPerSecond.mul(elapsedSecondsSinceLastPayout);&#13;
        &#13;
        // do we have the credits to pay owed?&#13;
        if (buyer.credits &gt;= buyerOwes) {&#13;
            // yay, buyer can pay their debits&#13;
            overdrafted = false;&#13;
            buyer.overdrafted = false;&#13;
&#13;
            // has buyer approved enough to pay what they owe?&#13;
            if (approvedAmountSinceLastPayout &gt;= buyerOwes) {&#13;
                // approved is greater than owed.  &#13;
                // mark as not exceeded approved amount&#13;
                buyer.exceededApprovedAmount[apiId] = false;&#13;
&#13;
                // we can pay the entire debt&#13;
                paid = buyerOwes;&#13;
&#13;
            } else {&#13;
                // they have no approved enough&#13;
                // mark as exceeded&#13;
                buyer.exceededApprovedAmount[apiId] = true;&#13;
                buyer.lifetimeExceededApprovalAmountCount += 1;&#13;
&#13;
                // we can only pay the approved portion of the debt&#13;
                paid = approvedAmountSinceLastPayout;&#13;
            }&#13;
        } else {&#13;
            // buyer spent more than they have.  mark as overdrafted&#13;
            overdrafted = true;&#13;
            buyer.overdrafted = true;&#13;
            buyer.lifetimeOverdraftCount += 1;&#13;
&#13;
            // does buyer have more credits than the amount they've approved?&#13;
            if (buyer.credits &gt;= approvedAmountSinceLastPayout) {&#13;
                // they have enough credits to pay approvedAmountSinceLastPayout, so pay that&#13;
                paid = approvedAmountSinceLastPayout;&#13;
&#13;
            } else {&#13;
                // the don't have enough credits to pay approvedAmountSinceLastPayout&#13;
                // so just pay whatever credits they have&#13;
                paid = buyer.credits;&#13;
            }&#13;
        }&#13;
&#13;
        buyer.credits = buyer.credits.sub(paid);&#13;
        buyer.lifetimeCreditsUsed = buyer.lifetimeCreditsUsed.add(paid);&#13;
    }&#13;
&#13;
    function removeAddressFromNonzeroBalancesArray(uint apiId, address toRemove) private {&#13;
        APIBalance storage apiBalance = owed[apiId];&#13;
&#13;
        bool foundElement = false;&#13;
&#13;
        for (uint i = 0; i &lt; apiBalance.nonzeroAddresses.length-1; i++) {&#13;
            if (apiBalance.nonzeroAddresses[i] == toRemove) {&#13;
                foundElement = true;&#13;
            }&#13;
            if (foundElement == true) {&#13;
                apiBalance.nonzeroAddresses[i] = apiBalance.nonzeroAddresses[i+1];&#13;
            }&#13;
        }&#13;
        if (foundElement == true) {&#13;
            apiBalance.nonzeroAddresses.length--;&#13;
        }&#13;
    }&#13;
}