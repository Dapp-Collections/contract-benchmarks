/// @title Store lederboards in the Blockchain
/// @author Marcel Scherello <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="bfddd3d0dcd4ccdcd0cddaccffccdcd7dacddad3d3d091dbda">[emailÂ protected]</a>&#13;
/// @notice Create a custom leaderboard and start counting the scores&#13;
/// @dev All function calls are currently implement without side effects&#13;
/// @dev v1.1.0&#13;
contract BlockScores {&#13;
    struct Player {&#13;
        bytes32  playerName;&#13;
        address playerAddress;&#13;
        uint  score;&#13;
        uint  score_unconfirmed;&#13;
        uint   isActive;&#13;
    }&#13;
    struct Board {&#13;
        bytes32  boardName;&#13;
        string  boardDescription;&#13;
        uint   numPlayers;&#13;
        address boardOwner;&#13;
        mapping (uint =&gt; Player) players;&#13;
    }&#13;
    mapping (bytes32 =&gt; Board) boards;&#13;
    uint public numBoards;&#13;
    address owner = msg.sender;&#13;
&#13;
    uint public balance;&#13;
    uint public boardCost = 1000000000000000;&#13;
    uint public playerCost = 1000000000000000;&#13;
&#13;
    modifier isOwner {&#13;
        assert(owner == msg.sender);&#13;
        _;&#13;
    }&#13;
&#13;
    /**&#13;
    Funding Functions&#13;
    */&#13;
&#13;
    /// @notice withdraw all funds to contract owner&#13;
    /// @return true&#13;
    function withdraw() isOwner public returns(bool) {&#13;
        uint _amount = address(this).balance;&#13;
        emit Withdrawal(owner, _amount);&#13;
        owner.transfer(_amount);&#13;
        balance -= _amount;&#13;
        return true;&#13;
    }&#13;
&#13;
    /// @notice change the costs for using the contract&#13;
    /// @param costBoard costs for a new board&#13;
    /// @param costPlayer costs for a new player&#13;
    /// @return true&#13;
    function setCosts (uint costBoard, uint costPlayer) isOwner public returns(bool) {&#13;
        boardCost = costBoard;&#13;
        playerCost = costPlayer;&#13;
        return true;&#13;
    }&#13;
&#13;
    /// @notice split the revenue of a new player between boardOwner and contract owner&#13;
    /// @param boardOwner of the leaderboard&#13;
    /// @param _amount amount to be split&#13;
    /// @return true&#13;
    function split(address boardOwner, uint _amount) internal returns(bool) {&#13;
        emit Withdrawal(owner, _amount/2);&#13;
        owner.transfer(_amount/2);&#13;
        //emit Withdrawal(boardOwner, _amount/2);&#13;
        boardOwner.transfer(_amount/2);&#13;
        return true;&#13;
    }&#13;
&#13;
    /// @notice Event for Withdrawal&#13;
    event Withdrawal(address indexed _from, uint _value);&#13;
&#13;
    /**&#13;
    Board Functions&#13;
    */&#13;
&#13;
    /// @notice Add a new leaderboard. Board hash will be created by name and creator&#13;
    /// @notice a funding is required to create a new leaderboard&#13;
    /// @param name The name of the leaderboard&#13;
    /// @param boardDescription A subtitle for the leaderboard&#13;
    /// @return The hash of the newly created leaderboard&#13;
    function addNewBoard(bytes32 name, string boardDescription) public payable returns(bytes32 boardHash){&#13;
        require(msg.value &gt;= boardCost);&#13;
        balance += msg.value;&#13;
        boardHash = keccak256(abi.encodePacked(name, msg.sender));&#13;
        numBoards++;&#13;
        boards[boardHash] = Board(name, boardDescription, 0, msg.sender);&#13;
        emit newBoardCreated(boardHash);&#13;
    }&#13;
&#13;
    /// @notice Simulate the creation of a leaderboard hash&#13;
    /// @param name The name of the leaderboard&#13;
    /// @param admin The address of the admin address&#13;
    /// @return The possible hash of the leaderboard&#13;
    function createBoardHash(bytes32 name, address admin) pure public returns (bytes32){&#13;
        return keccak256(abi.encodePacked(name, admin));&#13;
    }&#13;
&#13;
    /// @notice Get the metadata of a leaderboard&#13;
    /// @param boardHash The hash of the leaderboard&#13;
    /// @return Leaderboard name, description and number of players&#13;
    function getBoardByHash(bytes32 boardHash) constant public returns(bytes32,string,uint){&#13;
        return (boards[boardHash].boardName, boards[boardHash].boardDescription, boards[boardHash].numPlayers);&#13;
    }&#13;
&#13;
    /// @notice Overwrite leaderboard name and desctiption as owner only&#13;
    /// @param boardHash The hash of the leaderboard to be modified&#13;
    /// @param name The new name of the leaderboard&#13;
    /// @param boardDescription The new subtitle for the leaderboard&#13;
    /// @return true&#13;
    function changeBoardMetadata(bytes32 boardHash, bytes32 name, string boardDescription) public returns(bool) {&#13;
        require(boards[boardHash].boardOwner == msg.sender);&#13;
        boards[boardHash].boardName = name;&#13;
        boards[boardHash].boardDescription = boardDescription;&#13;
    }&#13;
&#13;
    /// @notice event for newly created leaderboard&#13;
    event newBoardCreated(bytes32 boardHash);&#13;
&#13;
&#13;
    /**&#13;
    Player Functions&#13;
    */&#13;
&#13;
    /// @notice Add a new player to an existing leaderboard&#13;
    /// @param boardHash The hash of the leaderboard&#13;
    /// @param playerName The name of the player&#13;
    /// @return Player ID&#13;
    function addPlayerToBoard(bytes32 boardHash, bytes32 playerName) public payable returns (bool) {&#13;
        require(msg.value &gt;= playerCost);&#13;
        Board storage g = boards[boardHash];&#13;
        split (g.boardOwner, msg.value);&#13;
        uint newPlayerID = g.numPlayers++;&#13;
        g.players[newPlayerID] = Player(playerName, msg.sender,0,0,1);&#13;
        return true;&#13;
    }&#13;
&#13;
    /// @notice Get player data by leaderboard hash and player id/index&#13;
    /// @param boardHash The hash of the leaderboard&#13;
    /// @param playerID Index number of the player&#13;
    /// @return Player name, confirmed score, unconfirmed score&#13;
    function getPlayerByBoard(bytes32 boardHash, uint8 playerID) constant public returns (bytes32, uint, uint){&#13;
        Player storage p = boards[boardHash].players[playerID];&#13;
        require(p.isActive == 1);&#13;
        return (p.playerName, p.score, p.score_unconfirmed);&#13;
    }&#13;
&#13;
    /// @notice The leaderboard owner can remove a player&#13;
    /// @param boardHash The hash of the leaderboard&#13;
    /// @param playerName The name of the player to be removed&#13;
    /// @return true/false&#13;
    function removePlayerFromBoard(bytes32 boardHash, bytes32 playerName) public returns (bool){&#13;
        Board storage g = boards[boardHash];&#13;
        require(g.boardOwner == msg.sender);&#13;
        uint8 playerID = getPlayerId (boardHash, playerName, 0);&#13;
        require(playerID &lt; 255 );&#13;
        g.players[playerID].isActive = 0;&#13;
        return true;&#13;
    }&#13;
&#13;
    /// @notice Get the player id either by player Name or address&#13;
    /// @param boardHash The hash of the leaderboard&#13;
    /// @param playerName The name of the player&#13;
    /// @param playerAddress The player address&#13;
    /// @return ID or 999 in case of false&#13;
    function getPlayerId (bytes32 boardHash, bytes32 playerName, address playerAddress) constant internal returns (uint8) {&#13;
        Board storage g = boards[boardHash];&#13;
        for (uint8 i = 0; i &lt;= g.numPlayers; i++) {&#13;
            if ((keccak256(abi.encodePacked(g.players[i].playerName)) == keccak256(abi.encodePacked(playerName)) || playerAddress == g.players[i].playerAddress) &amp;&amp; g.players[i].isActive == 1) {&#13;
                return i;&#13;
                break;&#13;
            }&#13;
        }&#13;
        return 255;&#13;
    }&#13;
&#13;
    /**&#13;
    Score Functions&#13;
    */&#13;
&#13;
    /// @notice Add a unconfirmed score to leaderboard/player. Overwrites an existing unconfirmed score&#13;
    /// @param boardHash The hash of the leaderboard&#13;
    /// @param playerName The name of the player&#13;
    /// @param score Integer&#13;
    /// @return true/false&#13;
    function addBoardScore(bytes32 boardHash, bytes32 playerName, uint score) public returns (bool){&#13;
        uint8 playerID = getPlayerId (boardHash, playerName, 0);&#13;
        require(playerID &lt; 255 );&#13;
        boards[boardHash].players[playerID].score_unconfirmed = score;&#13;
        return true;&#13;
    }&#13;
&#13;
    /// @notice Confirm an unconfirmed score to leaderboard/player. Adds unconfirmed to existing score. Player can not confirm his own score&#13;
    /// @param boardHash The hash of the leaderboard&#13;
    /// @param playerName The name of the player who's score should be confirmed&#13;
    /// @return true/false&#13;
    function confirmBoardScore(bytes32 boardHash, bytes32 playerName) public returns (bool){&#13;
        uint8 playerID = getPlayerId (boardHash, playerName, 0);&#13;
        uint8 confirmerID = getPlayerId (boardHash, "", msg.sender);&#13;
        require(playerID &lt; 255); // player needs to be active&#13;
        require(confirmerID &lt; 255); // confirmer needs to be active&#13;
        require(boards[boardHash].players[playerID].playerAddress != msg.sender); //confirm only other players&#13;
        boards[boardHash].players[playerID].score += boards[boardHash].players[playerID].score_unconfirmed;&#13;
        boards[boardHash].players[playerID].score_unconfirmed = 0;&#13;
        return true;&#13;
    }&#13;
&#13;
    /**&#13;
    Migration Functions&#13;
    */&#13;
    /// @notice Read board metadata for migration as contract owner only&#13;
    /// @param boardHash The hash of the leaderboard&#13;
    /// @return Bord metadata&#13;
    function migrationGetBoard(bytes32 boardHash) constant isOwner public returns(bytes32,string,uint,address) {&#13;
        return (boards[boardHash].boardName, boards[boardHash].boardDescription, boards[boardHash].numPlayers, boards[boardHash].boardOwner);&#13;
    }&#13;
&#13;
    /// @notice Write board metadata for migration as contract owner only&#13;
    /// @param boardHash The hash of the leaderboard to be modified&#13;
    /// @param name The new name of the leaderboard&#13;
    /// @param boardDescription The new subtitle for the leaderboard&#13;
    /// @param boardOwner The address for the boardowner&#13;
    /// @return true&#13;
    function migrationSetBoard(bytes32 boardHash, bytes32 name, string boardDescription, uint8 numPlayers, address boardOwner) isOwner public returns(bool) {&#13;
        boards[boardHash].boardName = name;&#13;
        boards[boardHash].boardDescription = boardDescription;&#13;
        boards[boardHash].numPlayers = numPlayers;&#13;
        boards[boardHash].boardOwner = boardOwner;&#13;
        return true;&#13;
    }&#13;
&#13;
    /// @notice Read player metadata for migration as contract owner&#13;
    /// @param boardHash The hash of the leaderboard&#13;
    /// @param playerID Index number of the player&#13;
    /// @return Player metadata&#13;
    function migrationGetPlayer(bytes32 boardHash, uint8 playerID) constant isOwner public returns (uint, bytes32, address, uint, uint, uint){&#13;
        Player storage p = boards[boardHash].players[playerID];&#13;
        return (playerID, p.playerName, p.playerAddress, p.score, p.score_unconfirmed, p.isActive);&#13;
    }&#13;
&#13;
    /// @notice Write player metadata for migration as contract owner only&#13;
    /// @param boardHash The hash of the leaderboard&#13;
    /// @param playerID Player ID&#13;
    /// @param playerName Player name&#13;
    /// @param playerAddress Player address&#13;
    /// @param score Player score&#13;
    /// @param score_unconfirmed Player unconfirmed score&#13;
    /// @param isActive Player isActive&#13;
    /// @return true&#13;
    function migrationSetPlayer(bytes32 boardHash, uint playerID, bytes32 playerName, address playerAddress, uint score, uint score_unconfirmed, uint isActive) isOwner public returns (bool) {&#13;
        Board storage g = boards[boardHash];&#13;
        g.players[playerID] = Player(playerName, playerAddress, score, score_unconfirmed, isActive);&#13;
        return true;&#13;
    }&#13;
&#13;
}