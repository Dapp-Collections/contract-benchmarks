pragma solidity ^0.4.18;

/************************************************** */
/* WhenHub Token Smart Contract                     */
/* Author: Nik Kalyani  <span class="__cf_email__" data-cfemail="b5dbdcdef5c2ddd0dbddc0d79bd6dad8">[email protected]</span>             */&#13;
/* Copyright (c) 2018 CalendarTree, Inc.            */&#13;
/* https://interface.whenhub.com                    */&#13;
/************************************************** */&#13;
contract WHENToken {&#13;
    using SafeMath for uint256;&#13;
&#13;
    mapping(address =&gt; uint256) balances;                               // Token balance for each address&#13;
    mapping (address =&gt; mapping (address =&gt; uint256)) internal allowed; // Approval granted to transfer tokens by one address to another address&#13;
&#13;
    /* ERC20 fields */&#13;
    string public name;&#13;
    string public symbol;&#13;
    uint public decimals = 18;&#13;
    string public sign = "￦";&#13;
    string public logoPng = "https://github.com/WhenHub/WHEN/raw/master/assets/when-token-icon.png";&#13;
&#13;
&#13;
    /* Each registered user on WhenHub Interface Network has a record in this contract */&#13;
    struct User {&#13;
        bool isRegistered;                                              // Flag to indicate user was registered &#13;
        uint256 seedJiffys;                                             // Tracks free tokens granted to user       &#13;
        uint256 interfaceEscrowJiffys;                                  // Tracks escrow tokens used in Interfaces      &#13;
        address referrer;                                               // Tracks who referred this user&#13;
    }&#13;
 &#13;
    // IcoBurnAuthorized is used to determine when remaining ICO tokens should be burned&#13;
    struct IcoBurnAuthorized {&#13;
        bool contractOwner;                                              // Flag to indicate ContractOwner has authorized&#13;
        bool platformManager;                                            // Flag to indicate PlatformManager has authorized&#13;
        bool icoOwner;                                                   // Flag to indicate SupportManager has authorized&#13;
    }&#13;
&#13;
    // PurchaseCredit is used to track purchases made by USD when user isn't already registered&#13;
    struct PurchaseCredit {&#13;
        uint256 jiffys;                                                  // Number of jiffys purchased&#13;
        uint256 purchaseTimestamp;                                       // Date/time of original purchase&#13;
    }&#13;
&#13;
    mapping(address =&gt; PurchaseCredit) purchaseCredits;                  // Temporary store for USD-purchased tokens&#13;
&#13;
    uint private constant ONE_WEEK = 604800;&#13;
    uint private constant SECONDS_IN_MONTH = 2629743;&#13;
    uint256 private constant ICO_START_TIMESTAMP = 1521471600; // 3/19/2018 08:00:00 PDT&#13;
&#13;
    uint private constant BASIS_POINTS_TO_PERCENTAGE = 10000;                         // All fees are expressed in basis points. This makes conversion easier&#13;
&#13;
    /* Token allocations per published WhenHub token economics */&#13;
    uint private constant ICO_TOKENS = 350000000;                              // Tokens available for public purchase&#13;
    uint private constant PLATFORM_TOKENS = 227500000;                         // Tokens available for network seeding&#13;
    uint private constant COMPANY_TOKENS = 262500000;                          // Tokens available to WhenHub for employees and future expansion&#13;
    uint private constant PARTNER_TOKENS = 17500000;                           // Tokens available for WhenHub partner inventives&#13;
    uint private constant FOUNDATION_TOKENS = 17500000;                        // Tokens available for WhenHub Foundationn charity&#13;
&#13;
    /* Network seeding tokens */&#13;
    uint constant INCENTIVE_TOKENS = 150000000;                         // Total pool of seed tokens for incentives&#13;
    uint constant REFERRAL_TOKENS = 77500000;                           // Total pool of seed tokens for referral&#13;
    uint256 private userSignupJiffys = 0;                                // Number of Jiffys per user who signs up&#13;
    uint256 private referralSignupJiffys = 0;                            // Number of Jiffys per user(x2) referrer + referree&#13;
   &#13;
    uint256 private jiffysMultiplier;                                   // 10 ** decimals&#13;
    uint256 private incentiveJiffysBalance;                             // Available balance of Jiffys for incentives&#13;
    uint256 private referralJiffysBalance;                              // Available balance of Jiffys for referrals&#13;
&#13;
    /* ICO variables */&#13;
    uint256 private bonus20EndTimestamp = 0;                             // End of 20% ICO token bonus timestamp&#13;
    uint256 private bonus10EndTimestamp = 0;                             // End of 10% ICO token bonus timestamp&#13;
    uint256 private bonus5EndTimestamp = 0;                              // End of 5% ICO token bonus timestamp&#13;
    uint private constant BUYER_REFERRER_BOUNTY = 3;                     // Referral bounty percentage&#13;
&#13;
    IcoBurnAuthorized icoBurnAuthorized = IcoBurnAuthorized(false, false, false);&#13;
&#13;
    /* Interface transaction settings */&#13;
    bool private operational = true;                                    // Blocks all state changes throughout the contract if false&#13;
                                                                        // Change using setOperatingStatus()&#13;
&#13;
    uint256 public winNetworkFeeBasisPoints = 0;                       // Per transaction fee deducted from payment to Expert&#13;
                                                                        // Change using setWinNetworkFeeBasisPoints()&#13;
&#13;
    uint256 public weiExchangeRate = 500000000000000;                  // Exchange rate for 1 WHEN Token in Wei ($0.25/￦)&#13;
                                                                        // Change using setWeiExchangeRate()&#13;
&#13;
    uint256 public centsExchangeRate = 25;                             // Exchange rate for 1 WHEN Token in cents&#13;
                                                                        // Change using setCentsExchangeRate()&#13;
&#13;
    /* State variables */&#13;
    address private contractOwner;                                      // Account used to deploy contract&#13;
    address private platformManager;                                    // Account used by API for Interface app&#13;
    address private icoOwner;                                           // Account from which ICO funds are disbursed&#13;
    address private supportManager;                                     // Account used by support team to reimburse users&#13;
    address private icoWallet;                                          // Account to which ICO ETH is sent&#13;
&#13;
    mapping(address =&gt; User) private users;                             // All registered users   &#13;
    mapping(address =&gt; uint256) private vestingEscrows;                 // Unvested tokens held in escrow&#13;
&#13;
    mapping(address =&gt; uint256) private authorizedContracts;            // Contracts authorized to call this one           &#13;
&#13;
    address[] private registeredUserLookup;                             // Lookup table of registered users     &#13;
&#13;
    /* ERC-20 Contract Events */&#13;
    event Approval          // Fired when an account authorizes another account to spend tokens on its behalf&#13;
                            (&#13;
                                address indexed owner, &#13;
                                address indexed spender, &#13;
                                uint256 value&#13;
                            );&#13;
&#13;
    event Transfer          // Fired when tokens are transferred from one account to another&#13;
                            (&#13;
                                address indexed from, &#13;
                                address indexed to, &#13;
                                uint256 value&#13;
                            );&#13;
&#13;
&#13;
    /* Interface app-specific Events */&#13;
    event UserRegister      // Fired when a new user account (wallet) is registered&#13;
                            (&#13;
                                address indexed user, &#13;
                                uint256 value,&#13;
                                uint256 seedJiffys&#13;
                            );                                 &#13;
&#13;
    event UserRefer         // Fired when tokens are granted to a user for referring a new user&#13;
                            (&#13;
                                address indexed user, &#13;
                                address indexed referrer, &#13;
                                uint256 value&#13;
                            );                             &#13;
&#13;
    event UserLink          // Fired when a previously existing user is linked to an account in the Interface DB&#13;
                            (&#13;
                                address indexed user&#13;
                            );&#13;
&#13;
&#13;
    /**&#13;
    * @dev Modifier that requires the "operational" boolean variable to be "true"&#13;
    *      This is used on all state changing functions to pause the contract in &#13;
    *      the event there is an issue that needs to be fixed&#13;
    */&#13;
    modifier requireIsOperational() &#13;
    {&#13;
        require(operational);&#13;
        _;&#13;
    }&#13;
&#13;
    /**&#13;
    * @dev Modifier that requires the "ContractOwner" account to be the function caller&#13;
    */&#13;
    modifier requireContractOwner()&#13;
    {&#13;
        require(msg.sender == contractOwner);&#13;
        _;&#13;
    }&#13;
&#13;
    /**&#13;
    * @dev Modifier that requires the "PlatformManager" account to be the function caller&#13;
    */&#13;
    modifier requirePlatformManager()&#13;
    {&#13;
        require(isPlatformManager(msg.sender));&#13;
        _;&#13;
    }&#13;
&#13;
&#13;
    /********************************************************************************************/&#13;
    /*                                       CONSTRUCTOR                                        */&#13;
    /********************************************************************************************/&#13;
&#13;
    /**&#13;
    * @dev Contract constructor&#13;
    *&#13;
    * @param tokenName ERC-20 token name&#13;
    * @param tokenSymbol ERC-20 token symbol&#13;
    * @param platformAccount Account for making calls from Interface API (i.e. PlatformManager)&#13;
    * @param icoAccount Account that holds ICO tokens (i.e. IcoOwner)&#13;
    * @param supportAccount Account with limited access to manage Interface user support (i.e. SupportManager)&#13;
    *&#13;
    */&#13;
    function WHENToken&#13;
                            ( &#13;
                                string tokenName, &#13;
                                string tokenSymbol, &#13;
                                address platformAccount, &#13;
                                address icoAccount,&#13;
                                address supportAccount&#13;
                            ) &#13;
                            public &#13;
    {&#13;
&#13;
        name = tokenName;&#13;
        symbol = tokenSymbol;&#13;
&#13;
        jiffysMultiplier = 10 ** uint256(decimals);                             // Multiplier used throughout contract&#13;
        incentiveJiffysBalance = INCENTIVE_TOKENS.mul(jiffysMultiplier);        // Network seeding tokens&#13;
        referralJiffysBalance = REFERRAL_TOKENS.mul(jiffysMultiplier);          // User referral tokens&#13;
&#13;
&#13;
        contractOwner = msg.sender;                                     // Owner of the contract&#13;
        platformManager = platformAccount;                              // API account for Interface&#13;
        icoOwner = icoAccount;                                          // Account with ICO tokens for settling Interface transactions&#13;
        icoWallet = icoOwner;                                           // Account to which ICO ETH is sent&#13;
        supportManager = supportAccount;                                // Support account with limited permissions&#13;
&#13;
                &#13;
        // Create user records for accounts&#13;
        users[contractOwner] = User(true, 0, 0, address(0));       &#13;
        registeredUserLookup.push(contractOwner);&#13;
&#13;
        users[platformManager] = User(true, 0, 0, address(0));   &#13;
        registeredUserLookup.push(platformManager);&#13;
&#13;
        users[icoOwner] = User(true, 0, 0, address(0));   &#13;
        registeredUserLookup.push(icoOwner);&#13;
&#13;
        users[supportManager] = User(true, 0, 0, address(0));   &#13;
        registeredUserLookup.push(supportManager);&#13;
&#13;
    }    &#13;
&#13;
    /**&#13;
    * @dev Contract constructor&#13;
    *&#13;
    * Initialize is to be called immediately after the supporting contracts are deployed.&#13;
    *&#13;
    * @param dataContract Address of the deployed InterfaceData contract&#13;
    * @param appContract Address of the deployed InterfaceApp contract&#13;
    * @param vestingContract Address of the deployed TokenVesting contract&#13;
    *&#13;
    */&#13;
    function initialize&#13;
                            (&#13;
                                address dataContract,&#13;
                                address appContract,&#13;
                                address vestingContract&#13;
                            )&#13;
                            external&#13;
                            requireContractOwner&#13;
    {        &#13;
        require(bonus20EndTimestamp == 0);      // Ensures function cannot be called twice&#13;
        authorizeContract(dataContract);        // Authorizes InterfaceData contract to make calls to this contract&#13;
        authorizeContract(appContract);         // Authorizes InterfaceApp contract to make calls to this contract&#13;
        authorizeContract(vestingContract);     // Authorizes TokenVesting contract to make calls to this contract&#13;
        &#13;
        bonus20EndTimestamp = ICO_START_TIMESTAMP.add(ONE_WEEK);&#13;
        bonus10EndTimestamp = bonus20EndTimestamp.add(ONE_WEEK);&#13;
        bonus5EndTimestamp = bonus10EndTimestamp.add(ONE_WEEK);&#13;
&#13;
        // ICO tokens are allocated without vesting to ICO account for distribution during sale&#13;
        balances[icoOwner] = ICO_TOKENS.mul(jiffysMultiplier);        &#13;
&#13;
        // Platform tokens (a.k.a. network seeding tokens) are allocated without vesting&#13;
        balances[platformManager] = balances[platformManager].add(PLATFORM_TOKENS.mul(jiffysMultiplier));        &#13;
&#13;
        // Allocate all other tokens to contract owner without vesting&#13;
        // These will be disbursed in initialize()&#13;
        balances[contractOwner] = balances[contractOwner].add((COMPANY_TOKENS + PARTNER_TOKENS + FOUNDATION_TOKENS).mul(jiffysMultiplier));&#13;
&#13;
        userSignupJiffys = jiffysMultiplier.mul(500);       // Initial signup incentive&#13;
        referralSignupJiffys = jiffysMultiplier.mul(100);   // Initial referral incentive&#13;
       &#13;
    }&#13;
&#13;
    /**&#13;
    * @dev Token allocations for various accounts&#13;
    *&#13;
    * Called from TokenVesting to grant tokens to each account&#13;
    *&#13;
    */&#13;
    function getTokenAllocations()&#13;
                                external&#13;
                                view&#13;
                                returns(uint256, uint256, uint256)&#13;
    {&#13;
        return (COMPANY_TOKENS.mul(jiffysMultiplier), PARTNER_TOKENS.mul(jiffysMultiplier), FOUNDATION_TOKENS.mul(jiffysMultiplier));&#13;
    }&#13;
&#13;
    /********************************************************************************************/&#13;
    /*                                       ERC20 TOKEN                                        */&#13;
    /********************************************************************************************/&#13;
&#13;
    /**&#13;
    * @dev Total supply of tokens&#13;
    */&#13;
    function totalSupply() &#13;
                            external &#13;
                            view &#13;
                            returns (uint) &#13;
    {&#13;
        uint256 total = ICO_TOKENS.add(PLATFORM_TOKENS).add(COMPANY_TOKENS).add(PARTNER_TOKENS).add(FOUNDATION_TOKENS);&#13;
        return total.mul(jiffysMultiplier);&#13;
    }&#13;
&#13;
    /**&#13;
    * @dev Gets the balance of the calling address.&#13;
    *&#13;
    * @return An uint256 representing the amount owned by the calling address&#13;
    */&#13;
    function balance()&#13;
                            public &#13;
                            view &#13;
                            returns (uint256) &#13;
    {&#13;
        return balanceOf(msg.sender);&#13;
    }&#13;
&#13;
    /**&#13;
    * @dev Gets the balance of the specified address.&#13;
    *&#13;
    * @param owner The address to query the balance of&#13;
    * @return An uint256 representing the amount owned by the passed address&#13;
    */&#13;
    function balanceOf&#13;
                            (&#13;
                                address owner&#13;
                            ) &#13;
                            public &#13;
                            view &#13;
                            returns (uint256) &#13;
    {&#13;
        return balances[owner];&#13;
    }&#13;
&#13;
    /**&#13;
    * @dev Transfers token for a specified address&#13;
    *&#13;
    * Constraints are added to ensure that tokens granted for network&#13;
    * seeding and tokens in escrow are not transferable&#13;
    *&#13;
    * @param to The address to transfer to.&#13;
    * @param value The amount to be transferred.&#13;
    * @return A bool indicating if the transfer was successful.&#13;
    */&#13;
    function transfer&#13;
                            (&#13;
                                address to, &#13;
                                uint256 value&#13;
                            ) &#13;
                            public &#13;
                            requireIsOperational &#13;
                            returns (bool) &#13;
    {&#13;
        require(to != address(0));&#13;
        require(to != msg.sender);&#13;
        require(value &lt;= transferableBalanceOf(msg.sender));                                         &#13;
&#13;
        balances[msg.sender] = balances[msg.sender].sub(value);&#13;
        balances[to] = balances[to].add(value);&#13;
        Transfer(msg.sender, to, value);&#13;
        return true;&#13;
    }&#13;
&#13;
    /**&#13;
    * @dev Transfers tokens from one address to another&#13;
    *&#13;
    * Constraints are added to ensure that tokens granted for network&#13;
    * seeding and tokens in escrow are not transferable&#13;
    *&#13;
    * @param from address The address which you want to send tokens from&#13;
    * @param to address The address which you want to transfer to&#13;
    * @param value uint256 the amount of tokens to be transferred&#13;
    * @return A bool indicating if the transfer was successful.&#13;
    */&#13;
    function transferFrom&#13;
                            (&#13;
                                address from, &#13;
                                address to, &#13;
                                uint256 value&#13;
                            ) &#13;
                            public &#13;
                            requireIsOperational &#13;
                            returns (bool) &#13;
    {&#13;
        require(from != address(0));&#13;
        require(value &lt;= allowed[from][msg.sender]);&#13;
        require(value &lt;= transferableBalanceOf(from));                                         &#13;
        require(to != address(0));&#13;
        require(from != to);&#13;
&#13;
        balances[from] = balances[from].sub(value);&#13;
        balances[to] = balances[to].add(value);&#13;
        allowed[from][msg.sender] = allowed[from][msg.sender].sub(value);&#13;
        Transfer(from, to, value);&#13;
        return true;&#13;
    }&#13;
&#13;
    /**&#13;
    * @dev Checks the amount of tokens that an owner allowed to a spender.&#13;
    *&#13;
    * @param owner address The address which owns the funds.&#13;
    * @param spender address The address which will spend the funds.&#13;
    * @return A uint256 specifying the amount of tokens still available for the spender.&#13;
    */&#13;
    function allowance&#13;
                            (&#13;
                                address owner, &#13;
                                address spender&#13;
                            ) &#13;
                            public &#13;
                            view &#13;
                            returns (uint256) &#13;
    {&#13;
        return allowed[owner][spender];&#13;
    }&#13;
&#13;
    /**&#13;
    * @dev Approves the passed address to spend the specified amount of tokens on behalf of msg.sender.&#13;
    *&#13;
    * Beware that changing an allowance with this method brings the risk that someone may use both the old&#13;
    * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this&#13;
    * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:&#13;
    * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729&#13;
    * @param spender The address which will spend the funds.&#13;
    * @param value The amount of tokens to be spent.&#13;
    * @return A bool indicating success (always returns true)&#13;
    */&#13;
    function approve&#13;
                            (&#13;
                                address spender, &#13;
                                uint256 value&#13;
                            ) &#13;
                            public &#13;
                            requireIsOperational &#13;
                            returns (bool) &#13;
    {&#13;
        allowed[msg.sender][spender] = value;&#13;
        Approval(msg.sender, spender, value);&#13;
        return true;&#13;
    }&#13;
&#13;
    /**&#13;
    * @dev Gets the balance of the specified address less greater of escrow tokens and free signup tokens.&#13;
    *&#13;
    * @param account The address to query the the balance of.&#13;
    * @return An uint256 representing the transferable amount owned by the passed address.&#13;
    */&#13;
    function transferableBalanceOf&#13;
                            (&#13;
                                address account&#13;
                            ) &#13;
                            public &#13;
                            view &#13;
                            returns (uint256) &#13;
    {&#13;
        require(account != address(0));&#13;
&#13;
        if (users[account].isRegistered) {&#13;
            uint256 restrictedJiffys = users[account].interfaceEscrowJiffys &gt;= users[account].seedJiffys ? users[account].interfaceEscrowJiffys : users[account].seedJiffys;&#13;
            return balances[account].sub(restrictedJiffys);&#13;
        }&#13;
        return balances[account];&#13;
    }&#13;
&#13;
   /**&#13;
    * @dev Gets the balance of the specified address less escrow tokens&#13;
    *&#13;
    * Since seed tokens can be used to pay for Interface transactions&#13;
    * this balance indicates what the user can afford to spend for such&#13;
    * "internal" transactions ignoring distinction between paid and signup tokens&#13;
    *&#13;
    * @param account The address to query the balance of.&#13;
    * @return An uint256 representing the spendable amount owned by the passed address.&#13;
    */ &#13;
    function spendableBalanceOf&#13;
                            (&#13;
                                address account&#13;
                            ) &#13;
                            public &#13;
                            view &#13;
                            returns(uint256) &#13;
    {&#13;
&#13;
        require(account != address(0));&#13;
&#13;
        if (users[account].isRegistered) {&#13;
            return balances[account].sub(users[account].interfaceEscrowJiffys);&#13;
        }&#13;
        return balances[account];&#13;
    }&#13;
&#13;
    /********************************************************************************************/&#13;
    /*                                  WHENHUB INTERFACE                                       */&#13;
    /********************************************************************************************/&#13;
&#13;
&#13;
   /**&#13;
    * @dev Get operating status of contract&#13;
    *&#13;
    * @return A bool that is the current operating status&#13;
    */      &#13;
    function isOperational() &#13;
                            public &#13;
                            view &#13;
                            returns(bool) &#13;
    {&#13;
        return operational;&#13;
    }&#13;
&#13;
   /**&#13;
    * @dev Sets contract operations on/off&#13;
    *&#13;
    * When operational mode is disabled, all write transactions except for this&#13;
    * one will fail&#13;
    * @return A bool that is the new operational mode&#13;
    */    &#13;
    function setOperatingStatus&#13;
                            (&#13;
                                bool mode&#13;
                            ) &#13;
                            external&#13;
                            requireContractOwner &#13;
    {&#13;
        operational = mode;&#13;
    }&#13;
&#13;
   /**&#13;
    * @dev Authorizes ICO end and burn of remaining tokens&#13;
    *&#13;
    * ContractOwner, PlatformManager and IcoOwner must each call this function&#13;
    * in any order. The third entity calling the function will cause the&#13;
    * icoOwner account balance to be reset to 0.&#13;
    */ &#13;
    function authorizeIcoBurn() &#13;
                            external&#13;
    {&#13;
        require(balances[icoOwner] &gt; 0);&#13;
        require((msg.sender == contractOwner) || (msg.sender == platformManager) || (msg.sender == icoOwner));&#13;
&#13;
        if (msg.sender == contractOwner) {&#13;
            icoBurnAuthorized.contractOwner = true;&#13;
        } else if (msg.sender == platformManager) {&#13;
            icoBurnAuthorized.platformManager = true;&#13;
        } else if (msg.sender == icoOwner) {&#13;
            icoBurnAuthorized.icoOwner = true;&#13;
        }&#13;
&#13;
        if (icoBurnAuthorized.contractOwner &amp;&amp; icoBurnAuthorized.platformManager &amp;&amp; icoBurnAuthorized.icoOwner) {&#13;
            balances[icoOwner] = 0;&#13;
        }&#13;
    }&#13;
&#13;
   /**&#13;
    * @dev Sets fee used in Interface transactions&#13;
    *&#13;
    * A network fee is charged for each transaction represented&#13;
    * as a percentage of the total fee payable to Experts. This fee&#13;
    * is deducted from the amount paid by Callers to Experts.&#13;
    * @param basisPoints The fee percentage expressed as basis points&#13;
    */    &#13;
    function setWinNetworkFee&#13;
                            (&#13;
                                uint256 basisPoints&#13;
                            ) &#13;
                            external &#13;
                            requireIsOperational &#13;
                            requireContractOwner&#13;
    {&#13;
        require(basisPoints &gt;= 0);&#13;
&#13;
        winNetworkFeeBasisPoints = basisPoints;&#13;
    }&#13;
&#13;
    /**&#13;
    * @dev Sets signup tokens allocated for each user (based on availability)&#13;
    *&#13;
    * @param tokens The number of tokens each user gets&#13;
    */    &#13;
    function setUserSignupTokens&#13;
                            (&#13;
                                uint256 tokens&#13;
                            ) &#13;
                            external &#13;
                            requireIsOperational &#13;
                            requireContractOwner&#13;
    {&#13;
        require(tokens &lt;= 10000);&#13;
&#13;
        userSignupJiffys = jiffysMultiplier.mul(tokens);&#13;
    }&#13;
&#13;
    /**&#13;
    * @dev Sets signup tokens allocated for each user (based on availability)&#13;
    *&#13;
    * @param tokens The number of tokens each referrer and referree get&#13;
    */    &#13;
    function setReferralSignupTokens&#13;
                            (&#13;
                                uint256 tokens&#13;
                            ) &#13;
                            external &#13;
                            requireIsOperational &#13;
                            requireContractOwner&#13;
    {&#13;
        require(tokens &lt;= 10000);&#13;
&#13;
        referralSignupJiffys = jiffysMultiplier.mul(tokens);&#13;
    }&#13;
&#13;
    /**&#13;
    * @dev Sets wallet to which ICO ETH funds are sent&#13;
    *&#13;
    * @param account The address to which ETH funds are sent&#13;
    */    &#13;
    function setIcoWallet&#13;
                            (&#13;
                                address account&#13;
                            ) &#13;
                            external &#13;
                            requireIsOperational &#13;
                            requireContractOwner&#13;
    {&#13;
        require(account != address(0));&#13;
&#13;
        icoWallet = account;&#13;
    }&#13;
&#13;
    /**&#13;
    * @dev Authorizes a smart contract to call this contract&#13;
    *&#13;
    * @param account Address of the calling smart contract&#13;
    */&#13;
    function authorizeContract&#13;
                            (&#13;
                                address account&#13;
                            ) &#13;
                            public &#13;
                            requireIsOperational &#13;
                            requireContractOwner&#13;
    {&#13;
        require(account != address(0));&#13;
&#13;
        authorizedContracts[account] = 1;&#13;
    }&#13;
&#13;
    /**&#13;
    * @dev Deauthorizes a previously authorized smart contract from calling this contract&#13;
    *&#13;
    * @param account Address of the calling smart contract&#13;
    */&#13;
    function deauthorizeContract&#13;
                            (&#13;
                                address account&#13;
                            ) &#13;
                            external &#13;
                            requireIsOperational&#13;
                            requireContractOwner &#13;
    {&#13;
        require(account != address(0));&#13;
&#13;
        delete authorizedContracts[account];&#13;
    }&#13;
&#13;
    /**&#13;
    * @dev Checks if a contract is authorized to call this contract&#13;
    *&#13;
    * @param account Address of the calling smart contract&#13;
    */&#13;
    function isContractAuthorized&#13;
                            (&#13;
                                address account&#13;
                            ) &#13;
                            public &#13;
                            view&#13;
                            returns(bool) &#13;
    {&#13;
        return authorizedContracts[account] == 1;&#13;
    }&#13;
&#13;
    /**&#13;
    * @dev Sets the Wei to WHEN exchange rate &#13;
    *&#13;
    * @param rate Number of Wei for one WHEN token&#13;
    */&#13;
    function setWeiExchangeRate&#13;
                            (&#13;
                                uint256 rate&#13;
                            ) &#13;
                            external &#13;
                            requireIsOperational&#13;
                            requireContractOwner&#13;
    {&#13;
        require(rate &gt;= 0); // Cannot set to less than 0.0001 ETH/￦&#13;
&#13;
        weiExchangeRate = rate;&#13;
    }&#13;
&#13;
    /**&#13;
    * @dev Sets the U.S. cents to WHEN exchange rate &#13;
    *&#13;
    * @param rate Number of cents for one WHEN token&#13;
    */&#13;
    function setCentsExchangeRate&#13;
                            (&#13;
                                uint256 rate&#13;
                            ) &#13;
                            external &#13;
                            requireIsOperational&#13;
                            requireContractOwner&#13;
    {&#13;
        require(rate &gt;= 1);&#13;
&#13;
        centsExchangeRate = rate;&#13;
    }&#13;
&#13;
    /**&#13;
    * @dev Sets the account that will be used for Platform Manager functions &#13;
    *&#13;
    * @param account Account to replace existing Platform Manager&#13;
    */&#13;
    function setPlatformManager&#13;
                            (&#13;
                                address account&#13;
                            ) &#13;
                            external &#13;
                            requireIsOperational&#13;
                            requireContractOwner&#13;
    {&#13;
        require(account != address(0));&#13;
        require(account != platformManager);&#13;
&#13;
        balances[account] = balances[account].add(balances[platformManager]);&#13;
        balances[platformManager] = 0;&#13;
&#13;
        if (!users[account].isRegistered) {&#13;
            users[account] = User(true, 0, 0, address(0)); &#13;
            registeredUserLookup.push(account);&#13;
        }&#13;
&#13;
        platformManager = account; &#13;
    }&#13;
&#13;
    /**&#13;
    * @dev Checks if an account is the PlatformManager &#13;
    *&#13;
    * @param account Account to check&#13;
    */&#13;
    function isPlatformManager&#13;
                            (&#13;
                                address account&#13;
                            ) &#13;
                            public&#13;
                            view &#13;
                            returns(bool) &#13;
    {&#13;
        return account == platformManager;&#13;
    }&#13;
&#13;
    /**&#13;
    * @dev Checks if an account is the PlatformManager or SupportManager&#13;
    *&#13;
    * @param account Account to check&#13;
    */&#13;
    function isPlatformOrSupportManager&#13;
                            (&#13;
                                address account&#13;
                            ) &#13;
                            public&#13;
                            view &#13;
                            returns(bool) &#13;
    {&#13;
        return (account == platformManager) || (account == supportManager);&#13;
    }&#13;
&#13;
    /**&#13;
    * @dev Gets address of SupportManager&#13;
    *&#13;
    */&#13;
    function getSupportManager()&#13;
                            public&#13;
                            view &#13;
                            returns(address) &#13;
    {&#13;
        return supportManager;&#13;
    }&#13;
&#13;
&#13;
    /**&#13;
    * @dev Checks if referral tokens are available&#13;
    *&#13;
    * referralSignupTokens is doubled because both referrer&#13;
    * and recipient get referral tokens&#13;
    *&#13;
    * @return A bool indicating if referral tokens are available&#13;
    */    &#13;
    function isReferralSupported() &#13;
                            public &#13;
                            view &#13;
                            returns(bool) &#13;
    {&#13;
        uint256 requiredJiffys = referralSignupJiffys.mul(2);&#13;
        return (referralJiffysBalance &gt;= requiredJiffys) &amp;&amp; (balances[platformManager] &gt;= requiredJiffys);&#13;
    }&#13;
&#13;
    /**&#13;
    * @dev Checks if user is a registered user&#13;
    *&#13;
    * @param account The address which owns the funds.&#13;
    * @return A bool indicating if user is a registered user.&#13;
    */&#13;
    function isUserRegistered&#13;
                            (&#13;
                                address account&#13;
                            ) &#13;
                            public &#13;
                            view &#13;
                            returns(bool) &#13;
    {&#13;
        return (account != address(0)) &amp;&amp; users[account].isRegistered;&#13;
    }&#13;
&#13;
    /**&#13;
    * @dev Checks pre-reqs and handles user registration&#13;
    *&#13;
    * @param account The address which is to be registered&#13;
    * @param creditAccount The address which contains token credits from CC purchase&#13;
    * @param referrer The address referred the account&#13;
    */&#13;
    function processRegisterUser&#13;
                            (&#13;
                                address account, &#13;
                                address creditAccount,&#13;
                                address referrer&#13;
                            ) &#13;
                            private&#13;
    {&#13;
        require(account != address(0));                                             // No invalid account&#13;
        require(!users[account].isRegistered);                                      // No double registration&#13;
        require(referrer == address(0) ? true : users[referrer].isRegistered);      // Referrer, if present, must be a registered user&#13;
        require(referrer != account);                                               // User can't refer her/himself&#13;
&#13;
        // Initialize user with restricted jiffys&#13;
        users[account] = User(true, 0, 0, referrer);&#13;
        registeredUserLookup.push(account);&#13;
&#13;
&#13;
        if (purchaseCredits[creditAccount].jiffys &gt; 0) {&#13;
            processPurchase(creditAccount, account, purchaseCredits[creditAccount].jiffys, purchaseCredits[creditAccount].purchaseTimestamp);&#13;
            purchaseCredits[creditAccount].jiffys = 0;&#13;
            delete purchaseCredits[creditAccount];&#13;
        }&#13;
&#13;
    }&#13;
&#13;
    /**&#13;
    * @dev Registers a user wallet with a referrer and deposits any applicable signup tokens&#13;
    *&#13;
    * @param account The wallet address&#13;
    * @param creditAccount The address containing any tokens purchased with USD&#13;
    * @param referrer The referring user address&#13;
    * @return A uint256 with the user's token balance&#13;
    */ &#13;
    function registerUser&#13;
                            (&#13;
                                address account, &#13;
                                address creditAccount,&#13;
                                address referrer&#13;
                            ) &#13;
                            public &#13;
                            requireIsOperational &#13;
                            requirePlatformManager &#13;
                            returns(uint256) &#13;
    {&#13;
                                    &#13;
        processRegisterUser(account, creditAccount, referrer);&#13;
        UserRegister(account, balanceOf(account), 0);          // Fire event&#13;
&#13;
        return balanceOf(account);&#13;
    }&#13;
&#13;
    /**&#13;
    * @dev Registers a user wallet with a referrer and deposits any applicable bonus tokens&#13;
    *&#13;
    * @param account The wallet address&#13;
    * @param creditAccount The address containing any tokens purchased with USD&#13;
    * @param referrer The referring user address&#13;
    * @return A uint256 with the user's token balance&#13;
    */&#13;
    function registerUserBonus&#13;
                            (&#13;
                                address account, &#13;
                                address creditAccount,&#13;
                                address referrer&#13;
                            ) &#13;
                            external &#13;
                            requireIsOperational &#13;
                            requirePlatformManager &#13;
                            returns(uint256) &#13;
    {&#13;
        &#13;
        processRegisterUser(account, creditAccount, referrer);&#13;
&#13;
        &#13;
        // Allocate if there are any remaining signup tokens&#13;
        uint256 jiffys = 0;&#13;
        if ((incentiveJiffysBalance &gt;= userSignupJiffys) &amp;&amp; (balances[platformManager] &gt;= userSignupJiffys)) {&#13;
            incentiveJiffysBalance = incentiveJiffysBalance.sub(userSignupJiffys);&#13;
            users[account].seedJiffys = users[account].seedJiffys.add(userSignupJiffys);&#13;
            transfer(account, userSignupJiffys);&#13;
            jiffys = userSignupJiffys;&#13;
        }&#13;
&#13;
        UserRegister(account, balanceOf(account), jiffys);          // Fire event&#13;
&#13;
       // Allocate referral tokens for both user and referrer if available       &#13;
       if ((referrer != address(0)) &amp;&amp; isReferralSupported()) {&#13;
            referralJiffysBalance = referralJiffysBalance.sub(referralSignupJiffys.mul(2));&#13;
&#13;
            // Referal tokens are restricted so it is necessary to update user's account&#13;
            transfer(referrer, referralSignupJiffys);&#13;
            users[referrer].seedJiffys = users[referrer].seedJiffys.add(referralSignupJiffys);&#13;
&#13;
            transfer(account, referralSignupJiffys);&#13;
            users[account].seedJiffys = users[account].seedJiffys.add(referralSignupJiffys);&#13;
&#13;
            UserRefer(account, referrer, referralSignupJiffys);     // Fire event&#13;
        }&#13;
&#13;
        return balanceOf(account);&#13;
    }&#13;
&#13;
    /**&#13;
    * @dev Adds Jiffys to escrow for a user&#13;
    *&#13;
    * Escrows track the number of Jiffys that the user may owe another user.&#13;
    * This function is called by the InterfaceData contract when a caller&#13;
    * subscribes to a call.&#13;
    *&#13;
    * @param account The wallet address&#13;
    * @param jiffys The number of Jiffys to put into escrow&#13;
    */ &#13;
    function depositEscrow&#13;
                            (&#13;
                                address account, &#13;
                                uint256 jiffys&#13;
                            ) &#13;
                            external &#13;
                            requireIsOperational &#13;
    {&#13;
        if (jiffys &gt; 0) {&#13;
            require(isContractAuthorized(msg.sender) || isPlatformManager(msg.sender));   &#13;
            require(isUserRegistered(account));                                                     &#13;
            require(spendableBalanceOf(account) &gt;= jiffys);&#13;
&#13;
            users[account].interfaceEscrowJiffys = users[account].interfaceEscrowJiffys.add(jiffys);&#13;
        }&#13;
    }&#13;
&#13;
    /**&#13;
    * @dev Refunds Jiffys from escrow for a user&#13;
    *&#13;
    * This function is called by the InterfaceData contract when a caller&#13;
    * unsubscribes from a call.&#13;
    *&#13;
    * @param account The wallet address&#13;
    * @param jiffys The number of Jiffys to remove from escrow&#13;
    */ &#13;
    function refundEscrow&#13;
                            (&#13;
                                address account, &#13;
                                uint256 jiffys&#13;
                            ) &#13;
                            external &#13;
                            requireIsOperational &#13;
    {&#13;
        if (jiffys &gt; 0) {&#13;
            require(isContractAuthorized(msg.sender) || isPlatformManager(msg.sender));   &#13;
            require(isUserRegistered(account));                                                     &#13;
            require(users[account].interfaceEscrowJiffys &gt;= jiffys);&#13;
&#13;
            users[account].interfaceEscrowJiffys = users[account].interfaceEscrowJiffys.sub(jiffys);&#13;
        }&#13;
    }&#13;
&#13;
    /**&#13;
    * @dev Handles payment for an Interface transaction&#13;
    *&#13;
    * This function is called by the InterfaceData contract when the front-end&#13;
    * application makes a settle() call indicating that the transaction is&#13;
    * complete and it's time to pay the Expert. To prevent unauthorized use&#13;
    * the function is only callable by a previously authorized contract and&#13;
    * is limited to paying out funds previously escrowed.&#13;
    *&#13;
    * @param payer The account paying (i.e. a caller)&#13;
    * @param payee The account being paid (i.e. the Expert)&#13;
    * @param referrer The account that referred payer to payee&#13;
    * @param referralFeeBasisPoints The referral fee payable to referrer&#13;
    * @param billableJiffys The number of Jiffys for payment&#13;
    * @param escrowJiffys The number of Jiffys held in escrow for Interface being paid&#13;
    */ &#13;
    function pay&#13;
                            (&#13;
                                address payer, &#13;
                                address payee, &#13;
                                address referrer, &#13;
                                uint256 referralFeeBasisPoints, &#13;
                                uint256 billableJiffys,&#13;
                                uint256 escrowJiffys&#13;
                            ) &#13;
                            external &#13;
                            requireIsOperational &#13;
                            returns(uint256, uint256)&#13;
    {&#13;
        require(isContractAuthorized(msg.sender));   &#13;
        require(billableJiffys &gt;= 0);&#13;
        require(users[payer].interfaceEscrowJiffys &gt;= billableJiffys);  // Only payment of Interface escrowed funds is allowed&#13;
        require(users[payee].isRegistered);&#13;
&#13;
        // This function may be called if the Expert's surety is&#13;
        // being forfeited. In that case, the payment is made to the &#13;
        // Support and then funds will be distributed as appropriate&#13;
        // to parties following a grievance process. Since the rules &#13;
        // for forfeiture can get very complex, they are best handled &#13;
        // off-contract. payee == supportManager indicates a forfeiture.&#13;
&#13;
&#13;
        // First, release Payer escrow&#13;
        users[payer].interfaceEscrowJiffys = users[payer].interfaceEscrowJiffys.sub(escrowJiffys);&#13;
        uint256 referralFeeJiffys = 0;&#13;
        uint256 winNetworkFeeJiffys = 0;&#13;
&#13;
        if (billableJiffys &gt; 0) {&#13;
&#13;
            // Second, pay the payee&#13;
            processPayment(payer, payee, billableJiffys);&#13;
&#13;
            // Payee is SupportManager if Expert surety is being forfeited, so skip referral and network fees&#13;
            if (payee != supportManager) {&#13;
&#13;
                // Third, Payee pays Referrer and referral fees due&#13;
                if ((referralFeeBasisPoints &gt; 0) &amp;&amp; (referrer != address(0)) &amp;&amp; (users[referrer].isRegistered)) {&#13;
                    referralFeeJiffys = billableJiffys.mul(referralFeeBasisPoints).div(BASIS_POINTS_TO_PERCENTAGE); // Basis points to percentage conversion&#13;
                    processPayment(payee, referrer, referralFeeJiffys);&#13;
                }&#13;
&#13;
                // Finally, Payee pays contract owner WIN network fee&#13;
                if (winNetworkFeeBasisPoints &gt; 0) {&#13;
                    winNetworkFeeJiffys = billableJiffys.mul(winNetworkFeeBasisPoints).div(BASIS_POINTS_TO_PERCENTAGE); // Basis points to percentage conversion&#13;
                    processPayment(payee, contractOwner, winNetworkFeeJiffys);&#13;
                }                    &#13;
            }&#13;
        }&#13;
&#13;
        return(referralFeeJiffys, winNetworkFeeJiffys);&#13;
    }&#13;
    &#13;
    /**&#13;
    * @dev Handles actual token transfer for payment&#13;
    *&#13;
    * @param payer The account paying&#13;
    * @param payee The account being paid&#13;
    * @param jiffys The number of Jiffys for payment&#13;
    */     &#13;
    function processPayment&#13;
                               (&#13;
                                   address payer,&#13;
                                   address payee,&#13;
                                   uint256 jiffys&#13;
                               )&#13;
                               private&#13;
    {&#13;
        require(isUserRegistered(payer));&#13;
        require(isUserRegistered(payee));&#13;
        require(spendableBalanceOf(payer) &gt;= jiffys);&#13;
&#13;
        balances[payer] = balances[payer].sub(jiffys); &#13;
        balances[payee] = balances[payee].add(jiffys);&#13;
        Transfer(payer, payee, jiffys);&#13;
&#13;
        // In the event the payer had received any signup tokens, their value&#13;
        // would be stored in the seedJiffys property. When any contract payment&#13;
        // is made, we reduce the seedJiffys number. seedJiffys tracks how many&#13;
        // tokens are not allowed to be transferred out of an account. As a user&#13;
        // makes payments to other users, those tokens have served their purpose&#13;
        // of encouraging use of the network and are no longer are restricted.&#13;
        if (users[payer].seedJiffys &gt;= jiffys) {&#13;
            users[payer].seedJiffys = users[payer].seedJiffys.sub(jiffys);&#13;
        } else {&#13;
            users[payer].seedJiffys = 0;&#13;
        }&#13;
           &#13;
    }&#13;
&#13;
    /**&#13;
    * @dev Handles transfer of tokens for vesting grants&#13;
    *&#13;
    * This function is called by the TokenVesting contract. To prevent unauthorized &#13;
    * use the function is only callable by a previously authorized contract.&#13;
    *&#13;
    * @param issuer The account granting tokens&#13;
    * @param beneficiary The account being granted tokens&#13;
    * @param vestedJiffys The number of vested Jiffys for immediate payment&#13;
    * @param unvestedJiffys The number of unvested Jiffys to be placed in escrow&#13;
    */     &#13;
    function vestingGrant&#13;
                            (&#13;
                                address issuer, &#13;
                                address beneficiary, &#13;
                                uint256 vestedJiffys,&#13;
                                uint256 unvestedJiffys&#13;
                            ) &#13;
                            external &#13;
                            requireIsOperational &#13;
    {&#13;
        require(isContractAuthorized(msg.sender));   &#13;
        require(spendableBalanceOf(issuer) &gt;= unvestedJiffys.add(vestedJiffys));&#13;
&#13;
&#13;
        // Any vestedJiffys are transferred immediately to the beneficiary&#13;
        if (vestedJiffys &gt; 0) {&#13;
            balances[issuer] = balances[issuer].sub(vestedJiffys);&#13;
            balances[beneficiary] = balances[beneficiary].add(vestedJiffys);&#13;
            Transfer(issuer, beneficiary, vestedJiffys);&#13;
        }&#13;
&#13;
        // Any unvestedJiffys are removed from the granting account balance&#13;
        // A corresponding number of Jiffys is added to the granting account's&#13;
        // vesting escrow balance.&#13;
        balances[issuer] = balances[issuer].sub(unvestedJiffys);&#13;
        vestingEscrows[issuer] = vestingEscrows[issuer].add(unvestedJiffys);&#13;
    }&#13;
&#13;
&#13;
    /**&#13;
    * @dev Handles transfer of tokens for vesting revokes and releases&#13;
    *&#13;
    * This function is called by the TokenVesting contract. To prevent unauthorized &#13;
    * use the function is only callable by a previously authorized contract.&#13;
    *&#13;
    * @param issuer The account granting tokens&#13;
    * @param beneficiary The account being granted tokens&#13;
    * @param jiffys The number of Jiffys for release or revoke&#13;
    */     &#13;
    function vestingTransfer&#13;
                            (&#13;
                                address issuer, &#13;
                                address beneficiary, &#13;
                                uint256 jiffys&#13;
                            ) &#13;
                            external &#13;
                            requireIsOperational &#13;
    {&#13;
        require(isContractAuthorized(msg.sender));   &#13;
        require(vestingEscrows[issuer] &gt;= jiffys);&#13;
&#13;
        vestingEscrows[issuer] = vestingEscrows[issuer].sub(jiffys);&#13;
        balances[beneficiary] = balances[beneficiary].add(jiffys);&#13;
        Transfer(issuer, beneficiary, jiffys);&#13;
    }&#13;
&#13;
&#13;
    /**&#13;
    * @dev Gets an array of addresses registered with contract&#13;
    *&#13;
    * This can be used by API to enumerate all users&#13;
    */   &#13;
    function getRegisteredUsers() &#13;
                                external &#13;
                                view &#13;
                                requirePlatformManager &#13;
                                returns(address[]) &#13;
    {&#13;
        return registeredUserLookup;&#13;
    }&#13;
&#13;
&#13;
    /**&#13;
    * @dev Gets an array of addresses registered with contract&#13;
    *&#13;
    * This can be used by API to enumerate all users&#13;
    */   &#13;
    function getRegisteredUser&#13;
                                (&#13;
                                    address account&#13;
                                ) &#13;
                                external &#13;
                                view &#13;
                                requirePlatformManager                                &#13;
                                returns(uint256, uint256, uint256, address) &#13;
    {&#13;
        require(users[account].isRegistered);&#13;
&#13;
        return (balances[account], users[account].seedJiffys, users[account].interfaceEscrowJiffys, users[account].referrer);&#13;
    }&#13;
&#13;
&#13;
    /**&#13;
    * @dev Returns ICO-related state information for use by API&#13;
    */ &#13;
    function getIcoInfo()&#13;
                                  public&#13;
                                  view&#13;
                                  returns(bool, uint256, uint256, uint256, uint256, uint256)&#13;
    {&#13;
        return (&#13;
                    balances[icoOwner] &gt; 0, &#13;
                    weiExchangeRate, &#13;
                    centsExchangeRate, &#13;
                    bonus20EndTimestamp, &#13;
                    bonus10EndTimestamp, &#13;
                    bonus5EndTimestamp&#13;
                );&#13;
    }&#13;
&#13;
    /********************************************************************************************/&#13;
    /*                                       TOKEN SALE                                         */&#13;
    /********************************************************************************************/&#13;
&#13;
    /**&#13;
    * @dev Fallback function for buying ICO tokens. This is not expected to be called with&#13;
    *      default gas as it will most certainly fail.&#13;
    *&#13;
    */&#13;
    function() &#13;
                            external &#13;
                            payable &#13;
    {&#13;
        buy(msg.sender);&#13;
    }&#13;
&#13;
&#13;
    /**&#13;
    * @dev Buy ICO tokens&#13;
    *&#13;
    * @param account Account that is buying tokens&#13;
    *&#13;
    */&#13;
    function buy&#13;
                            (&#13;
                                address account&#13;
                            ) &#13;
                            public &#13;
                            payable &#13;
                            requireIsOperational &#13;
    {&#13;
        require(balances[icoOwner] &gt; 0);&#13;
        require(account != address(0));        &#13;
        require(msg.value &gt;= weiExchangeRate);    // Minimum 1 token&#13;
&#13;
        uint256 weiReceived = msg.value;&#13;
&#13;
        // Convert Wei to Jiffys based on the exchange rate&#13;
        uint256 buyJiffys = weiReceived.mul(jiffysMultiplier).div(weiExchangeRate);&#13;
        processPurchase(icoOwner, account, buyJiffys, now);&#13;
        icoWallet.transfer(msg.value);&#13;
    }&#13;
&#13;
&#13;
    /**&#13;
    * @dev Buy ICO tokens with USD&#13;
    *&#13;
    * @param account Account that is buying tokens&#13;
    * @param cents Purchase amount in cents&#13;
    *&#13;
    */    &#13;
    function buyUSD&#13;
                            (&#13;
                                address account,&#13;
                                uint256 cents&#13;
                            ) &#13;
                            public &#13;
                            requireIsOperational &#13;
                            requirePlatformManager&#13;
    {&#13;
        require(balances[icoOwner] &gt; 0);&#13;
        require(account != address(0));        &#13;
        require(cents &gt;= centsExchangeRate);    // Minimum 1 token&#13;
&#13;
&#13;
&#13;
        // Convert Cents to Jiffys based on the exchange rate&#13;
        uint256 buyJiffys = cents.mul(jiffysMultiplier).div(centsExchangeRate);&#13;
&#13;
        if (users[account].isRegistered) {&#13;
            processPurchase(icoOwner, account, buyJiffys, now);&#13;
        } else {&#13;
            // Purchased credits will be transferred to account when user registers&#13;
            // They are kept in a holding area until then. We deduct buy+bonus from &#13;
            // icoOwner because that is the amount that will eventually be credited.&#13;
            // However, we store the credit as buyJiffys so that the referral calculation&#13;
            // will be against the buy amount and not the buy+bonus amount&#13;
            uint256 totalJiffys = buyJiffys.add(calculatePurchaseBonus(buyJiffys, now));&#13;
            balances[icoOwner] = balances[icoOwner].sub(totalJiffys);&#13;
            balances[account] = balances[account].add(totalJiffys);&#13;
            purchaseCredits[account] = PurchaseCredit(buyJiffys, now);&#13;
            Transfer(icoOwner, account, buyJiffys);&#13;
        }&#13;
&#13;
    }&#13;
&#13;
    /**&#13;
    * @dev Process token purchase&#13;
    *&#13;
    * @param account Account that is buying tokens&#13;
    * @param buyJiffys Number of Jiffys purchased&#13;
    *&#13;
    */    &#13;
    function processPurchase&#13;
                            (&#13;
                                address source,&#13;
                                address account,&#13;
                                uint256 buyJiffys,&#13;
                                uint256 purchaseTimestamp&#13;
                            ) &#13;
                            private &#13;
    {&#13;
&#13;
        uint256 totalJiffys = buyJiffys.add(calculatePurchaseBonus(buyJiffys, purchaseTimestamp));&#13;
&#13;
&#13;
        // Transfer purchased Jiffys to buyer&#13;
        require(transferableBalanceOf(source) &gt;= totalJiffys);        &#13;
        balances[source] = balances[source].sub(totalJiffys);&#13;
        balances[account] = balances[account].add(totalJiffys);            &#13;
        Transfer(source, account, totalJiffys);&#13;
&#13;
        // If the buyer has a referrer attached to their profile, then&#13;
        // transfer 3% of the purchased Jiffys to the referrer's account&#13;
        if (users[account].isRegistered &amp;&amp; (users[account].referrer != address(0))) {&#13;
            address referrer = users[account].referrer;&#13;
            uint256 referralJiffys = (buyJiffys.mul(BUYER_REFERRER_BOUNTY)).div(100);&#13;
            if ((referralJiffys &gt; 0) &amp;&amp; (transferableBalanceOf(icoOwner) &gt;= referralJiffys)) {&#13;
                balances[icoOwner] = balances[icoOwner].sub(referralJiffys);&#13;
                balances[referrer] = balances[referrer].add(referralJiffys);  &#13;
                Transfer(icoOwner, referrer, referralJiffys);&#13;
            }            &#13;
        }&#13;
    }&#13;
&#13;
    /**&#13;
    * @dev Calculates ICO bonus tokens&#13;
    *&#13;
    * @param buyJiffys Number of Jiffys purchased&#13;
    *&#13;
    */    &#13;
    function calculatePurchaseBonus&#13;
                            (&#13;
                                uint256 buyJiffys,&#13;
                                uint256 purchaseTimestamp&#13;
                            ) &#13;
                            private &#13;
                            view&#13;
                            returns(uint256)&#13;
    {&#13;
        uint256 bonusPercentage = 0;&#13;
&#13;
        // Time-based bonus&#13;
        if (purchaseTimestamp &lt;= bonus5EndTimestamp) {&#13;
            if (purchaseTimestamp &lt;= bonus10EndTimestamp) {&#13;
                if (purchaseTimestamp &lt;= bonus20EndTimestamp) {&#13;
                    bonusPercentage = 20;&#13;
                } else {&#13;
                    bonusPercentage = 10;&#13;
                }&#13;
            } else {&#13;
                bonusPercentage = 5;&#13;
            }&#13;
        }&#13;
&#13;
        return (buyJiffys.mul(bonusPercentage)).div(100);&#13;
    }&#13;
    &#13;
&#13;
}   &#13;
&#13;
/*&#13;
LICENSE FOR SafeMath and TokenVesting&#13;
&#13;
The MIT License (MIT)&#13;
&#13;
Copyright (c) 2016 Smart Contract Solutions, Inc.&#13;
&#13;
Permission is hereby granted, free of charge, to any person obtaining&#13;
a copy of this software and associated documentation files (the&#13;
"Software"), to deal in the Software without restriction, including&#13;
without limitation the rights to use, copy, modify, merge, publish,&#13;
distribute, sublicense, and/or sell copies of the Software, and to&#13;
permit persons to whom the Software is furnished to do so, subject to&#13;
the following conditions:&#13;
&#13;
The above copyright notice and this permission notice shall be included&#13;
in all copies or substantial portions of the Software.&#13;
&#13;
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS&#13;
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF&#13;
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.&#13;
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY&#13;
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,&#13;
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE&#13;
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.&#13;
*/&#13;
&#13;
&#13;
library SafeMath {&#13;
/* Copyright (c) 2016 Smart Contract Solutions, Inc. */&#13;
/* See License at end of file                        */&#13;
&#13;
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
        if (a == 0) {&#13;
        return 0;&#13;
        }&#13;
        uint256 c = a * b;&#13;
        assert(c / a == b);&#13;
        return c;&#13;
    }&#13;
&#13;
    function div(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
        // assert(b &gt; 0); // Solidity automatically throws when dividing by 0&#13;
        uint256 c = a / b;&#13;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold&#13;
        return c;&#13;
    }&#13;
&#13;
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
        assert(b &lt;= a);&#13;
        return a - b;&#13;
    }&#13;
&#13;
    function add(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
        uint256 c = a + b;&#13;
        assert(c &gt;= a);&#13;
        return c;&#13;
    }&#13;
}