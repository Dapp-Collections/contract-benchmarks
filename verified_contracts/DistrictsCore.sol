pragma solidity ^ 0.4.19;

// DopeRaider Districts Contract
// by gasmasters.io
// contact: <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="86f2e3e7ebc6e2e9f6e3f4e7efe2e3f4a8e5e9eb">[emailÂ protected]</a>&#13;
&#13;
/// @title Interface for contracts conforming to ERC-721: Non-Fungible Tokens&#13;
contract ERC721 {&#13;
  function implementsERC721() public pure returns(bool);&#13;
  function totalSupply() public view returns(uint256 total);&#13;
  function balanceOf(address _owner) public view returns(uint256 balance);&#13;
  function ownerOf(uint256 _tokenId) public view returns(address owner);&#13;
  function approve(address _to, uint256 _tokenId) public;&#13;
  function transferFrom(address _from, address _to, uint256 _tokenId) public;&#13;
  function transfer(address _to, uint256 _tokenId) public;&#13;
  event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);&#13;
  event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);&#13;
&#13;
  // Optional&#13;
  // function name() public view returns (string name);&#13;
  // function symbol() public view returns (string symbol);&#13;
  // function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256 tokenId);&#13;
  // function tokenMetadata(uint256 _tokenId) public view returns (string infoUrl);&#13;
}&#13;
&#13;
// File: contracts/NarcoCoreInterface.sol&#13;
&#13;
contract NarcosCoreInterface is ERC721 {&#13;
  function getNarco(uint256 _id)&#13;
  public&#13;
  view&#13;
  returns(&#13;
    string  narcoName,&#13;
    uint256 weedTotal,&#13;
    uint256 cokeTotal,&#13;
    uint16[6] skills,&#13;
    uint8[4] consumables,&#13;
    string genes,&#13;
    uint8 homeLocation,&#13;
    uint16 level,&#13;
    uint256[6] cooldowns,&#13;
    uint256 id,&#13;
    uint16[9] stats&#13;
  );&#13;
&#13;
  function updateWeedTotal(uint256 _narcoId, bool _add, uint16 _total) public;&#13;
  function updateCokeTotal(uint256 _narcoId, bool _add,  uint16 _total) public;&#13;
  function updateConsumable(uint256 _narcoId, uint256 _index, uint8 _new) public;&#13;
  function updateSkill(uint256 _narcoId, uint256 _index, uint16 _new) public;&#13;
  function incrementStat(uint256 _narcoId, uint256 _index) public;&#13;
  function setCooldown(uint256 _narcoId , uint256 _index , uint256 _new) public;&#13;
  function getRemainingCapacity(uint256 _id) public view returns (uint8 capacity);&#13;
}&#13;
&#13;
&#13;
// File: contracts/Ownable.sol&#13;
&#13;
/**&#13;
 * @title Ownable&#13;
 * @dev The Ownable contract has an owner address, and provides basic authorization control&#13;
 * functions, this simplifies the implementation of "user permissions".&#13;
 */&#13;
contract Ownable {&#13;
  address public owner;&#13;
&#13;
&#13;
  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);&#13;
&#13;
&#13;
  /**&#13;
   * @dev The Ownable constructor sets the original `owner` of the contract to the sender&#13;
   * account.&#13;
   */&#13;
  function Ownable() public {&#13;
    owner = msg.sender;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Throws if called by any account other than the owner.&#13;
   */&#13;
  modifier onlyOwner() {&#13;
    require(msg.sender == owner);&#13;
    _;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Allows the current owner to transfer control of the contract to a newOwner.&#13;
   * @param newOwner The address to transfer ownership to.&#13;
   */&#13;
  function transferOwnership(address newOwner) public onlyOwner {&#13;
    require(newOwner != address(0));&#13;
    OwnershipTransferred(owner, newOwner);&#13;
    owner = newOwner;&#13;
  }&#13;
&#13;
}&#13;
&#13;
// File: contracts/Pausable.sol&#13;
&#13;
/**&#13;
 * @title Pausable&#13;
 * @dev Base contract which allows children to implement an emergency stop mechanism.&#13;
 */&#13;
contract Pausable is Ownable {&#13;
  event Pause();&#13;
  event Unpause();&#13;
&#13;
  bool public paused = true;&#13;
&#13;
&#13;
  /**&#13;
   * @dev Modifier to make a function callable only when the contract is not paused.&#13;
   */&#13;
  modifier whenNotPaused() {&#13;
    require(!paused);&#13;
    _;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Modifier to make a function callable only when the contract is paused.&#13;
   */&#13;
  modifier whenPaused() {&#13;
    require(paused);&#13;
    _;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev called by the owner to pause, triggers stopped state&#13;
   */&#13;
  function pause() onlyOwner whenNotPaused public {&#13;
    paused = true;&#13;
    Pause();&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev called by the owner to unpause, returns to normal state&#13;
   */&#13;
  function unpause() onlyOwner whenPaused public {&#13;
    paused = false;&#13;
    Unpause();&#13;
  }&#13;
}&#13;
&#13;
&#13;
// File: contracts/Districts/DistrictsAdmin.sol&#13;
&#13;
contract DistrictsAdmin is Ownable, Pausable {&#13;
  event ContractUpgrade(address newContract);&#13;
&#13;
  address public newContractAddress;&#13;
  address public coreAddress;&#13;
&#13;
  NarcosCoreInterface public narcoCore;&#13;
&#13;
  function setNarcosCoreAddress(address _address) public onlyOwner {&#13;
    _setNarcosCoreAddress(_address);&#13;
  }&#13;
&#13;
  function _setNarcosCoreAddress(address _address) internal {&#13;
    NarcosCoreInterface candidateContract = NarcosCoreInterface(_address);&#13;
    require(candidateContract.implementsERC721());&#13;
    coreAddress = _address;&#13;
    narcoCore = candidateContract;&#13;
  }&#13;
&#13;
  /// @dev Used to mark the smart contract as upgraded, in case there is a serious&#13;
  ///  breaking bug. This method does nothing but keep track of the new contract and&#13;
  ///  emit a message indicating that the new address is set. It's up to clients of this&#13;
  ///  contract to update to the new contract address in that case.&#13;
  /// @param _v2Address new address&#13;
  function setNewAddress(address _v2Address) public onlyOwner whenPaused {&#13;
    newContractAddress = _v2Address;&#13;
&#13;
    ContractUpgrade(_v2Address);&#13;
  }&#13;
&#13;
  modifier onlyDopeRaiderContract() {&#13;
    require(msg.sender == coreAddress);&#13;
    _;&#13;
  }&#13;
&#13;
}&#13;
&#13;
&#13;
&#13;
// File: contracts/DistrictsCore.sol&#13;
&#13;
contract DistrictsCore is DistrictsAdmin {&#13;
&#13;
  // DISTRICT EVENTS&#13;
  event NarcoArrived(uint8 indexed location, uint256 indexed narcoId); // who just arrived here&#13;
  event NarcoLeft(uint8 indexed location, uint256 indexed narcoId); // who just left here&#13;
  event TravelBust(uint256 indexed narcoId, uint16 confiscatedWeed, uint16 confiscatedCoke);&#13;
  event Hijacked(uint256 indexed hijacker, uint256 indexed victim , uint16 stolenWeed , uint16 stolenCoke);&#13;
  event HijackDefended(uint256 indexed hijacker, uint256 indexed victim);&#13;
  event EscapedHijack(uint256 indexed hijacker, uint256 indexed victim , uint8 escapeLocation);&#13;
&#13;
  uint256 public airLiftPrice = 0.01 ether; // home dorothy price&#13;
  uint256 public hijackPrice = 0.002 ether; // universal hijackPrice&#13;
  uint256 public travelPrice = 0.001 ether; // universal travelPrice&#13;
  uint256 public spreadPercent = 5; // universal spread between buy and sell&#13;
  uint256 public devFeePercent = 2; // on various actions&#13;
  uint256 public currentDevFees = 0;&#13;
  uint256 public bustRange = 10;&#13;
&#13;
  function setAirLiftPrice(uint256 _price) public onlyOwner{&#13;
    airLiftPrice = _price;&#13;
  }&#13;
&#13;
  function setBustRange(uint256 _range) public onlyOwner{&#13;
    bustRange = _range;&#13;
  }&#13;
&#13;
  function setHijackPrice(uint256 _price) public onlyOwner{&#13;
    hijackPrice = _price;&#13;
  }&#13;
&#13;
  function setTravelPrice(uint256 _price) public onlyOwner{&#13;
    travelPrice = _price;&#13;
  }&#13;
&#13;
  function setSpreadPercent(uint256 _spread) public onlyOwner{&#13;
    spreadPercent = _spread;&#13;
  }&#13;
&#13;
  function setDevFeePercent(uint256 _fee) public onlyOwner{&#13;
    devFeePercent = _fee;&#13;
  }&#13;
&#13;
  function isDopeRaiderDistrictsCore() public pure returns(bool){ return true; }&#13;
&#13;
&#13;
  // Market Items&#13;
&#13;
  struct MarketItem{&#13;
    uint256 id;&#13;
    string itemName;&#13;
    uint8 skillAffected;&#13;
    uint8 upgradeAmount;&#13;
    uint8 levelRequired; // the level a narco must have before they&#13;
  }&#13;
&#13;
  // there is a fixed amount of items - they are not tokens bc iterations will be needed.&#13;
  // 0,1 = weed , coke , 2 - 4 consumables , 5-23 items&#13;
  MarketItem[24] public marketItems;&#13;
&#13;
  function configureMarketItem(uint256 _id, uint8 _skillAffected, uint8  _upgradeAmount, uint8 _levelRequired, string _itemName) public onlyOwner{&#13;
    marketItems[_id].skillAffected = _skillAffected;&#13;
    marketItems[_id].upgradeAmount = _upgradeAmount;&#13;
    marketItems[_id].levelRequired = _levelRequired;&#13;
    marketItems[_id].itemName = _itemName;&#13;
    marketItems[_id].id = _id;&#13;
  }&#13;
&#13;
&#13;
  struct District {&#13;
    uint256[6] exits;&#13;
    uint256 weedPot;&#13;
    uint256 weedAmountHere;&#13;
    uint256 cokePot;&#13;
    uint256 cokeAmountHere;&#13;
    uint256[24] marketPrices;&#13;
    bool[24] isStocked;&#13;
    bool hasMarket;&#13;
    string name;&#13;
  }&#13;
&#13;
  District[8] public districts; // there is no '0' district - this will be used to indicate no exit&#13;
&#13;
  // for keeping track of who is where&#13;
  mapping(uint256 =&gt; uint8) narcoIndexToLocation;&#13;
&#13;
  function DistrictsCore() public {&#13;
  }&#13;
&#13;
  function getDistrict(uint256 _id) public view returns(uint256[6] exits, bool hasMarket, uint256[24] prices, bool[24] isStocked, uint256 weedPot, uint256 cokePot, uint256 weedAmountHere, uint256 cokeAmountHere, string name){&#13;
    District storage district = districts[_id];&#13;
    exits = district.exits;&#13;
    hasMarket = district.hasMarket;&#13;
    prices = district.marketPrices;&#13;
&#13;
    // minimum prices for w/c set in the districts configuration file&#13;
    prices[0] = max(prices[0], (((district.weedPot / district.weedAmountHere)/100)*(100+spreadPercent)));// Smeti calc this is the buy price (contract sells)&#13;
    prices[1] = max(prices[1], (((district.cokePot / district.cokeAmountHere)/100)*(100+spreadPercent)));  // Smeti calc this is the buy price (contract sells)&#13;
    isStocked = district.isStocked;&#13;
    weedPot = district.weedPot;&#13;
    cokePot = district.cokePot;&#13;
    weedAmountHere = district.weedAmountHere;&#13;
    cokeAmountHere = district.cokeAmountHere;&#13;
    name = district.name;&#13;
  }&#13;
&#13;
  function createNamedDistrict(uint256 _index, string _name, bool _hasMarket) public onlyOwner{&#13;
    districts[_index].name = _name;&#13;
    districts[_index].hasMarket = _hasMarket;&#13;
    districts[_index].weedAmountHere = 1;&#13;
    districts[_index].cokeAmountHere = 1;&#13;
    districts[_index].weedPot = 0.001 ether;&#13;
    districts[_index].cokePot = 0.001 ether;&#13;
  }&#13;
&#13;
  function configureDistrict(uint256 _index, uint256[6]_exits, uint256[24] _prices, bool[24] _isStocked) public onlyOwner{&#13;
    districts[_index].exits = _exits; // clockwise starting at noon&#13;
    districts[_index].marketPrices = _prices;&#13;
    districts[_index].isStocked = _isStocked;&#13;
  }&#13;
&#13;
  // callable by other contracts to control economy&#13;
  function increaseDistrictWeed(uint256 _district, uint256 _quantity) public onlyDopeRaiderContract{&#13;
    districts[_district].weedAmountHere += _quantity;&#13;
  }&#13;
  function increaseDistrictCoke(uint256 _district, uint256 _quantity) public onlyDopeRaiderContract{&#13;
    districts[_district].cokeAmountHere += _quantity;&#13;
  }&#13;
&#13;
  function getNarcoLocation(uint256 _narcoId) public view returns(uint8 location){&#13;
    location = narcoIndexToLocation[_narcoId];&#13;
    // could be they have not travelled, so just return their home location&#13;
    if (location == 0) {&#13;
      (&#13;
            ,&#13;
            ,&#13;
            ,&#13;
            ,&#13;
            ,&#13;
            ,&#13;
        location&#13;
        ,&#13;
        ,&#13;
        ,&#13;
        ,&#13;
        ) = narcoCore.getNarco(_narcoId);&#13;
&#13;
    }&#13;
&#13;
  }&#13;
&#13;
  function getNarcoHomeLocation(uint256 _narcoId) public view returns(uint8 location){&#13;
      (&#13;
            ,&#13;
            ,&#13;
            ,&#13;
            ,&#13;
            ,&#13;
            ,&#13;
        location&#13;
        ,&#13;
        ,&#13;
        ,&#13;
        ,&#13;
        ) = narcoCore.getNarco(_narcoId);&#13;
  }&#13;
&#13;
  // function to be called when wanting to add funds to all districts&#13;
  function floatEconony() public payable onlyOwner {&#13;
        if(msg.value&gt;0){&#13;
          for (uint district=1;district&lt;8;district++){&#13;
              districts[district].weedPot+=(msg.value/14);&#13;
              districts[district].cokePot+=(msg.value/14);&#13;
            }&#13;
        }&#13;
    }&#13;
&#13;
  // function to be called when wanting to add funds to a district&#13;
  function distributeRevenue(uint256 _district , uint8 _splitW, uint8 _splitC) public payable onlyDopeRaiderContract {&#13;
        if(msg.value&gt;0){&#13;
         _distributeRevenue(msg.value, _district, _splitW, _splitC);&#13;
        }&#13;
  }&#13;
&#13;
  uint256 public localRevenuePercent = 80;&#13;
&#13;
  function setLocalRevenuPercent(uint256 _lrp) public onlyOwner{&#13;
    localRevenuePercent = _lrp;&#13;
  }&#13;
&#13;
  function _distributeRevenue(uint256 _grossRevenue, uint256 _district , uint8 _splitW, uint8 _splitC) internal {&#13;
          // subtract dev fees&#13;
          uint256 onePc = _grossRevenue/100;&#13;
          uint256 netRevenue = onePc*(100-devFeePercent);&#13;
          uint256 devFee = onePc*(devFeePercent);&#13;
&#13;
          uint256 districtRevenue = (netRevenue/100)*localRevenuePercent;&#13;
          uint256 federalRevenue = (netRevenue/100)*(100-localRevenuePercent);&#13;
&#13;
          // distribute district revenue&#13;
          // split evenly between weed and coke pots&#13;
          districts[_district].weedPot+=(districtRevenue/100)*_splitW;&#13;
          districts[_district].cokePot+=(districtRevenue/100)*_splitC;&#13;
&#13;
          // distribute federal revenue&#13;
           for (uint district=1;district&lt;8;district++){&#13;
              districts[district].weedPot+=(federalRevenue/14);&#13;
              districts[district].cokePot+=(federalRevenue/14);&#13;
            }&#13;
&#13;
          // acrue dev fee&#13;
          currentDevFees+=devFee;&#13;
  }&#13;
&#13;
  function withdrawFees() external onlyOwner {&#13;
        if (currentDevFees&lt;=address(this).balance){&#13;
          currentDevFees = 0;&#13;
          msg.sender.transfer(currentDevFees);&#13;
        }&#13;
    }&#13;
&#13;
&#13;
  function buyItem(uint256 _narcoId, uint256 _district, uint256 _itemIndex, uint256 _quantity) public payable whenNotPaused{&#13;
    require(narcoCore.ownerOf(_narcoId) == msg.sender); // must be owner&#13;
&#13;
    uint256 narcoWeedTotal;&#13;
    uint256 narcoCokeTotal;&#13;
    uint16[6] memory narcoSkills;&#13;
    uint8[4] memory narcoConsumables;&#13;
    uint16 narcoLevel;&#13;
&#13;
    (&#13;
                ,&#13;
      narcoWeedTotal,&#13;
      narcoCokeTotal,&#13;
      narcoSkills,&#13;
      narcoConsumables,&#13;
                ,&#13;
                ,&#13;
      narcoLevel,&#13;
                ,&#13;
                ,&#13;
    ) = narcoCore.getNarco(_narcoId);&#13;
&#13;
    require(getNarcoLocation(_narcoId) == uint8(_district)); // right place to buy&#13;
    require(uint8(_quantity) &gt; 0 &amp;&amp; districts[_district].isStocked[_itemIndex] == true); // there is enough of it&#13;
    require(marketItems[_itemIndex].levelRequired &lt;= narcoLevel || _district==7); //  must be level to buy this item or black market&#13;
    require(narcoCore.getRemainingCapacity(_narcoId) &gt;= _quantity || _itemIndex&gt;=6); // narco can carry it or not a consumable&#13;
&#13;
    // progression through the upgrades for non consumable items (&gt;=6)&#13;
    if (_itemIndex&gt;=6) {&#13;
      if (marketItems[_itemIndex].skillAffected!=5){&#13;
            // regular items&#13;
            require (marketItems[_itemIndex].levelRequired==0 || narcoSkills[marketItems[_itemIndex].skillAffected]&lt;marketItems[_itemIndex].upgradeAmount);&#13;
          }else{&#13;
            // capacity has 20 + requirement&#13;
            require (narcoSkills[5]&lt;20+marketItems[_itemIndex].upgradeAmount);&#13;
      }&#13;
    }&#13;
&#13;
    uint256 costPrice = districts[_district].marketPrices[_itemIndex] * _quantity;&#13;
&#13;
    if (_itemIndex ==0 ) {&#13;
      costPrice = max(districts[_district].marketPrices[0], (((districts[_district].weedPot / districts[_district].weedAmountHere)/100)*(100+spreadPercent))) * _quantity;&#13;
    }&#13;
    if (_itemIndex ==1 ) {&#13;
      costPrice = max(districts[_district].marketPrices[1], (((districts[_district].cokePot / districts[_district].cokeAmountHere)/100)*(100+spreadPercent))) * _quantity;&#13;
    }&#13;
&#13;
    require(msg.value &gt;= costPrice); // paid enough?&#13;
    // ok purchase here&#13;
    if (_itemIndex &gt; 1 &amp;&amp; _itemIndex &lt; 6) {&#13;
      // consumable&#13;
      narcoCore.updateConsumable(_narcoId, _itemIndex - 2, uint8(narcoConsumables[_itemIndex - 2] + _quantity));&#13;
       _distributeRevenue(costPrice, _district , 50, 50);&#13;
    }&#13;
&#13;
    if (_itemIndex &gt;= 6) {&#13;
        // skills boost&#13;
        // check which skill is updated by this item&#13;
        narcoCore.updateSkill(&#13;
          _narcoId,&#13;
          marketItems[_itemIndex].skillAffected,&#13;
          uint16(narcoSkills[marketItems[_itemIndex].skillAffected] + (marketItems[_itemIndex].upgradeAmount * _quantity))&#13;
        );&#13;
        _distributeRevenue(costPrice, _district , 50, 50);&#13;
    }&#13;
    if (_itemIndex == 0) {&#13;
        // weedTotal&#13;
        narcoCore.updateWeedTotal(_narcoId, true,  uint16(_quantity));&#13;
        districts[_district].weedAmountHere += uint8(_quantity);&#13;
        _distributeRevenue(costPrice, _district , 100, 0);&#13;
    }&#13;
    if (_itemIndex == 1) {&#13;
       // cokeTotal&#13;
       narcoCore.updateCokeTotal(_narcoId, true, uint16(_quantity));&#13;
       districts[_district].cokeAmountHere += uint8(_quantity);&#13;
       _distributeRevenue(costPrice, _district , 0, 100);&#13;
    }&#13;
&#13;
    // allow overbid&#13;
    if (msg.value&gt;costPrice){&#13;
        msg.sender.transfer(msg.value-costPrice);&#13;
    }&#13;
&#13;
  }&#13;
&#13;
&#13;
  function sellItem(uint256 _narcoId, uint256 _district, uint256 _itemIndex, uint256 _quantity) public whenNotPaused{&#13;
    require(narcoCore.ownerOf(_narcoId) == msg.sender); // must be owner&#13;
    require(_itemIndex &lt; marketItems.length &amp;&amp; _district &lt; 8 &amp;&amp; _district &gt; 0 &amp;&amp; _quantity &gt; 0); // valid item and district and quantity&#13;
&#13;
    uint256 narcoWeedTotal;&#13;
    uint256 narcoCokeTotal;&#13;
&#13;
    (&#13;
                ,&#13;
      narcoWeedTotal,&#13;
      narcoCokeTotal,&#13;
                ,&#13;
                ,&#13;
                ,&#13;
                ,&#13;
                ,&#13;
                ,&#13;
                ,&#13;
            ) = narcoCore.getNarco(_narcoId);&#13;
&#13;
&#13;
    require(getNarcoLocation(_narcoId) == _district); // right place to buy&#13;
    // at this time only weed and coke can be sold to the contract&#13;
    require((_itemIndex == 0 &amp;&amp; narcoWeedTotal &gt;= _quantity) || (_itemIndex == 1 &amp;&amp; narcoCokeTotal &gt;= _quantity));&#13;
&#13;
    uint256 salePrice = 0;&#13;
&#13;
    if (_itemIndex == 0) {&#13;
      salePrice = districts[_district].weedPot / districts[_district].weedAmountHere;  // Smeti calc this is the sell price (contract buys)&#13;
    }&#13;
    if (_itemIndex == 1) {&#13;
      salePrice = districts[_district].cokePot / districts[_district].cokeAmountHere;  // Smeti calc this is the sell price (contract buys)&#13;
    }&#13;
    require(salePrice &gt; 0); // yeah that old chestnut lol&#13;
&#13;
    // do the updates&#13;
    if (_itemIndex == 0) {&#13;
      narcoCore.updateWeedTotal(_narcoId, false, uint16(_quantity));&#13;
      districts[_district].weedPot-=salePrice*_quantity;&#13;
      districts[_district].weedAmountHere -= _quantity;&#13;
    }&#13;
    if (_itemIndex == 1) {&#13;
      narcoCore.updateCokeTotal(_narcoId, false, uint16(_quantity));&#13;
      districts[_district].cokePot-=salePrice*_quantity;&#13;
      districts[_district].cokeAmountHere -= _quantity;&#13;
    }&#13;
    narcoCore.incrementStat(_narcoId, 0); // dealsCompleted&#13;
    // transfer the amount to the seller - should be owner of, but for now...&#13;
    msg.sender.transfer(salePrice*_quantity);&#13;
&#13;
  }&#13;
&#13;
&#13;
&#13;
  // allow a Narco to travel between districts&#13;
  // travelling is done by taking "exit" --&gt; index into the loctions&#13;
  function travelTo(uint256 _narcoId, uint256 _exitId) public payable whenNotPaused{&#13;
    require(narcoCore.ownerOf(_narcoId) == msg.sender); // must be owner&#13;
    require((msg.value &gt;= travelPrice &amp;&amp; _exitId &lt; 7) || (msg.value &gt;= airLiftPrice &amp;&amp; _exitId==7));&#13;
&#13;
    // exitId ==7 is a special exit for airlifting narcos back to their home location&#13;
&#13;
&#13;
    uint256 narcoWeedTotal;&#13;
    uint256 narcoCokeTotal;&#13;
    uint16[6] memory narcoSkills;&#13;
    uint8[4] memory narcoConsumables;&#13;
    uint256[6] memory narcoCooldowns;&#13;
&#13;
    (&#13;
                ,&#13;
      narcoWeedTotal,&#13;
      narcoCokeTotal,&#13;
      narcoSkills,&#13;
      narcoConsumables,&#13;
                ,&#13;
                ,&#13;
                ,&#13;
      narcoCooldowns,&#13;
                ,&#13;
    ) = narcoCore.getNarco(_narcoId);&#13;
&#13;
    // travel cooldown must have expired and narco must have some gas&#13;
    require(now&gt;narcoCooldowns[0] &amp;&amp; narcoConsumables[0]&gt;0);&#13;
&#13;
    uint8 sourceLocation = getNarcoLocation(_narcoId);&#13;
    District storage sourceDistrict = districts[sourceLocation]; // find out source&#13;
    require(_exitId==7 || sourceDistrict.exits[_exitId] != 0); // must be a valid exit&#13;
&#13;
    // decrease the weed pot and cocaine pot for the destination district&#13;
    uint256 localWeedTotal = districts[sourceLocation].weedAmountHere;&#13;
    uint256 localCokeTotal = districts[sourceLocation].cokeAmountHere;&#13;
&#13;
    if (narcoWeedTotal &lt; localWeedTotal) {&#13;
      districts[sourceLocation].weedAmountHere -= narcoWeedTotal;&#13;
    } else {&#13;
      districts[sourceLocation].weedAmountHere = 1; // always drop to 1&#13;
    }&#13;
&#13;
    if (narcoCokeTotal &lt; localCokeTotal) {&#13;
      districts[sourceLocation].cokeAmountHere -= narcoCokeTotal;&#13;
    } else {&#13;
      districts[sourceLocation].cokeAmountHere = 1; // always drop to 1&#13;
    }&#13;
&#13;
    // do the move&#13;
    uint8 targetLocation = getNarcoHomeLocation(_narcoId);&#13;
    if (_exitId&lt;7){&#13;
      targetLocation =  uint8(sourceDistrict.exits[_exitId]);&#13;
    }&#13;
&#13;
    narcoIndexToLocation[_narcoId] = targetLocation;&#13;
&#13;
    // distribute the travel revenue&#13;
    _distributeRevenue(travelPrice, targetLocation , 50, 50);&#13;
&#13;
    // increase the weed pot and cocaine pot for the destination district with the travel cost&#13;
    districts[targetLocation].weedAmountHere += narcoWeedTotal;&#13;
    districts[targetLocation].cokeAmountHere += narcoCokeTotal;&#13;
&#13;
    // consume some gas (gas index = 0)&#13;
    narcoCore.updateConsumable(_narcoId, 0 , narcoConsumables[0]-1);&#13;
    // set travel cooldown (speed skill = 0)&#13;
    //narcoCore.setCooldown( _narcoId ,  0 , now + min(3 minutes,(455-(5*narcoSkills[0])* 1 seconds)));&#13;
    narcoCore.setCooldown( _narcoId ,  0 , now + (455-(5*narcoSkills[0])* 1 seconds));&#13;
&#13;
    // update travel stat&#13;
    narcoCore.incrementStat(_narcoId, 7);&#13;
    // Travel risk&#13;
     uint64 bustChance=random(50+(5*narcoSkills[0])); // 0  = speed skill&#13;
&#13;
     if (bustChance&lt;=bustRange){&#13;
      busted(_narcoId,targetLocation,narcoWeedTotal,narcoCokeTotal);&#13;
     }&#13;
&#13;
     NarcoArrived(targetLocation, _narcoId); // who just arrived here&#13;
     NarcoLeft(sourceLocation, _narcoId); // who just left here&#13;
&#13;
  }&#13;
&#13;
  function busted(uint256 _narcoId, uint256 targetLocation, uint256 narcoWeedTotal, uint256 narcoCokeTotal) private  {&#13;
       uint256 bustedWeed=narcoWeedTotal/2; // %50&#13;
       uint256 bustedCoke=narcoCokeTotal/2; // %50&#13;
       districts[targetLocation].weedAmountHere -= bustedWeed; // smeti fix&#13;
       districts[targetLocation].cokeAmountHere -= bustedCoke; // smeti fix&#13;
       districts[7].weedAmountHere += bustedWeed; // smeti fix&#13;
       districts[7].cokeAmountHere += bustedCoke; // smeti fix&#13;
       narcoCore.updateWeedTotal(_narcoId, false, uint16(bustedWeed)); // 50% weed&#13;
       narcoCore.updateCokeTotal(_narcoId, false, uint16(bustedCoke)); // 50% coke&#13;
       narcoCore.updateWeedTotal(0, true, uint16(bustedWeed)); // 50% weed confiscated into office lardass&#13;
       narcoCore.updateCokeTotal(0, true, uint16(bustedCoke)); // 50% coke confiscated into office lardass&#13;
       TravelBust(_narcoId, uint16(bustedWeed), uint16(bustedCoke));&#13;
  }&#13;
&#13;
&#13;
  function hijack(uint256 _hijackerId, uint256 _victimId)  public payable whenNotPaused{&#13;
    require(narcoCore.ownerOf(_hijackerId) == msg.sender); // must be owner&#13;
    require(msg.value &gt;= hijackPrice);&#13;
&#13;
    // has the victim escaped?&#13;
    if (getNarcoLocation(_hijackerId)!=getNarcoLocation(_victimId)){&#13;
        EscapedHijack(_hijackerId, _victimId , getNarcoLocation(_victimId));&#13;
        narcoCore.incrementStat(_victimId, 6); // lucky escape&#13;
    }else&#13;
    {&#13;
      // hijack calculation&#13;
      uint256 hijackerWeedTotal;&#13;
      uint256 hijackerCokeTotal;&#13;
      uint16[6] memory hijackerSkills;&#13;
      uint8[4] memory hijackerConsumables;&#13;
      uint256[6] memory hijackerCooldowns;&#13;
&#13;
      (&#13;
                  ,&#13;
        hijackerWeedTotal,&#13;
        hijackerCokeTotal,&#13;
        hijackerSkills,&#13;
        hijackerConsumables,&#13;
                  ,&#13;
                  ,&#13;
                  ,&#13;
        hijackerCooldowns,&#13;
                  ,&#13;
      ) = narcoCore.getNarco(_hijackerId);&#13;
&#13;
      // does hijacker have capacity to carry any loot?&#13;
&#13;
      uint256 victimWeedTotal;&#13;
      uint256 victimCokeTotal;&#13;
      uint16[6] memory victimSkills;&#13;
      uint256[6] memory victimCooldowns;&#13;
      uint8 victimHomeLocation;&#13;
      (&#13;
                  ,&#13;
        victimWeedTotal,&#13;
        victimCokeTotal,&#13;
        victimSkills,&#13;
                  ,&#13;
                  ,&#13;
       victimHomeLocation,&#13;
                  ,&#13;
        victimCooldowns,&#13;
                  ,&#13;
      ) = narcoCore.getNarco(_victimId);&#13;
&#13;
      // victim is not in home location , or is officer lardass&#13;
      require(getNarcoLocation(_victimId)!=victimHomeLocation || _victimId==0);&#13;
      require(hijackerConsumables[3] &gt;0); // narco has ammo&#13;
&#13;
      require(now&gt;hijackerCooldowns[3]); // must be outside cooldown&#13;
&#13;
      // consume the ammo&#13;
      narcoCore.updateConsumable(_hijackerId, 3 , hijackerConsumables[3]-1);&#13;
      // attempt the hijack&#13;
&#13;
      // 3 = attackIndex&#13;
      // 4 = defenseIndex&#13;
&#13;
      if (uint8(random((hijackerSkills[3]+victimSkills[4]))+1) &gt;victimSkills[4]) {&#13;
        // successful hijacking&#13;
&#13;
        doHijack(_hijackerId  , _victimId , victimWeedTotal , victimCokeTotal);&#13;
&#13;
        // heist character&#13;
        if (_victimId==0){&#13;
             narcoCore.incrementStat(_hijackerId, 5); // raidSuccessful&#13;
        }&#13;
&#13;
      }else{&#13;
        // successfully defended&#13;
        narcoCore.incrementStat(_victimId, 4); // defendedSuccessfully&#13;
        HijackDefended( _hijackerId,_victimId);&#13;
      }&#13;
&#13;
    } // end if escaped&#13;
&#13;
    //narcoCore.setCooldown( _hijackerId ,  3 , now + min(3 minutes,(455-(5*hijackerSkills[3])* 1 seconds))); // cooldown&#13;
     narcoCore.setCooldown( _hijackerId ,  3 , now + (455-(5*hijackerSkills[3])* 1 seconds)); // cooldown&#13;
&#13;
      // distribute the hijack revenue&#13;
      _distributeRevenue(hijackPrice, getNarcoLocation(_hijackerId) , 50, 50);&#13;
&#13;
  } // end hijack function&#13;
&#13;
  function doHijack(uint256 _hijackerId  , uint256 _victimId ,  uint256 victimWeedTotal , uint256 victimCokeTotal) private {&#13;
&#13;
        uint256 hijackerCapacity =  narcoCore.getRemainingCapacity(_hijackerId);&#13;
&#13;
        // fill pockets starting with coke&#13;
        uint16 stolenCoke = uint16(min(hijackerCapacity , (victimCokeTotal/2))); // steal 50%&#13;
        uint16 stolenWeed = uint16(min(hijackerCapacity - stolenCoke, (victimWeedTotal/2))); // steal 50%&#13;
&#13;
        // 50% chance to start with weed&#13;
        if (random(100)&gt;50){&#13;
           stolenWeed = uint16(min(hijackerCapacity , (victimWeedTotal/2))); // steal 50%&#13;
           stolenCoke = uint16(min(hijackerCapacity - stolenWeed, (victimCokeTotal/2))); // steal 50&#13;
        }&#13;
&#13;
        // steal some loot this calculation tbd&#13;
        // for now just take all coke / weed&#13;
        if (stolenWeed&gt;0){&#13;
          narcoCore.updateWeedTotal(_hijackerId, true, stolenWeed);&#13;
          narcoCore.updateWeedTotal(_victimId,false, stolenWeed);&#13;
        }&#13;
        if (stolenCoke&gt;0){&#13;
          narcoCore.updateCokeTotal(_hijackerId, true , stolenCoke);&#13;
          narcoCore.updateCokeTotal(_victimId,false, stolenCoke);&#13;
        }&#13;
&#13;
        narcoCore.incrementStat(_hijackerId, 3); // hijackSuccessful&#13;
        Hijacked(_hijackerId, _victimId , stolenWeed, stolenCoke);&#13;
&#13;
&#13;
  }&#13;
&#13;
&#13;
  // pseudo random - but does that matter?&#13;
  uint64 _seed = 0;&#13;
  function random(uint64 upper) private returns (uint64 randomNumber) {&#13;
     _seed = uint64(keccak256(keccak256(block.blockhash(block.number-1), _seed), now));&#13;
     return _seed % upper;&#13;
   }&#13;
&#13;
   function min(uint a, uint b) private pure returns (uint) {&#13;
            return a &lt; b ? a : b;&#13;
   }&#13;
   function max(uint a, uint b) private pure returns (uint) {&#13;
            return a &gt; b ? a : b;&#13;
   }&#13;
&#13;
  // never call this from a contract&#13;
  /// @param _loc that we are interested in&#13;
  function narcosByDistrict(uint8 _loc) public view returns(uint256[] narcosHere) {&#13;
    uint256 tokenCount = numberOfNarcosByDistrict(_loc);&#13;
    uint256 totalNarcos = narcoCore.totalSupply();&#13;
    uint256[] memory result = new uint256[](tokenCount);&#13;
    uint256 narcoId;&#13;
    uint256 resultIndex = 0;&#13;
    for (narcoId = 0; narcoId &lt;= totalNarcos; narcoId++) {&#13;
      if (getNarcoLocation(narcoId) == _loc) {&#13;
        result[resultIndex] = narcoId;&#13;
        resultIndex++;&#13;
      }&#13;
    }&#13;
    return result;&#13;
  }&#13;
&#13;
  function numberOfNarcosByDistrict(uint8 _loc) public view returns(uint256 number) {&#13;
    uint256 count = 0;&#13;
    uint256 narcoId;&#13;
    for (narcoId = 0; narcoId &lt;= narcoCore.totalSupply(); narcoId++) {&#13;
      if (getNarcoLocation(narcoId) == _loc) {&#13;
        count++;&#13;
      }&#13;
    }&#13;
    return count;&#13;
  }&#13;
&#13;
}