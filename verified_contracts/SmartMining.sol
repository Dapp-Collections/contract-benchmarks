pragma solidity ^0.4.25;

/**
 * @title SafeMath
 * @dev Math operations with safety checks that throw on error.
 */
library SafeMath {
    // Multiplies two numbers, throws on overflow./
    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {
        if (a == 0) return 0;
        c = a * b;
        assert(c / a == b);
        return c;
    }
    // Integer division of two numbers, truncating the quotient.
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return a / b;
    }
    // Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        assert(b <= a);
        return a - b;
    }
    // Adds two numbers, throws on overflow.
    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
        c = a + b;
        assert(c >= a);
        return c;
    }
}


/**
 * @title Smart-Mining 'mining-pool & token-distribution'-contract - https://smart-mining.io - <span class="__cf_email__" data-cfemail="91fcf0f8fdd1e2fcf0e3e5bcfcf8fff8fff6bff8fe">[emailÂ protected]</span>&#13;
 */&#13;
contract SmartMining {&#13;
    using SafeMath for uint256;&#13;
    &#13;
    // -------------------------------------------------------------------------&#13;
    // Variables&#13;
    // -------------------------------------------------------------------------&#13;
    &#13;
    string  constant public name     = "smart-mining.io"; // EIP-20&#13;
    string  constant public symbol   = "SMT";             // EIP-20&#13;
    uint8   constant public decimals = 18;                // EIP-20&#13;
    uint256 public totalSupply       = 10000;             // EIP-20&#13;
    &#13;
    struct Member {                                       // 'Member'-struct&#13;
        bool    crowdsalePrivateSale;                     // If 'true', member can participate in crowdsale before crowdsaleOpen == true&#13;
        uint256 crowdsaleMinPurchase;                     // Approved minimum crowdsale purchase in Wei&#13;
        uint256 balance;                                  // Token balance in Ici, represents the percent of mining profits&#13;
        uint256 unpaid;                                   // Available Wei for withdrawal, + 1 in storage for gas optimization and indicator if address is member of SmartMining contract&#13;
    }                                                  &#13;
    mapping (address =&gt; Member) public members;           // All Crowdsale members as 'Member'-struct&#13;
    &#13;
    uint16    public memberCount;                         // Count of all SmartMining members inclusive the team-contract&#13;
    address[] public memberIndex;                         // Lookuptable of all member addresses to iterate on deposit over and assign unpaid Ether to members&#13;
    address   public owner;                               // Owner of this contract&#13;
    address   public withdrawer;                          // Allowed executor of automatic processed member whitdrawals (SmartMining-API)&#13;
    address   public depositor;                           // Allowed depositor of mining profits&#13;
    &#13;
    bool      public crowdsaleOpen;                       // 'true' if crowdsale is open for investors&#13;
    bool      public crowdsaleFinished;                   // 'true' after crowdsaleCap was reached&#13;
    address   public crowdsaleWallet;                     // Address where crowdsale funds are collected&#13;
    uint256   public crowdsaleCap;                        // Wei after crowdsale is finished&#13;
    uint256   public crowdsaleRaised;                     // Amount of wei raised in crowdsale&#13;
    &#13;
    &#13;
    // -------------------------------------------------------------------------&#13;
    // Constructor&#13;
    // -------------------------------------------------------------------------&#13;
    &#13;
    constructor (uint256 _crowdsaleCapEth, address _crowdsaleWallet, address _teamContract, uint256 _teamShare, address _owner) public {&#13;
        require(_crowdsaleCapEth != 0 &amp;&amp; _crowdsaleWallet != 0x0 &amp;&amp; _teamContract != 0x0 &amp;&amp; _teamShare != 0 &amp;&amp; _owner != 0x0);&#13;
        &#13;
        // Initialize contract owner and trigger 'SetOwner'-event&#13;
        owner = _owner;&#13;
        emit SetOwner(owner);&#13;
        &#13;
        // Update totalSupply with the decimal amount&#13;
        totalSupply = totalSupply.mul(10 ** uint256(decimals));&#13;
        &#13;
        // Convert '_crowdsaleCapEth' from Ether to Wei&#13;
        crowdsaleCap = _crowdsaleCapEth.mul(10 ** 18);&#13;
        &#13;
        // Initialize withdrawer and crowdsaleWallet&#13;
        withdrawer = msg.sender;&#13;
        crowdsaleWallet = _crowdsaleWallet;&#13;
        &#13;
        // Assign totalSupply to contract address and trigger 'from 0x0'-'Transfer'-event for token creation&#13;
        members[address(this)].balance = totalSupply;&#13;
        emit Transfer(0x0, address(this), totalSupply);&#13;
        &#13;
        // Initialize team-contract&#13;
        members[_teamContract].unpaid = 1;&#13;
        memberIndex.push(_teamContract); // memberIndex[0] will become team-contract address&#13;
        memberCount++;&#13;
        &#13;
        // Transfer team tokens&#13;
        uint256 teamTokens = totalSupply.mul(_teamShare).div(100);&#13;
        members[address(this)].balance = members[address(this)].balance.sub(teamTokens);&#13;
        members[_teamContract].balance = teamTokens;&#13;
        emit Transfer(address(this), _teamContract, teamTokens);&#13;
    }&#13;
    &#13;
    &#13;
    // -------------------------------------------------------------------------&#13;
    // Events&#13;
    // -------------------------------------------------------------------------&#13;
    &#13;
    event SetOwner(address indexed owner);&#13;
    event SetDepositor(address indexed depositor);&#13;
    event SetWithdrawer(address indexed withdrawer);&#13;
    event SetTeamContract(address indexed teamContract);&#13;
    event Approve(address indexed member, uint256 crowdsaleMinPurchase, bool privateSale);&#13;
    event Participate(address indexed member, uint256 value, uint256 tokens);&#13;
    event Transfer(address indexed from, address indexed to, uint256 value);&#13;
    event ForwardCrowdsaleFunds(address indexed to, uint256 value);&#13;
    event CrowdsaleStarted(bool value);&#13;
    event CrowdsaleFinished(bool value);&#13;
    event Withdraw(address indexed member, uint256 value);&#13;
    event Deposit(address indexed from, uint256 value);&#13;
    &#13;
    &#13;
    // -------------------------------------------------------------------------&#13;
    // WITHDRAWER (SmartMining-API) &amp; OWNER ONLY external maintenance interface&#13;
    // -------------------------------------------------------------------------&#13;
    &#13;
    function approve (address _beneficiary, uint256 _ethMinPurchase, bool _privateSale) external {&#13;
        require(msg.sender == owner || msg.sender == withdrawer, "Only SmartMining-API and contract owner allowed to approve.");&#13;
        require(crowdsaleFinished == false, "No new approvals after crowdsale finished.");&#13;
        require(_beneficiary != 0x0);&#13;
        &#13;
        if( members[_beneficiary].unpaid == 1 ) {&#13;
            members[_beneficiary].crowdsaleMinPurchase = _ethMinPurchase.mul(10 ** 18);&#13;
            members[_beneficiary].crowdsalePrivateSale = _privateSale;&#13;
        } else {&#13;
            members[_beneficiary].unpaid = 1;&#13;
            members[_beneficiary].crowdsaleMinPurchase = _ethMinPurchase.mul(10 ** 18);&#13;
            members[_beneficiary].crowdsalePrivateSale = _privateSale;&#13;
            &#13;
            memberIndex.push(_beneficiary);&#13;
            memberCount++;&#13;
        }&#13;
        &#13;
        emit Approve(_beneficiary, members[_beneficiary].crowdsaleMinPurchase, _privateSale);&#13;
    }&#13;
    &#13;
    &#13;
    // -------------------------------------------------------------------------&#13;
    // OWNER ONLY external maintenance interface&#13;
    // -------------------------------------------------------------------------&#13;
    &#13;
    modifier onlyOwner () {&#13;
        require(msg.sender == owner);&#13;
        _;&#13;
    }&#13;
    &#13;
    function setTeamContract (address _newTeamContract) external onlyOwner {&#13;
        require(_newTeamContract != 0x0 &amp;&amp; _newTeamContract != memberIndex[0]);&#13;
        &#13;
        // Move team-contract member to new addresss&#13;
        members[_newTeamContract] = members[memberIndex[0]];&#13;
        delete members[memberIndex[0]];&#13;
        &#13;
        // Trigger 'SetTeamContract' &amp; 'Transfer'-event for token movement&#13;
        emit SetTeamContract(_newTeamContract);&#13;
        emit Transfer(memberIndex[0], _newTeamContract, members[_newTeamContract].balance);&#13;
        &#13;
        // Update memberIndex[0] to new team-contract address&#13;
        memberIndex[0] = _newTeamContract;&#13;
    }&#13;
    &#13;
    function setOwner (address _newOwner) external onlyOwner {&#13;
        if( _newOwner != 0x0 ) { owner = _newOwner; } else { owner = msg.sender; }&#13;
        emit SetOwner(owner);&#13;
    }&#13;
    &#13;
    function setDepositor (address _newDepositor) external onlyOwner {&#13;
        depositor = _newDepositor;&#13;
        emit SetDepositor(_newDepositor);&#13;
    }&#13;
    &#13;
    function setWithdrawer (address _newWithdrawer) external onlyOwner {&#13;
        withdrawer = _newWithdrawer;&#13;
        emit SetWithdrawer(_newWithdrawer);&#13;
    }&#13;
    &#13;
    function startCrowdsale () external onlyOwner {&#13;
        require(crowdsaleFinished == false, "Crowdsale can only be started once.");&#13;
        &#13;
        crowdsaleOpen = true;&#13;
        emit CrowdsaleStarted(true);&#13;
    }&#13;
    &#13;
    function cleanupMember (uint256 _memberIndex) external onlyOwner {&#13;
        require(members[memberIndex[_memberIndex]].unpaid == 1, "Not a member.");&#13;
        require(members[memberIndex[_memberIndex]].balance == 0, "Only members without participation can be deleted.");&#13;
        &#13;
        // Delete whitelisted member which not participated in crowdsale&#13;
        delete members[memberIndex[_memberIndex]];&#13;
        memberIndex[_memberIndex] = memberIndex[memberIndex.length-1];&#13;
        memberIndex.length--;&#13;
        memberCount--;&#13;
    }&#13;
    &#13;
    &#13;
    // -------------------------------------------------------------------------&#13;
    // Public external interface&#13;
    // -------------------------------------------------------------------------&#13;
    &#13;
    function () external payable {&#13;
        require(crowdsaleOpen || members[msg.sender].crowdsalePrivateSale || crowdsaleFinished, "smart-mining.io crowdsale not started yet.");&#13;
        &#13;
        if(crowdsaleFinished)&#13;
            deposit();&#13;
        if(crowdsaleOpen || members[msg.sender].crowdsalePrivateSale)&#13;
            participate();&#13;
    }&#13;
    &#13;
    function deposit () public payable {&#13;
        // Pre validate deposit&#13;
        require(crowdsaleFinished, "Deposits only possible after crowdsale finished.");&#13;
        require(msg.sender == depositor, "Only 'depositor' allowed to deposit.");&#13;
        require(msg.value &gt;= 10**9, "Minimum deposit 1 gwei.");&#13;
        &#13;
        // Distribute deposited Ether to all SmartMining members related to their profit-share which is representat by their ICE token balance&#13;
        for (uint i=0; i&lt;memberIndex.length; i++) {&#13;
            members[memberIndex[i]].unpaid = &#13;
                // Adding current deposit to members unpaid Wei amount&#13;
                members[memberIndex[i]].unpaid.add(&#13;
                    // MemberTokenBalance * DepositedWei / totalSupply = WeiAmount of member-share to be added to members unpaid holdings&#13;
                    members[memberIndex[i]].balance.mul(msg.value).div(totalSupply)&#13;
                );&#13;
        }&#13;
        &#13;
        // Trigger 'Deposit'-event&#13;
        emit Deposit(msg.sender, msg.value);&#13;
    }&#13;
    &#13;
    function participate () public payable {&#13;
        // Pre validate purchase&#13;
        require(members[msg.sender].unpaid == 1, "Only whitelisted members are allowed to participate!");&#13;
        require(crowdsaleOpen || members[msg.sender].crowdsalePrivateSale, "Crowdsale is not open.");&#13;
        require(msg.value != 0, "No Ether attached to this buy order.");&#13;
        require(members[msg.sender].crowdsaleMinPurchase == 0 || msg.value &gt;= members[msg.sender].crowdsaleMinPurchase,&#13;
            "Send at least your whitelisted crowdsaleMinPurchase Ether amount!");&#13;
            &#13;
        // Get token count and validate that enaugh tokens are available&#13;
        uint256 tokens = crowdsaleCalcTokenAmount(msg.value);&#13;
        require(members[address(this)].balance &gt;= tokens, "There are not enaugh Tokens left for this order.");&#13;
        emit Participate(msg.sender, msg.value, tokens);&#13;
        &#13;
        // Remove members crowdsaleMinPurchase for further orders&#13;
        members[msg.sender].crowdsaleMinPurchase = 0;&#13;
        &#13;
        // Subtract tokens from contract and add tokens to members current holdings (Transfer)&#13;
        members[address(this)].balance = members[address(this)].balance.sub(tokens);&#13;
        members[msg.sender].balance = members[msg.sender].balance.add(tokens);&#13;
        emit Transfer(address(this), msg.sender, tokens);&#13;
        &#13;
        // Update crowdsale states&#13;
        crowdsaleRaised = crowdsaleRaised.add(msg.value);&#13;
        if(members[address(this)].balance == 0) {&#13;
            // Close crowdsale if all tokens are sold out&#13;
            crowdsaleOpen = false;&#13;
            crowdsaleFinished = true;&#13;
            emit CrowdsaleFinished(true);&#13;
        }&#13;
        &#13;
        // Forward msg.value (attached Ether) to crowdsaleWallet and trigger 'ForwardCrowdsaleFunds'-event&#13;
        emit ForwardCrowdsaleFunds(crowdsaleWallet, msg.value);&#13;
        crowdsaleWallet.transfer(msg.value);&#13;
    }&#13;
    &#13;
    function crowdsaleCalcTokenAmount (uint256 _weiAmount) public view returns (uint256) {&#13;
        // Multiplied by totalSupply to avoid floats in calculation&#13;
        return &#13;
            // _weiAmount * totalSupply / crowdsaleCap * crowdsaleSupply / totalSupply&#13;
            _weiAmount&#13;
            .mul(totalSupply)&#13;
            .div(crowdsaleCap)&#13;
            .mul( totalSupply.sub(members[memberIndex[0]].balance) )&#13;
            .div(totalSupply);&#13;
    }&#13;
    &#13;
    function withdrawOf              (address _beneficiary) external                      { _withdraw(_beneficiary); }&#13;
    function withdraw                ()                     external                      { _withdraw(msg.sender); }&#13;
    function balanceOf               (address _beneficiary) public view returns (uint256) { return members[_beneficiary].balance; }&#13;
    function unpaidOf                (address _beneficiary) public view returns (uint256) { return members[_beneficiary].unpaid.sub(1); }&#13;
    function crowdsaleIsMemberOf     (address _beneficiary) public view returns (bool)    { return members[_beneficiary].unpaid &gt;= 1; }&#13;
    function crowdsaleRemainingWei   ()                     public view returns (uint256) { return crowdsaleCap.sub(crowdsaleRaised); }&#13;
    function crowdsaleRemainingToken ()                     public view returns (uint256) { return members[address(this)].balance; }&#13;
    function crowdsalePercentOfTotalSupply ()               public view returns (uint256) { return totalSupply.sub(members[memberIndex[0]].balance).mul(100).div(totalSupply); }&#13;
    &#13;
    &#13;
    // -------------------------------------------------------------------------&#13;
    // Private functions, can only be called by this contract&#13;
    // -------------------------------------------------------------------------&#13;
    &#13;
    function _withdraw (address _beneficiary) private {&#13;
        // Pre-validate withdrawal&#13;
        if(msg.sender != _beneficiary) {&#13;
            require(msg.sender == owner || msg.sender == withdrawer, "Only 'owner' and 'withdrawer' can withdraw for other members.");&#13;
        }&#13;
        require(members[_beneficiary].unpaid &gt;= 1, "Not a member account.");&#13;
        require(members[_beneficiary].unpaid &gt; 1, "No unpaid balance on account.");&#13;
        &#13;
        // Remember members unpaid amount but remove it from his contract holdings before initiating the withdrawal for security reasons&#13;
        uint256 unpaid = members[_beneficiary].unpaid.sub(1);&#13;
        members[_beneficiary].unpaid = 1;&#13;
        &#13;
        // Trigger 'Withdraw'-event&#13;
        emit Withdraw(_beneficiary, unpaid);&#13;
        &#13;
        // Transfer the unpaid Wei amount to member address&#13;
        if(_beneficiary != memberIndex[0]) {&#13;
            // Client withdrawals rely on the 'gas stipend' (2300 gas) which has been checked during KYC&#13;
            _beneficiary.transfer(unpaid);&#13;
        } else {&#13;
            // Team-contract withdrawals obtain up to 100 times more gas for further automatic processing&#13;
            require( _beneficiary.call.gas(230000).value(unpaid)() );&#13;
        }&#13;
    }&#13;
    &#13;
    &#13;
}