pragma solidity ^0.4.8;

// @address 0x
// @multisig
// The implementation for the IME.IME ICO smart contract was inspired by
// the Ethereum token creation tutorial, the FirstBlood token, and the BAT token.
// compiler: 0.4.17+commit.bdeb9e52

/*
1. Contract Address: 0x

2. Official Site URL:https://www.IME.IM/

3. Link to download a 28x28png icon logo:https://IME.IM/TOKENLOGO.png

4. Official Contact Email Address:<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="7930343930343c573034">[emailÂ protected]</a>&#13;
&#13;
5. Link to blog (optional):&#13;
&#13;
6. Link to reddit (optional):&#13;
&#13;
7. Link to slack (optional):https://&#13;
&#13;
8. Link to facebook (optional):https://www.facebook.com/&#13;
&#13;
9. Link to twitter (optional):@&#13;
&#13;
10. Link to bitcointalk (optional):&#13;
&#13;
11. Link to github (optional):https://github.com/IMEIM&#13;
&#13;
12. Link to telegram (optional):https://t.me/&#13;
&#13;
13. Link to whitepaper (optional):https://hitepaper_EN.pdf&#13;
*/&#13;
&#13;
///////////////&#13;
// SAFE MATH //&#13;
///////////////&#13;
&#13;
contract SafeMath {&#13;
&#13;
    function safeAdd(uint256 x, uint256 y) internal returns(uint256) {&#13;
        uint256 z = x + y;&#13;
        require((z &gt;= x) &amp;&amp; (z &gt;= y));&#13;
        return z;&#13;
    }&#13;
&#13;
    function safeSubtract(uint256 x, uint256 y) internal returns(uint256) {&#13;
        require(x &gt;= y);&#13;
        uint256 z = x - y;&#13;
        return z;&#13;
    }&#13;
&#13;
    function safeMult(uint256 x, uint256 y) internal returns(uint256) {&#13;
        uint256 z = x * y;&#13;
        require((x == 0)||(z/x == y));&#13;
        return z;&#13;
    }&#13;
&#13;
}&#13;
&#13;
&#13;
////////////////////&#13;
// STANDARD TOKEN //&#13;
////////////////////&#13;
&#13;
contract Token {&#13;
    uint256 public totalSupply;&#13;
    function balanceOf(address _owner) constant public returns (uint256 balance);&#13;
    function transfer(address _to, uint256 _value) public returns (bool success);&#13;
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);&#13;
    function approve(address _spender, uint256 _value) public returns (bool success);&#13;
    function allowance(address _owner, address _spender) constant public returns (uint256 remaining);&#13;
    event Transfer(address indexed _from, address indexed _to, uint256 _value);&#13;
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);&#13;
}&#13;
&#13;
/*  ERC 20 token */&#13;
contract StandardToken is Token {&#13;
&#13;
    mapping (address =&gt; uint256) balances;&#13;
    //pre ico locked balance&#13;
    mapping (address =&gt; uint256) lockedBalances;&#13;
    mapping (address =&gt; uint256) initLockedBalances;&#13;
&#13;
    mapping (address =&gt; mapping (address =&gt; uint256)) allowed;&#13;
    bool allowTransfer = false;&#13;
&#13;
    function transfer(address _to, uint256 _value) public returns (bool success){&#13;
        if (balances[msg.sender] &gt;= _value &amp;&amp; _value &gt; 0 &amp;&amp; allowTransfer) {&#13;
            balances[msg.sender] -= _value;&#13;
            balances[_to] += _value;&#13;
            Transfer(msg.sender, _to, _value);&#13;
            return true;&#13;
        } else {&#13;
            return false;&#13;
        }&#13;
    }&#13;
&#13;
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success){&#13;
        if (balances[_from] &gt;= _value &amp;&amp; allowed[_from][msg.sender] &gt;= _value &amp;&amp; _value &gt; 0 &amp;&amp; allowTransfer) {&#13;
            balances[_to] += _value;&#13;
            balances[_from] -= _value;&#13;
            allowed[_from][msg.sender] -= _value;&#13;
            Transfer(_from, _to, _value);&#13;
            return true;&#13;
        } else {&#13;
            return false;&#13;
        }&#13;
    }&#13;
&#13;
    function balanceOf(address _owner) constant public returns (uint256 balance){&#13;
        return balances[_owner] + lockedBalances[_owner];&#13;
    }&#13;
    function availableBalanceOf(address _owner) constant public returns (uint256 balance){&#13;
        return balances[_owner];&#13;
    }&#13;
&#13;
    function approve(address _spender, uint256 _value) public returns (bool success){&#13;
        allowed[msg.sender][_spender] = _value;&#13;
        Approval(msg.sender, _spender, _value);&#13;
        return true;&#13;
    }&#13;
&#13;
    function allowance(address _owner, address _spender) constant public returns (uint256 remaining){&#13;
        return allowed[_owner][_spender];&#13;
    }&#13;
}&#13;
&#13;
/////////////////////&#13;
//IME.IM ICO TOKEN//&#13;
/////////////////////&#13;
&#13;
contract IMETOKEN is StandardToken, SafeMath {&#13;
    // Descriptive properties&#13;
    string public constant name = "IME.IM Token";&#13;
    string public constant symbol = "IME";&#13;
    uint256 public constant decimals = 18;&#13;
    string public version = "1.0";&#13;
&#13;
    // Account for ether proceed.&#13;
    address public etherProceedsAccount = 0x0;&#13;
    address public multiWallet = 0x0;&#13;
&#13;
    //owners&#13;
    mapping (address =&gt; bool) public isOwner;&#13;
    address[] public owners;&#13;
&#13;
    // These params specify the start, end, min, and max of the sale.&#13;
    bool public isFinalized;&#13;
&#13;
    uint256 public window0TotalSupply = 0;&#13;
    uint256 public window1TotalSupply = 0;&#13;
    uint256 public window2TotalSupply = 0;&#13;
    uint256 public window3TotalSupply = 0;&#13;
&#13;
    uint256 public window0StartTime = 0;&#13;
    uint256 public window0EndTime = 0;&#13;
    uint256 public window1StartTime = 0;&#13;
    uint256 public window1EndTime = 0;&#13;
    uint256 public window2StartTime = 0;&#13;
    uint256 public window2EndTime = 0;&#13;
    uint256 public window3StartTime = 0;&#13;
    uint256 public window3EndTime = 0;&#13;
&#13;
    // setting the capacity of every part of ico&#13;
    uint256 public preservedTokens = 1300000000 * 10**decimals;&#13;
    uint256 public window0TokenCreationCap = 200000000 * 10**decimals;&#13;
    uint256 public window1TokenCreationCap = 200000000 * 10**decimals;&#13;
    uint256 public window2TokenCreationCap = 300000000 * 10**decimals;&#13;
    uint256 public window3TokenCreationCap = 0 * 10**decimals;&#13;
&#13;
    // Setting the exchange rate for the ICO.&#13;
    uint256 public window0TokenExchangeRate = 5000;&#13;
    uint256 public window1TokenExchangeRate = 4000;&#13;
    uint256 public window2TokenExchangeRate = 3000;&#13;
    uint256 public window3TokenExchangeRate = 0;&#13;
&#13;
    uint256 public preICOLimit = 0;&#13;
    bool public instantTransfer = false;&#13;
&#13;
    // Events for logging refunds and token creation.&#13;
    event CreateGameIco(address indexed _to, uint256 _value);&#13;
    event PreICOTokenPushed(address indexed _buyer, uint256 _amount);&#13;
    event UnlockBalance(address indexed _owner, uint256 _amount);&#13;
    event OwnerAddition(address indexed owner);&#13;
    event OwnerRemoval(address indexed owner);&#13;
&#13;
    modifier ownerExists(address owner) {&#13;
        require(isOwner[owner]);&#13;
        _;&#13;
    }&#13;
&#13;
    // constructor&#13;
    function IMEIM() public&#13;
    {&#13;
        totalSupply             = 2000000000 * 10**decimals;&#13;
        isFinalized             = false;&#13;
        etherProceedsAccount    = msg.sender;&#13;
    }&#13;
    function adjustTime(&#13;
    uint256 _window0StartTime, uint256 _window0EndTime,&#13;
    uint256 _window1StartTime, uint256 _window1EndTime,&#13;
    uint256 _window2StartTime, uint256 _window2EndTime)&#13;
    public{&#13;
        require(msg.sender == etherProceedsAccount);&#13;
        window0StartTime = _window0StartTime;&#13;
        window0EndTime = _window0EndTime;&#13;
        window1StartTime = _window1StartTime;&#13;
        window1EndTime = _window1EndTime;&#13;
        window2StartTime = _window2StartTime;&#13;
        window2EndTime = _window2EndTime;&#13;
    }&#13;
    function adjustSupply(&#13;
    uint256 _window0TotalSupply,&#13;
    uint256 _window1TotalSupply,&#13;
    uint256 _window2TotalSupply)&#13;
    public{&#13;
        require(msg.sender == etherProceedsAccount);&#13;
        window0TotalSupply = _window0TotalSupply * 10**decimals;&#13;
        window1TotalSupply = _window1TotalSupply * 10**decimals;&#13;
        window2TotalSupply = _window2TotalSupply * 10**decimals;&#13;
    }&#13;
    function adjustCap(&#13;
    uint256 _preservedTokens,&#13;
    uint256 _window0TokenCreationCap,&#13;
    uint256 _window1TokenCreationCap,&#13;
    uint256 _window2TokenCreationCap)&#13;
    public{&#13;
        require(msg.sender == etherProceedsAccount);&#13;
        preservedTokens = _preservedTokens * 10**decimals;&#13;
        window0TokenCreationCap = _window0TokenCreationCap * 10**decimals;&#13;
        window1TokenCreationCap = _window1TokenCreationCap * 10**decimals;&#13;
        window2TokenCreationCap = _window2TokenCreationCap * 10**decimals;&#13;
    }&#13;
    function adjustRate(&#13;
    uint256 _window0TokenExchangeRate,&#13;
    uint256 _window1TokenExchangeRate,&#13;
    uint256 _window2TokenExchangeRate)&#13;
    public{&#13;
        require(msg.sender == etherProceedsAccount);&#13;
        window0TokenExchangeRate = _window0TokenExchangeRate;&#13;
        window1TokenExchangeRate = _window1TokenExchangeRate;&#13;
        window2TokenExchangeRate = _window2TokenExchangeRate;&#13;
    }&#13;
    function setProceedsAccount(address _newEtherProceedsAccount)&#13;
    public{&#13;
        require(msg.sender == etherProceedsAccount);&#13;
        etherProceedsAccount = _newEtherProceedsAccount;&#13;
    }&#13;
    function setMultiWallet(address _newWallet)&#13;
    public{&#13;
        require(msg.sender == etherProceedsAccount);&#13;
        multiWallet = _newWallet;&#13;
    }&#13;
    function setPreICOLimit(uint256 _preICOLimit)&#13;
    public{&#13;
        require(msg.sender == etherProceedsAccount);&#13;
        preICOLimit = _preICOLimit;&#13;
    }&#13;
    function setInstantTransfer(bool _instantTransfer)&#13;
    public{&#13;
        require(msg.sender == etherProceedsAccount);&#13;
        instantTransfer = _instantTransfer;&#13;
    }&#13;
    function setAllowTransfer(bool _allowTransfer)&#13;
    public{&#13;
        require(msg.sender == etherProceedsAccount);&#13;
        allowTransfer = _allowTransfer;&#13;
    }&#13;
    function addOwner(address owner)&#13;
    public{&#13;
        require(msg.sender == etherProceedsAccount);&#13;
        isOwner[owner] = true;&#13;
        owners.push(owner);&#13;
        OwnerAddition(owner);&#13;
    }&#13;
    function removeOwner(address owner)&#13;
    public{&#13;
        require(msg.sender == etherProceedsAccount);&#13;
        isOwner[owner] = false;&#13;
        OwnerRemoval(owner);&#13;
    }&#13;
&#13;
    function preICOPush(address buyer, uint256 amount)&#13;
    public{&#13;
        require(msg.sender == etherProceedsAccount);&#13;
&#13;
        uint256 tokens = 0;&#13;
        uint256 checkedSupply = 0;&#13;
        checkedSupply = safeAdd(window0TotalSupply, amount);&#13;
        require(window0TokenCreationCap &gt;= checkedSupply);&#13;
        assignLockedBalance(buyer, amount);&#13;
        window0TotalSupply = checkedSupply;&#13;
        PreICOTokenPushed(buyer, amount);&#13;
    }&#13;
    function lockedBalanceOf(address _owner) constant public returns (uint256 balance) {&#13;
        return lockedBalances[_owner];&#13;
    }&#13;
    function initLockedBalanceOf(address _owner) constant public returns (uint256 balance) {&#13;
        return initLockedBalances[_owner];&#13;
    }&#13;
    function unlockBalance(address _owner, uint256 prob)&#13;
    public&#13;
    ownerExists(msg.sender)&#13;
    returns (bool){&#13;
        uint256 shouldUnlockedBalance = 0;&#13;
        shouldUnlockedBalance = initLockedBalances[_owner] * prob / 100;&#13;
        if(shouldUnlockedBalance &gt; lockedBalances[_owner]){&#13;
            shouldUnlockedBalance = lockedBalances[_owner];&#13;
        }&#13;
        balances[_owner] += shouldUnlockedBalance;&#13;
        lockedBalances[_owner] -= shouldUnlockedBalance;&#13;
        UnlockBalance(_owner, shouldUnlockedBalance);&#13;
        return true;&#13;
    }&#13;
&#13;
    function () payable public{&#13;
        create();&#13;
    }&#13;
    function create() internal{&#13;
        require(!isFinalized);&#13;
        require(msg.value &gt;= 0.01 ether);&#13;
        uint256 tokens = 0;&#13;
        uint256 checkedSupply = 0;&#13;
&#13;
        if(window0StartTime != 0 &amp;&amp; window0EndTime != 0 &amp;&amp; time() &gt;= window0StartTime &amp;&amp; time() &lt;= window0EndTime){&#13;
            if(preICOLimit &gt; 0){&#13;
                require(msg.value &gt;= preICOLimit);&#13;
            }&#13;
            tokens = safeMult(msg.value, window0TokenExchangeRate);&#13;
            checkedSupply = safeAdd(window0TotalSupply, tokens);&#13;
            require(window0TokenCreationCap &gt;= checkedSupply);&#13;
            assignLockedBalance(msg.sender, tokens);&#13;
            window0TotalSupply = checkedSupply;&#13;
            if(multiWallet != 0x0 &amp;&amp; instantTransfer) multiWallet.transfer(msg.value);&#13;
            CreateGameIco(msg.sender, tokens);&#13;
        }else if(window1StartTime != 0 &amp;&amp; window1EndTime!= 0 &amp;&amp; time() &gt;= window1StartTime &amp;&amp; time() &lt;= window1EndTime){&#13;
            tokens = safeMult(msg.value, window1TokenExchangeRate);&#13;
            checkedSupply = safeAdd(window1TotalSupply, tokens);&#13;
            require(window1TokenCreationCap &gt;= checkedSupply);&#13;
            balances[msg.sender] += tokens;&#13;
            window1TotalSupply = checkedSupply;&#13;
            if(multiWallet != 0x0 &amp;&amp; instantTransfer) multiWallet.transfer(msg.value);&#13;
            CreateGameIco(msg.sender, tokens);&#13;
        }else if(window2StartTime != 0 &amp;&amp; window2EndTime != 0 &amp;&amp; time() &gt;= window2StartTime &amp;&amp; time() &lt;= window2EndTime){&#13;
            tokens = safeMult(msg.value, window2TokenExchangeRate);&#13;
            checkedSupply = safeAdd(window2TotalSupply, tokens);&#13;
            require(window2TokenCreationCap &gt;= checkedSupply);&#13;
            balances[msg.sender] += tokens;&#13;
            window2TotalSupply = checkedSupply;&#13;
            if(multiWallet != 0x0 &amp;&amp; instantTransfer) multiWallet.transfer(msg.value);&#13;
            CreateGameIco(msg.sender, tokens);&#13;
        }else{&#13;
            require(false);&#13;
        }&#13;
&#13;
    }&#13;
&#13;
    function time() internal returns (uint) {&#13;
        return block.timestamp;&#13;
    }&#13;
&#13;
    function today(uint startTime) internal returns (uint) {&#13;
        return dayFor(time(), startTime);&#13;
    }&#13;
&#13;
    function dayFor(uint timestamp, uint startTime) internal returns (uint) {&#13;
        return timestamp &lt; startTime ? 0 : safeSubtract(timestamp, startTime) / 24 hours + 1;&#13;
    }&#13;
&#13;
    function withDraw(uint256 _value) public{&#13;
        require(msg.sender == etherProceedsAccount);&#13;
        if(multiWallet != 0x0){&#13;
            multiWallet.transfer(_value);&#13;
        }else{&#13;
            etherProceedsAccount.transfer(_value);&#13;
        }&#13;
    }&#13;
&#13;
    function finalize() public{&#13;
        require(!isFinalized);&#13;
        require(msg.sender == etherProceedsAccount);&#13;
        isFinalized = true;&#13;
        if(multiWallet != 0x0){&#13;
            assignLockedBalance(multiWallet, totalSupply- window0TotalSupply- window1TotalSupply - window2TotalSupply);&#13;
            if(this.balance &gt; 0) multiWallet.transfer(this.balance);&#13;
        }else{&#13;
            assignLockedBalance(etherProceedsAccount, totalSupply- window0TotalSupply- window1TotalSupply - window2TotalSupply);&#13;
            if(this.balance &gt; 0) etherProceedsAccount.transfer(this.balance);&#13;
        }&#13;
    }&#13;
&#13;
    function supply() constant public returns (uint256){&#13;
        return window0TotalSupply + window1TotalSupply + window2TotalSupply;&#13;
    }&#13;
&#13;
    function assignLockedBalance(address _owner, uint256 val) private{&#13;
        initLockedBalances[_owner] += val;&#13;
        lockedBalances[_owner] += val;&#13;
    }&#13;
&#13;
}