/*
 file:   Trullion.sol
 ver:    0.0.1_deploy
 author: Trivillon
 date:   24-Nov-2018
 email:  <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="1b686e6b6b74696f5b4f696e7777727475356f7e7873">[emailÂ protected]</a>&#13;
&#13;
 Licence&#13;
 -------&#13;
 (c) 2018 Everus-Trullion &#13;
   &#13;
 Release Notes&#13;
 -------------&#13;
 * Trullion  Based in Kualalumpur, Malaysia , we're blessed with strong rule of law, and great beaches. Welcome to Trullion.&#13;
&#13;
 * This contract is TRU, GOLD as an ERC20 token.&#13;
&#13;
 * see https://Everus.org/ for further information&#13;
&#13;
*/&#13;
&#13;
pragma solidity ^0.4.17;&#13;
&#13;
&#13;
contract TRUConfig&#13;
{&#13;
    // ERC20 token name&#13;
    string  public constant name            = "Trullion-e";&#13;
&#13;
    // ERC20 trading symbol&#13;
    string  public constant symbol          = "Tru-e";&#13;
&#13;
    // Contract owner at time of deployment.&#13;
    address public constant OWNER = 0x262f01741f2b6e6fda97bce85a6756a89c099e43;&#13;
&#13;
    // Contract 2nd admin&#13;
    address public constant ADMIN_TOO  = 0x262f01741f2b6e6fda97bce85a6756a89c099e43;&#13;
&#13;
    // Opening Supply&#13;
    uint    public constant TOTAL_TOKENS    = 0 ;&#13;
&#13;
    // ERC20 decimal places&#13;
    uint8   public constant decimals        = 8;&#13;
&#13;
&#13;
}&#13;
&#13;
&#13;
library SafeMath&#13;
{&#13;
    // a add to b&#13;
    function add(uint a, uint b) internal pure returns (uint c) {&#13;
        c = a + b;&#13;
        assert(c &gt;= a);&#13;
    }&#13;
&#13;
    // a subtract b&#13;
    function sub(uint a, uint b) internal pure returns (uint c) {&#13;
        c = a - b;&#13;
        assert(c &lt;= a);&#13;
    }&#13;
&#13;
    // a multiplied by b&#13;
    function mul(uint a, uint b) internal pure returns (uint c) {&#13;
        c = a * b;&#13;
        assert(a == 0 || c / a == b);&#13;
    }&#13;
&#13;
    // a divided by b&#13;
    function div(uint a, uint b) internal pure returns (uint c) {&#13;
        assert(b != 0);&#13;
        c = a / b;&#13;
    }&#13;
}&#13;
&#13;
&#13;
contract ReentryProtected&#13;
{&#13;
    // The reentry protection state mutex.&#13;
    bool __reMutex;&#13;
&#13;
    // Sets and clears mutex in order to block function reentry&#13;
    modifier preventReentry() {&#13;
        require(!__reMutex);&#13;
        __reMutex = true;&#13;
        _;&#13;
        delete __reMutex;&#13;
    }&#13;
&#13;
    // Blocks function entry if mutex is set&#13;
    modifier noReentry() {&#13;
        require(!__reMutex);&#13;
        _;&#13;
    }&#13;
}&#13;
&#13;
&#13;
contract ERC20Token&#13;
{&#13;
    using SafeMath for uint;&#13;
&#13;
/* Constants */&#13;
&#13;
    // none&#13;
&#13;
/* State variable */&#13;
&#13;
    /// @return The Total supply of tokens&#13;
    uint public totalSupply;&#13;
&#13;
    /// @return Tokens owned by an address&#13;
    mapping (address =&gt; uint) balances;&#13;
&#13;
    /// @return Tokens spendable by a thridparty&#13;
    mapping (address =&gt; mapping (address =&gt; uint)) allowed;&#13;
&#13;
/* Events */&#13;
&#13;
    // Triggered when tokens are transferred.&#13;
    event Transfer(&#13;
        address indexed _from,&#13;
        address indexed _to,&#13;
        uint256 _amount);&#13;
&#13;
    // Triggered whenever approve(address _spender, uint256 _amount) is called.&#13;
    event Approval(&#13;
        address indexed _owner,&#13;
        address indexed _spender,&#13;
        uint256 _amount);&#13;
&#13;
/* Modifiers */&#13;
&#13;
    // none&#13;
&#13;
/* Functions */&#13;
&#13;
    // Using an explicit getter allows for function overloading&#13;
    function balanceOf(address _addr)&#13;
        public&#13;
        view&#13;
        returns (uint)&#13;
    {&#13;
        return balances[_addr];&#13;
    }&#13;
&#13;
    // Quick checker on total supply&#13;
    function currentSupply()&#13;
        public&#13;
        view&#13;
        returns (uint)&#13;
    {&#13;
        return totalSupply;&#13;
    }&#13;
&#13;
&#13;
    // Using an explicit getter allows for function overloading&#13;
    function allowance(address _owner, address _spender)&#13;
        public&#13;
        returns (uint)&#13;
    {&#13;
        return allowed[_owner][_spender];&#13;
    }&#13;
&#13;
    // Send _value amount of tokens to address _to&#13;
    function transfer(address _to, uint256 _amount)&#13;
        public&#13;
        returns (bool)&#13;
    {&#13;
        return xfer(msg.sender, _to, _amount);&#13;
    }&#13;
&#13;
    // Send _value amount of tokens from address _from to address _to&#13;
    function transferFrom(address _from, address _to, uint256 _amount)&#13;
        public&#13;
        returns (bool)&#13;
    {&#13;
        require(_amount &lt;= allowed[_from][msg.sender]);&#13;
&#13;
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);&#13;
        return xfer(_from, _to, _amount);&#13;
    }&#13;
&#13;
    // Process a transfer internally.&#13;
    function xfer(address _from, address _to, uint _amount)&#13;
        internal&#13;
        returns (bool)&#13;
    {&#13;
        require(_amount &lt;= balances[_from]);&#13;
&#13;
        emit Transfer(_from, _to, _amount);&#13;
&#13;
        // avoid wasting gas on 0 token transfers&#13;
        if(_amount == 0) return true;&#13;
&#13;
        balances[_from] = balances[_from].sub(_amount);&#13;
        balances[_to]   = balances[_to].add(_amount);&#13;
&#13;
        return true;&#13;
    }&#13;
&#13;
    // Approves a third-party spender&#13;
    function approve(address _spender, uint256 _amount)&#13;
        public&#13;
        returns (bool)&#13;
    {&#13;
        allowed[msg.sender][_spender] = _amount;&#13;
        emit Approval(msg.sender, _spender, _amount);&#13;
        return true;&#13;
    }&#13;
}&#13;
&#13;
&#13;
&#13;
contract TRUAbstract&#13;
{&#13;
&#13;
    /// @dev Logged when new owner accepts ownership&#13;
    /// @param _from the old owner address&#13;
    /// @param _to the new owner address&#13;
    event ChangedOwner(address indexed _from, address indexed _to);&#13;
&#13;
    /// @dev Logged when owner initiates a change of ownership&#13;
    /// @param _to the new owner address&#13;
    event ChangeOwnerTo(address indexed _to);&#13;
&#13;
    /// @dev Logged when new adminToo accepts the role&#13;
    /// @param _from the old owner address&#13;
    /// @param _to the new owner address&#13;
    event ChangedAdminToo(address indexed _from, address indexed _to);&#13;
&#13;
    /// @dev Logged when owner initiates a change of ownership&#13;
    /// @param _to the new owner address&#13;
    event ChangeAdminToo(address indexed _to);&#13;
&#13;
// State Variables&#13;
//&#13;
    /// @dev An address permissioned to enact owner restricted functions&#13;
    /// @return owner&#13;
    address public owner;&#13;
&#13;
    /// @dev An address permissioned to take ownership of the contract&#13;
    /// @return new owner address&#13;
    address public newOwner;&#13;
&#13;
    /// @dev An address used in the withdrawal process&#13;
    /// @return adminToo&#13;
    address public adminToo;&#13;
&#13;
    /// @dev An address permissioned to become the withdrawal process address&#13;
    /// @return new admin address&#13;
    address public newAdminToo;&#13;
&#13;
//&#13;
// Modifiers&#13;
//&#13;
&#13;
    modifier onlyOwner() {&#13;
        require(msg.sender == owner);&#13;
        _;&#13;
    }&#13;
&#13;
//&#13;
// Function Abstracts&#13;
//&#13;
&#13;
&#13;
    /// @notice Make bulk transfer of tokens to many addresses (Automic drop)&#13;
    /// @param _addrs An array of recipient addresses&#13;
    /// @param _amounts An array of amounts to transfer to respective addresses&#13;
    /// @return Boolean success value&#13;
 &#13;
    function transferToMany(address[] _addrs, uint[] _amounts)&#13;
        public returns (bool);&#13;
&#13;
    /// @notice Salvage `_amount` tokens at `_kaddr` and send them to `_to`&#13;
    /// @param _kAddr An ERC20 contract address&#13;
    /// @param _to and address to send tokens&#13;
    /// @param _amount The number of tokens to transfer&#13;
    /// @return Boolean success value&#13;
    function transferExternalToken(address _kAddr, address _to, uint _amount)&#13;
        public returns (bool);&#13;
}&#13;
&#13;
&#13;
/*-----------------------------------------------------------------------------\&#13;
&#13;
BTCR implementation&#13;
&#13;
\*----------------------------------------------------------------------------*/&#13;
&#13;
contract TRU is&#13;
    ReentryProtected,&#13;
    ERC20Token,&#13;
   TRUAbstract,&#13;
   TRUConfig&#13;
{&#13;
    using SafeMath for uint;&#13;
&#13;
//&#13;
// Constants&#13;
//&#13;
&#13;
    // Token fixed point for decimal places&#13;
    uint constant TOKEN = uint(10)**decimals;&#13;
&#13;
&#13;
//&#13;
// Functions&#13;
//&#13;
&#13;
    constructor()&#13;
        public&#13;
    {&#13;
&#13;
        owner = OWNER;&#13;
        adminToo = ADMIN_TOO;&#13;
        totalSupply = TOTAL_TOKENS.mul(TOKEN);&#13;
        balances[owner] = totalSupply;&#13;
&#13;
    }&#13;
&#13;
    // Default function.&#13;
    function ()&#13;
        public&#13;
        payable&#13;
    {&#13;
        // nothing to see here, folks....&#13;
    }&#13;
&#13;
&#13;
//&#13;
// Manage supply&#13;
//&#13;
&#13;
event DecreaseSupply(address indexed burner, uint256 value);&#13;
event IncreaseSupply(address indexed burner, uint256 value);&#13;
&#13;
    /**&#13;
     * @dev lowers the supply by a specified amount of tokens.&#13;
     * @param _value The amount of tokens to lower the supply by.&#13;
     */&#13;
&#13;
    function decreaseSupply(uint256 _value)&#13;
        public&#13;
        onlyOwner {&#13;
            require(_value &gt; 0);&#13;
            address burner = adminToo;&#13;
            balances[burner] = balances[burner].sub(_value);&#13;
            totalSupply = totalSupply.sub(_value);&#13;
            emit DecreaseSupply(msg.sender, _value);&#13;
    }&#13;
&#13;
    function increaseSupply(uint256 _value)&#13;
        public&#13;
        onlyOwner {&#13;
            require(_value &gt; 0);&#13;
            totalSupply = totalSupply.add(_value);&#13;
            balances[owner] = balances[owner].add(_value);&#13;
            emit IncreaseSupply(msg.sender, _value);&#13;
    }&#13;
&#13;
&#13;
&#13;
&#13;
//&#13;
// ERC20 additional functions&#13;
//&#13;
&#13;
    // Allows a sender to transfer tokens to an array of recipients&#13;
    function transferToMany(address[] _addrs, uint[] _amounts)&#13;
        public&#13;
        noReentry&#13;
        returns (bool)&#13;
    {&#13;
        require(_addrs.length == _amounts.length);&#13;
        uint len = _addrs.length;&#13;
        for(uint i = 0; i &lt; len; i++) {&#13;
            xfer(msg.sender, _addrs[i], _amounts[i]);&#13;
        }&#13;
        return true;&#13;
    }&#13;
&#13;
   // Overload placeholder - could apply further logic&#13;
    function xfer(address _from, address _to, uint _amount)&#13;
        internal&#13;
        noReentry&#13;
        returns (bool)&#13;
    {&#13;
        super.xfer(_from, _to, _amount);&#13;
        return true;&#13;
    }&#13;
&#13;
//&#13;
// Contract management functions&#13;
//&#13;
&#13;
    // Initiate a change of owner to `_owner`&#13;
    function changeOwner(address _owner)&#13;
        public&#13;
        onlyOwner&#13;
        returns (bool)&#13;
    {&#13;
        emit ChangeOwnerTo(_owner);&#13;
        newOwner = _owner;&#13;
        return true;&#13;
    }&#13;
&#13;
    // Finalise change of ownership to newOwner&#13;
    function acceptOwnership()&#13;
        public&#13;
        returns (bool)&#13;
    {&#13;
        require(msg.sender == newOwner);&#13;
        emit ChangedOwner(owner, msg.sender);&#13;
        owner = newOwner;&#13;
        delete newOwner;&#13;
        return true;&#13;
    }&#13;
&#13;
    // Initiate a change of 2nd admin to _adminToo&#13;
    function changeAdminToo(address _adminToo)&#13;
        public&#13;
        onlyOwner&#13;
        returns (bool)&#13;
    {&#13;
        emit ChangeAdminToo(_adminToo);&#13;
        newAdminToo = _adminToo;&#13;
        return true;&#13;
    }&#13;
&#13;
    // Finalise change of 2nd admin to newAdminToo&#13;
    function acceptAdminToo()&#13;
        public&#13;
        returns (bool)&#13;
    {&#13;
        require(msg.sender == newAdminToo);&#13;
        emit ChangedAdminToo(adminToo, msg.sender);&#13;
        adminToo = newAdminToo;&#13;
        delete newAdminToo;&#13;
        return true;&#13;
    }&#13;
&#13;
&#13;
&#13;
    // Owner can salvage ERC20 tokens that may have been sent to the account&#13;
    function transferExternalToken(address _kAddr, address _to, uint _amount)&#13;
        public&#13;
        onlyOwner&#13;
        preventReentry&#13;
        returns (bool)&#13;
    {&#13;
        require(ERC20Token(_kAddr).transfer(_to, _amount));&#13;
        return true;&#13;
    }&#13;
&#13;
&#13;
}