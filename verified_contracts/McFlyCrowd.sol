pragma solidity ^0.4.19;

/**
 * @title ERC20 Basic smart contract
 * @author Copyright (c) 2016 Smart Contract Solutions, Inc.
 * @author "Manuel Araoz <<span class="__cf_email__" data-cfemail="99f4f8f7ecfcf5f8ebf8f6e3d9fef4f8f0f5b7faf6f4">[email protected]</span>&gt;"&#13;
 * @dev Simpler version of ERC20 interface&#13;
 * @dev see https://github.com/ethereum/EIPs/issues/179&#13;
 * @dev license: "MIT", source: https://github.com/OpenZeppelin/zeppelin-solidity&#13;
 * @author modification: Dmitriy Khizhinskiy @McFly.aero&#13;
 */&#13;
contract ERC20Basic {&#13;
    function totalSupply() public view returns (uint256);&#13;
    function balanceOf(address who) public view returns (uint256);&#13;
    function transfer(address to, uint256 value) public returns (bool);&#13;
    event Transfer(address indexed from, address indexed to, uint256 value);&#13;
}&#13;
&#13;
/**&#13;
 * @title LengthValidator smart contract - fix ERC20 short address attack&#13;
 * @author Copyright (c) 2018 McFly.aero&#13;
 * @author Dmitriy Khizhinskiy&#13;
 * @author "MIT"&#13;
 */&#13;
contract LengthValidator {&#13;
    modifier valid_short(uint _cntArgs) {&#13;
        assert(msg.data.length == (_cntArgs * 32 + 4));&#13;
        _;&#13;
    }&#13;
}&#13;
&#13;
/**&#13;
 * @title Ownable smart contract&#13;
 * @author Copyright (c) 2016 Smart Contract Solutions, Inc.&#13;
 * @author "Manuel Araoz &lt;<span class="__cf_email__" data-cfemail="c1aca0afb4a4ada0b3a0aebb81a6aca0a8adefa2aeac">[email protected]</span>&gt;"&#13;
 * @dev license: "MIT", source: https://github.com/OpenZeppelin/zeppelin-solidity&#13;
 * @author modification: Dmitriy Khizhinskiy @McFly.aero&#13;
 * @dev The Ownable contract has an owner address, and provides basic authorization control&#13;
 * functions, this simplifies the implementation of "user permissions".&#13;
 */&#13;
contract Ownable {&#13;
    address public owner;&#13;
    address public candidate;&#13;
&#13;
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);&#13;
&#13;
    /**&#13;
    * @dev The Ownable constructor sets the original `owner` of the contract to the sender&#13;
    * account.&#13;
    */&#13;
    function Ownable() public {&#13;
        owner = msg.sender;&#13;
    }&#13;
&#13;
&#13;
    /**&#13;
    * @dev Throws if called by any account other than the owner.&#13;
    */&#13;
    modifier onlyOwner() {&#13;
        require(msg.sender == owner);&#13;
        _;&#13;
    }&#13;
&#13;
&#13;
    /**&#13;
    * @dev Allows the current owner to _request_ transfer control of the contract to a newOwner.&#13;
    * @param newOwner The address to transfer ownership to.&#13;
    */&#13;
    function requestOwnership(address newOwner) onlyOwner public {&#13;
        require(newOwner != address(0));&#13;
        candidate = newOwner;&#13;
    }&#13;
&#13;
&#13;
    /**&#13;
    * @dev Allows the _NEW_ candidate to complete transfer control of the contract to him.&#13;
    */&#13;
    function confirmOwnership() public {&#13;
        require(candidate == msg.sender);&#13;
        owner = candidate;&#13;
        OwnershipTransferred(owner, candidate);        &#13;
    }&#13;
}&#13;
&#13;
&#13;
/**&#13;
 * @title MultiOwners smart contract&#13;
 * @author Copyright (c) 2018 McFly.aero&#13;
 * @author Dmitriy Khizhinskiy&#13;
 * @author "MIT"&#13;
 */&#13;
contract MultiOwners {&#13;
&#13;
    event AccessGrant(address indexed owner);&#13;
    event AccessRevoke(address indexed owner);&#13;
    &#13;
    mapping(address =&gt; bool) owners;&#13;
    address public publisher;&#13;
&#13;
&#13;
    function MultiOwners() public {&#13;
        owners[msg.sender] = true;&#13;
        publisher = msg.sender;&#13;
    }&#13;
&#13;
&#13;
    modifier onlyOwner() { &#13;
        require(owners[msg.sender] == true);&#13;
        _; &#13;
    }&#13;
&#13;
&#13;
    function isOwner() constant public returns (bool) {&#13;
        return owners[msg.sender] ? true : false;&#13;
    }&#13;
&#13;
&#13;
    function checkOwner(address maybe_owner) constant public returns (bool) {&#13;
        return owners[maybe_owner] ? true : false;&#13;
    }&#13;
&#13;
&#13;
    function grant(address _owner) onlyOwner public {&#13;
        owners[_owner] = true;&#13;
        AccessGrant(_owner);&#13;
    }&#13;
&#13;
&#13;
    function revoke(address _owner) onlyOwner public {&#13;
        require(_owner != publisher);&#13;
        require(msg.sender != _owner);&#13;
&#13;
        owners[_owner] = false;&#13;
        AccessRevoke(_owner);&#13;
    }&#13;
}&#13;
&#13;
&#13;
&#13;
&#13;
/**&#13;
 * @title SafeMath&#13;
 * @author Copyright (c) 2016 Smart Contract Solutions, Inc.&#13;
 * @author "Manuel Araoz &lt;<span class="__cf_email__" data-cfemail="086569667d6d64697a696772486f65696164266b6765">[email protected]</span>&gt;"&#13;
 * @dev license: "MIT", source: https://github.com/OpenZeppelin/zeppelin-solidity&#13;
 * @dev Math operations with safety checks that throw on error&#13;
 */&#13;
library SafeMath {&#13;
    /**&#13;
    * @dev Multiplies two numbers, throws on overflow.&#13;
    */&#13;
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
        if (a == 0) {&#13;
            return 0;&#13;
        }&#13;
        uint256 c = a * b;&#13;
        assert(c / a == b);&#13;
        return c;&#13;
    }&#13;
&#13;
&#13;
    /**&#13;
    * @dev Integer division of two numbers, truncating the quotient.&#13;
    */&#13;
    function div(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
        // assert(b &gt; 0); // Solidity automatically throws when dividing by 0&#13;
        uint256 c = a / b;&#13;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold&#13;
        return c;&#13;
    }&#13;
&#13;
&#13;
    /**&#13;
    * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).&#13;
    */&#13;
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
        assert(b &lt;= a);&#13;
        return a - b;&#13;
    }&#13;
&#13;
&#13;
    /**&#13;
    * @dev Adds two numbers, throws on overflow.&#13;
    */&#13;
    function add(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
        uint256 c = a + b;&#13;
        assert(c &gt;= a);&#13;
        return c;&#13;
    }&#13;
}&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
/**&#13;
 * @title BasicToken smart contract&#13;
 * @author Copyright (c) 2016 Smart Contract Solutions, Inc.&#13;
 * @author "Manuel Araoz &lt;<span class="__cf_email__" data-cfemail="82efe3ecf7e7eee3f0e3edf8c2e5efe3ebeeace1edef">[email protected]</span>&gt;"&#13;
 * @dev license: "MIT", source: https://github.com/OpenZeppelin/zeppelin-solidity&#13;
 * @author modification: Dmitriy Khizhinskiy @McFly.aero&#13;
 */&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
/**&#13;
 * @title Basic token&#13;
 * @dev Basic version of StandardToken, with no allowances.&#13;
 */&#13;
contract BasicToken is ERC20Basic, LengthValidator {&#13;
    using SafeMath for uint256;&#13;
&#13;
    mapping(address =&gt; uint256) balances;&#13;
&#13;
    uint256 totalSupply_;&#13;
&#13;
    /**&#13;
    * @dev total number of tokens in existence&#13;
    */&#13;
    function totalSupply() public view returns (uint256) {&#13;
        return totalSupply_;&#13;
    }&#13;
&#13;
&#13;
    /**&#13;
    * @dev transfer token for a specified address&#13;
    * @param _to The address to transfer to.&#13;
    * @param _value The amount to be transferred.&#13;
    */&#13;
    function transfer(address _to, uint256 _value) valid_short(2) public returns (bool) {&#13;
        require(_to != address(0));&#13;
        require(_value &lt;= balances[msg.sender]);&#13;
&#13;
        // SafeMath.sub will throw if there is not enough balance.&#13;
        balances[msg.sender] = balances[msg.sender].sub(_value);&#13;
        balances[_to] = balances[_to].add(_value);&#13;
        Transfer(msg.sender, _to, _value);&#13;
        return true;&#13;
    }&#13;
&#13;
&#13;
    /**&#13;
    * @dev Gets the balance of the specified address.&#13;
    * @param _owner The address to query the the balance of.&#13;
    * @return An uint256 representing the amount owned by the passed address.&#13;
    */&#13;
    function balanceOf(address _owner) public view returns (uint256 balance) {&#13;
        return balances[_owner];&#13;
    }&#13;
&#13;
}&#13;
&#13;
&#13;
/**&#13;
 * @title ERC20 smart contract&#13;
 * @author Copyright (c) 2016 Smart Contract Solutions, Inc.&#13;
 * @author "Manuel Araoz &lt;<span class="__cf_email__" data-cfemail="2449454a5141484556454b5e644349454d480a474b49">[email protected]</span>&gt;"&#13;
 * @dev license: "MIT", source: https://github.com/OpenZeppelin/zeppelin-solidity&#13;
 * @author modification: Dmitriy Khizhinskiy @McFly.aero&#13;
 */&#13;
&#13;
&#13;
&#13;
&#13;
/**&#13;
 * @title ERC20 interface&#13;
 * @dev see https://github.com/ethereum/EIPs/issues/20&#13;
 */&#13;
contract ERC20 is ERC20Basic {&#13;
    function allowance(address owner, address spender) public view returns (uint256);&#13;
    function transferFrom(address from, address to, uint256 value) public returns (bool);&#13;
    function approve(address spender, uint256 value) public returns (bool);&#13;
    event Approval(address indexed owner, address indexed spender, uint256 value);&#13;
}&#13;
&#13;
/**&#13;
 * @title Standard ERC20 token&#13;
 * @author Copyright (c) 2016 Smart Contract Solutions, Inc.&#13;
 * @author "Manuel Araoz &lt;<span class="__cf_email__" data-cfemail="2d404c435848414c5f4c42576d4a404c4441034e4240">[email protected]</span>&gt;"&#13;
 * @dev license: "MIT", source: https://github.com/OpenZeppelin/zeppelin-solidity&#13;
 * @author modification: Dmitriy Khizhinskiy @McFly.aero&#13;
 * @dev Implementation of the basic standard token.&#13;
 * @dev https://github.com/ethereum/EIPs/issues/20&#13;
 * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol&#13;
 */&#13;
contract StandardToken is ERC20, BasicToken {&#13;
&#13;
    mapping (address =&gt; mapping (address =&gt; uint256)) internal allowed;&#13;
  &#13;
    /** &#13;
    * @dev Transfer tokens from one address to another&#13;
    * @param _from address The address which you want to send tokens from&#13;
    * @param _to address The address which you want to transfer to&#13;
    * @param _value uint256 the amount of tokens to be transferred&#13;
    */&#13;
    function transferFrom(address _from, address _to, uint256 _value) valid_short(3) public returns (bool) {&#13;
        require(_to != address(0));&#13;
        require(_value &lt;= balances[_from]);&#13;
        require(_value &lt;= allowed[_from][msg.sender]);&#13;
&#13;
        balances[_from] = balances[_from].sub(_value);&#13;
        balances[_to] = balances[_to].add(_value);&#13;
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);&#13;
        Transfer(_from, _to, _value);&#13;
        return true;&#13;
    }&#13;
&#13;
&#13;
    /**&#13;
    * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.&#13;
    *&#13;
    * Beware that changing an allowance with this method brings the risk that someone may use both the old&#13;
    * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this&#13;
    * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:&#13;
    * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729&#13;
    * @param _spender The address which will spend the funds.&#13;
    * @param _value The amount of tokens to be spent.&#13;
    */&#13;
    function approve(address _spender, uint256 _value) valid_short(2) public returns (bool) {&#13;
        allowed[msg.sender][_spender] = _value;&#13;
        Approval(msg.sender, _spender, _value);&#13;
        return true;&#13;
    }&#13;
&#13;
&#13;
    /**&#13;
    * @dev Function to check the amount of tokens that an owner allowed to a spender.&#13;
    * @param _owner address The address which owns the funds.&#13;
    * @param _spender address The address which will spend the funds.&#13;
    * @return A uint256 specifying the amount of tokens still available for the spender.&#13;
    */&#13;
    function allowance(address _owner, address _spender) public view returns (uint256) {&#13;
        return allowed[_owner][_spender];&#13;
    }&#13;
&#13;
&#13;
    /**&#13;
    * @dev Increase the amount of tokens that an owner allowed to a spender.&#13;
    *&#13;
    * approve should be called when allowed[_spender] == 0. To increment&#13;
    * allowed value is better to use this function to avoid 2 calls (and wait until&#13;
    * the first transaction is mined)&#13;
    * From MonolithDAO Token.sol&#13;
    * @param _spender The address which will spend the funds.&#13;
    * @param _addedValue The amount of tokens to increase the allowance by.&#13;
    */&#13;
    function increaseApproval(address _spender, uint _addedValue) public returns (bool) {&#13;
        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);&#13;
        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);&#13;
        return true;&#13;
    }&#13;
&#13;
&#13;
    /**&#13;
    * @dev Decrease the amount of tokens that an owner allowed to a spender.&#13;
    *&#13;
    * approve should be called when allowed[_spender] == 0. To decrement&#13;
    * allowed value is better to use this function to avoid 2 calls (and wait until&#13;
    * the first transaction is mined)&#13;
    * From MonolithDAO Token.sol&#13;
    * @param _spender The address which will spend the funds.&#13;
    * @param _subtractedValue The amount of tokens to decrease the allowance by.&#13;
    */&#13;
    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {&#13;
        uint oldValue = allowed[msg.sender][_spender];&#13;
        if (_subtractedValue &gt; oldValue) {&#13;
            allowed[msg.sender][_spender] = 0;&#13;
        } else {&#13;
            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);&#13;
        }&#13;
        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);&#13;
        return true;&#13;
    }&#13;
}&#13;
&#13;
&#13;
/**&#13;
 * @title Mintable token smart contract&#13;
 * @author Copyright (c) 2016 Smart Contract Solutions, Inc.&#13;
 * @author "Manuel Araoz &lt;<span class="__cf_email__" data-cfemail="1d707c736878717c6f7c72675d7a707c7471337e7270">[email protected]</span>&gt;"&#13;
 * @dev license: "MIT", source: https://github.com/OpenZeppelin/zeppelin-solidity&#13;
 * @author modification: Dmitriy Khizhinskiy @McFly.aero&#13;
 * @dev Simple ERC20 Token example, with mintable token creation&#13;
 * @dev Issue: * https://github.com/OpenZeppelin/zeppelin-solidity/issues/120&#13;
 * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol&#13;
 */&#13;
contract MintableToken is StandardToken, Ownable {&#13;
    event Mint(address indexed to, uint256 amount);&#13;
    event MintFinished();&#13;
&#13;
    bool public mintingFinished = false;&#13;
&#13;
    modifier canMint() {&#13;
        require(!mintingFinished);&#13;
        _;&#13;
    }&#13;
&#13;
&#13;
    /**&#13;
    * @dev Function to mint tokens&#13;
    * @param _to The address that will receive the minted tokens.&#13;
    * @param _amount The amount of tokens to mint.&#13;
    * @return A boolean that indicates if the operation was successful.&#13;
    */&#13;
    function mint(address _to, uint256 _amount) onlyOwner canMint valid_short(2) public returns (bool) {&#13;
        totalSupply_ = totalSupply_.add(_amount);&#13;
        balances[_to] = balances[_to].add(_amount);&#13;
        Mint(_to, _amount);&#13;
        Transfer(address(0), _to, _amount);&#13;
        return true;&#13;
    }&#13;
&#13;
&#13;
    /**&#13;
    * @dev Function to stop minting new tokens.&#13;
    * @return True if the operation was successful.&#13;
    */&#13;
    function finishMinting() onlyOwner canMint public returns (bool) {&#13;
        mintingFinished = true;&#13;
        MintFinished();&#13;
        return true;&#13;
    }&#13;
}&#13;
&#13;
&#13;
/**&#13;
 * @title McFly token smart contract&#13;
 * @author Copyright (c) 2018 McFly.aero&#13;
 * @author Dmitriy Khizhinskiy&#13;
 * @author "MIT"&#13;
 */&#13;
contract McFlyToken is MintableToken {&#13;
    string public constant name = "McFlyToken";&#13;
    string public constant symbol = "McFly";&#13;
    uint8 public constant decimals = 18;&#13;
&#13;
    /// @dev mapping for whitelist&#13;
    mapping(address=&gt;bool) whitelist;&#13;
&#13;
    /// @dev event throw when allowed to transfer address added to whitelist&#13;
    /// @param from address&#13;
    event AllowTransfer(address from);&#13;
&#13;
    /// @dev check for allowence of transfer&#13;
    modifier canTransfer() {&#13;
        require(mintingFinished || whitelist[msg.sender]);&#13;
        _;        &#13;
    }&#13;
&#13;
    /// @dev add address to whitelist&#13;
    /// @param from address to add&#13;
    function allowTransfer(address from) onlyOwner public {&#13;
        whitelist[from] = true;&#13;
        AllowTransfer(from);&#13;
    }&#13;
&#13;
    /// @dev Do the transfer from address to address value&#13;
    /// @param from address from&#13;
    /// @param to address to&#13;
    /// @param value uint256&#13;
    function transferFrom(address from, address to, uint256 value) canTransfer public returns (bool) {&#13;
        return super.transferFrom(from, to, value);&#13;
    }&#13;
&#13;
    /// @dev Do the transfer from token address to "to" address value&#13;
    /// @param to address to&#13;
    /// @param value uint256 value&#13;
    function transfer(address to, uint256 value) canTransfer public returns (bool) {&#13;
        return super.transfer(to, value);&#13;
    }&#13;
}&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
/**&#13;
 * @title Haltable smart contract - controls owner access&#13;
 * @author Copyright (c) 2018 McFly.aero&#13;
 * @author Dmitriy Khizhinskiy&#13;
 * @author "MIT"&#13;
 */&#13;
contract Haltable is MultiOwners {&#13;
    bool public halted;&#13;
&#13;
    modifier stopInEmergency {&#13;
        require(!halted);&#13;
        _;&#13;
    }&#13;
&#13;
&#13;
    modifier onlyInEmergency {&#13;
        require(halted);&#13;
        _;&#13;
    }&#13;
&#13;
&#13;
    /// @dev called by the owner on emergency, triggers stopped state&#13;
    function halt() external onlyOwner {&#13;
        halted = true;&#13;
    }&#13;
&#13;
&#13;
    /// @dev called by the owner on end of emergency, returns to normal state&#13;
    function unhalt() external onlyOwner onlyInEmergency {&#13;
        halted = false;&#13;
    }&#13;
&#13;
}&#13;
&#13;
&#13;
&#13;
/**&#13;
 * @title McFly crowdsale smart contract&#13;
 * @author Copyright (c) 2018 McFly.aero&#13;
 * @author Dmitriy Khizhinskiy&#13;
 * @author "MIT"&#13;
 * @dev inherited from MultiOwners &amp; Haltable&#13;
 */&#13;
contract McFlyCrowd is MultiOwners, Haltable {&#13;
    using SafeMath for uint256;&#13;
&#13;
    /// @dev Total ETH received during WAVES, TLP1.2 &amp; window[1-5]&#13;
    uint256 public counter_in; // tlp2&#13;
    &#13;
    /// @dev minimum ETH to partisipate in window 1-5&#13;
    uint256 public minETHin = 1e18; // 1 ETH&#13;
&#13;
    /// @dev Token&#13;
    McFlyToken public token;&#13;
&#13;
    /// @dev Withdraw wallet&#13;
    address public wallet;&#13;
&#13;
    /// @dev start and end timestamp for TLP 1.2, other values callculated&#13;
    uint256 public sT2; // startTimeTLP2&#13;
    uint256 constant dTLP2 = 118 days; // days of TLP2&#13;
    uint256 constant dBt = 60 days; // days between Windows&#13;
    uint256 constant dW = 12 days; // 12 days for 3,4,5,6,7 windows;&#13;
&#13;
    /// @dev Cap maximum possible tokens for minting&#13;
    uint256 public constant hardCapInTokens = 1800e24; // 1,800,000,000 MFL&#13;
&#13;
    /// @dev maximum possible tokens for sell &#13;
    uint256 public constant mintCapInTokens = 1260e24; // 1,260,000,000 MFL&#13;
&#13;
    /// @dev tokens crowd within TLP2&#13;
    uint256 public crowdTokensTLP2;&#13;
&#13;
    /// @dev tokens crowd before this contract (MFL tokens)&#13;
    uint256 preMcFlyTotalSupply;&#13;
&#13;
    /// @dev maximum possible tokens for fund minting&#13;
    uint256 constant fundTokens = 270e24; // 270,000,000 MFL&#13;
    uint256 public fundTotalSupply;&#13;
    address public fundMintingAgent;&#13;
                                                          &#13;
    /// @dev maximum possible tokens to convert from WAVES&#13;
    uint256 wavesTokens = 100e24; // 100,000,000 MFL&#13;
    address public wavesAgent;&#13;
    address public wavesGW;&#13;
&#13;
    /// @dev Vesting param for team, advisory, reserve.&#13;
    uint256 VestingPeriodInSeconds = 30 days; // 24 month&#13;
    uint256 VestingPeriodsCount = 24;&#13;
&#13;
    /// @dev Team 10%&#13;
    uint256 _teamTokens;&#13;
    uint256 public teamTotalSupply;&#13;
    address public teamWallet;&#13;
&#13;
    /// @dev Bounty 5% (2% + 3%)&#13;
    /// @dev Bounty online 2%&#13;
    uint256 _bountyOnlineTokens;&#13;
    address public bountyOnlineWallet;&#13;
    address public bountyOnlineGW;&#13;
&#13;
    /// @dev Bounty offline 3%&#13;
    uint256 _bountyOfflineTokens;&#13;
    address public bountyOfflineWallet;&#13;
&#13;
    /// @dev Advisory 5%&#13;
    uint256 _advisoryTokens;&#13;
    uint256 public advisoryTotalSupply;&#13;
    address public advisoryWallet;&#13;
&#13;
    /// @dev Reserved for future 9%&#13;
    uint256 _reservedTokens;&#13;
    uint256 public reservedTotalSupply;&#13;
    address public reservedWallet;&#13;
&#13;
    /// @dev AirDrop 1%&#13;
    uint256 _airdropTokens;&#13;
    address public airdropWallet;&#13;
    address public airdropGW;&#13;
&#13;
    /// @dev PreMcFly wallet (MFL)&#13;
    uint256 _preMcFlyTokens;&#13;
    address public preMcFlyWallet;&#13;
&#13;
    /// @dev Ppl structure for Win1-5&#13;
    struct Ppl {&#13;
        address addr;&#13;
        uint256 amount;&#13;
    }&#13;
    mapping (uint32 =&gt; Ppl) public ppls;&#13;
&#13;
    /// @dev Window structure for Win1-5&#13;
    struct Window {&#13;
        bool active;&#13;
        uint256 totalEthInWindow;&#13;
        uint32 totalTransCnt;&#13;
        uint32 refundIndex;&#13;
        uint256 tokenPerWindow;&#13;
    } &#13;
    mapping (uint8 =&gt; Window) public ww;&#13;
&#13;
&#13;
    /// @dev Events&#13;
    event TokenPurchase(address indexed beneficiary, uint256 value, uint256 amount);&#13;
    event TokenPurchaseInWindow(address indexed beneficiary, uint256 value, uint8 winnum, uint32 totalcnt, uint256 totaleth1);&#13;
    event TransferOddEther(address indexed beneficiary, uint256 value);&#13;
    event FundMinting(address indexed beneficiary, uint256 value);&#13;
    event WithdrawVesting(address indexed beneficiary, uint256 period, uint256 value, uint256 valueTotal);&#13;
    event TokenWithdrawAtWindow(address indexed beneficiary, uint256 value);&#13;
    event SetFundMintingAgent(address newAgent);&#13;
    event SetTeamWallet(address newTeamWallet);&#13;
    event SetAdvisoryWallet(address newAdvisoryWallet);&#13;
    event SetReservedWallet(address newReservedWallet);&#13;
    event SetStartTimeTLP2(uint256 newStartTimeTLP2);&#13;
    event SetMinETHincome(uint256 newMinETHin);&#13;
    event NewWindow(uint8 winNum, uint256 amountTokensPerWin);&#13;
    event TokenETH(uint256 totalEth, uint32 totalCnt);&#13;
&#13;
&#13;
    /// @dev check for Non zero value&#13;
    modifier validPurchase() {&#13;
        bool nonZeroPurchase = msg.value != 0;&#13;
        require(nonZeroPurchase);&#13;
        _;        &#13;
    }&#13;
&#13;
    // comment this functions after test passed !!&#13;
    /*function getPpls(uint32 index) constant public returns (uint256) {&#13;
        return (ppls[index].amount);&#13;
    }&#13;
    function getPplsAddr(uint32 index) constant public returns (address) {&#13;
        return (ppls[index].addr);&#13;
    }&#13;
    function getWtotalEth(uint8 winNum) constant public returns (uint256) {&#13;
        return (ww[winNum].totalEthInWindow);&#13;
    }&#13;
    function getWtoken(uint8 winNum) constant public returns (uint256) {&#13;
        return (ww[winNum].tokenPerWindow);&#13;
    }&#13;
    function getWactive(uint8 winNum) constant public returns (bool) {&#13;
        return (ww[winNum].active);&#13;
    }&#13;
    function getWtotalTransCnt(uint8 winNum) constant public returns (uint32) {&#13;
        return (ww[winNum].totalTransCnt);&#13;
    }&#13;
    function getWrefundIndex(uint8 winNum) constant public returns (uint32) {&#13;
        return (ww[winNum].refundIndex);&#13;
    }*/&#13;
    // END comment this functions after test passed !!&#13;
&#13;
&#13;
    /**&#13;
     * @dev conctructor of contract, set main params, create new token, do minting for some wallets&#13;
     * @param _startTimeTLP2 - set date time of starting of TLP2 (main date!)&#13;
     * @param _preMcFlyTotalSupply - set amount in wei total supply of previouse contract (MFL)&#13;
     * @param _wallet - wallet for transfer ETH to it&#13;
     * @param _wavesAgent - wallet for WAVES gw&#13;
     * @param _wavesGW    - wallet for WAVES gw&#13;
     * @param _fundMintingAgent - wallet who allowed to mint before TLP2&#13;
     * @param _teamWallet - wallet for team vesting&#13;
     * @param _bountyOnlineWallet - wallet for online bounty&#13;
     * @param _bountyOnlineGW - wallet for online bounty GW&#13;
     * @param _bountyOfflineWallet - wallet for offline bounty&#13;
     * @param _advisoryWallet - wallet for advisory vesting&#13;
     * @param _reservedWallet - wallet for reserved vesting&#13;
     * @param _airdropWallet - wallet for airdrop&#13;
     * @param _airdropGW - wallet for airdrop GW&#13;
     * @param _preMcFlyWallet - wallet for transfer old MFL-&gt;McFly (once)&#13;
     */&#13;
    function McFlyCrowd(&#13;
        uint256 _startTimeTLP2,&#13;
        uint256 _preMcFlyTotalSupply,&#13;
        address _wallet,&#13;
        address _wavesAgent,&#13;
        address _wavesGW,&#13;
        address _fundMintingAgent,&#13;
        address _teamWallet,&#13;
        address _bountyOnlineWallet,&#13;
        address _bountyOnlineGW,&#13;
        address _bountyOfflineWallet,&#13;
        address _advisoryWallet,&#13;
        address _reservedWallet,&#13;
        address _airdropWallet,&#13;
        address _airdropGW,&#13;
        address _preMcFlyWallet&#13;
    ) public &#13;
    {   &#13;
        require(_startTimeTLP2 &gt;= block.timestamp);&#13;
        require(_preMcFlyTotalSupply &gt; 0);&#13;
        require(_wallet != 0x0);&#13;
        require(_wavesAgent != 0x0);&#13;
        require(_wavesGW != 0x0);&#13;
        require(_fundMintingAgent != 0x0);&#13;
        require(_teamWallet != 0x0);&#13;
        require(_bountyOnlineWallet != 0x0);&#13;
        require(_bountyOnlineGW != 0x0);&#13;
        require(_bountyOfflineWallet != 0x0);&#13;
        require(_advisoryWallet != 0x0);&#13;
        require(_reservedWallet != 0x0);&#13;
        require(_airdropWallet != 0x0);&#13;
        require(_airdropGW != 0x0);&#13;
        require(_preMcFlyWallet != 0x0);&#13;
&#13;
        token = new McFlyToken();&#13;
&#13;
        wallet = _wallet;&#13;
&#13;
        sT2 = _startTimeTLP2;&#13;
        setStartEndTimeTLP(_startTimeTLP2);&#13;
&#13;
        wavesAgent = _wavesAgent;&#13;
        wavesGW = _wavesGW;&#13;
&#13;
        fundMintingAgent = _fundMintingAgent;&#13;
&#13;
        teamWallet = _teamWallet;&#13;
        bountyOnlineWallet = _bountyOnlineWallet;&#13;
        bountyOnlineGW = _bountyOnlineGW;&#13;
        bountyOfflineWallet = _bountyOfflineWallet;&#13;
        advisoryWallet = _advisoryWallet;&#13;
        reservedWallet = _reservedWallet;&#13;
        airdropWallet = _airdropWallet;&#13;
        airdropGW = _airdropGW;&#13;
        preMcFlyWallet = _preMcFlyWallet;&#13;
&#13;
        /// @dev Mint all tokens and than control it by vesting&#13;
        _preMcFlyTokens = _preMcFlyTotalSupply; // McFly for thansfer to old MFL owners&#13;
        token.mint(preMcFlyWallet, _preMcFlyTokens);&#13;
        token.allowTransfer(preMcFlyWallet);&#13;
        crowdTokensTLP2 = crowdTokensTLP2.add(_preMcFlyTokens);&#13;
&#13;
        token.mint(wavesAgent, wavesTokens); // 100,000,000 MFL&#13;
        token.allowTransfer(wavesAgent);&#13;
        token.allowTransfer(wavesGW);&#13;
        crowdTokensTLP2 = crowdTokensTLP2.add(wavesTokens);&#13;
&#13;
        _teamTokens = 180e24; // 180,000,000 MFL&#13;
        token.mint(this, _teamTokens); // mint to contract address&#13;
&#13;
        _bountyOnlineTokens = 36e24; // 36,000,000 MFL&#13;
        token.mint(bountyOnlineWallet, _bountyOnlineTokens);&#13;
        token.allowTransfer(bountyOnlineWallet);&#13;
        token.allowTransfer(bountyOnlineGW);&#13;
&#13;
        _bountyOfflineTokens = 54e24; // 54,000,000 MFL&#13;
        token.mint(bountyOfflineWallet, _bountyOfflineTokens);&#13;
        token.allowTransfer(bountyOfflineWallet);&#13;
&#13;
        _advisoryTokens = 90e24; // 90,000,000 MFL&#13;
        token.mint(this, _advisoryTokens);&#13;
&#13;
        _reservedTokens = 162e24; // 162,000,000 MFL&#13;
        token.mint(this, _reservedTokens);&#13;
&#13;
        _airdropTokens = 18e24; // 18,000,000 MFL&#13;
        token.mint(airdropWallet, _airdropTokens);&#13;
        token.allowTransfer(airdropWallet);&#13;
        token.allowTransfer(airdropGW);&#13;
    }&#13;
&#13;
&#13;
    /**&#13;
     * @dev check is TLP2 is active?&#13;
     * @return false if crowd TLP2 event was ended&#13;
     */&#13;
    function withinPeriod() constant public returns (bool) {&#13;
        bool withinPeriodTLP2 = (now &gt;= sT2 &amp;&amp; now &lt;= (sT2+dTLP2));&#13;
        return withinPeriodTLP2;&#13;
    }&#13;
&#13;
&#13;
    /**&#13;
     * @dev check is TLP2 is active and minting Not finished&#13;
     * @return false if crowd event was ended&#13;
     */&#13;
    function running() constant public returns (bool) {&#13;
        return withinPeriod() &amp;&amp; !token.mintingFinished();&#13;
    }&#13;
&#13;
&#13;
    /**&#13;
     * @dev check current stage name&#13;
     * @return uint8 stage number&#13;
     */&#13;
    function stageName() constant public returns (uint8) {&#13;
        uint256 eT2 = sT2+dTLP2;&#13;
&#13;
        if (now &lt; sT2) {return 101;} // not started&#13;
        if (now &gt;= sT2 &amp;&amp; now &lt;= eT2) {return (102);} // TLP1.2&#13;
&#13;
        if (now &gt; eT2 &amp;&amp; now &lt; eT2+dBt) {return (103);} // preTLP1.3&#13;
        if (now &gt;= (eT2+dBt) &amp;&amp; now &lt;= (eT2+dBt+dW)) {return (0);} // TLP1.3&#13;
        if (now &gt; (eT2+dBt+dW) &amp;&amp; now &lt; (eT2+dBt+dW+dBt)) {return (104);} // preTLP1.4&#13;
        if (now &gt;= (eT2+dBt+dW+dBt) &amp;&amp; now &lt;= (eT2+dBt+dW+dBt+dW)) {return (1);} // TLP1.4&#13;
        if (now &gt; (eT2+dBt+dW+dBt+dW) &amp;&amp; now &lt; (eT2+dBt+dW+dBt+dW+dBt)) {return (105);} // preTLP1.5&#13;
        if (now &gt;= (eT2+dBt+dW+dBt+dW+dBt) &amp;&amp; now &lt;= (eT2+dBt+dW+dBt+dW+dBt+dW)) {return (2);} // TLP1.5&#13;
        if (now &gt; (eT2+dBt+dW+dBt+dW+dBt+dW) &amp;&amp; now &lt; (eT2+dBt+dW+dBt+dW+dBt+dW+dBt)) {return (106);} // preTLP1.6&#13;
        if (now &gt;= (eT2+dBt+dW+dBt+dW+dBt+dW+dBt) &amp;&amp; now &lt;= (eT2+dBt+dW+dBt+dW+dBt+dW+dBt+dW)) {return (3);} // TLP1.6&#13;
        if (now &gt; (eT2+dBt+dW+dBt+dW+dBt+dW+dBt+dW) &amp;&amp; now &lt; (eT2+dBt+dW+dBt+dW+dBt+dW+dBt+dW+dBt)) {return (107);} // preTLP1.7&#13;
        if (now &gt;= (eT2+dBt+dW+dBt+dW+dBt+dW+dBt+dW+dBt) &amp;&amp; now &lt;= (eT2+dBt+dW+dBt+dW+dBt+dW+dBt+dW+dBt+dW)) {return (4);} // TLP1.7"&#13;
        if (now &gt; (eT2+dBt+dW+dBt+dW+dBt+dW+dBt+dW+dBt+dW)) {return (200);} // Finished&#13;
        return (201); // unknown&#13;
    }&#13;
&#13;
&#13;
    /** &#13;
     * @dev change agent for minting&#13;
     * @param agent - new agent address&#13;
     */&#13;
    function setFundMintingAgent(address agent) onlyOwner public {&#13;
        fundMintingAgent = agent;&#13;
        SetFundMintingAgent(agent);&#13;
    }&#13;
&#13;
&#13;
    /** &#13;
     * @dev change wallet for team vesting (this make possible to set smart-contract address later)&#13;
     * @param _newTeamWallet - new wallet address&#13;
     */&#13;
    function setTeamWallet(address _newTeamWallet) onlyOwner public {&#13;
        teamWallet = _newTeamWallet;&#13;
        SetTeamWallet(_newTeamWallet);&#13;
    }&#13;
&#13;
&#13;
    /** &#13;
     * @dev change wallet for advisory vesting (this make possible to set smart-contract address later)&#13;
     * @param _newAdvisoryWallet - new wallet address&#13;
     */&#13;
    function setAdvisoryWallet(address _newAdvisoryWallet) onlyOwner public {&#13;
        advisoryWallet = _newAdvisoryWallet;&#13;
        SetAdvisoryWallet(_newAdvisoryWallet);&#13;
    }&#13;
&#13;
&#13;
    /** &#13;
     * @dev change wallet for reserved vesting (this make possible to set smart-contract address later)&#13;
     * @param _newReservedWallet - new wallet address&#13;
     */&#13;
    function setReservedWallet(address _newReservedWallet) onlyOwner public {&#13;
        reservedWallet = _newReservedWallet;&#13;
        SetReservedWallet(_newReservedWallet);&#13;
    }&#13;
&#13;
&#13;
    /**&#13;
     * @dev change min ETH income during Window1-5&#13;
     * @param _minETHin - new limit&#13;
     */&#13;
    function setMinETHin(uint256 _minETHin) onlyOwner public {&#13;
        minETHin = _minETHin;&#13;
        SetMinETHincome(_minETHin);&#13;
    }&#13;
&#13;
&#13;
    /**&#13;
     * @dev set TLP1.X (2-7) start &amp; end dates&#13;
     * @param _at - new or old start date&#13;
     */&#13;
    function setStartEndTimeTLP(uint256 _at) onlyOwner public {&#13;
        require(block.timestamp &lt; sT2); // forbid change time when TLP1.2 is active&#13;
        require(block.timestamp &lt; _at); // should be great than current block timestamp&#13;
&#13;
        sT2 = _at;&#13;
        SetStartTimeTLP2(_at);&#13;
    }&#13;
&#13;
&#13;
    /**&#13;
     * @dev Large Token Holder minting &#13;
     * @param to - mint to address&#13;
     * @param amount - how much mint&#13;
     */&#13;
    function fundMinting(address to, uint256 amount) stopInEmergency public {&#13;
        require(msg.sender == fundMintingAgent || isOwner());&#13;
        require(block.timestamp &lt; sT2);&#13;
        require(fundTotalSupply + amount &lt;= fundTokens);&#13;
        require(token.totalSupply() + amount &lt;= hardCapInTokens);&#13;
&#13;
        fundTotalSupply = fundTotalSupply.add(amount);&#13;
        token.mint(to, amount);&#13;
        FundMinting(to, amount);&#13;
    }&#13;
&#13;
&#13;
    /**&#13;
     * @dev calculate amount&#13;
     * @param  amount - ether to be converted to tokens&#13;
     * @param  at - current time&#13;
     * @param  _totalSupply - total supplied tokens&#13;
     * @return tokens amount that we should send to our dear ppl&#13;
     * @return odd ethers amount, which contract should send back&#13;
     */&#13;
    function calcAmountAt(&#13;
        uint256 amount,&#13;
        uint256 at,&#13;
        uint256 _totalSupply&#13;
    ) public constant returns (uint256, uint256) &#13;
    {&#13;
        uint256 estimate;&#13;
        uint256 price;&#13;
        &#13;
        if (at &gt;= sT2 &amp;&amp; at &lt;= (sT2+dTLP2)) {&#13;
            if (at &lt;= sT2 + 15 days) {price = 12e13;} else if (at &lt;= sT2 + 30 days) {&#13;
                price = 14e13;} else if (at &lt;= sT2 + 45 days) {&#13;
                    price = 16e13;} else if (at &lt;= sT2 + 60 days) {&#13;
                        price = 18e13;} else if (at &lt;= sT2 + 75 days) {&#13;
                            price = 20e13;} else if (at &lt;= sT2 + 90 days) {&#13;
                                price = 22e13;} else if (at &lt;= sT2 + 105 days) {&#13;
                                    price = 24e13;} else if (at &lt;= sT2 + 118 days) {&#13;
                                        price = 26e13;} else {revert();}&#13;
        } else {revert();}&#13;
&#13;
        estimate = _totalSupply.add(amount.mul(1e18).div(price));&#13;
&#13;
        if (estimate &gt; hardCapInTokens) {&#13;
            return (&#13;
                hardCapInTokens.sub(_totalSupply),&#13;
                estimate.sub(hardCapInTokens).mul(price).div(1e18)&#13;
            );&#13;
        }&#13;
        return (estimate.sub(_totalSupply), 0);&#13;
    }&#13;
&#13;
&#13;
    /**&#13;
     * @dev fallback for processing ether&#13;
     */&#13;
    function() payable public {&#13;
        return getTokens(msg.sender);&#13;
    }&#13;
&#13;
&#13;
    /**&#13;
     * @dev sell token and send to contributor address&#13;
     * @param contributor address&#13;
     */&#13;
    function getTokens(address contributor) payable stopInEmergency validPurchase public {&#13;
        uint256 amount;&#13;
        uint256 oddEthers;&#13;
        uint256 ethers;&#13;
        uint256 _at;&#13;
        uint8 _winNum;&#13;
&#13;
        _at = block.timestamp;&#13;
&#13;
        require(contributor != 0x0);&#13;
       &#13;
        if (withinPeriod()) {&#13;
        &#13;
            (amount, oddEthers) = calcAmountAt(msg.value, _at, token.totalSupply());  // recheck!!!&#13;
  &#13;
            require(amount + token.totalSupply() &lt;= hardCapInTokens);&#13;
&#13;
            ethers = msg.value.sub(oddEthers);&#13;
&#13;
            token.mint(contributor, amount); // fail if minting is finished&#13;
            TokenPurchase(contributor, ethers, amount);&#13;
            counter_in = counter_in.add(ethers);&#13;
            crowdTokensTLP2 = crowdTokensTLP2.add(amount);&#13;
&#13;
            if (oddEthers &gt; 0) {&#13;
                require(oddEthers &lt; msg.value);&#13;
                contributor.transfer(oddEthers);&#13;
                TransferOddEther(contributor, oddEthers);&#13;
            }&#13;
&#13;
            wallet.transfer(ethers);&#13;
        } else {&#13;
            require(msg.value &gt;= minETHin); // checks min ETH income&#13;
            _winNum = stageName();&#13;
            require(_winNum &gt;= 0 &amp;&amp; _winNum &lt; 5);&#13;
            Window storage w = ww[_winNum];&#13;
&#13;
            require(w.tokenPerWindow &gt; 0); // check that we have tokens!&#13;
&#13;
            w.totalEthInWindow = w.totalEthInWindow.add(msg.value);&#13;
            ppls[w.totalTransCnt].addr = contributor;&#13;
            ppls[w.totalTransCnt].amount = msg.value;&#13;
            w.totalTransCnt++;&#13;
            TokenPurchaseInWindow(contributor, msg.value, _winNum, w.totalTransCnt, w.totalEthInWindow);&#13;
        }&#13;
    }&#13;
&#13;
&#13;
    /**&#13;
     * @dev close Window and transfer Eth to wallet address&#13;
     * @param _winNum - number of window 0-4 to close&#13;
     */&#13;
    function closeWindow(uint8 _winNum) onlyOwner stopInEmergency public {&#13;
        require(ww[_winNum].active);&#13;
        ww[_winNum].active = false;&#13;
&#13;
        wallet.transfer(this.balance);&#13;
    }&#13;
&#13;
&#13;
    /**&#13;
     * @dev transfer tokens to ppl accts (window1-5)&#13;
     * @param _winNum - number of window 0-4 to close&#13;
     */&#13;
    function sendTokensWindow(uint8 _winNum) onlyOwner stopInEmergency public {&#13;
        uint256 _tokenPerETH;&#13;
        uint256 _tokenToSend = 0;&#13;
        address _tempAddr;&#13;
        uint32 index = ww[_winNum].refundIndex;&#13;
&#13;
        TokenETH(ww[_winNum].totalEthInWindow, ww[_winNum].totalTransCnt);&#13;
&#13;
        require(ww[_winNum].active);&#13;
        require(ww[_winNum].totalEthInWindow &gt; 0);&#13;
        require(ww[_winNum].totalTransCnt &gt; 0);&#13;
&#13;
        _tokenPerETH = ww[_winNum].tokenPerWindow.div(ww[_winNum].totalEthInWindow); // max McFly in window / ethInWindow&#13;
&#13;
        while (index &lt; ww[_winNum].totalTransCnt &amp;&amp; msg.gas &gt; 100000) {&#13;
            _tokenToSend = _tokenPerETH.mul(ppls[index].amount);&#13;
            ppls[index].amount = 0;&#13;
            _tempAddr = ppls[index].addr;&#13;
            ppls[index].addr = 0;&#13;
            index++;&#13;
            token.transfer(_tempAddr, _tokenToSend);&#13;
            TokenWithdrawAtWindow(_tempAddr, _tokenToSend);&#13;
        }&#13;
        ww[_winNum].refundIndex = index;&#13;
    }&#13;
&#13;
&#13;
    /**&#13;
     * @dev open new window 0-5 and write totl token per window in structure&#13;
     * @param _winNum - number of window 0-4 to close&#13;
     * @param _tokenPerWindow - total token for window 0-4&#13;
     */&#13;
    function newWindow(uint8 _winNum, uint256 _tokenPerWindow) private {&#13;
        ww[_winNum] = Window(true, 0, 0, 0, _tokenPerWindow);&#13;
        NewWindow(_winNum, _tokenPerWindow);&#13;
    }&#13;
&#13;
&#13;
    /**&#13;
     * @dev Finish crowdsale TLP1.2 period and open window1-5 crowdsale&#13;
     */&#13;
    function finishCrowd() onlyOwner public {&#13;
        uint256 _tokenPerWindow;&#13;
        require(now &gt; (sT2.add(dTLP2)) || hardCapInTokens == token.totalSupply());&#13;
        require(!token.mintingFinished());&#13;
&#13;
        _tokenPerWindow = (mintCapInTokens.sub(crowdTokensTLP2).sub(fundTotalSupply)).div(5);&#13;
        token.mint(this, _tokenPerWindow.mul(5)); // mint to contract address&#13;
        // shoud be MAX tokens minted!!! 1,800,000,000&#13;
        for (uint8 y = 0; y &lt; 5; y++) {&#13;
            newWindow(y, _tokenPerWindow);&#13;
        }&#13;
&#13;
        token.finishMinting();&#13;
    }&#13;
&#13;
&#13;
    /**&#13;
     * @dev withdraw tokens amount within vesting rules for team, advisory and reserved&#13;
     * @param withdrawWallet - wallet to transfer tokens&#13;
     * @param withdrawTokens - amount of tokens to transfer to&#13;
     * @param withdrawTotalSupply - total amount of tokens transfered to account&#13;
     * @return unit256 total amount of tokens after transfer&#13;
     */&#13;
    function vestingWithdraw(address withdrawWallet, uint256 withdrawTokens, uint256 withdrawTotalSupply) private returns (uint256) {&#13;
        require(token.mintingFinished());&#13;
        require(msg.sender == withdrawWallet || isOwner());&#13;
&#13;
        uint256 currentPeriod = (block.timestamp.sub(sT2.add(dTLP2))).div(VestingPeriodInSeconds);&#13;
        if (currentPeriod &gt; VestingPeriodsCount) {&#13;
            currentPeriod = VestingPeriodsCount;&#13;
        }&#13;
        uint256 tokenAvailable = withdrawTokens.mul(currentPeriod).div(VestingPeriodsCount).sub(withdrawTotalSupply);  // RECHECK!!!!!&#13;
&#13;
        require(withdrawTotalSupply + tokenAvailable &lt;= withdrawTokens);&#13;
&#13;
        uint256 _withdrawTotalSupply = withdrawTotalSupply + tokenAvailable;&#13;
&#13;
        token.transfer(withdrawWallet, tokenAvailable);&#13;
        WithdrawVesting(withdrawWallet, currentPeriod, tokenAvailable, _withdrawTotalSupply);&#13;
&#13;
        return _withdrawTotalSupply;&#13;
    }&#13;
&#13;
&#13;
    /**&#13;
     * @dev withdraw tokens amount within vesting rules for team&#13;
     */&#13;
    function teamWithdraw() public {&#13;
        teamTotalSupply = vestingWithdraw(teamWallet, _teamTokens, teamTotalSupply);&#13;
    }&#13;
&#13;
&#13;
    /**&#13;
     * @dev withdraw tokens amount within vesting rules for advisory&#13;
     */&#13;
    function advisoryWithdraw() public {&#13;
        advisoryTotalSupply = vestingWithdraw(advisoryWallet, _advisoryTokens, advisoryTotalSupply);&#13;
    }&#13;
&#13;
&#13;
    /**&#13;
     * @dev withdraw tokens amount within vesting rules for reserved wallet&#13;
     */&#13;
    function reservedWithdraw() public {&#13;
        reservedTotalSupply = vestingWithdraw(reservedWallet, _reservedTokens, reservedTotalSupply);&#13;
    }&#13;
}