pragma solidity ^0.4.21;

/**
 * @title SafeMath
 * @dev Math operations with safety checks that throw on error
 */
library SafeMath {

  /**
  * @dev Multiplies two numbers, throws on overflow.
  */
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }

  /**
  * @dev Integer division of two numbers, truncating the quotient.
  */
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    // assert(b > 0); // Solidity automatically throws when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return c;
  }

  /**
  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).
  */
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  /**
  * @dev Adds two numbers, throws on overflow.
  */
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }
}


/**
 * @title Ownable
 * @dev The Ownable contract has an owner address, and provides basic authorization control
 * functions, this simplifies the implementation of "user permissions".
 */
contract Ownable {
  address public owner;


  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);


  /**
   * @dev The Ownable constructor sets the original `owner` of the contract to the sender
   * account.
   */
  function Ownable() public {
    owner = msg.sender;
  }

  /**
   * @dev Throws if called by any account other than the owner.
   */
  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }

  /**
   * @dev Allows the current owner to transfer control of the contract to a newOwner.
   * @param newOwner The address to transfer ownership to.
   */
  function transferOwnership(address newOwner) public onlyOwner {
    require(newOwner != address(0));
    OwnershipTransferred(owner, newOwner);
    owner = newOwner;
  }

}


/**
 * @title ERC20Basic
 * @dev Simpler version of ERC20 interface
 * @dev see https://github.com/ethereum/EIPs/issues/179
 */
contract ERC20Basic {
  function totalSupply() public view returns (uint256);
  function balanceOf(address who) public view returns (uint256);
  function transfer(address to, uint256 value) public returns (bool);
  event Transfer(address indexed from, address indexed to, uint256 value);
}


/**
 * @title ERC20 interface
 * @dev see https://github.com/ethereum/EIPs/issues/20
 */
contract ERC20 is ERC20Basic {
  function allowance(address owner, address spender) public view returns (uint256);
  function transferFrom(address from, address to, uint256 value) public returns (bool);
  function approve(address spender, uint256 value) public returns (bool);
  event Approval(address indexed owner, address indexed spender, uint256 value);
}


/**
 * @title SafeERC20
 * @dev Wrappers around ERC20 operations that throw on failure.
 * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,
 * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.
 */
library SafeERC20 {
  function safeTransfer(ERC20Basic token, address to, uint256 value) internal {
    assert(token.transfer(to, value));
  }

  function safeTransferFrom(ERC20 token, address from, address to, uint256 value) internal {
    assert(token.transferFrom(from, to, value));
  }

  function safeApprove(ERC20 token, address spender, uint256 value) internal {
    assert(token.approve(spender, value));
  }
}


/**
 * @title Contracts that should be able to recover tokens
 * @author SylTi
 * @dev This allow a contract to recover any ERC20 token received in a contract by transferring the balance to the contract owner.
 * This will prevent any accidental loss of tokens.
 */
contract CanReclaimToken is Ownable {
  using SafeERC20 for ERC20Basic;

  /**
   * @dev Reclaim all ERC20Basic compatible tokens
   * @param token ERC20Basic The address of the token contract
   */
  function reclaimToken(ERC20Basic token) external onlyOwner {
    uint256 balance = token.balanceOf(this);
    token.safeTransfer(owner, balance);
  }

}


/**
 * @title Contracts that should not own Contracts
 * @author Remco Bloemen <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="bfcddad2dcd0ff8d">[email protected]</a>π.com&gt;&#13;
 * @dev Should contracts (anything Ownable) end up being owned by this contract, it allows the owner&#13;
 * of this contract to reclaim ownership of the contracts.&#13;
 */&#13;
contract HasNoContracts is Ownable {&#13;
&#13;
  /**&#13;
   * @dev Reclaim ownership of Ownable contracts&#13;
   * @param contractAddr The address of the Ownable to be reclaimed.&#13;
   */&#13;
  function reclaimContract(address contractAddr) external onlyOwner {&#13;
    Ownable contractInst = Ownable(contractAddr);&#13;
    contractInst.transferOwnership(owner);&#13;
  }&#13;
}&#13;
&#13;
&#13;
/**&#13;
 * @title Contracts that should not own Tokens&#13;
 * @author Remco Bloemen &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="5220373f313d1260">[email protected]</a>π.com&gt;&#13;
 * @dev This blocks incoming ERC223 tokens to prevent accidental loss of tokens.&#13;
 * Should tokens (any ERC20Basic compatible) end up in the contract, it allows the&#13;
 * owner to reclaim the tokens.&#13;
 */&#13;
contract HasNoTokens is CanReclaimToken {&#13;
&#13;
 /**&#13;
  * @dev Reject all ERC223 compatible tokens&#13;
  * @param from_ address The address that is transferring the tokens&#13;
  * @param value_ uint256 the amount of the specified token&#13;
  * @param data_ Bytes The data passed from the caller.&#13;
  */&#13;
  function tokenFallback(address from_, uint256 value_, bytes data_) external {&#13;
    from_;&#13;
    value_;&#13;
    data_;&#13;
    revert();&#13;
  }&#13;
&#13;
}&#13;
&#13;
&#13;
/**&#13;
 * @title Contracts that should not own Ether&#13;
 * @author Remco Bloemen &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="84f6e1e9e7ebc4b6">[email protected]</a>π.com&gt;&#13;
 * @dev This tries to block incoming ether to prevent accidental loss of Ether. Should Ether end up&#13;
 * in the contract, it will allow the owner to reclaim this ether.&#13;
 * @notice Ether can still be send to this contract by:&#13;
 * calling functions labeled `payable`&#13;
 * `selfdestruct(contract_address)`&#13;
 * mining directly to the contract address&#13;
*/&#13;
contract HasNoEther is Ownable {&#13;
&#13;
  /**&#13;
  * @dev Constructor that rejects incoming Ether&#13;
  * @dev The `payable` flag is added so we can access `msg.value` without compiler warning. If we&#13;
  * leave out payable, then Solidity will allow inheriting contracts to implement a payable&#13;
  * constructor. By doing it this way we prevent a payable constructor from working. Alternatively&#13;
  * we could use assembly to access msg.value.&#13;
  */&#13;
  function HasNoEther() public payable {&#13;
    require(msg.value == 0);&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Disallows direct send by settings a default function without the `payable` flag.&#13;
   */&#13;
  function() external {&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Transfer all Ether held by the contract to the owner.&#13;
   */&#13;
  function reclaimEther() external onlyOwner {&#13;
    assert(owner.send(this.balance));&#13;
  }&#13;
}&#13;
&#13;
&#13;
/**&#13;
 * @title Base contract for contracts that should not own things.&#13;
 * @author Remco Bloemen &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="aad8cfc7c9c5ea98">[email protected]</a>π.com&gt;&#13;
 * @dev Solves a class of errors where a contract accidentally becomes owner of Ether, Tokens or&#13;
 * Owned contracts. See respective base contracts for details.&#13;
 */&#13;
contract NoOwner is HasNoEther, HasNoTokens, HasNoContracts {&#13;
}&#13;
&#13;
&#13;
/**&#13;
 * @title Basic token&#13;
 * @dev Basic version of StandardToken, with no allowances.&#13;
 */&#13;
contract BasicToken is ERC20Basic {&#13;
  using SafeMath for uint256;&#13;
&#13;
  mapping(address =&gt; uint256) balances;&#13;
&#13;
  uint256 totalSupply_;&#13;
&#13;
  /**&#13;
  * @dev total number of tokens in existence&#13;
  */&#13;
  function totalSupply() public view returns (uint256) {&#13;
    return totalSupply_;&#13;
  }&#13;
&#13;
  /**&#13;
  * @dev transfer token for a specified address&#13;
  * @param _to The address to transfer to.&#13;
  * @param _value The amount to be transferred.&#13;
  */&#13;
  function transfer(address _to, uint256 _value) public returns (bool) {&#13;
    require(_to != address(0));&#13;
    require(_value &lt;= balances[msg.sender]);&#13;
&#13;
    // SafeMath.sub will throw if there is not enough balance.&#13;
    balances[msg.sender] = balances[msg.sender].sub(_value);&#13;
    balances[_to] = balances[_to].add(_value);&#13;
    Transfer(msg.sender, _to, _value);&#13;
    return true;&#13;
  }&#13;
&#13;
  /**&#13;
  * @dev Gets the balance of the specified address.&#13;
  * @param _owner The address to query the the balance of.&#13;
  * @return An uint256 representing the amount owned by the passed address.&#13;
  */&#13;
  function balanceOf(address _owner) public view returns (uint256 balance) {&#13;
    return balances[_owner];&#13;
  }&#13;
&#13;
}&#13;
&#13;
&#13;
/**&#13;
 * @title Standard ERC20 token&#13;
 *&#13;
 * @dev Implementation of the basic standard token.&#13;
 * @dev https://github.com/ethereum/EIPs/issues/20&#13;
 * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol&#13;
 */&#13;
contract StandardToken is ERC20, BasicToken {&#13;
&#13;
  mapping (address =&gt; mapping (address =&gt; uint256)) internal allowed;&#13;
&#13;
&#13;
  /**&#13;
   * @dev Transfer tokens from one address to another&#13;
   * @param _from address The address which you want to send tokens from&#13;
   * @param _to address The address which you want to transfer to&#13;
   * @param _value uint256 the amount of tokens to be transferred&#13;
   */&#13;
  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {&#13;
    require(_to != address(0));&#13;
    require(_value &lt;= balances[_from]);&#13;
    require(_value &lt;= allowed[_from][msg.sender]);&#13;
&#13;
    balances[_from] = balances[_from].sub(_value);&#13;
    balances[_to] = balances[_to].add(_value);&#13;
    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);&#13;
    Transfer(_from, _to, _value);&#13;
    return true;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.&#13;
   *&#13;
   * Beware that changing an allowance with this method brings the risk that someone may use both the old&#13;
   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this&#13;
   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:&#13;
   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729&#13;
   * @param _spender The address which will spend the funds.&#13;
   * @param _value The amount of tokens to be spent.&#13;
   */&#13;
  function approve(address _spender, uint256 _value) public returns (bool) {&#13;
    allowed[msg.sender][_spender] = _value;&#13;
    Approval(msg.sender, _spender, _value);&#13;
    return true;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Function to check the amount of tokens that an owner allowed to a spender.&#13;
   * @param _owner address The address which owns the funds.&#13;
   * @param _spender address The address which will spend the funds.&#13;
   * @return A uint256 specifying the amount of tokens still available for the spender.&#13;
   */&#13;
  function allowance(address _owner, address _spender) public view returns (uint256) {&#13;
    return allowed[_owner][_spender];&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Increase the amount of tokens that an owner allowed to a spender.&#13;
   *&#13;
   * approve should be called when allowed[_spender] == 0. To increment&#13;
   * allowed value is better to use this function to avoid 2 calls (and wait until&#13;
   * the first transaction is mined)&#13;
   * From MonolithDAO Token.sol&#13;
   * @param _spender The address which will spend the funds.&#13;
   * @param _addedValue The amount of tokens to increase the allowance by.&#13;
   */&#13;
  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {&#13;
    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);&#13;
    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);&#13;
    return true;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Decrease the amount of tokens that an owner allowed to a spender.&#13;
   *&#13;
   * approve should be called when allowed[_spender] == 0. To decrement&#13;
   * allowed value is better to use this function to avoid 2 calls (and wait until&#13;
   * the first transaction is mined)&#13;
   * From MonolithDAO Token.sol&#13;
   * @param _spender The address which will spend the funds.&#13;
   * @param _subtractedValue The amount of tokens to decrease the allowance by.&#13;
   */&#13;
  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {&#13;
    uint oldValue = allowed[msg.sender][_spender];&#13;
    if (_subtractedValue &gt; oldValue) {&#13;
      allowed[msg.sender][_spender] = 0;&#13;
    } else {&#13;
      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);&#13;
    }&#13;
    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);&#13;
    return true;&#13;
  }&#13;
&#13;
}&#13;
&#13;
&#13;
/**&#13;
 * @title BetexToken&#13;
 */&#13;
contract BetexToken is StandardToken, NoOwner {&#13;
&#13;
    string public constant name = "Betex Token"; // solium-disable-line uppercase&#13;
    string public constant symbol = "BETEX"; // solium-disable-line uppercase&#13;
    uint8 public constant decimals = 18; // solium-disable-line uppercase&#13;
&#13;
    // transfer unlock time (except team and broker recipients)&#13;
    uint256 public firstUnlockTime;&#13;
&#13;
    // transfer unlock time for the team and broker recipients&#13;
    uint256 public secondUnlockTime; &#13;
&#13;
    // addresses locked till second unlock time&#13;
    mapping (address =&gt; bool) public blockedTillSecondUnlock;&#13;
&#13;
    // token holders&#13;
    address[] public holders;&#13;
&#13;
    // holder number&#13;
    mapping (address =&gt; uint256) public holderNumber;&#13;
&#13;
    // ICO address&#13;
    address public icoAddress;&#13;
&#13;
    // supply constants&#13;
    uint256 public constant TOTAL_SUPPLY = 10000000 * (10 ** uint256(decimals));&#13;
    uint256 public constant SALE_SUPPLY = 5000000 * (10 ** uint256(decimals));&#13;
&#13;
    // funds supply constants&#13;
    uint256 public constant BOUNTY_SUPPLY = 200000 * (10 ** uint256(decimals));&#13;
    uint256 public constant RESERVE_SUPPLY = 800000 * (10 ** uint256(decimals));&#13;
    uint256 public constant BROKER_RESERVE_SUPPLY = 1000000 * (10 ** uint256(decimals));&#13;
    uint256 public constant TEAM_SUPPLY = 3000000 * (10 ** uint256(decimals));&#13;
&#13;
    // funds addresses constants&#13;
    address public constant BOUNTY_ADDRESS = 0x48c15e5A9343E3220cdD8127620AE286A204448a;&#13;
    address public constant RESERVE_ADDRESS = 0xC8fE659AaeF73b6e41DEe427c989150e3eDAf57D;&#13;
    address public constant BROKER_RESERVE_ADDRESS = 0x8697d46171aBCaD2dC5A4061b8C35f909a402417;&#13;
    address public constant TEAM_ADDRESS = 0x1761988F02C75E7c3432fa31d179cad6C5843F24;&#13;
&#13;
    // min tokens to be a holder, 0.1&#13;
    uint256 public constant MIN_HOLDER_TOKENS = 10 ** uint256(decimals - 1);&#13;
    &#13;
    /**&#13;
     * @dev Constructor&#13;
     * @param _firstUnlockTime first unlock time&#13;
     * @param _secondUnlockTime second unlock time&#13;
     */&#13;
    function BetexToken&#13;
    (&#13;
        uint256 _firstUnlockTime, &#13;
        uint256 _secondUnlockTime&#13;
    )&#13;
        public &#13;
    {        &#13;
        require(_secondUnlockTime &gt; firstUnlockTime);&#13;
&#13;
        firstUnlockTime = _firstUnlockTime;&#13;
        secondUnlockTime = _secondUnlockTime;&#13;
&#13;
        // Allocate tokens to the bounty fund&#13;
        balances[BOUNTY_ADDRESS] = BOUNTY_SUPPLY;&#13;
        holders.push(BOUNTY_ADDRESS);&#13;
        emit Transfer(0x0, BOUNTY_ADDRESS, BOUNTY_SUPPLY);&#13;
&#13;
        // Allocate tokens to the reserve fund&#13;
        balances[RESERVE_ADDRESS] = RESERVE_SUPPLY;&#13;
        holders.push(RESERVE_ADDRESS);&#13;
        emit Transfer(0x0, RESERVE_ADDRESS, RESERVE_SUPPLY);&#13;
&#13;
        // Allocate tokens to the broker reserve fund&#13;
        balances[BROKER_RESERVE_ADDRESS] = BROKER_RESERVE_SUPPLY;&#13;
        holders.push(BROKER_RESERVE_ADDRESS);&#13;
        emit Transfer(0x0, BROKER_RESERVE_ADDRESS, BROKER_RESERVE_SUPPLY);&#13;
&#13;
        // Allocate tokens to the team fund&#13;
        balances[TEAM_ADDRESS] = TEAM_SUPPLY;&#13;
        holders.push(TEAM_ADDRESS);&#13;
        emit Transfer(0x0, TEAM_ADDRESS, TEAM_SUPPLY);&#13;
&#13;
        totalSupply_ = TOTAL_SUPPLY.sub(SALE_SUPPLY);&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev set ICO address and allocate sale supply to it&#13;
     */&#13;
    function setICO(address _icoAddress) public onlyOwner {&#13;
        require(_icoAddress != address(0));&#13;
        require(icoAddress == address(0));&#13;
        require(totalSupply_ == TOTAL_SUPPLY.sub(SALE_SUPPLY));&#13;
        &#13;
        // Allocate tokens to the ico contract&#13;
        balances[_icoAddress] = SALE_SUPPLY;&#13;
        emit Transfer(0x0, _icoAddress, SALE_SUPPLY);&#13;
&#13;
        icoAddress = _icoAddress;&#13;
        totalSupply_ = TOTAL_SUPPLY;&#13;
    }&#13;
    &#13;
    // standard transfer function with timelocks&#13;
    function transfer(address _to, uint256 _value) public returns (bool) {&#13;
        require(transferAllowed(msg.sender));&#13;
        enforceSecondLock(msg.sender, _to);&#13;
        preserveHolders(msg.sender, _to, _value);&#13;
        return super.transfer(_to, _value);&#13;
    }&#13;
&#13;
    // standard transferFrom function with timelocks&#13;
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {&#13;
        require(transferAllowed(msg.sender));&#13;
        enforceSecondLock(msg.sender, _to);&#13;
        preserveHolders(_from, _to, _value);&#13;
        return super.transferFrom(_from, _to, _value);&#13;
    }&#13;
&#13;
    // get holders count&#13;
    function getHoldersCount() public view returns (uint256) {&#13;
        return holders.length;&#13;
    }&#13;
&#13;
    // enforce second lock on receiver&#13;
    function enforceSecondLock(address _from, address _to) internal {&#13;
        if (now &lt; secondUnlockTime) { // solium-disable-line security/no-block-members&#13;
            if (_from == TEAM_ADDRESS || _from == BROKER_RESERVE_ADDRESS) {&#13;
                require(balances[_to] == uint256(0) || blockedTillSecondUnlock[_to]);&#13;
                blockedTillSecondUnlock[_to] = true;&#13;
            }&#13;
        }&#13;
    }&#13;
&#13;
    // preserve holders list&#13;
    function preserveHolders(address _from, address _to, uint256 _value) internal {&#13;
        if (balances[_from].sub(_value) &lt; MIN_HOLDER_TOKENS) &#13;
            removeHolder(_from);&#13;
        if (balances[_to].add(_value) &gt;= MIN_HOLDER_TOKENS) &#13;
            addHolder(_to);   &#13;
    }&#13;
&#13;
    // remove holder from the holders list&#13;
    function removeHolder(address _holder) internal {&#13;
        uint256 _number = holderNumber[_holder];&#13;
&#13;
        if (_number == 0 || holders.length == 0 || _number &gt; holders.length)&#13;
            return;&#13;
&#13;
        uint256 _index = _number.sub(1);&#13;
        uint256 _lastIndex = holders.length.sub(1);&#13;
        address _lastHolder = holders[_lastIndex];&#13;
&#13;
        if (_index != _lastIndex) {&#13;
            holders[_index] = _lastHolder;&#13;
            holderNumber[_lastHolder] = _number;&#13;
        }&#13;
&#13;
        holderNumber[_holder] = 0;&#13;
        holders.length = _lastIndex;&#13;
    } &#13;
&#13;
    // add holder to the holders list&#13;
    function addHolder(address _holder) internal {&#13;
        if (holderNumber[_holder] == 0) {&#13;
            holders.push(_holder);&#13;
            holderNumber[_holder] = holders.length;&#13;
        }&#13;
    }&#13;
&#13;
    // @return true if transfer operation is allowed&#13;
    function transferAllowed(address _sender) internal view returns(bool) {&#13;
        if (now &gt; secondUnlockTime || _sender == icoAddress) // solium-disable-line security/no-block-members&#13;
            return true;&#13;
        if (now &lt; firstUnlockTime) // solium-disable-line security/no-block-members&#13;
            return false;&#13;
        if (blockedTillSecondUnlock[_sender])&#13;
            return false;&#13;
        return true;&#13;
    }&#13;
&#13;
}&#13;
&#13;
&#13;
/**&#13;
 * @title BetexStorage&#13;
 */&#13;
contract BetexStorage is Ownable {&#13;
&#13;
    // minimum funding to get volume bonus	&#13;
    uint256 public constant VOLUME_BONUS_CONDITION = 50 ether;&#13;
&#13;
    // minimum funding to get volume extra bonus	&#13;
    uint256 public constant VOLUME_EXTRA_BONUS_CONDITION = 100 ether;&#13;
&#13;
    // extra bonus amount during first bonus round, %&#13;
    uint256 public constant FIRST_VOLUME_EXTRA_BONUS = 20;&#13;
&#13;
    // extra bonus amount during second bonus round, %&#13;
    uint256 public constant SECOND_VOLUME_EXTRA_BONUS = 10;&#13;
&#13;
    // bonus amount during first bonus round, %&#13;
    uint256 public constant FIRST_VOLUME_BONUS = 10;&#13;
&#13;
    // bonus amount during second bonus round, %&#13;
    uint256 public constant SECOND_VOLUME_BONUS = 5;&#13;
&#13;
    // oraclize funding order&#13;
    struct Order {&#13;
        address beneficiary;&#13;
        uint256 funds;&#13;
        uint256 bonus;&#13;
        uint256 rate;&#13;
    }&#13;
&#13;
    // oraclize funding orders&#13;
    mapping (bytes32 =&gt; Order) public orders;&#13;
&#13;
    // oraclize orders for unsold tokens allocation&#13;
    mapping (bytes32 =&gt; bool) public unsoldAllocationOrders;&#13;
&#13;
    // addresses allowed to buy tokens&#13;
    mapping (address =&gt; bool) public whitelist;&#13;
&#13;
    // funded&#13;
    mapping (address =&gt; bool) public funded;&#13;
&#13;
    // funders&#13;
    address[] public funders;&#13;
    &#13;
    // pre ico funders&#13;
    address[] public preICOFunders;&#13;
&#13;
    // tokens to allocate before ico sale starts&#13;
    mapping (address =&gt; uint256) public preICOBalances;&#13;
&#13;
    // is preICO data initialized&#13;
    bool public preICODataInitialized;&#13;
&#13;
&#13;
    /**&#13;
     * @dev Constructor&#13;
     */  &#13;
    function BetexStorage() public {&#13;
&#13;
        // pre sale round 1&#13;
        preICOFunders.push(0x233Fd2B3d7a0924Fe1Bb0dd7FA168eEF8C522E65);&#13;
        preICOBalances[0x233Fd2B3d7a0924Fe1Bb0dd7FA168eEF8C522E65] = 15000000000000000000000;&#13;
        preICOFunders.push(0x2712ba56cB3Cf8783693c8a1796F70ABa57132b1);&#13;
        preICOBalances[0x2712ba56cB3Cf8783693c8a1796F70ABa57132b1] = 15000000000000000000000;&#13;
        preICOFunders.push(0x6f3DDfb726eA637e125C4fbf6694B940711478f4);&#13;
        preICOBalances[0x6f3DDfb726eA637e125C4fbf6694B940711478f4] = 15000000000000000000000;&#13;
        preICOFunders.push(0xAf7Ff6f381684707001d517Bf83C4a3538f9C82a);&#13;
        preICOBalances[0xAf7Ff6f381684707001d517Bf83C4a3538f9C82a] = 22548265874120000000000;&#13;
        preICOFunders.push(0x51219a9330c196b8bd7fA0737C8e0db53c1ad628);&#13;
        preICOBalances[0x51219a9330c196b8bd7fA0737C8e0db53c1ad628] = 32145215844400000000000;&#13;
        preICOFunders.push(0xA2D42D689769f7BA32712f27B09606fFD8F3b699);&#13;
        preICOBalances[0xA2D42D689769f7BA32712f27B09606fFD8F3b699] = 15000000000000000000000;&#13;
        preICOFunders.push(0xB7C9D3AAbF44296232538B8b184F274B57003994);&#13;
        preICOBalances[0xB7C9D3AAbF44296232538B8b184F274B57003994] = 20000000000000000000000;&#13;
        preICOFunders.push(0x58667a170F53b809CA9143c1CeEa00D2Df866577);&#13;
        preICOBalances[0x58667a170F53b809CA9143c1CeEa00D2Df866577] = 184526257787000000000000;&#13;
        preICOFunders.push(0x0D4b2A1a47b1059d622C033c2a58F2F651010553);&#13;
        preICOBalances[0x0D4b2A1a47b1059d622C033c2a58F2F651010553] = 17845264771100000000000;&#13;
        preICOFunders.push(0x982F59497026473d2227f5dd02cdf6fdCF237AE0);&#13;
        preICOBalances[0x982F59497026473d2227f5dd02cdf6fdCF237AE0] = 31358989521120000000000;&#13;
        preICOFunders.push(0x250d540EFeabA7b5C0407A955Fd76217590dbc37);&#13;
        preICOBalances[0x250d540EFeabA7b5C0407A955Fd76217590dbc37] = 15000000000000000000000;&#13;
        preICOFunders.push(0x2Cde7768B7d5dcb12c5b5572daEf3F7B855c8685);&#13;
        preICOBalances[0x2Cde7768B7d5dcb12c5b5572daEf3F7B855c8685] = 17500000000000000000000;&#13;
        preICOFunders.push(0x89777c2a4C1843a99B2fF481a4CEF67f5d7A1387);&#13;
        preICOBalances[0x89777c2a4C1843a99B2fF481a4CEF67f5d7A1387] = 15000000000000000000000;&#13;
        preICOFunders.push(0x63699D4d309e48e8B575BE771700570A828dC655);&#13;
        preICOBalances[0x63699D4d309e48e8B575BE771700570A828dC655] = 15000000000000000000000;&#13;
        preICOFunders.push(0x9bc92E0da2e4aC174b8E33D7c74b5009563a8e2A);&#13;
        preICOBalances[0x9bc92E0da2e4aC174b8E33D7c74b5009563a8e2A] = 21542365440880000000000;&#13;
        preICOFunders.push(0xA1CA632CF8Fb3a965c84668e09e3BEdb3567F35D);&#13;
        preICOBalances[0xA1CA632CF8Fb3a965c84668e09e3BEdb3567F35D] = 15000000000000000000000;&#13;
        preICOFunders.push(0x1DCeF74ddD26c82f34B300E027b5CaA4eC4F8C83);&#13;
        preICOBalances[0x1DCeF74ddD26c82f34B300E027b5CaA4eC4F8C83] = 15000000000000000000000;&#13;
        preICOFunders.push(0x51B7Bf4B7C1E89cfe7C09938Ad0096F9dFFCA4B7);&#13;
        preICOBalances[0x51B7Bf4B7C1E89cfe7C09938Ad0096F9dFFCA4B7] = 17533640761380000000000;&#13;
&#13;
        // pre sale round 2 &#13;
        preICOFunders.push(0xD2Cdc0905877ee3b7d08220D783bd042de825AEb);&#13;
        preICOBalances[0xD2Cdc0905877ee3b7d08220D783bd042de825AEb] = 5000000000000000000000;&#13;
        preICOFunders.push(0x3b217081702AF670e2c2fD25FD7da882620a68E8);&#13;
        preICOBalances[0x3b217081702AF670e2c2fD25FD7da882620a68E8] = 7415245400000000000000;&#13;
        preICOFunders.push(0xbA860D4B9423bF6b517B29c395A49fe80Da758E3);&#13;
        preICOBalances[0xbA860D4B9423bF6b517B29c395A49fe80Da758E3] = 5000000000000000000000;&#13;
        preICOFunders.push(0xF64b80DdfB860C0D1bEb760fd9fC663c4D5C4dC3);&#13;
        preICOBalances[0xF64b80DdfB860C0D1bEb760fd9fC663c4D5C4dC3] = 75000000000000000000000;&#13;
        preICOFunders.push(0x396D5A35B5f41D7cafCCF9BeF225c274d2c7B6E2);&#13;
        preICOBalances[0x396D5A35B5f41D7cafCCF9BeF225c274d2c7B6E2] = 74589245777000000000000;&#13;
        preICOFunders.push(0x4d61A4aD175E96139Ae8c5d951327e3f6Cc3f764);&#13;
        preICOBalances[0x4d61A4aD175E96139Ae8c5d951327e3f6Cc3f764] = 5000000000000000000000;&#13;
        preICOFunders.push(0x4B490F6A49C17657A5508B8Bf8F1D7f5aAD8c921);&#13;
        preICOBalances[0x4B490F6A49C17657A5508B8Bf8F1D7f5aAD8c921] = 200000000000000000000000;&#13;
        preICOFunders.push(0xC943038f2f1dd1faC6E10B82039C14bd20ff1F8E);&#13;
        preICOBalances[0xC943038f2f1dd1faC6E10B82039C14bd20ff1F8E] = 174522545811300000000000;&#13;
        preICOFunders.push(0xBa87D63A8C4Ed665b6881BaCe4A225a07c418F22);&#13;
        preICOBalances[0xBa87D63A8C4Ed665b6881BaCe4A225a07c418F22] = 5000000000000000000000;&#13;
        preICOFunders.push(0x753846c0467cF320BcDA9f1C67fF86dF39b1438c);&#13;
        preICOBalances[0x753846c0467cF320BcDA9f1C67fF86dF39b1438c] = 5000000000000000000000;&#13;
        preICOFunders.push(0x3773bBB1adDF9D642D5bbFaafa13b0690Fb33460);&#13;
        preICOBalances[0x3773bBB1adDF9D642D5bbFaafa13b0690Fb33460] = 5000000000000000000000;&#13;
        preICOFunders.push(0x456Cf70345cbF483779166af117B40938B8F0A9c);&#13;
        preICOBalances[0x456Cf70345cbF483779166af117B40938B8F0A9c] = 50000000000000000000000;&#13;
        preICOFunders.push(0x662AE260D736F041Db66c34617d5fB22eC0cC2Ee);&#13;
        preICOBalances[0x662AE260D736F041Db66c34617d5fB22eC0cC2Ee] = 40000000000000000000000;&#13;
        preICOFunders.push(0xEa7e647F167AdAa4df52AF630A873a1379f68E3F);&#13;
        preICOBalances[0xEa7e647F167AdAa4df52AF630A873a1379f68E3F] = 40000000000000000000000;&#13;
        preICOFunders.push(0x352913f3F7CA96530180b93C18C86f38b3F0c429);&#13;
        preICOBalances[0x352913f3F7CA96530180b93C18C86f38b3F0c429] = 45458265454000000000000;&#13;
        preICOFunders.push(0xB21bf8391a6500ED210Af96d125867124261f4d4);&#13;
        preICOBalances[0xB21bf8391a6500ED210Af96d125867124261f4d4] = 5000000000000000000000;&#13;
        preICOFunders.push(0xDecBd29B42c66f90679D2CB34e73E571F447f6c5);&#13;
        preICOBalances[0xDecBd29B42c66f90679D2CB34e73E571F447f6c5] = 7500000000000000000000;&#13;
        preICOFunders.push(0xE36106a0DC0F07e87f7194694631511317909b8B);&#13;
        preICOBalances[0xE36106a0DC0F07e87f7194694631511317909b8B] = 5000000000000000000000;&#13;
        preICOFunders.push(0xe9114cd97E0Ee4fe349D3F57d0C9710E18581b69);&#13;
        preICOBalances[0xe9114cd97E0Ee4fe349D3F57d0C9710E18581b69] = 40000000000000000000000;&#13;
        preICOFunders.push(0xC73996ce45752B9AE4e85EDDf056Aa9aaCaAD4A2);&#13;
        preICOBalances[0xC73996ce45752B9AE4e85EDDf056Aa9aaCaAD4A2] = 100000000000000000000000;&#13;
        preICOFunders.push(0x6C1407d9984Dc2cE33456b67acAaEC78c1784673);&#13;
        preICOBalances[0x6C1407d9984Dc2cE33456b67acAaEC78c1784673] = 5000000000000000000000;&#13;
        preICOFunders.push(0x987e93429004CA9fa2A42604658B99Bb5A574f01);&#13;
        preICOBalances[0x987e93429004CA9fa2A42604658B99Bb5A574f01] = 124354548881022000000000;&#13;
        preICOFunders.push(0x4c3B81B5f9f9c7efa03bE39218E6760E8D2A1609);&#13;
        preICOBalances[0x4c3B81B5f9f9c7efa03bE39218E6760E8D2A1609] = 5000000000000000000000;&#13;
        preICOFunders.push(0x33fA8cd89B151458Cb147ecC497e469f2c1D38eA);&#13;
        preICOBalances[0x33fA8cd89B151458Cb147ecC497e469f2c1D38eA] = 60000000000000000000000;&#13;
&#13;
        // main sale (01-31 of Marh)&#13;
        preICOFunders.push(0x9AfA1204afCf48AB4302F246Ef4BE5C1D733a751);&#13;
        preICOBalances[0x9AfA1204afCf48AB4302F246Ef4BE5C1D733a751] = 154551417972192330000000;&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Add a new address to the funders&#13;
     * @param _funder funder's address&#13;
     */&#13;
    function addFunder(address _funder) public onlyOwner {&#13;
        if (!funded[_funder]) {&#13;
            funders.push(_funder);&#13;
            funded[_funder] = true;&#13;
        }&#13;
    }&#13;
   &#13;
    /**&#13;
     * @return true if address is a funder address&#13;
     * @param _funder funder's address&#13;
     */&#13;
    function isFunder(address _funder) public view returns(bool) {&#13;
        return funded[_funder];&#13;
    }&#13;
&#13;
    /**&#13;
     * @return funders count&#13;
     */&#13;
    function getFundersCount() public view returns(uint256) {&#13;
        return funders.length;&#13;
    }&#13;
&#13;
    /**&#13;
     * @return number of preICO funders count&#13;
     */&#13;
    function getPreICOFundersCount() public view returns(uint256) {&#13;
        return preICOFunders.length;&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Add a new oraclize funding order&#13;
     * @param _orderId oraclize order id&#13;
     * @param _beneficiary who'll get the tokens&#13;
     * @param _funds paid wei amount&#13;
     * @param _bonus bonus amount&#13;
     */&#13;
    function addOrder(&#13;
        bytes32 _orderId, &#13;
        address _beneficiary, &#13;
        uint256 _funds, &#13;
        uint256 _bonus&#13;
    )&#13;
        public &#13;
        onlyOwner &#13;
    {&#13;
        orders[_orderId].beneficiary = _beneficiary;&#13;
        orders[_orderId].funds = _funds;&#13;
        orders[_orderId].bonus = _bonus;&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Get oraclize funding order by order id&#13;
     * @param _orderId oraclize order id&#13;
     * @return beneficiaty address, paid funds amount and bonus amount &#13;
     */&#13;
    function getOrder(bytes32 _orderId) &#13;
        public &#13;
        view &#13;
        returns(address, uint256, uint256)&#13;
    {&#13;
        address _beneficiary = orders[_orderId].beneficiary;&#13;
        uint256 _funds = orders[_orderId].funds;&#13;
        uint256 _bonus = orders[_orderId].bonus;&#13;
&#13;
        return (_beneficiary, _funds, _bonus);&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Set eth/usd rate for the specified oraclize order&#13;
     * @param _orderId oraclize order id&#13;
     * @param _rate eth/usd rate&#13;
     */&#13;
    function setRateForOrder(bytes32 _orderId, uint256 _rate) public onlyOwner {&#13;
        orders[_orderId].rate = _rate;&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Add a new oraclize unsold tokens allocation order&#13;
     * @param _orderId oraclize order id&#13;
     */&#13;
    function addUnsoldAllocationOrder(bytes32 _orderId) public onlyOwner {&#13;
        unsoldAllocationOrders[_orderId] = true;&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Whitelist the address&#13;
     * @param _address address to be whitelisted&#13;
     */&#13;
    function addToWhitelist(address _address) public onlyOwner {&#13;
        whitelist[_address] = true;&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Check if address is whitelisted&#13;
     * @param _address address that needs to be verified&#13;
     * @return true if address is whitelisted&#13;
     */&#13;
    function isWhitelisted(address _address) public view returns(bool) {&#13;
        return whitelist[_address];&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Get bonus amount for token purchase&#13;
     * @param _funds amount of the funds&#13;
     * @param _bonusChangeTime bonus change time&#13;
     * @return corresponding bonus value&#13;
     */&#13;
    function getBonus(uint256 _funds, uint256 _bonusChangeTime) public view returns(uint256) {&#13;
        &#13;
        if (_funds &lt; VOLUME_BONUS_CONDITION)&#13;
            return 0;&#13;
&#13;
        if (now &lt; _bonusChangeTime) { // solium-disable-line security/no-block-members&#13;
            if (_funds &gt;= VOLUME_EXTRA_BONUS_CONDITION)&#13;
                return FIRST_VOLUME_EXTRA_BONUS;&#13;
            else &#13;
                return FIRST_VOLUME_BONUS;&#13;
        } else {&#13;
            if (_funds &gt;= VOLUME_EXTRA_BONUS_CONDITION)&#13;
                return SECOND_VOLUME_EXTRA_BONUS;&#13;
            else&#13;
                return SECOND_VOLUME_BONUS;&#13;
        }&#13;
        return 0;&#13;
    }&#13;
}&#13;
&#13;
&#13;
&#13;
// &lt;ORACLIZE_API&gt;&#13;
/*&#13;
Copyright (c) 2015-2016 Oraclize SRL&#13;
Copyright (c) 2016 Oraclize LTD&#13;
&#13;
&#13;
&#13;
Permission is hereby granted, free of charge, to any person obtaining a copy&#13;
of this software and associated documentation files (the "Software"), to deal&#13;
in the Software without restriction, including without limitation the rights&#13;
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell&#13;
copies of the Software, and to permit persons to whom the Software is&#13;
furnished to do so, subject to the following conditions:&#13;
&#13;
&#13;
&#13;
The above copyright notice and this permission notice shall be included in&#13;
all copies or substantial portions of the Software.&#13;
&#13;
&#13;
&#13;
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR&#13;
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,&#13;
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE&#13;
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER&#13;
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,&#13;
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN&#13;
THE SOFTWARE.&#13;
*/&#13;
&#13;
// This api is currently targeted at 0.4.18, please import oraclizeAPI_pre0.4.sol or oraclizeAPI_0.4 where necessary&#13;
pragma solidity ^0.4.18;&#13;
&#13;
contract OraclizeI {&#13;
    address public cbAddress;&#13;
    function query(uint _timestamp, string _datasource, string _arg) external payable returns (bytes32 _id);&#13;
    function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) external payable returns (bytes32 _id);&#13;
    function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) public payable returns (bytes32 _id);&#13;
    function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) external payable returns (bytes32 _id);&#13;
    function queryN(uint _timestamp, string _datasource, bytes _argN) public payable returns (bytes32 _id);&#13;
    function queryN_withGasLimit(uint _timestamp, string _datasource, bytes _argN, uint _gaslimit) external payable returns (bytes32 _id);&#13;
    function getPrice(string _datasource) public returns (uint _dsprice);&#13;
    function getPrice(string _datasource, uint gaslimit) public returns (uint _dsprice);&#13;
    function setProofType(byte _proofType) external;&#13;
    function setCustomGasPrice(uint _gasPrice) external;&#13;
    function randomDS_getSessionPubKeyHash() external constant returns(bytes32);&#13;
}&#13;
contract OraclizeAddrResolverI {&#13;
    function getAddress() public returns (address _addr);&#13;
}&#13;
contract usingOraclize {&#13;
    uint constant day = 60*60*24;&#13;
    uint constant week = 60*60*24*7;&#13;
    uint constant month = 60*60*24*30;&#13;
    byte constant proofType_NONE = 0x00;&#13;
    byte constant proofType_TLSNotary = 0x10;&#13;
    byte constant proofType_Android = 0x20;&#13;
    byte constant proofType_Ledger = 0x30;&#13;
    byte constant proofType_Native = 0xF0;&#13;
    byte constant proofStorage_IPFS = 0x01;&#13;
    uint8 constant networkID_auto = 0;&#13;
    uint8 constant networkID_mainnet = 1;&#13;
    uint8 constant networkID_testnet = 2;&#13;
    uint8 constant networkID_morden = 2;&#13;
    uint8 constant networkID_consensys = 161;&#13;
&#13;
    OraclizeAddrResolverI OAR;&#13;
&#13;
    OraclizeI oraclize;&#13;
    modifier oraclizeAPI {&#13;
        if((address(OAR)==0)||(getCodeSize(address(OAR))==0))&#13;
            oraclize_setNetwork(networkID_auto);&#13;
&#13;
        if(address(oraclize) != OAR.getAddress())&#13;
            oraclize = OraclizeI(OAR.getAddress());&#13;
&#13;
        _;&#13;
    }&#13;
    modifier coupon(string code){&#13;
        oraclize = OraclizeI(OAR.getAddress());&#13;
        _;&#13;
    }&#13;
&#13;
    function oraclize_setNetwork(uint8 networkID) internal returns(bool){&#13;
      return oraclize_setNetwork();&#13;
      networkID; // silence the warning and remain backwards compatible&#13;
    }&#13;
    function oraclize_setNetwork() internal returns(bool){&#13;
        if (getCodeSize(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed)&gt;0){ //mainnet&#13;
            OAR = OraclizeAddrResolverI(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed);&#13;
            oraclize_setNetworkName("eth_mainnet");&#13;
            return true;&#13;
        }&#13;
        if (getCodeSize(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1)&gt;0){ //ropsten testnet&#13;
            OAR = OraclizeAddrResolverI(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1);&#13;
            oraclize_setNetworkName("eth_ropsten3");&#13;
            return true;&#13;
        }&#13;
        if (getCodeSize(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e)&gt;0){ //kovan testnet&#13;
            OAR = OraclizeAddrResolverI(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e);&#13;
            oraclize_setNetworkName("eth_kovan");&#13;
            return true;&#13;
        }&#13;
        if (getCodeSize(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48)&gt;0){ //rinkeby testnet&#13;
            OAR = OraclizeAddrResolverI(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48);&#13;
            oraclize_setNetworkName("eth_rinkeby");&#13;
            return true;&#13;
        }&#13;
        if (getCodeSize(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475)&gt;0){ //ethereum-bridge&#13;
            OAR = OraclizeAddrResolverI(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475);&#13;
            return true;&#13;
        }&#13;
        if (getCodeSize(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF)&gt;0){ //ether.camp ide&#13;
            OAR = OraclizeAddrResolverI(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF);&#13;
            return true;&#13;
        }&#13;
        if (getCodeSize(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA)&gt;0){ //browser-solidity&#13;
            OAR = OraclizeAddrResolverI(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA);&#13;
            return true;&#13;
        }&#13;
        return false;&#13;
    }&#13;
&#13;
    function __callback(bytes32 myid, string result) public {&#13;
        __callback(myid, result, new bytes(0));&#13;
    }&#13;
    function __callback(bytes32 myid, string result, bytes proof) public {&#13;
      return;&#13;
      myid; result; proof; // Silence compiler warnings&#13;
    }&#13;
&#13;
    function oraclize_getPrice(string datasource) oraclizeAPI internal returns (uint){&#13;
        return oraclize.getPrice(datasource);&#13;
    }&#13;
&#13;
    function oraclize_getPrice(string datasource, uint gaslimit) oraclizeAPI internal returns (uint){&#13;
        return oraclize.getPrice(datasource, gaslimit);&#13;
    }&#13;
&#13;
    function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){&#13;
        uint price = oraclize.getPrice(datasource);&#13;
        if (price &gt; 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price&#13;
        return oraclize.query.value(price)(0, datasource, arg);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){&#13;
        uint price = oraclize.getPrice(datasource);&#13;
        if (price &gt; 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price&#13;
        return oraclize.query.value(price)(timestamp, datasource, arg);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){&#13;
        uint price = oraclize.getPrice(datasource, gaslimit);&#13;
        if (price &gt; 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price&#13;
        return oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){&#13;
        uint price = oraclize.getPrice(datasource, gaslimit);&#13;
        if (price &gt; 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price&#13;
        return oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){&#13;
        uint price = oraclize.getPrice(datasource);&#13;
        if (price &gt; 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price&#13;
        return oraclize.query2.value(price)(0, datasource, arg1, arg2);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){&#13;
        uint price = oraclize.getPrice(datasource);&#13;
        if (price &gt; 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price&#13;
        return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){&#13;
        uint price = oraclize.getPrice(datasource, gaslimit);&#13;
        if (price &gt; 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price&#13;
        return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){&#13;
        uint price = oraclize.getPrice(datasource, gaslimit);&#13;
        if (price &gt; 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price&#13;
        return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, string[] argN) oraclizeAPI internal returns (bytes32 id){&#13;
        uint price = oraclize.getPrice(datasource);&#13;
        if (price &gt; 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price&#13;
        bytes memory args = stra2cbor(argN);&#13;
        return oraclize.queryN.value(price)(0, datasource, args);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, string[] argN) oraclizeAPI internal returns (bytes32 id){&#13;
        uint price = oraclize.getPrice(datasource);&#13;
        if (price &gt; 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price&#13;
        bytes memory args = stra2cbor(argN);&#13;
        return oraclize.queryN.value(price)(timestamp, datasource, args);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, string[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){&#13;
        uint price = oraclize.getPrice(datasource, gaslimit);&#13;
        if (price &gt; 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price&#13;
        bytes memory args = stra2cbor(argN);&#13;
        return oraclize.queryN_withGasLimit.value(price)(timestamp, datasource, args, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, string[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){&#13;
        uint price = oraclize.getPrice(datasource, gaslimit);&#13;
        if (price &gt; 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price&#13;
        bytes memory args = stra2cbor(argN);&#13;
        return oraclize.queryN_withGasLimit.value(price)(0, datasource, args, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, string[1] args) oraclizeAPI internal returns (bytes32 id) {&#13;
        string[] memory dynargs = new string[](1);&#13;
        dynargs[0] = args[0];&#13;
        return oraclize_query(datasource, dynargs);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, string[1] args) oraclizeAPI internal returns (bytes32 id) {&#13;
        string[] memory dynargs = new string[](1);&#13;
        dynargs[0] = args[0];&#13;
        return oraclize_query(timestamp, datasource, dynargs);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, string[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {&#13;
        string[] memory dynargs = new string[](1);&#13;
        dynargs[0] = args[0];&#13;
        return oraclize_query(timestamp, datasource, dynargs, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, string[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {&#13;
        string[] memory dynargs = new string[](1);&#13;
        dynargs[0] = args[0];&#13;
        return oraclize_query(datasource, dynargs, gaslimit);&#13;
    }&#13;
&#13;
    function oraclize_query(string datasource, string[2] args) oraclizeAPI internal returns (bytes32 id) {&#13;
        string[] memory dynargs = new string[](2);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        return oraclize_query(datasource, dynargs);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, string[2] args) oraclizeAPI internal returns (bytes32 id) {&#13;
        string[] memory dynargs = new string[](2);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        return oraclize_query(timestamp, datasource, dynargs);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, string[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {&#13;
        string[] memory dynargs = new string[](2);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        return oraclize_query(timestamp, datasource, dynargs, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, string[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {&#13;
        string[] memory dynargs = new string[](2);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        return oraclize_query(datasource, dynargs, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, string[3] args) oraclizeAPI internal returns (bytes32 id) {&#13;
        string[] memory dynargs = new string[](3);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        return oraclize_query(datasource, dynargs);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, string[3] args) oraclizeAPI internal returns (bytes32 id) {&#13;
        string[] memory dynargs = new string[](3);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        return oraclize_query(timestamp, datasource, dynargs);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, string[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {&#13;
        string[] memory dynargs = new string[](3);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        return oraclize_query(timestamp, datasource, dynargs, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, string[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {&#13;
        string[] memory dynargs = new string[](3);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        return oraclize_query(datasource, dynargs, gaslimit);&#13;
    }&#13;
&#13;
    function oraclize_query(string datasource, string[4] args) oraclizeAPI internal returns (bytes32 id) {&#13;
        string[] memory dynargs = new string[](4);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        dynargs[3] = args[3];&#13;
        return oraclize_query(datasource, dynargs);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, string[4] args) oraclizeAPI internal returns (bytes32 id) {&#13;
        string[] memory dynargs = new string[](4);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        dynargs[3] = args[3];&#13;
        return oraclize_query(timestamp, datasource, dynargs);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, string[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {&#13;
        string[] memory dynargs = new string[](4);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        dynargs[3] = args[3];&#13;
        return oraclize_query(timestamp, datasource, dynargs, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, string[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {&#13;
        string[] memory dynargs = new string[](4);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        dynargs[3] = args[3];&#13;
        return oraclize_query(datasource, dynargs, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, string[5] args) oraclizeAPI internal returns (bytes32 id) {&#13;
        string[] memory dynargs = new string[](5);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        dynargs[3] = args[3];&#13;
        dynargs[4] = args[4];&#13;
        return oraclize_query(datasource, dynargs);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, string[5] args) oraclizeAPI internal returns (bytes32 id) {&#13;
        string[] memory dynargs = new string[](5);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        dynargs[3] = args[3];&#13;
        dynargs[4] = args[4];&#13;
        return oraclize_query(timestamp, datasource, dynargs);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, string[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {&#13;
        string[] memory dynargs = new string[](5);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        dynargs[3] = args[3];&#13;
        dynargs[4] = args[4];&#13;
        return oraclize_query(timestamp, datasource, dynargs, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, string[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {&#13;
        string[] memory dynargs = new string[](5);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        dynargs[3] = args[3];&#13;
        dynargs[4] = args[4];&#13;
        return oraclize_query(datasource, dynargs, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, bytes[] argN) oraclizeAPI internal returns (bytes32 id){&#13;
        uint price = oraclize.getPrice(datasource);&#13;
        if (price &gt; 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price&#13;
        bytes memory args = ba2cbor(argN);&#13;
        return oraclize.queryN.value(price)(0, datasource, args);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, bytes[] argN) oraclizeAPI internal returns (bytes32 id){&#13;
        uint price = oraclize.getPrice(datasource);&#13;
        if (price &gt; 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price&#13;
        bytes memory args = ba2cbor(argN);&#13;
        return oraclize.queryN.value(price)(timestamp, datasource, args);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, bytes[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){&#13;
        uint price = oraclize.getPrice(datasource, gaslimit);&#13;
        if (price &gt; 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price&#13;
        bytes memory args = ba2cbor(argN);&#13;
        return oraclize.queryN_withGasLimit.value(price)(timestamp, datasource, args, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, bytes[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){&#13;
        uint price = oraclize.getPrice(datasource, gaslimit);&#13;
        if (price &gt; 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price&#13;
        bytes memory args = ba2cbor(argN);&#13;
        return oraclize.queryN_withGasLimit.value(price)(0, datasource, args, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, bytes[1] args) oraclizeAPI internal returns (bytes32 id) {&#13;
        bytes[] memory dynargs = new bytes[](1);&#13;
        dynargs[0] = args[0];&#13;
        return oraclize_query(datasource, dynargs);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, bytes[1] args) oraclizeAPI internal returns (bytes32 id) {&#13;
        bytes[] memory dynargs = new bytes[](1);&#13;
        dynargs[0] = args[0];&#13;
        return oraclize_query(timestamp, datasource, dynargs);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, bytes[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {&#13;
        bytes[] memory dynargs = new bytes[](1);&#13;
        dynargs[0] = args[0];&#13;
        return oraclize_query(timestamp, datasource, dynargs, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, bytes[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {&#13;
        bytes[] memory dynargs = new bytes[](1);&#13;
        dynargs[0] = args[0];&#13;
        return oraclize_query(datasource, dynargs, gaslimit);&#13;
    }&#13;
&#13;
    function oraclize_query(string datasource, bytes[2] args) oraclizeAPI internal returns (bytes32 id) {&#13;
        bytes[] memory dynargs = new bytes[](2);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        return oraclize_query(datasource, dynargs);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, bytes[2] args) oraclizeAPI internal returns (bytes32 id) {&#13;
        bytes[] memory dynargs = new bytes[](2);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        return oraclize_query(timestamp, datasource, dynargs);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, bytes[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {&#13;
        bytes[] memory dynargs = new bytes[](2);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        return oraclize_query(timestamp, datasource, dynargs, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, bytes[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {&#13;
        bytes[] memory dynargs = new bytes[](2);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        return oraclize_query(datasource, dynargs, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, bytes[3] args) oraclizeAPI internal returns (bytes32 id) {&#13;
        bytes[] memory dynargs = new bytes[](3);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        return oraclize_query(datasource, dynargs);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, bytes[3] args) oraclizeAPI internal returns (bytes32 id) {&#13;
        bytes[] memory dynargs = new bytes[](3);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        return oraclize_query(timestamp, datasource, dynargs);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, bytes[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {&#13;
        bytes[] memory dynargs = new bytes[](3);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        return oraclize_query(timestamp, datasource, dynargs, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, bytes[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {&#13;
        bytes[] memory dynargs = new bytes[](3);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        return oraclize_query(datasource, dynargs, gaslimit);&#13;
    }&#13;
&#13;
    function oraclize_query(string datasource, bytes[4] args) oraclizeAPI internal returns (bytes32 id) {&#13;
        bytes[] memory dynargs = new bytes[](4);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        dynargs[3] = args[3];&#13;
        return oraclize_query(datasource, dynargs);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, bytes[4] args) oraclizeAPI internal returns (bytes32 id) {&#13;
        bytes[] memory dynargs = new bytes[](4);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        dynargs[3] = args[3];&#13;
        return oraclize_query(timestamp, datasource, dynargs);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, bytes[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {&#13;
        bytes[] memory dynargs = new bytes[](4);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        dynargs[3] = args[3];&#13;
        return oraclize_query(timestamp, datasource, dynargs, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, bytes[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {&#13;
        bytes[] memory dynargs = new bytes[](4);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        dynargs[3] = args[3];&#13;
        return oraclize_query(datasource, dynargs, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, bytes[5] args) oraclizeAPI internal returns (bytes32 id) {&#13;
        bytes[] memory dynargs = new bytes[](5);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        dynargs[3] = args[3];&#13;
        dynargs[4] = args[4];&#13;
        return oraclize_query(datasource, dynargs);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, bytes[5] args) oraclizeAPI internal returns (bytes32 id) {&#13;
        bytes[] memory dynargs = new bytes[](5);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        dynargs[3] = args[3];&#13;
        dynargs[4] = args[4];&#13;
        return oraclize_query(timestamp, datasource, dynargs);&#13;
    }&#13;
    function oraclize_query(uint timestamp, string datasource, bytes[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {&#13;
        bytes[] memory dynargs = new bytes[](5);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        dynargs[3] = args[3];&#13;
        dynargs[4] = args[4];&#13;
        return oraclize_query(timestamp, datasource, dynargs, gaslimit);&#13;
    }&#13;
    function oraclize_query(string datasource, bytes[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {&#13;
        bytes[] memory dynargs = new bytes[](5);&#13;
        dynargs[0] = args[0];&#13;
        dynargs[1] = args[1];&#13;
        dynargs[2] = args[2];&#13;
        dynargs[3] = args[3];&#13;
        dynargs[4] = args[4];&#13;
        return oraclize_query(datasource, dynargs, gaslimit);&#13;
    }&#13;
&#13;
    function oraclize_cbAddress() oraclizeAPI internal returns (address){&#13;
        return oraclize.cbAddress();&#13;
    }&#13;
    function oraclize_setProof(byte proofP) oraclizeAPI internal {&#13;
        return oraclize.setProofType(proofP);&#13;
    }&#13;
    function oraclize_setCustomGasPrice(uint gasPrice) oraclizeAPI internal {&#13;
        return oraclize.setCustomGasPrice(gasPrice);&#13;
    }&#13;
&#13;
    function oraclize_randomDS_getSessionPubKeyHash() oraclizeAPI internal returns (bytes32){&#13;
        return oraclize.randomDS_getSessionPubKeyHash();&#13;
    }&#13;
&#13;
    function getCodeSize(address _addr) constant internal returns(uint _size) {&#13;
        assembly {&#13;
            _size := extcodesize(_addr)&#13;
        }&#13;
    }&#13;
&#13;
    function parseAddr(string _a) internal pure returns (address){&#13;
        bytes memory tmp = bytes(_a);&#13;
        uint160 iaddr = 0;&#13;
        uint160 b1;&#13;
        uint160 b2;&#13;
        for (uint i=2; i&lt;2+2*20; i+=2){&#13;
            iaddr *= 256;&#13;
            b1 = uint160(tmp[i]);&#13;
            b2 = uint160(tmp[i+1]);&#13;
            if ((b1 &gt;= 97)&amp;&amp;(b1 &lt;= 102)) b1 -= 87;&#13;
            else if ((b1 &gt;= 65)&amp;&amp;(b1 &lt;= 70)) b1 -= 55;&#13;
            else if ((b1 &gt;= 48)&amp;&amp;(b1 &lt;= 57)) b1 -= 48;&#13;
            if ((b2 &gt;= 97)&amp;&amp;(b2 &lt;= 102)) b2 -= 87;&#13;
            else if ((b2 &gt;= 65)&amp;&amp;(b2 &lt;= 70)) b2 -= 55;&#13;
            else if ((b2 &gt;= 48)&amp;&amp;(b2 &lt;= 57)) b2 -= 48;&#13;
            iaddr += (b1*16+b2);&#13;
        }&#13;
        return address(iaddr);&#13;
    }&#13;
&#13;
    function strCompare(string _a, string _b) internal pure returns (int) {&#13;
        bytes memory a = bytes(_a);&#13;
        bytes memory b = bytes(_b);&#13;
        uint minLength = a.length;&#13;
        if (b.length &lt; minLength) minLength = b.length;&#13;
        for (uint i = 0; i &lt; minLength; i ++)&#13;
            if (a[i] &lt; b[i])&#13;
                return -1;&#13;
            else if (a[i] &gt; b[i])&#13;
                return 1;&#13;
        if (a.length &lt; b.length)&#13;
            return -1;&#13;
        else if (a.length &gt; b.length)&#13;
            return 1;&#13;
        else&#13;
            return 0;&#13;
    }&#13;
&#13;
    function indexOf(string _haystack, string _needle) internal pure returns (int) {&#13;
        bytes memory h = bytes(_haystack);&#13;
        bytes memory n = bytes(_needle);&#13;
        if(h.length &lt; 1 || n.length &lt; 1 || (n.length &gt; h.length))&#13;
            return -1;&#13;
        else if(h.length &gt; (2**128 -1))&#13;
            return -1;&#13;
        else&#13;
        {&#13;
            uint subindex = 0;&#13;
            for (uint i = 0; i &lt; h.length; i ++)&#13;
            {&#13;
                if (h[i] == n[0])&#13;
                {&#13;
                    subindex = 1;&#13;
                    while(subindex &lt; n.length &amp;&amp; (i + subindex) &lt; h.length &amp;&amp; h[i + subindex] == n[subindex])&#13;
                    {&#13;
                        subindex++;&#13;
                    }&#13;
                    if(subindex == n.length)&#13;
                        return int(i);&#13;
                }&#13;
            }&#13;
            return -1;&#13;
        }&#13;
    }&#13;
&#13;
    function strConcat(string _a, string _b, string _c, string _d, string _e) internal pure returns (string) {&#13;
        bytes memory _ba = bytes(_a);&#13;
        bytes memory _bb = bytes(_b);&#13;
        bytes memory _bc = bytes(_c);&#13;
        bytes memory _bd = bytes(_d);&#13;
        bytes memory _be = bytes(_e);&#13;
        string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);&#13;
        bytes memory babcde = bytes(abcde);&#13;
        uint k = 0;&#13;
        for (uint i = 0; i &lt; _ba.length; i++) babcde[k++] = _ba[i];&#13;
        for (i = 0; i &lt; _bb.length; i++) babcde[k++] = _bb[i];&#13;
        for (i = 0; i &lt; _bc.length; i++) babcde[k++] = _bc[i];&#13;
        for (i = 0; i &lt; _bd.length; i++) babcde[k++] = _bd[i];&#13;
        for (i = 0; i &lt; _be.length; i++) babcde[k++] = _be[i];&#13;
        return string(babcde);&#13;
    }&#13;
&#13;
    function strConcat(string _a, string _b, string _c, string _d) internal pure returns (string) {&#13;
        return strConcat(_a, _b, _c, _d, "");&#13;
    }&#13;
&#13;
    function strConcat(string _a, string _b, string _c) internal pure returns (string) {&#13;
        return strConcat(_a, _b, _c, "", "");&#13;
    }&#13;
&#13;
    function strConcat(string _a, string _b) internal pure returns (string) {&#13;
        return strConcat(_a, _b, "", "", "");&#13;
    }&#13;
&#13;
    // parseInt&#13;
    function parseInt(string _a) internal pure returns (uint) {&#13;
        return parseInt(_a, 0);&#13;
    }&#13;
&#13;
    // parseInt(parseFloat*10^_b)&#13;
    function parseInt(string _a, uint _b) internal pure returns (uint) {&#13;
        bytes memory bresult = bytes(_a);&#13;
        uint mint = 0;&#13;
        bool decimals = false;&#13;
        for (uint i=0; i&lt;bresult.length; i++){&#13;
            if ((bresult[i] &gt;= 48)&amp;&amp;(bresult[i] &lt;= 57)){&#13;
                if (decimals){&#13;
                   if (_b == 0) break;&#13;
                    else _b--;&#13;
                }&#13;
                mint *= 10;&#13;
                mint += uint(bresult[i]) - 48;&#13;
            } else if (bresult[i] == 46) decimals = true;&#13;
        }&#13;
        if (_b &gt; 0) mint *= 10**_b;&#13;
        return mint;&#13;
    }&#13;
&#13;
    function uint2str(uint i) internal pure returns (string){&#13;
        if (i == 0) return "0";&#13;
        uint j = i;&#13;
        uint len;&#13;
        while (j != 0){&#13;
            len++;&#13;
            j /= 10;&#13;
        }&#13;
        bytes memory bstr = new bytes(len);&#13;
        uint k = len - 1;&#13;
        while (i != 0){&#13;
            bstr[k--] = byte(48 + i % 10);&#13;
            i /= 10;&#13;
        }&#13;
        return string(bstr);&#13;
    }&#13;
&#13;
    function stra2cbor(string[] arr) internal pure returns (bytes) {&#13;
            uint arrlen = arr.length;&#13;
&#13;
            // get correct cbor output length&#13;
            uint outputlen = 0;&#13;
            bytes[] memory elemArray = new bytes[](arrlen);&#13;
            for (uint i = 0; i &lt; arrlen; i++) {&#13;
                elemArray[i] = (bytes(arr[i]));&#13;
                outputlen += elemArray[i].length + (elemArray[i].length - 1)/23 + 3; //+3 accounts for paired identifier types&#13;
            }&#13;
            uint ctr = 0;&#13;
            uint cborlen = arrlen + 0x80;&#13;
            outputlen += byte(cborlen).length;&#13;
            bytes memory res = new bytes(outputlen);&#13;
&#13;
            while (byte(cborlen).length &gt; ctr) {&#13;
                res[ctr] = byte(cborlen)[ctr];&#13;
                ctr++;&#13;
            }&#13;
            for (i = 0; i &lt; arrlen; i++) {&#13;
                res[ctr] = 0x5F;&#13;
                ctr++;&#13;
                for (uint x = 0; x &lt; elemArray[i].length; x++) {&#13;
                    // if there's a bug with larger strings, this may be the culprit&#13;
                    if (x % 23 == 0) {&#13;
                        uint elemcborlen = elemArray[i].length - x &gt;= 24 ? 23 : elemArray[i].length - x;&#13;
                        elemcborlen += 0x40;&#13;
                        uint lctr = ctr;&#13;
                        while (byte(elemcborlen).length &gt; ctr - lctr) {&#13;
                            res[ctr] = byte(elemcborlen)[ctr - lctr];&#13;
                            ctr++;&#13;
                        }&#13;
                    }&#13;
                    res[ctr] = elemArray[i][x];&#13;
                    ctr++;&#13;
                }&#13;
                res[ctr] = 0xFF;&#13;
                ctr++;&#13;
            }&#13;
            return res;&#13;
        }&#13;
&#13;
    function ba2cbor(bytes[] arr) internal pure returns (bytes) {&#13;
            uint arrlen = arr.length;&#13;
&#13;
            // get correct cbor output length&#13;
            uint outputlen = 0;&#13;
            bytes[] memory elemArray = new bytes[](arrlen);&#13;
            for (uint i = 0; i &lt; arrlen; i++) {&#13;
                elemArray[i] = (bytes(arr[i]));&#13;
                outputlen += elemArray[i].length + (elemArray[i].length - 1)/23 + 3; //+3 accounts for paired identifier types&#13;
            }&#13;
            uint ctr = 0;&#13;
            uint cborlen = arrlen + 0x80;&#13;
            outputlen += byte(cborlen).length;&#13;
            bytes memory res = new bytes(outputlen);&#13;
&#13;
            while (byte(cborlen).length &gt; ctr) {&#13;
                res[ctr] = byte(cborlen)[ctr];&#13;
                ctr++;&#13;
            }&#13;
            for (i = 0; i &lt; arrlen; i++) {&#13;
                res[ctr] = 0x5F;&#13;
                ctr++;&#13;
                for (uint x = 0; x &lt; elemArray[i].length; x++) {&#13;
                    // if there's a bug with larger strings, this may be the culprit&#13;
                    if (x % 23 == 0) {&#13;
                        uint elemcborlen = elemArray[i].length - x &gt;= 24 ? 23 : elemArray[i].length - x;&#13;
                        elemcborlen += 0x40;&#13;
                        uint lctr = ctr;&#13;
                        while (byte(elemcborlen).length &gt; ctr - lctr) {&#13;
                            res[ctr] = byte(elemcborlen)[ctr - lctr];&#13;
                            ctr++;&#13;
                        }&#13;
                    }&#13;
                    res[ctr] = elemArray[i][x];&#13;
                    ctr++;&#13;
                }&#13;
                res[ctr] = 0xFF;&#13;
                ctr++;&#13;
            }&#13;
            return res;&#13;
        }&#13;
&#13;
&#13;
    string oraclize_network_name;&#13;
    function oraclize_setNetworkName(string _network_name) internal {&#13;
        oraclize_network_name = _network_name;&#13;
    }&#13;
&#13;
    function oraclize_getNetworkName() internal view returns (string) {&#13;
        return oraclize_network_name;&#13;
    }&#13;
&#13;
    function oraclize_newRandomDSQuery(uint _delay, uint _nbytes, uint _customGasLimit) internal returns (bytes32){&#13;
        require((_nbytes &gt; 0) &amp;&amp; (_nbytes &lt;= 32));&#13;
        bytes memory nbytes = new bytes(1);&#13;
        nbytes[0] = byte(_nbytes);&#13;
        bytes memory unonce = new bytes(32);&#13;
        bytes memory sessionKeyHash = new bytes(32);&#13;
        bytes32 sessionKeyHash_bytes32 = oraclize_randomDS_getSessionPubKeyHash();&#13;
        assembly {&#13;
            mstore(unonce, 0x20)&#13;
            mstore(add(unonce, 0x20), xor(blockhash(sub(number, 1)), xor(coinbase, timestamp)))&#13;
            mstore(sessionKeyHash, 0x20)&#13;
            mstore(add(sessionKeyHash, 0x20), sessionKeyHash_bytes32)&#13;
        }&#13;
        bytes[3] memory args = [unonce, nbytes, sessionKeyHash];&#13;
        bytes32 queryId = oraclize_query(_delay, "random", args, _customGasLimit);&#13;
        oraclize_randomDS_setCommitment(queryId, keccak256(bytes8(_delay), args[1], sha256(args[0]), args[2]));&#13;
        return queryId;&#13;
    }&#13;
&#13;
    function oraclize_randomDS_setCommitment(bytes32 queryId, bytes32 commitment) internal {&#13;
        oraclize_randomDS_args[queryId] = commitment;&#13;
    }&#13;
&#13;
    mapping(bytes32=&gt;bytes32) oraclize_randomDS_args;&#13;
    mapping(bytes32=&gt;bool) oraclize_randomDS_sessionKeysHashVerified;&#13;
&#13;
    function verifySig(bytes32 tosignh, bytes dersig, bytes pubkey) internal returns (bool){&#13;
        bool sigok;&#13;
        address signer;&#13;
&#13;
        bytes32 sigr;&#13;
        bytes32 sigs;&#13;
&#13;
        bytes memory sigr_ = new bytes(32);&#13;
        uint offset = 4+(uint(dersig[3]) - 0x20);&#13;
        sigr_ = copyBytes(dersig, offset, 32, sigr_, 0);&#13;
        bytes memory sigs_ = new bytes(32);&#13;
        offset += 32 + 2;&#13;
        sigs_ = copyBytes(dersig, offset+(uint(dersig[offset-1]) - 0x20), 32, sigs_, 0);&#13;
&#13;
        assembly {&#13;
            sigr := mload(add(sigr_, 32))&#13;
            sigs := mload(add(sigs_, 32))&#13;
        }&#13;
&#13;
&#13;
        (sigok, signer) = safer_ecrecover(tosignh, 27, sigr, sigs);&#13;
        if (address(keccak256(pubkey)) == signer) return true;&#13;
        else {&#13;
            (sigok, signer) = safer_ecrecover(tosignh, 28, sigr, sigs);&#13;
            return (address(keccak256(pubkey)) == signer);&#13;
        }&#13;
    }&#13;
&#13;
    function oraclize_randomDS_proofVerify__sessionKeyValidity(bytes proof, uint sig2offset) internal returns (bool) {&#13;
        bool sigok;&#13;
&#13;
        // Step 6: verify the attestation signature, APPKEY1 must sign the sessionKey from the correct ledger app (CODEHASH)&#13;
        bytes memory sig2 = new bytes(uint(proof[sig2offset+1])+2);&#13;
        copyBytes(proof, sig2offset, sig2.length, sig2, 0);&#13;
&#13;
        bytes memory appkey1_pubkey = new bytes(64);&#13;
        copyBytes(proof, 3+1, 64, appkey1_pubkey, 0);&#13;
&#13;
        bytes memory tosign2 = new bytes(1+65+32);&#13;
        tosign2[0] = byte(1); //role&#13;
        copyBytes(proof, sig2offset-65, 65, tosign2, 1);&#13;
        bytes memory CODEHASH = hex"fd94fa71bc0ba10d39d464d0d8f465efeef0a2764e3887fcc9df41ded20f505c";&#13;
        copyBytes(CODEHASH, 0, 32, tosign2, 1+65);&#13;
        sigok = verifySig(sha256(tosign2), sig2, appkey1_pubkey);&#13;
&#13;
        if (sigok == false) return false;&#13;
&#13;
&#13;
        // Step 7: verify the APPKEY1 provenance (must be signed by Ledger)&#13;
        bytes memory LEDGERKEY = hex"7fb956469c5c9b89840d55b43537e66a98dd4811ea0a27224272c2e5622911e8537a2f8e86a46baec82864e98dd01e9ccc2f8bc5dfc9cbe5a91a290498dd96e4";&#13;
&#13;
        bytes memory tosign3 = new bytes(1+65);&#13;
        tosign3[0] = 0xFE;&#13;
        copyBytes(proof, 3, 65, tosign3, 1);&#13;
&#13;
        bytes memory sig3 = new bytes(uint(proof[3+65+1])+2);&#13;
        copyBytes(proof, 3+65, sig3.length, sig3, 0);&#13;
&#13;
        sigok = verifySig(sha256(tosign3), sig3, LEDGERKEY);&#13;
&#13;
        return sigok;&#13;
    }&#13;
&#13;
    modifier oraclize_randomDS_proofVerify(bytes32 _queryId, string _result, bytes _proof) {&#13;
        // Step 1: the prefix has to match 'LP\x01' (Ledger Proof version 1)&#13;
        require((_proof[0] == "L") &amp;&amp; (_proof[1] == "P") &amp;&amp; (_proof[2] == 1));&#13;
&#13;
        bool proofVerified = oraclize_randomDS_proofVerify__main(_proof, _queryId, bytes(_result), oraclize_getNetworkName());&#13;
        require(proofVerified);&#13;
&#13;
        _;&#13;
    }&#13;
&#13;
    function oraclize_randomDS_proofVerify__returnCode(bytes32 _queryId, string _result, bytes _proof) internal returns (uint8){&#13;
        // Step 1: the prefix has to match 'LP\x01' (Ledger Proof version 1)&#13;
        if ((_proof[0] != "L")||(_proof[1] != "P")||(_proof[2] != 1)) return 1;&#13;
&#13;
        bool proofVerified = oraclize_randomDS_proofVerify__main(_proof, _queryId, bytes(_result), oraclize_getNetworkName());&#13;
        if (proofVerified == false) return 2;&#13;
&#13;
        return 0;&#13;
    }&#13;
&#13;
    function matchBytes32Prefix(bytes32 content, bytes prefix, uint n_random_bytes) internal pure returns (bool){&#13;
        bool match_ = true;&#13;
&#13;
&#13;
        for (uint256 i=0; i&lt; n_random_bytes; i++) {&#13;
            if (content[i] != prefix[i]) match_ = false;&#13;
        }&#13;
&#13;
        return match_;&#13;
    }&#13;
&#13;
    function oraclize_randomDS_proofVerify__main(bytes proof, bytes32 queryId, bytes result, string context_name) internal returns (bool){&#13;
&#13;
        // Step 2: the unique keyhash has to match with the sha256 of (context name + queryId)&#13;
        uint ledgerProofLength = 3+65+(uint(proof[3+65+1])+2)+32;&#13;
        bytes memory keyhash = new bytes(32);&#13;
        copyBytes(proof, ledgerProofLength, 32, keyhash, 0);&#13;
        if (!(keccak256(keyhash) == keccak256(sha256(context_name, queryId)))) return false;&#13;
&#13;
        bytes memory sig1 = new bytes(uint(proof[ledgerProofLength+(32+8+1+32)+1])+2);&#13;
        copyBytes(proof, ledgerProofLength+(32+8+1+32), sig1.length, sig1, 0);&#13;
&#13;
        // Step 3: we assume sig1 is valid (it will be verified during step 5) and we verify if 'result' is the prefix of sha256(sig1)&#13;
        if (!matchBytes32Prefix(sha256(sig1), result, uint(proof[ledgerProofLength+32+8]))) return false;&#13;
&#13;
        // Step 4: commitment match verification, keccak256(delay, nbytes, unonce, sessionKeyHash) == commitment in storage.&#13;
        // This is to verify that the computed args match with the ones specified in the query.&#13;
        bytes memory commitmentSlice1 = new bytes(8+1+32);&#13;
        copyBytes(proof, ledgerProofLength+32, 8+1+32, commitmentSlice1, 0);&#13;
&#13;
        bytes memory sessionPubkey = new bytes(64);&#13;
        uint sig2offset = ledgerProofLength+32+(8+1+32)+sig1.length+65;&#13;
        copyBytes(proof, sig2offset-64, 64, sessionPubkey, 0);&#13;
&#13;
        bytes32 sessionPubkeyHash = sha256(sessionPubkey);&#13;
        if (oraclize_randomDS_args[queryId] == keccak256(commitmentSlice1, sessionPubkeyHash)){ //unonce, nbytes and sessionKeyHash match&#13;
            delete oraclize_randomDS_args[queryId];&#13;
        } else return false;&#13;
&#13;
&#13;
        // Step 5: validity verification for sig1 (keyhash and args signed with the sessionKey)&#13;
        bytes memory tosign1 = new bytes(32+8+1+32);&#13;
        copyBytes(proof, ledgerProofLength, 32+8+1+32, tosign1, 0);&#13;
        if (!verifySig(sha256(tosign1), sig1, sessionPubkey)) return false;&#13;
&#13;
        // verify if sessionPubkeyHash was verified already, if not.. let's do it!&#13;
        if (oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash] == false){&#13;
            oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash] = oraclize_randomDS_proofVerify__sessionKeyValidity(proof, sig2offset);&#13;
        }&#13;
&#13;
        return oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash];&#13;
    }&#13;
&#13;
    // the following function has been written by Alex Beregszaszi (@axic), use it under the terms of the MIT license&#13;
    function copyBytes(bytes from, uint fromOffset, uint length, bytes to, uint toOffset) internal pure returns (bytes) {&#13;
        uint minLength = length + toOffset;&#13;
&#13;
        // Buffer too small&#13;
        require(to.length &gt;= minLength); // Should be a better way?&#13;
&#13;
        // NOTE: the offset 32 is added to skip the `size` field of both bytes variables&#13;
        uint i = 32 + fromOffset;&#13;
        uint j = 32 + toOffset;&#13;
&#13;
        while (i &lt; (32 + fromOffset + length)) {&#13;
            assembly {&#13;
                let tmp := mload(add(from, i))&#13;
                mstore(add(to, j), tmp)&#13;
            }&#13;
            i += 32;&#13;
            j += 32;&#13;
        }&#13;
&#13;
        return to;&#13;
    }&#13;
&#13;
    // the following function has been written by Alex Beregszaszi (@axic), use it under the terms of the MIT license&#13;
    // Duplicate Solidity's ecrecover, but catching the CALL return value&#13;
    function safer_ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal returns (bool, address) {&#13;
        // We do our own memory management here. Solidity uses memory offset&#13;
        // 0x40 to store the current end of memory. We write past it (as&#13;
        // writes are memory extensions), but don't update the offset so&#13;
        // Solidity will reuse it. The memory used here is only needed for&#13;
        // this context.&#13;
&#13;
        // FIXME: inline assembly can't access return values&#13;
        bool ret;&#13;
        address addr;&#13;
&#13;
        assembly {&#13;
            let size := mload(0x40)&#13;
            mstore(size, hash)&#13;
            mstore(add(size, 32), v)&#13;
            mstore(add(size, 64), r)&#13;
            mstore(add(size, 96), s)&#13;
&#13;
            // NOTE: we can reuse the request memory because we deal with&#13;
            //       the return code&#13;
            ret := call(3000, 1, 0, size, 128, size, 32)&#13;
            addr := mload(size)&#13;
        }&#13;
&#13;
        return (ret, addr);&#13;
    }&#13;
&#13;
    // the following function has been written by Alex Beregszaszi (@axic), use it under the terms of the MIT license&#13;
    function ecrecovery(bytes32 hash, bytes sig) internal returns (bool, address) {&#13;
        bytes32 r;&#13;
        bytes32 s;&#13;
        uint8 v;&#13;
&#13;
        if (sig.length != 65)&#13;
          return (false, 0);&#13;
&#13;
        // The signature format is a compact form of:&#13;
        //   {bytes32 r}{bytes32 s}{uint8 v}&#13;
        // Compact means, uint8 is not padded to 32 bytes.&#13;
        assembly {&#13;
            r := mload(add(sig, 32))&#13;
            s := mload(add(sig, 64))&#13;
&#13;
            // Here we are loading the last 32 bytes. We exploit the fact that&#13;
            // 'mload' will pad with zeroes if we overread.&#13;
            // There is no 'mload8' to do this, but that would be nicer.&#13;
            v := byte(0, mload(add(sig, 96)))&#13;
&#13;
            // Alternative solution:&#13;
            // 'byte' is not working due to the Solidity parser, so lets&#13;
            // use the second best option, 'and'&#13;
            // v := and(mload(add(sig, 65)), 255)&#13;
        }&#13;
&#13;
        // albeit non-transactional signatures are not specified by the YP, one would expect it&#13;
        // to match the YP range of [27, 28]&#13;
        //&#13;
        // geth uses [0, 1] and some clients have followed. This might change, see:&#13;
        //  https://github.com/ethereum/go-ethereum/issues/2053&#13;
        if (v &lt; 27)&#13;
          v += 27;&#13;
&#13;
        if (v != 27 &amp;&amp; v != 28)&#13;
            return (false, 0);&#13;
&#13;
        return safer_ecrecover(hash, v, r, s);&#13;
    }&#13;
&#13;
}&#13;
// &lt;/ORACLIZE_API&gt;&#13;
&#13;
&#13;
&#13;
/**&#13;
 * @title BetexICO&#13;
 */&#13;
contract BetexICO is usingOraclize, HasNoContracts {&#13;
    using SafeMath for uint256;&#13;
    using SafeERC20 for ERC20;&#13;
&#13;
    // Betex token&#13;
    BetexToken public token;&#13;
&#13;
    // Betex storage&#13;
    BetexStorage public betexStorage;&#13;
&#13;
    // ico start timestamp&#13;
    uint256 public startTime;&#13;
&#13;
    // bonus change timestamp  &#13;
    uint256 public bonusChangeTime;&#13;
&#13;
    // ico end timestamp&#13;
    uint256 public endTime;&#13;
&#13;
    // wallet address to trasfer funding to&#13;
    address public wallet;&#13;
&#13;
    // tokens sold&#13;
    uint256 public sold;&#13;
&#13;
    // wei raised&#13;
    uint256 public raised;&#13;
&#13;
    // unsold tokens amount&#13;
    uint256 public unsoldTokensAmount;&#13;
&#13;
    // how many tokens are sold before unsold allocation started&#13;
    uint256 public soldBeforeUnsoldAllocation;&#13;
&#13;
    // counter for funders, who got unsold tokens allocated&#13;
    uint256 public unsoldAllocationCount;&#13;
&#13;
    // are preICO tokens allocated&#13;
    bool public preICOTokensAllocated;&#13;
&#13;
    // is unsold tokens allocation scheduled&#13;
    bool public unsoldAllocatonScheduled;&#13;
&#13;
    // eth/usd rate url&#13;
    string public ethRateURL = "json(https://api.coinmarketcap.com/v1/ticker/ethereum/).0.price_usd";&#13;
&#13;
    // oraclize gas limit&#13;
    uint256 public oraclizeGasLimit = 200000;&#13;
&#13;
    // unsold tokens allocation oraclize gas limit&#13;
    uint256 public unsoldAllocationOraclizeGasLimit = 2500000;&#13;
&#13;
    // three hours delay (from the ico end time) for unsold tokens allocation&#13;
    uint256 public unsoldAllocationDelay = 10800;&#13;
&#13;
    // addresses authorized to refill the contract (for oraclize queries)&#13;
    mapping (address =&gt; bool) public refillers;&#13;
&#13;
    // minimum funding amount&#13;
    uint256 public constant MIN_FUNDING_AMOUNT = 0.5 ether;&#13;
&#13;
    // rate exponent&#13;
    uint256 public constant RATE_EXPONENT = 4;&#13;
&#13;
    // token price, usd&#13;
    uint256 public constant TOKEN_PRICE = 3;&#13;
&#13;
    // size of unsold tokens allocation bunch&#13;
    uint256 public constant UNSOLD_ALLOCATION_SIZE = 50; &#13;
&#13;
    // unsold allocation exponent&#13;
    uint256 public constant UNSOLD_ALLOCATION_EXPONENT = 10;&#13;
&#13;
    /**&#13;
     * event for add to whitelist logging&#13;
     * @param funder funder address&#13;
     */&#13;
    event WhitelistAddEvent(address indexed funder);&#13;
&#13;
    /**&#13;
     * event for funding order logging&#13;
     * @param funder funder who has done the order&#13;
     * @param orderId oraclize orderId&#13;
     * @param funds paid wei amount&#13;
     */&#13;
    event OrderEvent(address indexed funder, bytes32 indexed orderId, uint256 funds);&#13;
&#13;
    /**&#13;
     * event for token purchase logging&#13;
     * @param funder funder who paid for the tokens&#13;
     * @param orderId oraclize orderId&#13;
     * @param tokens amount of tokens purchased&#13;
     */&#13;
    event TokenPurchaseEvent(address indexed funder, bytes32 indexed orderId, uint256 tokens);&#13;
&#13;
    /**&#13;
     * event for unsold tokens allocation logging&#13;
     * @param funder funder token holders&#13;
     * @param tokens amount of tokens purchased&#13;
     */&#13;
    event UnsoldTokensAllocationEvent(address indexed funder, uint256 tokens);&#13;
&#13;
&#13;
    /**&#13;
     * @dev Constructor&#13;
     * @param _startTime start time timestamp&#13;
     * @param _bonusChangeTime bonus change timestamp&#13;
     * @param _endTime end time timestamp&#13;
     * @param _wallet wallet address to transfer funding to&#13;
     * @param _token Betex token address&#13;
     * @param _betexStorage BetexStorage contract address&#13;
     */&#13;
    function BetexICO (&#13;
        uint256 _startTime,&#13;
        uint256 _bonusChangeTime,&#13;
        uint256 _endTime,&#13;
        address _wallet, &#13;
        address _token,&#13;
        address _betexStorage&#13;
    ) &#13;
        public &#13;
        payable&#13;
    {&#13;
        require(_startTime &lt; _endTime);&#13;
        require(_bonusChangeTime &gt; _startTime &amp;&amp; _bonusChangeTime &lt; _endTime);&#13;
&#13;
        require(_wallet != address(0));&#13;
        require(_token != address(0));&#13;
        require(_betexStorage != address(0));&#13;
&#13;
        startTime = _startTime;&#13;
        bonusChangeTime = _bonusChangeTime;&#13;
        endTime = _endTime;&#13;
        wallet = _wallet;&#13;
&#13;
        token = BetexToken(_token);&#13;
        betexStorage = BetexStorage(_betexStorage);&#13;
    }&#13;
&#13;
    // fallback function, used to buy tokens and refill the contract for oraclize&#13;
    function () public payable {&#13;
        address _sender = msg.sender;&#13;
        uint256 _funds = msg.value;&#13;
&#13;
        if (betexStorage.isWhitelisted(_sender)) {&#13;
            buyTokens(_sender, _funds);&#13;
        } else if (!refillers[_sender] &amp;&amp; !(owner == _sender)) {&#13;
            revert();&#13;
        }&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Get current rate from oraclize and transfer tokens or start unsold tokens allocation&#13;
     * @param _orderId oraclize order id&#13;
     * @param _result current eth/usd rate&#13;
     */&#13;
    function __callback(bytes32 _orderId, string _result) public {  // solium-disable-line mixedcase&#13;
        require(msg.sender == oraclize_cbAddress());&#13;
&#13;
        // check if it's an order for aftersale token allocation&#13;
        if (betexStorage.unsoldAllocationOrders(_orderId)) {&#13;
            if (!allUnsoldTokensAllocated()) {&#13;
                allocateUnsoldTokens();&#13;
                if (!allUnsoldTokensAllocated()) {&#13;
                    bytes32 orderId = oraclize_query("URL", ethRateURL, unsoldAllocationOraclizeGasLimit);&#13;
                    betexStorage.addUnsoldAllocationOrder(orderId);&#13;
                }&#13;
            }&#13;
        } else {&#13;
            uint256 _rate = parseInt(_result, RATE_EXPONENT);&#13;
&#13;
            address _beneficiary;&#13;
            uint256 _funds;&#13;
            uint256 _bonus;&#13;
&#13;
            (_beneficiary, _funds, _bonus) = betexStorage.getOrder(_orderId);&#13;
&#13;
            uint256 _sum = _funds.mul(_rate).div(10 ** RATE_EXPONENT);&#13;
            uint256 _tokens = _sum.div(TOKEN_PRICE);&#13;
&#13;
            uint256 _bonusTokens = _tokens.mul(_bonus).div(100);&#13;
            _tokens = _tokens.add(_bonusTokens);&#13;
&#13;
            if (sold.add(_tokens) &gt; token.SALE_SUPPLY()) {&#13;
                _tokens = token.SALE_SUPPLY().sub(sold);&#13;
            }&#13;
&#13;
            betexStorage.setRateForOrder(_orderId, _rate);&#13;
&#13;
            token.transfer(_beneficiary, _tokens);&#13;
            sold = sold.add(_tokens);&#13;
            emit TokenPurchaseEvent(_beneficiary, _orderId, _tokens);&#13;
        }&#13;
    }&#13;
&#13;
    // schedule unsold tokens allocation using oraclize&#13;
    function scheduleUnsoldAllocation() public {&#13;
        require(!unsoldAllocatonScheduled);&#13;
&#13;
        // query for unsold tokens allocation with delay from the ico end time&#13;
        bytes32 _orderId = oraclize_query(endTime.add(unsoldAllocationDelay), "URL", ethRateURL, unsoldAllocationOraclizeGasLimit); // solium-disable-line arg-overflow&#13;
        betexStorage.addUnsoldAllocationOrder(_orderId); &#13;
&#13;
        unsoldAllocatonScheduled = true;&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Allocate unsold tokens (for bunch of funders)&#13;
     */&#13;
    function allocateUnsoldTokens() public {&#13;
        require(now &gt; endTime.add(unsoldAllocationDelay)); // solium-disable-line security/no-block-members&#13;
        require(!allUnsoldTokensAllocated());&#13;
&#13;
        // save unsold and sold amounts&#13;
        if (unsoldAllocationCount == 0) {&#13;
            unsoldTokensAmount = token.SALE_SUPPLY().sub(sold);&#13;
            soldBeforeUnsoldAllocation = sold;&#13;
        }&#13;
&#13;
        for (uint256 i = 0; i &lt; UNSOLD_ALLOCATION_SIZE &amp;&amp; !allUnsoldTokensAllocated(); i = i.add(1)) {&#13;
            address _funder = betexStorage.funders(unsoldAllocationCount);&#13;
            uint256 _funderTokens = token.balanceOf(_funder);&#13;
&#13;
            if (_funderTokens != 0) {&#13;
                uint256 _share = _funderTokens.mul(10 ** UNSOLD_ALLOCATION_EXPONENT).div(soldBeforeUnsoldAllocation);&#13;
                uint256 _tokensToAllocate = unsoldTokensAmount.mul(_share).div(10 ** UNSOLD_ALLOCATION_EXPONENT);&#13;
&#13;
                token.transfer(_funder, _tokensToAllocate); &#13;
                emit UnsoldTokensAllocationEvent(_funder, _tokensToAllocate);&#13;
                sold = sold.add(_tokensToAllocate);&#13;
            }&#13;
&#13;
            unsoldAllocationCount = unsoldAllocationCount.add(1);&#13;
        }&#13;
&#13;
        if (allUnsoldTokensAllocated()) {&#13;
            if (sold &lt; token.SALE_SUPPLY()) {&#13;
                uint256 _change = token.SALE_SUPPLY().sub(sold);&#13;
                address _reserveAddress = token.RESERVE_ADDRESS();&#13;
                token.transfer(_reserveAddress, _change);&#13;
                sold = sold.add(_change);&#13;
            }&#13;
        }           &#13;
    }&#13;
&#13;
    // allocate preICO tokens&#13;
    function allocatePreICOTokens() public {&#13;
        require(!preICOTokensAllocated);&#13;
&#13;
        for (uint256 i = 0; i &lt; betexStorage.getPreICOFundersCount(); i++) {&#13;
            address _funder = betexStorage.preICOFunders(i);&#13;
            uint256 _tokens = betexStorage.preICOBalances(_funder);&#13;
&#13;
            token.transfer(_funder, _tokens);&#13;
            sold = sold.add(_tokens);&#13;
&#13;
            betexStorage.addFunder(_funder);&#13;
        }&#13;
        &#13;
        preICOTokensAllocated = true;&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Whitelist funder's address&#13;
     * @param _funder funder's address&#13;
     */&#13;
    function addToWhitelist(address _funder) onlyOwner public {&#13;
        require(_funder != address(0));&#13;
        betexStorage.addToWhitelist(_funder);&#13;
&#13;
        emit WhitelistAddEvent(_funder);&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Set oraclize gas limit&#13;
     * @param _gasLimit a new oraclize gas limit&#13;
     */&#13;
    function setOraclizeGasLimit(uint256 _gasLimit) onlyOwner public {&#13;
        require(_gasLimit &gt; 0);&#13;
        oraclizeGasLimit = _gasLimit;&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Set oraclize gas price&#13;
     * @param _gasPrice a new oraclize gas price&#13;
     */&#13;
    function setOraclizeGasPrice(uint256 _gasPrice) onlyOwner public {&#13;
        require(_gasPrice &gt; 0);&#13;
        oraclize_setCustomGasPrice(_gasPrice);&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Add a refiller&#13;
     * @param _refiller address that authorized to refill the contract&#13;
     */&#13;
    function addRefiller(address _refiller) onlyOwner public {&#13;
        require(_refiller != address(0));&#13;
        refillers[_refiller] = true;&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Withdraw ether from contract&#13;
     * @param _amount amount to withdraw&#13;
     */&#13;
    function withdrawEther(uint256 _amount) onlyOwner public {&#13;
        require(address(this).balance &gt;= _amount);&#13;
        owner.transfer(_amount);&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Makes order for tokens purchase&#13;
     * @param _funder funder who paid for the tokens&#13;
     * @param _funds amount of the funds&#13;
     */&#13;
    function buyTokens(address _funder, uint256 _funds) internal {&#13;
        require(liveBetexICO());&#13;
        require(_funds &gt;= MIN_FUNDING_AMOUNT);&#13;
        require(oraclize_getPrice("URL") &lt;= address(this).balance);&#13;
        &#13;
        bytes32 _orderId = oraclize_query("URL", ethRateURL, oraclizeGasLimit);&#13;
        uint256 _bonus = betexStorage.getBonus(_funds, bonusChangeTime);&#13;
        betexStorage.addOrder(_orderId, _funder, _funds, _bonus); // solium-disable-line arg-overflow&#13;
&#13;
        wallet.transfer(_funds);&#13;
        raised = raised.add(_funds);&#13;
&#13;
        betexStorage.addFunder(_funder);&#13;
&#13;
        emit OrderEvent(_funder, _orderId, _funds);&#13;
    }&#13;
&#13;
    // @return true if all unsold tokens are allocated&#13;
    function allUnsoldTokensAllocated() internal view returns (bool) {&#13;
        return unsoldAllocationCount == betexStorage.getFundersCount();&#13;
    }&#13;
&#13;
    // @return true if the ICO is alive&#13;
    function liveBetexICO() internal view returns (bool) {&#13;
        return now &gt;= startTime &amp;&amp; now &lt;= endTime &amp;&amp; sold &lt; token.SALE_SUPPLY(); // solium-disable-line security/no-block-members&#13;
    }&#13;
    &#13;
}