/*
 * Just Price Protocol Smart Contract.
 * Copyright © 2018 by ABDK Consulting.
 * Author: Mikhail Vladimirov <<span class="__cf_email__" data-cfemail="325f5b595a535b5e1c445e53565b5f5b405d4472555f535b5e1c515d5f">[email protected]</span>&gt;&#13;
 */&#13;
pragma solidity ^0.4.20;&#13;
&#13;
//import "./SafeMath.sol";&#13;
//import "./OrgonToken.sol";&#13;
//import "./OrisSpace.sol";&#13;
contract SafeMath {&#13;
  uint256 constant private MAX_UINT256 =&#13;
    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;&#13;
&#13;
  /**&#13;
   * Add two uint256 values, throw in case of overflow.&#13;
   *&#13;
   * @param x first value to add&#13;
   * @param y second value to add&#13;
   * @return x + y&#13;
   */&#13;
  function safeAdd (uint256 x, uint256 y)&#13;
  pure internal&#13;
  returns (uint256 z) {&#13;
    assert (x &lt;= MAX_UINT256 - y);&#13;
    return x + y;&#13;
  }&#13;
&#13;
  /**&#13;
   * Subtract one uint256 value from another, throw in case of underflow.&#13;
   *&#13;
   * @param x value to subtract from&#13;
   * @param y value to subtract&#13;
   * @return x - y&#13;
   */&#13;
  function safeSub (uint256 x, uint256 y)&#13;
  pure internal&#13;
  returns (uint256 z) {&#13;
    assert (x &gt;= y);&#13;
    return x - y;&#13;
  }&#13;
&#13;
  /**&#13;
   * Multiply two uint256 values, throw in case of overflow.&#13;
   *&#13;
   * @param x first value to multiply&#13;
   * @param y second value to multiply&#13;
   * @return x * y&#13;
   */&#13;
  function safeMul (uint256 x, uint256 y)&#13;
  pure internal&#13;
  returns (uint256 z) {&#13;
    if (y == 0) return 0; // Prevent division by zero at the next line&#13;
    assert (x &lt;= MAX_UINT256 / y);&#13;
    return x * y;&#13;
  }&#13;
}&#13;
&#13;
contract Token {&#13;
  /**&#13;
   * Get total number of tokens in circulation.&#13;
   *&#13;
   * @return total number of tokens in circulation&#13;
   */&#13;
  function totalSupply () public view returns (uint256 supply);&#13;
&#13;
  /**&#13;
   * Get number of tokens currently belonging to given owner.&#13;
   *&#13;
   * @param _owner address to get number of tokens currently belonging to the&#13;
   *        owner of&#13;
   * @return number of tokens currently belonging to the owner of given address&#13;
   */&#13;
  function balanceOf (address _owner) public view returns (uint256 balance);&#13;
&#13;
  /**&#13;
   * Transfer given number of tokens from message sender to given recipient.&#13;
   *&#13;
   * @param _to address to transfer tokens to the owner of&#13;
   * @param _value number of tokens to transfer to the owner of given address&#13;
   * @return true if tokens were transferred successfully, false otherwise&#13;
   */&#13;
  function transfer (address _to, uint256 _value)&#13;
  public returns (bool success);&#13;
&#13;
  /**&#13;
   * Transfer given number of tokens from given owner to given recipient.&#13;
   *&#13;
   * @param _from address to transfer tokens from the owner of&#13;
   * @param _to address to transfer tokens to the owner of&#13;
   * @param _value number of tokens to transfer from given owner to given&#13;
   *        recipient&#13;
   * @return true if tokens were transferred successfully, false otherwise&#13;
   */&#13;
  function transferFrom (address _from, address _to, uint256 _value)&#13;
  public returns (bool success);&#13;
&#13;
  /**&#13;
   * Allow given spender to transfer given number of tokens from message sender.&#13;
   *&#13;
   * @param _spender address to allow the owner of to transfer tokens from&#13;
   *        message sender&#13;
   * @param _value number of tokens to allow to transfer&#13;
   * @return true if token transfer was successfully approved, false otherwise&#13;
   */&#13;
  function approve (address _spender, uint256 _value)&#13;
  public returns (bool success);&#13;
&#13;
  /**&#13;
   * Tell how many tokens given spender is currently allowed to transfer from&#13;
   * given owner.&#13;
   *&#13;
   * @param _owner address to get number of tokens allowed to be transferred&#13;
   *        from the owner of&#13;
   * @param _spender address to get number of tokens allowed to be transferred&#13;
   *        by the owner of&#13;
   * @return number of tokens given spender is currently allowed to transfer&#13;
   *         from given owner&#13;
   */&#13;
  function allowance (address _owner, address _spender)&#13;
  public view returns (uint256 remaining);&#13;
&#13;
  /**&#13;
   * Logged when tokens were transferred from one owner to another.&#13;
   *&#13;
   * @param _from address of the owner, tokens were transferred from&#13;
   * @param _to address of the owner, tokens were transferred to&#13;
   * @param _value number of tokens transferred&#13;
   */&#13;
  event Transfer (address indexed _from, address indexed _to, uint256 _value);&#13;
&#13;
  /**&#13;
   * Logged when owner approved his tokens to be transferred by some spender.&#13;
   *&#13;
   * @param _owner owner who approved his tokens to be transferred&#13;
   * @param _spender spender who were allowed to transfer the tokens belonging&#13;
   *        to the owner&#13;
   * @param _value number of tokens belonging to the owner, approved to be&#13;
   *        transferred by the spender&#13;
   */&#13;
  event Approval (&#13;
    address indexed _owner, address indexed _spender, uint256 _value);&#13;
}&#13;
&#13;
contract OrisSpace {&#13;
  /**&#13;
   * Start Oris Space smart contract.&#13;
   *&#13;
   * @param _returnAmount amount of tokens to return to message sender.&#13;
   */&#13;
  function start (uint256 _returnAmount) public;&#13;
}&#13;
&#13;
contract OrgonToken is Token {&#13;
  /**&#13;
   * Create _value new tokens and give new created tokens to msg.sender.&#13;
   * May only be called by smart contract owner.&#13;
   *&#13;
   * @param _value number of tokens to create&#13;
   * @return true if tokens were created successfully, false otherwise&#13;
   */&#13;
  function createTokens (uint256 _value) public returns (bool);&#13;
&#13;
  /**&#13;
   * Burn given number of tokens belonging to message sender.&#13;
   * May only be called by smart contract owner.&#13;
   *&#13;
   * @param _value number of tokens to burn&#13;
   * @return true on success, false on error&#13;
   */&#13;
  function burnTokens (uint256 _value) public returns (bool);&#13;
}&#13;
&#13;
/**&#13;
 * Just Price Protocol Smart Contract that serves as market maker for Orgon&#13;
 * tokens.&#13;
 */&#13;
contract JustPriceProtocol is SafeMath {&#13;
  /**&#13;
   * 2^128.&#13;
   */&#13;
  uint256 internal constant TWO_128 = 0x100000000000000000000000000000000;&#13;
&#13;
  /**&#13;
   * Sale start time (2018-04-19 06:00:00 UTC)&#13;
   */&#13;
  uint256 internal constant SALE_START_TIME = 1524117600;&#13;
&#13;
  /**&#13;
   * "Reserve" stage deadline (2018-07-08 00:00:00 UTC)&#13;
   */&#13;
  uint256 internal constant RESERVE_DEADLINE = 1531008000;&#13;
&#13;
  /**&#13;
   * Maximum amount to be collected during "reserve" stage.&#13;
   */&#13;
  uint256 internal constant RESERVE_MAX_AMOUNT = 72500 ether;&#13;
&#13;
  /**&#13;
   * Minimum amount to be collected during "reserve" stage.&#13;
   */&#13;
  uint256 internal constant RESERVE_MIN_AMOUNT = 30000 ether;&#13;
&#13;
  /**&#13;
   * Maximum number of tokens to be sold during "reserve" stage.&#13;
   */&#13;
  uint256 internal constant RESERVE_MAX_TOKENS = 82881476.72e9;&#13;
&#13;
  /**&#13;
   * ORNG/ETH ratio after "reserve" stage in Wei per ORGN unit.&#13;
   */&#13;
  uint256 internal constant RESERVE_RATIO = 72500 ether / 725000000e9;&#13;
&#13;
  /**&#13;
   * Maximum amount of ETH to collect at price 1.&#13;
   */&#13;
  uint256 internal constant RESERVE_THRESHOLD_1 = 10000 ether;&#13;
&#13;
  /**&#13;
   * Price 1 in Wei per ORGN unit.&#13;
   */&#13;
  uint256 internal constant RESERVE_PRICE_1 = 0.00080 ether / 1e9;&#13;
&#13;
  /**&#13;
   * Maximum amount of ETH to collect at price 2.&#13;
   */&#13;
  uint256 internal constant RESERVE_THRESHOLD_2 = 20000 ether;&#13;
&#13;
  /**&#13;
   * Price 2 in Wei per ORGN unit.&#13;
   */&#13;
  uint256 internal constant RESERVE_PRICE_2 = 0.00082 ether / 1e9;&#13;
&#13;
  /**&#13;
   * Maximum amount of ETH to collect at price 3.&#13;
   */&#13;
  uint256 internal constant RESERVE_THRESHOLD_3 = 30000 ether;&#13;
&#13;
  /**&#13;
   * Price 3 in Wei per ORGN unit.&#13;
   */&#13;
  uint256 internal constant RESERVE_PRICE_3 = 0.00085 ether / 1e9;&#13;
&#13;
  /**&#13;
   * Maximum amount of ETH to collect at price 4.&#13;
   */&#13;
  uint256 internal constant RESERVE_THRESHOLD_4 = 40000 ether;&#13;
&#13;
  /**&#13;
   * Price 4 in Wei per ORGN unit.&#13;
   */&#13;
  uint256 internal constant RESERVE_PRICE_4 = 0.00088 ether / 1e9;&#13;
&#13;
  /**&#13;
   * Maximum amount of ETH to collect at price 5.&#13;
   */&#13;
  uint256 internal constant RESERVE_THRESHOLD_5 = 50000 ether;&#13;
&#13;
  /**&#13;
   * Price 5 in Wei per ORGN unit.&#13;
   */&#13;
  uint256 internal constant RESERVE_PRICE_5 = 0.00090 ether / 1e9;&#13;
&#13;
  /**&#13;
   * Maximum amount of ETH to collect at price 6.&#13;
   */&#13;
  uint256 internal constant RESERVE_THRESHOLD_6 = 60000 ether;&#13;
&#13;
  /**&#13;
   * Price 6 in Wei per ORGN unit.&#13;
   */&#13;
  uint256 internal constant RESERVE_PRICE_6 = 0.00092 ether / 1e9;&#13;
&#13;
  /**&#13;
   * Maximum amount of ETH to collect at price 7.&#13;
   */&#13;
  uint256 internal constant RESERVE_THRESHOLD_7 = 70000 ether;&#13;
&#13;
  /**&#13;
   * Price 7 in Wei per ORGN unit.&#13;
   */&#13;
  uint256 internal constant RESERVE_PRICE_7 = 0.00095 ether / 1e9;&#13;
&#13;
  /**&#13;
   * Maximum amount of ETH to collect at price 8.&#13;
   */&#13;
  uint256 internal constant RESERVE_THRESHOLD_8 = 72500 ether;&#13;
&#13;
  /**&#13;
   * Price 8 in Wei per ORGN unit.&#13;
   */&#13;
  uint256 internal constant RESERVE_PRICE_8 = 0.00098 ether / 1e9;&#13;
&#13;
  /**&#13;
   * "Growth" stage ends once this many tokens were issued.&#13;
   */&#13;
  uint256 internal constant GROWTH_MAX_TOKENS = 1000000000e9;&#13;
&#13;
  /**&#13;
   * Maximum duration of "growth" stage.&#13;
   */&#13;
  uint256 internal constant GROWTH_MAX_DURATION = 285 days;&#13;
&#13;
  /**&#13;
   * Numerator of fraction of tokens bought at "reserve" stage to be delivered&#13;
   * before "growth" stage start.&#13;
   */&#13;
  uint256 internal constant GROWTH_MIN_DELIVERED_NUMERATOR = 75;&#13;
&#13;
  /**&#13;
   * Denominator of fraction of tokens bought at "reserve" stage to be delivered&#13;
   * before "growth" stage start.&#13;
   */&#13;
  uint256 internal constant GROWTH_MIN_DELIVERED_DENOMINATIOR = 100;&#13;
&#13;
  /**&#13;
   * Numerator of fraction of total votes to be given to a new K1 address for&#13;
   * vote to succeed.&#13;
   */&#13;
  uint256 internal constant REQUIRED_VOTES_NUMERATIOR = 51;&#13;
&#13;
  /**&#13;
   * Denominator of fraction of total votes to be given to a new K1 address for&#13;
   * vote to succeed.&#13;
   */&#13;
  uint256 internal constant REQUIRED_VOTES_DENOMINATOR = 100;&#13;
&#13;
  /**&#13;
   * Fee denominator (1 / 20000 = 0.00005).&#13;
   */&#13;
  uint256 internal constant FEE_DENOMINATOR = 20000;&#13;
&#13;
  /**&#13;
   * Delay after start of "growth" stage before fee may be changed.&#13;
   */&#13;
  uint256 internal constant FEE_CHANGE_DELAY = 650 days;&#13;
&#13;
  /**&#13;
   * Minimum fee (1 / 20000 = 0.0005).&#13;
   */&#13;
  uint256 internal constant MIN_FEE = 1;&#13;
&#13;
  /**&#13;
   * Maximum fee (2000 / 20000 = 0.1).&#13;
   */&#13;
  uint256 internal constant MAX_FEE = 2000;&#13;
&#13;
  /**&#13;
   * Deploy Just Price Protocol smart contract with given Orgon Token,&#13;
   * Oris Space, and K1 wallet.&#13;
   *&#13;
   * @param _orgonToken Orgon Token to use&#13;
   * @param _orisSpace Oris Space to use&#13;
   * @param _k1 address of K1 wallet&#13;
   */&#13;
  function JustPriceProtocol (&#13;
    OrgonToken _orgonToken, OrisSpace _orisSpace, address _k1)&#13;
  public {&#13;
    orgonToken = _orgonToken;&#13;
    orisSpace = _orisSpace;&#13;
    k1 = _k1;&#13;
  }&#13;
&#13;
  /**&#13;
   * When called with no data does the same as buyTokens ().&#13;
   */&#13;
  function () public payable {&#13;
    require (msg.data.length == 0);&#13;
&#13;
    buyTokens ();&#13;
  }&#13;
&#13;
  /**&#13;
   * Buy tokens.&#13;
   */&#13;
  function buyTokens () public payable {&#13;
    require (msg.value &gt; 0);&#13;
&#13;
    updateStage ();&#13;
&#13;
    if (stage == Stage.RESERVE)&#13;
      buyTokensReserve ();&#13;
    else if (stage == Stage.GROWTH || stage == Stage.LIFE)&#13;
      buyTokensGrowthLife ();&#13;
    else revert (); // No buying in current stage&#13;
  }&#13;
&#13;
  /**&#13;
   * Sell tokens.&#13;
   *&#13;
   * @param _value number of tokens to sell&#13;
   */&#13;
  function sellTokens (uint256 _value) public {&#13;
    require (_value &gt; 0);&#13;
    require (_value &lt; TWO_128);&#13;
&#13;
    updateStage ();&#13;
    require (stage == Stage.LIFE);&#13;
&#13;
    assert (reserveAmount &lt; TWO_128);&#13;
    uint256 totalSupply = orgonToken.totalSupply ();&#13;
    require (totalSupply &lt; TWO_128);&#13;
&#13;
    require (_value &lt;= totalSupply);&#13;
&#13;
    uint256 toPay = safeMul (&#13;
      reserveAmount,&#13;
      safeSub (&#13;
        TWO_128,&#13;
        pow_10 (safeSub (TWO_128, (_value &lt;&lt; 128) / totalSupply)))) &gt;&gt; 128;&#13;
&#13;
    require (orgonToken.transferFrom (msg.sender, this, _value));&#13;
    require (orgonToken.burnTokens (_value));&#13;
&#13;
    reserveAmount = safeSub (reserveAmount, toPay);&#13;
&#13;
    msg.sender.transfer (toPay);&#13;
  }&#13;
&#13;
  /**&#13;
   * Deliver tokens sold during "reserve" stage to corresponding investors.&#13;
   *&#13;
   * @param _investors addresses of investors to deliver tokens to&#13;
   */&#13;
  function deliver (address [] _investors) public {&#13;
    updateStage ();&#13;
    require (&#13;
      stage == Stage.BEFORE_GROWTH ||&#13;
      stage == Stage.GROWTH ||&#13;
      stage == Stage.LIFE);&#13;
&#13;
    for (uint256 i = 0; i &lt; _investors.length; i++) {&#13;
      address investorAddress = _investors [i];&#13;
      Investor storage investor = investors [investorAddress];&#13;
&#13;
      uint256 toDeliver = investor.tokensBought;&#13;
      investor.tokensBought = 0;&#13;
      investor.etherInvested = 0;&#13;
&#13;
      if (toDeliver &gt; 0) {&#13;
        require (orgonToken.transfer (investorAddress, toDeliver));&#13;
        reserveTokensDelivered = safeAdd (reserveTokensDelivered, toDeliver);&#13;
&#13;
        Delivery (investorAddress, toDeliver);&#13;
      }&#13;
    }&#13;
&#13;
    if (stage == Stage.BEFORE_GROWTH &amp;&amp;&#13;
      safeMul (reserveTokensDelivered, GROWTH_MIN_DELIVERED_DENOMINATIOR) &gt;=&#13;
        safeMul (reserveTokensSold, GROWTH_MIN_DELIVERED_NUMERATOR)) {&#13;
      stage = Stage.GROWTH;&#13;
      growthDeadline = currentTime () + GROWTH_MAX_DURATION;&#13;
      feeChangeEnableTime = currentTime () + FEE_CHANGE_DELAY;&#13;
    }&#13;
  }&#13;
&#13;
  /**&#13;
   * Refund investors who bought tokens during "reserve" stage.&#13;
   *&#13;
   * @param _investors addresses of investors to refund&#13;
   */&#13;
  function refund (address [] _investors) public {&#13;
    updateStage ();&#13;
    require (stage == Stage.REFUND);&#13;
&#13;
    for (uint256 i = 0; i &lt; _investors.length; i++) {&#13;
      address investorAddress = _investors [i];&#13;
      Investor storage investor = investors [investorAddress];&#13;
&#13;
      uint256 toBurn = investor.tokensBought;&#13;
      uint256 toRefund = investor.etherInvested;&#13;
&#13;
      investor.tokensBought = 0;&#13;
      investor.etherInvested = 0;&#13;
&#13;
      if (toBurn &gt; 0)&#13;
        require (orgonToken.burnTokens (toBurn));&#13;
&#13;
      if (toRefund &gt; 0) {&#13;
        investorAddress.transfer (toRefund);&#13;
&#13;
        Refund (investorAddress, toRefund);&#13;
      }&#13;
    }&#13;
  }&#13;
&#13;
  function vote (address _newK1) public {&#13;
    updateStage ();&#13;
&#13;
    require (stage == Stage.LIFE);&#13;
    require (!k1Changed);&#13;
&#13;
    uint256 votesCount = voteNumbers [msg.sender];&#13;
    if (votesCount &gt; 0) {&#13;
      address oldK1 = votes [msg.sender];&#13;
      if (_newK1 != oldK1) {&#13;
        if (oldK1 != address (0)) {&#13;
          voteResults [oldK1] = safeSub (voteResults [oldK1], votesCount);&#13;
&#13;
          VoteRevocation (msg.sender, oldK1, votesCount);&#13;
        }&#13;
&#13;
        votes [msg.sender] = _newK1;&#13;
&#13;
        if (_newK1 != address (0)) {&#13;
          voteResults [_newK1] = safeAdd (voteResults [_newK1], votesCount);&#13;
          Vote (msg.sender, _newK1, votesCount);&#13;
&#13;
          if (safeMul (voteResults [_newK1], REQUIRED_VOTES_DENOMINATOR) &gt;=&#13;
            safeMul (totalVotesNumber, REQUIRED_VOTES_NUMERATIOR)) {&#13;
            k1 = _newK1;&#13;
            k1Changed = true;&#13;
&#13;
            K1Change (_newK1);&#13;
          }&#13;
        }&#13;
      }&#13;
    }&#13;
  }&#13;
&#13;
  /**&#13;
   * Set new fee numerator.&#13;
   *&#13;
   * @param _fee new fee numerator.&#13;
   */&#13;
  function setFee (uint256 _fee) public {&#13;
    require (msg.sender == k1);&#13;
&#13;
    require (_fee &gt;= MIN_FEE);&#13;
    require (_fee &lt;= MAX_FEE);&#13;
&#13;
    updateStage ();&#13;
&#13;
    require (stage == Stage.GROWTH || stage == Stage.LIFE);&#13;
    require (currentTime () &gt;= feeChangeEnableTime);&#13;
&#13;
    require (safeSub (_fee, 1) &lt;= fee);&#13;
    require (safeAdd (_fee, 1) &gt;= fee);&#13;
&#13;
    if (fee != _fee) {&#13;
      fee = _fee;&#13;
&#13;
      FeeChange (_fee);&#13;
    }&#13;
  }&#13;
&#13;
  /**&#13;
   * Get number of tokens bought by given investor during reserve stage that are&#13;
   * not yet delivered to him.&#13;
   *&#13;
   * @param _investor address of investor to get number of outstanding tokens&#13;
   *       for&#13;
   * @return number of non-delivered tokens given investor bought during reserve&#13;
   *         stage&#13;
   */&#13;
  function outstandingTokens (address _investor) public view returns (uint256) {&#13;
    return investors [_investor].tokensBought;&#13;
  }&#13;
&#13;
  /**&#13;
   * Get current stage of Just Price Protocol.&#13;
   *&#13;
   * @param _currentTime current time in seconds since epoch&#13;
   * @return current stage of Just Price Protocol&#13;
   */&#13;
  function getStage (uint256 _currentTime) public view returns (Stage) {&#13;
    Stage currentStage = stage;&#13;
&#13;
    if (currentStage == Stage.BEFORE_RESERVE) {&#13;
      if (_currentTime &gt;= SALE_START_TIME)&#13;
        currentStage = Stage.RESERVE;&#13;
      else return currentStage;&#13;
    }&#13;
&#13;
    if (currentStage == Stage.RESERVE) {&#13;
      if (_currentTime &gt;= RESERVE_DEADLINE) {&#13;
        if (reserveAmount &gt;= RESERVE_MIN_AMOUNT)&#13;
          currentStage = Stage.BEFORE_GROWTH;&#13;
        else currentStage = Stage.REFUND;&#13;
      }&#13;
&#13;
      return currentStage;&#13;
    }&#13;
&#13;
    if (currentStage == Stage.GROWTH) {&#13;
      if (_currentTime &gt;= growthDeadline) {&#13;
        currentStage = Stage.LIFE;&#13;
      }&#13;
    }&#13;
&#13;
    return currentStage;&#13;
  }&#13;
&#13;
  /**&#13;
   * Return total number of votes eligible for choosing new K1 address.&#13;
   *&#13;
   * @return total number of votes eligible for choosing new K1 address&#13;
   */&#13;
  function totalEligibleVotes () public view returns (uint256) {&#13;
    return totalVotesNumber;&#13;
  }&#13;
&#13;
  /**&#13;
   * Return number of votes eligible for choosing new K1 address given investor&#13;
   * has.&#13;
   *&#13;
   * @param _investor address of investor to get number of eligible votes of&#13;
   * @return Number of eligible votes given investor has&#13;
   */&#13;
  function eligibleVotes (address _investor) public view returns (uint256) {&#13;
    return voteNumbers [_investor];&#13;
  }&#13;
&#13;
  /**&#13;
   * Get number of votes for the given new K1 address.&#13;
   *&#13;
   * @param _newK1 new K1 address to get number of votes for&#13;
   * @return number of votes for the given new K1 address&#13;
   */&#13;
  function votesFor (address _newK1) public view returns (uint256) {&#13;
    return voteResults [_newK1];&#13;
  }&#13;
&#13;
  /**&#13;
   * Buy tokens during "reserve" stage.&#13;
   */&#13;
  function buyTokensReserve () internal {&#13;
    require (stage == Stage.RESERVE);&#13;
&#13;
    uint256 toBuy = 0;&#13;
    uint256 toRefund = msg.value;&#13;
    uint256 etherInvested = 0;&#13;
    uint256 tokens;&#13;
    uint256 tokensValue;&#13;
&#13;
    if (reserveAmount &lt; RESERVE_THRESHOLD_1) {&#13;
      tokens = min (&#13;
        toRefund,&#13;
        safeSub (RESERVE_THRESHOLD_1, reserveAmount)) /&#13;
        RESERVE_PRICE_1;&#13;
&#13;
      if (tokens &gt; 0) {&#13;
        tokensValue = safeMul (tokens, RESERVE_PRICE_1);&#13;
&#13;
        toBuy = safeAdd (toBuy, tokens);&#13;
        toRefund = safeSub (toRefund, tokensValue);&#13;
        etherInvested = safeAdd (etherInvested, tokensValue);&#13;
        reserveAmount = safeAdd (reserveAmount, tokensValue);&#13;
      }&#13;
    }&#13;
&#13;
    if (reserveAmount &lt; RESERVE_THRESHOLD_2) {&#13;
      tokens = min (&#13;
        toRefund,&#13;
        safeSub (RESERVE_THRESHOLD_2, reserveAmount)) /&#13;
        RESERVE_PRICE_2;&#13;
&#13;
      if (tokens &gt; 0) {&#13;
        tokensValue = safeMul (tokens, RESERVE_PRICE_2);&#13;
&#13;
        toBuy = safeAdd (toBuy, tokens);&#13;
        toRefund = safeSub (toRefund, tokensValue);&#13;
        etherInvested = safeAdd (etherInvested, tokensValue);&#13;
        reserveAmount = safeAdd (reserveAmount, tokensValue);&#13;
      }&#13;
    }&#13;
&#13;
    if (reserveAmount &lt; RESERVE_THRESHOLD_3) {&#13;
      tokens = min (&#13;
        toRefund,&#13;
        safeSub (RESERVE_THRESHOLD_3, reserveAmount)) /&#13;
        RESERVE_PRICE_3;&#13;
&#13;
      if (tokens &gt; 0) {&#13;
        tokensValue = safeMul (tokens, RESERVE_PRICE_3);&#13;
&#13;
        toBuy = safeAdd (toBuy, tokens);&#13;
        toRefund = safeSub (toRefund, tokensValue);&#13;
        etherInvested = safeAdd (etherInvested, tokensValue);&#13;
        reserveAmount = safeAdd (reserveAmount, tokensValue);&#13;
      }&#13;
    }&#13;
&#13;
    if (reserveAmount &lt; RESERVE_THRESHOLD_4) {&#13;
      tokens = min (&#13;
        toRefund,&#13;
        safeSub (RESERVE_THRESHOLD_4, reserveAmount)) /&#13;
        RESERVE_PRICE_4;&#13;
&#13;
      if (tokens &gt; 0) {&#13;
        tokensValue = safeMul (tokens, RESERVE_PRICE_4);&#13;
&#13;
        toBuy = safeAdd (toBuy, tokens);&#13;
        toRefund = safeSub (toRefund, tokensValue);&#13;
        etherInvested = safeAdd (etherInvested, tokensValue);&#13;
        reserveAmount = safeAdd (reserveAmount, tokensValue);&#13;
      }&#13;
    }&#13;
&#13;
    if (reserveAmount &lt; RESERVE_THRESHOLD_5) {&#13;
      tokens = min (&#13;
        toRefund,&#13;
        safeSub (RESERVE_THRESHOLD_5, reserveAmount)) /&#13;
        RESERVE_PRICE_5;&#13;
&#13;
      if (tokens &gt; 0) {&#13;
        tokensValue = safeMul (tokens, RESERVE_PRICE_5);&#13;
&#13;
        toBuy = safeAdd (toBuy, tokens);&#13;
        toRefund = safeSub (toRefund, tokensValue);&#13;
        etherInvested = safeAdd (etherInvested, tokensValue);&#13;
        reserveAmount = safeAdd (reserveAmount, tokensValue);&#13;
      }&#13;
    }&#13;
&#13;
    if (reserveAmount &lt; RESERVE_THRESHOLD_6) {&#13;
      tokens = min (&#13;
        toRefund,&#13;
        safeSub (RESERVE_THRESHOLD_6, reserveAmount)) /&#13;
        RESERVE_PRICE_6;&#13;
&#13;
      if (tokens &gt; 0) {&#13;
        tokensValue = safeMul (tokens, RESERVE_PRICE_6);&#13;
&#13;
        toBuy = safeAdd (toBuy, tokens);&#13;
        toRefund = safeSub (toRefund, tokensValue);&#13;
        etherInvested = safeAdd (etherInvested, tokensValue);&#13;
        reserveAmount = safeAdd (reserveAmount, tokensValue);&#13;
      }&#13;
    }&#13;
&#13;
    if (reserveAmount &lt; RESERVE_THRESHOLD_7) {&#13;
      tokens = min (&#13;
        toRefund,&#13;
        safeSub (RESERVE_THRESHOLD_7, reserveAmount)) /&#13;
        RESERVE_PRICE_7;&#13;
&#13;
      if (tokens &gt; 0) {&#13;
        tokensValue = safeMul (tokens, RESERVE_PRICE_7);&#13;
&#13;
        toBuy = safeAdd (toBuy, tokens);&#13;
        toRefund = safeSub (toRefund, tokensValue);&#13;
        etherInvested = safeAdd (etherInvested, tokensValue);&#13;
        reserveAmount = safeAdd (reserveAmount, tokensValue);&#13;
      }&#13;
    }&#13;
&#13;
    if (reserveAmount &lt; RESERVE_THRESHOLD_8) {&#13;
      tokens = min (&#13;
        toRefund,&#13;
        safeSub (RESERVE_THRESHOLD_8, reserveAmount)) /&#13;
        RESERVE_PRICE_8;&#13;
&#13;
      if (tokens &gt; 0) {&#13;
        tokensValue = safeMul (tokens, RESERVE_PRICE_8);&#13;
&#13;
        toBuy = safeAdd (toBuy, tokens);&#13;
        toRefund = safeSub (toRefund, tokensValue);&#13;
        etherInvested = safeAdd (etherInvested, tokensValue);&#13;
        reserveAmount = safeAdd (reserveAmount, tokensValue);&#13;
      }&#13;
    }&#13;
&#13;
    if (toBuy &gt; 0) {&#13;
      Investor storage investor = investors [msg.sender];&#13;
&#13;
      investor.tokensBought = safeAdd (&#13;
        investor.tokensBought, toBuy);&#13;
&#13;
      investor.etherInvested = safeAdd (&#13;
        investor.etherInvested, etherInvested);&#13;
&#13;
      reserveTokensSold = safeAdd (reserveTokensSold, toBuy);&#13;
&#13;
      require (orgonToken.createTokens (toBuy));&#13;
&#13;
      voteNumbers [msg.sender] = safeAdd (voteNumbers [msg.sender], toBuy);&#13;
      totalVotesNumber = safeAdd (totalVotesNumber, toBuy);&#13;
&#13;
      Investment (msg.sender, etherInvested, toBuy);&#13;
&#13;
      if (safeSub (RESERVE_THRESHOLD_8, reserveAmount) &lt;&#13;
        RESERVE_PRICE_8) {&#13;
&#13;
        orisSpace.start (0);&#13;
&#13;
        stage = Stage.BEFORE_GROWTH;&#13;
      }&#13;
    }&#13;
&#13;
    if (toRefund &gt; 0)&#13;
      msg.sender.transfer (toRefund);&#13;
  }&#13;
&#13;
  /**&#13;
   * Buy tokens during "growth" or "life" stage.&#13;
   */&#13;
  function buyTokensGrowthLife () internal {&#13;
    require (stage == Stage.GROWTH || stage == Stage.LIFE);&#13;
&#13;
    require (msg.value &lt; TWO_128);&#13;
&#13;
    uint256 totalSupply = orgonToken.totalSupply ();&#13;
    assert (totalSupply &lt; TWO_128);&#13;
&#13;
    uint256 toBuy = safeMul (&#13;
      totalSupply,&#13;
      safeSub (&#13;
        root_10 (safeAdd (TWO_128, (msg.value &lt;&lt; 128) / reserveAmount)),&#13;
        TWO_128)) &gt;&gt; 128;&#13;
&#13;
    reserveAmount = safeAdd (reserveAmount, msg.value);&#13;
    require (reserveAmount &lt; TWO_128);&#13;
&#13;
    if (toBuy &gt; 0) {&#13;
      require (orgonToken.createTokens (toBuy));&#13;
      require (orgonToken.totalSupply () &lt; TWO_128);&#13;
&#13;
      uint256 feeAmount = safeMul (toBuy, fee) / FEE_DENOMINATOR;&#13;
&#13;
      require (orgonToken.transfer (msg.sender, safeSub (toBuy, feeAmount)));&#13;
&#13;
      if (feeAmount &gt; 0)&#13;
        require (orgonToken.transfer (k1, feeAmount));&#13;
&#13;
      if (stage == Stage.GROWTH) {&#13;
        uint256 votesCount = toBuy;&#13;
&#13;
        totalSupply = orgonToken.totalSupply ();&#13;
        if (totalSupply &gt;= GROWTH_MAX_TOKENS) {&#13;
          stage = Stage.LIFE;&#13;
          votesCount = safeSub (&#13;
            votesCount,&#13;
            safeSub (totalSupply, GROWTH_MAX_TOKENS));&#13;
        }&#13;
&#13;
        voteNumbers [msg.sender] =&#13;
          safeAdd (voteNumbers [msg.sender], votesCount);&#13;
        totalVotesNumber = safeAdd (totalVotesNumber, votesCount);&#13;
      }&#13;
    }&#13;
  }&#13;
&#13;
  /**&#13;
   * Update stage of Just Price Protocol and return updated stage.&#13;
   *&#13;
   * @return updated stage of Just Price Protocol&#13;
   */&#13;
  function updateStage () internal returns (Stage) {&#13;
    Stage currentStage = getStage (currentTime ());&#13;
    if (stage != currentStage) {&#13;
      if (currentStage == Stage.BEFORE_GROWTH) {&#13;
        // "Reserve" stage deadline reached and minimum amount collected&#13;
        uint256 tokensToBurn =&#13;
          safeSub (&#13;
            safeAdd (&#13;
              safeAdd (&#13;
                safeSub (RESERVE_MAX_AMOUNT, reserveAmount),&#13;
                safeSub (RESERVE_RATIO, 1)) /&#13;
                RESERVE_RATIO,&#13;
              reserveTokensSold),&#13;
            RESERVE_MAX_TOKENS);&#13;
&#13;
        orisSpace.start (tokensToBurn);&#13;
        if (tokensToBurn &gt; 0)&#13;
          require (orgonToken.burnTokens (tokensToBurn));&#13;
      }&#13;
&#13;
      stage = currentStage;&#13;
    }&#13;
  }&#13;
&#13;
  /**&#13;
   * Get minimum of two values.&#13;
   *&#13;
   * @param x first value&#13;
   * @param y second value&#13;
   * @return minimum of two values&#13;
   */&#13;
  function min (uint256 x, uint256 y) internal pure returns (uint256) {&#13;
    return x &lt; y ? x : y;&#13;
  }&#13;
&#13;
  /**&#13;
   * Calculate 2^128 * (x / 2^128)^(1/10).&#13;
   *&#13;
   * @param x parameter x&#13;
   * @return 2^128 * (x / 2^128)^(1/10)&#13;
   */&#13;
  function root_10 (uint256 x) internal pure returns (uint256 y) {&#13;
    uint256 shift = 0;&#13;
&#13;
    while (x &gt; TWO_128) {&#13;
      x &gt;&gt;= 10;&#13;
      shift += 1;&#13;
    }&#13;
&#13;
    if (x == TWO_128 || x == 0) y = x;&#13;
    else {&#13;
      uint256 x128 = x &lt;&lt; 128;&#13;
      y = TWO_128;&#13;
&#13;
      uint256 t = x;&#13;
      while (true) {&#13;
        t &lt;&lt;= 10;&#13;
        if (t &lt; TWO_128) y &gt;&gt;= 1;&#13;
        else break;&#13;
      }&#13;
&#13;
      for (uint256 i = 0; i &lt; 16; i++) {&#13;
        uint256 y9;&#13;
&#13;
        if (y == TWO_128) y9 = y;&#13;
        else {&#13;
          uint256 y2 = (y * y) &gt;&gt; 128;&#13;
          uint256 y4 = (y2 * y2) &gt;&gt; 128;&#13;
          uint256 y8 = (y4 * y4) &gt;&gt; 128;&#13;
          y9 = (y * y8) &gt;&gt; 128;&#13;
        }&#13;
&#13;
        y = (9 * y + x128 / y9) / 10;&#13;
&#13;
        assert (y &lt;= TWO_128);&#13;
      }&#13;
    }&#13;
&#13;
    y &lt;&lt;= shift;&#13;
  }&#13;
&#13;
  /**&#13;
   * Calculate 2^128 * (x / 2^128)^10.&#13;
   *&#13;
   * @param x parameter x&#13;
   * @return 2^128 * (x / 2^128)^10&#13;
   */&#13;
  function pow_10 (uint256 x) internal pure returns (uint256) {&#13;
    require (x &lt;= TWO_128);&#13;
&#13;
    if (x == TWO_128) return x;&#13;
    else {&#13;
      uint256 x2 = (x * x) &gt;&gt; 128;&#13;
      uint256 x4 = (x2 * x2) &gt;&gt; 128;&#13;
      uint256 x8 = (x4 * x4) &gt;&gt; 128;&#13;
      return (x2 * x8) &gt;&gt; 128;&#13;
    }&#13;
  }&#13;
&#13;
  /**&#13;
   * Get current time in seconds since epoch.&#13;
   *&#13;
   * @return current time in seconds since epoch&#13;
   */&#13;
  function currentTime () internal view returns (uint256) {&#13;
    return block.timestamp;&#13;
  }&#13;
&#13;
  /**&#13;
   * Just Price Protocol stages.&#13;
   * +----------------+&#13;
   * | BEFORE_RESERVE |&#13;
   * +----------------+&#13;
   *         |&#13;
   *         | Sale start time reached&#13;
   *         V&#13;
   *    +---------+   Reserve deadline reached&#13;
   *    | RESERVE |-------------------------------+&#13;
   *    +---------+                               |&#13;
   *         |                                    |&#13;
   *         | 72500 ETH collected                |&#13;
   *         V                                    |&#13;
   * +---------------+ 39013,174672 ETH collected |&#13;
   * | BEFORE_GROWTH |&lt;---------------------------O&#13;
   * +---------------+                            |&#13;
   *         |                                    | 39013,174672 ETH not collected&#13;
   *         | 80% of tokens delivered            |&#13;
   *         V                                    V&#13;
   *  +------------+                         +--------+&#13;
   *  |   GROWTH   |                         | REFUND |&#13;
   *  +------------+                         +--------+&#13;
   *         |&#13;
   *         | 1,500,000,000 tokens issued or 365 days passed since start of "GROWTH" stage&#13;
   *         V&#13;
   *     +------+&#13;
   *     | LIFE |&#13;
   *     +------+&#13;
   */&#13;
  enum Stage {&#13;
    BEFORE_RESERVE, // Before start of "Reserve" stage&#13;
    RESERVE, // "Reserve" stage&#13;
    BEFORE_GROWTH, // Between "Reserve" and "Growth" stages&#13;
    GROWTH, // "Grows" stage&#13;
    LIFE, // "Life" stage&#13;
    REFUND // "Refund" stage&#13;
  }&#13;
&#13;
  /**&#13;
   * Orgon Token smart contract.&#13;
   */&#13;
  OrgonToken internal orgonToken;&#13;
&#13;
  /**&#13;
   * Oris Space spart contract.&#13;
   */&#13;
  OrisSpace internal orisSpace;&#13;
&#13;
  /**&#13;
   * Address of K1 smart contract.&#13;
   */&#13;
  address internal k1;&#13;
&#13;
  /**&#13;
   * Last known stage of Just Price Protocol&#13;
   */&#13;
  Stage internal stage = Stage.BEFORE_RESERVE;&#13;
&#13;
  /**&#13;
   * Amount of ether in reserve.&#13;
   */&#13;
  uint256 internal reserveAmount;&#13;
&#13;
  /**&#13;
   * Number of tokens sold during "reserve" stage.&#13;
   */&#13;
  uint256 internal reserveTokensSold;&#13;
&#13;
  /**&#13;
   * Number of tokens sold during "reserve" stage that were already delivered to&#13;
   * investors.&#13;
   */&#13;
  uint256 internal reserveTokensDelivered;&#13;
&#13;
  /**&#13;
   * "Growth" stage deadline.&#13;
   */&#13;
  uint256 internal growthDeadline;&#13;
&#13;
  /**&#13;
   * Mapping from address of a person who bought some tokens during "reserve"&#13;
   * stage to information about how many tokens he bought to how much ether&#13;
   * invested.&#13;
   */&#13;
  mapping (address =&gt; Investor) internal investors;&#13;
&#13;
  /**&#13;
   * Mapping from address of an investor to the number of votes this investor&#13;
   * has.&#13;
   */&#13;
  mapping (address =&gt; uint256) internal voteNumbers;&#13;
&#13;
  /**&#13;
   * Mapping from address of an investor to the new K1 address this investor&#13;
   * voted for.&#13;
   */&#13;
  mapping (address =&gt; address) internal votes;&#13;
&#13;
  /**&#13;
   * Mapping from suggested new K1 address to the number of votes for this&#13;
   * address.&#13;
   */&#13;
  mapping (address =&gt; uint256) internal voteResults;&#13;
&#13;
  /**&#13;
   * Total number of eligible votes.&#13;
   */&#13;
  uint256 internal totalVotesNumber;&#13;
&#13;
  /**&#13;
   * Whether K1 address was already changed via voting.&#13;
   */&#13;
  bool internal k1Changed = false;&#13;
&#13;
  /**&#13;
   * Fee enumerator.  (2 / 20000 = 0.0001);&#13;
   */&#13;
  uint256 internal fee = 2;&#13;
&#13;
  /**&#13;
   * Time when fee changing is enabled.&#13;
   */&#13;
  uint256 internal feeChangeEnableTime;&#13;
&#13;
  /**&#13;
   * Encapsulates information about a person who bought some tokens during&#13;
   * "reserve" stage.&#13;
   */&#13;
  struct Investor {&#13;
    /**&#13;
     * Number of tokens bought during reserve stage.&#13;
     */&#13;
    uint256 tokensBought;&#13;
&#13;
    /**&#13;
     * Ether invested during reserve stage.&#13;
     */&#13;
    uint256 etherInvested;&#13;
  }&#13;
&#13;
  /**&#13;
   * Logged when investor invested some ether during "reserve" stage.&#13;
   *&#13;
   * @param investor address of investor&#13;
   * @param value amount of ether invested&#13;
   * @param amount number of tokens issued for investor&#13;
   */&#13;
  event Investment (address indexed investor, uint256 value, uint256 amount);&#13;
&#13;
  /**&#13;
   * Logged when tokens bought at "reserve" stage were delivered to investor.&#13;
   *&#13;
   * @param investor address of investor whom tokens were delivered to&#13;
   * @param amount number of tokens delivered&#13;
   */&#13;
  event Delivery (address indexed investor, uint256 amount);&#13;
&#13;
  /**&#13;
   * Logged when investment was refunded.&#13;
   *&#13;
   * @param investor address of investor whose investment was refunded&#13;
   * @param value amount of ether refunded&#13;
   */&#13;
  event Refund (address indexed investor, uint256 value);&#13;
&#13;
  /**&#13;
   * Logged when K1 address was changed.&#13;
   *&#13;
   * @param k1 new K1 address&#13;
   */&#13;
  event K1Change (address k1);&#13;
&#13;
  /**&#13;
   * Logged when investor voted for new K1 address.&#13;
   * &#13;
   * @param investor investor who voted for new K1 address&#13;
   * @param newK1 new K1 address investor voted for&#13;
   * @param votes number of votes investor has&#13;
   */&#13;
  event Vote (address indexed investor, address indexed newK1, uint256 votes);&#13;
&#13;
  /**&#13;
   * Logged when investor revoked vote for new K1 address.&#13;
   * &#13;
   * @param investor investor who revoked vote for new K1 address&#13;
   * @param newK1 new K1 address investor revoked vote for&#13;
   * @param votes number of votes investor has&#13;
   */&#13;
  event VoteRevocation (&#13;
    address indexed investor, address indexed newK1, uint256 votes);&#13;
&#13;
  /**&#13;
   * Logged when fee was changed.&#13;
   *&#13;
   * @param fee new fee numerator&#13;
   */&#13;
  event FeeChange (uint256 fee);&#13;
}