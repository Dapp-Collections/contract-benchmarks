pragma solidity 0.4.24;


/**
 * @title Ownable
 * @dev The Ownable contract has an owner address, and provides basic authorization control
 * functions, this simplifies the implementation of "user permissions".
 */
contract Ownable {
  address public owner;


  event OwnershipRenounced(address indexed previousOwner);
  event OwnershipTransferred(
    address indexed previousOwner,
    address indexed newOwner
  );


  /**
   * @dev The Ownable constructor sets the original `owner` of the contract to the sender
   * account.
   */
  constructor() public {
    owner = msg.sender;
  }

  /**
   * @dev Throws if called by any account other than the owner.
   */
  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }

  /**
   * @dev Allows the current owner to relinquish control of the contract.
   * @notice Renouncing to ownership will leave the contract without an owner.
   * It will not be possible to call the functions with the `onlyOwner`
   * modifier anymore.
   */
  function renounceOwnership() public onlyOwner {
    emit OwnershipRenounced(owner);
    owner = address(0);
  }

  /**
   * @dev Allows the current owner to transfer control of the contract to a newOwner.
   * @param _newOwner The address to transfer ownership to.
   */
  function transferOwnership(address _newOwner) public onlyOwner {
    _transferOwnership(_newOwner);
  }

  /**
   * @dev Transfers control of the contract to a newOwner.
   * @param _newOwner The address to transfer ownership to.
   */
  function _transferOwnership(address _newOwner) internal {
    require(_newOwner != address(0));
    emit OwnershipTransferred(owner, _newOwner);
    owner = _newOwner;
  }
}

/**
 * @title Contracts that should be able to recover tokens
 * @author SylTi
 * @dev This allow a contract to recover any ERC20 token received in a contract by transferring the balance to the contract owner.
 * This will prevent any accidental loss of tokens.
 */
contract CanReclaimToken is Ownable {
  using SafeERC20 for ERC20Basic;

  /**
   * @dev Reclaim all ERC20Basic compatible tokens
   * @param token ERC20Basic The address of the token contract
   */
  function reclaimToken(ERC20Basic token) external onlyOwner {
    uint256 balance = token.balanceOf(this);
    token.safeTransfer(owner, balance);
  }

}


/**
 * @title Contracts that should not own Tokens
 * @author Remco Bloemen <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="6d1f08000e022d5f">[email protected]</a>π.com&gt;&#13;
 * @dev This blocks incoming ERC223 tokens to prevent accidental loss of tokens.&#13;
 * Should tokens (any ERC20Basic compatible) end up in the contract, it allows the&#13;
 * owner to reclaim the tokens.&#13;
 */&#13;
contract HasNoTokens is CanReclaimToken {&#13;
&#13;
 /**&#13;
  * @dev Reject all ERC223 compatible tokens&#13;
  * @param from_ address The address that is transferring the tokens&#13;
  * @param value_ uint256 the amount of the specified token&#13;
  * @param data_ Bytes The data passed from the caller.&#13;
  */&#13;
  function tokenFallback(address from_, uint256 value_, bytes data_) external {&#13;
    from_;&#13;
    value_;&#13;
    data_;&#13;
    revert();&#13;
  }&#13;
&#13;
}&#13;
&#13;
&#13;
/**&#13;
 * @title ERC20Basic&#13;
 * @dev Simpler version of ERC20 interface&#13;
 * See https://github.com/ethereum/EIPs/issues/179&#13;
 */&#13;
contract ERC20Basic {&#13;
  function totalSupply() public view returns (uint256);&#13;
  function balanceOf(address who) public view returns (uint256);&#13;
  function transfer(address to, uint256 value) public returns (bool);&#13;
  event Transfer(address indexed from, address indexed to, uint256 value);&#13;
}&#13;
&#13;
&#13;
/**&#13;
 * @title SafeERC20&#13;
 * @dev Wrappers around ERC20 operations that throw on failure.&#13;
 * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,&#13;
 * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.&#13;
 */&#13;
library SafeERC20 {&#13;
  function safeTransfer(ERC20Basic token, address to, uint256 value) internal {&#13;
    require(token.transfer(to, value));&#13;
  }&#13;
&#13;
  function safeTransferFrom(&#13;
    ERC20 token,&#13;
    address from,&#13;
    address to,&#13;
    uint256 value&#13;
  )&#13;
    internal&#13;
  {&#13;
    require(token.transferFrom(from, to, value));&#13;
  }&#13;
&#13;
  function safeApprove(ERC20 token, address spender, uint256 value) internal {&#13;
    require(token.approve(spender, value));&#13;
  }&#13;
}&#13;
&#13;
&#13;
/**&#13;
 * @title ERC20 interface&#13;
 * @dev see https://github.com/ethereum/EIPs/issues/20&#13;
 */&#13;
contract ERC20 is ERC20Basic {&#13;
  function allowance(address owner, address spender)&#13;
    public view returns (uint256);&#13;
&#13;
  function transferFrom(address from, address to, uint256 value)&#13;
    public returns (bool);&#13;
&#13;
  function approve(address spender, uint256 value) public returns (bool);&#13;
  event Approval(&#13;
    address indexed owner,&#13;
    address indexed spender,&#13;
    uint256 value&#13;
  );&#13;
}&#13;
&#13;
&#13;
/**&#13;
 * @title Contracts that should not own Contracts&#13;
 * @author Remco Bloemen &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="0f7d6a626c604f3d">[email protected]</a>π.com&gt;&#13;
 * @dev Should contracts (anything Ownable) end up being owned by this contract, it allows the owner&#13;
 * of this contract to reclaim ownership of the contracts.&#13;
 */&#13;
contract HasNoContracts is Ownable {&#13;
&#13;
  /**&#13;
   * @dev Reclaim ownership of Ownable contracts&#13;
   * @param contractAddr The address of the Ownable to be reclaimed.&#13;
   */&#13;
  function reclaimContract(address contractAddr) external onlyOwner {&#13;
    Ownable contractInst = Ownable(contractAddr);&#13;
    contractInst.transferOwnership(owner);&#13;
  }&#13;
}&#13;
&#13;
&#13;
/**&#13;
 * @title SafeMath&#13;
 * @dev Math operations with safety checks that throw on error&#13;
 */&#13;
library SafeMath {&#13;
&#13;
  /**&#13;
  * @dev Multiplies two numbers, throws on overflow.&#13;
  */&#13;
  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {&#13;
    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the&#13;
    // benefit is lost if 'b' is also tested.&#13;
    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522&#13;
    if (a == 0) {&#13;
      return 0;&#13;
    }&#13;
&#13;
    c = a * b;&#13;
    assert(c / a == b);&#13;
    return c;&#13;
  }&#13;
&#13;
  /**&#13;
  * @dev Integer division of two numbers, truncating the quotient.&#13;
  */&#13;
  function div(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
    // assert(b &gt; 0); // Solidity automatically throws when dividing by 0&#13;
    // uint256 c = a / b;&#13;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold&#13;
    return a / b;&#13;
  }&#13;
&#13;
  /**&#13;
  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).&#13;
  */&#13;
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
    assert(b &lt;= a);&#13;
    return a - b;&#13;
  }&#13;
&#13;
  /**&#13;
  * @dev Adds two numbers, throws on overflow.&#13;
  */&#13;
  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {&#13;
    c = a + b;&#13;
    assert(c &gt;= a);&#13;
    return c;&#13;
  }&#13;
}&#13;
&#13;
&#13;
/// @title PoolParty contract responsible for deploying independent Pool.sol contracts.&#13;
contract PoolParty is HasNoTokens, HasNoContracts {&#13;
    using SafeMath for uint256;&#13;
&#13;
    event PoolCreated(uint256 poolId, address creator);&#13;
&#13;
    uint256 public nextPoolId;&#13;
&#13;
    /// @dev Holds the pool id and the corresponding pool contract address&#13;
    mapping(uint256 =&gt;address) public pools;&#13;
&#13;
    /// @notice Reclaim Ether that is accidentally sent to this contract.&#13;
    /// @dev If a user forces ether into this contract, via selfdestruct etc..&#13;
    /// Requires:&#13;
    ///     - msg.sender is the owner&#13;
    function reclaimEther() external onlyOwner {&#13;
        owner.transfer(address(this).balance);&#13;
    }&#13;
&#13;
    /// @notice Creates a new pool with custom configurations.&#13;
    /// @dev Creates a new pool via the imported Pool.sol contracts.&#13;
    /// Refer to Pool.sol contracts for specific details.&#13;
    /// @param _admins List of admins for the new pool.&#13;
    /// @param _configsUint Array of all uint256 custom configurations.&#13;
    /// Refer to the Config.sol files for a description of each one.&#13;
    /// @param _configsBool Array of all boolean custom configurations.&#13;
    /// Refer to the Config.sol files for a description of each one.&#13;
    /// @return The poolId for the created pool. Throws an exception on failure.&#13;
    function createPool(&#13;
        address[] _admins,&#13;
        uint256[] _configsUint,&#13;
        bool[] _configsBool&#13;
    )&#13;
        public&#13;
        returns (address _pool)&#13;
    {&#13;
        address poolOwner = msg.sender;&#13;
&#13;
        _pool = new Pool(&#13;
            poolOwner,&#13;
            _admins,&#13;
            _configsUint,&#13;
            _configsBool,&#13;
            nextPoolId&#13;
        );&#13;
&#13;
        pools[nextPoolId] = _pool;&#13;
        nextPoolId = nextPoolId.add(1);&#13;
&#13;
        emit PoolCreated(nextPoolId, poolOwner);&#13;
    }&#13;
}&#13;
&#13;
&#13;
/// @title Admin functionality for Pool.sol contracts.&#13;
contract Admin {&#13;
    using SafeMath for uint256;&#13;
    using SafeMath for uint8;&#13;
&#13;
    address public owner;&#13;
    address[] public admins;&#13;
&#13;
    /// @dev Verifies the msg.sender is a member of the admins list.&#13;
    modifier isAdmin() {&#13;
        bool found = false;&#13;
&#13;
        for (uint256 i = 0; i &lt; admins.length; ++i) {&#13;
            if (admins[i] == msg.sender) {&#13;
                found = true;&#13;
                break;&#13;
            }&#13;
        }&#13;
&#13;
        // msg.sender is not an admin!&#13;
        require(found);&#13;
        _;&#13;
    }&#13;
&#13;
    /// @dev Ensures creator of the pool is in the admin list and that there are no duplicates or 0x0 addresses.&#13;
    modifier isValidAdminsList(address[] _listOfAdmins) {&#13;
        bool containsSender = false;&#13;
&#13;
        for (uint256 i = 0; i &lt; _listOfAdmins.length; ++i) {&#13;
            // Admin list contains 0x0 address!&#13;
            require(_listOfAdmins[i] != address(0));&#13;
&#13;
            if (_listOfAdmins[i] == owner) {&#13;
                containsSender = true;&#13;
            }&#13;
&#13;
            for (uint256 j = i + 1; j &lt; _listOfAdmins.length; ++j) {&#13;
                // Admin list contains a duplicate address!&#13;
                require(_listOfAdmins[i] != _listOfAdmins[j]);&#13;
            }&#13;
        }&#13;
&#13;
        // Admin list does not contain the creators address!&#13;
        require(containsSender);&#13;
        _;&#13;
    }&#13;
&#13;
    /// @dev If the list of admins is verified, the global variable admins is set to equal the _listOfAdmins.&#13;
    /// throws an exception if _listOfAdmins is &lt; 1.&#13;
    /// @param _listOfAdmins the list of admin addresses for the new pool.&#13;
    function createAdminsForPool(&#13;
        address[] _listOfAdmins&#13;
    )&#13;
        internal&#13;
        isValidAdminsList(_listOfAdmins)&#13;
    {&#13;
        admins = _listOfAdmins;&#13;
    }&#13;
}&#13;
&#13;
&#13;
// @title State configurations for Pool.sol contracts.&#13;
contract State is Admin {&#13;
    enum PoolState{&#13;
        // @dev Pool is accepting ETH. Users can refund themselves in this state.&#13;
        OPEN,&#13;
&#13;
        // @dev Pool is closed and the funds are locked. No user refunds allowed.&#13;
        CLOSED,&#13;
&#13;
        // @dev ETH is transferred out and the funds are locked. No refunds can be processed.&#13;
        // State cannot be re-opened.&#13;
        AWAITING_TOKENS,&#13;
&#13;
        // @dev Available tokens are claimable by users.&#13;
        COMPLETED,&#13;
&#13;
        // @dev Eth can be refunded to all wallets. State is final.&#13;
        CANCELLED&#13;
    }&#13;
&#13;
    event PoolIsOpen ();&#13;
    event PoolIsClosed ();&#13;
    event PoolIsAwaitingTokens ();&#13;
    event PoolIsCompleted ();&#13;
    event PoolIsCancelled ();&#13;
&#13;
    PoolState public state;&#13;
&#13;
    /// @dev Verifies the pool is in the OPEN state.&#13;
    modifier isOpen() {&#13;
        // Pool is not set to open!&#13;
        require(state == PoolState.OPEN);&#13;
        _;&#13;
    }&#13;
&#13;
    /// @dev Verifies the pool is in the CLOSED state.&#13;
    modifier isClosed() {&#13;
        // Pool is not closed!&#13;
        require(state == PoolState.CLOSED);&#13;
        _;&#13;
    }&#13;
&#13;
    /// @dev Verifies the pool is in the OPEN or CLOSED state.&#13;
    modifier isOpenOrClosed() {&#13;
        // Pool is not cancelable!&#13;
        require(state == PoolState.OPEN || state == PoolState.CLOSED);&#13;
        _;&#13;
    }&#13;
&#13;
    /// @dev Verifies the pool is CANCELLED.&#13;
    modifier isCancelled() {&#13;
        // Pool is not cancelled!&#13;
        require(state == PoolState.CANCELLED);&#13;
        _;&#13;
    }&#13;
&#13;
    /// @dev Verifies the user is able to call a refund.&#13;
    modifier isUserRefundable() {&#13;
        // Pool is not user refundable!&#13;
        require(state == PoolState.OPEN || state == PoolState.CANCELLED);&#13;
        _;&#13;
    }&#13;
&#13;
    /// @dev Verifies an admin is able to call a refund.&#13;
    modifier isAdminRefundable() {&#13;
        // Pool is not admin refundable!&#13;
        require(state == PoolState.OPEN || state == PoolState.CLOSED || state == PoolState.CANCELLED);  // solium-disable-line max-len&#13;
        _;&#13;
    }&#13;
&#13;
    /// @dev Verifies the pool is in the COMPLETED or AWAITING_TOKENS state.&#13;
    modifier isAwaitingOrCompleted() {&#13;
        // Pool is not awaiting or completed!&#13;
        require(state == PoolState.COMPLETED || state == PoolState.AWAITING_TOKENS);&#13;
        _;&#13;
    }&#13;
&#13;
    /// @dev Verifies the pool is in the COMPLETED state.&#13;
    modifier isCompleted() {&#13;
        // Pool is not completed!&#13;
        require(state == PoolState.COMPLETED);&#13;
        _;&#13;
    }&#13;
&#13;
    /// @notice Allows the admin to set the state of the pool to OPEN.&#13;
    /// @dev Requires that the sender is an admin, and the pool is currently CLOSED.&#13;
    function setPoolToOpen() public isAdmin isClosed {&#13;
        state = PoolState.OPEN;&#13;
        emit PoolIsOpen();&#13;
    }&#13;
&#13;
    /// @notice Allows the admin to set the state of the pool to CLOSED.&#13;
    /// @dev Requires that the sender is an admin, and the contract is currently OPEN.&#13;
    function setPoolToClosed() public isAdmin isOpen {&#13;
        state = PoolState.CLOSED;&#13;
        emit PoolIsClosed();&#13;
    }&#13;
&#13;
    /// @notice Cancels the project and sets the state of the pool to CANCELLED.&#13;
    /// @dev Requires that the sender is an admin, and the contract is currently OPEN or CLOSED.&#13;
    function setPoolToCancelled() public isAdmin isOpenOrClosed {&#13;
        state = PoolState.CANCELLED;&#13;
        emit PoolIsCancelled();&#13;
    }&#13;
&#13;
    /// @dev Sets the pool to AWAITING_TOKENS.&#13;
    function setPoolToAwaitingTokens() internal {&#13;
        state = PoolState.AWAITING_TOKENS;&#13;
        emit PoolIsAwaitingTokens();&#13;
    }&#13;
&#13;
    /// @dev Sets the pool to COMPLETED.&#13;
    function setPoolToCompleted() internal {&#13;
        state = PoolState.COMPLETED;&#13;
        emit PoolIsCompleted();&#13;
    }&#13;
}&#13;
&#13;
&#13;
/// @title Uint256 and boolean configurations for Pool.sol contracts.&#13;
contract Config is State {&#13;
    enum OptionUint256{&#13;
        MAX_ALLOCATION,&#13;
        MIN_CONTRIBUTION,&#13;
        MAX_CONTRIBUTION,&#13;
&#13;
        // Number of decimal places for the ADMIN_FEE_PERCENTAGE - capped at FEE_PERCENTAGE_DECIMAL_CAP.&#13;
        ADMIN_FEE_PERCENT_DECIMALS,&#13;
&#13;
        // The percentage of admin fee relative to the amount of ADMIN_FEE_PERCENT_DECIMALS.&#13;
        ADMIN_FEE_PERCENTAGE&#13;
    }&#13;
&#13;
    enum OptionBool{&#13;
        // True when the pool requires a whitelist.&#13;
        HAS_WHITELIST,&#13;
&#13;
        // Uses ADMIN_FEE_PAYOUT_METHOD - true = tokens, false = ether.&#13;
        ADMIN_FEE_PAYOUT_TOKENS&#13;
    }&#13;
&#13;
    uint8 public constant  OPTION_UINT256_SIZE = 5;&#13;
    uint8 public constant  OPTION_BOOL_SIZE = 2;&#13;
    uint8 public constant  FEE_PERCENTAGE_DECIMAL_CAP = 5;&#13;
&#13;
    uint256 public maxAllocation;&#13;
    uint256 public minContribution;&#13;
    uint256 public maxContribution;&#13;
    uint256 public adminFeePercentageDecimals;&#13;
    uint256 public adminFeePercentage;&#13;
    uint256 public feePercentageDivisor;&#13;
&#13;
    bool public hasWhitelist;&#13;
    bool public adminFeePayoutIsToken;&#13;
&#13;
    /// @notice Sets the min and the max contribution configurations.&#13;
    /// @dev This will not retroactively effect previous contributions.&#13;
    /// This will only be applied to contributions moving forward.&#13;
    /// Requires:&#13;
    ///     - The msg.sender is an admin&#13;
    ///     - Max contribution is &lt;= the max allocation&#13;
    ///     - Minimum contribution is &lt;= max contribution&#13;
    ///     - The pool state is currently set to OPEN or CLOSED&#13;
    /// @param _min The new minimum contribution for this pool.&#13;
    /// @param _max The new maximum contribution for this pool.&#13;
    function setMinMaxContribution(&#13;
        uint256 _min,&#13;
        uint256 _max&#13;
    )&#13;
        public&#13;
        isAdmin&#13;
        isOpenOrClosed&#13;
    {&#13;
        // Max contribution is greater than max allocation!&#13;
        require(_max &lt;= maxAllocation);&#13;
        // Minimum contribution is greater than max contribution!&#13;
        require(_min &lt;= _max);&#13;
&#13;
        minContribution = _min;&#13;
        maxContribution = _max;&#13;
    }&#13;
&#13;
    /// @dev Validates and sets the configurations for the new pool.&#13;
    /// Throws an exception when:&#13;
    ///     - The config arrays are not the correct size&#13;
    ///     - The maxContribution &gt; maxAllocation&#13;
    ///     - The minContribution &gt; maxContribution&#13;
    ///     - The adminFeePercentageDecimals &gt; FEE_PERCENTAGE_DECIMAL_CAP&#13;
    ///     - The adminFeePercentage &gt;= 100&#13;
    /// @param _configsUint contains all of the uint256 configurations.&#13;
    /// The indexes are as follows:&#13;
    ///     - MAX_ALLOCATION&#13;
    ///     - MIN_CONTRIBUTION&#13;
    ///     - MAX_CONTRIBUTION&#13;
    ///     - ADMIN_FEE_PERCENT_DECIMALS&#13;
    ///     - ADMIN_FEE_PERCENTAGE&#13;
    /// @param _configsBool contains all of the  boolean configurations.&#13;
    /// The indexes are as follows:&#13;
    ///     - HAS_WHITELIST&#13;
    ///     - ADMIN_FEE_PAYOUT&#13;
    function createConfigsForPool(&#13;
        uint256[] _configsUint,&#13;
        bool[] _configsBool&#13;
    )&#13;
        internal&#13;
    {&#13;
        // Wrong number of uint256 configurations!&#13;
        require(_configsUint.length == OPTION_UINT256_SIZE);&#13;
        // Wrong number of boolean configurations!&#13;
        require(_configsBool.length == OPTION_BOOL_SIZE);&#13;
&#13;
        // Sets the uint256 configurations.&#13;
        maxAllocation = _configsUint[uint(OptionUint256.MAX_ALLOCATION)];&#13;
        minContribution = _configsUint[uint(OptionUint256.MIN_CONTRIBUTION)];&#13;
        maxContribution = _configsUint[uint(OptionUint256.MAX_CONTRIBUTION)];&#13;
        adminFeePercentageDecimals = _configsUint[uint(OptionUint256.ADMIN_FEE_PERCENT_DECIMALS)];&#13;
        adminFeePercentage = _configsUint[uint(OptionUint256.ADMIN_FEE_PERCENTAGE)];&#13;
&#13;
        // Sets the boolean values.&#13;
        hasWhitelist = _configsBool[uint(OptionBool.HAS_WHITELIST)];&#13;
        adminFeePayoutIsToken = _configsBool[uint(OptionBool.ADMIN_FEE_PAYOUT_TOKENS)];&#13;
&#13;
        // @dev Test the validity of _configsUint.&#13;
        // Number of decimals used for admin fee greater than cap!&#13;
        require(adminFeePercentageDecimals &lt;= FEE_PERCENTAGE_DECIMAL_CAP);&#13;
        // Max contribution is greater than max allocation!&#13;
        require(maxContribution &lt;= maxAllocation);&#13;
        // Minimum contribution is greater than max contribution!&#13;
        require(minContribution &lt;= maxContribution);&#13;
&#13;
        // Verify the admin fee is less than 100%.&#13;
        feePercentageDivisor = (10 ** adminFeePercentageDecimals).mul(100);&#13;
        // Admin fee percentage is &gt;= %100!&#13;
        require(adminFeePercentage &lt; feePercentageDivisor);&#13;
    }&#13;
}&#13;
&#13;
&#13;
/// @title Whitelist configurations for Pool.sol contracts.&#13;
contract Whitelist is Config {&#13;
    mapping(address =&gt; bool) public whitelist;&#13;
&#13;
    /// @dev Checks to see if the pool whitelist is enabled.&#13;
    modifier isWhitelistEnabled() {&#13;
        // Pool is not whitelisted!&#13;
        require(hasWhitelist);&#13;
        _;&#13;
    }&#13;
&#13;
    /// @dev If the pool is whitelisted, verifies the user is whitelisted.&#13;
    modifier canDeposit(address _user) {&#13;
        if (hasWhitelist) {&#13;
            // User is not whitelisted!&#13;
            require(whitelist[_user] != false);&#13;
        }&#13;
        _;&#13;
    }&#13;
&#13;
    /// @notice Adds a list of addresses to this pools whitelist.&#13;
    /// @dev Forwards a call to the internal method.&#13;
    /// Requires:&#13;
    ///     - Msg.sender is an admin&#13;
    /// @param _users The list of addresses to add to the whitelist.&#13;
    function addAddressesToWhitelist(address[] _users) public isAdmin {&#13;
        addAddressesToWhitelistInternal(_users);&#13;
    }&#13;
&#13;
    /// @dev The internal version of adding addresses to the whitelist.&#13;
    /// This is called directly when initializing the pool from the poolParty.&#13;
    /// Requires:&#13;
    ///     - The white list configuration enabled&#13;
    /// @param _users The list of addresses to add to the whitelist.&#13;
    function addAddressesToWhitelistInternal(&#13;
        address[] _users&#13;
    )&#13;
        internal&#13;
        isWhitelistEnabled&#13;
    {&#13;
        // Cannot add an empty list to whitelist!&#13;
        require(_users.length &gt; 0);&#13;
&#13;
        for (uint256 i = 0; i &lt; _users.length; ++i) {&#13;
            whitelist[_users[i]] = true;&#13;
        }&#13;
    }&#13;
}&#13;
&#13;
&#13;
/// @title Pool contract functionality and configurations.&#13;
contract Pool is Whitelist {&#13;
    /// @dev Address points to a boolean indicating if the address has participated in the pool.&#13;
    /// Even if they have been refunded and balance is zero&#13;
    /// This mapping internally helps us prevent duplicates from being pushed into swimmersList&#13;
    /// instead of iterating and popping from the list each time a users balance reaches 0.&#13;
    mapping(address =&gt; bool) public invested;&#13;
&#13;
    /// @dev Address points to the current amount of wei the address has contributed to the pool.&#13;
    /// Even after the wei has been transferred out.&#13;
    /// Because the claim tokens function uses swimmers balances to calculate their claimable tokens.&#13;
    mapping(address =&gt; uint256) public swimmers;&#13;
    mapping(address =&gt; uint256) public swimmerReimbursements;&#13;
    mapping(address =&gt; mapping(address =&gt; uint256)) public swimmersTokensPaid;&#13;
    mapping(address =&gt; uint256) public totalTokensDistributed;&#13;
    mapping(address =&gt; bool) public adminFeePaid;&#13;
&#13;
    address[] public swimmersList;&#13;
    address[] public tokenAddress;&#13;
&#13;
    address public poolPartyAddress;&#13;
    uint256 public adminWeiFee;&#13;
    uint256 public poolId;&#13;
    uint256 public weiRaised;&#13;
    uint256 public reimbursementTotal;&#13;
&#13;
    event AdminFeePayout(uint256 value);&#13;
    event Deposit(address recipient, uint256 value);&#13;
    event EtherTransferredOut(uint256 value);&#13;
    event ProjectReimbursed(uint256 value);&#13;
    event Refund(address recipient, uint256 value);&#13;
    event ReimbursementClaimed(address recipient, uint256 value);&#13;
    event TokenAdded(address tokenAddress);&#13;
    event TokenRemoved(address tokenAddress);&#13;
    event TokenClaimed(address recipient, uint256 value, address tokenAddress);&#13;
&#13;
    /// @dev Verifies the msg.sender is the owner.&#13;
    modifier isOwner() {&#13;
        // This is not the owner!&#13;
        require(msg.sender == owner);&#13;
        _;&#13;
    }&#13;
&#13;
    /// @dev Makes sure that the amount being transferred + the total amount previously sent&#13;
    /// is compliant with the configurations for the existing pool.&#13;
    modifier depositIsConfigCompliant() {&#13;
        // Value sent must be greater than 0!&#13;
        require(msg.value &gt; 0);&#13;
        uint256 totalRaised = weiRaised.add(msg.value);&#13;
        uint256 amount = swimmers[msg.sender].add(msg.value);&#13;
&#13;
        // Contribution will cause pool to be greater than max allocation!&#13;
        require(totalRaised &lt;= maxAllocation);&#13;
        // Contribution is greater than max contribution!&#13;
        require(amount &lt;= maxContribution);&#13;
        // Contribution is less than minimum contribution!&#13;
        require(amount &gt;= minContribution);&#13;
        _;&#13;
    }&#13;
&#13;
    /// @dev Verifies the user currently has funds in the pool.&#13;
    modifier userHasFundedPool(address _user) {&#13;
        // User does not have funds in the pool!&#13;
        require(swimmers[_user] &gt; 0);&#13;
        _;&#13;
    }&#13;
&#13;
    /// @dev Verifies the index parameters are valid/not out of bounds.&#13;
    modifier isValidIndex(uint256 _startIndex, uint256 _numberOfAddresses) {&#13;
        uint256 endIndex = _startIndex.add(_numberOfAddresses.sub(1));&#13;
&#13;
        // The starting index is out of the array bounds!&#13;
        require(_startIndex &lt; swimmersList.length);&#13;
        // The end index is out of the array bounds!&#13;
        require(endIndex &lt; swimmersList.length);&#13;
        _;&#13;
    }&#13;
&#13;
    /// @notice Creates a new pool with the parameters as custom configurations.&#13;
    /// @dev Creates a new pool where:&#13;
    ///     - The creator of the pool will be the owner&#13;
    ///     - _admins become administrators for the pool contract and are automatically&#13;
    ///      added to whitelist, if it is enabled in the _configsBool&#13;
    ///     - Pool is initialised with the state set to OPEN&#13;
    /// @param _poolOwner The owner of the new pool.&#13;
    /// @param _admins The list of admin addresses for the new pools. This list must include&#13;
    /// the creator of the pool.&#13;
    /// @param _configsUint Contains all of the uint256 configurations for the new pool.&#13;
    ///     - MAX_ALLOCATION&#13;
    ///     - MIN_CONTRIBUTION&#13;
    ///     - MAX_CONTRIBUTION&#13;
    ///     - ADMIN_FEE_PERCENT_DECIMALS&#13;
    ///     - ADMIN_FEE_PERCENTAGE&#13;
    /// @param _configsBool Contains all of the boolean configurations for the new pool.&#13;
    ///     - HAS_WHITELIST&#13;
    ///     - ADMIN_FEE_PAYOUT&#13;
    /// @param _poolId The corresponding poolId.&#13;
    constructor(&#13;
        address _poolOwner,&#13;
        address[] _admins,&#13;
        uint256[] _configsUint,&#13;
        bool[] _configsBool,&#13;
        uint256  _poolId&#13;
    )&#13;
        public&#13;
    {&#13;
        owner = _poolOwner;&#13;
        state = PoolState.OPEN;&#13;
        poolPartyAddress = msg.sender;&#13;
        poolId = _poolId;&#13;
&#13;
        createAdminsForPool(_admins);&#13;
        createConfigsForPool(_configsUint, _configsBool);&#13;
&#13;
        if (hasWhitelist) {&#13;
            addAddressesToWhitelistInternal(admins);&#13;
        }&#13;
&#13;
        emit PoolIsOpen();&#13;
    }&#13;
&#13;
    /// @notice The user sends Ether to the pool.&#13;
    /// @dev Calls the deposit function on behalf of the msg.sender.&#13;
    function() public payable {&#13;
        deposit(msg.sender);&#13;
    }&#13;
&#13;
    /// @notice Returns the array of admin addresses.&#13;
    /// @dev This is used specifically for the Web3 DAPP portion of PoolParty,&#13;
    /// as the EVM will not allow contracts to return dynamically sized arrays.&#13;
    /// @return Returns and instance of the admins array.&#13;
    function getAdminAddressArray(&#13;
    )&#13;
        public&#13;
        view&#13;
        returns (address[] _arrayToReturn)&#13;
    {&#13;
        _arrayToReturn = admins;&#13;
    }&#13;
&#13;
    /// @notice Returns the array of token addresses.&#13;
    /// @dev This is used specifically for the Web3 DAPP portion of PoolParty,&#13;
    /// as the EVM will not allow contracts to return dynamically sized arrays.&#13;
    /// @return Returns and instance of the tokenAddress array.&#13;
    function getTokenAddressArray(&#13;
    )&#13;
        public&#13;
        view&#13;
        returns (address[] _arrayToReturn)&#13;
    {&#13;
        _arrayToReturn = tokenAddress;&#13;
    }&#13;
&#13;
    /// @notice Returns the amount of tokens currently in this contract.&#13;
    /// @dev This is used specifically for the Web3 DAPP portion of PoolParty.&#13;
    /// @return Returns the length of the tokenAddress arrau.&#13;
    function getAmountOfTokens(&#13;
    )&#13;
        public&#13;
        view&#13;
        returns (uint256 _lengthOfTokens)&#13;
    {&#13;
        _lengthOfTokens = tokenAddress.length;&#13;
    }&#13;
&#13;
    /// @notice Returns the array of swimmers addresses.&#13;
    /// @dev This is used specifically for the DAPP portion of PoolParty,&#13;
    /// as the EVM will not allow contracts to return dynamically sized arrays.&#13;
    /// @return Returns and instance of the swimmersList array.&#13;
    function getSwimmersListArray(&#13;
    )&#13;
        public&#13;
        view&#13;
        returns (address[] _arrayToReturn)&#13;
    {&#13;
        _arrayToReturn = swimmersList;&#13;
    }&#13;
&#13;
    /// @notice Returns the amount of swimmers currently in this contract.&#13;
    /// @dev This is used specifically for the Web3 DAPP portion of PoolParty.&#13;
    /// @return Returns the length of the swimmersList array.&#13;
    function getAmountOfSwimmers(&#13;
    )&#13;
        public&#13;
        view&#13;
        returns (uint256 _lengthOfSwimmers)&#13;
    {&#13;
        _lengthOfSwimmers = swimmersList.length;&#13;
    }&#13;
&#13;
    /// @notice Deposit Ether where the contribution is credited to the address specified in the parameter.&#13;
    /// @dev Allows a user to deposit on the behalf of someone else. Emits a Deposit event on success.&#13;
    /// Requires:&#13;
    ///     - The pool state is set to OPEN&#13;
    ///     - The amount is &gt; 0&#13;
    ///     - The amount complies with the configurations of the pool&#13;
    ///     - If the whitelist configuration is enabled, verify the _user can deposit&#13;
    /// @param _user The address that will be credited with the deposit.&#13;
    function deposit(&#13;
        address _user&#13;
    )&#13;
        public&#13;
        payable&#13;
        isOpen&#13;
        depositIsConfigCompliant&#13;
        canDeposit(_user)&#13;
    {&#13;
        if (!invested[_user]) {&#13;
            swimmersList.push(_user);&#13;
            invested[_user] = true;&#13;
        }&#13;
&#13;
        weiRaised = weiRaised.add(msg.value);&#13;
        swimmers[_user] = swimmers[_user].add(msg.value);&#13;
&#13;
        emit Deposit(msg.sender, msg.value);&#13;
    }&#13;
&#13;
    /// @notice Process a refund.&#13;
    /// @dev Allows refunds in the contract. Calls the internal refund function.&#13;
    /// Requires:&#13;
    ///     - The state of the pool is either OPEN or CANCELLED&#13;
    ///     - The user currently has funds in the pool&#13;
    function refund() public isUserRefundable userHasFundedPool(msg.sender) {&#13;
        processRefundInternal(msg.sender);&#13;
    }&#13;
&#13;
    /// @notice This triggers a refund event for a subset of users.&#13;
    /// @dev Uses the internal refund function.&#13;
    /// Requires:&#13;
    ///     - The pool state is currently set to CANCELLED&#13;
    ///     - The indexes are within the bounds of the swimmersList&#13;
    /// @param _startIndex The starting index for the subset.&#13;
    /// @param _numberOfAddresses The number of addresses to include past the starting index.&#13;
    function refundManyAddresses(&#13;
        uint256 _startIndex,&#13;
        uint256 _numberOfAddresses&#13;
    )&#13;
        public&#13;
        isCancelled&#13;
        isValidIndex(_startIndex, _numberOfAddresses)&#13;
    {&#13;
        uint256 endIndex = _startIndex.add(_numberOfAddresses.sub(1));&#13;
&#13;
        for (uint256 i = _startIndex; i &lt;= endIndex; ++i) {&#13;
            address user = swimmersList[i];&#13;
&#13;
            if (swimmers[user] &gt; 0) {&#13;
                processRefundInternal(user);&#13;
            }&#13;
        }&#13;
    }&#13;
&#13;
    /// @notice claims available tokens.&#13;
    /// @dev Allows the user to claim their available tokens.&#13;
    /// Requires:&#13;
    ///     - The msg.sender has funded the pool&#13;
    function claim() public {&#13;
        claimAddress(msg.sender);&#13;
    }&#13;
&#13;
    /// @notice Process a claim function for a specified address.&#13;
    /// @dev Allows the user to claim tokens on behalf of someone else.&#13;
    /// Requires:&#13;
    ///     - The _address has funded the pool&#13;
    ///     - The pool is in the completed state&#13;
    /// @param _address The address for which tokens should be redeemed.&#13;
    function claimAddress(&#13;
        address _address&#13;
    )&#13;
        public&#13;
        isCompleted&#13;
        userHasFundedPool(_address)&#13;
    {&#13;
        for (uint256 i = 0; i &lt; tokenAddress.length; ++i) {&#13;
            ERC20Basic token = ERC20Basic(tokenAddress[i]);&#13;
            uint256 poolTokenBalance = token.balanceOf(this);&#13;
&#13;
            payoutTokensInternal(_address, poolTokenBalance, token);&#13;
        }&#13;
    }&#13;
&#13;
    /// @notice Distribute available tokens to a subset of users.&#13;
    /// @dev Allows anyone to call claim on a specified series of addresses.&#13;
    /// Requires:&#13;
    ///     - The indexes are within the bounds of the swimmersList&#13;
    /// @param _startIndex The starting index for the subset.&#13;
    /// @param _numberOfAddresses The number of addresses to include past the starting index.&#13;
    function claimManyAddresses(&#13;
        uint256 _startIndex,&#13;
        uint256 _numberOfAddresses&#13;
    )&#13;
        public&#13;
        isValidIndex(_startIndex, _numberOfAddresses)&#13;
    {&#13;
        uint256 endIndex = _startIndex.add(_numberOfAddresses.sub(1));&#13;
&#13;
        claimAddressesInternal(_startIndex, endIndex);&#13;
    }&#13;
&#13;
    /// @notice Process a reimbursement claim.&#13;
    /// @dev Allows the msg.sender to claim a reimbursement&#13;
    /// Requires:&#13;
    ///     - The msg.sender has a reimbursement to withdraw&#13;
    ///     - The pool state is currently set to AwaitingOrCompleted&#13;
    function reimbursement() public {&#13;
        claimReimbursement(msg.sender);&#13;
    }&#13;
&#13;
    /// @notice Process a reimbursement claim for a specified address.&#13;
    /// @dev Calls the internal method responsible for processing a reimbursement.&#13;
    /// Requires:&#13;
    ///     - The specified user has a reimbursement to withdraw&#13;
    ///     - The pool state is currently set to AwaitingOrCompleted&#13;
    /// @param _user The user having the reimbursement processed.&#13;
    function claimReimbursement(&#13;
        address _user&#13;
    )&#13;
        public&#13;
        isAwaitingOrCompleted&#13;
        userHasFundedPool(_user)&#13;
    {&#13;
        processReimbursementInternal(_user);&#13;
    }&#13;
&#13;
    /// @notice Process a reimbursement claim for subset of addresses.&#13;
    /// @dev Allows anyone to call claimReimbursement on a specified series of address indexes.&#13;
    /// Requires:&#13;
    ///     - The pool state is currently set to AwaitingOrCompleted&#13;
    ///     - The indexes are within the bounds of the swimmersList&#13;
    /// @param _startIndex The starting index for the subset.&#13;
    /// @param _numberOfAddresses The number of addresses to include past the starting index.&#13;
    function claimManyReimbursements(&#13;
        uint256 _startIndex,&#13;
        uint256 _numberOfAddresses&#13;
    )&#13;
        public&#13;
        isAwaitingOrCompleted&#13;
        isValidIndex(_startIndex, _numberOfAddresses)&#13;
    {&#13;
        uint256 endIndex = _startIndex.add(_numberOfAddresses.sub(1));&#13;
&#13;
        for (uint256 i = _startIndex; i &lt;= endIndex; ++i) {&#13;
            address user = swimmersList[i];&#13;
&#13;
            if (swimmers[user] &gt; 0) {&#13;
                processReimbursementInternal(user);&#13;
            }&#13;
        }&#13;
    }&#13;
&#13;
    /// @notice Set a new token address where users can redeem ERC20 tokens.&#13;
    /// @dev Adds a new ERC20 address to the tokenAddress array.&#13;
    /// Sets the pool state to COMPLETED if it is not already.&#13;
    /// Crucial that only valid ERC20 addresses be added with this function.&#13;
    /// In the event a bad one is entered, it can be removed with the removeToken() method.&#13;
    /// Requires:&#13;
    ///     - The msg.sender is an admin&#13;
    ///     - The pool state is set to either AWAITING_TOKENS or COMPLETED&#13;
    ///     - The token address has not previously been added&#13;
    /// @param _tokenAddress The ERC20 address users can redeem from.&#13;
    function addToken(&#13;
        address _tokenAddress&#13;
    )&#13;
        public&#13;
        isAdmin&#13;
        isAwaitingOrCompleted&#13;
    {&#13;
        if (state != PoolState.COMPLETED) {&#13;
            setPoolToCompleted();&#13;
        }&#13;
&#13;
        for (uint256 i = 0; i &lt; tokenAddress.length; ++i) {&#13;
            // The address has already been added!&#13;
            require(tokenAddress[i] != _tokenAddress);&#13;
        }&#13;
&#13;
        // @dev This verifies the address we are trying to add contains an ERC20 address.&#13;
        // This does not completely protect from having a bad address added, but it will reduce the likelihood.&#13;
        // Any address that does not contain a balanceOf() method cannot be added.&#13;
        ERC20Basic token = ERC20Basic(_tokenAddress);&#13;
&#13;
        // The address being added is not an ERC20!&#13;
        require(token.balanceOf(this) &gt;= 0);&#13;
&#13;
        tokenAddress.push(_tokenAddress);&#13;
&#13;
        emit TokenAdded(_tokenAddress);&#13;
    }&#13;
&#13;
    /// @notice Remove a token address from the list of token addresses.&#13;
    /// @dev Removes a token address. This prevents users from calling claim on it. Does not preserve order.&#13;
    /// If it reduces the tokenAddress length to zero, then the state is set back to awaiting tokens.&#13;
    /// Requires:&#13;
    ///     - The msg.sender is an admin&#13;
    ///     - The pool state is set to COMPLETED&#13;
    ///     - The token address is located in the list.&#13;
    /// @param _tokenAddress The address to remove.&#13;
    function removeToken(address _tokenAddress) public isAdmin isCompleted {&#13;
        for (uint256 i = 0; i &lt; tokenAddress.length; ++i) {&#13;
            if (tokenAddress[i] == _tokenAddress) {&#13;
                tokenAddress[i] = tokenAddress[tokenAddress.length - 1];&#13;
                delete tokenAddress[tokenAddress.length - 1];&#13;
                tokenAddress.length--;&#13;
                break;&#13;
            }&#13;
        }&#13;
&#13;
        if (tokenAddress.length == 0) {&#13;
            setPoolToAwaitingTokens();&#13;
        }&#13;
&#13;
        emit TokenRemoved(_tokenAddress);&#13;
    }&#13;
&#13;
    /// @notice Removes a user from the whitelist and processes a refund.&#13;
    /// @dev Removes a user from the whitelist and their ability to contribute to the pool.&#13;
    /// Requires:&#13;
    ///     - The msg.sender is an admin&#13;
    ///     - The pool state is currently set to OPEN or CLOSED or CANCELLED&#13;
    ///     - The pool has enabled whitelist functionality&#13;
    /// @param _address The address for which the refund is processed and removed from whitelist.&#13;
    function removeAddressFromWhitelistAndRefund(&#13;
        address _address&#13;
    )&#13;
        public&#13;
        isWhitelistEnabled&#13;
        canDeposit(_address)&#13;
    {&#13;
        whitelist[_address] = false;&#13;
        refundAddress(_address);&#13;
    }&#13;
&#13;
    /// @notice Refund a given address for all the Ether they have contributed.&#13;
    /// @dev Processes a refund for a given address by calling the internal refund function.&#13;
    /// Requires:&#13;
    ///     - The msg.sender is an admin&#13;
    ///     - The pool state is currently set to OPEN or CLOSED or CANCELLED&#13;
    /// @param _address The address for which the refund is processed.&#13;
    function refundAddress(&#13;
        address _address&#13;
    )&#13;
        public&#13;
        isAdmin&#13;
        isAdminRefundable&#13;
        userHasFundedPool(_address)&#13;
    {&#13;
        processRefundInternal(_address);&#13;
    }&#13;
&#13;
    /// @notice Provides a refund for the entire list of swimmers&#13;
    /// to distribute at a pro-rata rate via the reimbursement functions.&#13;
    /// @dev Refund users after the pool state is set to AWAITING_TOKENS or COMPLETED.&#13;
    /// Requires:&#13;
    ///     - The msg.sender is an admin&#13;
    ///     - The state is either Awaiting or Completed&#13;
    function projectReimbursement(&#13;
    )&#13;
        public&#13;
        payable&#13;
        isAdmin&#13;
        isAwaitingOrCompleted&#13;
    {&#13;
        reimbursementTotal = reimbursementTotal.add(msg.value);&#13;
&#13;
        emit ProjectReimbursed(msg.value);&#13;
    }&#13;
&#13;
    /// @notice Sets the maximum allocation for the contract.&#13;
    /// @dev Set the uint256 configuration for maxAllocation to the _newMax parameter.&#13;
    /// If the amount of weiRaised so far is already past the limit,&#13;
    //  no further deposits can be made until the weiRaised is reduced&#13;
    /// Possibly by refunding some users.&#13;
    /// Requires:&#13;
    ///     - The msg.sender is an admin&#13;
    ///     - The pool state is currently set to OPEN or CLOSED&#13;
    ///     - The _newMax must be &gt;= max contribution&#13;
    /// @param _newMax The new maximum allocation for this pool contract.&#13;
    function setMaxAllocation(uint256 _newMax) public isAdmin isOpenOrClosed {&#13;
        // Max Allocation cannot be below Max contribution!&#13;
        require(_newMax &gt;= maxContribution);&#13;
&#13;
        maxAllocation = _newMax;&#13;
    }&#13;
&#13;
    /// @notice Transfers the Ether out of the contract to the given address parameter.&#13;
    /// @dev If admin fee is &gt; 0, then call payOutAdminFee to distribute the admin fee.&#13;
    /// Sets the pool state to AWAITING_TOKENS.&#13;
    /// Requires:&#13;
    ///     - The pool state must be currently set to CLOSED&#13;
    ///     - msg.sender is the owner&#13;
    /// @param _contractAddress The address to send all Ether in the pool.&#13;
    function transferWei(address _contractAddress) public isOwner isClosed {&#13;
        uint256 weiForTransfer = weiTransferCalculator();&#13;
&#13;
        if (adminFeePercentage &gt; 0) {&#13;
            weiForTransfer = payOutAdminFee(weiForTransfer);&#13;
        }&#13;
&#13;
        // No Ether to transfer!&#13;
        require(weiForTransfer &gt; 0);&#13;
        _contractAddress.transfer(weiForTransfer);&#13;
&#13;
        setPoolToAwaitingTokens();&#13;
&#13;
        emit EtherTransferredOut(weiForTransfer);&#13;
    }&#13;
&#13;
    /// @dev Calculates the amount of wei to be transferred out of the contract.&#13;
    /// Adds the difference to the refund total for participants to withdraw pro-rata from.&#13;
    /// @return The difference between amount raised and the max allocation.&#13;
    function weiTransferCalculator() internal returns (uint256 _amountOfWei) {&#13;
        if (weiRaised &gt; maxAllocation) {&#13;
            _amountOfWei = maxAllocation;&#13;
            reimbursementTotal = reimbursementTotal.add(weiRaised.sub(maxAllocation));&#13;
        } else {&#13;
            _amountOfWei = weiRaised;&#13;
        }&#13;
    }&#13;
&#13;
    /// @dev Payout the owner of this contract, based on the adminFeePayoutIsToken boolean.&#13;
    ///  - adminFeePayoutIsToken == true -&gt; The payout is in tokens.&#13;
    /// Each member will have their portion deducted from their contribution before claiming tokens.&#13;
    ///  - adminFeePayoutIsToken == false -&gt; The adminFee is deducted from the total amount of wei&#13;
    /// that would otherwise be transferred out of the contract.&#13;
    /// @return The amount of wei that will be transferred out of this function.&#13;
    function payOutAdminFee(&#13;
        uint256 _weiTotal&#13;
    )&#13;
        internal&#13;
        returns (uint256 _weiForTransfer)&#13;
    {&#13;
        adminWeiFee = _weiTotal.mul(adminFeePercentage).div(feePercentageDivisor);&#13;
&#13;
        if (adminFeePayoutIsToken) {&#13;
            // @dev In the event the owner has wei currently contributed to the pool,&#13;
            // their fee is collected before they get credited on line 420.&#13;
            if (swimmers[owner] &gt; 0) {&#13;
                collectAdminFee(owner);&#13;
            } else {&#13;
                // @dev In the event the owner has never contributed to the pool,&#13;
                // they have their address added so they can be iterated over in the claim all method.&#13;
                if (!invested[owner]) {&#13;
                    swimmersList.push(owner);&#13;
                    invested[owner] = true;&#13;
                }&#13;
&#13;
                adminFeePaid[owner] = true;&#13;
            }&#13;
&#13;
            // @dev The admin gets credited for his fee upfront.&#13;
            // Then the first time a swimmer claims their tokens, they will have their portion&#13;
            // of the fee deducted from their contribution, via the collectAdminFee() method.&#13;
            swimmers[owner] = swimmers[owner].add(adminWeiFee);&#13;
            _weiForTransfer = _weiTotal;&#13;
        } else {&#13;
            _weiForTransfer = _weiTotal.sub(adminWeiFee);&#13;
&#13;
            if (adminWeiFee &gt; 0) {&#13;
                owner.transfer(adminWeiFee);&#13;
&#13;
                emit AdminFeePayout(adminWeiFee);&#13;
            }&#13;
        }&#13;
    }&#13;
&#13;
    /// @dev The internal claim function for distributing available tokens.&#13;
    /// Goes through each of the token addresses set by the addToken function,&#13;
    /// and calculates a pro-rata rate for each pool participant to be distributed.&#13;
    /// In the event that a bad token address is present, and the transfer function fails,&#13;
    /// this method cannot be processed until&#13;
    /// the bad address has been removed via the removeToken() method.&#13;
    /// Requires:&#13;
    ///     - The pool state must be set to COMPLETED&#13;
    ///     - The tokenAddress array must contain ERC20 compliant addresses.&#13;
    /// @param _startIndex The index we start iterating from.&#13;
    /// @param _endIndex The last index we process.&#13;
    function claimAddressesInternal(&#13;
        uint256 _startIndex,&#13;
        uint256 _endIndex&#13;
    )&#13;
        internal&#13;
        isCompleted&#13;
    {&#13;
        for (uint256 i = 0; i &lt; tokenAddress.length; ++i) {&#13;
            ERC20Basic token = ERC20Basic(tokenAddress[i]);&#13;
            uint256 tokenBalance = token.balanceOf(this);&#13;
&#13;
            for (uint256 j = _startIndex; j &lt;= _endIndex &amp;&amp; tokenBalance &gt; 0; ++j) {&#13;
                address user = swimmersList[j];&#13;
&#13;
                if (swimmers[user] &gt; 0) {&#13;
                    payoutTokensInternal(user, tokenBalance, token);&#13;
                }&#13;
&#13;
                tokenBalance = token.balanceOf(this);&#13;
            }&#13;
        }&#13;
    }&#13;
&#13;
    /// @dev Calculates the amount of tokens to be paid out for a given user.&#13;
    /// Emits a TokenClaimed event upon success.&#13;
    /// @param _user The user claiming tokens.&#13;
    /// @param _poolBalance The current balance the pool has for the given token.&#13;
    /// @param _token The token currently being calculated for.&#13;
    function payoutTokensInternal(&#13;
        address _user,&#13;
        uint256 _poolBalance,&#13;
        ERC20Basic _token&#13;
    )&#13;
        internal&#13;
    {&#13;
        // @dev The first time a user tries to claim tokens,&#13;
        // they will have the admin fee subtracted from their contribution.&#13;
        // This is the pro-rata portion added to swimmers[owner], in the payoutAdminFee() function.&#13;
        if (!adminFeePaid[_user] &amp;&amp; adminFeePayoutIsToken &amp;&amp; adminFeePercentage &gt; 0) {&#13;
            collectAdminFee(_user);&#13;
        }&#13;
&#13;
        // The total amount of tokens the contract has received.&#13;
        uint256 totalTokensReceived = _poolBalance.add(totalTokensDistributed[_token]);&#13;
&#13;
        uint256 tokensOwedTotal = swimmers[_user].mul(totalTokensReceived).div(weiRaised);&#13;
        uint256 tokensPaid = swimmersTokensPaid[_user][_token];&#13;
        uint256 tokensToBePaid = tokensOwedTotal.sub(tokensPaid);&#13;
&#13;
        if (tokensToBePaid &gt; 0) {&#13;
            swimmersTokensPaid[_user][_token] = tokensOwedTotal;&#13;
            totalTokensDistributed[_token] = totalTokensDistributed[_token].add(tokensToBePaid);&#13;
&#13;
            // Token transfer failed!&#13;
            require(_token.transfer(_user, tokensToBePaid));&#13;
&#13;
            emit TokenClaimed(_user, tokensToBePaid, _token);&#13;
        }&#13;
    }&#13;
&#13;
    /// @dev Processes a reimbursement claim for a given address.&#13;
    /// Emits a ReimbursementClaimed event for each successful iteration.&#13;
    /// @param _user The address being processed.&#13;
    function processReimbursementInternal(address _user) internal {&#13;
        // @dev The first time a user tries to claim tokens or a Reimbursement,&#13;
        // they will have the admin fee subtracted from their contribution.&#13;
        // This is the pro-rata portion added to swimmers[owner], in the payoutAdminFee() function.&#13;
        if (!adminFeePaid[_user] &amp;&amp; adminFeePayoutIsToken &amp;&amp; adminFeePercentage &gt; 0) {&#13;
            collectAdminFee(_user);&#13;
        }&#13;
&#13;
        // @dev Using integer division, there is the potential to truncate the result.&#13;
        // The effect is negligible because it is calculated in wei.&#13;
        // There will be dust, but the cost of gas for transferring it out, costs more than it is worth.&#13;
        uint256 amountContributed = swimmers[_user];&#13;
        uint256 totalReimbursement = reimbursementTotal.mul(amountContributed).div(weiRaised);&#13;
        uint256 alreadyReimbursed = swimmerReimbursements[_user];&#13;
&#13;
        uint256 reimbursementAvailable = totalReimbursement.sub(alreadyReimbursed);&#13;
&#13;
        if (reimbursementAvailable &gt; 0) {&#13;
            swimmerReimbursements[_user] = swimmerReimbursements[_user].add(reimbursementAvailable);&#13;
            _user.transfer(reimbursementAvailable);&#13;
&#13;
            emit ReimbursementClaimed(_user, reimbursementAvailable);&#13;
        }&#13;
    }&#13;
&#13;
    /// @dev Subtracts the admin fee from the user's contribution.&#13;
    /// This should only happen once per user.&#13;
    /// Requires:&#13;
    ///     - This is the first time a user has tried to claim tokens or a reimbursement.&#13;
    /// @param _user The user who is paying the admin fee.&#13;
    function collectAdminFee(address _user) internal {&#13;
        uint256 individualFee = swimmers[_user].mul(adminFeePercentage).div(feePercentageDivisor);&#13;
&#13;
        // @dev adding 1 to the fee is for rounding errors.&#13;
        // This will result in some left over dust, but it will cost more to transfer, than gained.&#13;
        individualFee = individualFee.add(1);&#13;
        swimmers[_user] = swimmers[_user].sub(individualFee);&#13;
&#13;
        // Indicates the user has paid their fee.&#13;
        adminFeePaid[_user] = true;&#13;
    }&#13;
&#13;
    /// @dev Processes a refund for a given address.&#13;
    /// Emits a Refund event for each successful iteration.&#13;
    /// @param _user The address for which the refund is processed.&#13;
    function processRefundInternal(address _user) internal {&#13;
        uint256 amount = swimmers[_user];&#13;
&#13;
        swimmers[_user] = 0;&#13;
        weiRaised = weiRaised.sub(amount);&#13;
        _user.transfer(amount);&#13;
&#13;
        emit Refund(_user, amount);&#13;
    }&#13;
}