pragma solidity ^0.4.19;

library SafeMath {

  /**
  * @dev Multiplies two numbers, throws on overflow.
  */
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }

  /**
  * @dev Integer division of two numbers, truncating the quotient.
  */
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    // assert(b > 0); // Solidity automatically throws when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return c;
  }

  /**
  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).
  */
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  /**
  * @dev Adds two numbers, throws on overflow.
  */
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }
}

/// @title Interface for contracts conforming to ERC-721: Non-Fungible Tokens
/// @author Dieter Shirley <<span class="__cf_email__" data-cfemail="c4a0a1b0a184a5bcadaba9bea1aaeaa7ab">[emailÂ protected]</span>&gt; (https://github.com/dete)&#13;
contract ERC721 {&#13;
    // Required methods&#13;
    function totalSupply() public view returns (uint256 total);&#13;
    function balanceOf(address _owner) public view returns (uint256 balance);&#13;
    function ownerOf(uint256 _tokenId) public view returns (address owner);&#13;
    function approve(address _to, uint256 _tokenId) public;&#13;
    function transfer(address _to, uint256 _tokenId) public;&#13;
    function transferFrom(address _from, address _to, uint256 _tokenId) public;&#13;
&#13;
    // Events&#13;
    event Transfer(address from, address to, uint256 tokenId);&#13;
    event Approval(address owner, address approved, uint256 tokenId);&#13;
&#13;
    // Optional&#13;
    // function name() public view returns (string name);&#13;
    // function symbol() public view returns (string symbol);&#13;
    // function tokensOfOwner(address _owner) external view returns (uint256[] tokenIds);&#13;
    // function tokenMetadata(uint256 _tokenId, string _preferredTransport) public view returns (string infoUrl);&#13;
&#13;
    // ERC-165 Compatibility (https://github.com/ethereum/EIPs/issues/165)&#13;
    // function supportsInterface(bytes4 _interfaceID) external view returns (bool);&#13;
}&#13;
&#13;
contract CryptoWaterMargin is ERC721{&#13;
  using SafeMath for uint256;&#13;
&#13;
  event Bought (uint256 indexed _itemId, address indexed _owner, uint256 _price);&#13;
  event Sold (uint256 indexed _itemId, address indexed _owner, uint256 _price);&#13;
  event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);&#13;
  event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);&#13;
&#13;
  address private owner;&#13;
  mapping (address =&gt; bool) private admins;&#13;
  IItemRegistry private itemRegistry;&#13;
&#13;
  uint256 private increaseLimit1 = 0.02 ether;&#13;
  uint256 private increaseLimit2 = 0.5 ether;&#13;
  uint256 private increaseLimit3 = 2.0 ether;&#13;
  uint256 private increaseLimit4 = 5.0 ether;&#13;
&#13;
  uint256[] private listedItems;&#13;
  mapping (uint256 =&gt; address) private ownerOfItem;&#13;
  mapping (uint256 =&gt; uint256) private priceOfItem;&#13;
  mapping (uint256 =&gt; address) private approvedOfItem;&#13;
&#13;
  function CryptoWaterMargin () public {&#13;
    owner = msg.sender;&#13;
    admins[owner] = true;    &#13;
    issueCard(1, 6, 0.1 ether);&#13;
  }&#13;
&#13;
  /* Modifiers */&#13;
  modifier onlyOwner() {&#13;
    require(owner == msg.sender);&#13;
    _;&#13;
  }&#13;
&#13;
  modifier onlyAdmins() {&#13;
    require(admins[msg.sender]);&#13;
    _;&#13;
  }&#13;
&#13;
  /* Owner */&#13;
  function setOwner (address _owner) onlyOwner() public {&#13;
    owner = _owner;&#13;
  }&#13;
&#13;
  function setItemRegistry (address _itemRegistry) onlyOwner() public {&#13;
    itemRegistry = IItemRegistry(_itemRegistry);&#13;
  }&#13;
&#13;
  function addAdmin (address _admin) onlyOwner() public {&#13;
    admins[_admin] = true;&#13;
  }&#13;
&#13;
  function removeAdmin (address _admin) onlyOwner() public {&#13;
    delete admins[_admin];&#13;
  }&#13;
&#13;
  /* Withdraw */&#13;
  /*&#13;
    NOTICE: These functions withdraw the developer's cut which is left&#13;
    in the contract by `buy`. User funds are immediately sent to the old&#13;
    owner in `buy`, no user funds are left in the contract.&#13;
  */&#13;
  function withdrawAll () onlyAdmins() public {&#13;
   msg.sender.transfer(this.balance);&#13;
  }&#13;
&#13;
  function withdrawAmount (uint256 _amount) onlyAdmins() public {&#13;
    msg.sender.transfer(_amount);&#13;
  }&#13;
&#13;
  /* Listing */&#13;
  function populateFromItemRegistry (uint256[] _itemIds) onlyOwner() public {&#13;
    for (uint256 i = 0; i &lt; _itemIds.length; i++) {&#13;
      if (priceOfItem[_itemIds[i]] &gt; 0 || itemRegistry.priceOf(_itemIds[i]) == 0) {&#13;
        continue;&#13;
      }&#13;
&#13;
      listItemFromRegistry(_itemIds[i]);&#13;
    }&#13;
  }&#13;
&#13;
  function listItemFromRegistry (uint256 _itemId) onlyOwner() public {&#13;
    require(itemRegistry != address(0));&#13;
    require(itemRegistry.ownerOf(_itemId) != address(0));&#13;
    require(itemRegistry.priceOf(_itemId) &gt; 0);&#13;
&#13;
    uint256 price = itemRegistry.priceOf(_itemId);&#13;
    address itemOwner = itemRegistry.ownerOf(_itemId);&#13;
    listItem(_itemId, price, itemOwner);&#13;
  }&#13;
&#13;
  function listMultipleItems (uint256[] _itemIds, uint256 _price, address _owner) onlyAdmins() external {&#13;
    for (uint256 i = 0; i &lt; _itemIds.length; i++) {&#13;
      listItem(_itemIds[i], _price, _owner);&#13;
    }&#13;
  }&#13;
&#13;
  function listItem (uint256 _itemId, uint256 _price, address _owner) onlyAdmins() public {&#13;
    require(_price &gt; 0);&#13;
    require(priceOfItem[_itemId] == 0);&#13;
    require(ownerOfItem[_itemId] == address(0));&#13;
&#13;
    ownerOfItem[_itemId] = _owner;&#13;
    priceOfItem[_itemId] = _price;&#13;
    listedItems.push(_itemId);&#13;
  }&#13;
&#13;
  /* Buying */&#13;
  function calculateNextPrice (uint256 _price) public view returns (uint256 _nextPrice) {&#13;
    if (_price &lt; increaseLimit1) {&#13;
      return _price.mul(200).div(95);&#13;
    } else if (_price &lt; increaseLimit2) {&#13;
      return _price.mul(135).div(96);&#13;
    } else if (_price &lt; increaseLimit3) {&#13;
      return _price.mul(125).div(97);&#13;
    } else if (_price &lt; increaseLimit4) {&#13;
      return _price.mul(117).div(97);&#13;
    } else {&#13;
      return _price.mul(115).div(98);&#13;
    }&#13;
  }&#13;
&#13;
  function calculateDevCut (uint256 _price) public view returns (uint256 _devCut) {&#13;
    if (_price &lt; increaseLimit1) {&#13;
      return _price.mul(5).div(100); // 5%&#13;
    } else if (_price &lt; increaseLimit2) {&#13;
      return _price.mul(4).div(100); // 4%&#13;
    } else if (_price &lt; increaseLimit3) {&#13;
      return _price.mul(3).div(100); // 3%&#13;
    } else if (_price &lt; increaseLimit4) {&#13;
      return _price.mul(3).div(100); // 3%&#13;
    } else {&#13;
      return _price.mul(2).div(100); // 2%&#13;
    }&#13;
  }&#13;
&#13;
  /*&#13;
     Buy a country directly from the contract for the calculated price&#13;
     which ensures that the owner gets a profit.  All countries that&#13;
     have been listed can be bought by this method. User funds are sent&#13;
     directly to the previous owner and are never stored in the contract.&#13;
  */&#13;
  function buy (uint256 _itemId) payable public {&#13;
    require(priceOf(_itemId) &gt; 0);&#13;
    require(ownerOf(_itemId) != address(0));&#13;
    require(msg.value &gt;= priceOf(_itemId));&#13;
    require(ownerOf(_itemId) != msg.sender);&#13;
    require(!isContract(msg.sender));&#13;
    require(msg.sender != address(0));&#13;
&#13;
    address oldOwner = ownerOf(_itemId);&#13;
    address newOwner = msg.sender;&#13;
    uint256 price = priceOf(_itemId);&#13;
    uint256 excess = msg.value.sub(price);&#13;
&#13;
    _transfer(oldOwner, newOwner, _itemId);&#13;
    priceOfItem[_itemId] = nextPriceOf(_itemId);&#13;
&#13;
    Bought(_itemId, newOwner, price);&#13;
    Sold(_itemId, oldOwner, price);&#13;
&#13;
    // Devevloper's cut which is left in contract and accesed by&#13;
    // `withdrawAll` and `withdrawAmountTo` methods.&#13;
    uint256 devCut = calculateDevCut(price);&#13;
&#13;
    // Transfer payment to old owner minus the developer's cut.&#13;
    oldOwner.transfer(price.sub(devCut));&#13;
&#13;
    if (excess &gt; 0) {&#13;
      newOwner.transfer(excess);&#13;
    }&#13;
  }&#13;
&#13;
  /* ERC721 */&#13;
&#13;
  function name() public view returns (string name) {&#13;
    return "Cryptohero.pro";&#13;
  }&#13;
&#13;
  function symbol() public view returns (string symbol) {&#13;
    return "CTH";&#13;
  }&#13;
&#13;
  function totalSupply() public view returns (uint256 _totalSupply) {&#13;
    return listedItems.length;&#13;
  }&#13;
&#13;
  function balanceOf (address _owner) public view returns (uint256 _balance) {&#13;
    uint256 counter = 0;&#13;
&#13;
    for (uint256 i = 0; i &lt; listedItems.length; i++) {&#13;
      if (ownerOf(listedItems[i]) == _owner) {&#13;
        counter++;&#13;
      }&#13;
    }&#13;
&#13;
    return counter;&#13;
  }&#13;
&#13;
  function ownerOf (uint256 _itemId) public view returns (address _owner) {&#13;
    return ownerOfItem[_itemId];&#13;
  }&#13;
&#13;
  function tokensOf (address _owner) public view returns (uint256[] _tokenIds) {&#13;
    uint256[] memory items = new uint256[](balanceOf(_owner));&#13;
&#13;
    uint256 itemCounter = 0;&#13;
    for (uint256 i = 0; i &lt; listedItems.length; i++) {&#13;
      if (ownerOf(listedItems[i]) == _owner) {&#13;
        items[itemCounter] = listedItems[i];&#13;
        itemCounter += 1;&#13;
      }&#13;
    }&#13;
&#13;
    return items;&#13;
  }&#13;
&#13;
  function tokenExists (uint256 _itemId) public view returns (bool _exists) {&#13;
    return priceOf(_itemId) &gt; 0;&#13;
  }&#13;
&#13;
  function approvedFor(uint256 _itemId) public view returns (address _approved) {&#13;
    return approvedOfItem[_itemId];&#13;
  }&#13;
&#13;
  function approve(address _to, uint256 _itemId) public {&#13;
    require(msg.sender != _to);&#13;
    require(tokenExists(_itemId));&#13;
    require(ownerOf(_itemId) == msg.sender);&#13;
&#13;
    if (_to == 0) {&#13;
      if (approvedOfItem[_itemId] != 0) {&#13;
        delete approvedOfItem[_itemId];&#13;
        Approval(msg.sender, 0, _itemId);&#13;
      }&#13;
    } else {&#13;
      approvedOfItem[_itemId] = _to;&#13;
      Approval(msg.sender, _to, _itemId);&#13;
    }&#13;
  }&#13;
&#13;
  /* Transferring a country to another owner will entitle the new owner the profits from `buy` */&#13;
  function transfer(address _to, uint256 _itemId) public {&#13;
    require(msg.sender == ownerOf(_itemId));&#13;
    _transfer(msg.sender, _to, _itemId);&#13;
  }&#13;
&#13;
  function transferFrom(address _from, address _to, uint256 _itemId) public {&#13;
    require(approvedFor(_itemId) == msg.sender);&#13;
    _transfer(_from, _to, _itemId);&#13;
  }&#13;
&#13;
  function _transfer(address _from, address _to, uint256 _itemId) internal {&#13;
    require(tokenExists(_itemId));&#13;
    require(ownerOf(_itemId) == _from);&#13;
    require(_to != address(0));&#13;
    require(_to != address(this));&#13;
&#13;
    ownerOfItem[_itemId] = _to;&#13;
    approvedOfItem[_itemId] = 0;&#13;
&#13;
    Transfer(_from, _to, _itemId);&#13;
  }&#13;
&#13;
  /* Read */&#13;
  function isAdmin (address _admin) public view returns (bool _isAdmin) {&#13;
    return admins[_admin];&#13;
  }&#13;
&#13;
  function priceOf (uint256 _itemId) public view returns (uint256 _price) {&#13;
    return priceOfItem[_itemId];&#13;
  }&#13;
&#13;
  function nextPriceOf (uint256 _itemId) public view returns (uint256 _nextPrice) {&#13;
    return calculateNextPrice(priceOf(_itemId));&#13;
  }&#13;
&#13;
  function allOf (uint256 _itemId) external view returns (address _owner, uint256 _price, uint256 _nextPrice) {&#13;
    return (ownerOf(_itemId), priceOf(_itemId), nextPriceOf(_itemId));&#13;
  }&#13;
&#13;
  function itemsForSaleLimit (uint256 _from, uint256 _take) public view returns (uint256[] _items) {&#13;
    uint256[] memory items = new uint256[](_take);&#13;
&#13;
    for (uint256 i = 0; i &lt; _take; i++) {&#13;
      items[i] = listedItems[_from + i];&#13;
    }&#13;
&#13;
    return items;&#13;
  }&#13;
&#13;
  /* Util */&#13;
  function isContract(address addr) internal view returns (bool) {&#13;
    uint size;&#13;
    assembly { size := extcodesize(addr) } // solium-disable-line&#13;
    return size &gt; 0;&#13;
  }&#13;
  &#13;
  function changePrice(uint256 _itemId, uint256 _price) public onlyAdmins() {&#13;
    require(_price &gt; 0);&#13;
    require(admins[ownerOfItem[_itemId]]);&#13;
    priceOfItem[_itemId] = _price;&#13;
  }&#13;
  &#13;
  function issueCard(uint256 l, uint256 r, uint256 price) onlyAdmins() public {&#13;
    for (uint256 i = l; i &lt;= r; i++) {&#13;
      ownerOfItem[i] = msg.sender;&#13;
      priceOfItem[i] = price;&#13;
      listedItems.push(i);&#13;
    }      &#13;
   }  &#13;
}   &#13;
&#13;
interface IItemRegistry {&#13;
  function itemsForSaleLimit (uint256 _from, uint256 _take) public view returns (uint256[] _items);&#13;
  function ownerOf (uint256 _itemId) public view returns (address _owner);&#13;
  function priceOf (uint256 _itemId) public view returns (uint256 _price);&#13;
}