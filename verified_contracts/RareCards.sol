pragma solidity ^0.4.18;
/* ==================================================================== */
/* Copyright (c) 2018 The MagicAcademy Project.  All rights reserved.
/* 
/* https://www.magicacademy.io One of the world's first idle strategy games of blockchain 
/*  
/* authors <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="c0b2a1a9aeb980aca9b6a5b3b4a1b2eea3afad">[email protected]</a>/<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="42082d2c2c3b6c0437022e2b3427313623306c212d2f">[email protected]</a>&#13;
/*                 &#13;
/* ==================================================================== */&#13;
/**&#13;
 * @title Ownable&#13;
 * @dev The Ownable contract has an owner address, and provides basic authorization control&#13;
 * functions, this simplifies the implementation of "user permissions".&#13;
 */&#13;
contract Ownable {&#13;
  address public owner;&#13;
&#13;
  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);&#13;
&#13;
  /*&#13;
   * @dev The Ownable constructor sets the original `owner` of the contract to the sender&#13;
   * account.&#13;
   */&#13;
  function Ownable() public {&#13;
    owner = msg.sender;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Throws if called by any account other than the owner.&#13;
   */&#13;
  modifier onlyOwner() {&#13;
    require(msg.sender == owner);&#13;
    _;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Allows the current owner to transfer control of the contract to a newOwner.&#13;
   * @param newOwner The address to transfer ownership to.&#13;
   */&#13;
  function transferOwnership(address newOwner) public onlyOwner {&#13;
    require(newOwner != address(0));&#13;
    OwnershipTransferred(owner, newOwner);&#13;
    owner = newOwner;&#13;
  }&#13;
}&#13;
&#13;
contract AccessAdmin is Ownable {&#13;
&#13;
  /// @dev Admin Address&#13;
  mapping (address =&gt; bool) adminContracts;&#13;
&#13;
  /// @dev Trust contract&#13;
  mapping (address =&gt; bool) actionContracts;&#13;
&#13;
  function setAdminContract(address _addr, bool _useful) public onlyOwner {&#13;
    require(_addr != address(0));&#13;
    adminContracts[_addr] = _useful;&#13;
  }&#13;
&#13;
  modifier onlyAdmin {&#13;
    require(adminContracts[msg.sender]); &#13;
    _;&#13;
  }&#13;
&#13;
  function setActionContract(address _actionAddr, bool _useful) public onlyAdmin {&#13;
    actionContracts[_actionAddr] = _useful;&#13;
  }&#13;
&#13;
  modifier onlyAccess() {&#13;
    require(actionContracts[msg.sender]);&#13;
    _;&#13;
  }&#13;
}&#13;
&#13;
/// @title ERC-721 Non-Fungible Token Standard&#13;
/// @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md&#13;
///  Note: the ERC-165 identifier for this interface is 0x80ac58cd&#13;
contract ERC721 /* is ERC165 */ {&#13;
  event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);&#13;
  event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);&#13;
  event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);&#13;
  &#13;
  function balanceOf(address _owner) external view returns (uint256);&#13;
  function ownerOf(uint256 _tokenId) external view returns (address);&#13;
  function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data) external payable;&#13;
  function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable;&#13;
  function transferFrom(address _from, address _to, uint256 _tokenId) external payable;&#13;
  function approve(address _approved, uint256 _tokenId) external payable;&#13;
  function setApprovalForAll(address _operator, bool _approved) external;&#13;
  function getApproved(uint256 _tokenId) external view returns (address);&#13;
  function isApprovedForAll(address _owner, address _operator) external view returns (bool);&#13;
}&#13;
&#13;
interface ERC165 {&#13;
  function supportsInterface(bytes4 interfaceID) external view returns (bool);&#13;
}&#13;
&#13;
/// @title ERC-721 Non-Fungible Token Standard&#13;
interface ERC721TokenReceiver {&#13;
  function onERC721Received(address _from, uint256 _tokenId, bytes data) external returns(bytes4);&#13;
}&#13;
&#13;
/// @title ERC-721 Non-Fungible Token Standard, optional metadata extension&#13;
/// @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md&#13;
///  Note: the ERC-165 identifier for this interface is 0x5b5e139f&#13;
/*interface ERC721Metadata is ERC721{&#13;
  function name() external view returns (string _name);&#13;
  function symbol() external view returns (string _symbol);&#13;
  function tokenURI(uint256 _tokenId) external view returns (string);&#13;
}*/&#13;
&#13;
/// @title ERC-721 Non-Fungible Token Standard, optional enumeration extension&#13;
/// @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md&#13;
///  Note: the ERC-165 identifier for this interface is 0x780e9d63&#13;
interface ERC721Enumerable /* is ERC721 */ {&#13;
  function totalSupply() external view returns (uint256);&#13;
  function tokenByIndex(uint256 _index) external view returns (uint256);&#13;
  function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256);&#13;
}&#13;
&#13;
contract RareCards is AccessAdmin, ERC721 {&#13;
  using SafeMath for SafeMath;&#13;
  // event&#13;
  event eCreateRare(uint256 tokenId, uint256 price, address owner);&#13;
&#13;
  // ERC721&#13;
  event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);&#13;
  event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);&#13;
  event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);&#13;
&#13;
  struct RareCard {&#13;
    uint256 rareId;     // rare item id&#13;
    uint256 rareClass;  // upgrade level of rare item&#13;
    uint256 cardId;     // related to basic card ID &#13;
    uint256 rareValue;  // upgrade value of rare item&#13;
  }&#13;
&#13;
  RareCard[] public rareArray; // dynamic Array&#13;
&#13;
  function RareCards() public {&#13;
    rareArray.length += 1;&#13;
    setAdminContract(msg.sender,true);&#13;
    setActionContract(msg.sender,true);&#13;
  }&#13;
&#13;
  /*** CONSTRUCTOR ***/&#13;
  uint256 private constant PROMO_CREATION_LIMIT = 20;&#13;
  uint256 private constant startPrice = 0.5 ether;&#13;
&#13;
  address thisAddress = this;&#13;
  uint256 PLATPrice = 65000;&#13;
  /**mapping**/&#13;
  /// @dev map tokenId to owner (tokenId -&gt; address)&#13;
  mapping (uint256 =&gt; address) public IndexToOwner;&#13;
  /// @dev search rare item index in owner's array (tokenId -&gt; index)&#13;
  mapping (uint256 =&gt; uint256) indexOfOwnedToken;&#13;
  /// @dev list of owned rare items by owner&#13;
  mapping (address =&gt; uint256[]) ownerToRareArray;&#13;
  /// @dev search token price by tokenId&#13;
  mapping (uint256 =&gt; uint256) IndexToPrice;&#13;
  /// @dev get the authorized address for each rare item&#13;
  mapping (uint256 =&gt; address) public IndexToApproved;&#13;
  /// @dev get the authorized operators for each rare item&#13;
  mapping (address =&gt; mapping(address =&gt; bool)) operatorToApprovals;&#13;
&#13;
  /** Modifier **/&#13;
  /// @dev Check if token ID is valid&#13;
  modifier isValidToken(uint256 _tokenId) {&#13;
    require(_tokenId &gt;= 1 &amp;&amp; _tokenId &lt;= rareArray.length);&#13;
    require(IndexToOwner[_tokenId] != address(0)); &#13;
    _;&#13;
  }&#13;
  /// @dev check the ownership of token&#13;
  modifier onlyOwnerOf(uint _tokenId) {&#13;
    require(msg.sender == IndexToOwner[_tokenId] || msg.sender == IndexToApproved[_tokenId]);&#13;
    _;&#13;
  }&#13;
&#13;
  /// @dev create a new rare item&#13;
  function createRareCard(uint256 _rareClass, uint256 _cardId, uint256 _rareValue) public onlyOwner {&#13;
    require(rareArray.length &lt; PROMO_CREATION_LIMIT); &#13;
    _createRareCard(thisAddress, startPrice, _rareClass, _cardId, _rareValue);&#13;
  }&#13;
&#13;
&#13;
  /// steps to create rare item &#13;
  function _createRareCard(address _owner, uint256 _price, uint256 _rareClass, uint256 _cardId, uint256 _rareValue) internal returns(uint) {&#13;
    uint256 newTokenId = rareArray.length;&#13;
    RareCard memory _rarecard = RareCard({&#13;
      rareId: newTokenId,&#13;
      rareClass: _rareClass,&#13;
      cardId: _cardId,&#13;
      rareValue: _rareValue&#13;
    });&#13;
    rareArray.push(_rarecard);&#13;
    //event&#13;
    eCreateRare(newTokenId, _price, _owner);&#13;
&#13;
    IndexToPrice[newTokenId] = _price;&#13;
    // This will assign ownership, and also emit the Transfer event as&#13;
    // per ERC721 draft&#13;
    _transfer(address(0), _owner, newTokenId);&#13;
&#13;
  } &#13;
&#13;
  /// @dev transfer the ownership of tokenId&#13;
  /// @param _from The old owner of rare item(If created: 0x0)&#13;
  /// @param _to The new owner of rare item&#13;
  /// @param _tokenId The tokenId of rare item&#13;
  function _transfer(address _from, address _to, uint256 _tokenId) internal {&#13;
    if (_from != address(0)) {&#13;
      uint256 indexFrom = indexOfOwnedToken[_tokenId];&#13;
      uint256[] storage rareArrayOfOwner = ownerToRareArray[_from];&#13;
      require(rareArrayOfOwner[indexFrom] == _tokenId);&#13;
&#13;
      // Switch the positions of selected item and last item&#13;
      if (indexFrom != rareArrayOfOwner.length - 1) {&#13;
        uint256 lastTokenId = rareArrayOfOwner[rareArrayOfOwner.length - 1];&#13;
        rareArrayOfOwner[indexFrom] = lastTokenId;&#13;
        indexOfOwnedToken[lastTokenId] = indexFrom;&#13;
      }&#13;
      rareArrayOfOwner.length -= 1;&#13;
&#13;
      // clear any previously approved ownership exchange&#13;
      if (IndexToApproved[_tokenId] != address(0)) {&#13;
        delete IndexToApproved[_tokenId];&#13;
      } &#13;
    }&#13;
    //transfer ownership&#13;
    IndexToOwner[_tokenId] = _to;&#13;
    ownerToRareArray[_to].push(_tokenId);&#13;
    indexOfOwnedToken[_tokenId] = ownerToRareArray[_to].length - 1;&#13;
    // Emit the transfer event.&#13;
    Transfer(_from != address(0) ? _from : this, _to, _tokenId);&#13;
  }&#13;
&#13;
  /// @notice Returns all the relevant information about a specific tokenId.&#13;
  /// @param _tokenId The tokenId of the rarecard.&#13;
  function getRareInfo(uint256 _tokenId) external view returns (&#13;
      uint256 sellingPrice,&#13;
      address owner,&#13;
      uint256 nextPrice,&#13;
      uint256 rareClass,&#13;
      uint256 cardId,&#13;
      uint256 rareValue&#13;
  ) {&#13;
    RareCard storage rarecard = rareArray[_tokenId];&#13;
    sellingPrice = IndexToPrice[_tokenId];&#13;
    owner = IndexToOwner[_tokenId];&#13;
    nextPrice = SafeMath.div(SafeMath.mul(sellingPrice,125),100);&#13;
    rareClass = rarecard.rareClass;&#13;
    cardId = rarecard.cardId;&#13;
    rareValue = rarecard.rareValue;&#13;
  }&#13;
&#13;
  /// @notice Returns all the relevant information about a specific tokenId.&#13;
  /// @param _tokenId The tokenId of the rarecard.&#13;
  function getRarePLATInfo(uint256 _tokenId) external view returns (&#13;
    uint256 sellingPrice,&#13;
    address owner,&#13;
    uint256 nextPrice,&#13;
    uint256 rareClass,&#13;
    uint256 cardId,&#13;
    uint256 rareValue&#13;
  ) {&#13;
    RareCard storage rarecard = rareArray[_tokenId];&#13;
    sellingPrice = SafeMath.mul(IndexToPrice[_tokenId],PLATPrice);&#13;
    owner = IndexToOwner[_tokenId];&#13;
    nextPrice = SafeMath.div(SafeMath.mul(sellingPrice,125),100);&#13;
    rareClass = rarecard.rareClass;&#13;
    cardId = rarecard.cardId;&#13;
    rareValue = rarecard.rareValue;&#13;
  }&#13;
&#13;
&#13;
  function getRareItemsOwner(uint256 rareId) external view returns (address) {&#13;
    return IndexToOwner[rareId];&#13;
  }&#13;
&#13;
  function getRareItemsPrice(uint256 rareId) external view returns (uint256) {&#13;
    return IndexToPrice[rareId];&#13;
  }&#13;
&#13;
  function getRareItemsPLATPrice(uint256 rareId) external view returns (uint256) {&#13;
    return SafeMath.mul(IndexToPrice[rareId],PLATPrice);&#13;
  }&#13;
&#13;
  function setRarePrice(uint256 _rareId, uint256 _price) external onlyAccess {&#13;
    IndexToPrice[_rareId] = _price;&#13;
  }&#13;
&#13;
  function rareStartPrice() external pure returns (uint256) {&#13;
    return startPrice;&#13;
  }&#13;
&#13;
  /// ERC721&#13;
  /// @notice Count all the rare items assigned to an owner&#13;
  function balanceOf(address _owner) external view returns (uint256) {&#13;
    require(_owner != address(0));&#13;
    return ownerToRareArray[_owner].length;&#13;
  }&#13;
&#13;
  /// @notice Find the owner of a rare item&#13;
  function ownerOf(uint256 _tokenId) external view returns (address _owner) {&#13;
    return IndexToOwner[_tokenId];&#13;
  }&#13;
&#13;
  /// @notice Transfers the ownership of a rare item from one address to another address&#13;
  function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data) external payable {&#13;
    _safeTransferFrom(_from, _to, _tokenId, data);&#13;
  }&#13;
&#13;
  function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable {&#13;
    _safeTransferFrom(_from, _to, _tokenId, "");&#13;
  }&#13;
&#13;
  /// @dev steps to implement the safeTransferFrom&#13;
  function _safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data) &#13;
    internal&#13;
    isValidToken(_tokenId)&#13;
    onlyOwnerOf(_tokenId) &#13;
  {&#13;
    address owner = IndexToOwner[_tokenId];&#13;
    require(owner != address(0) &amp;&amp; owner == _from);&#13;
    require(_to != address(0));&#13;
            &#13;
    _transfer(_from, _to, _tokenId);&#13;
&#13;
    // Do the callback after everything is done to avoid reentrancy attack&#13;
    /*uint256 codeSize;&#13;
    assembly { codeSize := extcodesize(_to) }&#13;
    if (codeSize == 0) {&#13;
        return;&#13;
    }*/&#13;
    bytes4 retval = ERC721TokenReceiver(_to).onERC721Received(_from, _tokenId, data);&#13;
    // bytes4(keccak256("onERC721Received(address,uint256,bytes)")) = 0xf0b9e5ba;&#13;
    require(retval == 0xf0b9e5ba);&#13;
  }&#13;
&#13;
  // function transfer(address _to, uint256 _tokenId) public onlyOwnerOf(_tokenId) {&#13;
  //   _transfer(msg.sender, _to, _tokenId);&#13;
  // }&#13;
&#13;
  /// @notice Transfers the ownership of a rare item from one address to another address&#13;
  /// @dev Transfer ownership of a rare item, '_to' must be a vaild address, or the card will lost&#13;
  /// @param _from The current owner of rare item&#13;
  /// @param _to The new owner&#13;
  /// @param _tokenId The rare item to transfer&#13;
  function transferFrom(address _from, address _to, uint256 _tokenId) &#13;
    external &#13;
    isValidToken(_tokenId)&#13;
    onlyOwnerOf(_tokenId) &#13;
    payable &#13;
  {&#13;
    address owner = IndexToOwner[_tokenId];&#13;
    // require(_owns(_from, _tokenId));&#13;
    // require(_approved(_to, _tokenId));&#13;
    require(owner != address(0) &amp;&amp; owner == _from);&#13;
    require(_to != address(0));&#13;
    _transfer(_from, _to, _tokenId);&#13;
  }&#13;
&#13;
  //   /// For checking approval of transfer for address _to&#13;
  //   function _approved(address _to, uint256 _tokenId) private view returns (bool) {&#13;
  //     return IndexToApproved[_tokenId] == _to;&#13;
  //   }&#13;
  //  /// Check for token ownership&#13;
  //   function _owns(address claimant, uint256 _tokenId) private view returns (bool) {&#13;
  //     return claimant == IndexToOwner[_tokenId];&#13;
  //   }&#13;
&#13;
  /// @dev Set or reaffirm the approved address for a rare item&#13;
  /// @param _approved The new approved rare item controller&#13;
  /// @param _tokenId The rare item to approve&#13;
  function approve(address _approved, uint256 _tokenId) &#13;
    external &#13;
    isValidToken(_tokenId)&#13;
    onlyOwnerOf(_tokenId) &#13;
    payable &#13;
  {&#13;
    address owner = IndexToOwner[_tokenId];&#13;
    require(operatorToApprovals[owner][msg.sender]);&#13;
    IndexToApproved[_tokenId] = _approved;&#13;
    Approval(owner, _approved, _tokenId);&#13;
  }&#13;
&#13;
&#13;
  /// @dev Enable or disable approval for a third party ("operator") to manage all your asset.&#13;
  /// @param _operator Address to add to the set of authorized operators.&#13;
  /// @param _approved True if the operators is approved, false to revoke approval&#13;
  function setApprovalForAll(address _operator, bool _approved) &#13;
    external &#13;
  {&#13;
    operatorToApprovals[msg.sender][_operator] = _approved;&#13;
    ApprovalForAll(msg.sender, _operator, _approved);&#13;
  }&#13;
&#13;
  /// @dev Get the approved address for a single rare item&#13;
  /// @param _tokenId The rare item to find the approved address for&#13;
  /// @return The approved address for this rare item, or the zero address if there is none&#13;
  function getApproved(uint256 _tokenId) external view isValidToken(_tokenId) returns (address) {&#13;
    return IndexToApproved[_tokenId];&#13;
  }&#13;
&#13;
  /// @dev Query if an address is an authorized operator for another address&#13;
  /// @param _owner The address that owns the rare item&#13;
  /// @param _operator The address that acts on behalf of the owner&#13;
  /// @return True if `_operator` is an approved operator for `_owner`, false otherwise&#13;
  function isApprovedForAll(address _owner, address _operator) external view returns (bool) {&#13;
    return operatorToApprovals[_owner][_operator];&#13;
  }&#13;
&#13;
  /// @notice Count rare items tracked by this contract&#13;
  /// @return A count of valid rare items tracked by this contract, where each one of&#13;
  ///  them has an assigned and queryable owner not equal to the zero address&#13;
  function totalSupply() external view returns (uint256) {&#13;
    return rareArray.length -1;&#13;
  }&#13;
&#13;
  /// @notice Enumerate valid rare items&#13;
  /// @dev Throws if `_index` &gt;= `totalSupply()`.&#13;
  /// @param _index A counter less than `totalSupply()`&#13;
  /// @return The token identifier for the `_index`the rare item,&#13;
  ///  (sort order not specified)&#13;
  function tokenByIndex(uint256 _index) external view returns (uint256) {&#13;
    require(_index &lt;= (rareArray.length - 1));&#13;
    return _index;&#13;
  }&#13;
&#13;
  /// @notice Enumerate rare items assigned to an owner&#13;
  /// @dev Throws if `_index` &gt;= `balanceOf(_owner)` or if&#13;
  ///  `_owner` is the zero address, representing invalid rare items.&#13;
  /// @param _owner An address where we are interested in rare items owned by them&#13;
  /// @param _index A counter less than `balanceOf(_owner)`&#13;
  /// @return The token identifier for the `_index`the rare item assigned to `_owner`,&#13;
  ///   (sort order not specified)&#13;
  function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256) {&#13;
    require(_index &lt; ownerToRareArray[_owner].length);&#13;
    if (_owner != address(0)) {&#13;
      uint256 tokenId = ownerToRareArray[_owner][_index];&#13;
      return tokenId;&#13;
    }&#13;
  }&#13;
&#13;
  /// @param _owner The owner whose celebrity tokens we are interested in.&#13;
  /// @dev This method MUST NEVER be called by smart contract code. First, it's fairly&#13;
  ///  expensive (it walks the entire Persons array looking for persons belonging to owner),&#13;
  ///  but it also returns a dynamic array, which is only supported for web3 calls, and&#13;
  ///  not contract-to-contract calls.&#13;
  function tokensOfOwner(address _owner) external view returns(uint256[]) {&#13;
    uint256 tokenCount = ownerToRareArray[_owner].length;&#13;
    if (tokenCount == 0) {&#13;
      // Return an empty array&#13;
      return new uint256[](0);&#13;
    } else {&#13;
      uint256[] memory result = new uint256[](tokenCount);&#13;
      uint256 totalRare = rareArray.length - 1;&#13;
      uint256 resultIndex = 0;&#13;
&#13;
      uint256 tokenId;&#13;
      for (tokenId = 0; tokenId &lt;= totalRare; tokenId++) {&#13;
        if (IndexToOwner[tokenId] == _owner) {&#13;
          result[resultIndex] = tokenId;&#13;
          resultIndex++;&#13;
        }&#13;
      }&#13;
      return result;&#13;
    }&#13;
  }&#13;
&#13;
  //transfer token &#13;
  function transferToken(address _from, address _to, uint256 _tokenId) external onlyAccess {&#13;
    _transfer(_from,  _to, _tokenId);&#13;
  }&#13;
&#13;
  // transfer token in contract-- for raffle&#13;
  function transferTokenByContract(uint256 _tokenId,address _to) external onlyAccess {&#13;
    _transfer(thisAddress,  _to, _tokenId);&#13;
  }&#13;
&#13;
  // owner &amp; price list &#13;
  function getRareItemInfo() external view returns (address[], uint256[], uint256[]) {&#13;
    address[] memory itemOwners = new address[](rareArray.length-1);&#13;
    uint256[] memory itemPrices = new uint256[](rareArray.length-1);&#13;
    uint256[] memory itemPlatPrices = new uint256[](rareArray.length-1);&#13;
        &#13;
    uint256 startId = 1;&#13;
    uint256 endId = rareArray.length-1;&#13;
        &#13;
    uint256 i;&#13;
    while (startId &lt;= endId) {&#13;
      itemOwners[i] = IndexToOwner[startId];&#13;
      itemPrices[i] = IndexToPrice[startId];&#13;
      itemPlatPrices[i] = SafeMath.mul(IndexToPrice[startId],PLATPrice);&#13;
      i++;&#13;
      startId++;&#13;
    }   &#13;
    return (itemOwners, itemPrices, itemPlatPrices);&#13;
  }&#13;
} &#13;
&#13;
library SafeMath {&#13;
&#13;
  /**&#13;
  * @dev Multiplies two numbers, throws on overflow.&#13;
  */&#13;
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
    if (a == 0) {&#13;
      return 0;&#13;
    }&#13;
    uint256 c = a * b;&#13;
    assert(c / a == b);&#13;
    return c;&#13;
  }&#13;
&#13;
  /**&#13;
  * @dev Integer division of two numbers, truncating the quotient.&#13;
  */&#13;
  function div(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
    // assert(b &gt; 0); // Solidity automatically throws when dividing by 0&#13;
    uint256 c = a / b;&#13;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold&#13;
    return c;&#13;
  }&#13;
&#13;
  /**&#13;
  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).&#13;
  */&#13;
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
    assert(b &lt;= a);&#13;
    return a - b;&#13;
  }&#13;
&#13;
  /**&#13;
  * @dev Adds two numbers, throws on overflow.&#13;
  */&#13;
  function add(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
    uint256 c = a + b;&#13;
    assert(c &gt;= a);&#13;
    return c;&#13;
  }&#13;
}