pragma solidity ^0.4.15;

/**
 *
 * @author  David Rosen <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="6f040e0e010b00061b2f020c000141001d08">[emailÂ protected]</a>&gt;&#13;
 *&#13;
 * Version A&#13;
 *&#13;
 * Overview:&#13;
 * This divides all incoming funds among various `activity` accounts. The division cannot be changed&#13;
 * after the contract is locked.&#13;
 */&#13;
&#13;
&#13;
// --------------------------&#13;
//  R Split Contract&#13;
// --------------------------&#13;
contract OrganizeFunds {&#13;
&#13;
  struct ActivityAccount {&#13;
    uint credited;   // total funds credited to this account&#13;
    uint balance;    // current balance = credited - amount withdrawn&#13;
    uint pctx10;     // percent allocation times ten&#13;
    address addr;    // payout addr of this acct&#13;
  }&#13;
&#13;
  uint constant TENHUNDWEI = 1000;                     // need gt. 1000 wei to distribute&#13;
  uint constant MAX_ACCOUNTS = 10;                     // max accounts this contract can handle&#13;
&#13;
  event MessageEvent(string message);&#13;
  event MessageEventI(string message, uint val);&#13;
&#13;
&#13;
  bool public isLocked;&#13;
  address public owner;                                // deployer executor&#13;
  mapping (uint =&gt; ActivityAccount) activityAccounts;  // accounts by index&#13;
  uint public activityCount;                           // how many activity accounts&#13;
  uint public totalFundsReceived;                      // amount received since begin of time&#13;
  uint public totalFundsDistributed;                   // amount distributed since begin of time&#13;
  uint public totalFundsWithdrawn;                     // amount withdrawn since begin of time&#13;
  uint public withdrawGas = 100000;                    // gas for withdrawals&#13;
&#13;
&#13;
  modifier ownerOnly {&#13;
    require(msg.sender == owner);&#13;
    _;&#13;
  }&#13;
&#13;
  modifier unlockedOnly {&#13;
    require(!isLocked);&#13;
    _;&#13;
  }&#13;
&#13;
&#13;
&#13;
  //&#13;
  // constructor&#13;
  //&#13;
  function OrganizeFunds() {&#13;
    owner = msg.sender;&#13;
  }&#13;
&#13;
  function lock() public ownerOnly {&#13;
    isLocked = true;&#13;
  }&#13;
&#13;
&#13;
  //&#13;
  // reset&#13;
  // reset all accounts&#13;
  // in case we have any funds that have not been withdrawn, they become  newly received and undistributed.&#13;
  //&#13;
  function reset() public ownerOnly unlockedOnly {&#13;
    totalFundsReceived = this.balance;&#13;
    totalFundsDistributed = 0;&#13;
    totalFundsWithdrawn = 0;&#13;
    activityCount = 0;&#13;
    MessageEvent("ok: all accts reset");&#13;
  }&#13;
&#13;
&#13;
  //&#13;
  // set withdrawal gas&#13;
  // nonstandard gas is necessary to support push-withdrawals to other contract&#13;
  //&#13;
  function setWitdrawGas(uint256 _withdrawGas) public ownerOnly unlockedOnly {&#13;
    withdrawGas = _withdrawGas;&#13;
    MessageEventI("ok: withdraw gas set", withdrawGas);&#13;
  }&#13;
&#13;
&#13;
  //&#13;
  // add a new account&#13;
  //&#13;
  function addAccount(address _addr, uint256 _pctx10) public ownerOnly unlockedOnly {&#13;
    if (activityCount &gt;= MAX_ACCOUNTS) {&#13;
      MessageEvent("err: max accounts");&#13;
      return;&#13;
    }&#13;
    activityAccounts[activityCount].addr = _addr;&#13;
    activityAccounts[activityCount].pctx10 = _pctx10;&#13;
    activityAccounts[activityCount].credited = 0;&#13;
    activityAccounts[activityCount].balance = 0;&#13;
    ++activityCount;&#13;
    MessageEvent("ok: acct added");&#13;
  }&#13;
&#13;
&#13;
  // ----------------------------&#13;
  // get acct info&#13;
  // ----------------------------&#13;
  function getAccountInfo(address _addr) public constant returns(uint _idx, uint _pctx10, uint _credited, uint _balance) {&#13;
    for (uint i = 0; i &lt; activityCount; i++ ) {&#13;
      address addr = activityAccounts[i].addr;&#13;
      if (addr == _addr) {&#13;
        _idx = i;&#13;
        _pctx10 = activityAccounts[i].pctx10;&#13;
        _credited = activityAccounts[i].credited;&#13;
        _balance = activityAccounts[i].balance;&#13;
        return;&#13;
      }&#13;
    }&#13;
  }&#13;
&#13;
&#13;
  //&#13;
  // get total percentages x10&#13;
  //&#13;
  function getTotalPctx10() public constant returns(uint _totalPctx10) {&#13;
    _totalPctx10 = 0;&#13;
    for (uint i = 0; i &lt; activityCount; i++ ) {&#13;
      _totalPctx10 += activityAccounts[i].pctx10;&#13;
    }&#13;
  }&#13;
&#13;
&#13;
  //&#13;
  // default payable function.&#13;
  // call us with plenty of gas, or catastrophe will ensue&#13;
  //&#13;
  function () payable {&#13;
    totalFundsReceived += msg.value;&#13;
    MessageEventI("ok: received", msg.value);&#13;
  }&#13;
&#13;
&#13;
  //&#13;
  // distribute funds to all activities&#13;
  //&#13;
  function distribute() public {&#13;
    //only payout if we have more than 1000 wei&#13;
    if (this.balance &lt; TENHUNDWEI) {&#13;
      return;&#13;
    }&#13;
    //each account gets their prescribed percentage of this holdover.&#13;
    uint i;&#13;
    uint pctx10;&#13;
    uint acctDist;&#13;
    for (i = 0; i &lt; activityCount; i++ ) {&#13;
      pctx10 = activityAccounts[i].pctx10;&#13;
      acctDist = totalFundsReceived * pctx10 / TENHUNDWEI;&#13;
      //we also double check to ensure that the amount credited cannot exceed the total amount due to this acct&#13;
      if (activityAccounts[i].credited &gt;= acctDist) {&#13;
        acctDist = 0;&#13;
      } else {&#13;
        acctDist = acctDist - activityAccounts[i].credited;&#13;
      }&#13;
      activityAccounts[i].credited += acctDist;&#13;
      activityAccounts[i].balance += acctDist;&#13;
      totalFundsDistributed += acctDist;&#13;
    }&#13;
    MessageEvent("ok: distributed funds");&#13;
  }&#13;
&#13;
&#13;
  //&#13;
  // withdraw actvity balance&#13;
  // can be called by owner to push funds to another contract&#13;
  //&#13;
  function withdraw() public {&#13;
    for (uint i = 0; i &lt; activityCount; i++ ) {&#13;
      address addr = activityAccounts[i].addr;&#13;
      if (addr == msg.sender || msg.sender == owner) {&#13;
        uint amount = activityAccounts[i].balance;&#13;
        if (amount &gt; 0) {&#13;
          activityAccounts[i].balance = 0;&#13;
          totalFundsWithdrawn += amount;&#13;
          if (!addr.call.gas(withdrawGas).value(amount)()) {&#13;
            //put back funds in case of err&#13;
            activityAccounts[i].balance = amount;&#13;
            totalFundsWithdrawn -= amount;&#13;
            MessageEvent("err: error sending funds");&#13;
            return;&#13;
          }&#13;
        }&#13;
      }&#13;
    }&#13;
  }&#13;
&#13;
&#13;
  //&#13;
  // suicide&#13;
  //&#13;
  function hariKari() public ownerOnly unlockedOnly {&#13;
    selfdestruct(owner);&#13;
  }&#13;
&#13;
}