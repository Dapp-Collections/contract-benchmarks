pragma solidity 0.4.24;
pragma experimental "v0.5.0";
/******************************************************************************\
* Author: Nick Mudge, <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="117f78727a517c7e7a747f623f787e">[emailÂ protected]</a>&gt;&#13;
*&#13;
* The MokenUpdates contract adds/updates/removes functions.&#13;
*&#13;
* Function changes emit the ContractUpdated event.&#13;
* Monitor changes to the Mokens contract by watching/querying the&#13;
* ContractUpdated event&#13;
*&#13;
* Functions and delegate contracts can be queried by using functions from the&#13;
* QueryMokenDelegates contract.&#13;
/******************************************************************************/&#13;
&#13;
///////////////////////////////////////////////////////////////////////////////////&#13;
// All storage variables are declared here&#13;
///////////////////////////////////////////////////////////////////////////////////&#13;
contract Storage0 {&#13;
    ///////////////////////////////////////////////////////////////////////////////////&#13;
    //Storage version 0&#13;
    ///////////////////////////////////////////////////////////////////////////////////&#13;
    ///////////////////////////////////////////////////////////////////////////////////&#13;
    ///////////////////////////////////////////////////////////////////////////////////&#13;
    //Contract Management&#13;
    ///////////////////////////////////////////////////////////////////////////////////&#13;
    // funcId =&gt; delegate contract&#13;
    mapping(bytes4 =&gt; address) internal delegates;&#13;
    address internal contractOwner;&#13;
    string[] internal functionSignatures;&#13;
    // signature =&gt; index+1&#13;
    mapping(string =&gt; uint256) internal functionSignatureToIndex;&#13;
&#13;
&#13;
    ///////////////////////////////////////////////////////////////////////////////////&#13;
    //SupportsInterfaces&#13;
    ///////////////////////////////////////////////////////////////////////////////////&#13;
    mapping(bytes4 =&gt; bool) internal supportedInterfaces;&#13;
&#13;
&#13;
    ///////////////////////////////////////////////////////////////////////////////////&#13;
    //RootOwnerOf&#13;
    //ERC721Metadata&#13;
    ///////////////////////////////////////////////////////////////////////////////////&#13;
    struct Moken {&#13;
        string name;&#13;
        uint256 data;&#13;
        uint256 parentTokenId;&#13;
    }&#13;
    //tokenId =&gt; moken&#13;
    mapping(uint256 =&gt; Moken) internal mokens;&#13;
    uint256 internal mokensLength;&#13;
    // child address =&gt; child tokenId =&gt; tokenId+1&#13;
    mapping(address =&gt; mapping(uint256 =&gt; uint256)) internal childTokenOwner;&#13;
&#13;
&#13;
    ///////////////////////////////////////////////////////////////////////////////////&#13;
    //ERC721&#13;
    //ERC721Enumerable&#13;
    ///////////////////////////////////////////////////////////////////////////////////&#13;
    // root token owner address =&gt; (tokenId =&gt; approved address)&#13;
    mapping(address =&gt; mapping(uint256 =&gt; address)) internal rootOwnerAndTokenIdToApprovedAddress;&#13;
    // token owner =&gt; (operator address =&gt; bool)&#13;
    mapping(address =&gt; mapping(address =&gt; bool)) internal tokenOwnerToOperators;&#13;
    // Mapping from owner to list of owned token IDs&#13;
    mapping(address =&gt; uint32[]) internal ownedTokens;&#13;
&#13;
&#13;
    ///////////////////////////////////////////////////////////////////////////////////&#13;
    //ERC998ERC721TopDown&#13;
    ///////////////////////////////////////////////////////////////////////////////////&#13;
    // tokenId =&gt; (child address =&gt; array of child tokens)&#13;
    mapping(uint256 =&gt; mapping(address =&gt; uint256[])) internal childTokens;&#13;
    // tokenId =&gt; (child address =&gt; (child token =&gt; child index)&#13;
    mapping(uint256 =&gt; mapping(address =&gt; mapping(uint256 =&gt; uint256))) internal childTokenIndex;&#13;
    // tokenId =&gt; (child address =&gt; contract index)&#13;
    mapping(uint256 =&gt; mapping(address =&gt; uint256)) internal childContractIndex;&#13;
    // tokenId =&gt; child contract&#13;
    mapping(uint256 =&gt; address[]) internal childContracts;&#13;
&#13;
&#13;
    ///////////////////////////////////////////////////////////////////////////////////&#13;
    //ERC998ERC20TopDown&#13;
    ///////////////////////////////////////////////////////////////////////////////////&#13;
    // tokenId =&gt; token contract&#13;
    mapping(uint256 =&gt; address[]) internal erc20Contracts;&#13;
    // tokenId =&gt; (token contract =&gt; token contract index)&#13;
    mapping(uint256 =&gt; mapping(address =&gt; uint256)) erc20ContractIndex;&#13;
    // tokenId =&gt; (token contract =&gt; balance)&#13;
    mapping(uint256 =&gt; mapping(address =&gt; uint256)) internal erc20Balances;&#13;
&#13;
&#13;
    ///////////////////////////////////////////////////////////////////////////////////&#13;
    //ERC998ERC721BottomUp&#13;
    ///////////////////////////////////////////////////////////////////////////////////&#13;
    // parent address =&gt; (parent tokenId =&gt; array of child tokenIds)&#13;
    mapping(address =&gt; mapping(uint256 =&gt; uint32[])) internal parentToChildTokenIds;&#13;
    // tokenId =&gt; position in childTokens array&#13;
    mapping(uint256 =&gt; uint256) internal tokenIdToChildTokenIdsIndex;&#13;
&#13;
&#13;
    ///////////////////////////////////////////////////////////////////////////////////&#13;
    //Era&#13;
    ///////////////////////////////////////////////////////////////////////////////////&#13;
    // index =&gt; era&#13;
    mapping(uint256 =&gt; bytes32) internal eras;&#13;
    uint256 internal eraLength;&#13;
    // era =&gt; index+1&#13;
    mapping(bytes32 =&gt; uint256) internal eraIndex;&#13;
&#13;
&#13;
    ///////////////////////////////////////////////////////////////////////////////////&#13;
    //Minting&#13;
    ///////////////////////////////////////////////////////////////////////////////////&#13;
    uint256 internal mintPriceOffset; // = 0 szabo;&#13;
    uint256 internal mintStepPrice; // = 500 szabo;&#13;
    uint256 internal mintPriceBuffer; // = 5000 szabo;&#13;
    address[] internal mintContracts;&#13;
    mapping(address =&gt; uint256) internal mintContractIndex;&#13;
    //moken name =&gt; tokenId+1&#13;
    mapping(string =&gt; uint256) internal tokenByName_;&#13;
}&#13;
&#13;
contract MokenUpdates is Storage0 {&#13;
&#13;
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);&#13;
    event ContractUpdated(bytes32 indexed indexedFunctionSignature, address indexed delegate, bytes32 indexed updateType, string functionSignature);&#13;
&#13;
    function initializeMokensContract(address contractManagement) external {&#13;
        require(contractOwner == address(0), "Contract owner has been set.");&#13;
        contractOwner = msg.sender;&#13;
        emit OwnershipTransferred(address(0), msg.sender);&#13;
        updateContract(1 /* addFunctions */, contractManagement, "executeDelegate(address,bytes)addFunctions(address,string)updateFunctions(address,string)removeFunctions(string)");&#13;
    }&#13;
&#13;
    function updateContract(uint256 _updateType, address _delegate, string signatures) internal {&#13;
        require(msg.sender == contractOwner, "Must own Mokens contract.");&#13;
        require(_delegate != address(0), "delegate can't be zero address.");&#13;
        bytes memory signaturesBytes = bytes(signatures);&#13;
        bytes memory signatureBytes;&#13;
        string memory signature;&#13;
        bytes4 funcId;&#13;
        uint256 length = signaturesBytes.length;&#13;
        uint256 pos = 2;&#13;
        uint256 start = 0;&#13;
        uint256 num;&#13;
        uint256 index;&#13;
        uint256 lastIndex;&#13;
        bytes32 signatureHash;&#13;
        for (; pos &lt; length; pos++) {&#13;
            // 0x29 == )&#13;
            if (signaturesBytes[pos] == 0x29) {&#13;
                num = (pos - start) + 1;&#13;
                signatureBytes = new bytes(num);&#13;
                for (uint i = 0; i &lt; num; i++) {&#13;
                    signatureBytes[i] = signaturesBytes[start + i];&#13;
                }&#13;
                start = pos + 1;&#13;
                signature = string(signatureBytes);&#13;
                signatureHash = keccak256(signatureBytes);&#13;
                funcId = bytes4(signatureHash);&#13;
                if (_updateType == 1) {&#13;
                    require(functionSignatureToIndex[signature] == 0, "Function already exists.");&#13;
                    require(delegates[funcId] == address(0), "FuncId clash.");&#13;
                    delegates[funcId] = _delegate;&#13;
                    functionSignatures.push(signature);&#13;
                    functionSignatureToIndex[signature] = functionSignatures.length;&#13;
                    emit ContractUpdated(signatureHash, _delegate, "new", signature);&#13;
                }&#13;
                else if (_updateType == 2) {&#13;
                    index = functionSignatureToIndex[signature];&#13;
                    if (index == 0) {&#13;
                        require(delegates[funcId] == address(0), "FuncId clash.");&#13;
                        delegates[funcId] = _delegate;&#13;
                        emit ContractUpdated(signatureHash, _delegate, "new", signature);&#13;
                    }&#13;
                    else if (delegates[funcId] != _delegate) {&#13;
                        delegates[funcId] = _delegate;&#13;
                        emit ContractUpdated(signatureHash, _delegate, "updated", signature);&#13;
                    }&#13;
                }&#13;
                else if (_updateType == 3) {&#13;
                    index = functionSignatureToIndex[signature];&#13;
                    require(index != 0, "Function does not exist.");&#13;
                    index--;&#13;
                    lastIndex = functionSignatures.length - 1;&#13;
                    if (index != lastIndex) {&#13;
                        functionSignatures[index] = functionSignatures[lastIndex];&#13;
                        functionSignatureToIndex[functionSignatures[lastIndex]] = index + 1;&#13;
                    }&#13;
                    functionSignatures.length--;&#13;
                    delete functionSignatureToIndex[signature];&#13;
                    _delegate = delegates[funcId];&#13;
                    delete delegates[funcId];&#13;
                    emit ContractUpdated(signatureHash, _delegate, "removed", signature);&#13;
                }&#13;
            }&#13;
        }&#13;
    }&#13;
&#13;
    function addFunctions(address _delegate, string signatures) external {&#13;
        updateContract(1, _delegate, signatures);&#13;
    }&#13;
&#13;
    function updateFunctions(address _delegate, string signatures) external {&#13;
        updateContract(2, _delegate, signatures);&#13;
    }&#13;
&#13;
    function removeFunctions(string signatures) external {&#13;
        updateContract(3, address(1), signatures);&#13;
    }&#13;
&#13;
&#13;
    function executeDelegate(address _delegate, bytes _functionCall) external returns(string) {&#13;
        require(msg.sender == contractOwner, "Must own Mokens contract.");&#13;
        bytes memory functionCall = _functionCall;&#13;
        assembly {&#13;
            let callSuccess := delegatecall(gas, _delegate, add(functionCall, 0x20), mload(functionCall), 0, 0)&#13;
            let size := returndatasize&#13;
            returndatacopy(functionCall, 0, size)&#13;
            switch callSuccess&#13;
            case 0 {revert(functionCall, size)}&#13;
            default {return (functionCall, size)}&#13;
        }&#13;
    }&#13;
}