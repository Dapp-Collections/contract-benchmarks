pragma solidity ^0.4.20;

library SafeMath {

  /**
  * @dev Multiplies two numbers, throws on overflow.
  */
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }

  /**
  * @dev Integer division of two numbers, truncating the quotient.
  */
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    // assert(b > 0); // Solidity automatically throws when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return c;
  }

  /**
  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).
  */
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  /**
  * @dev Adds two numbers, throws on overflow.
  */
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }
}

/// @title Interface for contracts conforming to ERC-721: Non-Fungible Tokens
/// @author Dieter Shirley <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="157170617055746d7c7a786f707b3b767a">[emailÂ protected]</a>&gt; (https://github.com/dete)&#13;
contract ERC721 {&#13;
    // Required methods&#13;
    function totalSupply() public view returns (uint256 total);&#13;
    function balanceOf(address _owner) public view returns (uint256 balance);&#13;
    function ownerOf(uint256 _tokenId) public view returns (address _owner);&#13;
    function approve(address _to, uint256 _tokenId) public;&#13;
    function transfer(address _to, uint256 _tokenId) public;&#13;
    function transferFrom(address _from, address _to, uint256 _tokenId) public;&#13;
&#13;
    // Events&#13;
    event Transfer(address from, address to, uint256 tokenId);&#13;
    event Approval(address owner, address approved, uint256 tokenId);&#13;
&#13;
    // Optional&#13;
    function name() public pure returns (string _name);&#13;
    function symbol() public pure returns (string _symbol);&#13;
    // function tokensOfOwner(address _owner) external view returns (uint256[] tokenIds);&#13;
    // function tokenMetadata(uint256 _tokenId, string _preferredTransport) public view returns (string infoUrl);&#13;
&#13;
    // ERC-165 Compatibility (https://github.com/ethereum/EIPs/issues/165)&#13;
    // function supportsInterface(bytes4 _interfaceID) external view returns (bool);&#13;
}&#13;
&#13;
contract CryptoChallenge is ERC721{&#13;
  using SafeMath for uint256;&#13;
&#13;
  event Bought (uint256 indexed _tokenId, address indexed _owner, uint256 _price);&#13;
  event Sold (uint256 indexed _tokenId, address indexed _owner, uint256 _price);&#13;
  event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);&#13;
  event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);&#13;
&#13;
  address private owner;&#13;
  mapping (address =&gt; bool) private admins;&#13;
&#13;
  uint256 private increaseLimit1 = 0.02 ether;&#13;
  uint256 private increaseLimit2 = 0.5 ether;&#13;
  uint256 private increaseLimit3 = 2.0 ether;&#13;
  uint256 private increaseLimit4 = 5.0 ether;&#13;
&#13;
  uint256[] private listedTokens;&#13;
  mapping (uint256 =&gt; uint256) private bet1OfToken;&#13;
  mapping (uint256 =&gt; uint256) private bet2OfToken;&#13;
  mapping (uint256 =&gt; uint256) private bet1deltaOfToken;&#13;
  mapping (uint256 =&gt; uint256) private bet2deltaOfToken;  &#13;
  mapping (uint256 =&gt; address) private ownerOfToken;&#13;
  mapping (uint256 =&gt; address) private owner1OfToken;&#13;
  mapping (uint256 =&gt; address) private owner2OfToken;&#13;
  mapping (uint256 =&gt; address) private witnessOfToken;  &#13;
  mapping (uint256 =&gt; address) private p1OfToken;&#13;
  mapping (uint256 =&gt; address) private p2OfToken;    &#13;
  mapping (uint256 =&gt; uint256) private price1OfToken;&#13;
  mapping (uint256 =&gt; uint256) private price2OfToken;  &#13;
  mapping (uint256 =&gt; uint256) private free1OfToken;&#13;
  mapping (uint256 =&gt; uint256) private free2OfToken;&#13;
  mapping (uint256 =&gt; address) private approvedOfToken;&#13;
  mapping (uint256 =&gt; uint256) private indexOfId;&#13;
  &#13;
  function CryptoChallenge () public {&#13;
    owner = msg.sender;&#13;
    admins[owner] = true;    &#13;
  }&#13;
&#13;
  /* Modifiers */&#13;
  modifier onlyOwner() {&#13;
    require(owner == msg.sender);&#13;
    _;&#13;
  }&#13;
&#13;
  modifier onlyAdmins() {&#13;
    require(admins[msg.sender]);&#13;
    _;&#13;
  }&#13;
&#13;
  modifier onlyWitness(uint256 _tokenId) {&#13;
    require(msg.sender == witnessOfToken[_tokenId]);&#13;
    _;&#13;
  }  &#13;
&#13;
  /* Owner */&#13;
  function setOwner (address _owner) onlyOwner() public {&#13;
    owner = _owner;&#13;
  }&#13;
&#13;
  function addAdmin (address _admin) onlyOwner() public {&#13;
    admins[_admin] = true;&#13;
  }&#13;
&#13;
  function removeAdmin (address _admin) onlyOwner() public {&#13;
    delete admins[_admin];&#13;
  }&#13;
&#13;
  /* Withdraw */&#13;
  /*&#13;
    NOTICE: These functions withdraw the developer's cut which is left&#13;
    in the contract by `buy`. User funds are immediately sent to the old&#13;
    owner in `buy`, no user funds are left in the contract.&#13;
  */&#13;
  function withdrawAll () onlyAdmins() public {&#13;
   msg.sender.transfer(this.balance);&#13;
  }&#13;
&#13;
  function withdrawAmount (uint256 _amount) onlyAdmins() public {&#13;
    msg.sender.transfer(_amount);&#13;
  }&#13;
&#13;
  /* Buying */&#13;
  function calculateNextPrice (uint256 _price) public view returns (uint256 _nextPrice) {&#13;
    if (_price &lt; increaseLimit1) {&#13;
      return _price.mul(200).div(95);&#13;
    } else if (_price &lt; increaseLimit2) {&#13;
      return _price.mul(135).div(96);&#13;
    } else if (_price &lt; increaseLimit3) {&#13;
      return _price.mul(125).div(97);&#13;
    } else if (_price &lt; increaseLimit4) {&#13;
      return _price.mul(117).div(97);&#13;
    } else {&#13;
      return _price.mul(115).div(98);&#13;
    }&#13;
  }&#13;
&#13;
  function calculateDevCut (uint256 _price) public pure returns (uint256 _devCut) {&#13;
     return _price.div(20);&#13;
  }&#13;
&#13;
  /*&#13;
     Buy a country directly from the contract for the calculated price&#13;
     which ensures that the owner gets a profit.  All countries that&#13;
     have been listed can be bought by this method. User funds are sent&#13;
     directly to the previous owner and are never stored in the contract.&#13;
  */&#13;
  function buy1 (uint256 _tokenId) payable public {&#13;
    require(price1Of(_tokenId) &gt; 0);&#13;
    require(owner1Of(_tokenId) != address(0));&#13;
    require(msg.value &gt;= price1Of(_tokenId));&#13;
    require(owner1Of(_tokenId) != msg.sender);&#13;
    require(!isContract(msg.sender));&#13;
    require(msg.sender != address(0));&#13;
    require(now &gt;= free1OfToken[_tokenId]);&#13;
    require(now &lt;= free2OfToken[_tokenId]);&#13;
&#13;
    address oldOwner = owner1Of(_tokenId);&#13;
    address newOwner = msg.sender;&#13;
    uint256 price = price1Of(_tokenId);&#13;
    uint256 excess = msg.value.sub(price);&#13;
&#13;
    price1OfToken[_tokenId] = nextPrice1Of(_tokenId);&#13;
&#13;
    uint256 devCut = calculateDevCut(price);&#13;
    oldOwner.transfer(price.sub(devCut));&#13;
&#13;
    if (excess &gt; 0) {&#13;
      newOwner.transfer(excess);&#13;
    }&#13;
&#13;
    owner1OfToken[_tokenId] = newOwner;&#13;
&#13;
  }&#13;
&#13;
  function buy2 (uint256 _tokenId) payable public {&#13;
    require(price2Of(_tokenId) &gt; 0);&#13;
    require(owner2Of(_tokenId) != address(0));&#13;
    require(msg.value &gt;= price2Of(_tokenId));&#13;
    require(owner2Of(_tokenId) != msg.sender);&#13;
    require(!isContract(msg.sender));&#13;
    require(msg.sender != address(0));&#13;
    require(now &gt;= free1OfToken[_tokenId]);&#13;
    require(now &lt;= free2OfToken[_tokenId]);&#13;
&#13;
    address oldOwner = owner2Of(_tokenId);&#13;
    address newOwner = msg.sender;&#13;
    uint256 price = price2Of(_tokenId);&#13;
    uint256 excess = msg.value.sub(price);&#13;
&#13;
    price2OfToken[_tokenId] = nextPrice2Of(_tokenId);&#13;
&#13;
    uint256 devCut = calculateDevCut(price);&#13;
    oldOwner.transfer(price.sub(devCut));&#13;
&#13;
    if (excess &gt; 0) {&#13;
      newOwner.transfer(excess);&#13;
    }&#13;
&#13;
    owner2OfToken[_tokenId] = newOwner;&#13;
  }  &#13;
&#13;
  /* ERC721 */&#13;
&#13;
  function name() public pure returns (string _name) {&#13;
    return "betsignature";&#13;
  }&#13;
&#13;
  function symbol() public pure returns (string _symbol) {&#13;
    return "BET";&#13;
  }&#13;
&#13;
  function totalSupply() public view returns (uint256 _totalSupply) {&#13;
    return listedTokens.length;&#13;
  }&#13;
&#13;
  function balanceOf (address _owner) public view returns (uint256 _balance) {&#13;
    uint256 counter = 0;&#13;
&#13;
    for (uint256 i = 0; i &lt; listedTokens.length; i++) {&#13;
      if (ownerOf(listedTokens[i]) == _owner) {&#13;
        counter++;&#13;
      }&#13;
    }&#13;
&#13;
    return counter;&#13;
  }&#13;
&#13;
  function ownerOf(uint256 _tokenId) public view returns (address _owner) {&#13;
    return ownerOfToken[_tokenId];&#13;
  }&#13;
&#13;
  function owner1Of (uint256 _tokenId) public view returns (address _owner) {&#13;
    return owner1OfToken[_tokenId];&#13;
  }&#13;
&#13;
  function owner2Of (uint256 _tokenId) public view returns (address _owner) {&#13;
    return owner2OfToken[_tokenId];&#13;
  }&#13;
&#13;
  function tokensOf (address _owner) public view returns (uint256[] _tokenIds) {&#13;
    uint256[] memory Tokens = new uint256[](balanceOf(_owner));&#13;
&#13;
    uint256 TokenCounter = 0;&#13;
    for (uint256 i = 0; i &lt; listedTokens.length; i++) {&#13;
      if (ownerOf(listedTokens[i]) == _owner) {&#13;
        Tokens[TokenCounter] = listedTokens[i];&#13;
        TokenCounter += 1;&#13;
      }&#13;
    }&#13;
&#13;
    return Tokens;&#13;
  }&#13;
&#13;
  function tokenExists (uint256 _tokenId) public pure returns (bool _exists) {&#13;
    return _tokenId == _tokenId;&#13;
  }&#13;
&#13;
  function approvedFor(uint256 _tokenId) public view returns (address _approved) {&#13;
    return approvedOfToken[_tokenId];&#13;
  }&#13;
&#13;
  function approve(address _to, uint256 _tokenId) public {&#13;
    require(msg.sender != _to);&#13;
    require(tokenExists(_tokenId));&#13;
    require(ownerOf(_tokenId) == msg.sender);&#13;
&#13;
    if (_to == 0) {&#13;
      if (approvedOfToken[_tokenId] != 0) {&#13;
        delete approvedOfToken[_tokenId];&#13;
        Approval(msg.sender, 0, _tokenId);&#13;
      }&#13;
    } else {&#13;
      approvedOfToken[_tokenId] = _to;&#13;
      Approval(msg.sender, _to, _tokenId);&#13;
    }&#13;
  }&#13;
&#13;
  /* Transferring a country to another owner will entitle the new owner the profits from `buy` */&#13;
  function transfer(address _to, uint256 _tokenId) public {&#13;
    require(msg.sender == ownerOf(_tokenId));&#13;
    _transfer(msg.sender, _to, _tokenId);&#13;
  }&#13;
&#13;
  function transferFrom(address _from, address _to, uint256 _tokenId) public {&#13;
    require(approvedFor(_tokenId) == msg.sender);&#13;
    _transfer(_from, _to, _tokenId);&#13;
  }&#13;
&#13;
  function _transfer(address _from, address _to, uint256 _tokenId) internal {&#13;
    require(tokenExists(_tokenId));&#13;
    require(ownerOf(_tokenId) == _from);&#13;
    require(_to != address(0));&#13;
    require(_to != address(this));&#13;
&#13;
    ownerOfToken[_tokenId] = _to;&#13;
    approvedOfToken[_tokenId] = 0;&#13;
&#13;
    Transfer(_from, _to, _tokenId);&#13;
  }&#13;
&#13;
  /* Read */&#13;
  function isAdmin (address _admin) public view returns (bool _isAdmin) {&#13;
    return admins[_admin];&#13;
  }&#13;
&#13;
  function price1Of (uint256 _tokenId) public view returns (uint256 _price) {&#13;
    return price1OfToken[_tokenId];&#13;
  }&#13;
&#13;
  function price2Of (uint256 _tokenId) public view returns (uint256 _price) {&#13;
    return price2OfToken[_tokenId];&#13;
  }  &#13;
&#13;
  function free1Of (uint256 _tokenId) public view returns (uint256 _free1) {&#13;
    return free1OfToken[_tokenId];&#13;
  }&#13;
  &#13;
  function free2Of (uint256 _tokenId) public view returns (uint256 _free2) {&#13;
      return free2OfToken[_tokenId];&#13;
  }&#13;
&#13;
  function nextPrice1Of (uint256 _tokenId) public view returns (uint256 _nextPrice) {&#13;
    return calculateNextPrice(price1Of(_tokenId));&#13;
  }&#13;
&#13;
  function nextPrice2Of (uint256 _tokenId) public view returns (uint256 _nextPrice) {&#13;
    return calculateNextPrice(price2Of(_tokenId));&#13;
  }  &#13;
&#13;
  function witnessOf (uint256 _tokenId) public view returns (address _witness) {&#13;
    return witnessOfToken[_tokenId];&#13;
  }&#13;
&#13;
  function allOf (uint256 _tokenId) external view returns (address _owner1, address _owner2, uint256 _price1, uint256 _price2, uint256 _free1, uint256 _free2, address _witness) {&#13;
    return (owner1Of(_tokenId), owner2Of(_tokenId), price1Of(_tokenId), price2Of(_tokenId), free1Of(_tokenId), free2Of(_tokenId), witnessOf(_tokenId));&#13;
  }&#13;
  &#13;
  /* Util */&#13;
  function isContract(address addr) internal view returns (bool) {&#13;
    uint size;&#13;
    assembly { size := extcodesize(addr) } // solium-disable-line&#13;
    return size &gt; 0;&#13;
  }&#13;
  &#13;
  function judge(uint256 _tokenId, bool _isP1Win) onlyWitness(_tokenId) public {&#13;
    require(price2OfToken[_tokenId] != 0);&#13;
    require(now &gt; free2OfToken[_tokenId]);&#13;
    uint reward = bet1OfToken[_tokenId] + bet2OfToken[_tokenId] + calculateDevCut(price1OfToken[_tokenId] + price2OfToken[_tokenId]);&#13;
    reward -= calculateDevCut(reward);&#13;
    if (_isP1Win == true) {&#13;
      reward = reward.div(bet1OfToken[_tokenId] + price1OfToken[_tokenId]);&#13;
      p1OfToken[_tokenId].transfer(reward.mul(bet1OfToken[_tokenId]));&#13;
      owner1OfToken[_tokenId].transfer(reward.mul(price1OfToken[_tokenId]));&#13;
    } else {&#13;
      reward = reward.div(bet2OfToken[_tokenId] + price2OfToken[_tokenId]);&#13;
      p2OfToken[_tokenId].transfer(reward.mul(bet2OfToken[_tokenId]));&#13;
      owner2OfToken[_tokenId].transfer(reward.mul(price2OfToken[_tokenId]));&#13;
    }&#13;
  }&#13;
&#13;
  function accept1(uint256 _tokenId, uint256 _price1) public payable {&#13;
    require(msg.sender == p1OfToken[_tokenId]);&#13;
    require(msg.value &gt;= bet1OfToken[_tokenId]);&#13;
    require(_price1 &gt; 0);&#13;
    price2OfToken[_tokenId] = _price1;&#13;
  }&#13;
&#13;
  function accept2(uint256 _tokenId) public payable {&#13;
    require(msg.sender == p2OfToken[_tokenId]);&#13;
    require(msg.value &gt;= bet2deltaOfToken[_tokenId]);&#13;
    bet2OfToken[_tokenId] += bet2deltaOfToken[_tokenId];&#13;
    bet1deltaOfToken[_tokenId] = bet2deltaOfToken[_tokenId] = 0;&#13;
  }&#13;
&#13;
  function cancel1(uint256 _tokenId) public {&#13;
    require(msg.sender == p1OfToken[_tokenId]);&#13;
    require(price2OfToken[_tokenId] == 0);&#13;
    msg.sender.transfer(bet1OfToken[_tokenId]);&#13;
  }&#13;
  &#13;
  function cancel2(uint256 _tokenId) public {&#13;
    require(msg.sender == p1OfToken[_tokenId]);&#13;
    require(price2OfToken[_tokenId] == 0);&#13;
    msg.sender.transfer(bet1deltaOfToken[_tokenId]);&#13;
    bet1deltaOfToken[_tokenId] = 0; &#13;
  }&#13;
  &#13;
  function issueToken(address p2, address witness, uint256 price1, uint256 frozen1, uint256 frozen2) payable public {&#13;
    require(msg.value &gt;= 1000);&#13;
    require(witness != msg.sender);&#13;
    require(witness != p2);&#13;
    require(price1 &gt; 0);&#13;
    uint i = listedTokens.length;&#13;
    bet1OfToken[i] = msg.value;&#13;
    witnessOfToken[i] = witness;&#13;
    p1OfToken[i] = owner1OfToken[i] = msg.sender;  &#13;
    p2OfToken[i] = owner2OfToken[i] = p2;    &#13;
    price1OfToken[i] = price1;&#13;
    free1OfToken[i] = now + frozen1;&#13;
    free2OfToken[i] = now + frozen1 + frozen2;&#13;
    listedTokens.push(i);&#13;
  }&#13;
&#13;
&#13;
  function addBet(uint256 _tokenId, uint256 _bet2delta) public payable {&#13;
    require(msg.sender == p1OfToken[_tokenId]);&#13;
    bet1deltaOfToken[_tokenId] = msg.value;&#13;
    bet2deltaOfToken[_tokenId] = _bet2delta;&#13;
  }&#13;
}