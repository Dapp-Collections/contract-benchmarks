pragma solidity ^0.4.23;

// File: zeppelin-solidity/contracts/ownership/Ownable.sol

/**
 * @title Ownable
 * @dev The Ownable contract has an owner address, and provides basic authorization control
 * functions, this simplifies the implementation of "user permissions".
 */
contract Ownable {
  address public owner;


  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);


  /**
   * @dev The Ownable constructor sets the original `owner` of the contract to the sender
   * account.
   */
  function Ownable() public {
    owner = msg.sender;
  }

  /**
   * @dev Throws if called by any account other than the owner.
   */
  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }

  /**
   * @dev Allows the current owner to transfer control of the contract to a newOwner.
   * @param newOwner The address to transfer ownership to.
   */
  function transferOwnership(address newOwner) public onlyOwner {
    require(newOwner != address(0));
    emit OwnershipTransferred(owner, newOwner);
    owner = newOwner;
  }

}

// File: zeppelin-solidity/contracts/lifecycle/Pausable.sol

/**
 * @title Pausable
 * @dev Base contract which allows children to implement an emergency stop mechanism.
 */
contract Pausable is Ownable {
  event Pause();
  event Unpause();

  bool public paused = false;


  /**
   * @dev Modifier to make a function callable only when the contract is not paused.
   */
  modifier whenNotPaused() {
    require(!paused);
    _;
  }

  /**
   * @dev Modifier to make a function callable only when the contract is paused.
   */
  modifier whenPaused() {
    require(paused);
    _;
  }

  /**
   * @dev called by the owner to pause, triggers stopped state
   */
  function pause() onlyOwner whenNotPaused public {
    paused = true;
    emit Pause();
  }

  /**
   * @dev called by the owner to unpause, returns to normal state
   */
  function unpause() onlyOwner whenPaused public {
    paused = false;
    emit Unpause();
  }
}

// File: zeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol

/**
 * @title ERC20Basic
 * @dev Simpler version of ERC20 interface
 * @dev see https://github.com/ethereum/EIPs/issues/179
 */
contract ERC20Basic {
  function totalSupply() public view returns (uint256);
  function balanceOf(address who) public view returns (uint256);
  function transfer(address to, uint256 value) public returns (bool);
  event Transfer(address indexed from, address indexed to, uint256 value);
}

// File: zeppelin-solidity/contracts/lifecycle/TokenDestructible.sol

/**
 * @title TokenDestructible:
 * @author Remco Bloemen <<span class="__cf_email__" data-cfemail="64160109070b2456">[email protected]</span>π.com&gt;&#13;
 * @dev Base contract that can be destroyed by owner. All funds in contract including&#13;
 * listed tokens will be sent to the owner.&#13;
 */&#13;
contract TokenDestructible is Ownable {&#13;
&#13;
  function TokenDestructible() public payable { }&#13;
&#13;
  /**&#13;
   * @notice Terminate contract and refund to owner&#13;
   * @param tokens List of addresses of ERC20 or ERC20Basic token contracts to&#13;
   refund.&#13;
   * @notice The called token contracts could try to re-enter this contract. Only&#13;
   supply token contracts you trust.&#13;
   */&#13;
  function destroy(address[] tokens) onlyOwner public {&#13;
&#13;
    // Transfer tokens to owner&#13;
    for (uint256 i = 0; i &lt; tokens.length; i++) {&#13;
      ERC20Basic token = ERC20Basic(tokens[i]);&#13;
      uint256 balance = token.balanceOf(this);&#13;
      token.transfer(owner, balance);&#13;
    }&#13;
&#13;
    // Transfer Eth to owner and terminate contract&#13;
    selfdestruct(owner);&#13;
  }&#13;
}&#13;
&#13;
// File: contracts/Atonomi.sol&#13;
&#13;
// solhint-disable-line&#13;
&#13;
&#13;
&#13;
&#13;
/// @title ERC-20 Token Standard&#13;
/// @author Fabian Vogelsteller &lt;<span class="__cf_email__" data-cfemail="6107000308000f21041509041304140c4f0e1306">[email protected]</span>&gt;, Vitalik Buterin &lt;<span class="__cf_email__" data-cfemail="b8ced1ccd9d4d1d396dacdccddcad1d6f8ddccd0ddcaddcdd596d7cadf">[email protected]</span>&gt;&#13;
/// @dev https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md&#13;
interface ERC20Interface {&#13;
    function decimals() public constant returns (uint8);&#13;
    function totalSupply() public constant returns (uint);&#13;
    function balanceOf(address tokenOwner) public constant returns (uint balance);&#13;
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);&#13;
    function transfer(address to, uint tokens) public returns (bool success);&#13;
    function approve(address spender, uint tokens) public returns (bool success);&#13;
    function transferFrom(address from, address to, uint tokens) public returns (bool success);&#13;
&#13;
    event Transfer(address indexed from, address indexed to, uint tokens);   // solhint-disable-line&#13;
    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);&#13;
}&#13;
&#13;
&#13;
/// @title Safe Math library&#13;
/// @dev Math operations with safety checks that throw on error&#13;
/// @dev https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/math/SafeMath.sol&#13;
library SafeMath {&#13;
    /// @dev Multiplies two numbers, throws on overflow.&#13;
    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {&#13;
        if (a == 0) {&#13;
            return 0;&#13;
        }&#13;
        c = a * b;&#13;
        assert(c / a == b);&#13;
        return c;&#13;
    }&#13;
&#13;
    /// @dev Integer division of two numbers, truncating the quotient.&#13;
    function div(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
        // assert(b &gt; 0); // Solidity automatically throws when dividing by 0&#13;
        // uint256 c = a / b;&#13;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold&#13;
        return a / b;&#13;
    }&#13;
&#13;
    /// @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).&#13;
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
        assert(b &lt;= a);&#13;
        return a - b;&#13;
    }&#13;
&#13;
    /// @dev Adds two numbers, throws on overflow.&#13;
    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {&#13;
        c = a + b;&#13;
        assert(c &gt;= a);&#13;
        return c;&#13;
    }&#13;
}&#13;
&#13;
&#13;
/// @dev Interface for the Network Settings contract&#13;
interface SettingsInterface {&#13;
    function registrationFee() external view returns (uint256);&#13;
    function activationFee() external view returns (uint256);&#13;
    function defaultReputationReward() external view returns (uint256);&#13;
    function reputationIRNNodeShare() external view returns (uint256);&#13;
    function blockThreshold() external view returns (uint256);&#13;
}&#13;
&#13;
&#13;
/// @title Atonomi Smart Contract&#13;
/// @author Atonomi&#13;
/// @notice Governs the activation, registration, and reputation of devices on the Atonomi network&#13;
/// @dev Ownable: Owner governs the access of Atonomi Admins, Fees, and Rewards on the network&#13;
/// @dev Pausable: Gives ability for Owner to pull emergency stop to prevent actions on the network&#13;
/// @dev TokenDestructible: Gives owner ability to kill the contract and extract funds to a new contract&#13;
contract Atonomi is Pausable, TokenDestructible {&#13;
    using SafeMath for uint256;&#13;
&#13;
    /// @title ATMI Token&#13;
    /// @notice Standard ERC20 Token&#13;
    /// @dev AMLToken source: https://github.com/TokenMarketNet/ico/blob/master/contracts/AMLToken.sol&#13;
    ERC20Interface public token;&#13;
&#13;
    /// @title Network Settings&#13;
    /// @notice Atonomi Owner controlled settings are governed in this contract&#13;
    SettingsInterface public settings;&#13;
&#13;
    ///&#13;
    /// STORAGE MAPPINGS &#13;
    ///&#13;
    /// @title Atonomi Devices registry&#13;
    /// @notice Contains all devices participating in the Atonomi Network&#13;
    /// @dev Key is a keccak256 hash of the device id&#13;
    /// @dev Value is a struct that contains the device status and metadata&#13;
    mapping (bytes32 =&gt; Device) public devices;&#13;
&#13;
    /// @title Atonomi Participant whitelist&#13;
    /// @notice Contains all the network participants&#13;
    /// @dev Atonomi Admins: Govern the access to manufacturers and IRN Nodes on the network&#13;
    /// @dev IRN Nodes: Governs reputation score data of devices&#13;
    /// @dev Manufacturers: Governs devices on the network&#13;
    /// @dev Key is ethereum account of the participant&#13;
    /// @dev Value is a struct that contains the role of the participant&#13;
    mapping (address =&gt; NetworkMember) public network;&#13;
&#13;
    /// @title Token Pools&#13;
    /// @notice each manufacturer will manage a pool of tokens for reputation rewards&#13;
    /// @dev Key is ethereum account for pool owner&#13;
    /// @dev Value is struct representing token pool attributes&#13;
    /// @dev incoming tokens will come from registrations, activations, or public donations&#13;
    /// @dev outgoing tokens will come from reputation rewards&#13;
    mapping (address =&gt; TokenPool) public pools;&#13;
&#13;
    /// @title Reward Balances&#13;
    /// @notice balances of rewards that are able to be claimed by participants&#13;
    /// @dev Key is ethereum account of the owner of the tokens&#13;
    /// @dev Value is tokens available for withdraw&#13;
    mapping (address =&gt; uint256) public rewards;&#13;
&#13;
    /// @title Lookup by Manufacturer ID the wallet for reputation rewards&#13;
    /// @dev Key is the manufacturer id&#13;
    /// @dev Value is ethereum account to be rewarded&#13;
    mapping (bytes32 =&gt; address) public manufacturerRewards;&#13;
&#13;
    /// @title Track last write by reputation author&#13;
    /// @dev First key is the ethereum address of the reputation author&#13;
    /// @dev Second key is the device id&#13;
    /// @dev Value is the block number of the last time the author has submitted a score for the device&#13;
    mapping (address =&gt; mapping (bytes32 =&gt; uint256)) public authorWrites;&#13;
&#13;
    /// @title Default Repuration score for manufacturers&#13;
    /// @dev Key is the manufacturer id&#13;
    /// @dev value is the score to use for newly registered devices&#13;
    mapping (bytes32 =&gt; bytes32) public defaultManufacturerReputations;&#13;
&#13;
    ///&#13;
    /// TYPES &#13;
    ///&#13;
    /// @title Atonomi Device&#13;
    /// @notice Contains the device state on the Atonomi network&#13;
    /// @dev manufacturerId is the manufacturer the device belongs to&#13;
    /// @dev deviceType is the type of device categorized by the manufacturer&#13;
    /// @dev registered is true when device is registered, otherwise false&#13;
    /// @dev activated is true when device is activated, otherwise false&#13;
    /// @dev reputationScore is official Atonomi Reputation score for the device&#13;
    /// @dev devicePublicKey is public key used by IRN Nodes for validation&#13;
    struct Device {&#13;
        bytes32 manufacturerId;&#13;
        bytes32 deviceType;&#13;
        bool registered;&#13;
        bool activated;&#13;
        bytes32 reputationScore;&#13;
        bytes32 devicePublicKey;&#13;
    }&#13;
&#13;
    /// @title Token Pool&#13;
    /// @notice Contains balance and reputation reward amounts for each token pool&#13;
    /// @dev balance is total amount of tokens available in the pool&#13;
    /// @dev rewardAmount is the total amount distributed between the manufacturer and reputation author&#13;
    struct TokenPool {&#13;
        uint256 balance;&#13;
        uint256 rewardAmount;&#13;
    }&#13;
&#13;
    /// @title Atonomi Network Participant&#13;
    /// @notice Contains role information for a participant&#13;
    /// @dev isIRNAdmin is true if participant is an IRN Admin, otherwise false&#13;
    /// @dev isManufacturer is true if participant is a Manufacturer, otherwise false&#13;
    /// @dev isIRNNode is true if participant is an IRN Node, otherwise false&#13;
    /// @dev memberId is the manufacturer id, for all other participants this will be 0&#13;
    struct NetworkMember {&#13;
        bool isIRNAdmin;&#13;
        bool isManufacturer;&#13;
        bool isIRNNode;&#13;
        bytes32 memberId;&#13;
    }&#13;
&#13;
    ///&#13;
    /// MODIFIERS&#13;
    ///&#13;
    /// @notice only manufacturers can call, otherwise throw&#13;
    modifier onlyManufacturer() {&#13;
        require(network[msg.sender].isManufacturer, "must be a manufacturer");&#13;
        _;&#13;
    }&#13;
&#13;
    /// @notice only IRNAdmins or Owner can call, otherwise throw&#13;
    modifier onlyIRNorOwner() {&#13;
        require(msg.sender == owner || network[msg.sender].isIRNAdmin, "must be owner or an irn admin");&#13;
        _;&#13;
    }&#13;
&#13;
    /// @notice only IRN Nodes can call, otherwise throw&#13;
    modifier onlyIRNNode() {&#13;
        require(network[msg.sender].isIRNNode, "must be an irn node");&#13;
        _;&#13;
    }&#13;
&#13;
    /// @notice Constructor sets the ERC Token contract and initial values for network fees&#13;
    /// @param _token is the Atonomi Token contract address (must be ERC20)&#13;
    /// @param _settings is the Atonomi Network Settings contract address&#13;
    constructor (&#13;
        address _token,&#13;
        address _settings) public {&#13;
        require(_token != address(0), "token address cannot be 0x0");&#13;
        require(_settings != address(0), "settings address cannot be 0x0");&#13;
        token = ERC20Interface(_token);&#13;
        settings = SettingsInterface(_settings);&#13;
    }&#13;
&#13;
    ///&#13;
    /// EVENTS &#13;
    ///&#13;
    /// @notice emitted on successful device registration&#13;
    /// @param _sender manufacturer paying for registration&#13;
    /// @param _fee registration fee paid by manufacturer&#13;
    /// @param _deviceHashKey keccak256 hash of device id used as the key in devices mapping&#13;
    /// @param _manufacturerId of the manufacturer the device belongs to&#13;
    /// @param _deviceType is the type of device categorized by the manufacturer&#13;
    event DeviceRegistered(&#13;
        address indexed _sender,&#13;
        uint256 _fee,&#13;
        bytes32 indexed _deviceHashKey,&#13;
        bytes32 indexed _manufacturerId,&#13;
        bytes32 _deviceType&#13;
    );&#13;
&#13;
    /// @notice emitted on successful device activation&#13;
    /// @param _sender manufacturer or device owner paying for activation&#13;
    /// @param _fee registration fee paid by manufacturer&#13;
    /// @param _deviceId the real device id (only revealed after activation)&#13;
    /// @param _manufacturerId of the manufacturer the device belongs to&#13;
    /// @param _deviceType is the type of device categorized by the manufacturer&#13;
    event DeviceActivated(&#13;
        address indexed _sender,&#13;
        uint256 _fee,&#13;
        bytes32 indexed _deviceId,&#13;
        bytes32 indexed _manufacturerId,&#13;
        bytes32 _deviceType&#13;
    );&#13;
&#13;
    /// @notice emitted on reputation change for a device&#13;
    /// @param _deviceId device id of the target device&#13;
    /// @param _deviceType is the type of device categorized by the manufacturer&#13;
    /// @param _newScore updated reputation score&#13;
    /// @param _irnNode IRN node submitting the new reputation&#13;
    /// @param _irnReward tokens awarded to irn node&#13;
    /// @param _manufacturerWallet manufacturer associated with the device is rewared a share of tokens&#13;
    /// @param _manufacturerReward tokens awarded to contributor&#13;
    event ReputationScoreUpdated(&#13;
        bytes32 indexed _deviceId,&#13;
        bytes32 _deviceType,&#13;
        bytes32 _newScore,&#13;
        address indexed _irnNode,&#13;
        uint256 _irnReward,&#13;
        address indexed _manufacturerWallet,&#13;
        uint256 _manufacturerReward&#13;
    );&#13;
&#13;
    /// @notice emitted on successful addition of network member address&#13;
    /// @param _sender ethereum account of participant that made the change&#13;
    /// @param _member address of added member&#13;
    /// @param _memberId manufacturer id for manufacturer, otherwise 0x0&#13;
    event NetworkMemberAdded(&#13;
        address indexed _sender,&#13;
        address indexed _member,&#13;
        bytes32 indexed _memberId&#13;
    );&#13;
&#13;
    /// @notice emitted on successful removal of network member address&#13;
    /// @param _sender ethereum account of participant that made the change&#13;
    /// @param _member address of removed member&#13;
    /// @param _memberId manufacturer id for manufacturer, otherwise 0x0&#13;
    event NetworkMemberRemoved(&#13;
        address indexed _sender,&#13;
        address indexed _member,&#13;
        bytes32 indexed _memberId&#13;
    );&#13;
&#13;
    /// @notice emitted everytime a manufacturer changes their wallet for rewards&#13;
    /// @param _old ethereum account&#13;
    /// @param _new ethereum account&#13;
    /// @param _manufacturerId that the member belongs to&#13;
    event ManufacturerRewardWalletChanged(&#13;
        address indexed _old,&#13;
        address indexed _new,&#13;
        bytes32 indexed _manufacturerId&#13;
    );&#13;
&#13;
    /// @notice emitted everytime a token pool reward amount changes&#13;
    /// @param _sender ethereum account of the token pool owner&#13;
    /// @param _newReward new reward value in ATMI tokens&#13;
    event TokenPoolRewardUpdated(&#13;
        address indexed _sender,&#13;
        uint256 _newReward&#13;
    );&#13;
&#13;
    /// @notice emitted everytime someone donates tokens to a manufacturer&#13;
    /// @param _sender ethereum account of the donater&#13;
    /// @param _manufacturerId of the manufacturer&#13;
    /// @param _manufacturer ethereum account&#13;
    /// @param _amount of tokens deposited&#13;
    event TokensDeposited(&#13;
        address indexed _sender,&#13;
        bytes32 indexed _manufacturerId,&#13;
        address indexed _manufacturer,&#13;
        uint256 _amount&#13;
    );&#13;
    &#13;
    /// @notice emitted everytime a participant withdraws from token pool&#13;
    /// @param _sender ethereum account of participant that made the change&#13;
    /// @param _amount tokens withdrawn&#13;
    event TokensWithdrawn(&#13;
        address indexed _sender,&#13;
        uint256 _amount&#13;
    );&#13;
&#13;
    /// @notice emitted everytime the default reputation for a manufacturer changes&#13;
    /// @param _sender ethereum account of participant that made the change&#13;
    /// @param _manufacturerId of the manufacturer&#13;
    /// @param _newDefaultScore to use for newly registered devices&#13;
    event DefaultReputationScoreChanged(&#13;
        address indexed _sender,&#13;
        bytes32 indexed _manufacturerId,&#13;
        bytes32 _newDefaultScore&#13;
    );&#13;
&#13;
    ///&#13;
    /// DEVICE ONBOARDING&#13;
    ///&#13;
    /// @notice registers device on the Atonomi network&#13;
    /// @param _deviceIdHash keccak256 hash of the device's id (needs to be hashed by caller)&#13;
    /// @param _deviceType is the type of device categorized by the manufacturer&#13;
    /// @dev devicePublicKey is public key used by IRN Nodes for validation&#13;
    /// @return true if successful, otherwise false&#13;
    /// @dev msg.sender is expected to be the manufacturer&#13;
    /// @dev tokens will be deducted from the manufacturer and added to the token pool&#13;
    /// @dev owner has ability to pause this operation&#13;
    function registerDevice(&#13;
        bytes32 _deviceIdHash,&#13;
        bytes32 _deviceType,&#13;
        bytes32 _devicePublicKey)&#13;
        public onlyManufacturer whenNotPaused returns (bool)&#13;
    {&#13;
        uint256 registrationFee = settings.registrationFee();&#13;
        Device memory d = _registerDevice(msg.sender, _deviceIdHash, _deviceType, _devicePublicKey);&#13;
        emit DeviceRegistered(&#13;
            msg.sender,&#13;
            registrationFee,&#13;
            _deviceIdHash,&#13;
            d.manufacturerId,&#13;
            _deviceType);&#13;
        _depositTokens(msg.sender, registrationFee);&#13;
        require(token.transferFrom(msg.sender, address(this), registrationFee), "transferFrom failed");&#13;
        return true;&#13;
    }&#13;
&#13;
    /// @notice Activates the device&#13;
    /// @param _deviceId id of the real device id to be activated (not the hash of the device id)&#13;
    /// @return true if successful, otherwise false&#13;
    /// @dev if the hash doesnt match, the device is considered not registered and will throw&#13;
    /// @dev anyone with the device id (in hand) is considered the device owner&#13;
    /// @dev tokens will be deducted from the device owner and added to the token pool&#13;
    /// @dev owner has ability to pause this operation&#13;
    function activateDevice(bytes32 _deviceId) public whenNotPaused returns (bool) {&#13;
        uint256 activationFee = settings.activationFee();&#13;
        Device memory d = _activateDevice(_deviceId);&#13;
        emit DeviceActivated(msg.sender, activationFee, _deviceId, d.manufacturerId, d.deviceType);&#13;
        address manufacturer = manufacturerRewards[d.manufacturerId];&#13;
        require(manufacturer != address(this), "manufacturer is unknown");&#13;
        _depositTokens(manufacturer, activationFee);&#13;
        require(token.transferFrom(msg.sender, address(this), activationFee), "transferFrom failed");&#13;
        return true;&#13;
    }&#13;
&#13;
    /// @notice Registers and immediately activates device, used by manufacturers to prepay activation&#13;
    /// @param _deviceId id of the real device id to be activated (not the has of the device id)&#13;
    /// @param _deviceType is the type of device categorized by the manufacturer&#13;
    /// @return true if successful, otherwise false&#13;
    /// @dev since the manufacturer is trusted, no need for the caller to hash the device id&#13;
    /// @dev msg.sender is expected to be the manufacturer&#13;
    /// @dev tokens will be deducted from the manufacturer and added to the token pool&#13;
    /// @dev owner has ability to pause this operation&#13;
    function registerAndActivateDevice(&#13;
        bytes32 _deviceId,&#13;
        bytes32 _deviceType,&#13;
        bytes32 _devicePublicKey) &#13;
        public onlyManufacturer whenNotPaused returns (bool)&#13;
    {&#13;
        uint256 registrationFee = settings.registrationFee();&#13;
        uint256 activationFee = settings.activationFee();&#13;
&#13;
        bytes32 deviceIdHash = keccak256(_deviceId);&#13;
        Device memory d = _registerDevice(msg.sender, deviceIdHash, _deviceType, _devicePublicKey);&#13;
        bytes32 manufacturerId = d.manufacturerId;&#13;
        emit DeviceRegistered(msg.sender, registrationFee, deviceIdHash, manufacturerId, _deviceType);&#13;
&#13;
        d = _activateDevice(_deviceId);&#13;
        emit DeviceActivated(msg.sender, activationFee, _deviceId, manufacturerId, _deviceType);&#13;
&#13;
        uint256 fee = registrationFee.add(activationFee);&#13;
        _depositTokens(msg.sender, fee);&#13;
        require(token.transferFrom(msg.sender, address(this), fee), "transferFrom failed");&#13;
        return true;&#13;
    }&#13;
&#13;
    ///&#13;
    /// REPUTATION MANAGEMENT&#13;
    ///&#13;
    /// @notice updates reputation for a device&#13;
    /// @param _deviceId target device Id&#13;
    /// @param _reputationScore updated reputation score computed by the author&#13;
    /// @return true if successful, otherwise false&#13;
    /// @dev msg.sender is expected to be the reputation author (either irn node or the reputation auditor)&#13;
    /// @dev tokens will be deducted from the contract pool&#13;
    /// @dev author and manufacturer will be rewarded a split of the tokens&#13;
    /// @dev owner has ability to pause this operation&#13;
    function updateReputationScore(&#13;
        bytes32 _deviceId,&#13;
        bytes32 _reputationScore)&#13;
        public onlyIRNNode whenNotPaused returns (bool)&#13;
    {&#13;
        Device memory d = _updateReputationScore(_deviceId, _reputationScore);&#13;
&#13;
        address _manufacturerWallet = manufacturerRewards[d.manufacturerId];&#13;
        require(_manufacturerWallet != address(0), "_manufacturerWallet cannot be 0x0");&#13;
        require(_manufacturerWallet != msg.sender, "manufacturers cannot collect the full reward");&#13;
&#13;
        uint256 irnReward;&#13;
        uint256 manufacturerReward;&#13;
        (irnReward, manufacturerReward) = getReputationRewards(msg.sender, _manufacturerWallet, _deviceId);&#13;
        _distributeRewards(_manufacturerWallet, msg.sender, irnReward);&#13;
        _distributeRewards(_manufacturerWallet, _manufacturerWallet, manufacturerReward);&#13;
        emit ReputationScoreUpdated(&#13;
            _deviceId,&#13;
            d.deviceType,&#13;
            _reputationScore,&#13;
            msg.sender,&#13;
            irnReward,&#13;
            _manufacturerWallet,&#13;
            manufacturerReward);&#13;
        authorWrites[msg.sender][_deviceId] = block.number;&#13;
        return true;&#13;
    }&#13;
&#13;
    /// @notice computes the portion of the reputation reward allotted to the manufacturer and author&#13;
    /// @param author is the reputation node submitting the score&#13;
    /// @param manufacturer is the token pool owner&#13;
    /// @param deviceId of the device being updated&#13;
    /// @return irnReward and manufacturerReward&#13;
    function getReputationRewards(&#13;
        address author,&#13;
        address manufacturer,&#13;
        bytes32 deviceId)&#13;
        public view returns (uint256 irnReward, uint256 manufacturerReward)&#13;
    {&#13;
        uint256 lastWrite = authorWrites[author][deviceId];&#13;
        uint256 blocks = 0;&#13;
        if (lastWrite &gt; 0) {&#13;
            blocks = block.number.sub(lastWrite);&#13;
        }&#13;
        uint256 totalRewards = calculateReward(pools[manufacturer].rewardAmount, blocks);&#13;
        irnReward = totalRewards.mul(settings.reputationIRNNodeShare()).div(100);&#13;
        manufacturerReward = totalRewards.sub(irnReward);&#13;
    }&#13;
&#13;
    /// @notice computes total reward based on the authors last submission&#13;
    /// @param rewardAmount total amount available for reward&#13;
    /// @param blocksSinceLastWrite number of blocks since last write&#13;
    /// @return actual reward available&#13;
    function calculateReward(uint256 rewardAmount, uint256 blocksSinceLastWrite) public view returns (uint256) {&#13;
        uint256 totalReward = rewardAmount;&#13;
        uint256 blockThreshold = settings.blockThreshold();&#13;
        if (blocksSinceLastWrite &gt; 0 &amp;&amp; blocksSinceLastWrite &lt; blockThreshold) {&#13;
            uint256 multiplier = 10 ** uint256(token.decimals());&#13;
            totalReward = rewardAmount.mul(blocksSinceLastWrite.mul(multiplier)).div(blockThreshold.mul(multiplier));&#13;
        }&#13;
        return totalReward;&#13;
    }&#13;
&#13;
    ///&#13;
    /// BULK OPERATIONS&#13;
    ///&#13;
    /// @notice registers multiple devices on the Atonomi network&#13;
    /// @param _deviceIdHashes array of keccak256 hashed ID's of each device&#13;
    /// @param _deviceTypes array of types of device categorized by the manufacturer&#13;
    /// @param _devicePublicKeys array of public keys associated with the devices&#13;
    /// @return true if successful, otherwise false&#13;
    /// @dev msg.sender is expected to be the manufacturer&#13;
    /// @dev tokens will be deducted from the manufacturer and added to the token pool&#13;
    /// @dev owner has ability to pause this operation&#13;
    function registerDevices(&#13;
        bytes32[] _deviceIdHashes,&#13;
        bytes32[] _deviceTypes,&#13;
        bytes32[] _devicePublicKeys)&#13;
        public onlyManufacturer whenNotPaused returns (bool)&#13;
    {&#13;
        require(_deviceIdHashes.length &gt; 0, "at least one device is required");&#13;
        require(&#13;
            _deviceIdHashes.length == _deviceTypes.length,&#13;
            "device type array needs to be same size as devices"&#13;
        );&#13;
        require(&#13;
            _deviceIdHashes.length == _devicePublicKeys.length,&#13;
            "device public key array needs to be same size as devices"&#13;
        );&#13;
&#13;
        uint256 runningBalance = 0;&#13;
        uint256 registrationFee = settings.registrationFee();&#13;
        for (uint256 i = 0; i &lt; _deviceIdHashes.length; i++) {&#13;
            bytes32 deviceIdHash = _deviceIdHashes[i];&#13;
            bytes32 deviceType = _deviceTypes[i];&#13;
            bytes32 devicePublicKey = _devicePublicKeys[i];&#13;
            Device memory d = _registerDevice(msg.sender, deviceIdHash, deviceType, devicePublicKey);&#13;
            emit DeviceRegistered(msg.sender, registrationFee, deviceIdHash, d.manufacturerId, deviceType);&#13;
&#13;
            runningBalance = runningBalance.add(registrationFee);&#13;
        }&#13;
&#13;
        _depositTokens(msg.sender, runningBalance);&#13;
        require(token.transferFrom(msg.sender, address(this), runningBalance), "transferFrom failed");&#13;
        return true;&#13;
    }&#13;
&#13;
    ///&#13;
    /// WHITELIST PARTICIPANT MANAGEMENT&#13;
    ///&#13;
    /// @notice add a member to the network&#13;
    /// @param _member ethereum address of member to be added&#13;
    /// @param _isIRNAdmin true if an irn admin, otherwise false&#13;
    /// @param _isManufacturer true if an manufactuter, otherwise false&#13;
    /// @param _memberId manufacturer id for manufacturers, otherwise 0x0&#13;
    /// @return true if successful, otherwise false&#13;
    /// @dev _memberId is only relevant for manufacturer, but is flexible to allow use for other purposes&#13;
    /// @dev msg.sender is expected to be either owner or irn admin&#13;
    function addNetworkMember(&#13;
        address _member,&#13;
        bool _isIRNAdmin,&#13;
        bool _isManufacturer,&#13;
        bool _isIRNNode,&#13;
        bytes32 _memberId)&#13;
        public onlyIRNorOwner returns(bool)&#13;
    {&#13;
        NetworkMember storage m = network[_member];&#13;
        require(!m.isIRNAdmin, "already an irn admin");&#13;
        require(!m.isManufacturer, "already a manufacturer");&#13;
        require(!m.isIRNNode, "already an irn node");&#13;
        require(m.memberId == 0, "already assigned a member id");&#13;
&#13;
        m.isIRNAdmin = _isIRNAdmin;&#13;
        m.isManufacturer = _isManufacturer;&#13;
        m.isIRNNode = _isIRNNode;&#13;
        m.memberId = _memberId;&#13;
&#13;
        if (m.isManufacturer) {&#13;
            require(_memberId != 0, "manufacturer id is required");&#13;
&#13;
            // keep lookup for rewards in sync&#13;
            require(manufacturerRewards[m.memberId] == address(0), "manufacturer is already assigned");&#13;
            manufacturerRewards[m.memberId] = _member;&#13;
&#13;
            // set reputation reward if token pool doesnt exist&#13;
            if (pools[_member].rewardAmount == 0) {&#13;
                pools[_member].rewardAmount = settings.defaultReputationReward();&#13;
            }&#13;
        }&#13;
&#13;
        emit NetworkMemberAdded(msg.sender, _member, _memberId);&#13;
&#13;
        return true;&#13;
    }&#13;
&#13;
    /// @notice remove a member from the network&#13;
    /// @param _member ethereum address of member to be removed&#13;
    /// @return true if successful, otherwise false&#13;
    /// @dev msg.sender is expected to be either owner or irn admin&#13;
    function removeNetworkMember(address _member) public onlyIRNorOwner returns(bool) {&#13;
        bytes32 memberId = network[_member].memberId;&#13;
        if (network[_member].isManufacturer) {&#13;
            // remove token pool if there is a zero balance&#13;
            if (pools[_member].balance == 0) {&#13;
                delete pools[_member];&#13;
            }&#13;
&#13;
            // keep lookup with rewards in sync&#13;
            delete manufacturerRewards[memberId];&#13;
        }&#13;
&#13;
        delete network[_member];&#13;
&#13;
        emit NetworkMemberRemoved(msg.sender, _member, memberId);&#13;
        return true;&#13;
    }&#13;
&#13;
    //&#13;
    // TOKEN POOL MANAGEMENT&#13;
    //&#13;
    /// @notice changes the ethereum wallet for a manufacturer used in reputation rewards&#13;
    /// @param _new new ethereum account&#13;
    /// @return true if successful, otherwise false&#13;
    /// @dev msg.sender is expected to be original manufacturer account&#13;
    function changeManufacturerWallet(address _new) public onlyManufacturer returns (bool) {&#13;
        require(_new != address(0), "new address cannot be 0x0");&#13;
&#13;
        NetworkMember memory old = network[msg.sender];&#13;
        require(old.isManufacturer &amp;&amp; old.memberId != 0, "must be a manufacturer");&#13;
&#13;
        // copy permissions&#13;
        require(!network[_new].isIRNAdmin, "already an irn admin");&#13;
        require(!network[_new].isManufacturer, "already a manufacturer");&#13;
        require(!network[_new].isIRNNode, "already an irn node");&#13;
        require(network[_new].memberId == 0, "memberId already exists");&#13;
        network[_new] = NetworkMember(&#13;
            old.isIRNAdmin,&#13;
            old.isManufacturer,&#13;
            old.isIRNNode,&#13;
            old.memberId&#13;
        );&#13;
&#13;
        // transfer balance from old pool to the new pool&#13;
        require(pools[_new].balance == 0 &amp;&amp; pools[_new].rewardAmount == 0, "new token pool already exists");&#13;
        pools[_new].balance = pools[msg.sender].balance;&#13;
        pools[_new].rewardAmount = pools[msg.sender].rewardAmount;&#13;
        delete pools[msg.sender];&#13;
&#13;
        // update reward mapping&#13;
        manufacturerRewards[old.memberId] = _new;&#13;
&#13;
        // delete old member&#13;
        delete network[msg.sender];&#13;
&#13;
        emit ManufacturerRewardWalletChanged(msg.sender, _new, old.memberId);&#13;
        return true;&#13;
    }&#13;
&#13;
    /// @notice allows a token pool owner to set a new reward amount&#13;
    /// @param newReward new reputation reward amount&#13;
    /// @return true if successful, otherwise false&#13;
    /// @dev msg.sender expected to be manufacturer&#13;
    function setTokenPoolReward(uint256 newReward) public onlyManufacturer returns (bool) {&#13;
        require(newReward != 0, "newReward is required");&#13;
&#13;
        TokenPool storage p = pools[msg.sender];&#13;
        require(p.rewardAmount != newReward, "newReward should be different");&#13;
&#13;
        p.rewardAmount = newReward;&#13;
        emit TokenPoolRewardUpdated(msg.sender, newReward);&#13;
        return true;&#13;
    }&#13;
&#13;
    /// @notice anyone can donate tokens to a manufacturer's pool&#13;
    /// @param manufacturerId of the manufacturer to receive the tokens&#13;
    /// @param amount of tokens to deposit&#13;
    function depositTokens(bytes32 manufacturerId, uint256 amount) public returns (bool) {&#13;
        require(manufacturerId != 0, "manufacturerId is required");&#13;
        require(amount &gt; 0, "amount is required");&#13;
&#13;
        address manufacturer = manufacturerRewards[manufacturerId];&#13;
        require(manufacturer != address(0));&#13;
&#13;
        _depositTokens(manufacturer, amount);&#13;
        emit TokensDeposited(msg.sender, manufacturerId, manufacturer, amount);&#13;
&#13;
        require(token.transferFrom(msg.sender, address(this), amount));&#13;
        return true;&#13;
    }&#13;
&#13;
    /// @notice allows participants in the Atonomi network to claim their rewards&#13;
    /// @return true if successful, otherwise false&#13;
    /// @dev owner has ability to pause this operation&#13;
    function withdrawTokens() public whenNotPaused returns (bool) {&#13;
        uint256 amount = rewards[msg.sender];&#13;
        require(amount &gt; 0, "amount is zero");&#13;
&#13;
        rewards[msg.sender] = 0;&#13;
        emit TokensWithdrawn(msg.sender, amount);&#13;
&#13;
        require(token.transfer(msg.sender, amount), "token transfer failed");&#13;
        return true;&#13;
    }&#13;
&#13;
    /// @notice allows the owner to change the default reputation for manufacturers&#13;
    /// @param _manufacturerId of the manufacturer&#13;
    /// @param _newDefaultScore to use for newly registered devices&#13;
    /// @return true if successful, otherwise false&#13;
    /// @dev owner is the only one with this feature&#13;
    function setDefaultReputationForManufacturer(&#13;
        bytes32 _manufacturerId,&#13;
        bytes32 _newDefaultScore) public onlyOwner returns (bool) {&#13;
        require(_manufacturerId != 0, "_manufacturerId is required");&#13;
        require(&#13;
            _newDefaultScore != defaultManufacturerReputations[_manufacturerId],&#13;
            "_newDefaultScore should be different"&#13;
        );&#13;
&#13;
        defaultManufacturerReputations[_manufacturerId] = _newDefaultScore;&#13;
        emit DefaultReputationScoreChanged(msg.sender, _manufacturerId, _newDefaultScore);&#13;
        return true;&#13;
    }&#13;
&#13;
    ///&#13;
    /// INTERNAL FUNCTIONS&#13;
    ///&#13;
    /// @dev track balances of any deposits going into a token pool&#13;
    function _depositTokens(address _owner, uint256 _amount) internal {&#13;
        pools[_owner].balance = pools[_owner].balance.add(_amount);&#13;
    }&#13;
&#13;
    /// @dev track balances of any rewards going out of the token pool&#13;
    function _distributeRewards(address _manufacturer, address _owner, uint256 _amount) internal {&#13;
        require(_amount &gt; 0, "_amount is required");&#13;
        pools[_manufacturer].balance = pools[_manufacturer].balance.sub(_amount);&#13;
        rewards[_owner] = rewards[_owner].add(_amount);&#13;
    }&#13;
&#13;
    /// @dev ensure a device is validated for registration&#13;
    /// @dev updates device registry&#13;
    function _registerDevice(&#13;
        address _manufacturer,&#13;
        bytes32 _deviceIdHash,&#13;
        bytes32 _deviceType,&#13;
        bytes32 _devicePublicKey) internal returns (Device) {&#13;
        require(_manufacturer != address(0), "manufacturer is required");&#13;
        require(_deviceIdHash != 0, "device id hash is required");&#13;
        require(_deviceType != 0, "device type is required");&#13;
        require(_devicePublicKey != 0, "device public key is required");&#13;
&#13;
        Device storage d = devices[_deviceIdHash];&#13;
        require(!d.registered, "device is already registered");&#13;
        require(!d.activated, "device is already activated");&#13;
&#13;
        bytes32 manufacturerId = network[_manufacturer].memberId;&#13;
        require(manufacturerId != 0, "manufacturer id is unknown");&#13;
&#13;
        d.manufacturerId = manufacturerId;&#13;
        d.deviceType = _deviceType;&#13;
        d.registered = true;&#13;
        d.activated = false;&#13;
        d.reputationScore = defaultManufacturerReputations[manufacturerId];&#13;
        d.devicePublicKey = _devicePublicKey;&#13;
        return d;&#13;
    }&#13;
&#13;
    /// @dev ensure a device is validated for activation&#13;
    /// @dev updates device registry&#13;
    function _activateDevice(bytes32 _deviceId) internal returns (Device) {&#13;
        bytes32 deviceIdHash = keccak256(_deviceId);&#13;
        Device storage d = devices[deviceIdHash];&#13;
        require(d.registered, "not registered");&#13;
        require(!d.activated, "already activated");&#13;
        require(d.manufacturerId != 0, "no manufacturer id was found");&#13;
&#13;
        d.activated = true;&#13;
        return d;&#13;
    }&#13;
&#13;
    /// @dev ensure a device is validated for a new reputation score&#13;
    /// @dev updates device registry&#13;
    function _updateReputationScore(bytes32 _deviceId, bytes32 _reputationScore) internal returns (Device) {&#13;
        require(_deviceId != 0, "device id is empty");&#13;
&#13;
        Device storage d = devices[keccak256(_deviceId)];&#13;
        require(d.registered, "not registered");&#13;
        require(d.activated, "not activated");&#13;
        require(d.reputationScore != _reputationScore, "new score needs to be different");&#13;
&#13;
        d.reputationScore = _reputationScore;&#13;
        return d;&#13;
    }&#13;
}