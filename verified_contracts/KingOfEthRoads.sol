// File: contracts/GodMode.sol

/****************************************************
 *
 * Copyright 2018 BurzNest LLC. All rights reserved.
 *
 * The contents of this file are provided for review
 * and educational purposes ONLY. You MAY NOT use,
 * copy, distribute, or modify this software without
 * explicit written permission from BurzNest LLC.
 *
 ****************************************************/

pragma solidity ^0.4.24;

/// @title God Mode
/// @author Anthony Burzillo <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="a5c7d0d7dfe5c7d0d7dfcbc0d6d18bc6cac8">[email protected]</a>&gt;&#13;
/// @dev This contract provides a basic interface for God&#13;
///  in a contract as well as the ability for God to pause&#13;
///  the contract&#13;
contract GodMode {&#13;
    /// @dev Is the contract paused?&#13;
    bool public isPaused;&#13;
&#13;
    /// @dev God's address&#13;
    address public god;&#13;
&#13;
    /// @dev Only God can run this function&#13;
    modifier onlyGod()&#13;
    {&#13;
        require(god == msg.sender);&#13;
        _;&#13;
    }&#13;
&#13;
    /// @dev This function can only be run while the contract&#13;
    ///  is not paused&#13;
    modifier notPaused()&#13;
    {&#13;
        require(!isPaused);&#13;
        _;&#13;
    }&#13;
&#13;
    /// @dev This event is fired when the contract is paused&#13;
    event GodPaused();&#13;
&#13;
    /// @dev This event is fired when the contract is unpaused&#13;
    event GodUnpaused();&#13;
&#13;
    constructor() public&#13;
    {&#13;
        // Make the creator of the contract God&#13;
        god = msg.sender;&#13;
    }&#13;
&#13;
    /// @dev God can change the address of God&#13;
    /// @param _newGod The new address for God&#13;
    function godChangeGod(address _newGod) public onlyGod&#13;
    {&#13;
        god = _newGod;&#13;
    }&#13;
&#13;
    /// @dev God can pause the game&#13;
    function godPause() public onlyGod&#13;
    {&#13;
        isPaused = true;&#13;
&#13;
        emit GodPaused();&#13;
    }&#13;
&#13;
    /// @dev God can unpause the game&#13;
    function godUnpause() public onlyGod&#13;
    {&#13;
        isPaused = false;&#13;
&#13;
        emit GodUnpaused();&#13;
    }&#13;
}&#13;
&#13;
// File: contracts/KingOfEthAbstractInterface.sol&#13;
&#13;
/****************************************************&#13;
 *&#13;
 * Copyright 2018 BurzNest LLC. All rights reserved.&#13;
 *&#13;
 * The contents of this file are provided for review&#13;
 * and educational purposes ONLY. You MAY NOT use,&#13;
 * copy, distribute, or modify this software without&#13;
 * explicit written permission from BurzNest LLC.&#13;
 *&#13;
 ****************************************************/&#13;
&#13;
pragma solidity ^0.4.24;&#13;
&#13;
/// @title King of Eth Abstract Interface&#13;
/// @author Anthony Burzillo &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="751700070f351700070f1b1006015b161a18">[email protected]</a>&gt;&#13;
/// @dev Abstract interface contract for titles and taxes&#13;
contract KingOfEthAbstractInterface {&#13;
    /// @dev The address of the current King&#13;
    address public king;&#13;
&#13;
    /// @dev The address of the current Wayfarer&#13;
    address public wayfarer;&#13;
&#13;
    /// @dev Anyone can pay taxes&#13;
    function payTaxes() public payable;&#13;
}&#13;
&#13;
// File: contracts/KingOfEthBlindAuctionsReferencer.sol&#13;
&#13;
/****************************************************&#13;
 *&#13;
 * Copyright 2018 BurzNest LLC. All rights reserved.&#13;
 *&#13;
 * The contents of this file are provided for review&#13;
 * and educational purposes ONLY. You MAY NOT use,&#13;
 * copy, distribute, or modify this software without&#13;
 * explicit written permission from BurzNest LLC.&#13;
 *&#13;
 ****************************************************/&#13;
&#13;
pragma solidity ^0.4.24;&#13;
&#13;
&#13;
/// @title King of Eth: Blind Auctions Referencer&#13;
/// @author Anthony Burzillo &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="91f3e4e3ebd1f3e4e3ebfff4e2e5bff2fefc">[email protected]</a>&gt;&#13;
/// @dev This contract provides a reference to the blind auctions contract&#13;
contract KingOfEthBlindAuctionsReferencer is GodMode {&#13;
    /// @dev The address of the blind auctions contract&#13;
    address public blindAuctionsContract;&#13;
&#13;
    /// @dev Only the blind auctions contract can run this&#13;
    modifier onlyBlindAuctionsContract()&#13;
    {&#13;
        require(blindAuctionsContract == msg.sender);&#13;
        _;&#13;
    }&#13;
&#13;
    /// @dev God can set a new blind auctions contract&#13;
    /// @param _blindAuctionsContract the address of the blind auctions&#13;
    ///  contract&#13;
    function godSetBlindAuctionsContract(address _blindAuctionsContract)&#13;
        public&#13;
        onlyGod&#13;
    {&#13;
        blindAuctionsContract = _blindAuctionsContract;&#13;
    }&#13;
}&#13;
&#13;
// File: contracts/KingOfEthOpenAuctionsReferencer.sol&#13;
&#13;
/****************************************************&#13;
 *&#13;
 * Copyright 2018 BurzNest LLC. All rights reserved.&#13;
 *&#13;
 * The contents of this file are provided for review&#13;
 * and educational purposes ONLY. You MAY NOT use,&#13;
 * copy, distribute, or modify this software without&#13;
 * explicit written permission from BurzNest LLC.&#13;
 *&#13;
 ****************************************************/&#13;
&#13;
pragma solidity ^0.4.24;&#13;
&#13;
&#13;
/// @title King of Eth: Open Auctions Referencer&#13;
/// @author Anthony Burzillo &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="b4d6c1c6cef4d6c1c6cedad1c7c09ad7dbd9">[email protected]</a>&gt;&#13;
/// @dev This contract provides a reference to the open auctions contract&#13;
contract KingOfEthOpenAuctionsReferencer is GodMode {&#13;
    /// @dev The address of the auctions contract&#13;
    address public openAuctionsContract;&#13;
&#13;
    /// @dev Only the open auctions contract can run this&#13;
    modifier onlyOpenAuctionsContract()&#13;
    {&#13;
        require(openAuctionsContract == msg.sender);&#13;
        _;&#13;
    }&#13;
&#13;
    /// @dev God can set a new auctions contract&#13;
    function godSetOpenAuctionsContract(address _openAuctionsContract)&#13;
        public&#13;
        onlyGod&#13;
    {&#13;
        openAuctionsContract = _openAuctionsContract;&#13;
    }&#13;
}&#13;
&#13;
// File: contracts/KingOfEthAuctionsReferencer.sol&#13;
&#13;
/****************************************************&#13;
 *&#13;
 * Copyright 2018 BurzNest LLC. All rights reserved.&#13;
 *&#13;
 * The contents of this file are provided for review&#13;
 * and educational purposes ONLY. You MAY NOT use,&#13;
 * copy, distribute, or modify this software without&#13;
 * explicit written permission from BurzNest LLC.&#13;
 *&#13;
 ****************************************************/&#13;
&#13;
pragma solidity ^0.4.24;&#13;
&#13;
&#13;
&#13;
/// @title King of Eth: Auctions Referencer&#13;
/// @author Anthony Burzillo &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="563423242c163423242c383325227835393b">[email protected]</a>&gt;&#13;
/// @dev This contract provides a reference to the auctions contracts&#13;
contract KingOfEthAuctionsReferencer is&#13;
      KingOfEthBlindAuctionsReferencer&#13;
    , KingOfEthOpenAuctionsReferencer&#13;
{&#13;
    /// @dev Only an auctions contract can run this&#13;
    modifier onlyAuctionsContract()&#13;
    {&#13;
        require(blindAuctionsContract == msg.sender&#13;
             || openAuctionsContract == msg.sender);&#13;
        _;&#13;
    }&#13;
}&#13;
&#13;
// File: contracts/KingOfEthReferencer.sol&#13;
&#13;
/****************************************************&#13;
 *&#13;
 * Copyright 2018 BurzNest LLC. All rights reserved.&#13;
 *&#13;
 * The contents of this file are provided for review&#13;
 * and educational purposes ONLY. You MAY NOT use,&#13;
 * copy, distribute, or modify this software without&#13;
 * explicit written permission from BurzNest LLC.&#13;
 *&#13;
 ****************************************************/&#13;
&#13;
pragma solidity ^0.4.24;&#13;
&#13;
&#13;
/// @title King of Eth Referencer&#13;
/// @author Anthony Burzillo &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="187a6d6a62587a6d6a62767d6b6c367b7775">[email protected]</a>&gt;&#13;
/// @dev Functionality to allow contracts to reference the king contract&#13;
contract KingOfEthReferencer is GodMode {&#13;
    /// @dev The address of the king contract&#13;
    address public kingOfEthContract;&#13;
&#13;
    /// @dev Only the king contract can run this&#13;
    modifier onlyKingOfEthContract()&#13;
    {&#13;
        require(kingOfEthContract == msg.sender);&#13;
        _;&#13;
    }&#13;
&#13;
    /// @dev God can change the king contract&#13;
    /// @param _kingOfEthContract The new address&#13;
    function godSetKingOfEthContract(address _kingOfEthContract)&#13;
        public&#13;
        onlyGod&#13;
    {&#13;
        kingOfEthContract = _kingOfEthContract;&#13;
    }&#13;
}&#13;
&#13;
// File: contracts/KingOfEthBoard.sol&#13;
&#13;
/****************************************************&#13;
 *&#13;
 * Copyright 2018 BurzNest LLC. All rights reserved.&#13;
 *&#13;
 * The contents of this file are provided for review&#13;
 * and educational purposes ONLY. You MAY NOT use,&#13;
 * copy, distribute, or modify this software without&#13;
 * explicit written permission from BurzNest LLC.&#13;
 *&#13;
 ****************************************************/&#13;
&#13;
pragma solidity ^0.4.24;&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
/// @title King of Eth: Board&#13;
/// @author Anthony Burzillo &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="157760676f557760676f7b7066613b767a78">[email protected]</a>&gt;&#13;
/// @dev Contract for board&#13;
contract KingOfEthBoard is&#13;
      GodMode&#13;
    , KingOfEthAuctionsReferencer&#13;
    , KingOfEthReferencer&#13;
{&#13;
    /// @dev x coordinate of the top left corner of the boundary&#13;
    uint public boundX1 = 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffef;&#13;
&#13;
    /// @dev y coordinate of the top left corner of the boundary&#13;
    uint public boundY1 = 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffef;&#13;
&#13;
    /// @dev x coordinate of the bottom right corner of the boundary&#13;
    uint public boundX2 = 0x800000000000000000000000000000000000000000000000000000000000000f;&#13;
&#13;
    /// @dev y coordinate of the bottom right corner of the boundary&#13;
    uint public boundY2 = 0x800000000000000000000000000000000000000000000000000000000000000f;&#13;
&#13;
    /// @dev Number used to divide the total number of house locations&#13;
    /// after any expansion to yield the number of auctions that  will be&#13;
    /// available to start for the expansion's duration&#13;
    uint public constant auctionsAvailableDivisor = 10;&#13;
&#13;
    /// @dev Amount of time the King must wait between increasing the board&#13;
    uint public constant kingTimeBetweenIncrease = 2 weeks;&#13;
&#13;
    /// @dev Amount of time the Wayfarer must wait between increasing the board&#13;
    uint public constant wayfarerTimeBetweenIncrease = 3 weeks;&#13;
&#13;
    /// @dev Amount of time that anyone but the King or Wayfarer must wait&#13;
    ///  before increasing the board&#13;
    uint public constant plebTimeBetweenIncrease = 4 weeks;&#13;
&#13;
    /// @dev The last time the board was increased in size&#13;
    uint public lastIncreaseTime;&#13;
&#13;
    /// @dev The direction of the next increase&#13;
    uint8 public nextIncreaseDirection;&#13;
&#13;
    /// @dev The number of auctions that players may choose to start&#13;
    ///  for this expansion&#13;
    uint public auctionsRemaining;&#13;
&#13;
    constructor() public&#13;
    {&#13;
        // Game is paused as God must start it&#13;
        isPaused = true;&#13;
&#13;
        // Set the auctions remaining&#13;
        setAuctionsAvailableForBounds();&#13;
    }&#13;
&#13;
    /// @dev Fired when the board is increased in size&#13;
    event BoardSizeIncreased(&#13;
          address initiator&#13;
        , uint newBoundX1&#13;
        , uint newBoundY1&#13;
        , uint newBoundX2&#13;
        , uint newBoundY2&#13;
        , uint lastIncreaseTime&#13;
        , uint nextIncreaseDirection&#13;
        , uint auctionsRemaining&#13;
    );&#13;
&#13;
    /// @dev Only the King can run this&#13;
    modifier onlyKing()&#13;
    {&#13;
        require(KingOfEthAbstractInterface(kingOfEthContract).king() == msg.sender);&#13;
        _;&#13;
    }&#13;
&#13;
    /// @dev Only the Wayfarer can run this&#13;
    modifier onlyWayfarer()&#13;
    {&#13;
        require(KingOfEthAbstractInterface(kingOfEthContract).wayfarer() == msg.sender);&#13;
        _;&#13;
    }&#13;
&#13;
    /// @dev Set the total auctions available&#13;
    function setAuctionsAvailableForBounds() private&#13;
    {&#13;
        uint boundDiffX = boundX2 - boundX1;&#13;
        uint boundDiffY = boundY2 - boundY1;&#13;
&#13;
        auctionsRemaining = boundDiffX * boundDiffY / 2 / auctionsAvailableDivisor;&#13;
    }&#13;
&#13;
    /// @dev Increase the board's size making sure to keep steady at&#13;
    ///  the maximum outer bounds&#13;
    function increaseBoard() private&#13;
    {&#13;
        // The length of increase&#13;
        uint _increaseLength;&#13;
&#13;
        // If this increase direction is right&#13;
        if(0 == nextIncreaseDirection)&#13;
        {&#13;
            _increaseLength = boundX2 - boundX1;&#13;
            uint _updatedX2 = boundX2 + _increaseLength;&#13;
&#13;
            // Stay within bounds&#13;
            if(_updatedX2 &lt;= boundX2 || _updatedX2 &lt;= _increaseLength)&#13;
            {&#13;
                boundX2 = ~uint(0);&#13;
            }&#13;
            else&#13;
            {&#13;
                boundX2 = _updatedX2;&#13;
            }&#13;
        }&#13;
        // If this increase direction is down&#13;
        else if(1 == nextIncreaseDirection)&#13;
        {&#13;
            _increaseLength = boundY2 - boundY1;&#13;
            uint _updatedY2 = boundY2 + _increaseLength;&#13;
&#13;
            // Stay within bounds&#13;
            if(_updatedY2 &lt;= boundY2 || _updatedY2 &lt;= _increaseLength)&#13;
            {&#13;
                boundY2 = ~uint(0);&#13;
            }&#13;
            else&#13;
            {&#13;
                boundY2 = _updatedY2;&#13;
            }&#13;
        }&#13;
        // If this increase direction is left&#13;
        else if(2 == nextIncreaseDirection)&#13;
        {&#13;
            _increaseLength = boundX2 - boundX1;&#13;
&#13;
            // Stay within bounds&#13;
            if(boundX1 &lt;= _increaseLength)&#13;
            {&#13;
                boundX1 = 0;&#13;
            }&#13;
            else&#13;
            {&#13;
                boundX1 -= _increaseLength;&#13;
            }&#13;
        }&#13;
        // If this increase direction is up&#13;
        else if(3 == nextIncreaseDirection)&#13;
        {&#13;
            _increaseLength = boundY2 - boundY1;&#13;
&#13;
            // Stay within bounds&#13;
            if(boundY1 &lt;= _increaseLength)&#13;
            {&#13;
                boundY1 = 0;&#13;
            }&#13;
            else&#13;
            {&#13;
                boundY1 -= _increaseLength;&#13;
            }&#13;
        }&#13;
&#13;
        // The last increase time is now&#13;
        lastIncreaseTime = now;&#13;
&#13;
        // Set the next increase direction&#13;
        nextIncreaseDirection = (nextIncreaseDirection + 1) % 4;&#13;
&#13;
        // Reset the auctions available&#13;
        setAuctionsAvailableForBounds();&#13;
&#13;
        emit BoardSizeIncreased(&#13;
              msg.sender&#13;
            , boundX1&#13;
            , boundY1&#13;
            , boundX2&#13;
            , boundY2&#13;
            , now&#13;
            , nextIncreaseDirection&#13;
            , auctionsRemaining&#13;
        );&#13;
    }&#13;
&#13;
    /// @dev God can start the game&#13;
    function godStartGame() public onlyGod&#13;
    {&#13;
        // Reset increase times&#13;
        lastIncreaseTime = now;&#13;
&#13;
        // Unpause the game&#13;
        godUnpause();&#13;
    }&#13;
&#13;
    /// @dev The auctions contracts can decrement the number&#13;
    ///  of auctions that are available to be started&#13;
    function auctionsDecrementAuctionsRemaining()&#13;
        public&#13;
        onlyAuctionsContract&#13;
    {&#13;
        auctionsRemaining -= 1;&#13;
    }&#13;
&#13;
    /// @dev The auctions contracts can increment the number&#13;
    ///  of auctions that are available to be started when&#13;
    ///  an auction ends wihout a winner&#13;
    function auctionsIncrementAuctionsRemaining()&#13;
        public&#13;
        onlyAuctionsContract&#13;
    {&#13;
        auctionsRemaining += 1;&#13;
    }&#13;
&#13;
    /// @dev The King can increase the board much faster than the plebs&#13;
    function kingIncreaseBoard()&#13;
        public&#13;
        onlyKing&#13;
    {&#13;
        // Require enough time has passed since the last increase&#13;
        require(lastIncreaseTime + kingTimeBetweenIncrease &lt; now);&#13;
&#13;
        increaseBoard();&#13;
    }&#13;
&#13;
    /// @dev The Wayfarer can increase the board faster than the plebs&#13;
    function wayfarerIncreaseBoard()&#13;
        public&#13;
        onlyWayfarer&#13;
    {&#13;
        // Require enough time has passed since the last increase&#13;
        require(lastIncreaseTime + wayfarerTimeBetweenIncrease &lt; now);&#13;
&#13;
        increaseBoard();&#13;
    }&#13;
&#13;
    /// @dev Any old pleb can increase the board&#13;
    function plebIncreaseBoard() public&#13;
    {&#13;
        // Require enough time has passed since the last increase&#13;
        require(lastIncreaseTime + plebTimeBetweenIncrease &lt; now);&#13;
&#13;
        increaseBoard();&#13;
    }&#13;
}&#13;
&#13;
// File: contracts/KingOfEthBoardReferencer.sol&#13;
&#13;
/****************************************************&#13;
 *&#13;
 * Copyright 2018 BurzNest LLC. All rights reserved.&#13;
 *&#13;
 * The contents of this file are provided for review&#13;
 * and educational purposes ONLY. You MAY NOT use,&#13;
 * copy, distribute, or modify this software without&#13;
 * explicit written permission from BurzNest LLC.&#13;
 *&#13;
 ****************************************************/&#13;
&#13;
pragma solidity ^0.4.24;&#13;
&#13;
&#13;
/// @title King of Eth: Board Referencer&#13;
/// @author Anthony Burzillo &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="610314131b210314131b0f0412154f020e0c">[email protected]</a>&gt;&#13;
/// @dev Functionality to allow contracts to reference the board contract&#13;
contract KingOfEthBoardReferencer is GodMode {&#13;
    /// @dev The address of the board contract&#13;
    address public boardContract;&#13;
&#13;
    /// @dev Only the board contract can run this&#13;
    modifier onlyBoardContract()&#13;
    {&#13;
        require(boardContract == msg.sender);&#13;
        _;&#13;
    }&#13;
&#13;
    /// @dev God can change the board contract&#13;
    /// @param _boardContract The new address&#13;
    function godSetBoardContract(address _boardContract)&#13;
        public&#13;
        onlyGod&#13;
    {&#13;
        boardContract = _boardContract;&#13;
    }&#13;
}&#13;
&#13;
// File: contracts/KingOfEthHousesAbstractInterface.sol&#13;
&#13;
/****************************************************&#13;
 *&#13;
 * Copyright 2018 BurzNest LLC. All rights reserved.&#13;
 *&#13;
 * The contents of this file are provided for review&#13;
 * and educational purposes ONLY. You MAY NOT use,&#13;
 * copy, distribute, or modify this software without&#13;
 * explicit written permission from BurzNest LLC.&#13;
 *&#13;
 ****************************************************/&#13;
&#13;
pragma solidity ^0.4.24;&#13;
&#13;
/// @title King of Eth: Houses Abstract Interface&#13;
/// @author Anthony Burzillo &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="254750575f654750575f4b4056510b464a48">[email protected]</a>&gt;&#13;
/// @dev Abstract interface contract for houses&#13;
contract KingOfEthHousesAbstractInterface {&#13;
    /// @dev Get the owner of the house at some location&#13;
    /// @param _x The x coordinate of the house&#13;
    /// @param _y The y coordinate of the house&#13;
    /// @return The address of the owner&#13;
    function ownerOf(uint _x, uint _y) public view returns(address);&#13;
&#13;
    /// @dev Get the level of the house at some location&#13;
    /// @param _x The x coordinate of the house&#13;
    /// @param _y The y coordinate of the house&#13;
    /// @return The level of the house&#13;
    function level(uint _x, uint _y) public view returns(uint8);&#13;
&#13;
    /// @dev The auctions contracts can set the owner of a house after an auction&#13;
    /// @param _x The x coordinate of the house&#13;
    /// @param _y The y coordinate of the house&#13;
    /// @param _owner The new owner of the house&#13;
    function auctionsSetOwner(uint _x, uint _y, address _owner) public;&#13;
&#13;
    /// @dev The house realty contract can transfer house ownership&#13;
    /// @param _x The x coordinate of the house&#13;
    /// @param _y The y coordinate of the house&#13;
    /// @param _from The previous owner of house&#13;
    /// @param _to The new owner of house&#13;
    function houseRealtyTransferOwnership(&#13;
          uint _x&#13;
        , uint _y&#13;
        , address _from&#13;
        , address _to&#13;
    ) public;&#13;
}&#13;
&#13;
// File: contracts/KingOfEthHousesReferencer.sol&#13;
&#13;
/****************************************************&#13;
 *&#13;
 * Copyright 2018 BurzNest LLC. All rights reserved.&#13;
 *&#13;
 * The contents of this file are provided for review&#13;
 * and educational purposes ONLY. You MAY NOT use,&#13;
 * copy, distribute, or modify this software without&#13;
 * explicit written permission from BurzNest LLC.&#13;
 *&#13;
 ****************************************************/&#13;
&#13;
pragma solidity ^0.4.24;&#13;
&#13;
&#13;
/// @title King of Eth: Houses Referencer&#13;
/// @author Anthony Burzillo &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="c6a4b3b4bc86a4b3b4bca8a3b5b2e8a5a9ab">[email protected]</a>&gt;&#13;
/// @dev Provides functionality to reference the houses contract&#13;
contract KingOfEthHousesReferencer is GodMode {&#13;
    /// @dev The houses contract's address&#13;
    address public housesContract;&#13;
&#13;
    /// @dev Only the houses contract can run this function&#13;
    modifier onlyHousesContract()&#13;
    {&#13;
        require(housesContract == msg.sender);&#13;
        _;&#13;
    }&#13;
&#13;
    /// @dev God can set the realty contract&#13;
    /// @param _housesContract The new address&#13;
    function godSetHousesContract(address _housesContract)&#13;
        public&#13;
        onlyGod&#13;
    {&#13;
        housesContract = _housesContract;&#13;
    }&#13;
}&#13;
&#13;
// File: contracts/KingOfEthEthExchangeReferencer.sol&#13;
&#13;
/****************************************************&#13;
 *&#13;
 * Copyright 2018 BurzNest LLC. All rights reserved.&#13;
 *&#13;
 * The contents of this file are provided for review&#13;
 * and educational purposes ONLY. You MAY NOT use,&#13;
 * copy, distribute, or modify this software without&#13;
 * explicit written permission from BurzNest LLC.&#13;
 *&#13;
 ****************************************************/&#13;
&#13;
pragma solidity ^0.4.24;&#13;
&#13;
&#13;
/// @title King of Eth: Resource-to-ETH Exchange Referencer&#13;
/// @author Anthony Burzillo &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="3f5d4a4d457f5d4a4d45515a4c4b115c5052">[email protected]</a>&gt;&#13;
/// @dev Provides functionality to interface with the&#13;
///  ETH exchange contract&#13;
contract KingOfEthEthExchangeReferencer is GodMode {&#13;
    /// @dev Address of the ETH exchange contract&#13;
    address public ethExchangeContract;&#13;
&#13;
    /// @dev Only the ETH exchange contract may run this function&#13;
    modifier onlyEthExchangeContract()&#13;
    {&#13;
        require(ethExchangeContract == msg.sender);&#13;
        _;&#13;
    }&#13;
&#13;
    /// @dev God may set the ETH exchange contract's address&#13;
    /// @dev _ethExchangeContract The new address&#13;
    function godSetEthExchangeContract(address _ethExchangeContract)&#13;
        public&#13;
        onlyGod&#13;
    {&#13;
        ethExchangeContract = _ethExchangeContract;&#13;
    }&#13;
}&#13;
&#13;
// File: contracts/KingOfEthResourceExchangeReferencer.sol&#13;
&#13;
/****************************************************&#13;
 *&#13;
 * Copyright 2018 BurzNest LLC. All rights reserved.&#13;
 *&#13;
 * The contents of this file are provided for review&#13;
 * and educational purposes ONLY. You MAY NOT use,&#13;
 * copy, distribute, or modify this software without&#13;
 * explicit written permission from BurzNest LLC.&#13;
 *&#13;
 ****************************************************/&#13;
&#13;
pragma solidity ^0.4.24;&#13;
&#13;
&#13;
/// @title King of Eth: Resource-to-Resource Exchange Referencer&#13;
/// @author Anthony Burzillo &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="553720272f153720272f3b3026217b363a38">[email protected]</a>&gt;&#13;
/// @dev Provides functionality to interface with the&#13;
///  resource-to-resource contract&#13;
contract KingOfEthResourceExchangeReferencer is GodMode {&#13;
    /// @dev Address of the resource-to-resource contract&#13;
    address public resourceExchangeContract;&#13;
&#13;
    /// @dev Only the resource-to-resource contract may run this function&#13;
    modifier onlyResourceExchangeContract()&#13;
    {&#13;
        require(resourceExchangeContract == msg.sender);&#13;
        _;&#13;
    }&#13;
&#13;
    /// @dev God may set the resource-to-resource contract's address&#13;
    /// @dev _resourceExchangeContract The new address&#13;
    function godSetResourceExchangeContract(address _resourceExchangeContract)&#13;
        public&#13;
        onlyGod&#13;
    {&#13;
        resourceExchangeContract = _resourceExchangeContract;&#13;
    }&#13;
}&#13;
&#13;
// File: contracts/KingOfEthExchangeReferencer.sol&#13;
&#13;
/****************************************************&#13;
 *&#13;
 * Copyright 2018 BurzNest LLC. All rights reserved.&#13;
 *&#13;
 * The contents of this file are provided for review&#13;
 * and educational purposes ONLY. You MAY NOT use,&#13;
 * copy, distribute, or modify this software without&#13;
 * explicit written permission from BurzNest LLC.&#13;
 *&#13;
 ****************************************************/&#13;
&#13;
pragma solidity ^0.4.24;&#13;
&#13;
&#13;
&#13;
&#13;
/// @title King of Eth: Exchange Referencer&#13;
/// @author Anthony Burzillo &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="482a3d3a32082a3d3a32262d3b3c662b2725">[email protected]</a>&gt;&#13;
/// @dev Provides functionality to interface with the exchange contract&#13;
contract KingOfEthExchangeReferencer is&#13;
      GodMode&#13;
    , KingOfEthEthExchangeReferencer&#13;
    , KingOfEthResourceExchangeReferencer&#13;
{&#13;
    /// @dev Only one of the exchange contracts may&#13;
    ///  run this function&#13;
    modifier onlyExchangeContract()&#13;
    {&#13;
        require(&#13;
               ethExchangeContract == msg.sender&#13;
            || resourceExchangeContract == msg.sender&#13;
        );&#13;
        _;&#13;
    }&#13;
}&#13;
&#13;
// File: contracts/KingOfEthResourcesInterfaceReferencer.sol&#13;
&#13;
/****************************************************&#13;
 *&#13;
 * Copyright 2018 BurzNest LLC. All rights reserved.&#13;
 *&#13;
 * The contents of this file are provided for review&#13;
 * and educational purposes ONLY. You MAY NOT use,&#13;
 * copy, distribute, or modify this software without&#13;
 * explicit written permission from BurzNest LLC.&#13;
 *&#13;
 ****************************************************/&#13;
&#13;
pragma solidity ^0.4.24;&#13;
&#13;
&#13;
/// @title King of Eth: Resources Interface Referencer&#13;
/// @author Anthony Burzillo &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="a1c3d4d3dbe1c3d4d3dbcfc4d2d58fc2cecc">[email protected]</a>&gt;&#13;
/// @dev Provides functionality to reference the resource interface contract&#13;
contract KingOfEthResourcesInterfaceReferencer is GodMode {&#13;
    /// @dev The interface contract's address&#13;
    address public interfaceContract;&#13;
&#13;
    /// @dev Only the interface contract can run this function&#13;
    modifier onlyInterfaceContract()&#13;
    {&#13;
        require(interfaceContract == msg.sender);&#13;
        _;&#13;
    }&#13;
&#13;
    /// @dev God can set the realty contract&#13;
    /// @param _interfaceContract The new address&#13;
    function godSetInterfaceContract(address _interfaceContract)&#13;
        public&#13;
        onlyGod&#13;
    {&#13;
        interfaceContract = _interfaceContract;&#13;
    }&#13;
}&#13;
&#13;
// File: contracts/KingOfEthResource.sol&#13;
&#13;
/****************************************************&#13;
 *&#13;
 * Copyright 2018 BurzNest LLC. All rights reserved.&#13;
 *&#13;
 * The contents of this file are provided for review&#13;
 * and educational purposes ONLY. You MAY NOT use,&#13;
 * copy, distribute, or modify this software without&#13;
 * explicit written permission from BurzNest LLC.&#13;
 *&#13;
 ****************************************************/&#13;
&#13;
pragma solidity ^0.4.24;&#13;
&#13;
&#13;
&#13;
/// @title ERC20Interface&#13;
/// @dev ERC20 token interface contract&#13;
contract ERC20Interface {&#13;
    function totalSupply() public constant returns(uint);&#13;
    function balanceOf(address _tokenOwner) public constant returns(uint balance);&#13;
    function allowance(address _tokenOwner, address _spender) public constant returns(uint remaining);&#13;
    function transfer(address _to, uint _tokens) public returns(bool success);&#13;
    function approve(address _spender, uint _tokens) public returns(bool success);&#13;
    function transferFrom(address _from, address _to, uint _tokens) public returns(bool success);&#13;
&#13;
    event Transfer(address indexed from, address indexed to, uint tokens);&#13;
    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);&#13;
}&#13;
&#13;
/// @title King of Eth: Resource&#13;
/// @author Anthony Burzillo &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="97f5e2e5edd7f5e2e5edf9f2e4e3b9f4f8fa">[email protected]</a>&gt;&#13;
/// @dev Common contract implementation for resources&#13;
contract KingOfEthResource is&#13;
      ERC20Interface&#13;
    , GodMode&#13;
    , KingOfEthResourcesInterfaceReferencer&#13;
{&#13;
    /// @dev Current resource supply&#13;
    uint public resourceSupply;&#13;
&#13;
    /// @dev ERC20 token's decimals&#13;
    uint8 public constant decimals = 0;&#13;
&#13;
    /// @dev mapping of addresses to holdings&#13;
    mapping (address =&gt; uint) holdings;&#13;
&#13;
    /// @dev mapping of addresses to amount of tokens frozen&#13;
    mapping (address =&gt; uint) frozenHoldings;&#13;
&#13;
    /// @dev mapping of addresses to mapping of allowances for an address&#13;
    mapping (address =&gt; mapping (address =&gt; uint)) allowances;&#13;
&#13;
    /// @dev ERC20 total supply&#13;
    /// @return The current total supply of the resource&#13;
    function totalSupply()&#13;
        public&#13;
        constant&#13;
        returns(uint)&#13;
    {&#13;
        return resourceSupply;&#13;
    }&#13;
&#13;
    /// @dev ERC20 balance of address&#13;
    /// @param _tokenOwner The address to look up&#13;
    /// @return The balance of the address&#13;
    function balanceOf(address _tokenOwner)&#13;
        public&#13;
        constant&#13;
        returns(uint balance)&#13;
    {&#13;
        return holdings[_tokenOwner];&#13;
    }&#13;
&#13;
    /// @dev Total resources frozen for an address&#13;
    /// @param _tokenOwner The address to look up&#13;
    /// @return The frozen balance of the address&#13;
    function frozenTokens(address _tokenOwner)&#13;
        public&#13;
        constant&#13;
        returns(uint balance)&#13;
    {&#13;
        return frozenHoldings[_tokenOwner];&#13;
    }&#13;
&#13;
    /// @dev The allowance for a spender on an account&#13;
    /// @param _tokenOwner The account that allows withdrawels&#13;
    /// @param _spender The account that is allowed to withdraw&#13;
    /// @return The amount remaining in the allowance&#13;
    function allowance(address _tokenOwner, address _spender)&#13;
        public&#13;
        constant&#13;
        returns(uint remaining)&#13;
    {&#13;
        return allowances[_tokenOwner][_spender];&#13;
    }&#13;
&#13;
    /// @dev Only run if player has at least some amount of tokens&#13;
    /// @param _owner The owner of the tokens&#13;
    /// @param _tokens The amount of tokens required&#13;
    modifier hasAvailableTokens(address _owner, uint _tokens)&#13;
    {&#13;
        require(holdings[_owner] - frozenHoldings[_owner] &gt;= _tokens);&#13;
        _;&#13;
    }&#13;
&#13;
    /// @dev Only run if player has at least some amount of tokens frozen&#13;
    /// @param _owner The owner of the tokens&#13;
    /// @param _tokens The amount of frozen tokens required&#13;
    modifier hasFrozenTokens(address _owner, uint _tokens)&#13;
    {&#13;
        require(frozenHoldings[_owner] &gt;= _tokens);&#13;
        _;&#13;
    }&#13;
&#13;
    /// @dev Set up the exact same state in each resource&#13;
    constructor() public&#13;
    {&#13;
        // God gets 200 to put on exchange&#13;
        holdings[msg.sender] = 200;&#13;
&#13;
        resourceSupply = 200;&#13;
    }&#13;
&#13;
    /// @dev The resources interface can burn tokens for building&#13;
    ///  roads or houses&#13;
    /// @param _owner The owner of the tokens&#13;
    /// @param _tokens The amount of tokens to burn&#13;
    function interfaceBurnTokens(address _owner, uint _tokens)&#13;
        public&#13;
        onlyInterfaceContract&#13;
        hasAvailableTokens(_owner, _tokens)&#13;
    {&#13;
        holdings[_owner] -= _tokens;&#13;
&#13;
        resourceSupply -= _tokens;&#13;
&#13;
        // Pretend the tokens were sent to 0x0&#13;
        emit Transfer(_owner, 0x0, _tokens);&#13;
    }&#13;
&#13;
    /// @dev The resources interface contract can mint tokens for houses&#13;
    /// @param _owner The owner of the tokens&#13;
    /// @param _tokens The amount of tokens to burn&#13;
    function interfaceMintTokens(address _owner, uint _tokens)&#13;
        public&#13;
        onlyInterfaceContract&#13;
    {&#13;
        holdings[_owner] += _tokens;&#13;
&#13;
        resourceSupply += _tokens;&#13;
&#13;
        // Pretend the tokens were sent from the interface contract&#13;
        emit Transfer(interfaceContract, _owner, _tokens);&#13;
    }&#13;
&#13;
    /// @dev The interface can freeze tokens&#13;
    /// @param _owner The owner of the tokens&#13;
    /// @param _tokens The amount of tokens to freeze&#13;
    function interfaceFreezeTokens(address _owner, uint _tokens)&#13;
        public&#13;
        onlyInterfaceContract&#13;
        hasAvailableTokens(_owner, _tokens)&#13;
    {&#13;
        frozenHoldings[_owner] += _tokens;&#13;
    }&#13;
&#13;
    /// @dev The interface can thaw tokens&#13;
    /// @param _owner The owner of the tokens&#13;
    /// @param _tokens The amount of tokens to thaw&#13;
    function interfaceThawTokens(address _owner, uint _tokens)&#13;
        public&#13;
        onlyInterfaceContract&#13;
        hasFrozenTokens(_owner, _tokens)&#13;
    {&#13;
        frozenHoldings[_owner] -= _tokens;&#13;
    }&#13;
&#13;
    /// @dev The interface can transfer tokens&#13;
    /// @param _from The owner of the tokens&#13;
    /// @param _to The new owner of the tokens&#13;
    /// @param _tokens The amount of tokens to transfer&#13;
    function interfaceTransfer(address _from, address _to, uint _tokens)&#13;
        public&#13;
        onlyInterfaceContract&#13;
    {&#13;
        assert(holdings[_from] &gt;= _tokens);&#13;
&#13;
        holdings[_from] -= _tokens;&#13;
        holdings[_to]   += _tokens;&#13;
&#13;
        emit Transfer(_from, _to, _tokens);&#13;
    }&#13;
&#13;
    /// @dev The interface can transfer frozend tokens&#13;
    /// @param _from The owner of the tokens&#13;
    /// @param _to The new owner of the tokens&#13;
    /// @param _tokens The amount of frozen tokens to transfer&#13;
    function interfaceFrozenTransfer(address _from, address _to, uint _tokens)&#13;
        public&#13;
        onlyInterfaceContract&#13;
        hasFrozenTokens(_from, _tokens)&#13;
    {&#13;
        // Make sure to deduct the tokens from both the total and frozen amounts&#13;
        holdings[_from]       -= _tokens;&#13;
        frozenHoldings[_from] -= _tokens;&#13;
        holdings[_to]         += _tokens;&#13;
&#13;
        emit Transfer(_from, _to, _tokens);&#13;
    }&#13;
&#13;
    /// @dev ERC20 transfer&#13;
    /// @param _to The address to transfer to&#13;
    /// @param _tokens The amount of tokens to transfer&#13;
    function transfer(address _to, uint _tokens)&#13;
        public&#13;
        hasAvailableTokens(msg.sender, _tokens)&#13;
        returns(bool success)&#13;
    {&#13;
        holdings[_to]        += _tokens;&#13;
        holdings[msg.sender] -= _tokens;&#13;
&#13;
        emit Transfer(msg.sender, _to, _tokens);&#13;
&#13;
        return true;&#13;
    }&#13;
&#13;
    /// @dev ERC20 approve&#13;
    /// @param _spender The address to approve&#13;
    /// @param _tokens The amount of tokens to approve&#13;
    function approve(address _spender, uint _tokens)&#13;
        public&#13;
        returns(bool success)&#13;
    {&#13;
        allowances[msg.sender][_spender] = _tokens;&#13;
&#13;
        emit Approval(msg.sender, _spender, _tokens);&#13;
&#13;
        return true;&#13;
    }&#13;
&#13;
    /// @dev ERC20 transfer from&#13;
    /// @param _from The address providing the allowance&#13;
    /// @param _to The address using the allowance&#13;
    /// @param _tokens The amount of tokens to transfer&#13;
    function transferFrom(address _from, address _to, uint _tokens)&#13;
        public&#13;
        hasAvailableTokens(_from, _tokens)&#13;
        returns(bool success)&#13;
    {&#13;
        require(allowances[_from][_to] &gt;= _tokens);&#13;
&#13;
        holdings[_to]          += _tokens;&#13;
        holdings[_from]        -= _tokens;&#13;
        allowances[_from][_to] -= _tokens;&#13;
&#13;
        emit Transfer(_from, _to, _tokens);&#13;
&#13;
        return true;&#13;
    }&#13;
}&#13;
&#13;
// File: contracts/KingOfEthResourceType.sol&#13;
&#13;
/****************************************************&#13;
 *&#13;
 * Copyright 2018 BurzNest LLC. All rights reserved.&#13;
 *&#13;
 * The contents of this file are provided for review&#13;
 * and educational purposes ONLY. You MAY NOT use,&#13;
 * copy, distribute, or modify this software without&#13;
 * explicit written permission from BurzNest LLC.&#13;
 *&#13;
 ****************************************************/&#13;
&#13;
pragma solidity ^0.4.24;&#13;
&#13;
/// @title King of Eth: Resource Type&#13;
/// @author Anthony Burzillo &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="610314131b210314131b0f0412154f020e0c">[email protected]</a>&gt;&#13;
/// @dev Provides enum to choose resource types&#13;
contract KingOfEthResourceType {&#13;
    /// @dev Enum describing a choice of a resource&#13;
    enum ResourceType {&#13;
          ETH&#13;
        , BRONZE&#13;
        , CORN&#13;
        , GOLD&#13;
        , OIL&#13;
        , ORE&#13;
        , STEEL&#13;
        , URANIUM&#13;
        , WOOD&#13;
    }&#13;
}&#13;
&#13;
// File: contracts/KingOfEthRoadsReferencer.sol&#13;
&#13;
/****************************************************&#13;
 *&#13;
 * Copyright 2018 BurzNest LLC. All rights reserved.&#13;
 *&#13;
 * The contents of this file are provided for review&#13;
 * and educational purposes ONLY. You MAY NOT use,&#13;
 * copy, distribute, or modify this software without&#13;
 * explicit written permission from BurzNest LLC.&#13;
 *&#13;
 ****************************************************/&#13;
&#13;
pragma solidity ^0.4.24;&#13;
&#13;
&#13;
/// @title King of Eth: Roads Referencer&#13;
/// @author Anthony Burzillo &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="90f2e5e2ead0f2e5e2eafef5e3e4bef3fffd">[email protected]</a>&gt;&#13;
/// @dev Provides functionality to reference the roads contract&#13;
contract KingOfEthRoadsReferencer is GodMode {&#13;
    /// @dev The roads contract's address&#13;
    address public roadsContract;&#13;
&#13;
    /// @dev Only the roads contract can run this function&#13;
    modifier onlyRoadsContract()&#13;
    {&#13;
        require(roadsContract == msg.sender);&#13;
        _;&#13;
    }&#13;
&#13;
    /// @dev God can set the realty contract&#13;
    /// @param _roadsContract The new address&#13;
    function godSetRoadsContract(address _roadsContract)&#13;
        public&#13;
        onlyGod&#13;
    {&#13;
        roadsContract = _roadsContract;&#13;
    }&#13;
}&#13;
&#13;
// File: contracts/KingOfEthResourcesInterface.sol&#13;
&#13;
/****************************************************&#13;
 *&#13;
 * Copyright 2018 BurzNest LLC. All rights reserved.&#13;
 *&#13;
 * The contents of this file are provided for review&#13;
 * and educational purposes ONLY. You MAY NOT use,&#13;
 * copy, distribute, or modify this software without&#13;
 * explicit written permission from BurzNest LLC.&#13;
 *&#13;
 ****************************************************/&#13;
&#13;
pragma solidity ^0.4.24;&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
/// @title King of Eth: Resources Interface&#13;
/// @author Anthony Burzillo &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="dfbdaaada59fbdaaada5b1baacabf1bcb0b2">[email protected]</a>&gt;&#13;
/// @dev Contract for interacting with resources&#13;
contract KingOfEthResourcesInterface is&#13;
      GodMode&#13;
    , KingOfEthExchangeReferencer&#13;
    , KingOfEthHousesReferencer&#13;
    , KingOfEthResourceType&#13;
    , KingOfEthRoadsReferencer&#13;
{&#13;
    /// @dev Amount of resources a user gets for building a house&#13;
    uint public constant resourcesPerHouse = 3;&#13;
&#13;
    /// @dev Address for the bronze contract&#13;
    address public bronzeContract;&#13;
&#13;
    /// @dev Address for the corn contract&#13;
    address public cornContract;&#13;
&#13;
    /// @dev Address for the gold contract&#13;
    address public goldContract;&#13;
&#13;
    /// @dev Address for the oil contract&#13;
    address public oilContract;&#13;
&#13;
    /// @dev Address for the ore contract&#13;
    address public oreContract;&#13;
&#13;
    /// @dev Address for the steel contract&#13;
    address public steelContract;&#13;
&#13;
    /// @dev Address for the uranium contract&#13;
    address public uraniumContract;&#13;
&#13;
    /// @dev Address for the wood contract&#13;
    address public woodContract;&#13;
&#13;
    /// @param _bronzeContract The address of the bronze contract&#13;
    /// @param _cornContract The address of the corn contract&#13;
    /// @param _goldContract The address of the gold contract&#13;
    /// @param _oilContract The address of the oil contract&#13;
    /// @param _oreContract The address of the ore contract&#13;
    /// @param _steelContract The address of the steel contract&#13;
    /// @param _uraniumContract The address of the uranium contract&#13;
    /// @param _woodContract The address of the wood contract&#13;
    constructor(&#13;
          address _bronzeContract&#13;
        , address _cornContract&#13;
        , address _goldContract&#13;
        , address _oilContract&#13;
        , address _oreContract&#13;
        , address _steelContract&#13;
        , address _uraniumContract&#13;
        , address _woodContract&#13;
    )&#13;
        public&#13;
    {&#13;
        bronzeContract  = _bronzeContract;&#13;
        cornContract    = _cornContract;&#13;
        goldContract    = _goldContract;&#13;
        oilContract     = _oilContract;&#13;
        oreContract     = _oreContract;&#13;
        steelContract   = _steelContract;&#13;
        uraniumContract = _uraniumContract;&#13;
        woodContract    = _woodContract;&#13;
    }&#13;
&#13;
    /// @dev Return the particular address for a certain resource type&#13;
    /// @param _type The resource type&#13;
    /// @return The address for that resource&#13;
    function contractFor(ResourceType _type)&#13;
        public&#13;
        view&#13;
        returns(address)&#13;
    {&#13;
        // ETH does not have a contract&#13;
        require(ResourceType.ETH != _type);&#13;
&#13;
        if(ResourceType.BRONZE == _type)&#13;
        {&#13;
            return bronzeContract;&#13;
        }&#13;
        else if(ResourceType.CORN == _type)&#13;
        {&#13;
            return cornContract;&#13;
        }&#13;
        else if(ResourceType.GOLD == _type)&#13;
        {&#13;
            return goldContract;&#13;
        }&#13;
        else if(ResourceType.OIL == _type)&#13;
        {&#13;
            return oilContract;&#13;
        }&#13;
        else if(ResourceType.ORE == _type)&#13;
        {&#13;
            return oreContract;&#13;
        }&#13;
        else if(ResourceType.STEEL == _type)&#13;
        {&#13;
            return steelContract;&#13;
        }&#13;
        else if(ResourceType.URANIUM == _type)&#13;
        {&#13;
            return uraniumContract;&#13;
        }&#13;
        else if(ResourceType.WOOD == _type)&#13;
        {&#13;
            return woodContract;&#13;
        }&#13;
    }&#13;
&#13;
    /// @dev Determine the resource type of a tile&#13;
    /// @param _x The x coordinate of the top left corner of the tile&#13;
    /// @param _y The y coordinate of the top left corner of the tile&#13;
    function resourceType(uint _x, uint _y)&#13;
        public&#13;
        pure&#13;
        returns(ResourceType resource)&#13;
    {&#13;
        uint _seed = (_x + 7777777) ^  _y;&#13;
&#13;
        if(0 == _seed % 97)&#13;
        {&#13;
          return ResourceType.URANIUM;&#13;
        }&#13;
        else if(0 == _seed % 29)&#13;
        {&#13;
          return ResourceType.OIL;&#13;
        }&#13;
        else if(0 == _seed % 23)&#13;
        {&#13;
          return ResourceType.STEEL;&#13;
        }&#13;
        else if(0 == _seed % 17)&#13;
        {&#13;
          return ResourceType.GOLD;&#13;
        }&#13;
        else if(0 == _seed % 11)&#13;
        {&#13;
          return ResourceType.BRONZE;&#13;
        }&#13;
        else if(0 == _seed % 5)&#13;
        {&#13;
          return ResourceType.WOOD;&#13;
        }&#13;
        else if(0 == _seed % 2)&#13;
        {&#13;
          return ResourceType.CORN;&#13;
        }&#13;
        else&#13;
        {&#13;
          return ResourceType.ORE;&#13;
        }&#13;
    }&#13;
&#13;
    /// @dev Lookup the number of resource points for a certain&#13;
    ///  player&#13;
    /// @param _player The player in question&#13;
    function lookupResourcePoints(address _player)&#13;
        public&#13;
        view&#13;
        returns(uint)&#13;
    {&#13;
        uint result = 0;&#13;
&#13;
        result += KingOfEthResource(bronzeContract).balanceOf(_player);&#13;
        result += KingOfEthResource(goldContract).balanceOf(_player)    * 3;&#13;
        result += KingOfEthResource(steelContract).balanceOf(_player)   * 6;&#13;
        result += KingOfEthResource(oilContract).balanceOf(_player)     * 10;&#13;
        result += KingOfEthResource(uraniumContract).balanceOf(_player) * 44;&#13;
&#13;
        return result;&#13;
    }&#13;
&#13;
    /// @dev Burn the resources necessary to build a house&#13;
    /// @param _count the number of houses being built&#13;
    /// @param _player The player who is building the house&#13;
    function burnHouseCosts(uint _count, address _player)&#13;
        public&#13;
        onlyHousesContract&#13;
    {&#13;
        // Costs 2 corn per house&#13;
        KingOfEthResource(contractFor(ResourceType.CORN)).interfaceBurnTokens(&#13;
              _player&#13;
            , 2 * _count&#13;
        );&#13;
&#13;
        // Costs 2 ore per house&#13;
        KingOfEthResource(contractFor(ResourceType.ORE)).interfaceBurnTokens(&#13;
              _player&#13;
            , 2 * _count&#13;
        );&#13;
&#13;
        // Costs 1 wood per house&#13;
        KingOfEthResource(contractFor(ResourceType.WOOD)).interfaceBurnTokens(&#13;
              _player&#13;
            , _count&#13;
        );&#13;
    }&#13;
&#13;
    /// @dev Burn the costs of upgrading a house&#13;
    /// @param _currentLevel The level of the house before the upgrade&#13;
    /// @param _player The player who is upgrading the house&#13;
    function burnUpgradeCosts(uint8 _currentLevel, address _player)&#13;
        public&#13;
        onlyHousesContract&#13;
    {&#13;
        // Do not allow upgrades after level 4&#13;
        require(5 &gt; _currentLevel);&#13;
&#13;
        // Burn the base house cost&#13;
        burnHouseCosts(1, _player);&#13;
&#13;
        if(0 == _currentLevel)&#13;
        {&#13;
            // Level 1 costs bronze&#13;
            KingOfEthResource(contractFor(ResourceType.BRONZE)).interfaceBurnTokens(&#13;
                  _player&#13;
                , 1&#13;
            );&#13;
        }&#13;
        else if(1 == _currentLevel)&#13;
        {&#13;
            // Level 2 costs gold&#13;
            KingOfEthResource(contractFor(ResourceType.GOLD)).interfaceBurnTokens(&#13;
                  _player&#13;
                , 1&#13;
            );&#13;
        }&#13;
        else if(2 == _currentLevel)&#13;
        {&#13;
            // Level 3 costs steel&#13;
            KingOfEthResource(contractFor(ResourceType.STEEL)).interfaceBurnTokens(&#13;
                  _player&#13;
                , 1&#13;
            );&#13;
        }&#13;
        else if(3 == _currentLevel)&#13;
        {&#13;
            // Level 4 costs oil&#13;
            KingOfEthResource(contractFor(ResourceType.OIL)).interfaceBurnTokens(&#13;
                  _player&#13;
                , 1&#13;
            );&#13;
        }&#13;
        else if(4 == _currentLevel)&#13;
        {&#13;
            // Level 5 costs uranium&#13;
            KingOfEthResource(contractFor(ResourceType.URANIUM)).interfaceBurnTokens(&#13;
                  _player&#13;
                , 1&#13;
            );&#13;
        }&#13;
    }&#13;
&#13;
    /// @dev Mint resources for a house and distribute all to its owner&#13;
    /// @param _owner The owner of the house&#13;
    /// @param _x The x coordinate of the house&#13;
    /// @param _y The y coordinate of the house&#13;
    /// @param _y The y coordinate of the house&#13;
    /// @param _level The new level of the house&#13;
    function distributeResources(address _owner, uint _x, uint _y, uint8 _level)&#13;
        public&#13;
        onlyHousesContract&#13;
    {&#13;
        // Calculate the count of resources for this level&#13;
        uint _count = resourcesPerHouse * uint(_level + 1);&#13;
&#13;
        // Distribute the top left resource&#13;
        KingOfEthResource(contractFor(resourceType(_x - 1, _y - 1))).interfaceMintTokens(&#13;
            _owner&#13;
          , _count&#13;
        );&#13;
&#13;
        // Distribute the top right resource&#13;
        KingOfEthResource(contractFor(resourceType(_x, _y - 1))).interfaceMintTokens(&#13;
            _owner&#13;
          , _count&#13;
        );&#13;
&#13;
        // Distribute the bottom right resource&#13;
        KingOfEthResource(contractFor(resourceType(_x, _y))).interfaceMintTokens(&#13;
            _owner&#13;
          , _count&#13;
        );&#13;
&#13;
        // Distribute the bottom left resource&#13;
        KingOfEthResource(contractFor(resourceType(_x - 1, _y))).interfaceMintTokens(&#13;
            _owner&#13;
          , _count&#13;
        );&#13;
    }&#13;
&#13;
    /// @dev Burn the costs necessary to build a road&#13;
    /// @param _length The length of the road&#13;
    /// @param _player The player who is building the house&#13;
    function burnRoadCosts(uint _length, address _player)&#13;
        public&#13;
        onlyRoadsContract&#13;
    {&#13;
        // Burn corn&#13;
        KingOfEthResource(cornContract).interfaceBurnTokens(&#13;
              _player&#13;
            , _length&#13;
        );&#13;
&#13;
        // Burn ore&#13;
        KingOfEthResource(oreContract).interfaceBurnTokens(&#13;
              _player&#13;
            , _length&#13;
        );&#13;
    }&#13;
&#13;
    /// @dev The exchange can freeze tokens&#13;
    /// @param _type The type of resource&#13;
    /// @param _owner The owner of the tokens&#13;
    /// @param _tokens The amount of tokens to freeze&#13;
    function exchangeFreezeTokens(ResourceType _type, address _owner, uint _tokens)&#13;
        public&#13;
        onlyExchangeContract&#13;
    {&#13;
        KingOfEthResource(contractFor(_type)).interfaceFreezeTokens(_owner, _tokens);&#13;
    }&#13;
&#13;
    /// @dev The exchange can thaw tokens&#13;
    /// @param _type The type of resource&#13;
    /// @param _owner The owner of the tokens&#13;
    /// @param _tokens The amount of tokens to thaw&#13;
    function exchangeThawTokens(ResourceType _type, address _owner, uint _tokens)&#13;
        public&#13;
        onlyExchangeContract&#13;
    {&#13;
        KingOfEthResource(contractFor(_type)).interfaceThawTokens(_owner, _tokens);&#13;
    }&#13;
&#13;
    /// @dev The exchange can transfer tokens&#13;
    /// @param _type The type of resource&#13;
    /// @param _from The owner of the tokens&#13;
    /// @param _to The new owner of the tokens&#13;
    /// @param _tokens The amount of tokens to transfer&#13;
    function exchangeTransfer(ResourceType _type, address _from, address _to, uint _tokens)&#13;
        public&#13;
        onlyExchangeContract&#13;
    {&#13;
        KingOfEthResource(contractFor(_type)).interfaceTransfer(_from, _to, _tokens);&#13;
    }&#13;
&#13;
    /// @dev The exchange can transfer frozend tokens&#13;
    /// @param _type The type of resource&#13;
    /// @param _from The owner of the tokens&#13;
    /// @param _to The new owner of the tokens&#13;
    /// @param _tokens The amount of frozen tokens to transfer&#13;
    function exchangeFrozenTransfer(ResourceType _type, address _from, address _to, uint _tokens)&#13;
        public&#13;
        onlyExchangeContract&#13;
    {&#13;
        KingOfEthResource(contractFor(_type)).interfaceFrozenTransfer(_from, _to, _tokens);&#13;
    }&#13;
}&#13;
&#13;
// File: contracts/KingOfEthRoadsAbstractInterface.sol&#13;
&#13;
/****************************************************&#13;
 *&#13;
 * Copyright 2018 BurzNest LLC. All rights reserved.&#13;
 *&#13;
 * The contents of this file are provided for review&#13;
 * and educational purposes ONLY. You MAY NOT use,&#13;
 * copy, distribute, or modify this software without&#13;
 * explicit written permission from BurzNest LLC.&#13;
 *&#13;
 ****************************************************/&#13;
&#13;
pragma solidity ^0.4.24;&#13;
&#13;
/// @title King of Eth: Roads Abstract Interface&#13;
/// @author Anthony Burzillo &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="036176717943617671796d6670772d606c6e">[email protected]</a>&gt;&#13;
/// @dev Abstract interface contract for roads&#13;
contract KingOfEthRoadsAbstractInterface {&#13;
    /// @dev Get the owner of the road at some location&#13;
    /// @param _x The x coordinate of the road&#13;
    /// @param _y The y coordinate of the road&#13;
    /// @param _direction The direction of the road (either&#13;
    ///  0 for right or 1 for down)&#13;
    /// @return The address of the owner&#13;
    function ownerOf(uint _x, uint _y, uint8 _direction) public view returns(address);&#13;
&#13;
    /// @dev The road realty contract can transfer road ownership&#13;
    /// @param _x The x coordinate of the road&#13;
    /// @param _y The y coordinate of the road&#13;
    /// @param _direction The direction of the road&#13;
    /// @param _from The previous owner of road&#13;
    /// @param _to The new owner of road&#13;
    function roadRealtyTransferOwnership(&#13;
          uint _x&#13;
        , uint _y&#13;
        , uint8 _direction&#13;
        , address _from&#13;
        , address _to&#13;
    ) public;&#13;
}&#13;
&#13;
// File: contracts/KingOfEthRoadRealty.sol&#13;
&#13;
/****************************************************&#13;
 *&#13;
 * Copyright 2018 BurzNest LLC. All rights reserved.&#13;
 *&#13;
 * The contents of this file are provided for review&#13;
 * and educational purposes ONLY. You MAY NOT use,&#13;
 * copy, distribute, or modify this software without&#13;
 * explicit written permission from BurzNest LLC.&#13;
 *&#13;
 ****************************************************/&#13;
&#13;
pragma solidity ^0.4.24;&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
/// @title King of Eth: Road Realty&#13;
/// @author Anthony Burzillo &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="563423242c163423242c383325227835393b">[email protected]</a>&gt;&#13;
/// @dev Contract for controlling sales of roads&#13;
contract KingOfEthRoadRealty is&#13;
      GodMode&#13;
    , KingOfEthReferencer&#13;
    , KingOfEthRoadsReferencer&#13;
{&#13;
    /// @dev The number that divides the amount payed for any sale to produce&#13;
    ///  the amount payed in taxes&#13;
    uint public constant taxDivisor = 25;&#13;
&#13;
    /// @dev Mapping from the x, y coordinates and the direction (0 for right and&#13;
    ///  1 for down) of a road to the  current sale price (0 if there is no sale)&#13;
    mapping (uint =&gt; mapping (uint =&gt; uint[2])) roadPrices;&#13;
&#13;
    /// @dev Fired when there is a new road for sale&#13;
    event RoadForSale(&#13;
          uint x&#13;
        , uint y&#13;
        , uint8 direction&#13;
        , address owner&#13;
        , uint amount&#13;
    );&#13;
&#13;
    /// @dev Fired when the owner changes the price of a road&#13;
    event RoadPriceChanged(&#13;
          uint x&#13;
        , uint y&#13;
        , uint8 direction&#13;
        , uint amount&#13;
    );&#13;
&#13;
    /// @dev Fired when a road is sold&#13;
    event RoadSold(&#13;
          uint x&#13;
        , uint y&#13;
        , uint8 direction&#13;
        , address from&#13;
        , address to&#13;
        , uint amount&#13;
    );&#13;
&#13;
    /// @dev Fired when the sale for a road is cancelled by the owner&#13;
    event RoadSaleCancelled(&#13;
          uint x&#13;
        , uint y&#13;
        , uint8 direction&#13;
        , address owner&#13;
    );&#13;
&#13;
    /// @dev Only the owner of the road at a location can run this&#13;
    /// @param _x The x coordinate of the road&#13;
    /// @param _y The y coordinate of the road&#13;
    /// @param _direction The direction of the road&#13;
    modifier onlyRoadOwner(uint _x, uint _y, uint8 _direction)&#13;
    {&#13;
        require(KingOfEthRoadsAbstractInterface(roadsContract).ownerOf(_x, _y, _direction) == msg.sender);&#13;
        _;&#13;
    }&#13;
&#13;
    /// @dev This can only be run if there is *not* an existing sale for a road&#13;
    ///  at a location&#13;
    /// @param _x The x coordinate of the road&#13;
    /// @param _y The y coordinate of the road&#13;
    /// @param _direction The direction of the road&#13;
    modifier noExistingRoadSale(uint _x, uint _y, uint8 _direction)&#13;
    {&#13;
        require(0 == roadPrices[_x][_y][_direction]);&#13;
        _;&#13;
    }&#13;
&#13;
    /// @dev This can only be run if there is an existing sale for a house&#13;
    ///  at a location&#13;
    /// @param _x The x coordinate of the road&#13;
    /// @param _y The y coordinate of the road&#13;
    /// @param _direction The direction of the road&#13;
    modifier existingRoadSale(uint _x, uint _y, uint8 _direction)&#13;
    {&#13;
        require(0 != roadPrices[_x][_y][_direction]);&#13;
        _;&#13;
    }&#13;
&#13;
    /// @param _kingOfEthContract The address of the king contract&#13;
    constructor(address _kingOfEthContract) public&#13;
    {&#13;
        kingOfEthContract = _kingOfEthContract;&#13;
    }&#13;
&#13;
    /// @dev The roads contract can cancel a sale when a road is transfered&#13;
    ///  to another player&#13;
    /// @param _x The x coordinate of the road&#13;
    /// @param _y The y coordinate of the road&#13;
    /// @param _direction The direction of the road&#13;
    function roadsCancelRoadSale(uint _x, uint _y, uint8 _direction)&#13;
        public&#13;
        onlyRoadsContract&#13;
    {&#13;
        // If there is indeed a sale&#13;
        if(0 != roadPrices[_x][_y][_direction])&#13;
        {&#13;
            // Cancel the sale&#13;
            roadPrices[_x][_y][_direction] = 0;&#13;
&#13;
            emit RoadSaleCancelled(_x, _y, _direction, msg.sender);&#13;
        }&#13;
    }&#13;
&#13;
    /// @dev The owner of a road can start a sale&#13;
    /// @param _x The x coordinate of the road&#13;
    /// @param _y The y coordinate of the road&#13;
    /// @param _direction The direction of the road&#13;
    /// @param _askingPrice The price that must be payed by another player&#13;
    ///  to purchase the road&#13;
    function startRoadSale(&#13;
          uint _x&#13;
        , uint _y&#13;
        , uint8 _direction&#13;
        , uint _askingPrice&#13;
    )&#13;
        public&#13;
        notPaused&#13;
        onlyRoadOwner(_x, _y, _direction)&#13;
        noExistingRoadSale(_x, _y, _direction)&#13;
    {&#13;
        // Require that the price is at least 0&#13;
        require(0 != _askingPrice);&#13;
&#13;
        // Record the price&#13;
        roadPrices[_x][_y][_direction] = _askingPrice;&#13;
&#13;
        emit RoadForSale(_x, _y, _direction, msg.sender, _askingPrice);&#13;
    }&#13;
&#13;
    /// @dev The owner of a road can change the price of a sale&#13;
    /// @param _x The x coordinate of the road&#13;
    /// @param _y The y coordinate of the road&#13;
    /// @param _direction The direction of the road&#13;
    /// @param _askingPrice The new price that must be payed by another&#13;
    ///  player to purchase the road&#13;
    function changeRoadPrice(&#13;
          uint _x&#13;
        , uint _y&#13;
        , uint8 _direction&#13;
        , uint _askingPrice&#13;
    )&#13;
        public&#13;
        notPaused&#13;
        onlyRoadOwner(_x, _y, _direction)&#13;
        existingRoadSale(_x, _y, _direction)&#13;
    {&#13;
        // Require that the price is at least 0&#13;
        require(0 != _askingPrice);&#13;
&#13;
        // Record the price&#13;
        roadPrices[_x][_y][_direction] = _askingPrice;&#13;
&#13;
        emit RoadPriceChanged(_x, _y, _direction, _askingPrice);&#13;
    }&#13;
&#13;
    /// @dev Anyone can purchase a road as long as the sale exists&#13;
    /// @param _x The x coordinate of the road&#13;
    /// @param _y The y coordinate of the road&#13;
    /// @param _direction The direction of the road&#13;
    function purchaseRoad(uint _x, uint _y, uint8 _direction)&#13;
        public&#13;
        payable&#13;
        notPaused&#13;
        existingRoadSale(_x, _y, _direction)&#13;
    {&#13;
        // Require that the exact price was paid&#13;
        require(roadPrices[_x][_y][_direction] == msg.value);&#13;
&#13;
        // End the sale&#13;
        roadPrices[_x][_y][_direction] = 0;&#13;
&#13;
        // Calculate the taxes to be paid&#13;
        uint taxCut = msg.value / taxDivisor;&#13;
&#13;
        // Pay the taxes&#13;
        KingOfEthAbstractInterface(kingOfEthContract).payTaxes.value(taxCut)();&#13;
&#13;
        KingOfEthRoadsAbstractInterface _roadsContract = KingOfEthRoadsAbstractInterface(roadsContract);&#13;
&#13;
        // Determine the previous owner&#13;
        address _oldOwner = _roadsContract.ownerOf(_x, _y, _direction);&#13;
&#13;
        // Send the buyer the house&#13;
        _roadsContract.roadRealtyTransferOwnership(&#13;
              _x&#13;
            , _y&#13;
            , _direction&#13;
            , _oldOwner&#13;
            , msg.sender&#13;
        );&#13;
&#13;
        // Send the previous owner his share&#13;
        _oldOwner.transfer(msg.value - taxCut);&#13;
&#13;
        emit RoadSold(&#13;
              _x&#13;
            , _y&#13;
            , _direction&#13;
            , _oldOwner&#13;
            , msg.sender&#13;
            , msg.value&#13;
        );&#13;
    }&#13;
&#13;
    /// @dev The owner of a road can cancel a sale&#13;
    /// @param _x The x coordinate of the road&#13;
    /// @param _y The y coordinate of the road&#13;
    /// @param _direction The direction of the road&#13;
    function cancelRoadSale(uint _x, uint _y, uint8 _direction)&#13;
        public&#13;
        notPaused&#13;
        onlyRoadOwner(_x, _y, _direction)&#13;
        existingRoadSale(_x, _y, _direction)&#13;
    {&#13;
        // Cancel the sale&#13;
        roadPrices[_x][_y][_direction] = 0;&#13;
&#13;
        emit RoadSaleCancelled(_x, _y, _direction, msg.sender);&#13;
    }&#13;
}&#13;
&#13;
// File: contracts/KingOfEthRoadRealtyReferencer.sol&#13;
&#13;
/****************************************************&#13;
 *&#13;
 * Copyright 2018 BurzNest LLC. All rights reserved.&#13;
 *&#13;
 * The contents of this file are provided for review&#13;
 * and educational purposes ONLY. You MAY NOT use,&#13;
 * copy, distribute, or modify this software without&#13;
 * explicit written permission from BurzNest LLC.&#13;
 *&#13;
 ****************************************************/&#13;
&#13;
pragma solidity ^0.4.24;&#13;
&#13;
&#13;
/// @title King of Eth: Road Realty Referencer&#13;
/// @author Anthony Burzillo &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="8eecfbfcf4ceecfbfcf4e0ebfdfaa0ede1e3">[email protected]</a>&gt;&#13;
/// @dev Provides functionality to reference the road realty contract&#13;
contract KingOfEthRoadRealtyReferencer is GodMode {&#13;
    /// @dev The realty contract's address&#13;
    address public roadRealtyContract;&#13;
&#13;
    /// @dev Only the road realty contract can run this function&#13;
    modifier onlyRoadRealtyContract()&#13;
    {&#13;
        require(roadRealtyContract == msg.sender);&#13;
        _;&#13;
    }&#13;
&#13;
    /// @dev God can set the road realty contract&#13;
    /// @param _roadRealtyContract The new address&#13;
    function godSetRoadRealtyContract(address _roadRealtyContract)&#13;
        public&#13;
        onlyGod&#13;
    {&#13;
        roadRealtyContract = _roadRealtyContract;&#13;
    }&#13;
}&#13;
&#13;
// File: contracts/KingOfEthRoads.sol&#13;
&#13;
/****************************************************&#13;
 *&#13;
 * Copyright 2018 BurzNest LLC. All rights reserved.&#13;
 *&#13;
 * The contents of this file are provided for review&#13;
 * and educational purposes ONLY. You MAY NOT use,&#13;
 * copy, distribute, or modify this software without&#13;
 * explicit written permission from BurzNest LLC.&#13;
 *&#13;
 ****************************************************/&#13;
&#13;
pragma solidity ^0.4.24;&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
/// @title King of Eth: Roads&#13;
/// @author Anthony Burzillo &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="cba9beb9b18ba9beb9b1a5aeb8bfe5a8a4a6">[email protected]</a>&gt;&#13;
/// @dev Contract for roads&#13;
contract KingOfEthRoads is&#13;
      GodMode&#13;
    , KingOfEthBoardReferencer&#13;
    , KingOfEthHousesReferencer&#13;
    , KingOfEthReferencer&#13;
    , KingOfEthResourcesInterfaceReferencer&#13;
    , KingOfEthRoadRealtyReferencer&#13;
    , KingOfEthRoadsAbstractInterface&#13;
{&#13;
    /// @dev ETH cost to build a road&#13;
    uint public roadCost = 0.0002 ether;&#13;
&#13;
    /// @dev Mapping from the x, y, direction coordinate of the location to its owner&#13;
    mapping (uint =&gt; mapping (uint =&gt; address[2])) owners;&#13;
&#13;
    /// @dev Mapping from a players address to his road counts&#13;
    mapping (address =&gt; uint) roadCounts;&#13;
&#13;
    /// @param _boardContract The address of the board contract&#13;
    /// @param _roadRealtyContract The address of the road realty contract&#13;
    /// @param _kingOfEthContract The address of the king contract&#13;
    /// @param _interfaceContract The address of the resources&#13;
    ///  interface contract&#13;
    constructor(&#13;
          address _boardContract&#13;
        , address _roadRealtyContract&#13;
        , address _kingOfEthContract&#13;
        , address _interfaceContract&#13;
    )&#13;
        public&#13;
    {&#13;
        boardContract      = _boardContract;&#13;
        roadRealtyContract = _roadRealtyContract;&#13;
        kingOfEthContract  = _kingOfEthContract;&#13;
        interfaceContract  = _interfaceContract;&#13;
    }&#13;
&#13;
    /// @dev Fired when new roads are built&#13;
    event NewRoads(&#13;
          address owner&#13;
        , uint x&#13;
        , uint y&#13;
        , uint8 direction&#13;
        , uint length&#13;
    );&#13;
&#13;
    /// @dev Fired when a road is sent from one player to another&#13;
    event SentRoad(&#13;
          uint x&#13;
        , uint y&#13;
        , uint direction&#13;
        , address from&#13;
        , address to&#13;
    );&#13;
&#13;
    /// @dev Get the owner of the road at some location&#13;
    /// @param _x The x coordinate of the road&#13;
    /// @param _y The y coordinate of the road&#13;
    /// @param _direction The direction of the road (either&#13;
    ///  0 for right or 1 for down)&#13;
    /// @return The address of the owner&#13;
    function ownerOf(uint _x, uint _y, uint8 _direction)&#13;
        public&#13;
        view&#13;
        returns(address)&#13;
    {&#13;
        // Only 0 or 1 is a valid direction&#13;
        require(2 &gt; _direction);&#13;
&#13;
        return owners[_x][_y][_direction];&#13;
    }&#13;
&#13;
    /// @dev Get the number of roads owned by a player&#13;
    /// @param _player The player's address&#13;
    /// @return The number of roads&#13;
    function numberOfRoads(address _player) public view returns(uint)&#13;
    {&#13;
        return roadCounts[_player];&#13;
    }&#13;
&#13;
    /// @dev Only the owner of a road can run this&#13;
    /// @param _x The x coordinate of the road&#13;
    /// @param _y The y coordinate of the road&#13;
    /// @param _direction The direction of the road&#13;
    modifier onlyRoadOwner(uint _x, uint _y, uint8 _direction)&#13;
    {&#13;
        require(owners[_x][_y][_direction] == msg.sender);&#13;
        _;&#13;
    }&#13;
&#13;
    /// @dev Build houses to the right&#13;
    /// @param _x The x coordinate of the starting point of the first road&#13;
    /// @param _y The y coordinate of the starting point of the first road&#13;
    /// @param _length The length to build&#13;
    function buildRight(uint _x, uint _y, uint _length) private&#13;
    {&#13;
        // Require that nobody currently owns the road&#13;
        require(0x0 == owners[_x][_y][0]);&#13;
&#13;
        KingOfEthHousesAbstractInterface _housesContract = KingOfEthHousesAbstractInterface(housesContract);&#13;
&#13;
        // Require that either the player owns the house at the&#13;
        // starting location, the road below it, the road to the&#13;
        // left of it, or the road above it&#13;
        address _houseOwner = _housesContract.ownerOf(_x, _y);&#13;
        require(_houseOwner == msg.sender || (0x0 == _houseOwner &amp;&amp; (&#13;
               owners[_x][_y][1] == msg.sender&#13;
            || owners[_x - 1][_y][0] == msg.sender&#13;
            || owners[_x][_y - 1][1] == msg.sender&#13;
        )));&#13;
&#13;
        // Set the new owner&#13;
        owners[_x][_y][0] = msg.sender;&#13;
&#13;
        for(uint _i = 1; _i &lt; _length; ++_i)&#13;
        {&#13;
            // Require that nobody currently owns the road&#13;
            require(0x0 == owners[_x + _i][_y][0]);&#13;
&#13;
            // Require that either the house location is empty or&#13;
            // that it is owned by the player&#13;
            require(&#13;
                   _housesContract.ownerOf(_x + _i, _y) == 0x0&#13;
                || _housesContract.ownerOf(_x + _i, _y) == msg.sender&#13;
            );&#13;
&#13;
            // Set the new owner&#13;
            owners[_x + _i][_y][0] = msg.sender;&#13;
        }&#13;
    }&#13;
&#13;
    /// @dev Build houses downwards&#13;
    /// @param _x The x coordinate of the starting point of the first road&#13;
    /// @param _y The y coordinate of the starting point of the first road&#13;
    /// @param _length The length to build&#13;
    function buildDown(uint _x, uint _y, uint _length) private&#13;
    {&#13;
        // Require that nobody currently owns the road&#13;
        require(0x0 == owners[_x][_y][1]);&#13;
&#13;
        KingOfEthHousesAbstractInterface _housesContract = KingOfEthHousesAbstractInterface(housesContract);&#13;
&#13;
        // Require that either the player owns the house at the&#13;
        // starting location, the road to the right of it, the road to&#13;
        // the left of it, or the road above it&#13;
        address _houseOwner = _housesContract.ownerOf(_x, _y);&#13;
        require(_houseOwner == msg.sender || (0x0 == _houseOwner &amp;&amp; (&#13;
               owners[_x][_y][0] == msg.sender&#13;
            || owners[_x - 1][_y][0] == msg.sender&#13;
            || owners[_x][_y - 1][1] == msg.sender&#13;
        )));&#13;
&#13;
        // Set the new owner&#13;
        owners[_x][_y][1] = msg.sender;&#13;
&#13;
        for(uint _i = 1; _i &lt; _length; ++_i)&#13;
        {&#13;
            // Require that nobody currently owns the road&#13;
            require(0x0 == owners[_x][_y + _i][1]);&#13;
&#13;
            // Require that either the house location is empty or&#13;
            // that it is owned by the player&#13;
            require(&#13;
                   _housesContract.ownerOf(_x, _y + _i) == 0x0&#13;
                || _housesContract.ownerOf(_x, _y + _i) == msg.sender&#13;
            );&#13;
&#13;
            // Set the new owner&#13;
            owners[_x][_y + _i][1] = msg.sender;&#13;
        }&#13;
    }&#13;
&#13;
    /// @dev Build houses to the left&#13;
    /// @param _x The x coordinate of the starting point of the first road&#13;
    /// @param _y The y coordinate of the starting point of the first road&#13;
    /// @param _length The length to build&#13;
    function buildLeft(uint _x, uint _y, uint _length) private&#13;
    {&#13;
        // Require that nobody currently owns the road&#13;
        require(0x0 == owners[_x - 1][_y][0]);&#13;
&#13;
        KingOfEthHousesAbstractInterface _housesContract = KingOfEthHousesAbstractInterface(housesContract);&#13;
&#13;
        // Require that either the player owns the house at the&#13;
        // starting location, the road to the right of it, the road&#13;
        // below it, or the road above it&#13;
        address _houseOwner = _housesContract.ownerOf(_x, _y);&#13;
        require(_houseOwner == msg.sender || (0x0 == _houseOwner &amp;&amp; (&#13;
               owners[_x][_y][0] == msg.sender&#13;
            || owners[_x][_y][1] == msg.sender&#13;
            || owners[_x][_y - 1][1] == msg.sender&#13;
        )));&#13;
&#13;
        // Set the new owner&#13;
        owners[_x - 1][_y][0] = msg.sender;&#13;
&#13;
        for(uint _i = 1; _i &lt; _length; ++_i)&#13;
        {&#13;
            // Require that nobody currently owns the road&#13;
            require(0x0 == owners[_x - _i - 1][_y][0]);&#13;
&#13;
            // Require that either the house location is empty or&#13;
            // that it is owned by the player&#13;
            require(&#13;
                   _housesContract.ownerOf(_x - _i, _y) == 0x0&#13;
                || _housesContract.ownerOf(_x - _i, _y) == msg.sender&#13;
            );&#13;
&#13;
            // Set the new owner&#13;
            owners[_x - _i - 1][_y][0] = msg.sender;&#13;
        }&#13;
    }&#13;
&#13;
    /// @dev Build houses upwards&#13;
    /// @param _x The x coordinate of the starting point of the first road&#13;
    /// @param _y The y coordinate of the starting point of the first road&#13;
    /// @param _length The length to build&#13;
    function buildUp(uint _x, uint _y, uint _length) private&#13;
    {&#13;
        // Require that nobody currently owns the road&#13;
        require(0x0 == owners[_x][_y - 1][1]);&#13;
&#13;
        KingOfEthHousesAbstractInterface _housesContract = KingOfEthHousesAbstractInterface(housesContract);&#13;
&#13;
        // Require that either the player owns the house at the&#13;
        // starting location, the road to the right of it, the road&#13;
        // below it, or the road to the left of it&#13;
        address _houseOwner = _housesContract.ownerOf(_x, _y);&#13;
        require(_houseOwner == msg.sender || (0x0 == _houseOwner &amp;&amp; (&#13;
               owners[_x][_y][0] == msg.sender&#13;
            || owners[_x][_y][1] == msg.sender&#13;
            || owners[_x - 1][_y][0] == msg.sender&#13;
        )));&#13;
&#13;
        // Set the new owner&#13;
        owners[_x][_y - 1][1] = msg.sender;&#13;
&#13;
        for(uint _i = 1; _i &lt; _length; ++_i)&#13;
        {&#13;
            // Require that nobody currently owns the road&#13;
            require(0x0 == owners[_x][_y - _i - 1][1]);&#13;
&#13;
            // Require that either the house location is empty or&#13;
            // that it is owned by the player&#13;
            require(&#13;
                   _housesContract.ownerOf(_x, _y - _i) == 0x0&#13;
                || _housesContract.ownerOf(_x, _y - _i) == msg.sender&#13;
            );&#13;
&#13;
            // Set the new owner&#13;
            owners[_x][_y - _i - 1][1] = msg.sender;&#13;
        }&#13;
    }&#13;
&#13;
    /// @dev God can change the road cost&#13;
    /// @param _newRoadCost The new cost of a road&#13;
    function godChangeRoadCost(uint _newRoadCost)&#13;
        public&#13;
        onlyGod&#13;
    {&#13;
        roadCost = _newRoadCost;&#13;
    }&#13;
&#13;
    /// @dev The road realty contract can transfer road ownership&#13;
    /// @param _x The x coordinate of the road&#13;
    /// @param _y The y coordinate of the road&#13;
    /// @param _direction The direction of the road&#13;
    /// @param _from The previous owner of road&#13;
    /// @param _to The new owner of road&#13;
    function roadRealtyTransferOwnership(&#13;
          uint _x&#13;
        , uint _y&#13;
        , uint8 _direction&#13;
        , address _from&#13;
        , address _to&#13;
    )&#13;
        public&#13;
        onlyRoadRealtyContract&#13;
    {&#13;
        // Assert that the previous owner still has the road&#13;
        assert(owners[_x][_y][_direction] == _from);&#13;
&#13;
        // Set the new owner&#13;
        owners[_x][_y][_direction] = _to;&#13;
&#13;
        // Update the road counts&#13;
        --roadCounts[_from];&#13;
        ++roadCounts[_to];&#13;
    }&#13;
&#13;
    /// @dev Build a road in a direction from a location&#13;
    /// @param _x The x coordinate of the starting location&#13;
    /// @param _y The y coordinate of the starting location&#13;
    /// @param _direction The direction to build (right is 0, down is 1,&#13;
    ///  2 is left, and 3 is up)&#13;
    /// @param _length The number of roads to build&#13;
    function buildRoads(&#13;
          uint _x&#13;
        , uint _y&#13;
        , uint8 _direction&#13;
        , uint _length&#13;
    )&#13;
        public&#13;
        payable&#13;
    {&#13;
        // Require at least one road to be built&#13;
        require(0 &lt; _length);&#13;
&#13;
        // Require that the cost for each road was payed&#13;
        require(roadCost * _length == msg.value);&#13;
&#13;
        KingOfEthBoard _boardContract = KingOfEthBoard(boardContract);&#13;
&#13;
        // Require that the start is within bounds&#13;
        require(_boardContract.boundX1() &lt;= _x);&#13;
        require(_boardContract.boundY1() &lt;= _y);&#13;
        require(_boardContract.boundX2() &gt; _x);&#13;
        require(_boardContract.boundY2() &gt; _y);&#13;
&#13;
        // Burn the resource costs for each road&#13;
        KingOfEthResourcesInterface(interfaceContract).burnRoadCosts(&#13;
              _length&#13;
            , msg.sender&#13;
        );&#13;
&#13;
        // If the direction is right&#13;
        if(0 == _direction)&#13;
        {&#13;
            // Require that the roads will be in bounds&#13;
            require(_boardContract.boundX2() &gt; _x + _length);&#13;
&#13;
            buildRight(_x, _y, _length);&#13;
        }&#13;
        // If the direction is down&#13;
        else if(1 == _direction)&#13;
        {&#13;
            // Require that the roads will be in bounds&#13;
            require(_boardContract.boundY2() &gt; _y + _length);&#13;
&#13;
            buildDown(_x, _y, _length);&#13;
        }&#13;
        // If the direction is left&#13;
        else if(2 == _direction)&#13;
        {&#13;
            // Require that the roads will be in bounds&#13;
            require(_boardContract.boundX1() &lt; _x - _length - 1);&#13;
&#13;
            buildLeft(_x, _y, _length);&#13;
        }&#13;
        // If the direction is up&#13;
        else if(3 == _direction)&#13;
        {&#13;
            // Require that the roads will be in bounds&#13;
            require(_boardContract.boundY1() &lt; _y - _length - 1);&#13;
&#13;
            buildUp(_x, _y, _length);&#13;
        }&#13;
        else&#13;
        {&#13;
            // Revert if the direction is invalid&#13;
            revert();&#13;
        }&#13;
&#13;
        // Update the number of roads of the player&#13;
        roadCounts[msg.sender] += _length;&#13;
&#13;
        // Pay taxes&#13;
        KingOfEthAbstractInterface(kingOfEthContract).payTaxes.value(msg.value)();&#13;
&#13;
        emit NewRoads(msg.sender, _x, _y, _direction, _length);&#13;
    }&#13;
&#13;
    /// @dev Send a road to another player&#13;
    /// @param _x The x coordinate of the road&#13;
    /// @param _y The y coordinate of the road&#13;
    /// @param _direction The direction of the road&#13;
    /// @param _to The recipient of the road&#13;
    function sendRoad(uint _x, uint _y, uint8 _direction, address _to)&#13;
        public&#13;
        onlyRoadOwner(_x, _y, _direction)&#13;
    {&#13;
        // Set the new owner&#13;
        owners[_x][_y][_direction] = _to;&#13;
&#13;
        // Update road counts&#13;
        --roadCounts[msg.sender];&#13;
        ++roadCounts[_to];&#13;
&#13;
        // Cancel any sales that exist&#13;
        KingOfEthRoadRealty(roadRealtyContract).roadsCancelRoadSale(&#13;
              _x&#13;
            , _y&#13;
            , _direction&#13;
        );&#13;
&#13;
        emit SentRoad(_x, _y, _direction, msg.sender, _to);&#13;
    }&#13;
}