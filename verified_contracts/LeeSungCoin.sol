pragma solidity ^0.4.19;

// LeeSungCoin Made By PinkCherry - <span class="__cf_email__" data-cfemail="cda4a3beaca3a4b9b4bea6aca38daaa0aca4a1e3aea2a0">[email protected]</span>&#13;
// LeeSungCoin Request Question - <span class="__cf_email__" data-cfemail="deb5b1acbbbfbdb1b7b0adb1b2abaab7b1b09eb9b3bfb7b2f0bdb1b3">[email protected]</span>&#13;
&#13;
library SafeMath&#13;
{&#13;
  	function mul(uint256 a, uint256 b) internal pure returns (uint256)&#13;
    {&#13;
		uint256 c = a * b;&#13;
		assert(a == 0 || c / a == b);&#13;
&#13;
		return c;&#13;
  	}&#13;
&#13;
  	function div(uint256 a, uint256 b) internal pure returns (uint256)&#13;
	{&#13;
		uint256 c = a / b;&#13;
&#13;
		return c;&#13;
  	}&#13;
&#13;
  	function sub(uint256 a, uint256 b) internal pure returns (uint256)&#13;
	{&#13;
		assert(b &lt;= a);&#13;
&#13;
		return a - b;&#13;
  	}&#13;
&#13;
  	function add(uint256 a, uint256 b) internal pure returns (uint256)&#13;
	{&#13;
		uint256 c = a + b;&#13;
		assert(c &gt;= a);&#13;
&#13;
		return c;&#13;
  	}&#13;
}&#13;
&#13;
&#13;
contract OwnerHelper&#13;
{&#13;
  	address public owner;&#13;
&#13;
  	event OwnerTransferPropose(address indexed _from, address indexed _to);&#13;
&#13;
  	modifier onlyOwner&#13;
	{&#13;
		require(msg.sender == owner);&#13;
		_;&#13;
  	}&#13;
&#13;
  	function OwnerHelper() public&#13;
	{&#13;
		owner = msg.sender;&#13;
  	}&#13;
&#13;
  	function transferOwnership(address _to) onlyOwner public&#13;
	{&#13;
            require(_to != owner);&#13;
    		require(_to != address(0x0));&#13;
    		owner = _to;&#13;
    		OwnerTransferPropose(owner, _to);&#13;
  	}&#13;
&#13;
}&#13;
&#13;
&#13;
contract ERC20Interface&#13;
{&#13;
  	event Transfer(address indexed _from, address indexed _to, uint _value);&#13;
  	event Approval(address indexed _owner, address indexed _spender, uint _value);&#13;
	event Burned(address indexed _burner, uint _value);&#13;
&#13;
  	function totalSupply() public constant returns (uint);&#13;
  	function balanceOf(address _owner) public constant returns (uint balance);&#13;
  	function transfer(address _to, uint _value) public returns (bool success);&#13;
  	function transferFrom(address _from, address _to, uint _value) public returns (bool success);&#13;
  	function approve(address _spender, uint _value) public returns (bool success);&#13;
  	function allowance(address _owner, address _spender) public constant returns (uint remaining);&#13;
	function burn(uint _burnAmount) public returns (bool success);&#13;
}&#13;
&#13;
&#13;
contract ERC20Token is ERC20Interface, OwnerHelper&#13;
{&#13;
  	using SafeMath for uint;&#13;
&#13;
  	uint public tokensIssuedTotal = 0;&#13;
  	address public constant burnAddress = 0;&#13;
&#13;
  	mapping(address =&gt; uint) balances;&#13;
  	mapping(address =&gt; mapping (address =&gt; uint)) allowed;&#13;
&#13;
  	function totalSupply() public constant returns (uint)&#13;
	{&#13;
		return tokensIssuedTotal;&#13;
  	}&#13;
&#13;
  	function balanceOf(address _owner) public constant returns (uint balance)&#13;
	{&#13;
		return balances[_owner];&#13;
  	}&#13;
&#13;
	function transfer(address _to, uint _amount) public returns (bool success)&#13;
	{&#13;
		require( balances[msg.sender] &gt;= _amount );&#13;
&#13;
	    balances[msg.sender] = balances[msg.sender].sub(_amount);&#13;
		balances[_to]        = balances[_to].add(_amount);&#13;
&#13;
		Transfer(msg.sender, _to, _amount);&#13;
    &#13;
		return true;&#13;
  	}&#13;
&#13;
  	function approve(address _spender, uint _amount) public returns (bool success)&#13;
	{&#13;
		require ( balances[msg.sender] &gt;= _amount );&#13;
&#13;
		allowed[msg.sender][_spender] = _amount;&#13;
    		&#13;
		Approval(msg.sender, _spender, _amount);&#13;
&#13;
		return true;&#13;
	}&#13;
&#13;
  	function transferFrom(address _from, address _to, uint _amount) public returns (bool success)&#13;
	{&#13;
		require( balances[_from] &gt;= _amount );&#13;
		require( allowed[_from][msg.sender] &gt;= _amount );&#13;
		balances[_from]            = balances[_from].sub(_amount);&#13;
		allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);&#13;
		balances[_to]              = balances[_to].add(_amount);&#13;
&#13;
		Transfer(_from, _to, _amount);&#13;
		return true;&#13;
  	}&#13;
&#13;
  	function allowance(address _owner, address _spender) public constant returns (uint remaining)&#13;
	{&#13;
		return allowed[_owner][_spender];&#13;
  	}&#13;
&#13;
	function burn(uint _burnAmount) public returns (bool success)&#13;
	{&#13;
		address burner = msg.sender;&#13;
		balances[burner] = balances[burner].sub(_burnAmount);&#13;
		tokensIssuedTotal = tokensIssuedTotal.sub(_burnAmount);&#13;
		Burned(burner, _burnAmount);&#13;
		Transfer(burner, burnAddress, _burnAmount);&#13;
&#13;
		return true;&#13;
	}&#13;
}&#13;
&#13;
contract LeeSungCoin is ERC20Token&#13;
{&#13;
	uint constant E18 = 10**18;&#13;
&#13;
  	string public constant name 	= "Lee Sung Coin";&#13;
  	string public constant symbol 	= "LSC";&#13;
  	uint public constant decimals 	= 18;&#13;
&#13;
	address public wallet;&#13;
	address public adminWallet;&#13;
&#13;
	uint public constant totalCoinCap   = 200000000 * E18;&#13;
	uint public constant icoCoinCap     = 140000000 * E18;&#13;
	uint public constant mktCoinCap     =  60000000 * E18;&#13;
	uint public constant preSaleCoinCap =  48000000 * E18;&#13;
&#13;
	uint public coinPerEth = 20000 * E18;&#13;
&#13;
	uint public constant privateSaleBonus	 = 30;&#13;
	uint public constant preSaleFirstBonus	 = 20;&#13;
	uint public constant preSaleSecondBonus  = 15;&#13;
	uint public constant mainSaleFirstBonus	 = 5;&#13;
	uint public constant mainSaleSecondBonus = 0;&#13;
&#13;
  	uint public constant preSaleFirstStartDate = 1517788800; // 2018-02-05 00:00 UTC&#13;
  	uint public constant preSaleFirstEndDate   = 1518307200; // 2018-02-11 00:00 UTC&#13;
&#13;
  	uint public constant preSaleSecondStartDate = 1518393600; // 2018-02-12 00:00 UTC&#13;
  	uint public constant preSaleSecondEndDate   = 1518912000; // 2018-02-18 00:00 UTC&#13;
&#13;
&#13;
  	uint public constant mainSaleFirstStartDate = 1519603200; // 2018-02-26 00:00 UTC&#13;
  	uint public constant mainSaleFirstEndDate   = 1520121600; // 2018-03-04 00:00 UTC&#13;
&#13;
  	uint public constant mainSaleSecondStartDate = 1520208000; // 2018-03-05 00:00 UTC&#13;
  	uint public constant mainSaleSecondEndDate   = 1520726400; // 2018-03-11 00:00 UTC&#13;
&#13;
	uint public constant transferCooldown = 2 days;&#13;
&#13;
	uint public constant preSaleMinEth  = 1 ether;&#13;
	uint public constant mainSaleMinEth =  1 ether / 2; // 0.5 Ether&#13;
&#13;
  	uint public icoEtherReceived = 0; // Ether actually received by the contract&#13;
&#13;
    uint public coinIssuedTotal     = 0;&#13;
  	uint public coinIssuedIco       = 0;&#13;
  	uint public coinIssuedMkt       = 0;&#13;
	uint public coinIssuedPrivate   = 0;&#13;
	&#13;
	uint public coinBurnIco = 0;&#13;
	uint public coinBurnMkt = 0;&#13;
&#13;
  	mapping(address =&gt; uint) public icoEtherContributed;&#13;
  	mapping(address =&gt; uint) public icoCoinReceived;&#13;
  	mapping(address =&gt; bool) public refundClaimed;&#13;
  	mapping(address =&gt; bool) public coinLocked;&#13;
  	&#13;
 	event WalletChange(address _newWallet);&#13;
  	event AdminWalletChange(address _newAdminWallet);&#13;
  	event CoinMinted(address indexed _owner, uint _tokens, uint _balance);&#13;
  	event CoinIssued(address indexed _owner, uint _tokens, uint _balance, uint _etherContributed);&#13;
  	event Refund(address indexed _owner, uint _amount, uint _tokens);&#13;
  	event LockRemove(address indexed _participant);&#13;
	event WithDraw(address indexed _to, uint _amount);&#13;
	event OwnerReclaim(address indexed _from, address indexed _owner, uint _amount);&#13;
&#13;
  	function LeeSungCoin() public&#13;
	{&#13;
		require( icoCoinCap + mktCoinCap == totalCoinCap );&#13;
		wallet = owner;&#13;
		adminWallet = owner;&#13;
  	}&#13;
&#13;
  	function () payable public&#13;
	{&#13;
    	buyCoin();&#13;
  	}&#13;
  	&#13;
  	function atNow() public constant returns (uint)&#13;
	{&#13;
		return now;&#13;
  	}&#13;
&#13;
  	function buyCoin() private&#13;
	{&#13;
		uint nowTime = atNow();&#13;
&#13;
		uint saleTime = 0; // 1 : preSaleFirst, 2 : preSaleSecond, 3 : mainSaleFirst, 4 : mainSaleSecond&#13;
&#13;
		uint minEth = 0;&#13;
		uint maxEth = 300 ether;&#13;
&#13;
		uint coins = 0;&#13;
		uint coinBonus = 0;&#13;
		uint coinCap = 0;&#13;
&#13;
		if (nowTime &gt; preSaleFirstStartDate &amp;&amp; nowTime &lt; preSaleFirstEndDate)&#13;
		{&#13;
			saleTime = 1;&#13;
			minEth = preSaleMinEth;&#13;
			coinBonus = preSaleFirstBonus;&#13;
			coinCap = preSaleCoinCap;&#13;
		}&#13;
&#13;
		if (nowTime &gt; preSaleSecondStartDate &amp;&amp; nowTime &lt; preSaleSecondEndDate)&#13;
		{&#13;
			saleTime = 2;&#13;
			minEth = preSaleMinEth;&#13;
			coinBonus = preSaleSecondBonus;&#13;
			coinCap = preSaleCoinCap;&#13;
		}&#13;
&#13;
		if (nowTime &gt; mainSaleFirstStartDate &amp;&amp; nowTime &lt; mainSaleFirstEndDate)&#13;
		{&#13;
			saleTime = 3;&#13;
			minEth = mainSaleMinEth;&#13;
			coinBonus = mainSaleFirstBonus;&#13;
			coinCap = icoCoinCap;&#13;
		}&#13;
&#13;
		if (nowTime &gt; mainSaleSecondStartDate &amp;&amp; nowTime &lt; mainSaleSecondEndDate)&#13;
		{&#13;
			saleTime = 4;&#13;
			minEth = mainSaleMinEth;&#13;
			coinBonus = mainSaleSecondBonus;&#13;
			coinCap = icoCoinCap;&#13;
		}&#13;
		&#13;
		require( saleTime &gt;= 1 &amp;&amp; saleTime &lt;= 4 );&#13;
		require( msg.value &gt;= minEth );&#13;
		require( icoEtherContributed[msg.sender].add(msg.value) &lt;= maxEth );&#13;
&#13;
		coins = coinPerEth.mul(msg.value) / 1 ether;&#13;
      	coins = coins.mul(100 + coinBonus) / 100;&#13;
&#13;
		require( coinIssuedIco.add(coins) &lt;= coinCap );&#13;
&#13;
		balances[msg.sender]        = balances[msg.sender].add(coins);&#13;
	    icoCoinReceived[msg.sender] = icoCoinReceived[msg.sender].add(coins);&#13;
		coinIssuedIco               = coinIssuedIco.add(coins);&#13;
		tokensIssuedTotal           = tokensIssuedTotal.add(coins);&#13;
    &#13;
		icoEtherReceived                = icoEtherReceived.add(msg.value);&#13;
		icoEtherContributed[msg.sender] = icoEtherContributed[msg.sender].add(msg.value);&#13;
    &#13;
		coinLocked[msg.sender] = true;&#13;
    &#13;
		Transfer(0x0, msg.sender, coins);&#13;
		CoinIssued(msg.sender, coins, balances[msg.sender], msg.value);&#13;
&#13;
		wallet.transfer(this.balance);&#13;
  	}&#13;
&#13;
 	function isTransferable() public constant returns (bool transferable)&#13;
	{&#13;
		if ( atNow() &lt; mainSaleSecondEndDate + transferCooldown )&#13;
		{&#13;
			return false;&#13;
		}&#13;
&#13;
		return true;&#13;
  	}&#13;
&#13;
	function coinLockRemove(address _participant) public&#13;
	{&#13;
		require( msg.sender == adminWallet || msg.sender == owner );&#13;
		coinLocked[_participant] = false;&#13;
		LockRemove(_participant);&#13;
  	}&#13;
&#13;
	function coinLockRmoveMultiple(address[] _participants) public&#13;
	{&#13;
		require( msg.sender == adminWallet || msg.sender == owner );&#13;
    		&#13;
		for (uint i = 0; i &lt; _participants.length; i++)&#13;
		{&#13;
  			coinLocked[_participants[i]] = false;&#13;
  			LockRemove(_participants[i]);&#13;
		}&#13;
  	}&#13;
&#13;
  	function changeWallet(address _wallet) onlyOwner public&#13;
	{&#13;
    		require( _wallet != address(0x0) );&#13;
    		wallet = _wallet;&#13;
    		WalletChange(wallet);&#13;
  	}&#13;
&#13;
  	function changeAdminWallet(address _wallet) onlyOwner public&#13;
	{&#13;
    		require( _wallet != address(0x0) );&#13;
    		adminWallet = _wallet;&#13;
    		AdminWalletChange(adminWallet);&#13;
  	}&#13;
&#13;
  	function mintMarketing(address _participant, uint _amount) onlyOwner public&#13;
	{&#13;
		uint coins = _amount * E18;&#13;
		&#13;
		require( coins &lt;= mktCoinCap.sub(coinIssuedMkt) );&#13;
		&#13;
		balances[_participant] = balances[_participant].add(coins);&#13;
		&#13;
		coinIssuedMkt   = coinIssuedMkt.add(coins);&#13;
		coinIssuedTotal = coinIssuedTotal.add(coins);&#13;
		&#13;
		coinLocked[_participant] = true;&#13;
		&#13;
		Transfer(0x0, _participant, coins);&#13;
		CoinMinted(_participant, coins, balances[_participant]);&#13;
  	}&#13;
&#13;
  	function mintPrivate(address _participant, uint _etherValue) onlyOwner public&#13;
	{&#13;
		uint coins = coinPerEth.mul(_etherValue);&#13;
      	coins = coins.mul(100 + privateSaleBonus) / 100;&#13;
&#13;
		require( coins &lt;= icoCoinCap.sub(coinIssuedIco) );&#13;
		require( atNow() &lt; preSaleFirstStartDate );&#13;
&#13;
		balances[_participant] = balances[_participant].add(coins);&#13;
&#13;
		coinIssuedPrivate   = coinIssuedPrivate.add(coins);&#13;
		coinIssuedIco       = coinIssuedIco.add(coins);&#13;
		coinIssuedTotal     = coinIssuedTotal.add(coins);&#13;
&#13;
		coinLocked[_participant] = true;&#13;
		Transfer(0x0, _participant, coins);&#13;
		CoinMinted(_participant, coins, balances[_participant]);&#13;
  	}&#13;
  	&#13;
  	function ownerWithdraw() external onlyOwner&#13;
	{&#13;
		uint amount = this.balance;&#13;
		wallet.transfer(amount);&#13;
		WithDraw(msg.sender, amount);&#13;
  	}&#13;
  	&#13;
  	function transferAnyERC20Token(address tokenAddress, uint amount) onlyOwner public returns (bool success)&#13;
	{&#13;
  		return ERC20Interface(tokenAddress).transfer(owner, amount);&#13;
  	}&#13;
  	&#13;
  	function transfer(address _to, uint _amount) public returns (bool success)&#13;
	{&#13;
		require( isTransferable() );&#13;
		require( coinLocked[msg.sender] == false );&#13;
		require( coinLocked[_to] == false );&#13;
		return super.transfer(_to, _amount);&#13;
  	}&#13;
  	&#13;
  	function transferFrom(address _from, address _to, uint _amount) public returns (bool success)&#13;
	{&#13;
		require( isTransferable() );&#13;
		require( coinLocked[_from] == false );&#13;
		require( coinLocked[_to] == false );&#13;
		return super.transferFrom(_from, _to, _amount);&#13;
  	}&#13;
&#13;
  	function transferMultiple(address[] _addresses, uint[] _amounts) external&#13;
  	{&#13;
		require( isTransferable() );&#13;
		require( coinLocked[msg.sender] == false );&#13;
		require( _addresses.length == _amounts.length );&#13;
		&#13;
		for (uint i = 0; i &lt; _addresses.length; i++)&#13;
		{&#13;
  			if (coinLocked[_addresses[i]] == false) &#13;
			{&#13;
				super.transfer(_addresses[i], _amounts[i]);&#13;
			}&#13;
		}&#13;
  	}&#13;
&#13;
  	function reclaimFunds() external&#13;
	{&#13;
		uint coins;&#13;
		uint amount;&#13;
&#13;
		require( atNow() &gt; mainSaleSecondEndDate );&#13;
		require( !refundClaimed[msg.sender] );&#13;
		require( icoEtherContributed[msg.sender] &gt; 0 );&#13;
&#13;
		coins = icoCoinReceived[msg.sender];&#13;
		amount = icoEtherContributed[msg.sender];&#13;
&#13;
		balances[msg.sender] = balances[msg.sender].sub(coins);&#13;
		tokensIssuedTotal    = tokensIssuedTotal.sub(coins);&#13;
&#13;
		refundClaimed[msg.sender] = true;&#13;
&#13;
		msg.sender.transfer(amount);&#13;
&#13;
		Transfer(msg.sender, 0x0, coins);&#13;
		Refund(msg.sender, amount, coins);&#13;
  	}&#13;
  	&#13;
    function transferToOwner(address _from) onlyOwner public&#13;
    {&#13;
		require( coinLocked[_from] == false );&#13;
        uint amount = balanceOf(_from);&#13;
        &#13;
        balances[_from] = balances[_from].sub(amount);&#13;
        balances[owner] = balances[owner].add(amount);&#13;
        &#13;
        Transfer(_from, owner, amount);&#13;
        OwnerReclaim(_from, owner, amount);&#13;
    }&#13;
&#13;
	function burnCoins(uint _icoAmount, uint _mktAmount) onlyOwner public returns (bool success)&#13;
	{&#13;
	    uint icoCoins = _icoAmount * E18;&#13;
	    uint mktCoins = _mktAmount * E18;&#13;
	    &#13;
	    uint totalBurnCoins = 0;&#13;
	    totalBurnCoins = totalBurnCoins.add(icoCoins);&#13;
	    totalBurnCoins = totalBurnCoins.add(mktCoins);&#13;
	    &#13;
	    coinBurnIco = coinBurnIco.add(icoCoins);&#13;
	    coinBurnMkt = coinBurnMkt.add(mktCoins);&#13;
	    &#13;
		return super.burn(totalBurnCoins);&#13;
	}&#13;
&#13;
}