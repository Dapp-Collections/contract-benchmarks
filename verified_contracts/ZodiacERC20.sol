pragma solidity ^0.4.24;


/*
 * Ownable
 *
 * Base contract with an owner.
 * Provides onlyOwner modifier, which prevents function from running if it is called by anyone other than the owner.
 */

contract Ownable {
    address public owner;

    constructor()
        public
    {
        owner = msg.sender;
    }

    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    function transferOwnership(address newOwner)
        public
        onlyOwner
    {
        if (newOwner != address(0)) {
            owner = newOwner;
        }
    }
}

library SafeMath {
    function safeMul(uint a, uint b)
        internal
        pure
        returns (uint256)
    {
        uint c = a * b;
        assert(a == 0 || c / a == b);
        return c;
    }

    function safeDiv(uint a, uint b)
        internal
        pure
        returns (uint256)
    {
        uint c = a / b;
        return c;
    }

    function safeSub(uint a, uint b)
        internal
        pure
        returns (uint256)
    {
        assert(b <= a);
        return a - b;
    }

    function safeAdd(uint a, uint b)
        internal
        pure
        returns (uint256)
    {
        uint c = a + b;
        assert(c >= a);
        return c;
    }

    function max64(uint64 a, uint64 b)
        internal
        pure
        returns (uint256)
    {
        return a >= b ? a : b;
    }

    function min64(uint64 a, uint64 b)
        internal
        pure
        returns (uint256)
    {
        return a < b ? a : b;
    }

    function max256(uint256 a, uint256 b)
        internal
        pure
        returns (uint256)
    {
        return a >= b ? a : b;
    }

    function min256(uint256 a, uint256 b)
        internal
        pure
        returns (uint256)
    {
        return a < b ? a : b;
    }
}


/**
 * @title BytesToTypes
 * @dev The BytesToTypes contract converts the memory byte arrays to the standard solidity types
 * @author <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="7d0d1208111c19071c19183d1a101c1411531e1210">[emailÂ protected]</a>&#13;
 */&#13;
&#13;
contract BytesToTypes {&#13;
    &#13;
&#13;
    function bytesToAddress(uint _offst, bytes memory _input) internal pure returns (address _output) {&#13;
        &#13;
        assembly {&#13;
            _output := mload(add(_input, _offst))&#13;
        }&#13;
    } &#13;
    &#13;
    function bytesToBool(uint _offst, bytes memory _input) internal pure returns (bool _output) {&#13;
        &#13;
        uint8 x;&#13;
        assembly {&#13;
            x := mload(add(_input, _offst))&#13;
        }&#13;
        x==0 ? _output = false : _output = true;&#13;
    }   &#13;
        &#13;
    function getStringSize(uint _offst, bytes memory _input) internal pure returns(uint size){&#13;
        &#13;
        assembly{&#13;
            &#13;
            size := mload(add(_input,_offst))&#13;
            let chunk_count := add(div(size,32),1) // chunk_count = size/32 + 1&#13;
            &#13;
            if gt(mod(size,32),0) {// if size%32 &gt; 0&#13;
                chunk_count := add(chunk_count,1)&#13;
            } &#13;
            &#13;
             size := mul(chunk_count,32)// first 32 bytes reseves for size in strings&#13;
        }&#13;
    }&#13;
&#13;
    function bytesToString(uint _offst, bytes memory _input, bytes memory _output) internal  {&#13;
&#13;
        uint size = 32;&#13;
        assembly {&#13;
            let loop_index:= 0&#13;
                  &#13;
            let chunk_count&#13;
            &#13;
            size := mload(add(_input,_offst))&#13;
            chunk_count := add(div(size,32),1) // chunk_count = size/32 + 1&#13;
            &#13;
            if gt(mod(size,32),0) {&#13;
                chunk_count := add(chunk_count,1)  // chunk_count++&#13;
            }&#13;
                &#13;
            &#13;
            loop:&#13;
                mstore(add(_output,mul(loop_index,32)),mload(add(_input,_offst)))&#13;
                _offst := sub(_offst,32)           // _offst -= 32&#13;
                loop_index := add(loop_index,1)&#13;
                &#13;
            jumpi(loop , lt(loop_index , chunk_count))&#13;
            &#13;
        }&#13;
    }&#13;
&#13;
    function slice(bytes _bytes, uint _start, uint _length) internal  pure returns (bytes) {&#13;
        require(_bytes.length &gt;= (_start + _length));&#13;
&#13;
        bytes memory tempBytes;&#13;
&#13;
        assembly {&#13;
            switch iszero(_length)&#13;
            case 0 {&#13;
                // Get a location of some free memory and store it in tempBytes as&#13;
                // Solidity does for memory variables.&#13;
                tempBytes := mload(0x40)&#13;
&#13;
                // The first word of the slice result is potentially a partial&#13;
                // word read from the original array. To read it, we calculate&#13;
                // the length of that partial word and start copying that many&#13;
                // bytes into the array. The first word we copy will start with&#13;
                // data we don't care about, but the last `lengthmod` bytes will&#13;
                // land at the beginning of the contents of the new array. When&#13;
                // we're done copying, we overwrite the full first word with&#13;
                // the actual length of the slice.&#13;
                let lengthmod := and(_length, 31)&#13;
&#13;
                // The multiplication in the next line is necessary&#13;
                // because when slicing multiples of 32 bytes (lengthmod == 0)&#13;
                // the following copy loop was copying the origin's length&#13;
                // and then ending prematurely not copying everything it should.&#13;
                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))&#13;
                let end := add(mc, _length)&#13;
&#13;
                for {&#13;
                    // The multiplication in the next line has the same exact purpose&#13;
                    // as the one above.&#13;
                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)&#13;
                } lt(mc, end) {&#13;
                    mc := add(mc, 0x20)&#13;
                    cc := add(cc, 0x20)&#13;
                } {&#13;
                    mstore(mc, mload(cc))&#13;
                }&#13;
&#13;
                mstore(tempBytes, _length)&#13;
&#13;
                //update free-memory pointer&#13;
                //allocating the array padded to 32 bytes like the compiler does now&#13;
                mstore(0x40, and(add(mc, 31), not(31)))&#13;
            }&#13;
            //if we want a zero-length slice let's just return a zero-length array&#13;
            default {&#13;
                tempBytes := mload(0x40)&#13;
&#13;
                mstore(0x40, add(tempBytes, 0x20))&#13;
            }&#13;
        }&#13;
&#13;
        return tempBytes;&#13;
    }&#13;
&#13;
&#13;
    function bytesToBytes32(uint _offst, bytes memory  _input) internal pure returns (bytes32 _output) {&#13;
&#13;
        assembly {&#13;
            _output := mload(add(_input, _offst))&#13;
        }&#13;
    }&#13;
&#13;
    /*function bytesToBytes32(uint _offst, bytes memory  _input, bytes32 _output) internal pure {&#13;
        &#13;
        assembly {&#13;
            mstore(_output , add(_input, _offst))&#13;
            mstore(add(_output,32) , add(add(_input, _offst),32))&#13;
        }&#13;
    }*/&#13;
    &#13;
    function bytesToInt8(uint _offst, bytes memory  _input) internal pure returns (int8 _output) {&#13;
        &#13;
        assembly {&#13;
            _output := mload(add(_input, _offst))&#13;
        }&#13;
    }&#13;
    &#13;
    function bytesToInt16(uint _offst, bytes memory _input) internal pure returns (int16 _output) {&#13;
        &#13;
        assembly {&#13;
            _output := mload(add(_input, _offst))&#13;
        }&#13;
    }&#13;
&#13;
    function bytesToInt24(uint _offst, bytes memory _input) internal pure returns (int24 _output) {&#13;
        &#13;
        assembly {&#13;
            _output := mload(add(_input, _offst))&#13;
        }&#13;
    }&#13;
&#13;
    function bytesToInt32(uint _offst, bytes memory _input) internal pure returns (int32 _output) {&#13;
        &#13;
        assembly {&#13;
            _output := mload(add(_input, _offst))&#13;
        }&#13;
    }&#13;
&#13;
    function bytesToInt40(uint _offst, bytes memory _input) internal pure returns (int40 _output) {&#13;
        &#13;
        assembly {&#13;
            _output := mload(add(_input, _offst))&#13;
        }&#13;
    }&#13;
&#13;
    function bytesToInt48(uint _offst, bytes memory _input) internal pure returns (int48 _output) {&#13;
        &#13;
        assembly {&#13;
            _output := mload(add(_input, _offst))&#13;
        }&#13;
    }&#13;
&#13;
    function bytesToInt56(uint _offst, bytes memory _input) internal pure returns (int56 _output) {&#13;
        &#13;
        assembly {&#13;
            _output := mload(add(_input, _offst))&#13;
        }&#13;
    }&#13;
&#13;
    function bytesToInt64(uint _offst, bytes memory _input) internal pure returns (int64 _output) {&#13;
        &#13;
        assembly {&#13;
            _output := mload(add(_input, _offst))&#13;
        }&#13;
    }&#13;
&#13;
    function bytesToInt72(uint _offst, bytes memory _input) internal pure returns (int72 _output) {&#13;
        &#13;
        assembly {&#13;
            _output := mload(add(_input, _offst))&#13;
        }&#13;
    }&#13;
&#13;
    function bytesToInt80(uint _offst, bytes memory _input) internal pure returns (int80 _output) {&#13;
        &#13;
        assembly {&#13;
            _output := mload(add(_input, _offst))&#13;
        }&#13;
    }&#13;
&#13;
    function bytesToInt88(uint _offst, bytes memory _input) internal pure returns (int88 _output) {&#13;
        &#13;
        assembly {&#13;
            _output := mload(add(_input, _offst))&#13;
        }&#13;
    }&#13;
&#13;
    function bytesToInt96(uint _offst, bytes memory _input) internal pure returns (int96 _output) {&#13;
        &#13;
        assembly {&#13;
            _output := mload(add(_input, _offst))&#13;
        }&#13;
    }&#13;
	&#13;
	function bytesToInt104(uint _offst, bytes memory _input) internal pure returns (int104 _output) {&#13;
        &#13;
        assembly {&#13;
            _output := mload(add(_input, _offst))&#13;
        }&#13;
    }&#13;
    &#13;
    function bytesToInt112(uint _offst, bytes memory _input) internal pure returns (int112 _output) {&#13;
        &#13;
        assembly {&#13;
            _output := mload(add(_input, _offst))&#13;
        }&#13;
    }&#13;
&#13;
    function bytesToInt120(uint _offst, bytes memory _input) internal pure returns (int120 _output) {&#13;
        &#13;
        assembly {&#13;
            _output := mload(add(_input, _offst))&#13;
        }&#13;
    }&#13;
&#13;
    function bytesToInt128(uint _offst, bytes memory _input) internal pure returns (int128 _output) {&#13;
        &#13;
        assembly {&#13;
            _output := mload(add(_input, _offst))&#13;
        }&#13;
    }&#13;
&#13;
    function bytesToInt136(uint _offst, bytes memory _input) internal pure returns (int136 _output) {&#13;
        &#13;
        assembly {&#13;
            _output := mload(add(_input, _offst))&#13;
        }&#13;
    }&#13;
&#13;
    function bytesToInt144(uint _offst, bytes memory _input) internal pure returns (int144 _output) {&#13;
        &#13;
        assembly {&#13;
            _output := mload(add(_input, _offst))&#13;
        }&#13;
    }&#13;
&#13;
    function bytesToInt152(uint _offst, bytes memory _input) internal pure returns (int152 _output) {&#13;
        &#13;
        assembly {&#13;
            _output := mload(add(_input, _offst))&#13;
        }&#13;
    }&#13;
&#13;
    function bytesToInt160(uint _offst, bytes memory _input) internal pure returns (int160 _output) {&#13;
        &#13;
        assembly {&#13;
            _output := mload(add(_input, _offst))&#13;
        }&#13;
    }&#13;
&#13;
    function bytesToInt168(uint _offst, bytes memory _input) internal pure returns (int168 _output) {&#13;
        &#13;
        assembly {&#13;
            _output := mload(add(_input, _offst))&#13;
        }&#13;
    }&#13;
&#13;
    function bytesToInt176(uint _offst, bytes memory _input) internal pure returns (int176 _output) {&#13;
        &#13;
        assembly {&#13;
            _output := mload(add(_input, _offst))&#13;
        }&#13;
    }&#13;
&#13;
    function bytesToInt184(uint _offst, bytes memory _input) internal pure returns (int184 _output) {&#13;
        &#13;
        assembly {&#13;
            _output := mload(add(_input, _offst))&#13;
        }&#13;
    }&#13;
&#13;
    function bytesToInt192(uint _offst, bytes memory _input) internal pure returns (int192 _output) {&#13;
        &#13;
        assembly {&#13;
            _output := mload(add(_input, _offst))&#13;
        }&#13;
    }&#13;
&#13;
    function bytesToInt200(uint _offst, bytes memory _input) internal pure returns (int200 _output) {&#13;
        &#13;
        assembly {&#13;
            _output := mload(add(_input, _offst))&#13;
        }&#13;
    }&#13;
&#13;
    function bytesToInt208(uint _offst, bytes memory _input) internal pure returns (int208 _output) {&#13;
        &#13;
        assembly {&#13;
            _output := mload(add(_input, _offst))&#13;
        }&#13;
    }&#13;
&#13;
    function bytesToInt216(uint _offst, bytes memory _input) internal pure returns (int216 _output) {&#13;
        &#13;
        assembly {&#13;
            _output := mload(add(_input, _offst))&#13;
        }&#13;
    }&#13;
&#13;
    function bytesToInt224(uint _offst, bytes memory _input) internal pure returns (int224 _output) {&#13;
        &#13;
        assembly {&#13;
            _output := mload(add(_input, _offst))&#13;
        }&#13;
    }&#13;
&#13;
    function bytesToInt232(uint _offst, bytes memory _input) internal pure returns (int232 _output) {&#13;
        &#13;
        assembly {&#13;
            _output := mload(add(_input, _offst))&#13;
        }&#13;
    }&#13;
&#13;
    function bytesToInt240(uint _offst, bytes memory _input) internal pure returns (int240 _output) {&#13;
        &#13;
        assembly {&#13;
            _output := mload(add(_input, _offst))&#13;
        }&#13;
    }&#13;
&#13;
    function bytesToInt248(uint _offst, bytes memory _input) internal pure returns (int248 _output) {&#13;
        &#13;
        assembly {&#13;
            _output := mload(add(_input, _offst))&#13;
        }&#13;
    }&#13;
&#13;
    function bytesToInt256(uint _offst, bytes memory _input) internal pure returns (int256 _output) {&#13;
        &#13;
        assembly {&#13;
            _output := mload(add(_input, _offst))&#13;
        }&#13;
    }&#13;
&#13;
	function bytesToUint8(uint _offst, bytes memory _input) internal pure returns (uint8 _output) {&#13;
        &#13;
        assembly {&#13;
            _output := mload(add(_input, _offst))&#13;
        }&#13;
    } &#13;
&#13;
	function bytesToUint16(uint _offst, bytes memory _input) internal pure returns (uint16 _output) {&#13;
        &#13;
        assembly {&#13;
            _output := mload(add(_input, _offst))&#13;
        }&#13;
    } &#13;
&#13;
	function bytesToUint24(uint _offst, bytes memory _input) internal pure returns (uint24 _output) {&#13;
        &#13;
        assembly {&#13;
            _output := mload(add(_input, _offst))&#13;
        }&#13;
    } &#13;
&#13;
	function bytesToUint32(uint _offst, bytes memory _input) internal pure returns (uint32 _output) {&#13;
        &#13;
        assembly {&#13;
            _output := mload(add(_input, _offst))&#13;
        }&#13;
    } &#13;
&#13;
	function bytesToUint40(uint _offst, bytes memory _input) internal pure returns (uint40 _output) {&#13;
        &#13;
        assembly {&#13;
            _output := mload(add(_input, _offst))&#13;
        }&#13;
    } &#13;
&#13;
	function bytesToUint48(uint _offst, bytes memory _input) internal pure returns (uint48 _output) {&#13;
        &#13;
        assembly {&#13;
            _output := mload(add(_input, _offst))&#13;
        }&#13;
    } &#13;
&#13;
	function bytesToUint56(uint _offst, bytes memory _input) internal pure returns (uint56 _output) {&#13;
        &#13;
        assembly {&#13;
            _output := mload(add(_input, _offst))&#13;
        }&#13;
    } &#13;
&#13;
	function bytesToUint64(uint _offst, bytes memory _input) internal pure returns (uint64 _output) {&#13;
        &#13;
        assembly {&#13;
            _output := mload(add(_input, _offst))&#13;
        }&#13;
    } &#13;
&#13;
	function bytesToUint72(uint _offst, bytes memory _input) internal pure returns (uint72 _output) {&#13;
        &#13;
        assembly {&#13;
            _output := mload(add(_input, _offst))&#13;
        }&#13;
    } &#13;
&#13;
	function bytesToUint80(uint _offst, bytes memory _input) internal pure returns (uint80 _output) {&#13;
        &#13;
        assembly {&#13;
            _output := mload(add(_input, _offst))&#13;
        }&#13;
    } &#13;
&#13;
	function bytesToUint88(uint _offst, bytes memory _input) internal pure returns (uint88 _output) {&#13;
        &#13;
        assembly {&#13;
            _output := mload(add(_input, _offst))&#13;
        }&#13;
    } &#13;
&#13;
	function bytesToUint96(uint _offst, bytes memory _input) internal pure returns (uint96 _output) {&#13;
        &#13;
        assembly {&#13;
            _output := mload(add(_input, _offst))&#13;
        }&#13;
    } &#13;
	&#13;
	function bytesToUint104(uint _offst, bytes memory _input) internal pure returns (uint104 _output) {&#13;
        &#13;
        assembly {&#13;
            _output := mload(add(_input, _offst))&#13;
        }&#13;
    } &#13;
&#13;
    function bytesToUint112(uint _offst, bytes memory _input) internal pure returns (uint112 _output) {&#13;
        &#13;
        assembly {&#13;
            _output := mload(add(_input, _offst))&#13;
        }&#13;
    } &#13;
&#13;
    function bytesToUint120(uint _offst, bytes memory _input) internal pure returns (uint120 _output) {&#13;
        &#13;
        assembly {&#13;
            _output := mload(add(_input, _offst))&#13;
        }&#13;
    } &#13;
&#13;
    function bytesToUint128(uint _offst, bytes memory _input) internal pure returns (uint128 _output) {&#13;
        &#13;
        assembly {&#13;
            _output := mload(add(_input, _offst))&#13;
        }&#13;
    } &#13;
&#13;
    function bytesToUint136(uint _offst, bytes memory _input) internal pure returns (uint136 _output) {&#13;
        &#13;
        assembly {&#13;
            _output := mload(add(_input, _offst))&#13;
        }&#13;
    } &#13;
&#13;
    function bytesToUint144(uint _offst, bytes memory _input) internal pure returns (uint144 _output) {&#13;
        &#13;
        assembly {&#13;
            _output := mload(add(_input, _offst))&#13;
        }&#13;
    } &#13;
&#13;
    function bytesToUint152(uint _offst, bytes memory _input) internal pure returns (uint152 _output) {&#13;
        &#13;
        assembly {&#13;
            _output := mload(add(_input, _offst))&#13;
        }&#13;
    } &#13;
&#13;
    function bytesToUint160(uint _offst, bytes memory _input) internal pure returns (uint160 _output) {&#13;
        &#13;
        assembly {&#13;
            _output := mload(add(_input, _offst))&#13;
        }&#13;
    } &#13;
&#13;
    function bytesToUint168(uint _offst, bytes memory _input) internal pure returns (uint168 _output) {&#13;
        &#13;
        assembly {&#13;
            _output := mload(add(_input, _offst))&#13;
        }&#13;
    } &#13;
&#13;
    function bytesToUint176(uint _offst, bytes memory _input) internal pure returns (uint176 _output) {&#13;
        &#13;
        assembly {&#13;
            _output := mload(add(_input, _offst))&#13;
        }&#13;
    } &#13;
&#13;
    function bytesToUint184(uint _offst, bytes memory _input) internal pure returns (uint184 _output) {&#13;
        &#13;
        assembly {&#13;
            _output := mload(add(_input, _offst))&#13;
        }&#13;
    } &#13;
&#13;
    function bytesToUint192(uint _offst, bytes memory _input) internal pure returns (uint192 _output) {&#13;
        &#13;
        assembly {&#13;
            _output := mload(add(_input, _offst))&#13;
        }&#13;
    } &#13;
&#13;
    function bytesToUint200(uint _offst, bytes memory _input) internal pure returns (uint200 _output) {&#13;
        &#13;
        assembly {&#13;
            _output := mload(add(_input, _offst))&#13;
        }&#13;
    } &#13;
&#13;
    function bytesToUint208(uint _offst, bytes memory _input) internal pure returns (uint208 _output) {&#13;
        &#13;
        assembly {&#13;
            _output := mload(add(_input, _offst))&#13;
        }&#13;
    } &#13;
&#13;
    function bytesToUint216(uint _offst, bytes memory _input) internal pure returns (uint216 _output) {&#13;
        &#13;
        assembly {&#13;
            _output := mload(add(_input, _offst))&#13;
        }&#13;
    } &#13;
&#13;
    function bytesToUint224(uint _offst, bytes memory _input) internal pure returns (uint224 _output) {&#13;
        &#13;
        assembly {&#13;
            _output := mload(add(_input, _offst))&#13;
        }&#13;
    } &#13;
&#13;
    function bytesToUint232(uint _offst, bytes memory _input) internal pure returns (uint232 _output) {&#13;
        &#13;
        assembly {&#13;
            _output := mload(add(_input, _offst))&#13;
        }&#13;
    } &#13;
&#13;
    function bytesToUint240(uint _offst, bytes memory _input) internal pure returns (uint240 _output) {&#13;
        &#13;
        assembly {&#13;
            _output := mload(add(_input, _offst))&#13;
        }&#13;
    } &#13;
&#13;
    function bytesToUint248(uint _offst, bytes memory _input) internal pure returns (uint248 _output) {&#13;
        &#13;
        assembly {&#13;
            _output := mload(add(_input, _offst))&#13;
        }&#13;
    } &#13;
&#13;
    function bytesToUint256(uint _offst, bytes memory _input) internal pure returns (uint256 _output) {&#13;
        &#13;
        assembly {&#13;
            _output := mload(add(_input, _offst))&#13;
        }&#13;
    } &#13;
    &#13;
}&#13;
&#13;
&#13;
interface ITradeable {&#13;
    &#13;
    /// @param _owner The address from which the balance will be retrieved&#13;
    /// @return The balance&#13;
    function balanceOf(address _owner) external view returns (uint balance);&#13;
    &#13;
    /// @notice send `_value` token to `_to` from `msg.sender`&#13;
    /// @param _to The address of the recipient&#13;
    /// @param _value The amount of token to be transferred&#13;
    /// @return Whether the transfer was successful or not&#13;
    function transfer(address _to, uint _value) external returns (bool success);&#13;
&#13;
    /// @param _from The address of the sender&#13;
    /// @param _to The address of the recipient&#13;
    /// @param _value The amount of token to be transferred&#13;
    /// @return Whether the transfer was successful or not&#13;
    function transferFrom(address _from, address _to, uint _value) external returns (bool success);&#13;
&#13;
    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens&#13;
    /// @param _spender The address of the account able to transfer the tokens&#13;
    /// @param _value The amount of wei to be approved for transfer&#13;
    /// @return Whether the approval was successful or not&#13;
    function approve(address _spender, uint _value) external returns (bool success);&#13;
    &#13;
    /// @param _owner The address of the account owning tokens&#13;
    /// @param _spender The address of the account able to transfer the tokens&#13;
    /// @return Amount of remaining tokens allowed to spent&#13;
    function allowance(address _owner, address _spender) external view returns (uint remaining);&#13;
}&#13;
&#13;
&#13;
&#13;
contract ITrader {&#13;
&#13;
  function getDataLength(&#13;
  ) public pure returns (uint256);&#13;
&#13;
  function getProtocol(&#13;
  ) public pure returns (uint8);&#13;
&#13;
  function getAvailableVolume(&#13;
    bytes orderData&#13;
  ) public view returns(uint);&#13;
&#13;
  function isExpired(&#13;
    bytes orderData&#13;
  ) public view returns (bool); &#13;
&#13;
  function trade(&#13;
    bool isSell,&#13;
    bytes orderData,&#13;
    uint volume,&#13;
    uint volumeEth&#13;
  ) public;&#13;
  &#13;
  function getFillVolumes(&#13;
    bool isSell,&#13;
    bytes orderData,&#13;
    uint volume,&#13;
    uint volumeEth&#13;
  ) public view returns(uint, uint);&#13;
&#13;
}&#13;
&#13;
contract ITraders {&#13;
&#13;
  /// @dev Add a valid trader address. Only owner.&#13;
  function addTrader(uint8 id, ITrader trader) public;&#13;
&#13;
  /// @dev Remove a trader address. Only owner.&#13;
  function removeTrader(uint8 id) public;&#13;
&#13;
  /// @dev Get trader by id.&#13;
  function getTrader(uint8 id) public view returns(ITrader);&#13;
&#13;
  /// @dev Check if an address is a valid trader.&#13;
  function isValidTraderAddress(address addr) public view returns(bool);&#13;
&#13;
}&#13;
&#13;
contract Members is Ownable {&#13;
&#13;
  mapping(address =&gt; bool) public members; // Mappings of addresses of allowed addresses&#13;
&#13;
  modifier onlyMembers() {&#13;
    require(isValidMember(msg.sender));&#13;
    _;&#13;
  }&#13;
&#13;
  /// @dev Check if an address is a valid member.&#13;
  function isValidMember(address _member) public view returns(bool) {&#13;
    return members[_member];&#13;
  }&#13;
&#13;
  /// @dev Add a valid member address. Only owner.&#13;
  function addMember(address _member) public onlyOwner {&#13;
    members[_member] = true;&#13;
  }&#13;
&#13;
  /// @dev Remove a member address. Only owner.&#13;
  function removeMember(address _member) public onlyOwner {&#13;
    delete members[_member];&#13;
  }&#13;
}&#13;
&#13;
&#13;
contract IFeeWallet {&#13;
&#13;
  function getFee(&#13;
    uint amount) public view returns(uint);&#13;
&#13;
  function collect(&#13;
    address _affiliate) public payable;&#13;
}&#13;
&#13;
&#13;
contract FeeWallet is IFeeWallet, Ownable, Members {&#13;
&#13;
  address public serviceAccount; // Address of service account&#13;
  uint public servicePercentage; // Percentage times (1 ether)&#13;
  uint public affiliatePercentage; // Percentage times (1 ether)&#13;
&#13;
  mapping (address =&gt; uint) public pendingWithdrawals; // Balances&#13;
&#13;
  constructor(&#13;
    address _serviceAccount,&#13;
    uint _servicePercentage,&#13;
    uint _affiliatePercentage) public&#13;
  {&#13;
    serviceAccount = _serviceAccount;&#13;
    servicePercentage = _servicePercentage;&#13;
    affiliatePercentage = _affiliatePercentage;&#13;
  }&#13;
&#13;
  /// @dev Set the new service account. Only owner.&#13;
  function changeServiceAccount(address _serviceAccount) public onlyOwner {&#13;
    serviceAccount = _serviceAccount;&#13;
  }&#13;
&#13;
  /// @dev Set the service percentage. Only owner.&#13;
  function changeServicePercentage(uint _servicePercentage) public onlyOwner {&#13;
    servicePercentage = _servicePercentage;&#13;
  }&#13;
&#13;
  /// @dev Set the affiliate percentage. Only owner.&#13;
  function changeAffiliatePercentage(uint _affiliatePercentage) public onlyOwner {&#13;
    affiliatePercentage = _affiliatePercentage;&#13;
  }&#13;
&#13;
  /// @dev Calculates the service fee for a specific amount. Only owner.&#13;
  function getFee(uint amount) public view returns(uint)  {&#13;
    return SafeMath.safeMul(amount, servicePercentage) / (1 ether);&#13;
  }&#13;
&#13;
  /// @dev Calculates the affiliate amount for a specific amount. Only owner.&#13;
  function getAffiliateAmount(uint amount) public view returns(uint)  {&#13;
    return SafeMath.safeMul(amount, affiliatePercentage) / (1 ether);&#13;
  }&#13;
&#13;
  /// @dev Collects fees according to last payment receivedi. Only valid smart contracts.&#13;
  function collect(&#13;
    address _affiliate) public payable onlyMembers&#13;
  {&#13;
    if(_affiliate == address(0))&#13;
      pendingWithdrawals[serviceAccount] += msg.value;&#13;
    else {&#13;
      uint affiliateAmount = getAffiliateAmount(msg.value);&#13;
      pendingWithdrawals[_affiliate] += affiliateAmount;&#13;
      pendingWithdrawals[serviceAccount] += SafeMath.safeSub(msg.value, affiliateAmount);&#13;
    }&#13;
  }&#13;
&#13;
  /// @dev Withdraw.&#13;
  function withdraw() public {&#13;
    uint amount = pendingWithdrawals[msg.sender];&#13;
    pendingWithdrawals[msg.sender] = 0;&#13;
    msg.sender.transfer(amount);&#13;
  }&#13;
}&#13;
contract ZodiacERC20 is Ownable, BytesToTypes {&#13;
  string constant public VERSION = '2.0.0';&#13;
&#13;
  ITraders public traders; // Smart contract that hold the list of valid traders&#13;
  IFeeWallet public feeWallet; // Smart contract that hold the fees collected&#13;
  bool public tradingEnabled; // Switch to enable or disable the contract&#13;
&#13;
  event Sell(&#13;
    address account,&#13;
    address destinationAddr,&#13;
    address traedeable,&#13;
    uint volume,&#13;
    uint volumeEth,&#13;
    uint volumeEffective,&#13;
    uint volumeEthEffective&#13;
  );&#13;
  event Buy(&#13;
    address account,&#13;
    address destinationAddr,&#13;
    address traedeable,&#13;
    uint volume,&#13;
    uint volumeEth,&#13;
    uint volumeEffective,&#13;
    uint volumeEthEffective&#13;
  );&#13;
&#13;
&#13;
  constructor(ITraders _traders, IFeeWallet _feeWallet) public {&#13;
    traders = _traders;&#13;
    feeWallet = _feeWallet;&#13;
    tradingEnabled = true;&#13;
  }&#13;
&#13;
  /// @dev Only accepts payment from smart contract traders.&#13;
  function() public payable {&#13;
  //  require(traders.isValidTraderAddress(msg.sender));&#13;
  }&#13;
&#13;
  /// @dev Setter for feeWallet smart contract (Only owner)&#13;
  function changeFeeWallet(IFeeWallet _feeWallet) public onlyOwner {&#13;
    feeWallet = _feeWallet;&#13;
  }&#13;
&#13;
  /// @dev Setter for traders smart contract (Only owner)&#13;
  function changeTraders(ITraders _traders) public onlyOwner {&#13;
    traders = _traders;&#13;
  }&#13;
&#13;
  /// @dev Enable/Disable trading with smart contract (Only owner)&#13;
  function changeTradingEnabled(bool enabled) public onlyOwner {&#13;
    tradingEnabled = enabled;&#13;
  }&#13;
&#13;
  /// @dev Buy a token.&#13;
  function buy(&#13;
    ITradeable tradeable,&#13;
    uint volume,&#13;
    bytes ordersData,&#13;
    address destinationAddr,&#13;
    address affiliate&#13;
  ) external payable&#13;
  {&#13;
&#13;
    require(tradingEnabled);&#13;
&#13;
    // Execute the trade (at most fullfilling volume)&#13;
    trade(&#13;
      false,&#13;
      tradeable,&#13;
      volume,&#13;
      ordersData,&#13;
      affiliate&#13;
    );&#13;
&#13;
    // Since our balance before trade was 0. What we bought is our current balance.&#13;
    uint volumeEffective = tradeable.balanceOf(this);&#13;
&#13;
    // We make sure that something was traded&#13;
    require(volumeEffective &gt; 0);&#13;
&#13;
    // Used ethers are: balance_before - balance_after.&#13;
    // And since before call balance=0; then balance_before = msg.value&#13;
    uint volumeEthEffective = SafeMath.safeSub(msg.value, address(this).balance);&#13;
&#13;
    // IMPORTANT: Check that: effective_price &lt;= agreed_price (guarantee a good deal for the buyer)&#13;
    require(&#13;
      SafeMath.safeDiv(volumeEthEffective, volumeEffective) &lt;=&#13;
      SafeMath.safeDiv(msg.value, volume)&#13;
    );&#13;
&#13;
    // Return remaining ethers&#13;
    if(address(this).balance &gt; 0) {&#13;
      destinationAddr.transfer(address(this).balance);&#13;
    }&#13;
&#13;
    // Send the tokens&#13;
    transferTradeable(tradeable, destinationAddr, volumeEffective);&#13;
&#13;
    emit Buy(msg.sender, destinationAddr, tradeable, volume, msg.value, volumeEffective, volumeEthEffective);&#13;
  }&#13;
&#13;
  /// @dev sell a token.&#13;
  function sell(&#13;
    ITradeable tradeable,&#13;
    uint volume,&#13;
    uint volumeEth,&#13;
    bytes ordersData,&#13;
    address destinationAddr,&#13;
    address affiliate&#13;
  ) external&#13;
  {&#13;
    require(tradingEnabled);&#13;
&#13;
    // We transfer to ouselves the user's trading volume, to operate on it&#13;
    // note: Our balance is 0 before this&#13;
    require(tradeable.transferFrom(msg.sender, this, volume));&#13;
&#13;
    // Execute the trade (at most fullfilling volume)&#13;
    trade(&#13;
      true,&#13;
      tradeable,&#13;
      volume,&#13;
      ordersData,&#13;
      affiliate&#13;
    );&#13;
&#13;
    // Check how much we traded. Our balance = volume - tradedVolume&#13;
    // then: tradedVolume = volume - balance&#13;
    uint volumeEffective = SafeMath.safeSub(volume, tradeable.balanceOf(this));&#13;
&#13;
    // We make sure that something was traded&#13;
    require(volumeEffective &gt; 0);&#13;
&#13;
    // Collects service fee&#13;
    uint volumeEthEffective = collectSellFee(affiliate);&#13;
&#13;
    // IMPORTANT: Check that: effective_price &gt;= agreed_price (guarantee a good deal for the seller)&#13;
    require(&#13;
      SafeMath.safeDiv(volumeEthEffective, volumeEffective) &gt;=&#13;
      SafeMath.safeDiv(volumeEth, volume)&#13;
    );&#13;
&#13;
    // Return remaining volume&#13;
    if (volumeEffective &lt; volume) {&#13;
     transferTradeable(tradeable, destinationAddr, SafeMath.safeSub(volume, volumeEffective));&#13;
    }&#13;
&#13;
    // Send ethers obtained&#13;
    destinationAddr.transfer(volumeEthEffective);&#13;
&#13;
    emit Sell(msg.sender, destinationAddr, tradeable, volume, volumeEth, volumeEffective, volumeEthEffective);&#13;
  }&#13;
&#13;
&#13;
  /// @dev Trade buy or sell orders.&#13;
  function trade(&#13;
    bool isSell,&#13;
    ITradeable tradeable,&#13;
    uint volume,&#13;
    bytes ordersData,&#13;
    address affiliate&#13;
  ) internal&#13;
  {&#13;
    uint remainingVolume = volume;&#13;
    uint offset = ordersData.length;&#13;
&#13;
    while(offset &gt; 0 &amp;&amp; remainingVolume &gt; 0) {&#13;
      //Get the trader&#13;
      uint8 protocolId = bytesToUint8(offset, ordersData);&#13;
      ITrader trader = traders.getTrader(protocolId);&#13;
      require(trader != address(0));&#13;
&#13;
      //Get the order data&#13;
      uint dataLength = trader.getDataLength();&#13;
      offset = SafeMath.safeSub(offset, dataLength);&#13;
      bytes memory orderData = slice(ordersData, offset, dataLength);&#13;
&#13;
      //Fill order&#13;
      remainingVolume = fillOrder(&#13;
         isSell,&#13;
         tradeable,&#13;
         trader,&#13;
         remainingVolume,&#13;
         orderData,&#13;
         affiliate&#13;
      );&#13;
    }&#13;
  }&#13;
&#13;
  /// @dev Fills a buy order.&#13;
  function fillOrder(&#13;
    bool isSell,&#13;
    ITradeable tradeable,&#13;
    ITrader trader,&#13;
    uint remaining,&#13;
    bytes memory orderData,&#13;
    address affiliate&#13;
    ) internal returns(uint)&#13;
  {&#13;
&#13;
    //Checks that there is enoughh amount to execute the trade&#13;
    uint volume;&#13;
    uint volumeEth;&#13;
    (volume, volumeEth) = trader.getFillVolumes(&#13;
      isSell,&#13;
      orderData,&#13;
      remaining,&#13;
      address(this).balance&#13;
    );&#13;
&#13;
    if(volume &gt; 0) {&#13;
&#13;
      if(isSell) {&#13;
        //Approve available amount of token to trader&#13;
        require(tradeable.approve(trader, volume));&#13;
      } else {&#13;
        //Collects service fee&#13;
        //TODO: transfer fees after all iteration&#13;
        volumeEth = collectBuyFee(volumeEth, affiliate);&#13;
        address(trader).transfer(volumeEth);&#13;
      }&#13;
&#13;
      //Call trader to trade orders&#13;
      trader.trade(&#13;
        isSell,&#13;
        orderData,&#13;
        volume,&#13;
        volumeEth&#13;
      );&#13;
&#13;
    }&#13;
&#13;
    return SafeMath.safeSub(remaining, volume);&#13;
  }&#13;
&#13;
  /// @dev Transfer tradeables to user account.&#13;
  function transferTradeable(ITradeable tradeable, address account, uint amount) internal {&#13;
    require(tradeable.transfer(account, amount));&#13;
  }&#13;
&#13;
  // @dev Collect service/affiliate fee for a buy&#13;
  function collectBuyFee(uint ethers, address affiliate) internal returns(uint) {&#13;
    uint remaining;&#13;
    uint fee = feeWallet.getFee(ethers);&#13;
    //If there is enough remaining to pay fee, it substract from the balance&#13;
    if(SafeMath.safeSub(address(this).balance, ethers) &gt;= fee)&#13;
      remaining = ethers;&#13;
    else&#13;
      remaining = SafeMath.safeSub(SafeMath.safeSub(ethers, address(this).balance), fee);&#13;
    feeWallet.collect.value(fee)(affiliate);&#13;
    return remaining;&#13;
  }&#13;
&#13;
  // @dev Collect service/affiliate fee for a sell&#13;
  function collectSellFee(address affiliate) internal returns(uint) {&#13;
    uint fee = feeWallet.getFee(address(this).balance);&#13;
    feeWallet.collect.value(fee)(affiliate);&#13;
    return address(this).balance;&#13;
  }&#13;
&#13;
}