// File: contracts/GodMode.sol

/****************************************************
 *
 * Copyright 2018 BurzNest LLC. All rights reserved.
 *
 * The contents of this file are provided for review
 * and educational purposes ONLY. You MAY NOT use,
 * copy, distribute, or modify this software without
 * explicit written permission from BurzNest LLC.
 *
 ****************************************************/

pragma solidity ^0.4.24;

/// @title God Mode
/// @author Anthony Burzillo <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="036176717943617671796d6670772d606c6e">[email protected]</a>&gt;&#13;
/// @dev This contract provides a basic interface for God&#13;
///  in a contract as well as the ability for God to pause&#13;
///  the contract&#13;
contract GodMode {&#13;
    /// @dev Is the contract paused?&#13;
    bool public isPaused;&#13;
&#13;
    /// @dev God's address&#13;
    address public god;&#13;
&#13;
    /// @dev Only God can run this function&#13;
    modifier onlyGod()&#13;
    {&#13;
        require(god == msg.sender);&#13;
        _;&#13;
    }&#13;
&#13;
    /// @dev This function can only be run while the contract&#13;
    ///  is not paused&#13;
    modifier notPaused()&#13;
    {&#13;
        require(!isPaused);&#13;
        _;&#13;
    }&#13;
&#13;
    /// @dev This event is fired when the contract is paused&#13;
    event GodPaused();&#13;
&#13;
    /// @dev This event is fired when the contract is unpaused&#13;
    event GodUnpaused();&#13;
&#13;
    constructor() public&#13;
    {&#13;
        // Make the creator of the contract God&#13;
        god = msg.sender;&#13;
    }&#13;
&#13;
    /// @dev God can change the address of God&#13;
    /// @param _newGod The new address for God&#13;
    function godChangeGod(address _newGod) public onlyGod&#13;
    {&#13;
        god = _newGod;&#13;
    }&#13;
&#13;
    /// @dev God can pause the game&#13;
    function godPause() public onlyGod&#13;
    {&#13;
        isPaused = true;&#13;
&#13;
        emit GodPaused();&#13;
    }&#13;
&#13;
    /// @dev God can unpause the game&#13;
    function godUnpause() public onlyGod&#13;
    {&#13;
        isPaused = false;&#13;
&#13;
        emit GodUnpaused();&#13;
    }&#13;
}&#13;
&#13;
// File: contracts/KingOfEthAuctionsAbstractInterface.sol&#13;
&#13;
/****************************************************&#13;
 *&#13;
 * Copyright 2018 BurzNest LLC. All rights reserved.&#13;
 *&#13;
 * The contents of this file are provided for review&#13;
 * and educational purposes ONLY. You MAY NOT use,&#13;
 * copy, distribute, or modify this software without&#13;
 * explicit written permission from BurzNest LLC.&#13;
 *&#13;
 ****************************************************/&#13;
&#13;
pragma solidity ^0.4.24;&#13;
&#13;
/// @title King of Eth: Auctions Abstract Interface&#13;
/// @author Anthony Burzillo &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="88eafdfaf2c8eafdfaf2e6edfbfca6ebe7e5">[email protected]</a>&gt;&#13;
/// @dev Abstract interface contract for auctions of houses&#13;
contract KingOfEthAuctionsAbstractInterface {&#13;
    /// @dev Determines if there is an auction at a particular location&#13;
    /// @param _x The x coordinate of the auction&#13;
    /// @param _y The y coordinate of the auction&#13;
    /// @return true if there is an existing auction&#13;
    function existingAuction(uint _x, uint _y) public view returns(bool);&#13;
}&#13;
&#13;
// File: contracts/KingOfEthBlindAuctionsReferencer.sol&#13;
&#13;
/****************************************************&#13;
 *&#13;
 * Copyright 2018 BurzNest LLC. All rights reserved.&#13;
 *&#13;
 * The contents of this file are provided for review&#13;
 * and educational purposes ONLY. You MAY NOT use,&#13;
 * copy, distribute, or modify this software without&#13;
 * explicit written permission from BurzNest LLC.&#13;
 *&#13;
 ****************************************************/&#13;
&#13;
pragma solidity ^0.4.24;&#13;
&#13;
&#13;
/// @title King of Eth: Blind Auctions Referencer&#13;
/// @author Anthony Burzillo &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="d4b6a1a6ae94b6a1a6aebab1a7a0fab7bbb9">[email protected]</a>&gt;&#13;
/// @dev This contract provides a reference to the blind auctions contract&#13;
contract KingOfEthBlindAuctionsReferencer is GodMode {&#13;
    /// @dev The address of the blind auctions contract&#13;
    address public blindAuctionsContract;&#13;
&#13;
    /// @dev Only the blind auctions contract can run this&#13;
    modifier onlyBlindAuctionsContract()&#13;
    {&#13;
        require(blindAuctionsContract == msg.sender);&#13;
        _;&#13;
    }&#13;
&#13;
    /// @dev God can set a new blind auctions contract&#13;
    /// @param _blindAuctionsContract the address of the blind auctions&#13;
    ///  contract&#13;
    function godSetBlindAuctionsContract(address _blindAuctionsContract)&#13;
        public&#13;
        onlyGod&#13;
    {&#13;
        blindAuctionsContract = _blindAuctionsContract;&#13;
    }&#13;
}&#13;
&#13;
// File: contracts/KingOfEthOpenAuctionsReferencer.sol&#13;
&#13;
/****************************************************&#13;
 *&#13;
 * Copyright 2018 BurzNest LLC. All rights reserved.&#13;
 *&#13;
 * The contents of this file are provided for review&#13;
 * and educational purposes ONLY. You MAY NOT use,&#13;
 * copy, distribute, or modify this software without&#13;
 * explicit written permission from BurzNest LLC.&#13;
 *&#13;
 ****************************************************/&#13;
&#13;
pragma solidity ^0.4.24;&#13;
&#13;
&#13;
/// @title King of Eth: Open Auctions Referencer&#13;
/// @author Anthony Burzillo &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="f59780878fb59780878f9b908681db969a98">[email protected]</a>&gt;&#13;
/// @dev This contract provides a reference to the open auctions contract&#13;
contract KingOfEthOpenAuctionsReferencer is GodMode {&#13;
    /// @dev The address of the auctions contract&#13;
    address public openAuctionsContract;&#13;
&#13;
    /// @dev Only the open auctions contract can run this&#13;
    modifier onlyOpenAuctionsContract()&#13;
    {&#13;
        require(openAuctionsContract == msg.sender);&#13;
        _;&#13;
    }&#13;
&#13;
    /// @dev God can set a new auctions contract&#13;
    function godSetOpenAuctionsContract(address _openAuctionsContract)&#13;
        public&#13;
        onlyGod&#13;
    {&#13;
        openAuctionsContract = _openAuctionsContract;&#13;
    }&#13;
}&#13;
&#13;
// File: contracts/KingOfEthAuctionsReferencer.sol&#13;
&#13;
/****************************************************&#13;
 *&#13;
 * Copyright 2018 BurzNest LLC. All rights reserved.&#13;
 *&#13;
 * The contents of this file are provided for review&#13;
 * and educational purposes ONLY. You MAY NOT use,&#13;
 * copy, distribute, or modify this software without&#13;
 * explicit written permission from BurzNest LLC.&#13;
 *&#13;
 ****************************************************/&#13;
&#13;
pragma solidity ^0.4.24;&#13;
&#13;
&#13;
&#13;
/// @title King of Eth: Auctions Referencer&#13;
/// @author Anthony Burzillo &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="afcddaddd5efcddaddd5c1cadcdb81ccc0c2">[email protected]</a>&gt;&#13;
/// @dev This contract provides a reference to the auctions contracts&#13;
contract KingOfEthAuctionsReferencer is&#13;
      KingOfEthBlindAuctionsReferencer&#13;
    , KingOfEthOpenAuctionsReferencer&#13;
{&#13;
    /// @dev Only an auctions contract can run this&#13;
    modifier onlyAuctionsContract()&#13;
    {&#13;
        require(blindAuctionsContract == msg.sender&#13;
             || openAuctionsContract == msg.sender);&#13;
        _;&#13;
    }&#13;
}&#13;
&#13;
// File: contracts/KingOfEthAbstractInterface.sol&#13;
&#13;
/****************************************************&#13;
 *&#13;
 * Copyright 2018 BurzNest LLC. All rights reserved.&#13;
 *&#13;
 * The contents of this file are provided for review&#13;
 * and educational purposes ONLY. You MAY NOT use,&#13;
 * copy, distribute, or modify this software without&#13;
 * explicit written permission from BurzNest LLC.&#13;
 *&#13;
 ****************************************************/&#13;
&#13;
pragma solidity ^0.4.24;&#13;
&#13;
/// @title King of Eth Abstract Interface&#13;
/// @author Anthony Burzillo &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="6d0f181f172d0f181f1703081e19430e0200">[email protected]</a>&gt;&#13;
/// @dev Abstract interface contract for titles and taxes&#13;
contract KingOfEthAbstractInterface {&#13;
    /// @dev The address of the current King&#13;
    address public king;&#13;
&#13;
    /// @dev The address of the current Wayfarer&#13;
    address public wayfarer;&#13;
&#13;
    /// @dev Anyone can pay taxes&#13;
    function payTaxes() public payable;&#13;
}&#13;
&#13;
// File: contracts/KingOfEthReferencer.sol&#13;
&#13;
/****************************************************&#13;
 *&#13;
 * Copyright 2018 BurzNest LLC. All rights reserved.&#13;
 *&#13;
 * The contents of this file are provided for review&#13;
 * and educational purposes ONLY. You MAY NOT use,&#13;
 * copy, distribute, or modify this software without&#13;
 * explicit written permission from BurzNest LLC.&#13;
 *&#13;
 ****************************************************/&#13;
&#13;
pragma solidity ^0.4.24;&#13;
&#13;
&#13;
/// @title King of Eth Referencer&#13;
/// @author Anthony Burzillo &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="e88a9d9a92a88a9d9a92868d9b9cc68b8785">[email protected]</a>&gt;&#13;
/// @dev Functionality to allow contracts to reference the king contract&#13;
contract KingOfEthReferencer is GodMode {&#13;
    /// @dev The address of the king contract&#13;
    address public kingOfEthContract;&#13;
&#13;
    /// @dev Only the king contract can run this&#13;
    modifier onlyKingOfEthContract()&#13;
    {&#13;
        require(kingOfEthContract == msg.sender);&#13;
        _;&#13;
    }&#13;
&#13;
    /// @dev God can change the king contract&#13;
    /// @param _kingOfEthContract The new address&#13;
    function godSetKingOfEthContract(address _kingOfEthContract)&#13;
        public&#13;
        onlyGod&#13;
    {&#13;
        kingOfEthContract = _kingOfEthContract;&#13;
    }&#13;
}&#13;
&#13;
// File: contracts/KingOfEthBoard.sol&#13;
&#13;
/****************************************************&#13;
 *&#13;
 * Copyright 2018 BurzNest LLC. All rights reserved.&#13;
 *&#13;
 * The contents of this file are provided for review&#13;
 * and educational purposes ONLY. You MAY NOT use,&#13;
 * copy, distribute, or modify this software without&#13;
 * explicit written permission from BurzNest LLC.&#13;
 *&#13;
 ****************************************************/&#13;
&#13;
pragma solidity ^0.4.24;&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
/// @title King of Eth: Board&#13;
/// @author Anthony Burzillo &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="630116111923011611190d0610174d000c0e">[email protected]</a>&gt;&#13;
/// @dev Contract for board&#13;
contract KingOfEthBoard is&#13;
      GodMode&#13;
    , KingOfEthAuctionsReferencer&#13;
    , KingOfEthReferencer&#13;
{&#13;
    /// @dev x coordinate of the top left corner of the boundary&#13;
    uint public boundX1 = 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffef;&#13;
&#13;
    /// @dev y coordinate of the top left corner of the boundary&#13;
    uint public boundY1 = 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffef;&#13;
&#13;
    /// @dev x coordinate of the bottom right corner of the boundary&#13;
    uint public boundX2 = 0x800000000000000000000000000000000000000000000000000000000000000f;&#13;
&#13;
    /// @dev y coordinate of the bottom right corner of the boundary&#13;
    uint public boundY2 = 0x800000000000000000000000000000000000000000000000000000000000000f;&#13;
&#13;
    /// @dev Number used to divide the total number of house locations&#13;
    /// after any expansion to yield the number of auctions that  will be&#13;
    /// available to start for the expansion's duration&#13;
    uint public constant auctionsAvailableDivisor = 10;&#13;
&#13;
    /// @dev Amount of time the King must wait between increasing the board&#13;
    uint public constant kingTimeBetweenIncrease = 2 weeks;&#13;
&#13;
    /// @dev Amount of time the Wayfarer must wait between increasing the board&#13;
    uint public constant wayfarerTimeBetweenIncrease = 3 weeks;&#13;
&#13;
    /// @dev Amount of time that anyone but the King or Wayfarer must wait&#13;
    ///  before increasing the board&#13;
    uint public constant plebTimeBetweenIncrease = 4 weeks;&#13;
&#13;
    /// @dev The last time the board was increased in size&#13;
    uint public lastIncreaseTime;&#13;
&#13;
    /// @dev The direction of the next increase&#13;
    uint8 public nextIncreaseDirection;&#13;
&#13;
    /// @dev The number of auctions that players may choose to start&#13;
    ///  for this expansion&#13;
    uint public auctionsRemaining;&#13;
&#13;
    constructor() public&#13;
    {&#13;
        // Game is paused as God must start it&#13;
        isPaused = true;&#13;
&#13;
        // Set the auctions remaining&#13;
        setAuctionsAvailableForBounds();&#13;
    }&#13;
&#13;
    /// @dev Fired when the board is increased in size&#13;
    event BoardSizeIncreased(&#13;
          address initiator&#13;
        , uint newBoundX1&#13;
        , uint newBoundY1&#13;
        , uint newBoundX2&#13;
        , uint newBoundY2&#13;
        , uint lastIncreaseTime&#13;
        , uint nextIncreaseDirection&#13;
        , uint auctionsRemaining&#13;
    );&#13;
&#13;
    /// @dev Only the King can run this&#13;
    modifier onlyKing()&#13;
    {&#13;
        require(KingOfEthAbstractInterface(kingOfEthContract).king() == msg.sender);&#13;
        _;&#13;
    }&#13;
&#13;
    /// @dev Only the Wayfarer can run this&#13;
    modifier onlyWayfarer()&#13;
    {&#13;
        require(KingOfEthAbstractInterface(kingOfEthContract).wayfarer() == msg.sender);&#13;
        _;&#13;
    }&#13;
&#13;
    /// @dev Set the total auctions available&#13;
    function setAuctionsAvailableForBounds() private&#13;
    {&#13;
        uint boundDiffX = boundX2 - boundX1;&#13;
        uint boundDiffY = boundY2 - boundY1;&#13;
&#13;
        auctionsRemaining = boundDiffX * boundDiffY / 2 / auctionsAvailableDivisor;&#13;
    }&#13;
&#13;
    /// @dev Increase the board's size making sure to keep steady at&#13;
    ///  the maximum outer bounds&#13;
    function increaseBoard() private&#13;
    {&#13;
        // The length of increase&#13;
        uint _increaseLength;&#13;
&#13;
        // If this increase direction is right&#13;
        if(0 == nextIncreaseDirection)&#13;
        {&#13;
            _increaseLength = boundX2 - boundX1;&#13;
            uint _updatedX2 = boundX2 + _increaseLength;&#13;
&#13;
            // Stay within bounds&#13;
            if(_updatedX2 &lt;= boundX2 || _updatedX2 &lt;= _increaseLength)&#13;
            {&#13;
                boundX2 = ~uint(0);&#13;
            }&#13;
            else&#13;
            {&#13;
                boundX2 = _updatedX2;&#13;
            }&#13;
        }&#13;
        // If this increase direction is down&#13;
        else if(1 == nextIncreaseDirection)&#13;
        {&#13;
            _increaseLength = boundY2 - boundY1;&#13;
            uint _updatedY2 = boundY2 + _increaseLength;&#13;
&#13;
            // Stay within bounds&#13;
            if(_updatedY2 &lt;= boundY2 || _updatedY2 &lt;= _increaseLength)&#13;
            {&#13;
                boundY2 = ~uint(0);&#13;
            }&#13;
            else&#13;
            {&#13;
                boundY2 = _updatedY2;&#13;
            }&#13;
        }&#13;
        // If this increase direction is left&#13;
        else if(2 == nextIncreaseDirection)&#13;
        {&#13;
            _increaseLength = boundX2 - boundX1;&#13;
&#13;
            // Stay within bounds&#13;
            if(boundX1 &lt;= _increaseLength)&#13;
            {&#13;
                boundX1 = 0;&#13;
            }&#13;
            else&#13;
            {&#13;
                boundX1 -= _increaseLength;&#13;
            }&#13;
        }&#13;
        // If this increase direction is up&#13;
        else if(3 == nextIncreaseDirection)&#13;
        {&#13;
            _increaseLength = boundY2 - boundY1;&#13;
&#13;
            // Stay within bounds&#13;
            if(boundY1 &lt;= _increaseLength)&#13;
            {&#13;
                boundY1 = 0;&#13;
            }&#13;
            else&#13;
            {&#13;
                boundY1 -= _increaseLength;&#13;
            }&#13;
        }&#13;
&#13;
        // The last increase time is now&#13;
        lastIncreaseTime = now;&#13;
&#13;
        // Set the next increase direction&#13;
        nextIncreaseDirection = (nextIncreaseDirection + 1) % 4;&#13;
&#13;
        // Reset the auctions available&#13;
        setAuctionsAvailableForBounds();&#13;
&#13;
        emit BoardSizeIncreased(&#13;
              msg.sender&#13;
            , boundX1&#13;
            , boundY1&#13;
            , boundX2&#13;
            , boundY2&#13;
            , now&#13;
            , nextIncreaseDirection&#13;
            , auctionsRemaining&#13;
        );&#13;
    }&#13;
&#13;
    /// @dev God can start the game&#13;
    function godStartGame() public onlyGod&#13;
    {&#13;
        // Reset increase times&#13;
        lastIncreaseTime = now;&#13;
&#13;
        // Unpause the game&#13;
        godUnpause();&#13;
    }&#13;
&#13;
    /// @dev The auctions contracts can decrement the number&#13;
    ///  of auctions that are available to be started&#13;
    function auctionsDecrementAuctionsRemaining()&#13;
        public&#13;
        onlyAuctionsContract&#13;
    {&#13;
        auctionsRemaining -= 1;&#13;
    }&#13;
&#13;
    /// @dev The auctions contracts can increment the number&#13;
    ///  of auctions that are available to be started when&#13;
    ///  an auction ends wihout a winner&#13;
    function auctionsIncrementAuctionsRemaining()&#13;
        public&#13;
        onlyAuctionsContract&#13;
    {&#13;
        auctionsRemaining += 1;&#13;
    }&#13;
&#13;
    /// @dev The King can increase the board much faster than the plebs&#13;
    function kingIncreaseBoard()&#13;
        public&#13;
        onlyKing&#13;
    {&#13;
        // Require enough time has passed since the last increase&#13;
        require(lastIncreaseTime + kingTimeBetweenIncrease &lt; now);&#13;
&#13;
        increaseBoard();&#13;
    }&#13;
&#13;
    /// @dev The Wayfarer can increase the board faster than the plebs&#13;
    function wayfarerIncreaseBoard()&#13;
        public&#13;
        onlyWayfarer&#13;
    {&#13;
        // Require enough time has passed since the last increase&#13;
        require(lastIncreaseTime + wayfarerTimeBetweenIncrease &lt; now);&#13;
&#13;
        increaseBoard();&#13;
    }&#13;
&#13;
    /// @dev Any old pleb can increase the board&#13;
    function plebIncreaseBoard() public&#13;
    {&#13;
        // Require enough time has passed since the last increase&#13;
        require(lastIncreaseTime + plebTimeBetweenIncrease &lt; now);&#13;
&#13;
        increaseBoard();&#13;
    }&#13;
}&#13;
&#13;
// File: contracts/KingOfEthBoardReferencer.sol&#13;
&#13;
/****************************************************&#13;
 *&#13;
 * Copyright 2018 BurzNest LLC. All rights reserved.&#13;
 *&#13;
 * The contents of this file are provided for review&#13;
 * and educational purposes ONLY. You MAY NOT use,&#13;
 * copy, distribute, or modify this software without&#13;
 * explicit written permission from BurzNest LLC.&#13;
 *&#13;
 ****************************************************/&#13;
&#13;
pragma solidity ^0.4.24;&#13;
&#13;
&#13;
/// @title King of Eth: Board Referencer&#13;
/// @author Anthony Burzillo &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="d2b0a7a0a892b0a7a0a8bcb7a1a6fcb1bdbf">[email protected]</a>&gt;&#13;
/// @dev Functionality to allow contracts to reference the board contract&#13;
contract KingOfEthBoardReferencer is GodMode {&#13;
    /// @dev The address of the board contract&#13;
    address public boardContract;&#13;
&#13;
    /// @dev Only the board contract can run this&#13;
    modifier onlyBoardContract()&#13;
    {&#13;
        require(boardContract == msg.sender);&#13;
        _;&#13;
    }&#13;
&#13;
    /// @dev God can change the board contract&#13;
    /// @param _boardContract The new address&#13;
    function godSetBoardContract(address _boardContract)&#13;
        public&#13;
        onlyGod&#13;
    {&#13;
        boardContract = _boardContract;&#13;
    }&#13;
}&#13;
&#13;
// File: contracts/KingOfEthHousesAbstractInterface.sol&#13;
&#13;
/****************************************************&#13;
 *&#13;
 * Copyright 2018 BurzNest LLC. All rights reserved.&#13;
 *&#13;
 * The contents of this file are provided for review&#13;
 * and educational purposes ONLY. You MAY NOT use,&#13;
 * copy, distribute, or modify this software without&#13;
 * explicit written permission from BurzNest LLC.&#13;
 *&#13;
 ****************************************************/&#13;
&#13;
pragma solidity ^0.4.24;&#13;
&#13;
/// @title King of Eth: Houses Abstract Interface&#13;
/// @author Anthony Burzillo &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="432136313903213631392d2630376d202c2e">[email protected]</a>&gt;&#13;
/// @dev Abstract interface contract for houses&#13;
contract KingOfEthHousesAbstractInterface {&#13;
    /// @dev Get the owner of the house at some location&#13;
    /// @param _x The x coordinate of the house&#13;
    /// @param _y The y coordinate of the house&#13;
    /// @return The address of the owner&#13;
    function ownerOf(uint _x, uint _y) public view returns(address);&#13;
&#13;
    /// @dev Get the level of the house at some location&#13;
    /// @param _x The x coordinate of the house&#13;
    /// @param _y The y coordinate of the house&#13;
    /// @return The level of the house&#13;
    function level(uint _x, uint _y) public view returns(uint8);&#13;
&#13;
    /// @dev The auctions contracts can set the owner of a house after an auction&#13;
    /// @param _x The x coordinate of the house&#13;
    /// @param _y The y coordinate of the house&#13;
    /// @param _owner The new owner of the house&#13;
    function auctionsSetOwner(uint _x, uint _y, address _owner) public;&#13;
&#13;
    /// @dev The house realty contract can transfer house ownership&#13;
    /// @param _x The x coordinate of the house&#13;
    /// @param _y The y coordinate of the house&#13;
    /// @param _from The previous owner of house&#13;
    /// @param _to The new owner of house&#13;
    function houseRealtyTransferOwnership(&#13;
          uint _x&#13;
        , uint _y&#13;
        , address _from&#13;
        , address _to&#13;
    ) public;&#13;
}&#13;
&#13;
// File: contracts/KingOfEthHousesReferencer.sol&#13;
&#13;
/****************************************************&#13;
 *&#13;
 * Copyright 2018 BurzNest LLC. All rights reserved.&#13;
 *&#13;
 * The contents of this file are provided for review&#13;
 * and educational purposes ONLY. You MAY NOT use,&#13;
 * copy, distribute, or modify this software without&#13;
 * explicit written permission from BurzNest LLC.&#13;
 *&#13;
 ****************************************************/&#13;
&#13;
pragma solidity ^0.4.24;&#13;
&#13;
&#13;
/// @title King of Eth: Houses Referencer&#13;
/// @author Anthony Burzillo &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="1b796e69615b796e6961757e686f35787476">[email protected]</a>&gt;&#13;
/// @dev Provides functionality to reference the houses contract&#13;
contract KingOfEthHousesReferencer is GodMode {&#13;
    /// @dev The houses contract's address&#13;
    address public housesContract;&#13;
&#13;
    /// @dev Only the houses contract can run this function&#13;
    modifier onlyHousesContract()&#13;
    {&#13;
        require(housesContract == msg.sender);&#13;
        _;&#13;
    }&#13;
&#13;
    /// @dev God can set the realty contract&#13;
    /// @param _housesContract The new address&#13;
    function godSetHousesContract(address _housesContract)&#13;
        public&#13;
        onlyGod&#13;
    {&#13;
        housesContract = _housesContract;&#13;
    }&#13;
}&#13;
&#13;
// File: contracts/KingOfEthHouseRealty.sol&#13;
&#13;
/****************************************************&#13;
 *&#13;
 * Copyright 2018 BurzNest LLC. All rights reserved.&#13;
 *&#13;
 * The contents of this file are provided for review&#13;
 * and educational purposes ONLY. You MAY NOT use,&#13;
 * copy, distribute, or modify this software without&#13;
 * explicit written permission from BurzNest LLC.&#13;
 *&#13;
 ****************************************************/&#13;
&#13;
pragma solidity ^0.4.24;&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
/// @title King of Eth: House Realty&#13;
/// @author Anthony Burzillo &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="177562656d577562656d797264633974787a">[email protected]</a>&gt;&#13;
/// @dev Contract for controlling sales of houses&#13;
contract KingOfEthHouseRealty is&#13;
      GodMode&#13;
    , KingOfEthHousesReferencer&#13;
    , KingOfEthReferencer&#13;
{&#13;
    /// @dev The number that divides the amount payed for any sale to produce&#13;
    ///  the amount payed in taxes&#13;
    uint public constant taxDivisor = 25;&#13;
&#13;
    /// @dev Mapping from the x, y coordinates of a house to the current sale&#13;
    ///  price (0 if there is no sale)&#13;
    mapping (uint =&gt; mapping (uint =&gt; uint)) housePrices;&#13;
&#13;
    /// @dev Fired when there is a new house for sale&#13;
    event HouseForSale(&#13;
          uint x&#13;
        , uint y&#13;
        , address owner&#13;
        , uint amount&#13;
    );&#13;
&#13;
    /// @dev Fired when the owner changes the price of a house&#13;
    event HousePriceChanged(uint x, uint y, uint amount);&#13;
&#13;
    /// @dev Fired when a house is sold&#13;
    event HouseSold(&#13;
          uint x&#13;
        , uint y&#13;
        , address from&#13;
        , address to&#13;
        , uint amount&#13;
        , uint8 level&#13;
    );&#13;
&#13;
    /// @dev Fired when the sale for a house is cancelled by the owner&#13;
    event HouseSaleCancelled(&#13;
          uint x&#13;
        , uint y&#13;
        , address owner&#13;
    );&#13;
&#13;
    /// @dev Only the owner of the house at a location can run this&#13;
    /// @param _x The x coordinate of the house&#13;
    /// @param _y The y coordinate of the house&#13;
    modifier onlyHouseOwner(uint _x, uint _y)&#13;
    {&#13;
        require(KingOfEthHousesAbstractInterface(housesContract).ownerOf(_x, _y) == msg.sender);&#13;
        _;&#13;
    }&#13;
&#13;
    /// @dev This can only be run if there is *not* an existing sale for a house&#13;
    ///  at a location&#13;
    /// @param _x The x coordinate of the house&#13;
    /// @param _y The y coordinate of the house&#13;
    modifier noExistingHouseSale(uint _x, uint _y)&#13;
    {&#13;
        require(0 == housePrices[_x][_y]);&#13;
        _;&#13;
    }&#13;
&#13;
    /// @dev This can only be run if there is an existing sale for a house&#13;
    ///  at a location&#13;
    /// @param _x The x coordinate of the house&#13;
    /// @param _y The y coordinate of the house&#13;
    modifier existingHouseSale(uint _x, uint _y)&#13;
    {&#13;
        require(0 != housePrices[_x][_y]);&#13;
        _;&#13;
    }&#13;
&#13;
    /// @param _kingOfEthContract The address of the king contract&#13;
    constructor(address _kingOfEthContract) public&#13;
    {&#13;
        kingOfEthContract = _kingOfEthContract;&#13;
    }&#13;
&#13;
    /// @dev The houses contract can cancel a sale when a house is transfered&#13;
    ///  to another player&#13;
    /// @param _x The x coordinate of the house&#13;
    /// @param _y The y coordinate of the house&#13;
    function housesCancelHouseSale(uint _x, uint _y)&#13;
        public&#13;
        onlyHousesContract&#13;
    {&#13;
        // If there is indeed a sale&#13;
        if(0 != housePrices[_x][_y])&#13;
        {&#13;
            // Cancel the sale&#13;
            housePrices[_x][_y] = 0;&#13;
&#13;
            emit HouseSaleCancelled(_x, _y, msg.sender);&#13;
        }&#13;
    }&#13;
&#13;
    /// @dev The owner of a house can start a sale&#13;
    /// @param _x The x coordinate of the house&#13;
    /// @param _y The y coordinate of the house&#13;
    /// @param _askingPrice The price that must be payed by another player&#13;
    ///  to purchase the house&#13;
    function startHouseSale(uint _x, uint _y, uint _askingPrice)&#13;
        public&#13;
        notPaused&#13;
        onlyHouseOwner(_x, _y)&#13;
        noExistingHouseSale(_x, _y)&#13;
    {&#13;
        // Require that the price is at least 0&#13;
        require(0 != _askingPrice);&#13;
&#13;
        // Record the price&#13;
        housePrices[_x][_y] = _askingPrice;&#13;
&#13;
        emit HouseForSale(_x, _y, msg.sender, _askingPrice);&#13;
    }&#13;
&#13;
    /// @dev The owner of a house can change the price of a sale&#13;
    /// @param _x The x coordinate of the house&#13;
    /// @param _y The y coordinate of the house&#13;
    /// @param _askingPrice The new price that must be payed by another&#13;
    ///  player to purchase the house&#13;
    function changeHousePrice(uint _x, uint _y, uint _askingPrice)&#13;
        public&#13;
        notPaused&#13;
        onlyHouseOwner(_x, _y)&#13;
        existingHouseSale(_x, _y)&#13;
    {&#13;
        // Require that the price is at least 0&#13;
        require(0 != _askingPrice);&#13;
&#13;
        // Record the price&#13;
        housePrices[_x][_y] = _askingPrice;&#13;
&#13;
        emit HousePriceChanged(_x, _y, _askingPrice);&#13;
    }&#13;
&#13;
    /// @dev Anyone can purchase a house as long as the sale exists&#13;
    /// @param _x The y coordinate of the house&#13;
    /// @param _y The y coordinate of the house&#13;
    function purchaseHouse(uint _x, uint _y)&#13;
        public&#13;
        payable&#13;
        notPaused&#13;
        existingHouseSale(_x, _y)&#13;
    {&#13;
        // Require that the exact price was paid&#13;
        require(housePrices[_x][_y] == msg.value);&#13;
&#13;
        // End the sale&#13;
        housePrices[_x][_y] = 0;&#13;
&#13;
        // Calculate the taxes to be paid&#13;
        uint taxCut = msg.value / taxDivisor;&#13;
&#13;
        // Pay the taxes&#13;
        KingOfEthAbstractInterface(kingOfEthContract).payTaxes.value(taxCut)();&#13;
&#13;
        KingOfEthHousesAbstractInterface _housesContract = KingOfEthHousesAbstractInterface(housesContract);&#13;
&#13;
        // Determine the previous owner&#13;
        address _oldOwner = _housesContract.ownerOf(_x, _y);&#13;
&#13;
        // Send the buyer the house&#13;
        _housesContract.houseRealtyTransferOwnership(&#13;
              _x&#13;
            , _y&#13;
            , _oldOwner&#13;
            , msg.sender&#13;
        );&#13;
&#13;
        // Send the previous owner his share&#13;
        _oldOwner.transfer(msg.value - taxCut);&#13;
&#13;
        emit HouseSold(&#13;
              _x&#13;
            , _y&#13;
            , _oldOwner&#13;
            , msg.sender&#13;
            , msg.value&#13;
            , _housesContract.level(_x, _y)&#13;
        );&#13;
    }&#13;
&#13;
    /// @dev The owner of a house can cancel a sale&#13;
    /// @param _x The y coordinate of the house&#13;
    /// @param _y The y coordinate of the house&#13;
    function cancelHouseSale(uint _x, uint _y)&#13;
        public&#13;
        notPaused&#13;
        onlyHouseOwner(_x, _y)&#13;
        existingHouseSale(_x, _y)&#13;
    {&#13;
        // Cancel the sale&#13;
        housePrices[_x][_y] = 0;&#13;
&#13;
        emit HouseSaleCancelled(_x, _y, msg.sender);&#13;
    }&#13;
}&#13;
&#13;
// File: contracts/KingOfEthHouseRealtyReferencer.sol&#13;
&#13;
/****************************************************&#13;
 *&#13;
 * Copyright 2018 BurzNest LLC. All rights reserved.&#13;
 *&#13;
 * The contents of this file are provided for review&#13;
 * and educational purposes ONLY. You MAY NOT use,&#13;
 * copy, distribute, or modify this software without&#13;
 * explicit written permission from BurzNest LLC.&#13;
 *&#13;
 ****************************************************/&#13;
&#13;
pragma solidity ^0.4.24;&#13;
&#13;
&#13;
/// @title King of Eth: House Realty Referencer&#13;
/// @author Anthony Burzillo &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="a4c6d1d6dee4c6d1d6decac1d7d08ac7cbc9">[email protected]</a>&gt;&#13;
/// @dev Provides functionality to reference the house realty contract&#13;
contract KingOfEthHouseRealtyReferencer is GodMode {&#13;
    /// @dev The realty contract's address&#13;
    address public houseRealtyContract;&#13;
&#13;
    /// @dev Only the house realty contract can run this function&#13;
    modifier onlyHouseRealtyContract()&#13;
    {&#13;
        require(houseRealtyContract == msg.sender);&#13;
        _;&#13;
    }&#13;
&#13;
    /// @dev God can set the house realty contract&#13;
    /// @param _houseRealtyContract The new address&#13;
    function godSetHouseRealtyContract(address _houseRealtyContract)&#13;
        public&#13;
        onlyGod&#13;
    {&#13;
        houseRealtyContract = _houseRealtyContract;&#13;
    }&#13;
}&#13;
&#13;
// File: contracts/KingOfEthRoadsAbstractInterface.sol&#13;
&#13;
/****************************************************&#13;
 *&#13;
 * Copyright 2018 BurzNest LLC. All rights reserved.&#13;
 *&#13;
 * The contents of this file are provided for review&#13;
 * and educational purposes ONLY. You MAY NOT use,&#13;
 * copy, distribute, or modify this software without&#13;
 * explicit written permission from BurzNest LLC.&#13;
 *&#13;
 ****************************************************/&#13;
&#13;
pragma solidity ^0.4.24;&#13;
&#13;
/// @title King of Eth: Roads Abstract Interface&#13;
/// @author Anthony Burzillo &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="204255525a604255525a4e4553540e434f4d">[email protected]</a>&gt;&#13;
/// @dev Abstract interface contract for roads&#13;
contract KingOfEthRoadsAbstractInterface {&#13;
    /// @dev Get the owner of the road at some location&#13;
    /// @param _x The x coordinate of the road&#13;
    /// @param _y The y coordinate of the road&#13;
    /// @param _direction The direction of the road (either&#13;
    ///  0 for right or 1 for down)&#13;
    /// @return The address of the owner&#13;
    function ownerOf(uint _x, uint _y, uint8 _direction) public view returns(address);&#13;
&#13;
    /// @dev The road realty contract can transfer road ownership&#13;
    /// @param _x The x coordinate of the road&#13;
    /// @param _y The y coordinate of the road&#13;
    /// @param _direction The direction of the road&#13;
    /// @param _from The previous owner of road&#13;
    /// @param _to The new owner of road&#13;
    function roadRealtyTransferOwnership(&#13;
          uint _x&#13;
        , uint _y&#13;
        , uint8 _direction&#13;
        , address _from&#13;
        , address _to&#13;
    ) public;&#13;
}&#13;
&#13;
// File: contracts/KingOfEthRoadsReferencer.sol&#13;
&#13;
/****************************************************&#13;
 *&#13;
 * Copyright 2018 BurzNest LLC. All rights reserved.&#13;
 *&#13;
 * The contents of this file are provided for review&#13;
 * and educational purposes ONLY. You MAY NOT use,&#13;
 * copy, distribute, or modify this software without&#13;
 * explicit written permission from BurzNest LLC.&#13;
 *&#13;
 ****************************************************/&#13;
&#13;
pragma solidity ^0.4.24;&#13;
&#13;
&#13;
/// @title King of Eth: Roads Referencer&#13;
/// @author Anthony Burzillo &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="a4c6d1d6dee4c6d1d6decac1d7d08ac7cbc9">[email protected]</a>&gt;&#13;
/// @dev Provides functionality to reference the roads contract&#13;
contract KingOfEthRoadsReferencer is GodMode {&#13;
    /// @dev The roads contract's address&#13;
    address public roadsContract;&#13;
&#13;
    /// @dev Only the roads contract can run this function&#13;
    modifier onlyRoadsContract()&#13;
    {&#13;
        require(roadsContract == msg.sender);&#13;
        _;&#13;
    }&#13;
&#13;
    /// @dev God can set the realty contract&#13;
    /// @param _roadsContract The new address&#13;
    function godSetRoadsContract(address _roadsContract)&#13;
        public&#13;
        onlyGod&#13;
    {&#13;
        roadsContract = _roadsContract;&#13;
    }&#13;
}&#13;
&#13;
// File: contracts/KingOfEthEthExchangeReferencer.sol&#13;
&#13;
/****************************************************&#13;
 *&#13;
 * Copyright 2018 BurzNest LLC. All rights reserved.&#13;
 *&#13;
 * The contents of this file are provided for review&#13;
 * and educational purposes ONLY. You MAY NOT use,&#13;
 * copy, distribute, or modify this software without&#13;
 * explicit written permission from BurzNest LLC.&#13;
 *&#13;
 ****************************************************/&#13;
&#13;
pragma solidity ^0.4.24;&#13;
&#13;
&#13;
/// @title King of Eth: Resource-to-ETH Exchange Referencer&#13;
/// @author Anthony Burzillo &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="690b1c1b13290b1c1b13070c1a1d470a0604">[email protected]</a>&gt;&#13;
/// @dev Provides functionality to interface with the&#13;
///  ETH exchange contract&#13;
contract KingOfEthEthExchangeReferencer is GodMode {&#13;
    /// @dev Address of the ETH exchange contract&#13;
    address public ethExchangeContract;&#13;
&#13;
    /// @dev Only the ETH exchange contract may run this function&#13;
    modifier onlyEthExchangeContract()&#13;
    {&#13;
        require(ethExchangeContract == msg.sender);&#13;
        _;&#13;
    }&#13;
&#13;
    /// @dev God may set the ETH exchange contract's address&#13;
    /// @dev _ethExchangeContract The new address&#13;
    function godSetEthExchangeContract(address _ethExchangeContract)&#13;
        public&#13;
        onlyGod&#13;
    {&#13;
        ethExchangeContract = _ethExchangeContract;&#13;
    }&#13;
}&#13;
&#13;
// File: contracts/KingOfEthResourceExchangeReferencer.sol&#13;
&#13;
/****************************************************&#13;
 *&#13;
 * Copyright 2018 BurzNest LLC. All rights reserved.&#13;
 *&#13;
 * The contents of this file are provided for review&#13;
 * and educational purposes ONLY. You MAY NOT use,&#13;
 * copy, distribute, or modify this software without&#13;
 * explicit written permission from BurzNest LLC.&#13;
 *&#13;
 ****************************************************/&#13;
&#13;
pragma solidity ^0.4.24;&#13;
&#13;
&#13;
/// @title King of Eth: Resource-to-Resource Exchange Referencer&#13;
/// @author Anthony Burzillo &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="fa988f8880ba988f8880949f898ed4999597">[email protected]</a>&gt;&#13;
/// @dev Provides functionality to interface with the&#13;
///  resource-to-resource contract&#13;
contract KingOfEthResourceExchangeReferencer is GodMode {&#13;
    /// @dev Address of the resource-to-resource contract&#13;
    address public resourceExchangeContract;&#13;
&#13;
    /// @dev Only the resource-to-resource contract may run this function&#13;
    modifier onlyResourceExchangeContract()&#13;
    {&#13;
        require(resourceExchangeContract == msg.sender);&#13;
        _;&#13;
    }&#13;
&#13;
    /// @dev God may set the resource-to-resource contract's address&#13;
    /// @dev _resourceExchangeContract The new address&#13;
    function godSetResourceExchangeContract(address _resourceExchangeContract)&#13;
        public&#13;
        onlyGod&#13;
    {&#13;
        resourceExchangeContract = _resourceExchangeContract;&#13;
    }&#13;
}&#13;
&#13;
// File: contracts/KingOfEthExchangeReferencer.sol&#13;
&#13;
/****************************************************&#13;
 *&#13;
 * Copyright 2018 BurzNest LLC. All rights reserved.&#13;
 *&#13;
 * The contents of this file are provided for review&#13;
 * and educational purposes ONLY. You MAY NOT use,&#13;
 * copy, distribute, or modify this software without&#13;
 * explicit written permission from BurzNest LLC.&#13;
 *&#13;
 ****************************************************/&#13;
&#13;
pragma solidity ^0.4.24;&#13;
&#13;
&#13;
&#13;
&#13;
/// @title King of Eth: Exchange Referencer&#13;
/// @author Anthony Burzillo &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="5e3c2b2c241e3c2b2c24303b2d2a703d3133">[email protected]</a>&gt;&#13;
/// @dev Provides functionality to interface with the exchange contract&#13;
contract KingOfEthExchangeReferencer is&#13;
      GodMode&#13;
    , KingOfEthEthExchangeReferencer&#13;
    , KingOfEthResourceExchangeReferencer&#13;
{&#13;
    /// @dev Only one of the exchange contracts may&#13;
    ///  run this function&#13;
    modifier onlyExchangeContract()&#13;
    {&#13;
        require(&#13;
               ethExchangeContract == msg.sender&#13;
            || resourceExchangeContract == msg.sender&#13;
        );&#13;
        _;&#13;
    }&#13;
}&#13;
&#13;
// File: contracts/KingOfEthResourcesInterfaceReferencer.sol&#13;
&#13;
/****************************************************&#13;
 *&#13;
 * Copyright 2018 BurzNest LLC. All rights reserved.&#13;
 *&#13;
 * The contents of this file are provided for review&#13;
 * and educational purposes ONLY. You MAY NOT use,&#13;
 * copy, distribute, or modify this software without&#13;
 * explicit written permission from BurzNest LLC.&#13;
 *&#13;
 ****************************************************/&#13;
&#13;
pragma solidity ^0.4.24;&#13;
&#13;
&#13;
/// @title King of Eth: Resources Interface Referencer&#13;
/// @author Anthony Burzillo &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="781a0d0a02381a0d0a02161d0b0c561b1715">[email protected]</a>&gt;&#13;
/// @dev Provides functionality to reference the resource interface contract&#13;
contract KingOfEthResourcesInterfaceReferencer is GodMode {&#13;
    /// @dev The interface contract's address&#13;
    address public interfaceContract;&#13;
&#13;
    /// @dev Only the interface contract can run this function&#13;
    modifier onlyInterfaceContract()&#13;
    {&#13;
        require(interfaceContract == msg.sender);&#13;
        _;&#13;
    }&#13;
&#13;
    /// @dev God can set the realty contract&#13;
    /// @param _interfaceContract The new address&#13;
    function godSetInterfaceContract(address _interfaceContract)&#13;
        public&#13;
        onlyGod&#13;
    {&#13;
        interfaceContract = _interfaceContract;&#13;
    }&#13;
}&#13;
&#13;
// File: contracts/KingOfEthResource.sol&#13;
&#13;
/****************************************************&#13;
 *&#13;
 * Copyright 2018 BurzNest LLC. All rights reserved.&#13;
 *&#13;
 * The contents of this file are provided for review&#13;
 * and educational purposes ONLY. You MAY NOT use,&#13;
 * copy, distribute, or modify this software without&#13;
 * explicit written permission from BurzNest LLC.&#13;
 *&#13;
 ****************************************************/&#13;
&#13;
pragma solidity ^0.4.24;&#13;
&#13;
&#13;
&#13;
/// @title ERC20Interface&#13;
/// @dev ERC20 token interface contract&#13;
contract ERC20Interface {&#13;
    function totalSupply() public constant returns(uint);&#13;
    function balanceOf(address _tokenOwner) public constant returns(uint balance);&#13;
    function allowance(address _tokenOwner, address _spender) public constant returns(uint remaining);&#13;
    function transfer(address _to, uint _tokens) public returns(bool success);&#13;
    function approve(address _spender, uint _tokens) public returns(bool success);&#13;
    function transferFrom(address _from, address _to, uint _tokens) public returns(bool success);&#13;
&#13;
    event Transfer(address indexed from, address indexed to, uint tokens);&#13;
    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);&#13;
}&#13;
&#13;
/// @title King of Eth: Resource&#13;
/// @author Anthony Burzillo &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="80e2f5f2fac0e2f5f2faeee5f3f4aee3efed">[email protected]</a>&gt;&#13;
/// @dev Common contract implementation for resources&#13;
contract KingOfEthResource is&#13;
      ERC20Interface&#13;
    , GodMode&#13;
    , KingOfEthResourcesInterfaceReferencer&#13;
{&#13;
    /// @dev Current resource supply&#13;
    uint public resourceSupply;&#13;
&#13;
    /// @dev ERC20 token's decimals&#13;
    uint8 public constant decimals = 0;&#13;
&#13;
    /// @dev mapping of addresses to holdings&#13;
    mapping (address =&gt; uint) holdings;&#13;
&#13;
    /// @dev mapping of addresses to amount of tokens frozen&#13;
    mapping (address =&gt; uint) frozenHoldings;&#13;
&#13;
    /// @dev mapping of addresses to mapping of allowances for an address&#13;
    mapping (address =&gt; mapping (address =&gt; uint)) allowances;&#13;
&#13;
    /// @dev ERC20 total supply&#13;
    /// @return The current total supply of the resource&#13;
    function totalSupply()&#13;
        public&#13;
        constant&#13;
        returns(uint)&#13;
    {&#13;
        return resourceSupply;&#13;
    }&#13;
&#13;
    /// @dev ERC20 balance of address&#13;
    /// @param _tokenOwner The address to look up&#13;
    /// @return The balance of the address&#13;
    function balanceOf(address _tokenOwner)&#13;
        public&#13;
        constant&#13;
        returns(uint balance)&#13;
    {&#13;
        return holdings[_tokenOwner];&#13;
    }&#13;
&#13;
    /// @dev Total resources frozen for an address&#13;
    /// @param _tokenOwner The address to look up&#13;
    /// @return The frozen balance of the address&#13;
    function frozenTokens(address _tokenOwner)&#13;
        public&#13;
        constant&#13;
        returns(uint balance)&#13;
    {&#13;
        return frozenHoldings[_tokenOwner];&#13;
    }&#13;
&#13;
    /// @dev The allowance for a spender on an account&#13;
    /// @param _tokenOwner The account that allows withdrawels&#13;
    /// @param _spender The account that is allowed to withdraw&#13;
    /// @return The amount remaining in the allowance&#13;
    function allowance(address _tokenOwner, address _spender)&#13;
        public&#13;
        constant&#13;
        returns(uint remaining)&#13;
    {&#13;
        return allowances[_tokenOwner][_spender];&#13;
    }&#13;
&#13;
    /// @dev Only run if player has at least some amount of tokens&#13;
    /// @param _owner The owner of the tokens&#13;
    /// @param _tokens The amount of tokens required&#13;
    modifier hasAvailableTokens(address _owner, uint _tokens)&#13;
    {&#13;
        require(holdings[_owner] - frozenHoldings[_owner] &gt;= _tokens);&#13;
        _;&#13;
    }&#13;
&#13;
    /// @dev Only run if player has at least some amount of tokens frozen&#13;
    /// @param _owner The owner of the tokens&#13;
    /// @param _tokens The amount of frozen tokens required&#13;
    modifier hasFrozenTokens(address _owner, uint _tokens)&#13;
    {&#13;
        require(frozenHoldings[_owner] &gt;= _tokens);&#13;
        _;&#13;
    }&#13;
&#13;
    /// @dev Set up the exact same state in each resource&#13;
    constructor() public&#13;
    {&#13;
        // God gets 200 to put on exchange&#13;
        holdings[msg.sender] = 200;&#13;
&#13;
        resourceSupply = 200;&#13;
    }&#13;
&#13;
    /// @dev The resources interface can burn tokens for building&#13;
    ///  roads or houses&#13;
    /// @param _owner The owner of the tokens&#13;
    /// @param _tokens The amount of tokens to burn&#13;
    function interfaceBurnTokens(address _owner, uint _tokens)&#13;
        public&#13;
        onlyInterfaceContract&#13;
        hasAvailableTokens(_owner, _tokens)&#13;
    {&#13;
        holdings[_owner] -= _tokens;&#13;
&#13;
        resourceSupply -= _tokens;&#13;
&#13;
        // Pretend the tokens were sent to 0x0&#13;
        emit Transfer(_owner, 0x0, _tokens);&#13;
    }&#13;
&#13;
    /// @dev The resources interface contract can mint tokens for houses&#13;
    /// @param _owner The owner of the tokens&#13;
    /// @param _tokens The amount of tokens to burn&#13;
    function interfaceMintTokens(address _owner, uint _tokens)&#13;
        public&#13;
        onlyInterfaceContract&#13;
    {&#13;
        holdings[_owner] += _tokens;&#13;
&#13;
        resourceSupply += _tokens;&#13;
&#13;
        // Pretend the tokens were sent from the interface contract&#13;
        emit Transfer(interfaceContract, _owner, _tokens);&#13;
    }&#13;
&#13;
    /// @dev The interface can freeze tokens&#13;
    /// @param _owner The owner of the tokens&#13;
    /// @param _tokens The amount of tokens to freeze&#13;
    function interfaceFreezeTokens(address _owner, uint _tokens)&#13;
        public&#13;
        onlyInterfaceContract&#13;
        hasAvailableTokens(_owner, _tokens)&#13;
    {&#13;
        frozenHoldings[_owner] += _tokens;&#13;
    }&#13;
&#13;
    /// @dev The interface can thaw tokens&#13;
    /// @param _owner The owner of the tokens&#13;
    /// @param _tokens The amount of tokens to thaw&#13;
    function interfaceThawTokens(address _owner, uint _tokens)&#13;
        public&#13;
        onlyInterfaceContract&#13;
        hasFrozenTokens(_owner, _tokens)&#13;
    {&#13;
        frozenHoldings[_owner] -= _tokens;&#13;
    }&#13;
&#13;
    /// @dev The interface can transfer tokens&#13;
    /// @param _from The owner of the tokens&#13;
    /// @param _to The new owner of the tokens&#13;
    /// @param _tokens The amount of tokens to transfer&#13;
    function interfaceTransfer(address _from, address _to, uint _tokens)&#13;
        public&#13;
        onlyInterfaceContract&#13;
    {&#13;
        assert(holdings[_from] &gt;= _tokens);&#13;
&#13;
        holdings[_from] -= _tokens;&#13;
        holdings[_to]   += _tokens;&#13;
&#13;
        emit Transfer(_from, _to, _tokens);&#13;
    }&#13;
&#13;
    /// @dev The interface can transfer frozend tokens&#13;
    /// @param _from The owner of the tokens&#13;
    /// @param _to The new owner of the tokens&#13;
    /// @param _tokens The amount of frozen tokens to transfer&#13;
    function interfaceFrozenTransfer(address _from, address _to, uint _tokens)&#13;
        public&#13;
        onlyInterfaceContract&#13;
        hasFrozenTokens(_from, _tokens)&#13;
    {&#13;
        // Make sure to deduct the tokens from both the total and frozen amounts&#13;
        holdings[_from]       -= _tokens;&#13;
        frozenHoldings[_from] -= _tokens;&#13;
        holdings[_to]         += _tokens;&#13;
&#13;
        emit Transfer(_from, _to, _tokens);&#13;
    }&#13;
&#13;
    /// @dev ERC20 transfer&#13;
    /// @param _to The address to transfer to&#13;
    /// @param _tokens The amount of tokens to transfer&#13;
    function transfer(address _to, uint _tokens)&#13;
        public&#13;
        hasAvailableTokens(msg.sender, _tokens)&#13;
        returns(bool success)&#13;
    {&#13;
        holdings[_to]        += _tokens;&#13;
        holdings[msg.sender] -= _tokens;&#13;
&#13;
        emit Transfer(msg.sender, _to, _tokens);&#13;
&#13;
        return true;&#13;
    }&#13;
&#13;
    /// @dev ERC20 approve&#13;
    /// @param _spender The address to approve&#13;
    /// @param _tokens The amount of tokens to approve&#13;
    function approve(address _spender, uint _tokens)&#13;
        public&#13;
        returns(bool success)&#13;
    {&#13;
        allowances[msg.sender][_spender] = _tokens;&#13;
&#13;
        emit Approval(msg.sender, _spender, _tokens);&#13;
&#13;
        return true;&#13;
    }&#13;
&#13;
    /// @dev ERC20 transfer from&#13;
    /// @param _from The address providing the allowance&#13;
    /// @param _to The address using the allowance&#13;
    /// @param _tokens The amount of tokens to transfer&#13;
    function transferFrom(address _from, address _to, uint _tokens)&#13;
        public&#13;
        hasAvailableTokens(_from, _tokens)&#13;
        returns(bool success)&#13;
    {&#13;
        require(allowances[_from][_to] &gt;= _tokens);&#13;
&#13;
        holdings[_to]          += _tokens;&#13;
        holdings[_from]        -= _tokens;&#13;
        allowances[_from][_to] -= _tokens;&#13;
&#13;
        emit Transfer(_from, _to, _tokens);&#13;
&#13;
        return true;&#13;
    }&#13;
}&#13;
&#13;
// File: contracts/KingOfEthResourceType.sol&#13;
&#13;
/****************************************************&#13;
 *&#13;
 * Copyright 2018 BurzNest LLC. All rights reserved.&#13;
 *&#13;
 * The contents of this file are provided for review&#13;
 * and educational purposes ONLY. You MAY NOT use,&#13;
 * copy, distribute, or modify this software without&#13;
 * explicit written permission from BurzNest LLC.&#13;
 *&#13;
 ****************************************************/&#13;
&#13;
pragma solidity ^0.4.24;&#13;
&#13;
/// @title King of Eth: Resource Type&#13;
/// @author Anthony Burzillo &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="4b293e39310b293e3931252e383f65282426">[email protected]</a>&gt;&#13;
/// @dev Provides enum to choose resource types&#13;
contract KingOfEthResourceType {&#13;
    /// @dev Enum describing a choice of a resource&#13;
    enum ResourceType {&#13;
          ETH&#13;
        , BRONZE&#13;
        , CORN&#13;
        , GOLD&#13;
        , OIL&#13;
        , ORE&#13;
        , STEEL&#13;
        , URANIUM&#13;
        , WOOD&#13;
    }&#13;
}&#13;
&#13;
// File: contracts/KingOfEthResourcesInterface.sol&#13;
&#13;
/****************************************************&#13;
 *&#13;
 * Copyright 2018 BurzNest LLC. All rights reserved.&#13;
 *&#13;
 * The contents of this file are provided for review&#13;
 * and educational purposes ONLY. You MAY NOT use,&#13;
 * copy, distribute, or modify this software without&#13;
 * explicit written permission from BurzNest LLC.&#13;
 *&#13;
 ****************************************************/&#13;
&#13;
pragma solidity ^0.4.24;&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
/// @title King of Eth: Resources Interface&#13;
/// @author Anthony Burzillo &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="5d3f282f271d3f282f2733382e29733e3230">[email protected]</a>&gt;&#13;
/// @dev Contract for interacting with resources&#13;
contract KingOfEthResourcesInterface is&#13;
      GodMode&#13;
    , KingOfEthExchangeReferencer&#13;
    , KingOfEthHousesReferencer&#13;
    , KingOfEthResourceType&#13;
    , KingOfEthRoadsReferencer&#13;
{&#13;
    /// @dev Amount of resources a user gets for building a house&#13;
    uint public constant resourcesPerHouse = 3;&#13;
&#13;
    /// @dev Address for the bronze contract&#13;
    address public bronzeContract;&#13;
&#13;
    /// @dev Address for the corn contract&#13;
    address public cornContract;&#13;
&#13;
    /// @dev Address for the gold contract&#13;
    address public goldContract;&#13;
&#13;
    /// @dev Address for the oil contract&#13;
    address public oilContract;&#13;
&#13;
    /// @dev Address for the ore contract&#13;
    address public oreContract;&#13;
&#13;
    /// @dev Address for the steel contract&#13;
    address public steelContract;&#13;
&#13;
    /// @dev Address for the uranium contract&#13;
    address public uraniumContract;&#13;
&#13;
    /// @dev Address for the wood contract&#13;
    address public woodContract;&#13;
&#13;
    /// @param _bronzeContract The address of the bronze contract&#13;
    /// @param _cornContract The address of the corn contract&#13;
    /// @param _goldContract The address of the gold contract&#13;
    /// @param _oilContract The address of the oil contract&#13;
    /// @param _oreContract The address of the ore contract&#13;
    /// @param _steelContract The address of the steel contract&#13;
    /// @param _uraniumContract The address of the uranium contract&#13;
    /// @param _woodContract The address of the wood contract&#13;
    constructor(&#13;
          address _bronzeContract&#13;
        , address _cornContract&#13;
        , address _goldContract&#13;
        , address _oilContract&#13;
        , address _oreContract&#13;
        , address _steelContract&#13;
        , address _uraniumContract&#13;
        , address _woodContract&#13;
    )&#13;
        public&#13;
    {&#13;
        bronzeContract  = _bronzeContract;&#13;
        cornContract    = _cornContract;&#13;
        goldContract    = _goldContract;&#13;
        oilContract     = _oilContract;&#13;
        oreContract     = _oreContract;&#13;
        steelContract   = _steelContract;&#13;
        uraniumContract = _uraniumContract;&#13;
        woodContract    = _woodContract;&#13;
    }&#13;
&#13;
    /// @dev Return the particular address for a certain resource type&#13;
    /// @param _type The resource type&#13;
    /// @return The address for that resource&#13;
    function contractFor(ResourceType _type)&#13;
        public&#13;
        view&#13;
        returns(address)&#13;
    {&#13;
        // ETH does not have a contract&#13;
        require(ResourceType.ETH != _type);&#13;
&#13;
        if(ResourceType.BRONZE == _type)&#13;
        {&#13;
            return bronzeContract;&#13;
        }&#13;
        else if(ResourceType.CORN == _type)&#13;
        {&#13;
            return cornContract;&#13;
        }&#13;
        else if(ResourceType.GOLD == _type)&#13;
        {&#13;
            return goldContract;&#13;
        }&#13;
        else if(ResourceType.OIL == _type)&#13;
        {&#13;
            return oilContract;&#13;
        }&#13;
        else if(ResourceType.ORE == _type)&#13;
        {&#13;
            return oreContract;&#13;
        }&#13;
        else if(ResourceType.STEEL == _type)&#13;
        {&#13;
            return steelContract;&#13;
        }&#13;
        else if(ResourceType.URANIUM == _type)&#13;
        {&#13;
            return uraniumContract;&#13;
        }&#13;
        else if(ResourceType.WOOD == _type)&#13;
        {&#13;
            return woodContract;&#13;
        }&#13;
    }&#13;
&#13;
    /// @dev Determine the resource type of a tile&#13;
    /// @param _x The x coordinate of the top left corner of the tile&#13;
    /// @param _y The y coordinate of the top left corner of the tile&#13;
    function resourceType(uint _x, uint _y)&#13;
        public&#13;
        pure&#13;
        returns(ResourceType resource)&#13;
    {&#13;
        uint _seed = (_x + 7777777) ^  _y;&#13;
&#13;
        if(0 == _seed % 97)&#13;
        {&#13;
          return ResourceType.URANIUM;&#13;
        }&#13;
        else if(0 == _seed % 29)&#13;
        {&#13;
          return ResourceType.OIL;&#13;
        }&#13;
        else if(0 == _seed % 23)&#13;
        {&#13;
          return ResourceType.STEEL;&#13;
        }&#13;
        else if(0 == _seed % 17)&#13;
        {&#13;
          return ResourceType.GOLD;&#13;
        }&#13;
        else if(0 == _seed % 11)&#13;
        {&#13;
          return ResourceType.BRONZE;&#13;
        }&#13;
        else if(0 == _seed % 5)&#13;
        {&#13;
          return ResourceType.WOOD;&#13;
        }&#13;
        else if(0 == _seed % 2)&#13;
        {&#13;
          return ResourceType.CORN;&#13;
        }&#13;
        else&#13;
        {&#13;
          return ResourceType.ORE;&#13;
        }&#13;
    }&#13;
&#13;
    /// @dev Lookup the number of resource points for a certain&#13;
    ///  player&#13;
    /// @param _player The player in question&#13;
    function lookupResourcePoints(address _player)&#13;
        public&#13;
        view&#13;
        returns(uint)&#13;
    {&#13;
        uint result = 0;&#13;
&#13;
        result += KingOfEthResource(bronzeContract).balanceOf(_player);&#13;
        result += KingOfEthResource(goldContract).balanceOf(_player)    * 3;&#13;
        result += KingOfEthResource(steelContract).balanceOf(_player)   * 6;&#13;
        result += KingOfEthResource(oilContract).balanceOf(_player)     * 10;&#13;
        result += KingOfEthResource(uraniumContract).balanceOf(_player) * 44;&#13;
&#13;
        return result;&#13;
    }&#13;
&#13;
    /// @dev Burn the resources necessary to build a house&#13;
    /// @param _count the number of houses being built&#13;
    /// @param _player The player who is building the house&#13;
    function burnHouseCosts(uint _count, address _player)&#13;
        public&#13;
        onlyHousesContract&#13;
    {&#13;
        // Costs 2 corn per house&#13;
        KingOfEthResource(contractFor(ResourceType.CORN)).interfaceBurnTokens(&#13;
              _player&#13;
            , 2 * _count&#13;
        );&#13;
&#13;
        // Costs 2 ore per house&#13;
        KingOfEthResource(contractFor(ResourceType.ORE)).interfaceBurnTokens(&#13;
              _player&#13;
            , 2 * _count&#13;
        );&#13;
&#13;
        // Costs 1 wood per house&#13;
        KingOfEthResource(contractFor(ResourceType.WOOD)).interfaceBurnTokens(&#13;
              _player&#13;
            , _count&#13;
        );&#13;
    }&#13;
&#13;
    /// @dev Burn the costs of upgrading a house&#13;
    /// @param _currentLevel The level of the house before the upgrade&#13;
    /// @param _player The player who is upgrading the house&#13;
    function burnUpgradeCosts(uint8 _currentLevel, address _player)&#13;
        public&#13;
        onlyHousesContract&#13;
    {&#13;
        // Do not allow upgrades after level 4&#13;
        require(5 &gt; _currentLevel);&#13;
&#13;
        // Burn the base house cost&#13;
        burnHouseCosts(1, _player);&#13;
&#13;
        if(0 == _currentLevel)&#13;
        {&#13;
            // Level 1 costs bronze&#13;
            KingOfEthResource(contractFor(ResourceType.BRONZE)).interfaceBurnTokens(&#13;
                  _player&#13;
                , 1&#13;
            );&#13;
        }&#13;
        else if(1 == _currentLevel)&#13;
        {&#13;
            // Level 2 costs gold&#13;
            KingOfEthResource(contractFor(ResourceType.GOLD)).interfaceBurnTokens(&#13;
                  _player&#13;
                , 1&#13;
            );&#13;
        }&#13;
        else if(2 == _currentLevel)&#13;
        {&#13;
            // Level 3 costs steel&#13;
            KingOfEthResource(contractFor(ResourceType.STEEL)).interfaceBurnTokens(&#13;
                  _player&#13;
                , 1&#13;
            );&#13;
        }&#13;
        else if(3 == _currentLevel)&#13;
        {&#13;
            // Level 4 costs oil&#13;
            KingOfEthResource(contractFor(ResourceType.OIL)).interfaceBurnTokens(&#13;
                  _player&#13;
                , 1&#13;
            );&#13;
        }&#13;
        else if(4 == _currentLevel)&#13;
        {&#13;
            // Level 5 costs uranium&#13;
            KingOfEthResource(contractFor(ResourceType.URANIUM)).interfaceBurnTokens(&#13;
                  _player&#13;
                , 1&#13;
            );&#13;
        }&#13;
    }&#13;
&#13;
    /// @dev Mint resources for a house and distribute all to its owner&#13;
    /// @param _owner The owner of the house&#13;
    /// @param _x The x coordinate of the house&#13;
    /// @param _y The y coordinate of the house&#13;
    /// @param _y The y coordinate of the house&#13;
    /// @param _level The new level of the house&#13;
    function distributeResources(address _owner, uint _x, uint _y, uint8 _level)&#13;
        public&#13;
        onlyHousesContract&#13;
    {&#13;
        // Calculate the count of resources for this level&#13;
        uint _count = resourcesPerHouse * uint(_level + 1);&#13;
&#13;
        // Distribute the top left resource&#13;
        KingOfEthResource(contractFor(resourceType(_x - 1, _y - 1))).interfaceMintTokens(&#13;
            _owner&#13;
          , _count&#13;
        );&#13;
&#13;
        // Distribute the top right resource&#13;
        KingOfEthResource(contractFor(resourceType(_x, _y - 1))).interfaceMintTokens(&#13;
            _owner&#13;
          , _count&#13;
        );&#13;
&#13;
        // Distribute the bottom right resource&#13;
        KingOfEthResource(contractFor(resourceType(_x, _y))).interfaceMintTokens(&#13;
            _owner&#13;
          , _count&#13;
        );&#13;
&#13;
        // Distribute the bottom left resource&#13;
        KingOfEthResource(contractFor(resourceType(_x - 1, _y))).interfaceMintTokens(&#13;
            _owner&#13;
          , _count&#13;
        );&#13;
    }&#13;
&#13;
    /// @dev Burn the costs necessary to build a road&#13;
    /// @param _length The length of the road&#13;
    /// @param _player The player who is building the house&#13;
    function burnRoadCosts(uint _length, address _player)&#13;
        public&#13;
        onlyRoadsContract&#13;
    {&#13;
        // Burn corn&#13;
        KingOfEthResource(cornContract).interfaceBurnTokens(&#13;
              _player&#13;
            , _length&#13;
        );&#13;
&#13;
        // Burn ore&#13;
        KingOfEthResource(oreContract).interfaceBurnTokens(&#13;
              _player&#13;
            , _length&#13;
        );&#13;
    }&#13;
&#13;
    /// @dev The exchange can freeze tokens&#13;
    /// @param _type The type of resource&#13;
    /// @param _owner The owner of the tokens&#13;
    /// @param _tokens The amount of tokens to freeze&#13;
    function exchangeFreezeTokens(ResourceType _type, address _owner, uint _tokens)&#13;
        public&#13;
        onlyExchangeContract&#13;
    {&#13;
        KingOfEthResource(contractFor(_type)).interfaceFreezeTokens(_owner, _tokens);&#13;
    }&#13;
&#13;
    /// @dev The exchange can thaw tokens&#13;
    /// @param _type The type of resource&#13;
    /// @param _owner The owner of the tokens&#13;
    /// @param _tokens The amount of tokens to thaw&#13;
    function exchangeThawTokens(ResourceType _type, address _owner, uint _tokens)&#13;
        public&#13;
        onlyExchangeContract&#13;
    {&#13;
        KingOfEthResource(contractFor(_type)).interfaceThawTokens(_owner, _tokens);&#13;
    }&#13;
&#13;
    /// @dev The exchange can transfer tokens&#13;
    /// @param _type The type of resource&#13;
    /// @param _from The owner of the tokens&#13;
    /// @param _to The new owner of the tokens&#13;
    /// @param _tokens The amount of tokens to transfer&#13;
    function exchangeTransfer(ResourceType _type, address _from, address _to, uint _tokens)&#13;
        public&#13;
        onlyExchangeContract&#13;
    {&#13;
        KingOfEthResource(contractFor(_type)).interfaceTransfer(_from, _to, _tokens);&#13;
    }&#13;
&#13;
    /// @dev The exchange can transfer frozend tokens&#13;
    /// @param _type The type of resource&#13;
    /// @param _from The owner of the tokens&#13;
    /// @param _to The new owner of the tokens&#13;
    /// @param _tokens The amount of frozen tokens to transfer&#13;
    function exchangeFrozenTransfer(ResourceType _type, address _from, address _to, uint _tokens)&#13;
        public&#13;
        onlyExchangeContract&#13;
    {&#13;
        KingOfEthResource(contractFor(_type)).interfaceFrozenTransfer(_from, _to, _tokens);&#13;
    }&#13;
}&#13;
&#13;
// File: contracts/KingOfEthHouses.sol&#13;
&#13;
/****************************************************&#13;
 *&#13;
 * Copyright 2018 BurzNest LLC. All rights reserved.&#13;
 *&#13;
 * The contents of this file are provided for review&#13;
 * and educational purposes ONLY. You MAY NOT use,&#13;
 * copy, distribute, or modify this software without&#13;
 * explicit written permission from BurzNest LLC.&#13;
 *&#13;
 ****************************************************/&#13;
&#13;
pragma solidity ^0.4.24;&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
/// @title King of Eth: Houses&#13;
/// @author Anthony Burzillo &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="c6a4b3b4bc86a4b3b4bca8a3b5b2e8a5a9ab">[email protected]</a>&gt;&#13;
/// @dev Contract for houses&#13;
contract KingOfEthHouses is&#13;
      GodMode&#13;
    , KingOfEthAuctionsReferencer&#13;
    , KingOfEthBoardReferencer&#13;
    , KingOfEthHouseRealtyReferencer&#13;
    , KingOfEthHousesAbstractInterface&#13;
    , KingOfEthReferencer&#13;
    , KingOfEthRoadsReferencer&#13;
    , KingOfEthResourcesInterfaceReferencer&#13;
{&#13;
    /// @dev ETH cost to build or upgrade a house&#13;
    uint public houseCost = 0.001 ether;&#13;
&#13;
    /// @dev Struct to hold info about a house location on the board&#13;
    struct LocationInfo {&#13;
        /// @dev The owner of the house at this location&#13;
        address owner;&#13;
&#13;
        /// @dev The level of the house at this location&#13;
        uint8 level;&#13;
    }&#13;
&#13;
    /// @dev Mapping from the (x, y) coordinate of the location to its info&#13;
    mapping (uint =&gt; mapping (uint =&gt; LocationInfo)) locationInfo;&#13;
&#13;
    /// @dev Mapping from a player's address to his points&#13;
    mapping (address =&gt; uint) pointCounts;&#13;
&#13;
    /// @param _blindAuctionsContract The address of the blind auctions contract&#13;
    /// @param _boardContract The address of the board contract&#13;
    /// @param _kingOfEthContract The address of the king contract&#13;
    /// @param _houseRealtyContract The address of the house realty contract&#13;
    /// @param _openAuctionsContract The address of the open auctions contract&#13;
    /// @param _roadsContract The address of the roads contract&#13;
    /// @param _interfaceContract The address of the resources&#13;
    ///  interface contract&#13;
    constructor(&#13;
          address _blindAuctionsContract&#13;
        , address _boardContract&#13;
        , address _kingOfEthContract&#13;
        , address _houseRealtyContract&#13;
        , address _openAuctionsContract&#13;
        , address _roadsContract&#13;
        , address _interfaceContract&#13;
    )&#13;
        public&#13;
    {&#13;
        blindAuctionsContract = _blindAuctionsContract;&#13;
        boardContract         = _boardContract;&#13;
        kingOfEthContract     = _kingOfEthContract;&#13;
        houseRealtyContract   = _houseRealtyContract;&#13;
        openAuctionsContract  = _openAuctionsContract;&#13;
        roadsContract         = _roadsContract;&#13;
        interfaceContract     = _interfaceContract;&#13;
    }&#13;
&#13;
    /// @dev Fired when new houses are built&#13;
    event NewHouses(address owner, uint[] locations);&#13;
&#13;
    /// @dev Fired when a house is sent from one player to another&#13;
    event SentHouse(uint x, uint y, address from, address to, uint8 level);&#13;
&#13;
    /// @dev Fired when a house is upgraded&#13;
    event UpgradedHouse(uint x, uint y, address owner, uint8 newLevel);&#13;
&#13;
    /// @dev Get the owner of the house at some location&#13;
    /// @param _x The x coordinate of the house&#13;
    /// @param _y The y coordinate of the house&#13;
    /// @return The address of the owner&#13;
    function ownerOf(uint _x, uint _y) public view returns(address)&#13;
    {&#13;
        return locationInfo[_x][_y].owner;&#13;
    }&#13;
&#13;
    /// @dev Get the level of the house at some location&#13;
    /// @param _x The x coordinate of the house&#13;
    /// @param _y The y coordinate of the house&#13;
    /// @return The level of the house&#13;
    function level(uint _x, uint _y) public view returns(uint8)&#13;
    {&#13;
        return locationInfo[_x][_y].level;&#13;
    }&#13;
&#13;
    /// @dev Get the number of points held by a player&#13;
    /// @param _player The player's address&#13;
    /// @return The number of points&#13;
    function numberOfPoints(address _player) public view returns(uint)&#13;
    {&#13;
        return pointCounts[_player];&#13;
    }&#13;
&#13;
    /// @dev Helper function to build a house at a location&#13;
    /// @param _x The x coordinate of the house&#13;
    /// @param _y The y coordinate of the house&#13;
    function buildHouseInner(uint _x, uint _y) private&#13;
    {&#13;
        // Lookup the info about the house&#13;
        LocationInfo storage _locationInfo = locationInfo[_x][_y];&#13;
&#13;
        KingOfEthBoard _boardContract = KingOfEthBoard(boardContract);&#13;
&#13;
        // Require the house to be within the current bounds of the game&#13;
        require(_boardContract.boundX1() &lt;= _x);&#13;
        require(_boardContract.boundY1() &lt;= _y);&#13;
        require(_boardContract.boundX2() &gt; _x);&#13;
        require(_boardContract.boundY2() &gt; _y);&#13;
&#13;
        // Require the spot to be empty&#13;
        require(0x0 == _locationInfo.owner);&#13;
&#13;
        KingOfEthRoadsAbstractInterface _roadsContract = KingOfEthRoadsAbstractInterface(roadsContract);&#13;
&#13;
        // Require either either the right, bottom, left or top road&#13;
        // to be owned by the player&#13;
        require(&#13;
                _roadsContract.ownerOf(_x, _y, 0) == msg.sender&#13;
             || _roadsContract.ownerOf(_x, _y, 1) == msg.sender&#13;
             || _roadsContract.ownerOf(_x - 1, _y, 0) == msg.sender&#13;
             || _roadsContract.ownerOf(_x, _y - 1, 1) == msg.sender&#13;
        );&#13;
&#13;
        // Require that there is no existing blind auction at the location&#13;
        require(!KingOfEthAuctionsAbstractInterface(blindAuctionsContract).existingAuction(_x, _y));&#13;
&#13;
        // Require that there is no existing open auction at the location&#13;
        require(!KingOfEthAuctionsAbstractInterface(openAuctionsContract).existingAuction(_x, _y));&#13;
&#13;
        // Set new owner&#13;
        _locationInfo.owner = msg.sender;&#13;
&#13;
        // Update player's points&#13;
        ++pointCounts[msg.sender];&#13;
&#13;
        // Distribute resources to the player&#13;
        KingOfEthResourcesInterface(interfaceContract).distributeResources(&#13;
              msg.sender&#13;
            , _x&#13;
            , _y&#13;
            , 0 // Level 0&#13;
        );&#13;
    }&#13;
&#13;
    /// @dev God can change the house cost&#13;
    /// @param _newHouseCost The new cost of a house&#13;
    function godChangeHouseCost(uint _newHouseCost)&#13;
        public&#13;
        onlyGod&#13;
    {&#13;
        houseCost = _newHouseCost;&#13;
    }&#13;
&#13;
    /// @dev The auctions contracts can set the owner of a house after an auction&#13;
    /// @param _x The x coordinate of the house&#13;
    /// @param _y The y coordinate of the house&#13;
    /// @param _owner The new owner of the house&#13;
    function auctionsSetOwner(uint _x, uint _y, address _owner)&#13;
        public&#13;
        onlyAuctionsContract&#13;
    {&#13;
        // Lookup the info about the house&#13;
        LocationInfo storage _locationInfo = locationInfo[_x][_y];&#13;
&#13;
        // Require that nobody already owns the house.&#13;
        // Note that this would be an assert if only the blind auctions&#13;
        // contract used this code, but the open auctions contract&#13;
        // depends on this require to save space.&#13;
        require(0x0 == _locationInfo.owner);&#13;
&#13;
        // Set the house's new owner&#13;
        _locationInfo.owner = _owner;&#13;
&#13;
        // Give the player a point for the house&#13;
        ++pointCounts[_owner];&#13;
&#13;
        // Distribute the resources for the house&#13;
        KingOfEthResourcesInterface(interfaceContract).distributeResources(&#13;
              _owner&#13;
            , _x&#13;
            , _y&#13;
            , 0 // Level 0&#13;
        );&#13;
&#13;
        // Set up the locations for the event&#13;
        uint[] memory _locations = new uint[](2);&#13;
        _locations[0] = _x;&#13;
        _locations[1] = _y;&#13;
&#13;
        emit NewHouses(_owner, _locations);&#13;
    }&#13;
&#13;
    /// @dev The house realty contract can transfer house ownership&#13;
    /// @param _x The x coordinate of the house&#13;
    /// @param _y The y coordinate of the house&#13;
    /// @param _from The previous owner of house&#13;
    /// @param _to The new owner of house&#13;
    function houseRealtyTransferOwnership(&#13;
          uint _x&#13;
        , uint _y&#13;
        , address _from&#13;
        , address _to&#13;
    )&#13;
        public&#13;
        onlyHouseRealtyContract&#13;
    {&#13;
        // Lookup the info about the house&#13;
        LocationInfo storage _locationInfo = locationInfo[_x][_y];&#13;
&#13;
        // Assert that the previous owner still has the house&#13;
        assert(_locationInfo.owner == _from);&#13;
&#13;
        // Set the new owner&#13;
        _locationInfo.owner = _to;&#13;
&#13;
        // Calculate the total points of the house&#13;
        uint _points = _locationInfo.level + 1;&#13;
&#13;
        // Update the point counts&#13;
        pointCounts[_from] -= _points;&#13;
        pointCounts[_to]   += _points;&#13;
    }&#13;
&#13;
    /// @dev Build multiple houses at once&#13;
    /// @param _locations An array of coordinates for the houses. These&#13;
    ///  are specified sequentially like [x1, y1, x2, y2] representing&#13;
    ///  location (x1, y1) and location (x2, y2).&#13;
    function buildHouses(uint[] _locations)&#13;
        public&#13;
        payable&#13;
    {&#13;
        // Require that there are an even number of locations&#13;
        require(0 == _locations.length % 2);&#13;
&#13;
        uint _count = _locations.length / 2;&#13;
&#13;
        // Require the house cost&#13;
        require(houseCost * _count == msg.value);&#13;
&#13;
        // Pay taxes&#13;
        KingOfEthAbstractInterface(kingOfEthContract).payTaxes.value(msg.value)();&#13;
&#13;
        // Burn the required resource costs for the houses&#13;
        KingOfEthResourcesInterface(interfaceContract).burnHouseCosts(&#13;
              _count&#13;
            , msg.sender&#13;
        );&#13;
&#13;
        // Build a house at each one of the locations&#13;
        for(uint i = 0; i &lt; _locations.length; i += 2)&#13;
        {&#13;
            buildHouseInner(_locations[i], _locations[i + 1]);&#13;
        }&#13;
&#13;
        emit NewHouses(msg.sender, _locations);&#13;
    }&#13;
&#13;
    /// @dev Send a house to another player&#13;
    /// @param _x The x coordinate of the house&#13;
    /// @param _y The y coordinate of the house&#13;
    /// @param _to The recipient of the house&#13;
    function sendHouse(uint _x, uint _y, address _to) public&#13;
    {&#13;
        // Lookup the info about the house&#13;
        LocationInfo storage _locationInfo = locationInfo[_x][_y];&#13;
&#13;
        // Require that the sender is the owner&#13;
        require(_locationInfo.owner == msg.sender);&#13;
&#13;
        // Set the new owner&#13;
        _locationInfo.owner = _to;&#13;
&#13;
        // Calculate the points of the house&#13;
        uint _points = _locationInfo.level + 1;&#13;
&#13;
        // Update point counts&#13;
        pointCounts[msg.sender] -= _points;&#13;
        pointCounts[_to]        += _points;&#13;
&#13;
        // Cancel any sales that exist&#13;
        KingOfEthHouseRealty(houseRealtyContract).housesCancelHouseSale(_x, _y);&#13;
&#13;
        emit SentHouse(_x, _y, msg.sender, _to, _locationInfo.level);&#13;
    }&#13;
&#13;
    /// @dev Upgrade a house&#13;
    /// @param _x The x coordinate of the house&#13;
    /// @param _y The y coordinate of the house&#13;
    function upgradeHouse(uint _x, uint _y) public payable&#13;
    {&#13;
        // Lookup the info about the house&#13;
        LocationInfo storage _locationInfo = locationInfo[_x][_y];&#13;
&#13;
        // Require that the sender is the owner&#13;
        require(_locationInfo.owner == msg.sender);&#13;
&#13;
        // Require the house cost be payed&#13;
        require(houseCost == msg.value);&#13;
&#13;
        // Pay the taxes&#13;
        KingOfEthAbstractInterface(kingOfEthContract).payTaxes.value(msg.value)();&#13;
&#13;
        // Burn the resource costs of the upgrade&#13;
        KingOfEthResourcesInterface(interfaceContract).burnUpgradeCosts(&#13;
              _locationInfo.level&#13;
            , msg.sender&#13;
        );&#13;
&#13;
        // Update the house's level&#13;
        ++locationInfo[_x][_y].level;&#13;
&#13;
        // Update the owner's points&#13;
        ++pointCounts[msg.sender];&#13;
&#13;
        // Distribute the resources for the house&#13;
        KingOfEthResourcesInterface(interfaceContract).distributeResources(&#13;
              msg.sender&#13;
            , _x&#13;
            , _y&#13;
            , _locationInfo.level&#13;
        );&#13;
&#13;
        emit UpgradedHouse(_x, _y, msg.sender, _locationInfo.level);&#13;
    }&#13;
}&#13;
&#13;
// File: contracts/KingOfEthRoadRealty.sol&#13;
&#13;
/****************************************************&#13;
 *&#13;
 * Copyright 2018 BurzNest LLC. All rights reserved.&#13;
 *&#13;
 * The contents of this file are provided for review&#13;
 * and educational purposes ONLY. You MAY NOT use,&#13;
 * copy, distribute, or modify this software without&#13;
 * explicit written permission from BurzNest LLC.&#13;
 *&#13;
 ****************************************************/&#13;
&#13;
pragma solidity ^0.4.24;&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
/// @title King of Eth: Road Realty&#13;
/// @author Anthony Burzillo &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="026077707842607770786c6771762c616d6f">[email protected]</a>&gt;&#13;
/// @dev Contract for controlling sales of roads&#13;
contract KingOfEthRoadRealty is&#13;
      GodMode&#13;
    , KingOfEthReferencer&#13;
    , KingOfEthRoadsReferencer&#13;
{&#13;
    /// @dev The number that divides the amount payed for any sale to produce&#13;
    ///  the amount payed in taxes&#13;
    uint public constant taxDivisor = 25;&#13;
&#13;
    /// @dev Mapping from the x, y coordinates and the direction (0 for right and&#13;
    ///  1 for down) of a road to the  current sale price (0 if there is no sale)&#13;
    mapping (uint =&gt; mapping (uint =&gt; uint[2])) roadPrices;&#13;
&#13;
    /// @dev Fired when there is a new road for sale&#13;
    event RoadForSale(&#13;
          uint x&#13;
        , uint y&#13;
        , uint8 direction&#13;
        , address owner&#13;
        , uint amount&#13;
    );&#13;
&#13;
    /// @dev Fired when the owner changes the price of a road&#13;
    event RoadPriceChanged(&#13;
          uint x&#13;
        , uint y&#13;
        , uint8 direction&#13;
        , uint amount&#13;
    );&#13;
&#13;
    /// @dev Fired when a road is sold&#13;
    event RoadSold(&#13;
          uint x&#13;
        , uint y&#13;
        , uint8 direction&#13;
        , address from&#13;
        , address to&#13;
        , uint amount&#13;
    );&#13;
&#13;
    /// @dev Fired when the sale for a road is cancelled by the owner&#13;
    event RoadSaleCancelled(&#13;
          uint x&#13;
        , uint y&#13;
        , uint8 direction&#13;
        , address owner&#13;
    );&#13;
&#13;
    /// @dev Only the owner of the road at a location can run this&#13;
    /// @param _x The x coordinate of the road&#13;
    /// @param _y The y coordinate of the road&#13;
    /// @param _direction The direction of the road&#13;
    modifier onlyRoadOwner(uint _x, uint _y, uint8 _direction)&#13;
    {&#13;
        require(KingOfEthRoadsAbstractInterface(roadsContract).ownerOf(_x, _y, _direction) == msg.sender);&#13;
        _;&#13;
    }&#13;
&#13;
    /// @dev This can only be run if there is *not* an existing sale for a road&#13;
    ///  at a location&#13;
    /// @param _x The x coordinate of the road&#13;
    /// @param _y The y coordinate of the road&#13;
    /// @param _direction The direction of the road&#13;
    modifier noExistingRoadSale(uint _x, uint _y, uint8 _direction)&#13;
    {&#13;
        require(0 == roadPrices[_x][_y][_direction]);&#13;
        _;&#13;
    }&#13;
&#13;
    /// @dev This can only be run if there is an existing sale for a house&#13;
    ///  at a location&#13;
    /// @param _x The x coordinate of the road&#13;
    /// @param _y The y coordinate of the road&#13;
    /// @param _direction The direction of the road&#13;
    modifier existingRoadSale(uint _x, uint _y, uint8 _direction)&#13;
    {&#13;
        require(0 != roadPrices[_x][_y][_direction]);&#13;
        _;&#13;
    }&#13;
&#13;
    /// @param _kingOfEthContract The address of the king contract&#13;
    constructor(address _kingOfEthContract) public&#13;
    {&#13;
        kingOfEthContract = _kingOfEthContract;&#13;
    }&#13;
&#13;
    /// @dev The roads contract can cancel a sale when a road is transfered&#13;
    ///  to another player&#13;
    /// @param _x The x coordinate of the road&#13;
    /// @param _y The y coordinate of the road&#13;
    /// @param _direction The direction of the road&#13;
    function roadsCancelRoadSale(uint _x, uint _y, uint8 _direction)&#13;
        public&#13;
        onlyRoadsContract&#13;
    {&#13;
        // If there is indeed a sale&#13;
        if(0 != roadPrices[_x][_y][_direction])&#13;
        {&#13;
            // Cancel the sale&#13;
            roadPrices[_x][_y][_direction] = 0;&#13;
&#13;
            emit RoadSaleCancelled(_x, _y, _direction, msg.sender);&#13;
        }&#13;
    }&#13;
&#13;
    /// @dev The owner of a road can start a sale&#13;
    /// @param _x The x coordinate of the road&#13;
    /// @param _y The y coordinate of the road&#13;
    /// @param _direction The direction of the road&#13;
    /// @param _askingPrice The price that must be payed by another player&#13;
    ///  to purchase the road&#13;
    function startRoadSale(&#13;
          uint _x&#13;
        , uint _y&#13;
        , uint8 _direction&#13;
        , uint _askingPrice&#13;
    )&#13;
        public&#13;
        notPaused&#13;
        onlyRoadOwner(_x, _y, _direction)&#13;
        noExistingRoadSale(_x, _y, _direction)&#13;
    {&#13;
        // Require that the price is at least 0&#13;
        require(0 != _askingPrice);&#13;
&#13;
        // Record the price&#13;
        roadPrices[_x][_y][_direction] = _askingPrice;&#13;
&#13;
        emit RoadForSale(_x, _y, _direction, msg.sender, _askingPrice);&#13;
    }&#13;
&#13;
    /// @dev The owner of a road can change the price of a sale&#13;
    /// @param _x The x coordinate of the road&#13;
    /// @param _y The y coordinate of the road&#13;
    /// @param _direction The direction of the road&#13;
    /// @param _askingPrice The new price that must be payed by another&#13;
    ///  player to purchase the road&#13;
    function changeRoadPrice(&#13;
          uint _x&#13;
        , uint _y&#13;
        , uint8 _direction&#13;
        , uint _askingPrice&#13;
    )&#13;
        public&#13;
        notPaused&#13;
        onlyRoadOwner(_x, _y, _direction)&#13;
        existingRoadSale(_x, _y, _direction)&#13;
    {&#13;
        // Require that the price is at least 0&#13;
        require(0 != _askingPrice);&#13;
&#13;
        // Record the price&#13;
        roadPrices[_x][_y][_direction] = _askingPrice;&#13;
&#13;
        emit RoadPriceChanged(_x, _y, _direction, _askingPrice);&#13;
    }&#13;
&#13;
    /// @dev Anyone can purchase a road as long as the sale exists&#13;
    /// @param _x The x coordinate of the road&#13;
    /// @param _y The y coordinate of the road&#13;
    /// @param _direction The direction of the road&#13;
    function purchaseRoad(uint _x, uint _y, uint8 _direction)&#13;
        public&#13;
        payable&#13;
        notPaused&#13;
        existingRoadSale(_x, _y, _direction)&#13;
    {&#13;
        // Require that the exact price was paid&#13;
        require(roadPrices[_x][_y][_direction] == msg.value);&#13;
&#13;
        // End the sale&#13;
        roadPrices[_x][_y][_direction] = 0;&#13;
&#13;
        // Calculate the taxes to be paid&#13;
        uint taxCut = msg.value / taxDivisor;&#13;
&#13;
        // Pay the taxes&#13;
        KingOfEthAbstractInterface(kingOfEthContract).payTaxes.value(taxCut)();&#13;
&#13;
        KingOfEthRoadsAbstractInterface _roadsContract = KingOfEthRoadsAbstractInterface(roadsContract);&#13;
&#13;
        // Determine the previous owner&#13;
        address _oldOwner = _roadsContract.ownerOf(_x, _y, _direction);&#13;
&#13;
        // Send the buyer the house&#13;
        _roadsContract.roadRealtyTransferOwnership(&#13;
              _x&#13;
            , _y&#13;
            , _direction&#13;
            , _oldOwner&#13;
            , msg.sender&#13;
        );&#13;
&#13;
        // Send the previous owner his share&#13;
        _oldOwner.transfer(msg.value - taxCut);&#13;
&#13;
        emit RoadSold(&#13;
              _x&#13;
            , _y&#13;
            , _direction&#13;
            , _oldOwner&#13;
            , msg.sender&#13;
            , msg.value&#13;
        );&#13;
    }&#13;
&#13;
    /// @dev The owner of a road can cancel a sale&#13;
    /// @param _x The x coordinate of the road&#13;
    /// @param _y The y coordinate of the road&#13;
    /// @param _direction The direction of the road&#13;
    function cancelRoadSale(uint _x, uint _y, uint8 _direction)&#13;
        public&#13;
        notPaused&#13;
        onlyRoadOwner(_x, _y, _direction)&#13;
        existingRoadSale(_x, _y, _direction)&#13;
    {&#13;
        // Cancel the sale&#13;
        roadPrices[_x][_y][_direction] = 0;&#13;
&#13;
        emit RoadSaleCancelled(_x, _y, _direction, msg.sender);&#13;
    }&#13;
}&#13;
&#13;
// File: contracts/KingOfEthRoadRealtyReferencer.sol&#13;
&#13;
/****************************************************&#13;
 *&#13;
 * Copyright 2018 BurzNest LLC. All rights reserved.&#13;
 *&#13;
 * The contents of this file are provided for review&#13;
 * and educational purposes ONLY. You MAY NOT use,&#13;
 * copy, distribute, or modify this software without&#13;
 * explicit written permission from BurzNest LLC.&#13;
 *&#13;
 ****************************************************/&#13;
&#13;
pragma solidity ^0.4.24;&#13;
&#13;
&#13;
/// @title King of Eth: Road Realty Referencer&#13;
/// @author Anthony Burzillo &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="9af8efe8e0daf8efe8e0f4ffe9eeb4f9f5f7">[email protected]</a>&gt;&#13;
/// @dev Provides functionality to reference the road realty contract&#13;
contract KingOfEthRoadRealtyReferencer is GodMode {&#13;
    /// @dev The realty contract's address&#13;
    address public roadRealtyContract;&#13;
&#13;
    /// @dev Only the road realty contract can run this function&#13;
    modifier onlyRoadRealtyContract()&#13;
    {&#13;
        require(roadRealtyContract == msg.sender);&#13;
        _;&#13;
    }&#13;
&#13;
    /// @dev God can set the road realty contract&#13;
    /// @param _roadRealtyContract The new address&#13;
    function godSetRoadRealtyContract(address _roadRealtyContract)&#13;
        public&#13;
        onlyGod&#13;
    {&#13;
        roadRealtyContract = _roadRealtyContract;&#13;
    }&#13;
}&#13;
&#13;
// File: contracts/KingOfEthRoads.sol&#13;
&#13;
/****************************************************&#13;
 *&#13;
 * Copyright 2018 BurzNest LLC. All rights reserved.&#13;
 *&#13;
 * The contents of this file are provided for review&#13;
 * and educational purposes ONLY. You MAY NOT use,&#13;
 * copy, distribute, or modify this software without&#13;
 * explicit written permission from BurzNest LLC.&#13;
 *&#13;
 ****************************************************/&#13;
&#13;
pragma solidity ^0.4.24;&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
/// @title King of Eth: Roads&#13;
/// @author Anthony Burzillo &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="462433343c062433343c282335326825292b">[email protected]</a>&gt;&#13;
/// @dev Contract for roads&#13;
contract KingOfEthRoads is&#13;
      GodMode&#13;
    , KingOfEthBoardReferencer&#13;
    , KingOfEthHousesReferencer&#13;
    , KingOfEthReferencer&#13;
    , KingOfEthResourcesInterfaceReferencer&#13;
    , KingOfEthRoadRealtyReferencer&#13;
    , KingOfEthRoadsAbstractInterface&#13;
{&#13;
    /// @dev ETH cost to build a road&#13;
    uint public roadCost = 0.0002 ether;&#13;
&#13;
    /// @dev Mapping from the x, y, direction coordinate of the location to its owner&#13;
    mapping (uint =&gt; mapping (uint =&gt; address[2])) owners;&#13;
&#13;
    /// @dev Mapping from a players address to his road counts&#13;
    mapping (address =&gt; uint) roadCounts;&#13;
&#13;
    /// @param _boardContract The address of the board contract&#13;
    /// @param _roadRealtyContract The address of the road realty contract&#13;
    /// @param _kingOfEthContract The address of the king contract&#13;
    /// @param _interfaceContract The address of the resources&#13;
    ///  interface contract&#13;
    constructor(&#13;
          address _boardContract&#13;
        , address _roadRealtyContract&#13;
        , address _kingOfEthContract&#13;
        , address _interfaceContract&#13;
    )&#13;
        public&#13;
    {&#13;
        boardContract      = _boardContract;&#13;
        roadRealtyContract = _roadRealtyContract;&#13;
        kingOfEthContract  = _kingOfEthContract;&#13;
        interfaceContract  = _interfaceContract;&#13;
    }&#13;
&#13;
    /// @dev Fired when new roads are built&#13;
    event NewRoads(&#13;
          address owner&#13;
        , uint x&#13;
        , uint y&#13;
        , uint8 direction&#13;
        , uint length&#13;
    );&#13;
&#13;
    /// @dev Fired when a road is sent from one player to another&#13;
    event SentRoad(&#13;
          uint x&#13;
        , uint y&#13;
        , uint direction&#13;
        , address from&#13;
        , address to&#13;
    );&#13;
&#13;
    /// @dev Get the owner of the road at some location&#13;
    /// @param _x The x coordinate of the road&#13;
    /// @param _y The y coordinate of the road&#13;
    /// @param _direction The direction of the road (either&#13;
    ///  0 for right or 1 for down)&#13;
    /// @return The address of the owner&#13;
    function ownerOf(uint _x, uint _y, uint8 _direction)&#13;
        public&#13;
        view&#13;
        returns(address)&#13;
    {&#13;
        // Only 0 or 1 is a valid direction&#13;
        require(2 &gt; _direction);&#13;
&#13;
        return owners[_x][_y][_direction];&#13;
    }&#13;
&#13;
    /// @dev Get the number of roads owned by a player&#13;
    /// @param _player The player's address&#13;
    /// @return The number of roads&#13;
    function numberOfRoads(address _player) public view returns(uint)&#13;
    {&#13;
        return roadCounts[_player];&#13;
    }&#13;
&#13;
    /// @dev Only the owner of a road can run this&#13;
    /// @param _x The x coordinate of the road&#13;
    /// @param _y The y coordinate of the road&#13;
    /// @param _direction The direction of the road&#13;
    modifier onlyRoadOwner(uint _x, uint _y, uint8 _direction)&#13;
    {&#13;
        require(owners[_x][_y][_direction] == msg.sender);&#13;
        _;&#13;
    }&#13;
&#13;
    /// @dev Build houses to the right&#13;
    /// @param _x The x coordinate of the starting point of the first road&#13;
    /// @param _y The y coordinate of the starting point of the first road&#13;
    /// @param _length The length to build&#13;
    function buildRight(uint _x, uint _y, uint _length) private&#13;
    {&#13;
        // Require that nobody currently owns the road&#13;
        require(0x0 == owners[_x][_y][0]);&#13;
&#13;
        KingOfEthHousesAbstractInterface _housesContract = KingOfEthHousesAbstractInterface(housesContract);&#13;
&#13;
        // Require that either the player owns the house at the&#13;
        // starting location, the road below it, the road to the&#13;
        // left of it, or the road above it&#13;
        address _houseOwner = _housesContract.ownerOf(_x, _y);&#13;
        require(_houseOwner == msg.sender || (0x0 == _houseOwner &amp;&amp; (&#13;
               owners[_x][_y][1] == msg.sender&#13;
            || owners[_x - 1][_y][0] == msg.sender&#13;
            || owners[_x][_y - 1][1] == msg.sender&#13;
        )));&#13;
&#13;
        // Set the new owner&#13;
        owners[_x][_y][0] = msg.sender;&#13;
&#13;
        for(uint _i = 1; _i &lt; _length; ++_i)&#13;
        {&#13;
            // Require that nobody currently owns the road&#13;
            require(0x0 == owners[_x + _i][_y][0]);&#13;
&#13;
            // Require that either the house location is empty or&#13;
            // that it is owned by the player&#13;
            require(&#13;
                   _housesContract.ownerOf(_x + _i, _y) == 0x0&#13;
                || _housesContract.ownerOf(_x + _i, _y) == msg.sender&#13;
            );&#13;
&#13;
            // Set the new owner&#13;
            owners[_x + _i][_y][0] = msg.sender;&#13;
        }&#13;
    }&#13;
&#13;
    /// @dev Build houses downwards&#13;
    /// @param _x The x coordinate of the starting point of the first road&#13;
    /// @param _y The y coordinate of the starting point of the first road&#13;
    /// @param _length The length to build&#13;
    function buildDown(uint _x, uint _y, uint _length) private&#13;
    {&#13;
        // Require that nobody currently owns the road&#13;
        require(0x0 == owners[_x][_y][1]);&#13;
&#13;
        KingOfEthHousesAbstractInterface _housesContract = KingOfEthHousesAbstractInterface(housesContract);&#13;
&#13;
        // Require that either the player owns the house at the&#13;
        // starting location, the road to the right of it, the road to&#13;
        // the left of it, or the road above it&#13;
        address _houseOwner = _housesContract.ownerOf(_x, _y);&#13;
        require(_houseOwner == msg.sender || (0x0 == _houseOwner &amp;&amp; (&#13;
               owners[_x][_y][0] == msg.sender&#13;
            || owners[_x - 1][_y][0] == msg.sender&#13;
            || owners[_x][_y - 1][1] == msg.sender&#13;
        )));&#13;
&#13;
        // Set the new owner&#13;
        owners[_x][_y][1] = msg.sender;&#13;
&#13;
        for(uint _i = 1; _i &lt; _length; ++_i)&#13;
        {&#13;
            // Require that nobody currently owns the road&#13;
            require(0x0 == owners[_x][_y + _i][1]);&#13;
&#13;
            // Require that either the house location is empty or&#13;
            // that it is owned by the player&#13;
            require(&#13;
                   _housesContract.ownerOf(_x, _y + _i) == 0x0&#13;
                || _housesContract.ownerOf(_x, _y + _i) == msg.sender&#13;
            );&#13;
&#13;
            // Set the new owner&#13;
            owners[_x][_y + _i][1] = msg.sender;&#13;
        }&#13;
    }&#13;
&#13;
    /// @dev Build houses to the left&#13;
    /// @param _x The x coordinate of the starting point of the first road&#13;
    /// @param _y The y coordinate of the starting point of the first road&#13;
    /// @param _length The length to build&#13;
    function buildLeft(uint _x, uint _y, uint _length) private&#13;
    {&#13;
        // Require that nobody currently owns the road&#13;
        require(0x0 == owners[_x - 1][_y][0]);&#13;
&#13;
        KingOfEthHousesAbstractInterface _housesContract = KingOfEthHousesAbstractInterface(housesContract);&#13;
&#13;
        // Require that either the player owns the house at the&#13;
        // starting location, the road to the right of it, the road&#13;
        // below it, or the road above it&#13;
        address _houseOwner = _housesContract.ownerOf(_x, _y);&#13;
        require(_houseOwner == msg.sender || (0x0 == _houseOwner &amp;&amp; (&#13;
               owners[_x][_y][0] == msg.sender&#13;
            || owners[_x][_y][1] == msg.sender&#13;
            || owners[_x][_y - 1][1] == msg.sender&#13;
        )));&#13;
&#13;
        // Set the new owner&#13;
        owners[_x - 1][_y][0] = msg.sender;&#13;
&#13;
        for(uint _i = 1; _i &lt; _length; ++_i)&#13;
        {&#13;
            // Require that nobody currently owns the road&#13;
            require(0x0 == owners[_x - _i - 1][_y][0]);&#13;
&#13;
            // Require that either the house location is empty or&#13;
            // that it is owned by the player&#13;
            require(&#13;
                   _housesContract.ownerOf(_x - _i, _y) == 0x0&#13;
                || _housesContract.ownerOf(_x - _i, _y) == msg.sender&#13;
            );&#13;
&#13;
            // Set the new owner&#13;
            owners[_x - _i - 1][_y][0] = msg.sender;&#13;
        }&#13;
    }&#13;
&#13;
    /// @dev Build houses upwards&#13;
    /// @param _x The x coordinate of the starting point of the first road&#13;
    /// @param _y The y coordinate of the starting point of the first road&#13;
    /// @param _length The length to build&#13;
    function buildUp(uint _x, uint _y, uint _length) private&#13;
    {&#13;
        // Require that nobody currently owns the road&#13;
        require(0x0 == owners[_x][_y - 1][1]);&#13;
&#13;
        KingOfEthHousesAbstractInterface _housesContract = KingOfEthHousesAbstractInterface(housesContract);&#13;
&#13;
        // Require that either the player owns the house at the&#13;
        // starting location, the road to the right of it, the road&#13;
        // below it, or the road to the left of it&#13;
        address _houseOwner = _housesContract.ownerOf(_x, _y);&#13;
        require(_houseOwner == msg.sender || (0x0 == _houseOwner &amp;&amp; (&#13;
               owners[_x][_y][0] == msg.sender&#13;
            || owners[_x][_y][1] == msg.sender&#13;
            || owners[_x - 1][_y][0] == msg.sender&#13;
        )));&#13;
&#13;
        // Set the new owner&#13;
        owners[_x][_y - 1][1] = msg.sender;&#13;
&#13;
        for(uint _i = 1; _i &lt; _length; ++_i)&#13;
        {&#13;
            // Require that nobody currently owns the road&#13;
            require(0x0 == owners[_x][_y - _i - 1][1]);&#13;
&#13;
            // Require that either the house location is empty or&#13;
            // that it is owned by the player&#13;
            require(&#13;
                   _housesContract.ownerOf(_x, _y - _i) == 0x0&#13;
                || _housesContract.ownerOf(_x, _y - _i) == msg.sender&#13;
            );&#13;
&#13;
            // Set the new owner&#13;
            owners[_x][_y - _i - 1][1] = msg.sender;&#13;
        }&#13;
    }&#13;
&#13;
    /// @dev God can change the road cost&#13;
    /// @param _newRoadCost The new cost of a road&#13;
    function godChangeRoadCost(uint _newRoadCost)&#13;
        public&#13;
        onlyGod&#13;
    {&#13;
        roadCost = _newRoadCost;&#13;
    }&#13;
&#13;
    /// @dev The road realty contract can transfer road ownership&#13;
    /// @param _x The x coordinate of the road&#13;
    /// @param _y The y coordinate of the road&#13;
    /// @param _direction The direction of the road&#13;
    /// @param _from The previous owner of road&#13;
    /// @param _to The new owner of road&#13;
    function roadRealtyTransferOwnership(&#13;
          uint _x&#13;
        , uint _y&#13;
        , uint8 _direction&#13;
        , address _from&#13;
        , address _to&#13;
    )&#13;
        public&#13;
        onlyRoadRealtyContract&#13;
    {&#13;
        // Assert that the previous owner still has the road&#13;
        assert(owners[_x][_y][_direction] == _from);&#13;
&#13;
        // Set the new owner&#13;
        owners[_x][_y][_direction] = _to;&#13;
&#13;
        // Update the road counts&#13;
        --roadCounts[_from];&#13;
        ++roadCounts[_to];&#13;
    }&#13;
&#13;
    /// @dev Build a road in a direction from a location&#13;
    /// @param _x The x coordinate of the starting location&#13;
    /// @param _y The y coordinate of the starting location&#13;
    /// @param _direction The direction to build (right is 0, down is 1,&#13;
    ///  2 is left, and 3 is up)&#13;
    /// @param _length The number of roads to build&#13;
    function buildRoads(&#13;
          uint _x&#13;
        , uint _y&#13;
        , uint8 _direction&#13;
        , uint _length&#13;
    )&#13;
        public&#13;
        payable&#13;
    {&#13;
        // Require at least one road to be built&#13;
        require(0 &lt; _length);&#13;
&#13;
        // Require that the cost for each road was payed&#13;
        require(roadCost * _length == msg.value);&#13;
&#13;
        KingOfEthBoard _boardContract = KingOfEthBoard(boardContract);&#13;
&#13;
        // Require that the start is within bounds&#13;
        require(_boardContract.boundX1() &lt;= _x);&#13;
        require(_boardContract.boundY1() &lt;= _y);&#13;
        require(_boardContract.boundX2() &gt; _x);&#13;
        require(_boardContract.boundY2() &gt; _y);&#13;
&#13;
        // Burn the resource costs for each road&#13;
        KingOfEthResourcesInterface(interfaceContract).burnRoadCosts(&#13;
              _length&#13;
            , msg.sender&#13;
        );&#13;
&#13;
        // If the direction is right&#13;
        if(0 == _direction)&#13;
        {&#13;
            // Require that the roads will be in bounds&#13;
            require(_boardContract.boundX2() &gt; _x + _length);&#13;
&#13;
            buildRight(_x, _y, _length);&#13;
        }&#13;
        // If the direction is down&#13;
        else if(1 == _direction)&#13;
        {&#13;
            // Require that the roads will be in bounds&#13;
            require(_boardContract.boundY2() &gt; _y + _length);&#13;
&#13;
            buildDown(_x, _y, _length);&#13;
        }&#13;
        // If the direction is left&#13;
        else if(2 == _direction)&#13;
        {&#13;
            // Require that the roads will be in bounds&#13;
            require(_boardContract.boundX1() &lt; _x - _length - 1);&#13;
&#13;
            buildLeft(_x, _y, _length);&#13;
        }&#13;
        // If the direction is up&#13;
        else if(3 == _direction)&#13;
        {&#13;
            // Require that the roads will be in bounds&#13;
            require(_boardContract.boundY1() &lt; _y - _length - 1);&#13;
&#13;
            buildUp(_x, _y, _length);&#13;
        }&#13;
        else&#13;
        {&#13;
            // Revert if the direction is invalid&#13;
            revert();&#13;
        }&#13;
&#13;
        // Update the number of roads of the player&#13;
        roadCounts[msg.sender] += _length;&#13;
&#13;
        // Pay taxes&#13;
        KingOfEthAbstractInterface(kingOfEthContract).payTaxes.value(msg.value)();&#13;
&#13;
        emit NewRoads(msg.sender, _x, _y, _direction, _length);&#13;
    }&#13;
&#13;
    /// @dev Send a road to another player&#13;
    /// @param _x The x coordinate of the road&#13;
    /// @param _y The y coordinate of the road&#13;
    /// @param _direction The direction of the road&#13;
    /// @param _to The recipient of the road&#13;
    function sendRoad(uint _x, uint _y, uint8 _direction, address _to)&#13;
        public&#13;
        onlyRoadOwner(_x, _y, _direction)&#13;
    {&#13;
        // Set the new owner&#13;
        owners[_x][_y][_direction] = _to;&#13;
&#13;
        // Update road counts&#13;
        --roadCounts[msg.sender];&#13;
        ++roadCounts[_to];&#13;
&#13;
        // Cancel any sales that exist&#13;
        KingOfEthRoadRealty(roadRealtyContract).roadsCancelRoadSale(&#13;
              _x&#13;
            , _y&#13;
            , _direction&#13;
        );&#13;
&#13;
        emit SentRoad(_x, _y, _direction, msg.sender, _to);&#13;
    }&#13;
}&#13;
&#13;
// File: contracts/KingOfEth.sol&#13;
&#13;
/****************************************************&#13;
 *&#13;
 * Copyright 2018 BurzNest LLC. All rights reserved.&#13;
 *&#13;
 * The contents of this file are provided for review&#13;
 * and educational purposes ONLY. You MAY NOT use,&#13;
 * copy, distribute, or modify this software without&#13;
 * explicit written permission from BurzNest LLC.&#13;
 *&#13;
 ****************************************************/&#13;
&#13;
pragma solidity ^0.4.24;&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
/// @title King of Eth&#13;
/// @author Anthony Burzillo &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="cdafb8bfb78dafb8bfb7a3a8beb9e3aea2a0">[email protected]</a>&gt;&#13;
/// @dev Contract for titles, and taxes&#13;
contract KingOfEth is&#13;
      GodMode&#13;
    , KingOfEthHousesReferencer&#13;
    , KingOfEthRoadsReferencer&#13;
    , KingOfEthResourcesInterfaceReferencer&#13;
{&#13;
    /// @dev Number used to divide the taxes to yield the King's share&#13;
    uint public constant kingsTaxDivisor = 5;&#13;
&#13;
    /// @dev Number used to divide the taxes to yield the Wayfarer's share&#13;
    uint public constant wayfarersTaxDivisor = 20;&#13;
&#13;
    /// @dev Number used to divide the taxes to yield Parliament's share&#13;
    uint public constant parliamentsTaxDivisor = 4;&#13;
&#13;
    /// @dev Amount of time the King, Wayfarer, and Paliament must wait&#13;
    ///  between claiming/distributing their taxes&#13;
    uint public constant timeBetweenClaims = 2 weeks;&#13;
&#13;
    /// @dev Amount of time the King or Parliement has to claim/distribute&#13;
    ///  their taxes before the other side is able to overthrow them&#13;
    uint public constant gracePeriod = 1 days;&#13;
&#13;
    /// @dev The address of the current King&#13;
    address public king;&#13;
&#13;
    /// @dev The amount of taxes currently reserved for the King&#13;
    uint public kingsTaxes;&#13;
&#13;
    /// @dev The last time that the King claimed his taxes&#13;
    uint public kingsTaxesLastClaimed;&#13;
&#13;
    /// @dev The address of the current Wayfarer&#13;
    address public wayfarer;&#13;
&#13;
    /// @dev The amount of taxes currently reserved for the Wayfarer&#13;
    uint public wayfarersTaxes;&#13;
&#13;
    /// @dev The last time that the Wayfarer claimed his taxes&#13;
    uint public wayfarersTaxesLastClaimed;&#13;
&#13;
    /// @dev Relevant data for each seat of Parliament&#13;
    struct ParliamentSeatData {&#13;
        /// @dev The number of resource points the seat holds&#13;
        uint points;&#13;
&#13;
        /// @dev The amount of unclaimed taxes the seat has&#13;
        ///  and can claim at any time&#13;
        uint unclaimedTaxes;&#13;
    }&#13;
&#13;
    /// @dev The 10 seats of Parliament&#13;
    address[10] public parliamentSeats;&#13;
&#13;
    /// @dev Mapping from an arbitrary address to data about a seat&#13;
    ///  of Parliament (this data exists only for the current seats)&#13;
    mapping (address =&gt; ParliamentSeatData) parliamentSeatData;&#13;
&#13;
    /// @dev The number of taxes currently reserved for Parliament&#13;
    uint public parliamentsTaxes;&#13;
&#13;
    /// @dev The last time that Parliament's taxes were distributed&#13;
    uint public parliamentsTaxesLastDistributed;&#13;
&#13;
    /// @param _interfaceContract The address for the resources&#13;
    ///  interface contract&#13;
    constructor(address _interfaceContract) public&#13;
    {&#13;
        interfaceContract = _interfaceContract;&#13;
&#13;
        // Game is paused as God must start it&#13;
        isPaused = true;&#13;
    }&#13;
&#13;
    /// @dev Fired when the King's taxes are claimed&#13;
    event KingsTaxesClaimed(address king, uint claimedTime);&#13;
&#13;
    /// @dev Fired when the Wayfarer's taxes are claimed&#13;
    event WayfarersTaxesClaimed(address wayfarer, uint claimedTime);&#13;
&#13;
    /// @dev Fired when a seat in Parliament claims their&#13;
    ///  unclaimed taxes&#13;
    event ParliamentTaxesClaimed(address seat);&#13;
&#13;
    /// @dev Fired when a new King claims the throne&#13;
    event NewKing(address king);&#13;
&#13;
    /// @dev Fired when a new Wayfarer claims the title&#13;
    event NewWayfarer(address wayfarer);&#13;
&#13;
    /// @dev Fired when a player claims a seat in Parliament&#13;
    event ParliamentSeatClaimed(address seat, uint points);&#13;
&#13;
    /// @dev Fired when a successful inquest is made against a&#13;
    ///  seat of Parliament&#13;
    event ParliamentInquest(address seat, uint points);&#13;
&#13;
    /// @dev Fired when Parliament's taxes are distributed&#13;
    event ParliamentsTaxesDistributed(&#13;
          address distributor&#13;
        , uint share&#13;
        , uint distributedTime&#13;
    );&#13;
&#13;
    /// @dev Fired when Parliament is overthrown by the king&#13;
    event ParliamentOverthrown(uint overthrownTime);&#13;
&#13;
    /// @dev Fired when the King is overthrown by Parliament&#13;
    event KingOverthrown(uint overthrownTime);&#13;
&#13;
    /// @dev Only the King can run this&#13;
    modifier onlyKing()&#13;
    {&#13;
        require(king == msg.sender);&#13;
        _;&#13;
    }&#13;
&#13;
    /// @dev Only the Wayfarer can run this&#13;
    modifier onlyWayfarer()&#13;
    {&#13;
        require(wayfarer == msg.sender);&#13;
        _;&#13;
    }&#13;
&#13;
    /// @dev Only a Parliament seat can run this&#13;
    modifier onlyParliamentSeat()&#13;
    {&#13;
        require(0 != parliamentSeatData[msg.sender].points);&#13;
        _;&#13;
    }&#13;
&#13;
    /// @dev God can withdraw his taxes&#13;
    function godWithdrawTaxes()&#13;
        public&#13;
        onlyGod&#13;
    {&#13;
        // Add up each Parliament seat's unclaimed taxes&#13;
        uint _parliamentsUnclaimed = 0;&#13;
        for(uint8 _i = 0; _i &lt; 10; ++_i)&#13;
        {&#13;
            _parliamentsUnclaimed += parliamentSeatData[parliamentSeats[_i]].unclaimedTaxes;&#13;
        }&#13;
&#13;
        // God's share is the balance minus the king's, the wayfarer's,&#13;
        //  Parliament's, as well as any of Parliament's seat's unclaimed taxes&#13;
        uint taxes = address(this).balance - kingsTaxes - wayfarersTaxes&#13;
                   - parliamentsTaxes - _parliamentsUnclaimed;&#13;
&#13;
        god.transfer(taxes);&#13;
    }&#13;
&#13;
    /// @dev God can start the game&#13;
    function godStartGame() public onlyGod&#13;
    {&#13;
        // Reset time title taxes were last claimed&#13;
        kingsTaxesLastClaimed           = now;&#13;
        wayfarersTaxesLastClaimed       = now;&#13;
        parliamentsTaxesLastDistributed = now;&#13;
&#13;
        // Unpause the game&#13;
        isPaused = false;&#13;
    }&#13;
&#13;
    /// @dev The King can claim his taxes&#13;
    function kingWithdrawTaxes()&#13;
        public&#13;
        onlyKing&#13;
    {&#13;
        // Require that enought time has passed since the King's last claim&#13;
        require(kingsTaxesLastClaimed + timeBetweenClaims &lt; now);&#13;
&#13;
        // The last claim time is now&#13;
        kingsTaxesLastClaimed = now;&#13;
&#13;
        // Temporarily save the King's taxes&#13;
        uint _taxes = kingsTaxes;&#13;
&#13;
        // Reset the King's taxes&#13;
        kingsTaxes = 0;&#13;
&#13;
        king.transfer(_taxes);&#13;
&#13;
        emit KingsTaxesClaimed(msg.sender, now);&#13;
    }&#13;
&#13;
    /// @dev The Wayfarer can claim his taxes&#13;
    function wayfarerWithdrawTaxes()&#13;
        public&#13;
        onlyWayfarer&#13;
    {&#13;
        // Require that enough time has passed since the Wayfarer's last claim&#13;
        require(wayfarersTaxesLastClaimed + timeBetweenClaims &lt; now);&#13;
&#13;
        // The last claim time is now&#13;
        wayfarersTaxesLastClaimed = now;&#13;
&#13;
        // Temporarily save the Wayfarer's taxes&#13;
        uint _taxes = wayfarersTaxes;&#13;
&#13;
        // Reset the Wayfarer's taxes&#13;
        wayfarersTaxes = 0;&#13;
&#13;
        wayfarer.transfer(_taxes);&#13;
&#13;
        emit WayfarersTaxesClaimed(msg.sender, now);&#13;
    }&#13;
&#13;
    /// @dev A seat of Parliament can withdraw any unclaimed taxes&#13;
    function parliamentWithdrawTaxes()&#13;
        public&#13;
    {&#13;
        // Lookup the data on the sender&#13;
        ParliamentSeatData storage _senderData = parliamentSeatData[msg.sender];&#13;
&#13;
        // If the sender does indeed have unclaimed taxes&#13;
        if(0 != _senderData.unclaimedTaxes)&#13;
        {&#13;
            // Temporarily save the taxes&#13;
            uint _taxes = _senderData.unclaimedTaxes;&#13;
&#13;
            // Mark the taxes as claimed&#13;
            _senderData.unclaimedTaxes = 0;&#13;
&#13;
            // Send the sender the unclaimed taxes&#13;
            msg.sender.transfer(_taxes);&#13;
        }&#13;
&#13;
        emit ParliamentTaxesClaimed(msg.sender);&#13;
    }&#13;
&#13;
    /// @dev Claim the King's throne&#13;
    function claimThrone() public&#13;
    {&#13;
        KingOfEthHouses _housesContract = KingOfEthHouses(housesContract);&#13;
&#13;
        // Require the claimant to have more points than the King&#13;
        require(_housesContract.numberOfPoints(king) &lt; _housesContract.numberOfPoints(msg.sender));&#13;
&#13;
        // Save the new King&#13;
        king = msg.sender;&#13;
&#13;
        emit NewKing(msg.sender);&#13;
    }&#13;
&#13;
    /// @dev Claim the Wayfarer's title&#13;
    function claimWayfarerTitle() public&#13;
    {&#13;
        KingOfEthRoads _roadsContract = KingOfEthRoads(roadsContract);&#13;
&#13;
        // Require the claimant to have more roads than the wayfarer&#13;
        require(_roadsContract.numberOfRoads(wayfarer) &lt; _roadsContract.numberOfRoads(msg.sender));&#13;
&#13;
        // Save the new Wayfarer&#13;
        wayfarer = msg.sender;&#13;
&#13;
        emit NewWayfarer(msg.sender);&#13;
    }&#13;
&#13;
    /// @dev Claim a seat in Parliament&#13;
    function claimParliamentSeat() public&#13;
    {&#13;
        // Lookup the sender's data&#13;
        ParliamentSeatData storage _senderData = parliamentSeatData[msg.sender];&#13;
&#13;
        // If the sender is not already in Parliament&#13;
        if(0 == _senderData.points)&#13;
        {&#13;
            // Determine the points of the sender&#13;
            uint _points&#13;
                = KingOfEthResourcesInterface(interfaceContract).lookupResourcePoints(msg.sender);&#13;
&#13;
            // Lookup the lowest seat in parliament (the last seat)&#13;
            ParliamentSeatData storage _lastSeat = parliamentSeatData[parliamentSeats[9]];&#13;
&#13;
            // If the lowest ranking seat has fewer points than the sender&#13;
            if(_lastSeat.points &lt; _points)&#13;
            {&#13;
                // If the lowest ranking seat has unclaimed taxes&#13;
                if(0 != _lastSeat.unclaimedTaxes)&#13;
                {&#13;
                    // Put them back into Parliament's pool&#13;
                    parliamentsTaxes += _lastSeat.unclaimedTaxes;&#13;
                }&#13;
&#13;
                // Delete the lowest seat's data&#13;
                delete parliamentSeatData[parliamentSeats[9]];&#13;
&#13;
                // Record the sender's points&#13;
                _senderData.points = _points;&#13;
&#13;
                // Record the new seat's temporary standing&#13;
                parliamentSeats[_i] = msg.sender;&#13;
&#13;
                uint8 _i;&#13;
&#13;
                // Move the new seat up until they are in the correct position&#13;
                for(_i = 8; _i &gt;= 0; --_i)&#13;
                {&#13;
                    // If the seat above has fewer points than the new seat&#13;
                    if(parliamentSeatData[parliamentSeats[_i]].points &lt; _points)&#13;
                    {&#13;
                        // Move the seat above down&#13;
                        parliamentSeats[_i + 1] = parliamentSeats[_i];&#13;
                    }&#13;
                    else&#13;
                    {&#13;
                        // We have found the new seat's position&#13;
                        parliamentSeats[_i] = msg.sender;&#13;
&#13;
                        break;&#13;
                    }&#13;
                }&#13;
&#13;
                emit ParliamentSeatClaimed(msg.sender, _points);&#13;
            }&#13;
        }&#13;
    }&#13;
&#13;
    /// @dev Question the standing of a current seat in Parliament&#13;
    /// @param _seat The seat to run the inquest on&#13;
    function parliamentInquest(address _seat) public&#13;
    {&#13;
        // Grab the seat's data&#13;
        ParliamentSeatData storage _seatData = parliamentSeatData[_seat];&#13;
&#13;
        // Ensure that the account in question is actually in Parliament&#13;
        if(0 != _seatData.points)&#13;
        {&#13;
            // Determine the current points held by the seat&#13;
            uint _newPoints&#13;
                = KingOfEthResourcesInterface(interfaceContract).lookupResourcePoints(_seat);&#13;
&#13;
            uint _i;&#13;
&#13;
            // If the seat has more points than before&#13;
            if(_seatData.points &lt; _newPoints)&#13;
            {&#13;
                // Find the seat's current location&#13;
                _i = 9;&#13;
                while(_seat != parliamentSeats[_i])&#13;
                {&#13;
                    --_i;&#13;
                }&#13;
&#13;
                // For each seat higher than the seat in question&#13;
                for(; _i &gt; 0; --_i)&#13;
                {&#13;
                    // If the higher seat has fewer points than the seat in question&#13;
                    if(parliamentSeatData[parliamentSeats[_i - 1]].points &lt; _newPoints)&#13;
                    {&#13;
                        // Move the seat back&#13;
                        parliamentSeats[_i] = parliamentSeats[_i - 1];&#13;
                    }&#13;
                    else&#13;
                    {&#13;
                        // Record the seat's (new) position&#13;
                        parliamentSeats[_i] = _seat;&#13;
&#13;
                        break;&#13;
                    }&#13;
                }&#13;
            }&#13;
            // If the seat has the same number of points&#13;
            else if(_seatData.points == _newPoints)&#13;
            {&#13;
                revert();&#13;
            }&#13;
            // If the seat has fewer points than before&#13;
            else&#13;
            {&#13;
                // Find the seat's current position&#13;
                _i = 0;&#13;
                while(_seat != parliamentSeats[_i])&#13;
                {&#13;
                    ++_i;&#13;
                }&#13;
&#13;
                // For each seat lower than the seat in question&#13;
                for(; _i &lt; 10; ++_i)&#13;
                {&#13;
                    // If the lower seat has more points than the seat in question&#13;
                    if(parliamentSeatData[parliamentSeats[_i + 1]].points &gt; _newPoints)&#13;
                    {&#13;
                        // Move the lower seat up&#13;
                        parliamentSeats[_i] = parliamentSeats[_i + 1];&#13;
                    }&#13;
                    else&#13;
                    {&#13;
                        // Record the seat's (new) position&#13;
                        parliamentSeats[_i] = _seat;&#13;
&#13;
                        break;&#13;
                    }&#13;
                }&#13;
            }&#13;
&#13;
            // Save the seat in question's points&#13;
            _seatData.points = _newPoints;&#13;
&#13;
            emit ParliamentInquest(_seat, _newPoints);&#13;
        }&#13;
    }&#13;
&#13;
    /// @dev Distribute the taxes set aside for Parliament to&#13;
    ///  the seats of Parliament&#13;
    function distributeParliamentTaxes()&#13;
        public&#13;
        onlyParliamentSeat&#13;
    {&#13;
        // Require enough time has passed since Parliament's last taxes&#13;
        // were distributed&#13;
        require(parliamentsTaxesLastDistributed + timeBetweenClaims &lt; now);&#13;
&#13;
        // Determine the share for each seat of Parliament (plus an additional&#13;
        // share for the distributor)&#13;
        uint _share = parliamentsTaxes / 11;&#13;
&#13;
        // Calculate the distributor's share&#13;
        uint _distributorsShare = parliamentsTaxes - _share * 9;&#13;
&#13;
        // Reset Parliament's claimable taxes&#13;
        parliamentsTaxes = 0;&#13;
&#13;
        // For each seat of Parliament&#13;
        for(uint8 _i = 0; _i &lt; 10; ++_i)&#13;
        {&#13;
            // If the distributor is not the seat in question&#13;
            if(msg.sender != parliamentSeats[_i])&#13;
            {&#13;
                // Add the share to the seat's unclaimedTaxes&#13;
                parliamentSeatData[parliamentSeats[_i]].unclaimedTaxes += _share;&#13;
            }&#13;
        }&#13;
&#13;
        // Set the last time the taxes were distributed to now&#13;
        parliamentsTaxesLastDistributed = now;&#13;
&#13;
        // Send the distributor their double share&#13;
        msg.sender.transfer(_distributorsShare);&#13;
&#13;
        emit ParliamentsTaxesDistributed(msg.sender, _share, now);&#13;
    }&#13;
&#13;
    /// @dev If the grace period has elapsed, the king can overthrow&#13;
    ///  Parliament and claim their taxes&#13;
    function overthrowParliament()&#13;
        public&#13;
        onlyKing&#13;
    {&#13;
        // Require that the time between claims plus&#13;
        //  the grace period has elapsed&#13;
        require(parliamentsTaxesLastDistributed + timeBetweenClaims + gracePeriod &lt; now);&#13;
&#13;
        // The king can now claim Parliament's taxes as well&#13;
        kingsTaxes += parliamentsTaxes;&#13;
&#13;
        // Parliament has lost their taxes&#13;
        parliamentsTaxes = 0;&#13;
&#13;
        // Parliament must wait before distributing their taxes again&#13;
        parliamentsTaxesLastDistributed = now;&#13;
&#13;
        emit ParliamentOverthrown(now);&#13;
    }&#13;
&#13;
    /// @dev If the grace period has elapsed, Parliament can overthrow&#13;
    ///  the king and claim his taxes&#13;
    function overthrowKing()&#13;
        public&#13;
        onlyParliamentSeat&#13;
    {&#13;
        // Require the time between claims plus&#13;
        // the grace period has elapsed&#13;
        require(kingsTaxesLastClaimed + timeBetweenClaims + gracePeriod &lt; now);&#13;
&#13;
        // Parliament can now claim the King's taxes as well&#13;
        parliamentsTaxes += kingsTaxes;&#13;
&#13;
        // The King has lost his taxes&#13;
        kingsTaxes = 0;&#13;
&#13;
        // The King must wait before claiming his taxes again&#13;
        kingsTaxesLastClaimed = now;&#13;
&#13;
        emit KingOverthrown(now);&#13;
    }&#13;
&#13;
    /// @dev Anyone can pay taxes&#13;
    function payTaxes() public payable&#13;
    {&#13;
        // Add the King's share&#13;
        kingsTaxes += msg.value / kingsTaxDivisor;&#13;
&#13;
        // Add the Wayfarer's share&#13;
        wayfarersTaxes += msg.value / wayfarersTaxDivisor;&#13;
&#13;
        // Add Parliament's share&#13;
        parliamentsTaxes += msg.value / parliamentsTaxDivisor;&#13;
    }&#13;
}