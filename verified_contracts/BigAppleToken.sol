pragma solidity ^0.4.23;
// produced by the Solididy File Flattener (c) David Appleton 2018
// contact : <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="5c383d2a391c3d3733313e3d723f3331">[emailÂ protected]</a>&#13;
// released under Apache 2.0 licence&#13;
contract Owned {&#13;
&#13;
    address public owner;&#13;
&#13;
    constructor() public {&#13;
        owner = msg.sender;&#13;
    }&#13;
&#13;
    modifier onlyOwner() {&#13;
        require(msg.sender == owner);&#13;
        _;&#13;
    }&#13;
&#13;
    function setOwner(address _newOwner) public onlyOwner {&#13;
        emit onOwnershipTransferred(owner, _newOwner);&#13;
        owner = _newOwner; &#13;
    }&#13;
    &#13;
    event onOwnershipTransferred (address indexed _from, address indexed _to);&#13;
    &#13;
}&#13;
contract ERC20 {&#13;
    /* This is a slight change to the ERC20 vip standard.&#13;
    function totalSupply() constant returns (uint256 supply);&#13;
    is replaced with:&#13;
    uint256 public totalSupply;&#13;
    This automatically creates a getter function for the totalSupply.&#13;
    This is moved to the vip contract since public getter functions are not&#13;
    currently recognised as an implementation of the matching abstract&#13;
    function by the compiler.&#13;
    */&#13;
    /// total amount of tokens&#13;
    uint256 public totalSupply;&#13;
&#13;
    /// @param _owner The address from which the balance will be retrieved&#13;
    /// @return The balance&#13;
    function balanceOf(address _owner) public view returns (uint256 balance);&#13;
&#13;
    /// @notice send `_value` token to `_to` from `msg.sender`&#13;
    /// @param _to The address of the recipient&#13;
    /// @param _value The amount of token to be transferred&#13;
    /// @return Whether the transfer was successful or not&#13;
    function transfer(address _to, uint256 _value) public returns (bool success);&#13;
&#13;
    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`&#13;
    /// @param _from The address of the sender&#13;
    /// @param _to The address of the recipient&#13;
    /// @param _value The amount of token to be transferred&#13;
    /// @return Whether the transfer was successful or not&#13;
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);&#13;
&#13;
    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens&#13;
    /// @param _spender The address of the account able to transfer the tokens&#13;
    /// @param _value The amount of wei to be approved for transfer&#13;
    /// @return Whether the approval was successful or not&#13;
    function approve(address _spender, uint256 _value) public returns (bool success);&#13;
&#13;
    /// @param _owner The address of the account owning tokens&#13;
    /// @param _spender The address of the account able to transfer the tokens&#13;
    /// @return Amount of remaining tokens allowed to spent&#13;
    function allowance(address _owner, address _spender) public view returns (uint256 remaining);&#13;
&#13;
    event Transfer(address indexed _from, address indexed _to, uint256 _value);&#13;
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);&#13;
}&#13;
library SafeMath {&#13;
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
        uint256 c = a * b;&#13;
        assert(a == 0 || c / a == b);&#13;
        return c;&#13;
    }&#13;
&#13;
    function div(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
        // assert(b &gt; 0); // Solidity automatically throws when dividing by 0&#13;
        uint256 c = a / b;&#13;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold&#13;
        return c;&#13;
    }&#13;
&#13;
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
        assert(b &lt;= a);&#13;
        return a - b;&#13;
    }&#13;
&#13;
    function add(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
        uint256 c = a + b;&#13;
        assert(c &gt;= a);&#13;
        return c;&#13;
    }&#13;
&#13;
    function toUINT112(uint256 a) internal pure returns(uint112) {&#13;
        assert(uint112(a) == a);&#13;
        return uint112(a);&#13;
    }&#13;
&#13;
    function toUINT120(uint256 a) internal pure returns(uint120) {&#13;
        assert(uint120(a) == a);&#13;
        return uint120(a);&#13;
    }&#13;
&#13;
    function toUINT128(uint256 a) internal pure returns(uint128) {&#13;
        assert(uint128(a) == a);&#13;
        return uint128(a);&#13;
    }&#13;
}&#13;
&#13;
contract BigAppleToken is ERC20, Owned {&#13;
&#13;
    using SafeMath for uint256;&#13;
&#13;
    string public constant name    = "BigApple";        //The Token's name&#13;
    uint8 public constant decimals = 18;                //Number of decimals of the smallest unit&#13;
    string public constant symbol  = "BA";&#13;
    string public constant version = "v0.1";&#13;
&#13;
    bool public transferEnabled;&#13;
&#13;
    mapping (address =&gt; uint256) balances;&#13;
    mapping (address =&gt; mapping (address =&gt; uint256)) allowed;&#13;
&#13;
    /**&#13;
    * @dev Enable/disalbe the transferring of tokens of all addresses.&#13;
    * @param _enable Determines whether or not enable token transferring.&#13;
    */&#13;
    function enableTransfer(bool _enable) external onlyOwner {&#13;
        transferEnabled = _enable;&#13;
    }&#13;
    &#13;
    /**&#13;
    * @dev Transfer token to the specified address.&#13;
    * @param _to The address token will be transferred to.&#13;
    * @param _value The amout of token will be transferred.&#13;
    * @return Returns true if the transfer succeedes, otherwise false.&#13;
    */&#13;
    function transfer(address _to, uint256 _value) public returns (bool success) {&#13;
        &#13;
        // Not power items, transfer from the balance.&#13;
        require(transferEnabled);&#13;
&#13;
        //Default assumes totalSupply can't be over max (2^256 - 1).&#13;
        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.&#13;
        //Replace the if with this one instead.&#13;
        //if (balances[msg.sender] &gt;= _value &amp;&amp; balances[_to] + _value &gt; balances[_to]) {&#13;
        if (balances[msg.sender] &gt;= _value &amp;&amp; _value &gt; 0) {&#13;
&#13;
            balances[msg.sender] = balances[msg.sender].sub(_value);&#13;
            balances[_to] = balances[_to].add(_value);&#13;
            emit Transfer(msg.sender, _to, _value);&#13;
        }&#13;
    }&#13;
&#13;
    /**&#13;
    * @dev Transfer tokens from one address to another.&#13;
    * @param _from Address from which the sender want to transfer.&#13;
    * @param _to Address to which the send want to transfer.&#13;
    * @return Returns true if the transfer succeeds, otherwise false.&#13;
    */&#13;
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {&#13;
        require(transferEnabled);&#13;
        //same as above. Replace this line with the following if you want to protect against wrapping uints.&#13;
        //if (balances[_from] &gt;= _value &amp;&amp; allowed[_from][msg.sender] &gt;= _value &amp;&amp; balances[_to] + _value &gt; balances[_to]) {&#13;
        if (balances[_from] &gt;= _value &amp;&amp; allowed[_from][msg.sender] &gt;= _value &amp;&amp; _value &gt; 0) {&#13;
            balances[_to] += _value;&#13;
            balances[_from] -= _value;&#13;
            allowed[_from][msg.sender] -= _value;&#13;
            emit Transfer(_from, _to, _value);&#13;
            return true;&#13;
        } else {&#13;
            return false;&#13;
        }&#13;
    }&#13;
&#13;
    /**&#13;
    * @dev Gets the balance of the specified address.&#13;
    * @param _owner The address used to query the balance.&#13;
    * @return Returns the balance of the specified address.&#13;
    */&#13;
    function balanceOf(address _owner) public view returns (uint256 balance) {&#13;
        return balances[_owner];&#13;
    }&#13;
&#13;
    /**&#13;
    * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.&#13;
    * Beware that changing an allowance with this method brings the risk that someone may use both the old&#13;
    * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this&#13;
    * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:&#13;
    * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729&#13;
    * @param _spender The address which will spend the funds.&#13;
    * @param _value The amount of tokens to be spent.&#13;
    */&#13;
    function approve(address _spender, uint256 _value) public returns (bool success) {&#13;
        allowed[msg.sender][_spender] = _value;&#13;
        emit Approval(msg.sender, _spender, _value);&#13;
        return true;&#13;
    }&#13;
&#13;
    /**&#13;
    * @dev Get the remained amount of tokens the specified owner approved for the specifed spender.&#13;
    * @param _owner Address of the owner of the funds.&#13;
    * @param _spender Address of the approved spender.&#13;
    * @return A uint256 specifying the remained amount of tokens available for the spender.&#13;
    */&#13;
    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {&#13;
        return allowed[_owner][_spender];&#13;
    }&#13;
&#13;
    /* Approves and then calls the receiving contract */&#13;
    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {&#13;
        allowed[msg.sender][_spender] = _value;&#13;
        emit Approval(msg.sender, _spender, _value);&#13;
&#13;
        //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.&#13;
        //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)&#13;
        //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.&#13;
        //if(!_spender.call(bytes4(bytes32(sha3("receiveApproval(address,uint256,address,bytes)"))), msg.sender, _value, this, _extraData)) { revert(); }&#13;
        ApprovalReceiver(_spender).receiveApproval(msg.sender, _value, this, _extraData);&#13;
        return true;&#13;
    }&#13;
&#13;
    function mintToBalance(address _to, uint256 _amount) external onlyOwner {&#13;
&#13;
        require(_amount &gt;= 0);&#13;
&#13;
        balances[_to] = balances[_to].add(_amount);&#13;
        totalSupply = totalSupply.add(_amount);&#13;
&#13;
        // Emiting Transfer event so that wallets support ERC20 &#13;
        // can show the this minting(transferring) record to the user.&#13;
        emit Transfer(0, _to, _amount);&#13;
    }&#13;
&#13;
    function withdraw() external onlyOwner {&#13;
        owner.transfer(this.balance);&#13;
    }&#13;
&#13;
    function destroy() external onlyOwner {&#13;
        selfdestruct(owner);&#13;
    }&#13;
}&#13;
&#13;
contract ApprovalReceiver {&#13;
    function receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData) public;&#13;
}