pragma solidity 0.4.20;

contract ERC20 {
	function balanceOf(address who) public view returns (uint256);

	function transfer(address to, uint256 value) public returns (bool);

	function transferFrom(address _from, address _to, uint _value) external returns (bool);
}

contract Ownable {
	address public owner = 0x045dCD3419273C8BF7ca88563Fc25725Acf93Ae9;

	modifier onlyOwner() {
		require(msg.sender == owner);
		_;
	}
}


/**
 * @title Pausable
 * @dev Base contract which allows children to implement an emergency stop mechanism.
 */
contract Pausable is Ownable {
	event Pause();

	event Unpause();

	bool public paused = false;


	/**
		* @dev modifier to allow actions only when the contract IS paused
		*/
	modifier whenNotPaused() {
		require(!paused);
		_;
	}

	/**
		* @dev modifier to allow actions only when the contract IS NOT paused
		*/
	modifier whenPaused() {
		require(paused);
		_;
	}

	/**
		* @dev called by the owner to pause, triggers stopped state
		*/
	function pause() public onlyOwner whenNotPaused {
		paused = true;
		Pause();
	}

	/**
		* @dev called by the owner to unpause, returns to normal state
		*/
	function unpause() public onlyOwner whenPaused {
		paused = false;
		Unpause();
	}
}

/// @title Interface for contracts conforming to ERC-721: Non-Fungible Tokens
/// @author Dieter Shirley <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="543031203114352c3d3b392e313a7a373b">[email protected]</a>&gt; (https://github.com/dete)&#13;
contract ERC721 {&#13;
	// Required methods&#13;
	function totalSupply() public view returns (uint total);&#13;
&#13;
	function balanceOf(address owner) public view returns (uint balance);&#13;
&#13;
	function ownerOf(uint tokenId) external view returns (address owner);&#13;
&#13;
	function approve(address to, uint tokenId) external;&#13;
&#13;
	function transfer(address to, uint tokenId) public;&#13;
&#13;
	function transferFrom(address from, address to, uint tokenId) external;&#13;
&#13;
	// Events&#13;
	event Transfer(address indexed from, address indexed to, uint tokenId);&#13;
	event Approval(address indexed owner, address indexed approved, uint tokenId);&#13;
&#13;
	// Optional&#13;
	function name() public view returns (string);&#13;
&#13;
	function symbol() public view returns (string);&#13;
&#13;
	function tokensOfOwner(address owner) external view returns (uint[] tokenIds);&#13;
&#13;
	function tokenMetadata(uint tokenId, string preferredTransport) public view returns (string infoUrl);&#13;
&#13;
	// ERC-165 Compatibility (https://github.com/ethereum/EIPs/issues/165)&#13;
	function supportsInterface(bytes4 contractID) external view returns (bool);&#13;
}&#13;
&#13;
&#13;
contract ERC721Metadata {&#13;
	function getMetadata(uint tokenId, string preferredTransport) public view returns (bytes32[4] buffer, uint count);&#13;
}&#13;
&#13;
contract CryptoversePreorderBonusAssets is Pausable, ERC721 {&#13;
&#13;
	struct Item {&#13;
		ItemType typeId;&#13;
		ItemModel model;&#13;
		ItemManufacturer manufacturer;&#13;
		ItemRarity rarity;&#13;
		uint createTime;&#13;
		uint amount;&#13;
	}&#13;
&#13;
	enum ItemType {VRCBox, VCXVault, SaiHead, SaiBody, SaiEarrings, MechHead, MechBody, MechLegs, MechRailgun, MechMachineGun, MechRocketLauncher}&#13;
&#13;
	enum ItemModel {NC01, MK1, V1, V1_1, V2_1, M442_1, BG, Q3, TRFL405, BC, DES1, PlasmaS, BD, DRL, Casper, Kilo, Mega, Giga, Tera, Peta, Exa, EA}&#13;
&#13;
	enum ItemManufacturer {BTC, VRC, ETH, Satoshipowered}&#13;
&#13;
	enum ItemRarity {Common, Uncommon, Rare, Superior, Epic, Legendary, Unique}&#13;
&#13;
	function name() public view returns (string){&#13;
		return "Cryptoverse Preorder Bonus Assets";&#13;
	}&#13;
&#13;
	function symbol() public view returns (string){&#13;
		return "CPBA";&#13;
	}&#13;
&#13;
	Item[] public items;&#13;
&#13;
	mapping(uint =&gt; address) public itemIndexToOwner;&#13;
&#13;
	mapping(address =&gt; uint) public ownershipTokenCount;&#13;
&#13;
	mapping(uint =&gt; address) public itemIndexToApproved;&#13;
&#13;
	function reclaimToken(ERC20 token) external onlyOwner {&#13;
		uint256 balance = token.balanceOf(this);&#13;
		token.transfer(owner, balance);&#13;
	}&#13;
&#13;
	function _transfer(address from, address to, uint tokenId) internal {&#13;
		ownershipTokenCount[from]--;&#13;
		ownershipTokenCount[to]++;&#13;
		itemIndexToOwner[tokenId] = to;&#13;
		delete itemIndexToApproved[tokenId];&#13;
&#13;
		Transfer(from, to, tokenId);&#13;
	}&#13;
&#13;
	event CreateItem(uint id, ItemType typeId, ItemModel model, ItemManufacturer manufacturer, ItemRarity rarity, uint createTime, uint amount, address indexed owner);&#13;
&#13;
	function createItem(ItemType typeId, ItemModel model, ItemManufacturer manufacturer, ItemRarity rarity, uint amount, address owner) internal returns (uint) {&#13;
		require(owner != address(0));&#13;
&#13;
		Item memory item = Item(typeId, model, manufacturer, rarity, now, amount);&#13;
&#13;
		uint newItemId = items.length;&#13;
&#13;
		items.push(item);&#13;
&#13;
		CreateItem(newItemId, typeId, model, manufacturer, rarity, now, amount, owner);&#13;
&#13;
		ownershipTokenCount[owner]++;&#13;
		itemIndexToOwner[newItemId] = owner;&#13;
&#13;
		return newItemId;&#13;
	}&#13;
&#13;
	function tokensOfOwner(address owner) external view returns (uint[] ownerTokens) {&#13;
		uint tokenCount = balanceOf(owner);&#13;
&#13;
		if (tokenCount == 0) {&#13;
			return new uint[](0);&#13;
		} else {&#13;
			ownerTokens = new uint[](tokenCount);&#13;
			uint totalItems = totalSupply();&#13;
			uint resultIndex = 0;&#13;
&#13;
			for (uint itemId = 0; itemId &lt; totalItems; itemId++) {&#13;
				if (itemIndexToOwner[itemId] == owner) {&#13;
					ownerTokens[resultIndex] = itemId;&#13;
					resultIndex++;&#13;
				}&#13;
			}&#13;
&#13;
			return ownerTokens;&#13;
		}&#13;
	}&#13;
&#13;
	ERC721Metadata public erc721Metadata;&#13;
&#13;
	bytes4 constant InterfaceSignature_ERC165 =&#13;
	bytes4(keccak256('supportsInterface(bytes4)'));&#13;
&#13;
	bytes4 constant InterfaceSignature_ERC721 =&#13;
	bytes4(keccak256('name()')) ^&#13;
	bytes4(keccak256('symbol()')) ^&#13;
	bytes4(keccak256('totalSupply()')) ^&#13;
	bytes4(keccak256('balanceOf(address)')) ^&#13;
	bytes4(keccak256('ownerOf(uint)')) ^&#13;
	bytes4(keccak256('approve(address,uint)')) ^&#13;
	bytes4(keccak256('transfer(address,uint)')) ^&#13;
	bytes4(keccak256('transferFrom(address,address,uint)')) ^&#13;
	bytes4(keccak256('tokensOfOwner(address)')) ^&#13;
	bytes4(keccak256('tokenMetadata(uint,string)'));&#13;
&#13;
	function supportsInterface(bytes4 contractID) external view returns (bool)&#13;
	{&#13;
		return ((contractID == InterfaceSignature_ERC165) || (contractID == InterfaceSignature_ERC721));&#13;
	}&#13;
&#13;
	function setMetadataAddress(address contractAddress) public onlyOwner {&#13;
		erc721Metadata = ERC721Metadata(contractAddress);&#13;
	}&#13;
&#13;
	function _owns(address claimant, uint tokenId) internal view returns (bool) {&#13;
		return itemIndexToOwner[tokenId] == claimant;&#13;
	}&#13;
&#13;
	function _approvedFor(address claimant, uint tokenId) internal view returns (bool) {&#13;
		return itemIndexToApproved[tokenId] == claimant;&#13;
	}&#13;
&#13;
	function _approve(uint tokenId, address approved) internal {&#13;
		itemIndexToApproved[tokenId] = approved;&#13;
	}&#13;
&#13;
	function balanceOf(address owner) public view returns (uint count) {&#13;
		return ownershipTokenCount[owner];&#13;
	}&#13;
&#13;
	function transfer(address to, uint tokenId) public {&#13;
		require(to != address(0));&#13;
		require(_owns(msg.sender, tokenId));&#13;
		require(!_owns(to, tokenId));&#13;
		_transfer(msg.sender, to, tokenId);&#13;
	}&#13;
&#13;
	function approve(address to, uint tokenId) external {&#13;
		require(_owns(msg.sender, tokenId));&#13;
		_approve(tokenId, to);&#13;
		Approval(msg.sender, to, tokenId);&#13;
	}&#13;
&#13;
	function transferFrom(address from, address to, uint tokenId) external {&#13;
		require(to != address(0));&#13;
		require(to != address(this));&#13;
		require(_approvedFor(msg.sender, tokenId));&#13;
		require(_owns(from, tokenId));&#13;
		_transfer(from, to, tokenId);&#13;
	}&#13;
&#13;
	function totalSupply() public view returns (uint) {&#13;
		return items.length;&#13;
	}&#13;
&#13;
	function ownerOf(uint tokenId) external view returns (address owner)   {&#13;
		owner = itemIndexToOwner[tokenId];&#13;
&#13;
		require(owner != address(0));&#13;
	}&#13;
&#13;
	/// @dev Adapted from memcpy() by @arachnid (Nick Johnson &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="24455645474c4a4d40644a4b50404b500a4a4150">[email protected]</a>&gt;)&#13;
	///  This method is licenced under the Apache License.&#13;
	///  Ref: https://github.com/Arachnid/solidity-stringutils/blob/2f6ca9accb48ae14c66f1437ec50ed19a0616f78/strings.sol&#13;
	function _memcpy(uint _dest, uint _src, uint _len) private pure {&#13;
		// Copy word-length chunks while possible&#13;
		for (; _len &gt;= 32; _len -= 32) {&#13;
			assembly {&#13;
				mstore(_dest, mload(_src))&#13;
			}&#13;
			_dest += 32;&#13;
			_src += 32;&#13;
		}&#13;
&#13;
		// Copy remaining bytes&#13;
		uint mask = 256 ** (32 - _len) - 1;&#13;
		assembly {&#13;
			let srcpart := and(mload(_src), not(mask))&#13;
			let destpart := and(mload(_dest), mask)&#13;
			mstore(_dest, or(destpart, srcpart))&#13;
		}&#13;
	}&#13;
&#13;
	/// @dev Adapted from toString(slice) by @arachnid (Nick Johnson &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="9effecfffdf6f0f7fadef0f1eafaf1eab0f0fbea">[email protected]</a>&gt;)&#13;
	///  This method is licenced under the Apache License.&#13;
	///  Ref: https://github.com/Arachnid/solidity-stringutils/blob/2f6ca9accb48ae14c66f1437ec50ed19a0616f78/strings.sol&#13;
	function _toString(bytes32[4] _rawBytes, uint _stringLength) private pure returns (string) {&#13;
		var outputString = new string(_stringLength);&#13;
		uint outputPtr;&#13;
		uint bytesPtr;&#13;
&#13;
		assembly {&#13;
			outputPtr := add(outputString, 32)&#13;
			bytesPtr := _rawBytes&#13;
		}&#13;
&#13;
		_memcpy(outputPtr, bytesPtr, _stringLength);&#13;
&#13;
		return outputString;&#13;
	}&#13;
&#13;
	/// @notice Returns a URI pointing to a metadata package for this token conforming to&#13;
	///  ERC-721 (https://github.com/ethereum/EIPs/issues/721)&#13;
	/// @param _tokenId The ID number of the Kitty whose metadata should be returned.&#13;
	function tokenMetadata(uint _tokenId, string _preferredTransport) public view returns (string infoUrl) {&#13;
		require(erc721Metadata != address(0));&#13;
		bytes32[4] memory buffer;&#13;
		uint count;&#13;
		(buffer, count) = erc721Metadata.getMetadata(_tokenId, _preferredTransport);&#13;
&#13;
		return _toString(buffer, count);&#13;
	}&#13;
}&#13;
&#13;
contract CryptoversePreorder is CryptoversePreorderBonusAssets {&#13;
&#13;
	ERC20 public vrc;&#13;
	ERC20 public vcx;&#13;
&#13;
	address public vrcWallet;&#13;
	address public vcxWallet;&#13;
&#13;
	uint public vrcCount;&#13;
	uint public vcxCount;&#13;
&#13;
	uint public weiRaised;&#13;
&#13;
	uint public constant minInvest = 100 ether;&#13;
&#13;
	uint public constant target = 10000 ether;&#13;
&#13;
	uint public constant hardCap = 50000 ether;&#13;
&#13;
	uint public startTime = 1519153200; // 20 February 2018 19:00 UTC&#13;
&#13;
	uint public endTime = startTime + 60 days;&#13;
&#13;
	uint public targetTime = 0;&#13;
&#13;
	mapping(address =&gt; uint) public contributorBalance;&#13;
&#13;
	address[] public contributors;&#13;
&#13;
	event Purchase(address indexed contributor, uint weiAmount);&#13;
&#13;
	function() public payable {&#13;
		buyTokens(msg.sender);&#13;
	}&#13;
&#13;
	function createSaiLimitedEdition(uint weiAmount, address contributor) private {&#13;
		createItem(ItemType.SaiHead, ItemModel.M442_1, ItemManufacturer.Satoshipowered, ItemRarity.Epic, weiAmount, contributor);&#13;
		createItem(ItemType.SaiBody, ItemModel.M442_1, ItemManufacturer.Satoshipowered, ItemRarity.Epic, weiAmount, contributor);&#13;
		createItem(ItemType.SaiEarrings, ItemModel.V1_1, ItemManufacturer.Satoshipowered, ItemRarity.Unique, weiAmount, contributor);&#13;
	}&#13;
&#13;
	function createSaiCollectorsEdition(uint weiAmount, address contributor) private {&#13;
		createItem(ItemType.SaiHead, ItemModel.V2_1, ItemManufacturer.Satoshipowered, ItemRarity.Legendary, weiAmount, contributor);&#13;
		createItem(ItemType.SaiBody, ItemModel.V2_1, ItemManufacturer.Satoshipowered, ItemRarity.Legendary, weiAmount, contributor);&#13;
		createItem(ItemType.SaiEarrings, ItemModel.V1_1, ItemManufacturer.Satoshipowered, ItemRarity.Unique, weiAmount, contributor);&#13;
	}&#13;
&#13;
	function createSaiFoundersEdition(uint weiAmount, address contributor) private {&#13;
		createItem(ItemType.SaiHead, ItemModel.V1, ItemManufacturer.Satoshipowered, ItemRarity.Unique, weiAmount, contributor);&#13;
		createItem(ItemType.SaiBody, ItemModel.V1, ItemManufacturer.Satoshipowered, ItemRarity.Unique, weiAmount, contributor);&#13;
		createItem(ItemType.SaiEarrings, ItemModel.V1_1, ItemManufacturer.Satoshipowered, ItemRarity.Unique, weiAmount, contributor);&#13;
	}&#13;
&#13;
	function createVRCBox(ItemModel model, uint weiAmount, address contributor) private {&#13;
		createItem(ItemType.VRCBox, model, ItemManufacturer.Satoshipowered, ItemRarity.Legendary, weiAmount, contributor);&#13;
	}&#13;
&#13;
	function createVCXVault(uint weiAmount, address contributor) private {&#13;
		createItem(ItemType.VCXVault, ItemModel.EA, ItemManufacturer.Satoshipowered, ItemRarity.Unique, weiAmount, contributor);&#13;
	}&#13;
&#13;
	function createMechBTC(uint weiAmount, address contributor) private {&#13;
		createItem(ItemType.MechHead, ItemModel.NC01, ItemManufacturer.BTC, ItemRarity.Epic, weiAmount, contributor);&#13;
		createItem(ItemType.MechBody, ItemModel.NC01, ItemManufacturer.BTC, ItemRarity.Epic, weiAmount, contributor);&#13;
		createItem(ItemType.MechLegs, ItemModel.NC01, ItemManufacturer.BTC, ItemRarity.Epic, weiAmount, contributor);&#13;
		createItem(ItemType.MechRailgun, ItemModel.BG, ItemManufacturer.BTC, ItemRarity.Epic, weiAmount, contributor);&#13;
		createItem(ItemType.MechMachineGun, ItemModel.BC, ItemManufacturer.BTC, ItemRarity.Epic, weiAmount, contributor);&#13;
		createItem(ItemType.MechRocketLauncher, ItemModel.BD, ItemManufacturer.BTC, ItemRarity.Epic, weiAmount, contributor);&#13;
	}&#13;
&#13;
	function createMechVRC(uint weiAmount, address contributor) private {&#13;
		createItem(ItemType.MechHead, ItemModel.MK1, ItemManufacturer.VRC, ItemRarity.Legendary, weiAmount, contributor);&#13;
		createItem(ItemType.MechBody, ItemModel.MK1, ItemManufacturer.VRC, ItemRarity.Legendary, weiAmount, contributor);&#13;
		createItem(ItemType.MechLegs, ItemModel.MK1, ItemManufacturer.VRC, ItemRarity.Legendary, weiAmount, contributor);&#13;
		createItem(ItemType.MechRailgun, ItemModel.Q3, ItemManufacturer.VRC, ItemRarity.Legendary, weiAmount, contributor);&#13;
		createItem(ItemType.MechMachineGun, ItemModel.DES1, ItemManufacturer.VRC, ItemRarity.Legendary, weiAmount, contributor);&#13;
		createItem(ItemType.MechRocketLauncher, ItemModel.DRL, ItemManufacturer.VRC, ItemRarity.Legendary, weiAmount, contributor);&#13;
	}&#13;
&#13;
	function createMechETH(uint weiAmount, address contributor) private {&#13;
		createItem(ItemType.MechHead, ItemModel.V1, ItemManufacturer.ETH, ItemRarity.Unique, weiAmount, contributor);&#13;
		createItem(ItemType.MechBody, ItemModel.V1, ItemManufacturer.ETH, ItemRarity.Unique, weiAmount, contributor);&#13;
		createItem(ItemType.MechLegs, ItemModel.V1, ItemManufacturer.ETH, ItemRarity.Unique, weiAmount, contributor);&#13;
		createItem(ItemType.MechRailgun, ItemModel.TRFL405, ItemManufacturer.ETH, ItemRarity.Unique, weiAmount, contributor);&#13;
		createItem(ItemType.MechMachineGun, ItemModel.PlasmaS, ItemManufacturer.ETH, ItemRarity.Unique, weiAmount, contributor);&#13;
		createItem(ItemType.MechRocketLauncher, ItemModel.Casper, ItemManufacturer.ETH, ItemRarity.Unique, weiAmount, contributor);&#13;
	}&#13;
&#13;
	function buyTokens(address contributor) public whenNotPaused payable {&#13;
		require(startTime &lt;= now &amp;&amp; now &lt;= endTime);&#13;
		require(contributor != address(0));&#13;
&#13;
		uint weiAmount = msg.value;&#13;
&#13;
		require(weiAmount &gt;= minInvest);&#13;
&#13;
		weiRaised += weiAmount;&#13;
&#13;
		require(weiRaised &lt;= hardCap);&#13;
&#13;
		if (weiRaised &gt;= target &amp;&amp; targetTime == 0) {&#13;
			targetTime = now;&#13;
			endTime = targetTime + 2 weeks;&#13;
		}&#13;
&#13;
		Purchase(contributor, weiAmount);&#13;
&#13;
		if (contributorBalance[contributor] == 0) contributors.push(contributor);&#13;
		contributorBalance[contributor] += weiAmount;&#13;
&#13;
		if (weiAmount &lt; 500 ether) {&#13;
&#13;
			createSaiLimitedEdition(weiAmount, contributor);&#13;
			createVRCBox(ItemModel.Kilo, weiAmount, contributor);&#13;
			createVCXVault(weiAmount, contributor);&#13;
&#13;
		} else if (weiAmount &lt; 1000 ether) {&#13;
&#13;
			createSaiLimitedEdition(weiAmount, contributor);&#13;
			createMechBTC(weiAmount, contributor);&#13;
			createVRCBox(ItemModel.Mega, weiAmount, contributor);&#13;
			createVCXVault(weiAmount, contributor);&#13;
&#13;
		} else if (weiAmount &lt; 2500 ether) {&#13;
&#13;
			createSaiCollectorsEdition(weiAmount, contributor);&#13;
			createMechBTC(weiAmount, contributor);&#13;
			createMechVRC(weiAmount, contributor);&#13;
			createVRCBox(ItemModel.Giga, weiAmount, contributor);&#13;
			createVCXVault(weiAmount, contributor);&#13;
&#13;
		} else if (weiAmount &lt; 5000 ether) {&#13;
&#13;
			createSaiCollectorsEdition(weiAmount, contributor);&#13;
			createMechBTC(weiAmount, contributor);&#13;
			createMechVRC(weiAmount, contributor);&#13;
			createVRCBox(ItemModel.Tera, weiAmount, contributor);&#13;
			createVCXVault(weiAmount, contributor);&#13;
&#13;
		} else if (weiAmount &lt; 9000 ether) {&#13;
&#13;
			createSaiFoundersEdition(weiAmount, contributor);&#13;
			createMechBTC(weiAmount, contributor);&#13;
			createMechVRC(weiAmount, contributor);&#13;
			createVRCBox(ItemModel.Peta, weiAmount, contributor);&#13;
			createVCXVault(weiAmount, contributor);&#13;
&#13;
		} else if (weiAmount &gt;= 9000 ether) {&#13;
&#13;
			createSaiFoundersEdition(weiAmount, contributor);&#13;
			createMechBTC(weiAmount, contributor);&#13;
			createMechVRC(weiAmount, contributor);&#13;
			createMechETH(weiAmount, contributor);&#13;
			createVRCBox(ItemModel.Exa, weiAmount, contributor);&#13;
			createVCXVault(weiAmount, contributor);&#13;
&#13;
		}&#13;
	}&#13;
&#13;
	function withdrawal(uint amount) public onlyOwner {&#13;
		owner.transfer(amount);&#13;
	}&#13;
&#13;
	function contributorsCount() public view returns (uint){&#13;
		return contributors.length;&#13;
	}&#13;
&#13;
	function setVRC(address _vrc, address _vrcWallet, uint _vrcCount) public onlyOwner {&#13;
		require(_vrc != address(0));&#13;
		require(_vrcWallet != address(0));&#13;
		require(_vrcCount &gt; 0);&#13;
&#13;
		vrc = ERC20(_vrc);&#13;
		vrcWallet = _vrcWallet;&#13;
		vrcCount = _vrcCount;&#13;
	}&#13;
&#13;
	function setVCX(address _vcx, address _vcxWallet, uint _vcxCount) public onlyOwner {&#13;
		require(_vcx != address(0));&#13;
		require(_vcxWallet != address(0));&#13;
		require(_vcxCount &gt; 0);&#13;
&#13;
		vcx = ERC20(_vcx);&#13;
		vcxWallet = _vcxWallet;&#13;
		vcxCount = _vcxCount;&#13;
	}&#13;
&#13;
	function getBoxes(address contributor) public view returns (uint[] boxes) {&#13;
		uint tokenCount = balanceOf(contributor);&#13;
&#13;
		if (tokenCount == 0) {&#13;
			return new uint[](0);&#13;
		} else {&#13;
			uint[] memory _boxes = new uint[](tokenCount);&#13;
			uint totalItems = totalSupply();&#13;
			uint n = 0;&#13;
&#13;
			for (uint itemId = 0; itemId &lt; totalItems; itemId++) {&#13;
				if (itemIndexToOwner[itemId] == contributor &amp;&amp; isBoxItemId(itemId)) {&#13;
					_boxes[n++] = itemId;&#13;
				}&#13;
			}&#13;
&#13;
			boxes = new uint[](n);&#13;
&#13;
			for (uint i = 0; i &lt; n; i++) {&#13;
				boxes[i] = _boxes[i];&#13;
			}&#13;
			return boxes;&#13;
		}&#13;
	}&#13;
&#13;
	function isBox(Item item) private pure returns (bool){&#13;
		return item.typeId == ItemType.VRCBox || item.typeId == ItemType.VCXVault;&#13;
	}&#13;
&#13;
	function isBoxItemId(uint itemId) public view returns (bool){&#13;
		return isBox(items[itemId]);&#13;
	} &#13;
&#13;
	function openBoxes(uint[] itemIds) public {&#13;
		for (uint i = 0; i &lt; itemIds.length; i++) {&#13;
			uint itemId = itemIds[i];&#13;
			Item storage item = items[itemId];&#13;
			require(isBox(item));&#13;
&#13;
			transfer(this, itemId);&#13;
&#13;
			if (item.typeId == ItemType.VRCBox) {&#13;
				vrc.transferFrom(vrcWallet, msg.sender, item.amount * vrcCount / weiRaised);&#13;
			} else {&#13;
				vcx.transferFrom(vcxWallet, msg.sender, item.amount * vcxCount / weiRaised);&#13;
			}&#13;
		}&#13;
	}&#13;
}