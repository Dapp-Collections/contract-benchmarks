/// @title Public Token Register - Allows to register coins and get it from another contract.
/// @author Global Group - <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="2443484b4645484d4a524157505448454741644349454d480a474b49">[emailÂ protected]</a>&gt;&#13;
pragma solidity ^0.4.24;&#13;
&#13;
contract IPublicTokenRegister {&#13;
	function securityReg(address _securityWallet) public;&#13;
	function registerCoin(string _name,string _symbol, address coinTokenContract) public;&#13;
	function getSymbol(string _coin) public view returns(string _symbol);&#13;
	function getCoinAddress(string _coin) public view returns(address _coinTokenContract);&#13;
	function getHexSymbol(string _coin) public view returns(bytes4 _hexSymbol);&#13;
	function getIsCoinReg(string _coin) public view returns(bool _isReg);&#13;
	function getCoinInfo(string _coin) public view returns(string _symbol, address coinAddress, bytes4 _hexSymbol, bool _isReg);&#13;
	function getIsSecurityWalletReg(address _wallet) public view returns(bool _isReg);&#13;
&#13;
	event RegisterCoin(string _coin, string _name, string _symbol, address _coinTokenContract);&#13;
	event SecurityReg(address _securityWallet, bool isRegistered);&#13;
}&#13;
&#13;
contract Ownable {&#13;
	address public owner;&#13;
	&#13;
	event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);&#13;
&#13;
	constructor() public {&#13;
		owner = msg.sender;&#13;
	}&#13;
&#13;
	modifier onlyOwner() {&#13;
		require(msg.sender == owner);&#13;
		_;&#13;
	}&#13;
&#13;
	function transferOwnership(address newOwner) public onlyOwner {&#13;
		require(newOwner != address(0));&#13;
		emit OwnershipTransferred(owner, newOwner);&#13;
		owner = newOwner;&#13;
	}&#13;
}&#13;
&#13;
contract PublicTokenRegister is IPublicTokenRegister, Ownable {&#13;
	mapping(string =&gt; Coin) internal coin;&#13;
	mapping(address =&gt; bool) internal registeredSecurity;&#13;
	address[] internal registeredCoins;&#13;
	&#13;
	modifier onlySecurity {&#13;
		require(registeredSecurity[msg.sender] == true);&#13;
		_;&#13;
	}&#13;
    &#13;
    // STRUCTS&#13;
	struct Coin {&#13;
		string symbol;&#13;
		address coinTokenContract;&#13;
		bytes4 hexSymbol;&#13;
		bool isReg;&#13;
	}&#13;
&#13;
    function() public payable {&#13;
		revert();&#13;
    }&#13;
    &#13;
    constructor() public {&#13;
    }&#13;
    &#13;
    function registerCoin(string _name, string _symbol, address _coinTokenContract) public onlySecurity {&#13;
		require(coin[_name].isReg == false);&#13;
		bytes4 _hexSymbol = convertStringToBytes(_name);&#13;
        coin[_name] = Coin ({&#13;
            symbol: _symbol,&#13;
            coinTokenContract: _coinTokenContract,&#13;
            hexSymbol: _hexSymbol,&#13;
            isReg: true&#13;
        });&#13;
        registeredCoins.push(_coinTokenContract);&#13;
		&#13;
		emit RegisterCoin(_name, _name, _symbol, _coinTokenContract);&#13;
    }&#13;
	&#13;
	function removeCoin(string _name) public onlyOwner {&#13;
		require(coin[_name].isReg == true);&#13;
		coin[_name] = Coin({&#13;
			symbol: "",&#13;
			coinTokenContract: 0x0,&#13;
			hexSymbol: 0x0,&#13;
			isReg: false&#13;
		});&#13;
	}&#13;
	&#13;
	function securityReg(address _securityWallet) public onlyOwner {&#13;
		require(registeredSecurity[_securityWallet] == false);&#13;
		registeredSecurity[_securityWallet] = true;&#13;
		emit SecurityReg(_securityWallet, true);&#13;
	}&#13;
	&#13;
	function getSymbol(string _coinName) public view returns(string _symbol) {&#13;
		return coin[_coinName].symbol;&#13;
	}&#13;
	&#13;
	function getHexSymbol(string _coinName) public view returns(bytes4 _hexSymbol) {&#13;
		return coin[_coinName].hexSymbol;&#13;
	}&#13;
	&#13;
   	function getCoinAddress(string _coinName) public view returns(address _coinTokenContract) {&#13;
		return coin[_coinName].coinTokenContract;&#13;
	}&#13;
	&#13;
	function getIsCoinReg(string _coinName) public view returns(bool _isCoinReg) {&#13;
		return coin[_coinName].isReg;&#13;
	}&#13;
	&#13;
	function getCoinInfo(string _coinName) public view returns(string _symbol, address coinAddress, bytes4 _hexSymbol, bool _isReg) {&#13;
		return (getSymbol(_coinName),getCoinAddress(_coinName),getHexSymbol(_coinName),getIsCoinReg(_coinName));&#13;
	}&#13;
	&#13;
	function getIsSecurityWalletReg(address _wallet) public view returns(bool _isReg) {&#13;
		return registeredSecurity[_wallet];&#13;
	}&#13;
	&#13;
    function convertStringToBytes(string memory source) internal pure returns (bytes4 result) {&#13;
        bytes memory tempEmptyStringTest = bytes(source);&#13;
        if (tempEmptyStringTest.length == 0) {&#13;
            return 0x0;&#13;
        }&#13;
        assembly {&#13;
            result := mload(add(source, 32))&#13;
        }&#13;
    }&#13;
}