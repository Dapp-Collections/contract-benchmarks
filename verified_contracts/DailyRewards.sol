pragma solidity ^0.4.24;

// written by garry from Team Chibi Fighters
// find us at https://chibifighters.io
// <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="7b18131219121d121c130f1e09083b1c161a121755181416">[emailÂ protected]</a>&#13;
// version 1.0.0&#13;
&#13;
&#13;
contract Owned {&#13;
    address public owner;&#13;
    address public newOwner;&#13;
&#13;
    event OwnershipTransferred(address indexed _from, address indexed _to);&#13;
&#13;
    constructor() public {&#13;
        owner = msg.sender;&#13;
    }&#13;
&#13;
    modifier onlyOwner {&#13;
        require(msg.sender == owner);&#13;
        _;&#13;
    }&#13;
&#13;
    function transferOwnership(address _newOwner) public onlyOwner {&#13;
        newOwner = _newOwner;&#13;
    }&#13;
    &#13;
    function acceptOwnership() public {&#13;
        require(msg.sender == newOwner);&#13;
        emit OwnershipTransferred(owner, newOwner);&#13;
        owner = newOwner;&#13;
        newOwner = address(0);&#13;
    }&#13;
}&#13;
&#13;
&#13;
interface ERC20Interface {&#13;
    function transferFrom(address from, address to, uint tokens) external returns (bool success);&#13;
    function transfer(address to, uint tokens) external;&#13;
    function balanceOf(address _owner) external view returns (uint256 _balance);&#13;
}&#13;
&#13;
interface ERC20InterfaceClassic {&#13;
    function transfer(address to, uint tokens) external returns (bool success);&#13;
}&#13;
&#13;
contract DailyRewards is Owned {&#13;
&#13;
	event RewardClaimed(&#13;
		address indexed buyer,&#13;
		uint256 day&#13;
	);&#13;
	&#13;
	// what day the player is on in his reward chain&#13;
	mapping (address =&gt; uint) private daysInRow;&#13;
&#13;
	// timeout after which row is broken&#13;
	mapping (address =&gt; uint) private timeout;&#13;
	&#13;
	// how often the reward can be claimed, e.g. every 24h&#13;
	uint waitingTime = 24 hours;&#13;
	// window of claiming, if it expires day streak resets to day 1&#13;
	uint waitingTimeBuffer = 48 hours;&#13;
	&#13;
	&#13;
	constructor() public {&#13;
	    // Explore Chibis and their universe&#13;
	    // Off chain battles, real Ether fights, true on chain ownership&#13;
	    // Leaderboards, tournaments, roleplay elements, we got it all&#13;
	}&#13;
	&#13;
	&#13;
	function requestReward() public returns (uint _days) {&#13;
	    require (msg.sender != address(0));&#13;
	    require (now &gt; timeout[msg.sender]);&#13;
	    &#13;
	    // waited too long, reset&#13;
	    if (now &gt; timeout[msg.sender] + waitingTimeBuffer) {&#13;
	        daysInRow[msg.sender] = 1;    &#13;
	    } else {&#13;
	        // no limit to being logged in, looking forward to the longest streak&#13;
	        daysInRow[msg.sender]++;&#13;
	    }&#13;
	    &#13;
	    timeout[msg.sender] = now + waitingTime;&#13;
	    &#13;
	    emit RewardClaimed(msg.sender, daysInRow[msg.sender]);&#13;
	    &#13;
	    return daysInRow[msg.sender];&#13;
	}&#13;
	&#13;
	&#13;
	/**&#13;
	 * @dev Query stats of next reward, checks for expired time, too&#13;
	 **/&#13;
	function nextReward() public view returns (uint _day, uint _nextClaimTime, uint _nextClaimExpire) {&#13;
	    uint _dayCheck;&#13;
	    if (now &gt; timeout[msg.sender] + waitingTimeBuffer) _dayCheck = 1; else _dayCheck = daysInRow[msg.sender] + 1;&#13;
	    &#13;
	    return (_dayCheck, timeout[msg.sender], timeout[msg.sender] + waitingTimeBuffer);&#13;
	}&#13;
	&#13;
	&#13;
	function queryWaitingTime() public view returns (uint _waitingTime) {&#13;
	    return waitingTime;&#13;
	}&#13;
	&#13;
	function queryWaitingTimeBuffer() public view returns (uint _waitingTimeBuffer) {&#13;
	    return waitingTimeBuffer;&#13;
	}&#13;
	&#13;
&#13;
	/**&#13;
	 * @dev Sets the interval for daily rewards, e.g. 24h = 86400&#13;
	 * @param newTime New interval time in seconds&#13;
	 **/&#13;
	function setWaitingTime(uint newTime) public onlyOwner returns (uint _newWaitingTime) {&#13;
	    waitingTime = newTime;&#13;
	    return waitingTime;&#13;
	}&#13;
	&#13;
	&#13;
	/**&#13;
	 * @dev Sets buffer for daily rewards. So user have time to claim it. e.g. 1h = 3600&#13;
	 * @param newTime New buffer in seconds&#13;
	 **/&#13;
	function setWaitingTimeBuffer(uint newTime) public onlyOwner returns (uint _newWaitingTimeBuffer) {&#13;
	    waitingTimeBuffer = newTime;&#13;
	    return waitingTimeBuffer;&#13;
	}&#13;
&#13;
&#13;
    /**&#13;
    * @dev Send Ether to owner&#13;
    * @param _address Receiving address&#13;
    * @param _amountWei Amount in WEI to send&#13;
    **/&#13;
    function weiToOwner(address _address, uint _amountWei) public onlyOwner returns (bool) {&#13;
        require(_amountWei &lt;= address(this).balance);&#13;
        _address.transfer(_amountWei);&#13;
        return true;&#13;
    }&#13;
&#13;
    function ERC20ToOwner(address _to, uint256 _amount, ERC20Interface _tokenContract) public onlyOwner {&#13;
        _tokenContract.transfer(_to, _amount);&#13;
    }&#13;
&#13;
    function ERC20ClassicToOwner(address _to, uint256 _amount, ERC20InterfaceClassic _tokenContract) public onlyOwner {&#13;
        _tokenContract.transfer(_to, _amount);&#13;
    }&#13;
&#13;
}