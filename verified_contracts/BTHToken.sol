pragma solidity ^0.4.16;

// copyright <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="9efdf1f0eafffdeadefce7eafbeaf6fbecb0fdf1f3">[emailÂ protected]</a>&#13;
&#13;
contract BasicAccessControl {&#13;
    address public owner;&#13;
    address[] public moderators;&#13;
&#13;
    function BasicAccessControl() public {&#13;
        owner = msg.sender;&#13;
    }&#13;
&#13;
    modifier onlyOwner {&#13;
        require(msg.sender == owner);&#13;
        _;&#13;
    }&#13;
&#13;
    modifier onlyModerators() {&#13;
        if (msg.sender != owner) {&#13;
            bool found = false;&#13;
            for (uint index = 0; index &lt; moderators.length; index++) {&#13;
                if (moderators[index] == msg.sender) {&#13;
                    found = true;&#13;
                    break;&#13;
                }&#13;
            }&#13;
            require(found);&#13;
        }&#13;
        _;&#13;
    }&#13;
&#13;
    function ChangeOwner(address _newOwner) onlyOwner public {&#13;
        if (_newOwner != address(0)) {&#13;
            owner = _newOwner;&#13;
        }&#13;
    }&#13;
&#13;
    function Kill() onlyOwner public {&#13;
        selfdestruct(owner);&#13;
    }&#13;
&#13;
    function AddModerator(address _newModerator) onlyOwner public {&#13;
        if (_newModerator != address(0)) {&#13;
            for (uint index = 0; index &lt; moderators.length; index++) {&#13;
                if (moderators[index] == _newModerator) {&#13;
                    return;&#13;
                }&#13;
            }&#13;
            moderators.push(_newModerator);&#13;
        }&#13;
    }&#13;
    &#13;
    function RemoveModerator(address _oldModerator) onlyOwner public {&#13;
        uint foundIndex = 0;&#13;
        for (; foundIndex &lt; moderators.length; foundIndex++) {&#13;
            if (moderators[foundIndex] == _oldModerator) {&#13;
                break;&#13;
            }&#13;
        }&#13;
        if (foundIndex &lt; moderators.length) {&#13;
            moderators[foundIndex] = moderators[moderators.length-1];&#13;
            delete moderators[moderators.length-1];&#13;
            moderators.length--;&#13;
        }&#13;
    }&#13;
}&#13;
&#13;
interface TokenRecipient { &#13;
    function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public; &#13;
}&#13;
&#13;
interface CrossForkDistribution {&#13;
    function getDistributedAmount(uint64 _requestId, string _btcAddress, address _receiver) public;&#13;
}&#13;
&#13;
interface CrossForkCallback {&#13;
    function callbackCrossFork(uint64 _requestId, uint256 _amount, bytes32 _referCodeHash) public;&#13;
}&#13;
&#13;
contract TokenERC20 {&#13;
    uint256 public totalSupply;&#13;
&#13;
    mapping (address =&gt; uint256) public balanceOf;&#13;
    mapping (address =&gt; mapping (address =&gt; uint256)) public allowance;&#13;
&#13;
    event Transfer(address indexed from, address indexed to, uint256 value);&#13;
    event Burn(address indexed from, uint256 value);&#13;
&#13;
    function _transfer(address _from, address _to, uint _value) internal {&#13;
        require(_to != 0x0);&#13;
        require(balanceOf[_from] &gt;= _value);&#13;
        require(balanceOf[_to] + _value &gt; balanceOf[_to]);&#13;
        uint previousBalances = balanceOf[_from] + balanceOf[_to];&#13;
        balanceOf[_from] -= _value;&#13;
        balanceOf[_to] += _value;&#13;
        Transfer(_from, _to, _value);&#13;
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);&#13;
    }&#13;
&#13;
    function transfer(address _to, uint256 _value) public {&#13;
        _transfer(msg.sender, _to, _value);&#13;
    }&#13;
&#13;
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {&#13;
        require(_value &lt;= allowance[_from][msg.sender]);&#13;
        allowance[_from][msg.sender] -= _value;&#13;
        _transfer(_from, _to, _value);&#13;
        return true; &#13;
    }&#13;
&#13;
    function approve(address _spender, uint256 _value) public returns (bool success) {&#13;
        allowance[msg.sender][_spender] = _value;&#13;
        return true;&#13;
    }&#13;
&#13;
    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {&#13;
        TokenRecipient spender = TokenRecipient(_spender);&#13;
        if (approve(_spender, _value)) {&#13;
            spender.receiveApproval(msg.sender, _value, this, _extraData);&#13;
            return true;&#13;
        }&#13;
    }&#13;
&#13;
    function burn(uint256 _value) public returns (bool success) {&#13;
        require(balanceOf[msg.sender] &gt;= _value);&#13;
        balanceOf[msg.sender] -= _value;&#13;
        totalSupply -= _value;&#13;
        Burn(msg.sender, _value);&#13;
        return true;&#13;
    }&#13;
&#13;
    function burnFrom(address _from, uint256 _value) public returns (bool success) {&#13;
        require(balanceOf[_from] &gt;= _value);&#13;
        require(_value &lt;= allowance[_from][msg.sender]);&#13;
        balanceOf[_from] -= _value;&#13;
        allowance[_from][msg.sender] -= _value;&#13;
        totalSupply -= _value;&#13;
        Burn(_from, _value);&#13;
        return true;&#13;
    }&#13;
}&#13;
&#13;
contract BTHToken is BasicAccessControl, TokenERC20, CrossForkCallback {&#13;
    // metadata&#13;
    string public constant name = "Bytether";&#13;
    string public constant symbol = "BTH";&#13;
    uint256 public constant decimals = 18;&#13;
    string public version = "1.0";&#13;
    &#13;
    // cross fork data&#13;
    enum ForkResultCode { &#13;
        SUCCESS,&#13;
        TRIGGERED,&#13;
        RECEIVED,&#13;
        PENDING,&#13;
        FAILED,&#13;
        ID_MISMATCH,&#13;
        NOT_ENOUGH_BALANCE,&#13;
        NOT_RECEIVED&#13;
    }&#13;
    enum ClaimReferResultCode {&#13;
        SUCCESS,&#13;
        NOT_ENOUGH_BALANCE&#13;
    }&#13;
    struct CrossForkData {&#13;
        string btcAddress;&#13;
        address receiver;&#13;
        uint256 amount;&#13;
        bytes32 referCodeHash;&#13;
        uint createTime;&#13;
    }&#13;
    uint64 public crossForkCount = 0;&#13;
    uint public referBenefitRate = 10; // 10 btc -&gt; 1 bth&#13;
    bool public crossForking = false;&#13;
    mapping (uint64 =&gt; CrossForkData) crossForkMapping;&#13;
    mapping (string =&gt; uint64) crossForkIds;&#13;
    mapping (bytes32 =&gt; uint256) referBenefits; // referCodeHash -&gt; bth amount&#13;
    address public crossForkDistribution = 0x0; // crossfork contract&#13;
    uint256 public constant satoshi_bth_decimals = 10 ** 10;&#13;
    &#13;
    event LogRevertCrossFork(bytes32 indexed btcAddressHash, address indexed receiver, uint64 indexed requestId, uint256 amount, ForkResultCode result);&#13;
    event LogTriggerCrossFork(bytes32 indexed btcAddressHash, uint64 indexed requestId, ForkResultCode result);&#13;
    event LogCrossFork(uint64 indexed requestId, address receiver, uint256 amount, ForkResultCode result);&#13;
    event LogClaimReferBenefit(bytes32 indexed referCodeHash, address receiver, uint256 amount, ClaimReferResultCode result);&#13;
    &#13;
    // deposit address&#13;
    address public crossForkFundDeposit; // deposit address for cross fork&#13;
    address public bthFundDeposit; // deposit address for user growth pool &amp; marketing&#13;
    address public developerFundDeposit; // deposit address for developer fund&#13;
    &#13;
    // fund distribution&#13;
    uint256 public crossForkFund = 17 * (10**6) * 10**decimals; //17m reserved for BitCoin Cross-Fork&#13;
    uint256 public marketingFund = 2  * (10**6) * 10**decimals; //2m reserved for marketing&#13;
    uint256 public userPoolFund  = 1  * (10**6) * 10**decimals; //1m for user growth pool&#13;
    uint256 public developerFund = 1  * (10**6) * 10**decimals; //1m reserved for developers&#13;
    &#13;
    // for future feature&#13;
    uint256 public sellPrice;&#13;
    uint256 public buyPrice;&#13;
    bool public trading = false;&#13;
    mapping (address =&gt; bool) public frozenAccount;&#13;
    event FrozenFunds(address target, bool frozen);&#13;
    &#13;
    // modifier&#13;
    modifier isCrossForking {&#13;
        require(crossForking == true || msg.sender == owner);&#13;
        require(crossForkDistribution != 0x0);&#13;
        _;&#13;
    }&#13;
    &#13;
    modifier isTrading {&#13;
        require(trading == true || msg.sender == owner);&#13;
        _;&#13;
    } &#13;
&#13;
    // constructor&#13;
    function BTHToken(address _crossForkDistribution, address _crossForkFundDeposit, address _bthFundDeposit, address _developerFundDeposit) public {&#13;
        totalSupply = crossForkFund + marketingFund + userPoolFund + developerFund;&#13;
        crossForkDistribution = _crossForkDistribution;&#13;
        crossForkFundDeposit = _crossForkFundDeposit;&#13;
        bthFundDeposit = _bthFundDeposit;&#13;
        developerFundDeposit = _developerFundDeposit;&#13;
        &#13;
        balanceOf[crossForkFundDeposit] += crossForkFund;&#13;
        balanceOf[bthFundDeposit] += marketingFund + userPoolFund;&#13;
        balanceOf[developerFundDeposit] += developerFund;&#13;
    }&#13;
&#13;
    function () payable public {}&#13;
    &#13;
    // only admin&#13;
    function setCrossForkDistribution(address _crossForkDistribution) onlyOwner public {&#13;
        crossForkDistribution = _crossForkDistribution;&#13;
    }&#13;
&#13;
    function setDepositAddress(address _crossForkFund, address _bthFund, address _developerFund) onlyOwner public {&#13;
        crossForkFundDeposit = _crossForkFund;&#13;
        bthFundDeposit = _bthFund;&#13;
        developerFundDeposit = _developerFund;&#13;
    }&#13;
&#13;
    function setPrices(uint256 _newSellPrice, uint256 _newBuyPrice) onlyOwner public {&#13;
        sellPrice = _newSellPrice;&#13;
        buyPrice = _newBuyPrice;&#13;
    }&#13;
&#13;
    function setReferBenefitRate(uint _rate) onlyOwner public {&#13;
        referBenefitRate = _rate;&#13;
    }&#13;
    &#13;
    // only moderators&#13;
    function toggleCrossForking() onlyModerators public {&#13;
        crossForking = !crossForking;&#13;
    }&#13;
    &#13;
    function toggleTrading() onlyModerators public {&#13;
        trading = !trading;&#13;
    }&#13;
    &#13;
    function claimReferBenefit(string _referCode, address _receiver) onlyModerators public {&#13;
        bytes32 referCodeHash = keccak256(_referCode);&#13;
        uint256 totalAmount = referBenefits[referCodeHash];&#13;
        if (totalAmount==0) {&#13;
            LogClaimReferBenefit(referCodeHash, _receiver, 0, ClaimReferResultCode.SUCCESS);&#13;
            return;&#13;
        }&#13;
        if (balanceOf[bthFundDeposit] &lt; totalAmount) {&#13;
            LogClaimReferBenefit(referCodeHash, _receiver, 0, ClaimReferResultCode.NOT_ENOUGH_BALANCE);&#13;
            return;&#13;
        }&#13;
        &#13;
        referBenefits[referCodeHash] = 0;&#13;
        balanceOf[bthFundDeposit] -= totalAmount;&#13;
        balanceOf[_receiver] += totalAmount;&#13;
        LogClaimReferBenefit(referCodeHash, _receiver, totalAmount, ClaimReferResultCode.SUCCESS);&#13;
    }&#13;
&#13;
    // in case there is an error&#13;
    function revertCrossFork(string _btcAddress) onlyModerators public {&#13;
        bytes32 btcAddressHash = keccak256(_btcAddress);&#13;
        uint64 requestId = crossForkIds[_btcAddress];&#13;
        if (requestId == 0) {&#13;
            LogRevertCrossFork(btcAddressHash, 0x0, 0, 0, ForkResultCode.NOT_RECEIVED);&#13;
            return;&#13;
        }&#13;
        CrossForkData storage crossForkData = crossForkMapping[requestId];&#13;
        uint256 amount = crossForkData.amount;        &#13;
        address receiver = crossForkData.receiver;&#13;
        if (balanceOf[receiver] &lt; crossForkData.amount) {&#13;
            LogRevertCrossFork(btcAddressHash, receiver, requestId, amount, ForkResultCode.NOT_ENOUGH_BALANCE);&#13;
            return;&#13;
        }&#13;
        &#13;
        // revert&#13;
        balanceOf[crossForkData.receiver] -= crossForkData.amount;&#13;
        balanceOf[crossForkFundDeposit] += crossForkData.amount;&#13;
        crossForkIds[_btcAddress] = 0;&#13;
        crossForkData.btcAddress = "";&#13;
        crossForkData.receiver = 0x0;&#13;
        crossForkData.amount = 0;&#13;
        crossForkData.createTime = 0;&#13;
        &#13;
        // revert refer claimable amount if possible&#13;
        if (referBenefits[crossForkData.referCodeHash] &gt; 0) {&#13;
            uint256 deductAmount = crossForkData.amount;&#13;
            if (referBenefits[crossForkData.referCodeHash] &lt; deductAmount) {&#13;
                deductAmount = referBenefits[crossForkData.referCodeHash];&#13;
            }&#13;
            referBenefits[crossForkData.referCodeHash] -= deductAmount;&#13;
        }&#13;
        &#13;
        LogRevertCrossFork(btcAddressHash, receiver, requestId, amount, ForkResultCode.SUCCESS);&#13;
    }&#13;
&#13;
    // public&#13;
    function getCrossForkId(string _btcAddress) constant public returns(uint64) {&#13;
        return crossForkIds[_btcAddress];&#13;
    }&#13;
    &#13;
    function getCrossForkData(uint64 _id) constant public returns(string, address, uint256, uint) {&#13;
        CrossForkData storage crossForkData = crossForkMapping[_id];&#13;
        return (crossForkData.btcAddress, crossForkData.receiver, crossForkData.amount, crossForkData.createTime);&#13;
    }&#13;
    &#13;
    function getReferBenefit(string _referCode) constant public returns(uint256) {&#13;
        return referBenefits[keccak256(_referCode)];&#13;
    }&#13;
    &#13;
    function callbackCrossFork(uint64 _requestId, uint256 _amount, bytes32 _referCodeHash) public {&#13;
        if (msg.sender != crossForkDistribution || _amount == 0) {&#13;
            LogCrossFork(_requestId, 0x0, 0, ForkResultCode.FAILED);&#13;
            return;&#13;
        }&#13;
        CrossForkData storage crossForkData = crossForkMapping[_requestId];&#13;
        if (crossForkData.receiver == 0x0) {&#13;
            LogCrossFork(_requestId, crossForkData.receiver, 0, ForkResultCode.ID_MISMATCH);&#13;
            return;&#13;
        }&#13;
        if (crossForkIds[crossForkData.btcAddress] != 0) {&#13;
            LogCrossFork(_requestId, crossForkData.receiver, crossForkData.amount, ForkResultCode.RECEIVED);&#13;
            return;&#13;
        }&#13;
        crossForkIds[crossForkData.btcAddress] = _requestId;&#13;
        crossForkData.amount = _amount*satoshi_bth_decimals;&#13;
        &#13;
        // add fund for address&#13;
        if (balanceOf[crossForkFundDeposit] &lt; crossForkData.amount) {&#13;
            LogCrossFork(_requestId, crossForkData.receiver, crossForkData.amount, ForkResultCode.NOT_ENOUGH_BALANCE);&#13;
            return;&#13;
        }&#13;
        balanceOf[crossForkFundDeposit] -= crossForkData.amount;&#13;
        balanceOf[crossForkData.receiver] += crossForkData.amount;&#13;
        if (referBenefitRate &gt; 0) {&#13;
            crossForkData.referCodeHash = _referCodeHash;&#13;
            referBenefits[_referCodeHash] += crossForkData.amount / referBenefitRate;&#13;
        }&#13;
        &#13;
        LogCrossFork(_requestId, crossForkData.receiver, crossForkData.amount, ForkResultCode.SUCCESS);&#13;
    }&#13;
    &#13;
    function triggerCrossFork(string _btcAddress) isCrossForking public returns(ForkResultCode) {&#13;
        bytes32 btcAddressHash = keccak256(_btcAddress);&#13;
        if (crossForkIds[_btcAddress] &gt; 0) {&#13;
            LogTriggerCrossFork(btcAddressHash, crossForkIds[_btcAddress], ForkResultCode.RECEIVED);&#13;
            return ForkResultCode.RECEIVED;&#13;
        }&#13;
&#13;
        crossForkCount += 1;&#13;
        CrossForkData storage crossForkData = crossForkMapping[crossForkCount];&#13;
        crossForkData.btcAddress = _btcAddress;&#13;
        crossForkData.receiver = msg.sender;&#13;
        crossForkData.amount = 0;&#13;
        crossForkData.createTime = now;&#13;
        CrossForkDistribution crossfork = CrossForkDistribution(crossForkDistribution);&#13;
        crossfork.getDistributedAmount(crossForkCount, _btcAddress, msg.sender);&#13;
        LogTriggerCrossFork(btcAddressHash, crossForkIds[_btcAddress], ForkResultCode.TRIGGERED);&#13;
        return ForkResultCode.TRIGGERED;&#13;
    }&#13;
    &#13;
    function _transfer(address _from, address _to, uint _value) internal {&#13;
        require (_to != 0x0);&#13;
        require (balanceOf[_from] &gt; _value);&#13;
        require (balanceOf[_to] + _value &gt; balanceOf[_to]);&#13;
        require(!frozenAccount[_from]);&#13;
        require(!frozenAccount[_to]);&#13;
        balanceOf[_from] -= _value;&#13;
        balanceOf[_to] += _value;&#13;
        Transfer(_from, _to, _value);&#13;
    }&#13;
    &#13;
    function freezeAccount(address _target, bool _freeze) onlyOwner public {&#13;
        frozenAccount[_target] = _freeze;&#13;
        FrozenFunds(_target, _freeze);&#13;
    }&#13;
    &#13;
    function buy() payable isTrading public {&#13;
        uint amount = msg.value / buyPrice;&#13;
        _transfer(this, msg.sender, amount);&#13;
    }&#13;
&#13;
    function sell(uint256 amount) isTrading public {&#13;
        require(this.balance &gt;= amount * sellPrice);&#13;
        _transfer(msg.sender, this, amount);&#13;
        msg.sender.transfer(amount * sellPrice);&#13;
    }&#13;
    &#13;
    &#13;
}