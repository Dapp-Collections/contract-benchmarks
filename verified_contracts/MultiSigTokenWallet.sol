pragma solidity 0.4.16;

/// @title Multi signature token wallet - Allows multiple parties to approve tokens transfer
/// @author popofe (Avalon Platform) - <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="bfcfd0cfd0d9daffdec9ded3d0d191d1ca">[emailÂ protected]</a>&gt;&#13;
&#13;
contract MultiSigTokenWallet {&#13;
    /// @dev No fallback function to prevent ether deposit&#13;
&#13;
    address constant public TOKEN = 0xeD247980396B10169BB1d36f6e278eD16700a60f;&#13;
&#13;
    event Confirmation(address source, uint actionId);&#13;
    event Revocation(address source, uint actionId);&#13;
    event NewAction(uint actionId);&#13;
    event Execution(uint actionId);&#13;
    event ExecutionFailure(uint actionId);&#13;
    event OwnerAddition(address owner);&#13;
    event OwnerWithdraw(address owner);&#13;
    event QuorumChange(uint quorum);&#13;
&#13;
    enum ActionChoices { AddOwner, ChangeQuorum, DeleteAction, TransferToken, WithdrawOwner}&#13;
    mapping (uint =&gt; Action) public actions;&#13;
    mapping (uint =&gt; mapping (address =&gt; bool)) public confirmations;&#13;
    mapping (address =&gt; bool) public isOwner;&#13;
    address[] public owners;&#13;
    uint public quorum;&#13;
    uint public actionCount;&#13;
&#13;
    struct Action {&#13;
        address addressField;&#13;
        uint value;&#13;
        ActionChoices actionType;&#13;
        bool executed;&#13;
        bool deleted;&#13;
    }&#13;
&#13;
    modifier ownerDeclared(address owner) {&#13;
        require (isOwner[owner]);&#13;
        _;&#13;
    }&#13;
&#13;
    modifier actionSubmitted(uint actionId) {&#13;
        require (   actions[actionId].addressField != 0&#13;
                 || actions[actionId].value != 0);&#13;
        _;&#13;
    }&#13;
&#13;
    modifier confirmed(uint actionId, address owner) {&#13;
        require (confirmations[actionId][owner]);&#13;
        _;&#13;
    }&#13;
&#13;
    modifier notConfirmed(uint actionId, address owner) {&#13;
        require (!confirmations[actionId][owner]);&#13;
        _;&#13;
    }&#13;
&#13;
    modifier notExecuted(uint actionId) {&#13;
        require (!actions[actionId].executed);&#13;
        _;&#13;
    }&#13;
&#13;
    modifier notDeleted(uint actionId) {&#13;
        require (!actions[actionId].deleted);&#13;
        _;&#13;
    }&#13;
&#13;
    modifier validQuorum(uint ownerCount, uint _quorum) {&#13;
        require (_quorum &lt;= ownerCount &amp;&amp; _quorum &gt; 0);&#13;
        _;&#13;
    }&#13;
&#13;
    modifier validAction(address  addressField, uint value, ActionChoices actionType) {&#13;
        require ((actionType == ActionChoices.AddOwner &amp;&amp; addressField != 0 &amp;&amp; value == 0)&#13;
                || (actionType == ActionChoices.ChangeQuorum &amp;&amp; addressField == 0 &amp;&amp; value &gt; 0)&#13;
                || (actionType == ActionChoices.DeleteAction &amp;&amp; addressField == 0 &amp;&amp; value &gt; 0)&#13;
                || (actionType == ActionChoices.TransferToken &amp;&amp; addressField != 0 &amp;&amp; value &gt; 0)&#13;
                || (actionType == ActionChoices.WithdrawOwner &amp;&amp; addressField != 0 &amp;&amp; value == 0));&#13;
        _;&#13;
    }&#13;
&#13;
    /*&#13;
     * Public functions&#13;
     */&#13;
    /// @dev Contract constructor sets initial owners and required number of confirmations.&#13;
    /// @param _owners List of initial owners.&#13;
    /// @param _quorum Number of required confirmations.&#13;
    function MultiSigTokenWallet(address[] _owners, uint _quorum)&#13;
        public&#13;
        validQuorum(_owners.length, _quorum)&#13;
    {&#13;
        for (uint i=0; i&lt;_owners.length; i++) {&#13;
            require (!isOwner[_owners[i]] &amp;&amp; _owners[i] != 0);&#13;
            isOwner[_owners[i]] = true;&#13;
        }&#13;
        owners = _owners;&#13;
        quorum = _quorum;&#13;
    }&#13;
&#13;
    /// @dev Allows to add a new owner. &#13;
    /// @param owner Address of new owner.&#13;
    function addOwner(address owner)&#13;
        private&#13;
    {&#13;
        require(!isOwner[owner]);&#13;
        isOwner[owner] = true;&#13;
        owners.push(owner);&#13;
        OwnerAddition(owner);&#13;
    }&#13;
&#13;
    /// @dev Allows to withdraw an owner. &#13;
    /// @param owner Address of owner.&#13;
    function withdrawOwner(address owner)&#13;
        private&#13;
    {&#13;
        require (isOwner[owner]);&#13;
        require (owners.length - 1 &gt;= quorum);&#13;
        isOwner[owner] = false;&#13;
        for (uint i=0; i&lt;owners.length - 1; i++)&#13;
            if (owners[i] == owner) {&#13;
                owners[i] = owners[owners.length - 1];&#13;
                break;&#13;
            }&#13;
        owners.length -= 1;&#13;
        OwnerWithdraw(owner);&#13;
    }&#13;
&#13;
    /// @dev Allows to change the number of required confirmations.&#13;
    /// @param _quorum Number of required confirmations.&#13;
    function changeQuorum(uint _quorum)&#13;
        private&#13;
    {&#13;
        require (_quorum &gt; 0 &amp;&amp; _quorum &lt;= owners.length);&#13;
        quorum = _quorum;&#13;
        QuorumChange(_quorum);&#13;
    }&#13;
&#13;
    /// @dev Allows to delete a previous action not executed&#13;
    /// @param _actionId Number of required confirmations.&#13;
    function deleteAction(uint _actionId)&#13;
        private&#13;
        notExecuted(_actionId)&#13;
    {&#13;
        actions[_actionId].deleted = true;&#13;
    }&#13;
&#13;
    /// @dev Allows to delete a previous action not executed&#13;
    /// @param _destination address that receive tokens.&#13;
    /// @param _value Number of tokens.&#13;
    function transferToken(address _destination, uint _value)&#13;
        private&#13;
        returns (bool)&#13;
    {&#13;
        ERC20Basic ERC20Contract = ERC20Basic(TOKEN);&#13;
        return ERC20Contract.transfer(_destination, _value);&#13;
    }&#13;
&#13;
    /// @dev Allows an owner to submit and confirm a transaction.&#13;
    /// @param addressField Action target address.&#13;
    /// @param value Number of token / new quorum to reach.&#13;
    /// @return Returns transaction ID.&#13;
    function submitAction(address addressField, uint value, ActionChoices actionType)&#13;
        public&#13;
        ownerDeclared(msg.sender)&#13;
        validAction(addressField, value, actionType)&#13;
        returns (uint actionId)&#13;
    {&#13;
        actionId = addAction(addressField, value, actionType);&#13;
        confirmAction(actionId);&#13;
    }&#13;
&#13;
    /// @dev Allows an owner to confirm a transaction.&#13;
    /// @param actionId Action ID.&#13;
    function confirmAction(uint actionId)&#13;
        public&#13;
        ownerDeclared(msg.sender)&#13;
        actionSubmitted(actionId)&#13;
        notConfirmed(actionId, msg.sender)&#13;
    {&#13;
        confirmations[actionId][msg.sender] = true;&#13;
        Confirmation(msg.sender, actionId);&#13;
    }&#13;
&#13;
    /// @dev Allows an owner to revoke a confirmation for a transaction.&#13;
    /// @param actionId Action ID.&#13;
    function revokeConfirmation(uint actionId)&#13;
        public&#13;
        ownerDeclared(msg.sender)&#13;
        confirmed(actionId, msg.sender)&#13;
        notExecuted(actionId)&#13;
    {&#13;
        confirmations[actionId][msg.sender] = false;&#13;
        Revocation(msg.sender, actionId);&#13;
    }&#13;
&#13;
    /// @dev Allows anyone to execute a confirmed transaction.&#13;
    /// @param actionId Action ID.&#13;
    function executeAction(uint actionId)&#13;
        public&#13;
        ownerDeclared(msg.sender)&#13;
        actionSubmitted(actionId)&#13;
        notExecuted(actionId)&#13;
        notDeleted(actionId)&#13;
    {&#13;
        if (isConfirmed(actionId)) {&#13;
            Action memory action = actions[actionId];&#13;
            action.executed = true;&#13;
            if (action.actionType == ActionChoices.AddOwner)&#13;
                addOwner(action.addressField);&#13;
            else if (action.actionType == ActionChoices.ChangeQuorum)&#13;
                changeQuorum(action.value);&#13;
            else if (action.actionType == ActionChoices.DeleteAction)&#13;
                deleteAction(action.value);&#13;
            else if (action.actionType == ActionChoices.TransferToken)&#13;
                if (transferToken(action.addressField, action.value))&#13;
                    Execution(actionId);&#13;
                else {    &#13;
                    ExecutionFailure(actionId);&#13;
                    action.executed = false;&#13;
                }&#13;
            else if (action.actionType == ActionChoices.WithdrawOwner)&#13;
                withdrawOwner(action.addressField);&#13;
            else&#13;
                revert();&#13;
        }&#13;
    }&#13;
&#13;
    /// @dev Returns the confirmation status of a transaction.&#13;
    /// @param actionId Action ID.&#13;
    /// @return Confirmation status.&#13;
    function isConfirmed(uint actionId)&#13;
        public&#13;
        constant&#13;
        returns (bool)&#13;
    {&#13;
        uint count = 0;&#13;
        for (uint i=0; i&lt;owners.length; i++) {&#13;
            if (confirmations[actionId][owners[i]])&#13;
                count += 1;&#13;
            if (count == quorum)&#13;
                return true;&#13;
        }&#13;
        return false;&#13;
    }&#13;
&#13;
    /// @dev Adds a new action to the transaction list, if action does not exist yet.&#13;
    /// @param addressField address to send token or too add or withadraw as owner.&#13;
    /// @param value number of tokens (useful only for token transfer).&#13;
    /// @return Returns transaction ID.&#13;
    function addAction(address addressField, uint value, ActionChoices actionType)&#13;
        private&#13;
        returns (uint)&#13;
    {&#13;
        actionCount += 1;&#13;
        uint actionId = actionCount;&#13;
        actions[actionId] = Action({&#13;
            addressField: addressField,&#13;
            value: value,&#13;
            actionType: actionType,&#13;
            executed: false,&#13;
            deleted: false&#13;
        });&#13;
        NewAction(actionId);&#13;
        return actionId;&#13;
    }&#13;
&#13;
    /// @dev Returns number of confirmations of an action.&#13;
    /// @param actionId Action ID.&#13;
    /// @return Number of confirmations.&#13;
    function getConfirmationCount(uint actionId)&#13;
        public&#13;
        constant&#13;
        returns (uint count)&#13;
    {&#13;
        for (uint i=0; i&lt;owners.length; i++)&#13;
            if (confirmations[actionId][owners[i]])&#13;
                count += 1;&#13;
    }&#13;
&#13;
    /// @dev Returns total number of actions after filers are applied.&#13;
    /// @param pending Include pending actions.&#13;
    /// @param executed Include executed actions.&#13;
    /// @return Total number of actions after filters are applied.&#13;
    function getActionCount(bool pending, bool executed, bool exceptDeleted)&#13;
        public&#13;
        constant&#13;
        returns (uint count)&#13;
    {&#13;
        for (uint i=0; i&lt;actionCount; i++)&#13;
            if (   ((pending &amp;&amp; !actions[i].executed)&#13;
                    || (executed &amp;&amp; actions[i].executed))&#13;
                &amp;&amp; (!exceptDeleted || !actions[i].deleted))&#13;
                count += 1;&#13;
    }&#13;
&#13;
    /// @dev Returns list of owners.&#13;
    /// @return List of owner addresses.&#13;
    function getOwners()&#13;
        public&#13;
        constant&#13;
        returns (address[])&#13;
    {&#13;
        return owners;&#13;
    }&#13;
&#13;
    /// @dev Returns array with owner addresses, which confirmed transaction.&#13;
    /// @param actionId Action ID.&#13;
    /// @return Returns array of owner addresses.&#13;
    function getConfirmations(uint actionId)&#13;
        public&#13;
        constant&#13;
        returns (address[] _confirmations)&#13;
    {&#13;
        address[] memory confirmationsTemp = new address[](owners.length);&#13;
        uint count = 0;&#13;
        uint i;&#13;
        for (i=0; i&lt;owners.length; i++)&#13;
            if (confirmations[actionId][owners[i]]) {&#13;
                confirmationsTemp[count] = owners[i];&#13;
                count += 1;&#13;
            }&#13;
        _confirmations = new address[](count);&#13;
        for (i=0; i&lt;count; i++)&#13;
            _confirmations[i] = confirmationsTemp[i];&#13;
    }&#13;
&#13;
    /// @dev Returns list of action IDs in defined range.&#13;
    /// @param pending Include pending actions.&#13;
    /// @param executed Include executed actions.&#13;
    /// @param exceptDeleted Exclude deleted actions.&#13;
    /// @return Returns array of transaction IDs.&#13;
    function getActionIds(bool pending, bool executed, bool exceptDeleted)&#13;
        public&#13;
        constant&#13;
        returns (uint[] memory)&#13;
    {&#13;
        uint[] memory actionIds;&#13;
        uint count = 0;&#13;
        uint i;&#13;
        for (i=0; i&lt;actionCount; i++)&#13;
            if (((pending &amp;&amp; !actions[i].executed)&#13;
                 || (executed &amp;&amp; actions[i].executed))&#13;
                &amp;&amp; (!exceptDeleted || !actions[i].deleted))&#13;
            {&#13;
                actionIds[count] = i;&#13;
                count += 1;&#13;
            }&#13;
            &#13;
    }&#13;
}&#13;
&#13;
&#13;
/**&#13;
 * @title ERC20Basic&#13;
 * @dev Simpler version of ERC20 interface&#13;
 * @dev see https://github.com/ethereum/EIPs/issues/179&#13;
 */&#13;
contract ERC20Basic {&#13;
  uint256 public totalSupply;&#13;
  function balanceOf(address who) constant returns (uint256);&#13;
  function transfer(address to, uint256 value) returns (bool);&#13;
  event Transfer(address indexed from, address indexed to, uint256 value);&#13;
}