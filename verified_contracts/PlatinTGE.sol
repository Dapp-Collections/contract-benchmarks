pragma solidity ^0.4.25; // solium-disable-line linebreak-style

/**
 * @author Anatolii Kucheruk (<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="c4a5aaa5b0aba8adad84b4a8a5b0adaaeaadab">[email protected]</a>)&#13;
 * @author Platin Limited, platin.io (<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="5a2a363b2e33341a2a363b2e3334743335">[email protected]</a>)&#13;
 */&#13;
&#13;
/**&#13;
 * @title SafeMath&#13;
 * @dev Math operations with safety checks that throw on error&#13;
 */&#13;
library SafeMath {&#13;
&#13;
  /**&#13;
  * @dev Multiplies two numbers, throws on overflow.&#13;
  */&#13;
  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {&#13;
    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the&#13;
    // benefit is lost if 'b' is also tested.&#13;
    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522&#13;
    if (_a == 0) {&#13;
      return 0;&#13;
    }&#13;
&#13;
    c = _a * _b;&#13;
    assert(c / _a == _b);&#13;
    return c;&#13;
  }&#13;
&#13;
  /**&#13;
  * @dev Integer division of two numbers, truncating the quotient.&#13;
  */&#13;
  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {&#13;
    // assert(_b &gt; 0); // Solidity automatically throws when dividing by 0&#13;
    // uint256 c = _a / _b;&#13;
    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold&#13;
    return _a / _b;&#13;
  }&#13;
&#13;
  /**&#13;
  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).&#13;
  */&#13;
  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {&#13;
    assert(_b &lt;= _a);&#13;
    return _a - _b;&#13;
  }&#13;
&#13;
  /**&#13;
  * @dev Adds two numbers, throws on overflow.&#13;
  */&#13;
  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {&#13;
    c = _a + _b;&#13;
    assert(c &gt;= _a);&#13;
    return c;&#13;
  }&#13;
}&#13;
&#13;
/**&#13;
 * @title Ownable&#13;
 * @dev The Ownable contract has an owner address, and provides basic authorization control&#13;
 * functions, this simplifies the implementation of "user permissions".&#13;
 */&#13;
contract Ownable {&#13;
  address public owner;&#13;
&#13;
&#13;
  event OwnershipRenounced(address indexed previousOwner);&#13;
  event OwnershipTransferred(&#13;
    address indexed previousOwner,&#13;
    address indexed newOwner&#13;
  );&#13;
&#13;
&#13;
  /**&#13;
   * @dev The Ownable constructor sets the original `owner` of the contract to the sender&#13;
   * account.&#13;
   */&#13;
  constructor() public {&#13;
    owner = msg.sender;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Throws if called by any account other than the owner.&#13;
   */&#13;
  modifier onlyOwner() {&#13;
    require(msg.sender == owner);&#13;
    _;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Allows the current owner to relinquish control of the contract.&#13;
   * @notice Renouncing to ownership will leave the contract without an owner.&#13;
   * It will not be possible to call the functions with the `onlyOwner`&#13;
   * modifier anymore.&#13;
   */&#13;
  function renounceOwnership() public onlyOwner {&#13;
    emit OwnershipRenounced(owner);&#13;
    owner = address(0);&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Allows the current owner to transfer control of the contract to a newOwner.&#13;
   * @param _newOwner The address to transfer ownership to.&#13;
   */&#13;
  function transferOwnership(address _newOwner) public onlyOwner {&#13;
    _transferOwnership(_newOwner);&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Transfers control of the contract to a newOwner.&#13;
   * @param _newOwner The address to transfer ownership to.&#13;
   */&#13;
  function _transferOwnership(address _newOwner) internal {&#13;
    require(_newOwner != address(0));&#13;
    emit OwnershipTransferred(owner, _newOwner);&#13;
    owner = _newOwner;&#13;
  }&#13;
}&#13;
&#13;
/**&#13;
 * @title Contracts that should not own Ether&#13;
 * @author Remco Bloemen &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="f5879098969ab5c7">[email protected]</a>π.com&gt;&#13;
 * @dev This tries to block incoming ether to prevent accidental loss of Ether. Should Ether end up&#13;
 * in the contract, it will allow the owner to reclaim this Ether.&#13;
 * @notice Ether can still be sent to this contract by:&#13;
 * calling functions labeled `payable`&#13;
 * `selfdestruct(contract_address)`&#13;
 * mining directly to the contract address&#13;
 */&#13;
contract HasNoEther is Ownable {&#13;
&#13;
  /**&#13;
  * @dev Constructor that rejects incoming Ether&#13;
  * The `payable` flag is added so we can access `msg.value` without compiler warning. If we&#13;
  * leave out payable, then Solidity will allow inheriting contracts to implement a payable&#13;
  * constructor. By doing it this way we prevent a payable constructor from working. Alternatively&#13;
  * we could use assembly to access msg.value.&#13;
  */&#13;
  constructor() public payable {&#13;
    require(msg.value == 0);&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Disallows direct send by setting a default function without the `payable` flag.&#13;
   */&#13;
  function() external {&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Transfer all Ether held by the contract to the owner.&#13;
   */&#13;
  function reclaimEther() external onlyOwner {&#13;
    owner.transfer(address(this).balance);&#13;
  }&#13;
}&#13;
&#13;
/**&#13;
 * @title SafeERC20&#13;
 * @dev Wrappers around ERC20 operations that throw on failure.&#13;
 * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,&#13;
 * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.&#13;
 */&#13;
library SafeERC20 {&#13;
  function safeTransfer(&#13;
    ERC20Basic _token,&#13;
    address _to,&#13;
    uint256 _value&#13;
  )&#13;
    internal&#13;
  {&#13;
    require(_token.transfer(_to, _value));&#13;
  }&#13;
&#13;
  function safeTransferFrom(&#13;
    ERC20 _token,&#13;
    address _from,&#13;
    address _to,&#13;
    uint256 _value&#13;
  )&#13;
    internal&#13;
  {&#13;
    require(_token.transferFrom(_from, _to, _value));&#13;
  }&#13;
&#13;
  function safeApprove(&#13;
    ERC20 _token,&#13;
    address _spender,&#13;
    uint256 _value&#13;
  )&#13;
    internal&#13;
  {&#13;
    require(_token.approve(_spender, _value));&#13;
  }&#13;
}&#13;
&#13;
/**&#13;
 * @title Contracts that should be able to recover tokens&#13;
 * @author SylTi&#13;
 * @dev This allow a contract to recover any ERC20 token received in a contract by transferring the balance to the contract owner.&#13;
 * This will prevent any accidental loss of tokens.&#13;
 */&#13;
contract CanReclaimToken is Ownable {&#13;
  using SafeERC20 for ERC20Basic;&#13;
&#13;
  /**&#13;
   * @dev Reclaim all ERC20Basic compatible tokens&#13;
   * @param _token ERC20Basic The address of the token contract&#13;
   */&#13;
  function reclaimToken(ERC20Basic _token) external onlyOwner {&#13;
    uint256 balance = _token.balanceOf(this);&#13;
    _token.safeTransfer(owner, balance);&#13;
  }&#13;
&#13;
}&#13;
&#13;
/**&#13;
 * @title Contracts that should not own Tokens&#13;
 * @author Remco Bloemen &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="91e3f4fcf2fed1a3">[email protected]</a>π.com&gt;&#13;
 * @dev This blocks incoming ERC223 tokens to prevent accidental loss of tokens.&#13;
 * Should tokens (any ERC20Basic compatible) end up in the contract, it allows the&#13;
 * owner to reclaim the tokens.&#13;
 */&#13;
contract HasNoTokens is CanReclaimToken {&#13;
&#13;
 /**&#13;
  * @dev Reject all ERC223 compatible tokens&#13;
  * @param _from address The address that is transferring the tokens&#13;
  * @param _value uint256 the amount of the specified token&#13;
  * @param _data Bytes The data passed from the caller.&#13;
  */&#13;
  function tokenFallback(&#13;
    address _from,&#13;
    uint256 _value,&#13;
    bytes _data&#13;
  )&#13;
    external&#13;
    pure&#13;
  {&#13;
    _from;&#13;
    _value;&#13;
    _data;&#13;
    revert();&#13;
  }&#13;
&#13;
}&#13;
&#13;
/**&#13;
 * @title Contracts that should not own Contracts&#13;
 * @author Remco Bloemen &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="0f7d6a626c604f3d">[email protected]</a>π.com&gt;&#13;
 * @dev Should contracts (anything Ownable) end up being owned by this contract, it allows the owner&#13;
 * of this contract to reclaim ownership of the contracts.&#13;
 */&#13;
contract HasNoContracts is Ownable {&#13;
&#13;
  /**&#13;
   * @dev Reclaim ownership of Ownable contracts&#13;
   * @param _contractAddr The address of the Ownable to be reclaimed.&#13;
   */&#13;
  function reclaimContract(address _contractAddr) external onlyOwner {&#13;
    Ownable contractInst = Ownable(_contractAddr);&#13;
    contractInst.transferOwnership(owner);&#13;
  }&#13;
}&#13;
&#13;
/**&#13;
 * @title Base contract for contracts that should not own things.&#13;
 * @author Remco Bloemen &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="4133242c222e0173">[email protected]</a>π.com&gt;&#13;
 * @dev Solves a class of errors where a contract accidentally becomes owner of Ether, Tokens or&#13;
 * Owned contracts. See respective base contracts for details.&#13;
 */&#13;
contract NoOwner is HasNoEther, HasNoTokens, HasNoContracts {&#13;
}&#13;
&#13;
/**&#13;
 * @title Pausable&#13;
 * @dev Base contract which allows children to implement an emergency stop mechanism.&#13;
 */&#13;
contract Pausable is Ownable {&#13;
  event Pause();&#13;
  event Unpause();&#13;
&#13;
  bool public paused = false;&#13;
&#13;
&#13;
  /**&#13;
   * @dev Modifier to make a function callable only when the contract is not paused.&#13;
   */&#13;
  modifier whenNotPaused() {&#13;
    require(!paused);&#13;
    _;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Modifier to make a function callable only when the contract is paused.&#13;
   */&#13;
  modifier whenPaused() {&#13;
    require(paused);&#13;
    _;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev called by the owner to pause, triggers stopped state&#13;
   */&#13;
  function pause() public onlyOwner whenNotPaused {&#13;
    paused = true;&#13;
    emit Pause();&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev called by the owner to unpause, returns to normal state&#13;
   */&#13;
  function unpause() public onlyOwner whenPaused {&#13;
    paused = false;&#13;
    emit Unpause();&#13;
  }&#13;
}&#13;
&#13;
/**&#13;
 * @title Authorizable&#13;
 * @dev Authorizable contract holds a list of control addresses that authorized to do smth.&#13;
 */&#13;
contract Authorizable is Ownable {&#13;
&#13;
    // List of authorized (control) addresses&#13;
    mapping (address =&gt; bool) public authorized;&#13;
&#13;
    // Authorize event logging&#13;
    event Authorize(address indexed who);&#13;
&#13;
    // UnAuthorize event logging&#13;
    event UnAuthorize(address indexed who);&#13;
&#13;
    // onlyAuthorized modifier, restrict to the owner and the list of authorized addresses&#13;
    modifier onlyAuthorized() {&#13;
        require(msg.sender == owner || authorized[msg.sender], "Not Authorized.");&#13;
        _;&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Authorize given address&#13;
     * @param _who address Address to authorize &#13;
     */&#13;
    function authorize(address _who) public onlyOwner {&#13;
        require(_who != address(0), "Address can't be zero.");&#13;
        require(!authorized[_who], "Already authorized");&#13;
&#13;
        authorized[_who] = true;&#13;
        emit Authorize(_who);&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev unAuthorize given address&#13;
     * @param _who address Address to unauthorize &#13;
     */&#13;
    function unAuthorize(address _who) public onlyOwner {&#13;
        require(_who != address(0), "Address can't be zero.");&#13;
        require(authorized[_who], "Address is not authorized");&#13;
&#13;
        authorized[_who] = false;&#13;
        emit UnAuthorize(_who);&#13;
    }&#13;
}&#13;
&#13;
/**&#13;
 * @title ERC20Basic&#13;
 * @dev Simpler version of ERC20 interface&#13;
 * See https://github.com/ethereum/EIPs/issues/179&#13;
 */&#13;
contract ERC20Basic {&#13;
  function totalSupply() public view returns (uint256);&#13;
  function balanceOf(address _who) public view returns (uint256);&#13;
  function transfer(address _to, uint256 _value) public returns (bool);&#13;
  event Transfer(address indexed from, address indexed to, uint256 value);&#13;
}&#13;
&#13;
/**&#13;
 * @title ERC20 interface&#13;
 * @dev see https://github.com/ethereum/EIPs/issues/20&#13;
 */&#13;
contract ERC20 is ERC20Basic {&#13;
  function allowance(address _owner, address _spender)&#13;
    public view returns (uint256);&#13;
&#13;
  function transferFrom(address _from, address _to, uint256 _value)&#13;
    public returns (bool);&#13;
&#13;
  function approve(address _spender, uint256 _value) public returns (bool);&#13;
  event Approval(&#13;
    address indexed owner,&#13;
    address indexed spender,&#13;
    uint256 value&#13;
  );&#13;
}&#13;
&#13;
/**&#13;
 * @title Basic token&#13;
 * @dev Basic version of StandardToken, with no allowances.&#13;
 */&#13;
contract BasicToken is ERC20Basic {&#13;
  using SafeMath for uint256;&#13;
&#13;
  mapping(address =&gt; uint256) internal balances;&#13;
&#13;
  uint256 internal totalSupply_;&#13;
&#13;
  /**&#13;
  * @dev Total number of tokens in existence&#13;
  */&#13;
  function totalSupply() public view returns (uint256) {&#13;
    return totalSupply_;&#13;
  }&#13;
&#13;
  /**&#13;
  * @dev Transfer token for a specified address&#13;
  * @param _to The address to transfer to.&#13;
  * @param _value The amount to be transferred.&#13;
  */&#13;
  function transfer(address _to, uint256 _value) public returns (bool) {&#13;
    require(_value &lt;= balances[msg.sender]);&#13;
    require(_to != address(0));&#13;
&#13;
    balances[msg.sender] = balances[msg.sender].sub(_value);&#13;
    balances[_to] = balances[_to].add(_value);&#13;
    emit Transfer(msg.sender, _to, _value);&#13;
    return true;&#13;
  }&#13;
&#13;
  /**&#13;
  * @dev Gets the balance of the specified address.&#13;
  * @param _owner The address to query the the balance of.&#13;
  * @return An uint256 representing the amount owned by the passed address.&#13;
  */&#13;
  function balanceOf(address _owner) public view returns (uint256) {&#13;
    return balances[_owner];&#13;
  }&#13;
&#13;
}&#13;
&#13;
/**&#13;
 * @title Standard ERC20 token&#13;
 *&#13;
 * @dev Implementation of the basic standard token.&#13;
 * https://github.com/ethereum/EIPs/issues/20&#13;
 * Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol&#13;
 */&#13;
contract StandardToken is ERC20, BasicToken {&#13;
&#13;
  mapping (address =&gt; mapping (address =&gt; uint256)) internal allowed;&#13;
&#13;
&#13;
  /**&#13;
   * @dev Transfer tokens from one address to another&#13;
   * @param _from address The address which you want to send tokens from&#13;
   * @param _to address The address which you want to transfer to&#13;
   * @param _value uint256 the amount of tokens to be transferred&#13;
   */&#13;
  function transferFrom(&#13;
    address _from,&#13;
    address _to,&#13;
    uint256 _value&#13;
  )&#13;
    public&#13;
    returns (bool)&#13;
  {&#13;
    require(_value &lt;= balances[_from]);&#13;
    require(_value &lt;= allowed[_from][msg.sender]);&#13;
    require(_to != address(0));&#13;
&#13;
    balances[_from] = balances[_from].sub(_value);&#13;
    balances[_to] = balances[_to].add(_value);&#13;
    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);&#13;
    emit Transfer(_from, _to, _value);&#13;
    return true;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.&#13;
   * Beware that changing an allowance with this method brings the risk that someone may use both the old&#13;
   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this&#13;
   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:&#13;
   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729&#13;
   * @param _spender The address which will spend the funds.&#13;
   * @param _value The amount of tokens to be spent.&#13;
   */&#13;
  function approve(address _spender, uint256 _value) public returns (bool) {&#13;
    allowed[msg.sender][_spender] = _value;&#13;
    emit Approval(msg.sender, _spender, _value);&#13;
    return true;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Function to check the amount of tokens that an owner allowed to a spender.&#13;
   * @param _owner address The address which owns the funds.&#13;
   * @param _spender address The address which will spend the funds.&#13;
   * @return A uint256 specifying the amount of tokens still available for the spender.&#13;
   */&#13;
  function allowance(&#13;
    address _owner,&#13;
    address _spender&#13;
   )&#13;
    public&#13;
    view&#13;
    returns (uint256)&#13;
  {&#13;
    return allowed[_owner][_spender];&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Increase the amount of tokens that an owner allowed to a spender.&#13;
   * approve should be called when allowed[_spender] == 0. To increment&#13;
   * allowed value is better to use this function to avoid 2 calls (and wait until&#13;
   * the first transaction is mined)&#13;
   * From MonolithDAO Token.sol&#13;
   * @param _spender The address which will spend the funds.&#13;
   * @param _addedValue The amount of tokens to increase the allowance by.&#13;
   */&#13;
  function increaseApproval(&#13;
    address _spender,&#13;
    uint256 _addedValue&#13;
  )&#13;
    public&#13;
    returns (bool)&#13;
  {&#13;
    allowed[msg.sender][_spender] = (&#13;
      allowed[msg.sender][_spender].add(_addedValue));&#13;
    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);&#13;
    return true;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Decrease the amount of tokens that an owner allowed to a spender.&#13;
   * approve should be called when allowed[_spender] == 0. To decrement&#13;
   * allowed value is better to use this function to avoid 2 calls (and wait until&#13;
   * the first transaction is mined)&#13;
   * From MonolithDAO Token.sol&#13;
   * @param _spender The address which will spend the funds.&#13;
   * @param _subtractedValue The amount of tokens to decrease the allowance by.&#13;
   */&#13;
  function decreaseApproval(&#13;
    address _spender,&#13;
    uint256 _subtractedValue&#13;
  )&#13;
    public&#13;
    returns (bool)&#13;
  {&#13;
    uint256 oldValue = allowed[msg.sender][_spender];&#13;
    if (_subtractedValue &gt;= oldValue) {&#13;
      allowed[msg.sender][_spender] = 0;&#13;
    } else {&#13;
      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);&#13;
    }&#13;
    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);&#13;
    return true;&#13;
  }&#13;
&#13;
}&#13;
&#13;
/**&#13;
 * @title Holders Token&#13;
 * @dev Extension to the OpenZepellin's StandardToken contract to track token holders.&#13;
 * Only holders with the non-zero balance are listed.&#13;
 */&#13;
contract HoldersToken is StandardToken {&#13;
    using SafeMath for uint256;    &#13;
&#13;
    // holders list&#13;
    address[] public holders;&#13;
&#13;
    // holder number in the list&#13;
    mapping (address =&gt; uint256) public holderNumber;&#13;
&#13;
    /**&#13;
     * @dev Get the holders count&#13;
     * @return uint256 Holders count&#13;
     */&#13;
    function holdersCount() public view returns (uint256) {&#13;
        return holders.length;&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Transfer tokens from one address to another preserving token holders&#13;
     * @param _to address The address which you want to transfer to&#13;
     * @param _value uint256 The amount of tokens to be transferred&#13;
     * @return bool Returns true if the transfer was succeeded&#13;
     */&#13;
    function transfer(address _to, uint256 _value) public returns (bool) {&#13;
        _preserveHolders(msg.sender, _to, _value);&#13;
        return super.transfer(_to, _value);&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Transfer tokens from one address to another preserving token holders&#13;
     * @param _from address The address which you want to send tokens from&#13;
     * @param _to address The address which you want to transfer to&#13;
     * @param _value uint256 The amount of tokens to be transferred&#13;
     * @return bool Returns true if the transfer was succeeded&#13;
     */&#13;
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {&#13;
        _preserveHolders(_from, _to, _value);&#13;
        return super.transferFrom(_from, _to, _value);&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Remove holder from the holders list&#13;
     * @param _holder address Address of the holder to remove&#13;
     */&#13;
    function _removeHolder(address _holder) internal {&#13;
        uint256 _number = holderNumber[_holder];&#13;
&#13;
        if (_number == 0 || holders.length == 0 || _number &gt; holders.length)&#13;
            return;&#13;
&#13;
        uint256 _index = _number.sub(1);&#13;
        uint256 _lastIndex = holders.length.sub(1);&#13;
        address _lastHolder = holders[_lastIndex];&#13;
&#13;
        if (_index != _lastIndex) {&#13;
            holders[_index] = _lastHolder;&#13;
            holderNumber[_lastHolder] = _number;&#13;
        }&#13;
&#13;
        holderNumber[_holder] = 0;&#13;
        holders.length = _lastIndex;&#13;
    } &#13;
&#13;
    /**&#13;
     * @dev Add holder to the holders list&#13;
     * @param _holder address Address of the holder to add   &#13;
     */&#13;
    function _addHolder(address _holder) internal {&#13;
        if (holderNumber[_holder] == 0) {&#13;
            holders.push(_holder);&#13;
            holderNumber[_holder] = holders.length;&#13;
        }&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Preserve holders during transfers&#13;
     * @param _from address The address which you want to send tokens from&#13;
     * @param _to address The address which you want to transfer to&#13;
     * @param _value uint256 the amount of tokens to be transferred&#13;
     */&#13;
    function _preserveHolders(address _from, address _to, uint256 _value) internal {&#13;
        _addHolder(_to);   &#13;
        if (balanceOf(_from).sub(_value) == 0) &#13;
            _removeHolder(_from);&#13;
    }&#13;
}&#13;
&#13;
/**&#13;
 * @title PlatinToken&#13;
 * @dev Platin PTNX Token contract. Tokens are allocated during TGE.&#13;
 * Token contract is a standard ERC20 token with additional capabilities: TGE allocation, holders tracking and lockup.&#13;
 * Initial allocation should be invoked by the TGE contract at the TGE moment of time.&#13;
 * Token contract holds list of token holders, the list includes holders with positive balance only.&#13;
 * Authorized holders can transfer token with lockup(s). Lockups can be refundable. &#13;
 * Lockups is a list of releases dates and releases amounts.&#13;
 * In case of refund previous holder can get back locked up tokens. Only still locked up amounts can be transferred back.&#13;
 */&#13;
contract PlatinToken is HoldersToken, NoOwner, Authorizable, Pausable {&#13;
    using SafeMath for uint256;&#13;
&#13;
    string public constant name = "Platin Token"; // solium-disable-line uppercase&#13;
    string public constant symbol = "PTNX"; // solium-disable-line uppercase&#13;
    uint8 public constant decimals = 18; // solium-disable-line uppercase&#13;
 &#13;
    // lockup sruct&#13;
    struct Lockup {&#13;
        uint256 release; // release timestamp&#13;
        uint256 amount; // amount of tokens to release&#13;
    }&#13;
&#13;
    // list of lockups&#13;
    mapping (address =&gt; Lockup[]) public lockups;&#13;
&#13;
    // list of lockups that can be refunded&#13;
    mapping (address =&gt; mapping (address =&gt; Lockup[])) public refundable;&#13;
&#13;
    // idexes mapping from refundable to lockups lists &#13;
    mapping (address =&gt; mapping (address =&gt; mapping (uint256 =&gt; uint256))) public indexes;    &#13;
&#13;
    // Platin TGE contract&#13;
    PlatinTGE public tge;&#13;
&#13;
    // allocation event logging&#13;
    event Allocate(address indexed to, uint256 amount);&#13;
&#13;
    // lockup event logging&#13;
    event SetLockups(address indexed to, uint256 amount, uint256 fromIdx, uint256 toIdx);&#13;
&#13;
    // refund event logging&#13;
    event Refund(address indexed from, address indexed to, uint256 amount);&#13;
&#13;
    // spotTransfer modifier, check balance spot on transfer&#13;
    modifier spotTransfer(address _from, uint256 _value) {&#13;
        require(_value &lt;= balanceSpot(_from), "Attempt to transfer more than balance spot.");&#13;
        _;&#13;
    }&#13;
&#13;
    // onlyTGE modifier, restrict to the TGE contract only&#13;
    modifier onlyTGE() {&#13;
        require(msg.sender == address(tge), "Only TGE method.");&#13;
        _;&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Set TGE contract&#13;
     * @param _tge address PlatinTGE contract address    &#13;
     */&#13;
    function setTGE(PlatinTGE _tge) external onlyOwner {&#13;
        require(tge == address(0), "TGE is already set.");&#13;
        require(_tge != address(0), "TGE address can't be zero.");&#13;
        tge = _tge;&#13;
        authorize(_tge);&#13;
    }        &#13;
&#13;
    /**&#13;
     * @dev Allocate tokens during TGE&#13;
     * @param _to address Address gets the tokens&#13;
     * @param _amount uint256 Amount to allocate&#13;
     */ &#13;
    function allocate(address _to, uint256 _amount) external onlyTGE {&#13;
        require(_to != address(0), "Allocate To address can't be zero");&#13;
        require(_amount &gt; 0, "Allocate amount should be &gt; 0.");&#13;
       &#13;
        totalSupply_ = totalSupply_.add(_amount);&#13;
        balances[_to] = balances[_to].add(_amount);&#13;
&#13;
        _addHolder(_to);&#13;
&#13;
        require(totalSupply_ &lt;= tge.TOTAL_SUPPLY(), "Can't allocate more than TOTAL SUPPLY.");&#13;
&#13;
        emit Allocate(_to, _amount);&#13;
        emit Transfer(address(0), _to, _amount);&#13;
    }  &#13;
&#13;
    /**&#13;
     * @dev Transfer tokens from one address to another&#13;
     * @param _to address The address which you want to transfer to&#13;
     * @param _value uint256 The amount of tokens to be transferred&#13;
     * @return bool Returns true if the transfer was succeeded&#13;
     */&#13;
    function transfer(address _to, uint256 _value) public whenNotPaused spotTransfer(msg.sender, _value) returns (bool) {&#13;
        return super.transfer(_to, _value);&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Transfer tokens from one address to another&#13;
     * @param _from address The address which you want to send tokens from&#13;
     * @param _to address The address which you want to transfer to&#13;
     * @param _value uint256 The amount of tokens to be transferred&#13;
     * @return bool Returns true if the transfer was succeeded&#13;
     */&#13;
    function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused spotTransfer(_from, _value) returns (bool) {&#13;
        return super.transferFrom(_from, _to, _value);&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Transfer tokens from one address to another with lockup&#13;
     * @param _to address The address which you want to transfer to&#13;
     * @param _value uint256 The amount of tokens to be transferred&#13;
     * @param _lockupReleases uint256[] List of lockup releases&#13;
     * @param _lockupAmounts uint256[] List of lockup amounts&#13;
     * @param _refundable bool Is locked up amount refundable&#13;
     * @return bool Returns true if the transfer was succeeded     &#13;
     */&#13;
    function transferWithLockup(&#13;
        address _to, &#13;
        uint256 _value, &#13;
        uint256[] _lockupReleases,&#13;
        uint256[] _lockupAmounts,&#13;
        bool _refundable&#13;
    ) &#13;
    public onlyAuthorized returns (bool)&#13;
    {        &#13;
        transfer(_to, _value);&#13;
        _lockup(_to, _value, _lockupReleases, _lockupAmounts, _refundable); // solium-disable-line arg-overflow     &#13;
    }       &#13;
&#13;
    /**&#13;
     * @dev Transfer tokens from one address to another with lockup&#13;
     * @param _from address The address which you want to send tokens from&#13;
     * @param _to address The address which you want to transfer to&#13;
     * @param _value uint256 The amount of tokens to be transferred&#13;
     * @param _lockupReleases uint256[] List of lockup releases&#13;
     * @param _lockupAmounts uint256[] List of lockup amounts&#13;
     * @param _refundable bool Is locked up amount refundable      &#13;
     * @return bool Returns true if the transfer was succeeded     &#13;
     */&#13;
    function transferFromWithLockup(&#13;
        address _from, &#13;
        address _to, &#13;
        uint256 _value, &#13;
        uint256[] _lockupReleases,&#13;
        uint256[] _lockupAmounts,&#13;
        bool _refundable&#13;
    ) &#13;
    public onlyAuthorized returns (bool)&#13;
    {&#13;
        transferFrom(_from, _to, _value);&#13;
        _lockup(_to, _value, _lockupReleases, _lockupAmounts, _refundable); // solium-disable-line arg-overflow  &#13;
    }     &#13;
&#13;
    /**&#13;
     * @dev Refund refundable locked up amount&#13;
     * @param _from address The address which you want to refund tokens from&#13;
     * @return uint256 Returns amount of refunded tokens   &#13;
     */&#13;
    function refundLockedUp(&#13;
        address _from&#13;
    )&#13;
    public onlyAuthorized returns (uint256)&#13;
    {&#13;
        address _sender = msg.sender;&#13;
        uint256 _balanceRefundable = 0;&#13;
        uint256 _refundableLength = refundable[_from][_sender].length;&#13;
        if (_refundableLength &gt; 0) {&#13;
            uint256 _lockupIdx;&#13;
            for (uint256 i = 0; i &lt; _refundableLength; i++) {&#13;
                if (refundable[_from][_sender][i].release &gt; block.timestamp) { // solium-disable-line security/no-block-members&#13;
                    _balanceRefundable = _balanceRefundable.add(refundable[_from][_sender][i].amount);&#13;
                    refundable[_from][_sender][i].release = 0;&#13;
                    refundable[_from][_sender][i].amount = 0;&#13;
                    _lockupIdx = indexes[_from][_sender][i];&#13;
                    lockups[_from][_lockupIdx].release = 0;&#13;
                    lockups[_from][_lockupIdx].amount = 0;       &#13;
                }    &#13;
            }&#13;
&#13;
            if (_balanceRefundable &gt; 0) {&#13;
                _preserveHolders(_from, _sender, _balanceRefundable);&#13;
                balances[_from] = balances[_from].sub(_balanceRefundable);&#13;
                balances[_sender] = balances[_sender].add(_balanceRefundable);&#13;
                emit Refund(_from, _sender, _balanceRefundable);&#13;
                emit Transfer(_from, _sender, _balanceRefundable);&#13;
            }&#13;
        }&#13;
        return _balanceRefundable;&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Get the lockups list count&#13;
     * @param _who address Address owns locked up list&#13;
     * @return uint256 Lockups list count&#13;
     */&#13;
    function lockupsCount(address _who) public view returns (uint256) {&#13;
        return lockups[_who].length;&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Find out if the address has lockups&#13;
     * @param _who address Address checked for lockups&#13;
     * @return bool Returns true if address has lockups&#13;
     */&#13;
    function hasLockups(address _who) public view returns (bool) {&#13;
        return lockups[_who].length &gt; 0;&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Get balance locked up at the current moment of time&#13;
     * @param _who address Address owns locked up amounts&#13;
     * @return uint256 Balance locked up at the current moment of time&#13;
     */&#13;
    function balanceLockedUp(address _who) public view returns (uint256) {&#13;
        uint256 _balanceLokedUp = 0;&#13;
        uint256 _lockupsLength = lockups[_who].length;&#13;
        for (uint256 i = 0; i &lt; _lockupsLength; i++) {&#13;
            if (lockups[_who][i].release &gt; block.timestamp) // solium-disable-line security/no-block-members&#13;
                _balanceLokedUp = _balanceLokedUp.add(lockups[_who][i].amount);&#13;
        }&#13;
        return _balanceLokedUp;&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Get refundable locked up balance at the current moment of time&#13;
     * @param _who address Address owns locked up amounts&#13;
     * @param _sender address Address owned locked up amounts&#13;
     * @return uint256 Locked up refundable balance at the current moment of time&#13;
     */&#13;
    function balanceRefundable(address _who, address _sender) public view returns (uint256) {&#13;
        uint256 _balanceRefundable = 0;&#13;
        uint256 _refundableLength = refundable[_who][_sender].length;&#13;
        if (_refundableLength &gt; 0) {&#13;
            for (uint256 i = 0; i &lt; _refundableLength; i++) {&#13;
                if (refundable[_who][_sender][i].release &gt; block.timestamp) // solium-disable-line security/no-block-members&#13;
                    _balanceRefundable = _balanceRefundable.add(refundable[_who][_sender][i].amount);&#13;
            }&#13;
        }&#13;
        return _balanceRefundable;&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Get balance spot for the current moment of time&#13;
     * @param _who address Address owns balance spot&#13;
     * @return uint256 Balance spot for the current moment of time&#13;
     */&#13;
    function balanceSpot(address _who) public view returns (uint256) {&#13;
        uint256 _balanceSpot = balanceOf(_who);&#13;
        _balanceSpot = _balanceSpot.sub(balanceLockedUp(_who));&#13;
        return _balanceSpot;&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Lockup amount till release time&#13;
     * @param _who address Address gets the locked up amount&#13;
     * @param _amount uint256 Amount to lockup&#13;
     * @param _lockupReleases uint256[] List of lockup releases&#13;
     * @param _lockupAmounts uint256[] List of lockup amounts&#13;
     * @param _refundable bool Is locked up amount refundable     &#13;
     */     &#13;
    function _lockup(&#13;
        address _who, &#13;
        uint256 _amount, &#13;
        uint256[] _lockupReleases,&#13;
        uint256[] _lockupAmounts,&#13;
        bool _refundable) &#13;
    internal &#13;
    {&#13;
        require(_lockupReleases.length == _lockupAmounts.length, "Length of lockup releases and amounts lists should be equal.");&#13;
        require(_lockupReleases.length.add(lockups[_who].length) &lt;= 1000, "Can't be more than 1000 lockups per address.");&#13;
        if (_lockupReleases.length &gt; 0) {&#13;
            uint256 _balanceLokedUp = 0;&#13;
            address _sender = msg.sender;&#13;
            uint256 _fromIdx = lockups[_who].length;&#13;
            uint256 _toIdx = _fromIdx + _lockupReleases.length - 1;&#13;
            uint256 _lockupIdx;&#13;
            uint256 _refundIdx;&#13;
            for (uint256 i = 0; i &lt; _lockupReleases.length; i++) {&#13;
                if (_lockupReleases[i] &gt; block.timestamp) { // solium-disable-line security/no-block-members&#13;
                    lockups[_who].push(Lockup(_lockupReleases[i], _lockupAmounts[i]));&#13;
                    _balanceLokedUp = _balanceLokedUp.add(_lockupAmounts[i]);&#13;
                    if (_refundable) {&#13;
                        refundable[_who][_sender].push(Lockup(_lockupReleases[i], _lockupAmounts[i]));&#13;
                        _lockupIdx = lockups[_who].length - 1;&#13;
                        _refundIdx = refundable[_who][_sender].length - 1;&#13;
                        indexes[_who][_sender][_refundIdx] = _lockupIdx;&#13;
                    }&#13;
                }&#13;
            }&#13;
&#13;
            require(_balanceLokedUp &lt;= _amount, "Can't lockup more than transferred amount.");&#13;
            emit SetLockups(_who, _amount, _fromIdx, _toIdx); // solium-disable-line arg-overflow&#13;
        }            &#13;
    }      &#13;
}&#13;
&#13;
/**&#13;
 * @title PlatinTGE&#13;
 * @dev Platin Token Generation Event contract. It holds token economic constants and makes initial token allocation.&#13;
 * Initial token allocation function should be called outside the blockchain at the TGE moment of time, &#13;
 * from here on out, Platin Token and other Platin contracts become functional.&#13;
 */&#13;
contract PlatinTGE {&#13;
    using SafeMath for uint256;&#13;
    &#13;
    // Token decimals&#13;
    uint8 public constant decimals = 18; // solium-disable-line uppercase&#13;
&#13;
    // Total Tokens Supply&#13;
    uint256 public constant TOTAL_SUPPLY = 1000000000 * (10 ** uint256(decimals)); // 1,000,000,000 PTNX&#13;
&#13;
    // SUPPLY&#13;
    // TOTAL_SUPPLY = 1,000,000,000 PTNX, is distributed as follows:&#13;
    uint256 public constant SALES_SUPPLY = 300000000 * (10 ** uint256(decimals)); // 300,000,000 PTNX - 30%&#13;
    uint256 public constant MINING_POOL_SUPPLY = 200000000 * (10 ** uint256(decimals)); // 200,000,000 PTNX - 20%&#13;
    uint256 public constant FOUNDERS_AND_EMPLOYEES_SUPPLY = 200000000 * (10 ** uint256(decimals)); // 200,000,000 PTNX - 20%&#13;
    uint256 public constant AIRDROPS_POOL_SUPPLY = 100000000 * (10 ** uint256(decimals)); // 100,000,000 PTNX - 10%&#13;
    uint256 public constant RESERVES_POOL_SUPPLY = 100000000 * (10 ** uint256(decimals)); // 100,000,000 PTNX - 10%&#13;
    uint256 public constant ADVISORS_POOL_SUPPLY = 70000000 * (10 ** uint256(decimals)); // 70,000,000 PTNX - 7%&#13;
    uint256 public constant ECOSYSTEM_POOL_SUPPLY = 30000000 * (10 ** uint256(decimals)); // 30,000,000 PTNX - 3%&#13;
&#13;
    // HOLDERS&#13;
    address public PRE_ICO_POOL; // solium-disable-line mixedcase&#13;
    address public LIQUID_POOL; // solium-disable-line mixedcase&#13;
    address public ICO; // solium-disable-line mixedcase&#13;
    address public MINING_POOL; // solium-disable-line mixedcase &#13;
    address public FOUNDERS_POOL; // solium-disable-line mixedcase&#13;
    address public EMPLOYEES_POOL; // solium-disable-line mixedcase &#13;
    address public AIRDROPS_POOL; // solium-disable-line mixedcase &#13;
    address public RESERVES_POOL; // solium-disable-line mixedcase &#13;
    address public ADVISORS_POOL; // solium-disable-line mixedcase&#13;
    address public ECOSYSTEM_POOL; // solium-disable-line mixedcase &#13;
&#13;
    // HOLDER AMOUNT AS PART OF SUPPLY&#13;
    // SALES_SUPPLY = PRE_ICO_POOL_AMOUNT + LIQUID_POOL_AMOUNT + ICO_AMOUNT&#13;
    uint256 public constant PRE_ICO_POOL_AMOUNT = 20000000 * (10 ** uint256(decimals)); // 20,000,000 PTNX&#13;
    uint256 public constant LIQUID_POOL_AMOUNT = 100000000 * (10 ** uint256(decimals)); // 100,000,000 PTNX&#13;
    uint256 public constant ICO_AMOUNT = 180000000 * (10 ** uint256(decimals)); // 180,000,000 PTNX&#13;
    // FOUNDERS_AND_EMPLOYEES_SUPPLY = FOUNDERS_POOL_AMOUNT + EMPLOYEES_POOL_AMOUNT&#13;
    uint256 public constant FOUNDERS_POOL_AMOUNT = 190000000 * (10 ** uint256(decimals)); // 190,000,000 PTNX&#13;
    uint256 public constant EMPLOYEES_POOL_AMOUNT = 10000000 * (10 ** uint256(decimals)); // 10,000,000 PTNX&#13;
&#13;
    // Unsold tokens reserve address&#13;
    address public UNSOLD_RESERVE; // solium-disable-line mixedcase&#13;
&#13;
    // Tokens ico sale with lockup period&#13;
    uint256 public constant ICO_LOCKUP_PERIOD = 182 days;&#13;
    &#13;
    // Platin Token ICO rate, regular&#13;
    uint256 public constant TOKEN_RATE = 1000; &#13;
&#13;
    // Platin Token ICO rate with lockup, 20% bonus&#13;
    uint256 public constant TOKEN_RATE_LOCKUP = 1200;&#13;
&#13;
    // Platin ICO min purchase amount&#13;
    uint256 public constant MIN_PURCHASE_AMOUNT = 1 ether;&#13;
&#13;
    // Platin Token contract&#13;
    PlatinToken public token;&#13;
&#13;
    // TGE time&#13;
    uint256 public tgeTime;&#13;
&#13;
&#13;
    /**&#13;
     * @dev Constructor&#13;
     * @param _tgeTime uint256 TGE moment of time&#13;
     * @param _token address Address of the Platin Token contract       &#13;
     * @param _preIcoPool address Address of the Platin PreICO Pool&#13;
     * @param _liquidPool address Address of the Platin Liquid Pool&#13;
     * @param _ico address Address of the Platin ICO contract&#13;
     * @param _miningPool address Address of the Platin Mining Pool&#13;
     * @param _foundersPool address Address of the Platin Founders Pool&#13;
     * @param _employeesPool address Address of the Platin Employees Pool&#13;
     * @param _airdropsPool address Address of the Platin Airdrops Pool&#13;
     * @param _reservesPool address Address of the Platin Reserves Pool&#13;
     * @param _advisorsPool address Address of the Platin Advisors Pool&#13;
     * @param _ecosystemPool address Address of the Platin Ecosystem Pool  &#13;
     * @param _unsoldReserve address Address of the Platin Unsold Reserve                                 &#13;
     */  &#13;
    constructor(&#13;
        uint256 _tgeTime,&#13;
        PlatinToken _token, &#13;
        address _preIcoPool,&#13;
        address _liquidPool,&#13;
        address _ico,&#13;
        address _miningPool,&#13;
        address _foundersPool,&#13;
        address _employeesPool,&#13;
        address _airdropsPool,&#13;
        address _reservesPool,&#13;
        address _advisorsPool,&#13;
        address _ecosystemPool,&#13;
        address _unsoldReserve&#13;
    ) public {&#13;
        require(_tgeTime &gt;= block.timestamp, "TGE time should be &gt;= current time."); // solium-disable-line security/no-block-members&#13;
        require(_token != address(0), "Token address can't be zero.");&#13;
        require(_preIcoPool != address(0), "PreICO Pool address can't be zero.");&#13;
        require(_liquidPool != address(0), "Liquid Pool address can't be zero.");&#13;
        require(_ico != address(0), "ICO address can't be zero.");&#13;
        require(_miningPool != address(0), "Mining Pool address can't be zero.");&#13;
        require(_foundersPool != address(0), "Founders Pool address can't be zero.");&#13;
        require(_employeesPool != address(0), "Employees Pool address can't be zero.");&#13;
        require(_airdropsPool != address(0), "Airdrops Pool address can't be zero.");&#13;
        require(_reservesPool != address(0), "Reserves Pool address can't be zero.");&#13;
        require(_advisorsPool != address(0), "Advisors Pool address can't be zero.");&#13;
        require(_ecosystemPool != address(0), "Ecosystem Pool address can't be zero.");&#13;
        require(_unsoldReserve != address(0), "Unsold reserve address can't be zero.");&#13;
&#13;
        // Setup tge time&#13;
        tgeTime = _tgeTime;&#13;
&#13;
        // Setup token address&#13;
        token = _token;&#13;
&#13;
        // Setup holder addresses&#13;
        PRE_ICO_POOL = _preIcoPool;&#13;
        LIQUID_POOL = _liquidPool;&#13;
        ICO = _ico;&#13;
        MINING_POOL = _miningPool;&#13;
        FOUNDERS_POOL = _foundersPool;&#13;
        EMPLOYEES_POOL = _employeesPool;&#13;
        AIRDROPS_POOL = _airdropsPool;&#13;
        RESERVES_POOL = _reservesPool;&#13;
        ADVISORS_POOL = _advisorsPool;&#13;
        ECOSYSTEM_POOL = _ecosystemPool;&#13;
&#13;
        // Setup unsold reserve address&#13;
        UNSOLD_RESERVE = _unsoldReserve; &#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Allocate function. Token Generation Event entry point.&#13;
     * It makes initial token allocation according to the initial token supply constants.&#13;
     */&#13;
    function allocate() public {&#13;
&#13;
        // Should be called just after tge time&#13;
        require(block.timestamp &gt;= tgeTime, "Should be called just after tge time."); // solium-disable-line security/no-block-members&#13;
&#13;
        // Should not be allocated already&#13;
        require(token.totalSupply() == 0, "Allocation is already done.");&#13;
&#13;
        // SALES          &#13;
        token.allocate(PRE_ICO_POOL, PRE_ICO_POOL_AMOUNT);&#13;
        token.allocate(LIQUID_POOL, LIQUID_POOL_AMOUNT);&#13;
        token.allocate(ICO, ICO_AMOUNT);&#13;
      &#13;
        // MINING POOL&#13;
        token.allocate(MINING_POOL, MINING_POOL_SUPPLY);&#13;
&#13;
        // FOUNDERS AND EMPLOYEES&#13;
        token.allocate(FOUNDERS_POOL, FOUNDERS_POOL_AMOUNT);&#13;
        token.allocate(EMPLOYEES_POOL, EMPLOYEES_POOL_AMOUNT);&#13;
&#13;
        // AIRDROPS POOL&#13;
        token.allocate(AIRDROPS_POOL, AIRDROPS_POOL_SUPPLY);&#13;
&#13;
        // RESERVES POOL&#13;
        token.allocate(RESERVES_POOL, RESERVES_POOL_SUPPLY);&#13;
&#13;
        // ADVISORS POOL&#13;
        token.allocate(ADVISORS_POOL, ADVISORS_POOL_SUPPLY);&#13;
&#13;
        // ECOSYSTEM POOL&#13;
        token.allocate(ECOSYSTEM_POOL, ECOSYSTEM_POOL_SUPPLY);&#13;
&#13;
        // Check Token Total Supply&#13;
        require(token.totalSupply() == TOTAL_SUPPLY, "Total supply check error.");   &#13;
    }&#13;
}