/* Author: Aleksey Selikhov  <span class="__cf_email__" data-cfemail="d9b8b5bcb2aabca0f7aabcb5b0b2b1b6af99beb4b8b0b5f7bab6b4">[emailÂ protected]</span> */&#13;
&#13;
pragma solidity ^0.4.24;&#13;
&#13;
&#13;
/**&#13;
 * @title CommonModifiersInterface&#13;
 * @dev Base contract which contains common checks.&#13;
 */&#13;
contract CommonModifiersInterface {&#13;
&#13;
  /**&#13;
   * @dev Assemble the given address bytecode. If bytecode exists then the _addr is a contract.&#13;
   */&#13;
  function isContract(address _targetAddress) internal constant returns (bool);&#13;
&#13;
  /**&#13;
   * @dev modifier to allow actions only when the _targetAddress is a contract.&#13;
   */&#13;
  modifier onlyContractAddress(address _targetAddress) {&#13;
    require(isContract(_targetAddress) == true);&#13;
    _;&#13;
  }&#13;
}&#13;
&#13;
&#13;
/**&#13;
 * @title CommonModifiers&#13;
 * @dev Base contract which contains common checks.&#13;
 */&#13;
contract CommonModifiers is CommonModifiersInterface {&#13;
&#13;
  /**&#13;
   * @dev Assemble the given address bytecode. If bytecode exists then the _addr is a contract.&#13;
   */&#13;
  function isContract(address _targetAddress) internal constant returns (bool) {&#13;
    require (_targetAddress != address(0x0));&#13;
&#13;
    uint256 length;&#13;
    assembly {&#13;
      //retrieve the size of the code on target address, this needs assembly&#13;
      length := extcodesize(_targetAddress)&#13;
    }&#13;
    return (length &gt; 0);&#13;
  }&#13;
}&#13;
&#13;
&#13;
/**&#13;
 * @title OwnableInterface&#13;
 * @dev The Ownable contract has an owner address, and provides basic authorization control&#13;
 * functions, this simplifies the implementation of "user permissions".&#13;
 */&#13;
contract OwnableInterface {&#13;
&#13;
  /**&#13;
   * @dev The getter for "owner" contract variable&#13;
   */&#13;
  function getOwner() public constant returns (address);&#13;
&#13;
  /**&#13;
   * @dev Throws if called by any account other than the current owner.&#13;
   */&#13;
  modifier onlyOwner() {&#13;
    require (msg.sender == getOwner());&#13;
    _;&#13;
  }&#13;
}&#13;
&#13;
&#13;
/**&#13;
 * @title Ownable&#13;
 * @dev The Ownable contract has an owner address, and provides basic authorization control&#13;
 * functions, this simplifies the implementation of "user permissions".&#13;
 */&#13;
contract Ownable is OwnableInterface {&#13;
&#13;
  /* Storage */&#13;
&#13;
  address owner = address(0x0);&#13;
  address proposedOwner = address(0x0);&#13;
&#13;
&#13;
  /* Events */&#13;
&#13;
  event OwnerAssignedEvent(address indexed newowner);&#13;
  event OwnershipOfferCreatedEvent(address indexed currentowner, address indexed proposedowner);&#13;
  event OwnershipOfferAcceptedEvent(address indexed currentowner, address indexed proposedowner);&#13;
  event OwnershipOfferCancelledEvent(address indexed currentowner, address indexed proposedowner);&#13;
&#13;
&#13;
  /**&#13;
   * @dev The constructor sets the initial `owner` to the passed account.&#13;
   */&#13;
  constructor () public {&#13;
    owner = msg.sender;&#13;
&#13;
    emit OwnerAssignedEvent(owner);&#13;
  }&#13;
&#13;
&#13;
  /**&#13;
   * @dev Old owner requests transfer ownership to the new owner.&#13;
   * @param _proposedOwner The address to transfer ownership to.&#13;
   */&#13;
  function createOwnershipOffer(address _proposedOwner) external onlyOwner {&#13;
    require (proposedOwner == address(0x0));&#13;
    require (_proposedOwner != address(0x0));&#13;
    require (_proposedOwner != address(this));&#13;
&#13;
    proposedOwner = _proposedOwner;&#13;
&#13;
    emit OwnershipOfferCreatedEvent(owner, _proposedOwner);&#13;
  }&#13;
&#13;
&#13;
  /**&#13;
   * @dev Allows the new owner to accept an ownership offer to contract control.&#13;
   */&#13;
  //noinspection UnprotectedFunction&#13;
  function acceptOwnershipOffer() external {&#13;
    require (proposedOwner != address(0x0));&#13;
    require (msg.sender == proposedOwner);&#13;
&#13;
    address _oldOwner = owner;&#13;
    owner = proposedOwner;&#13;
    proposedOwner = address(0x0);&#13;
&#13;
    emit OwnerAssignedEvent(owner);&#13;
    emit OwnershipOfferAcceptedEvent(_oldOwner, owner);&#13;
  }&#13;
&#13;
&#13;
  /**&#13;
   * @dev Old owner cancels transfer ownership to the new owner.&#13;
   */&#13;
  function cancelOwnershipOffer() external {&#13;
    require (proposedOwner != address(0x0));&#13;
    require (msg.sender == owner || msg.sender == proposedOwner);&#13;
&#13;
    address _oldProposedOwner = proposedOwner;&#13;
    proposedOwner = address(0x0);&#13;
&#13;
    emit OwnershipOfferCancelledEvent(owner, _oldProposedOwner);&#13;
  }&#13;
&#13;
&#13;
  /**&#13;
   * @dev The getter for "owner" contract variable&#13;
   */&#13;
  function getOwner() public constant returns (address) {&#13;
    return owner;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev The getter for "proposedOwner" contract variable&#13;
   */&#13;
  function getProposedOwner() public constant returns (address) {&#13;
    return proposedOwner;&#13;
  }&#13;
}&#13;
&#13;
&#13;
/**&#13;
 * @title ManageableInterface&#13;
 * @dev Contract that allows to grant permissions to any address&#13;
 * @dev In real life we are no able to perform all actions with just one Ethereum address&#13;
 * @dev because risks are too high.&#13;
 * @dev Instead owner delegates rights to manage an contract to the different addresses and&#13;
 * @dev stay able to revoke permissions at any time.&#13;
 */&#13;
contract ManageableInterface {&#13;
&#13;
  /**&#13;
   * @dev Function to check if the manager can perform the action or not&#13;
   * @param _manager        address Manager`s address&#13;
   * @param _permissionName string  Permission name&#13;
   * @return True if manager is enabled and has been granted needed permission&#13;
   */&#13;
  function isManagerAllowed(address _manager, string _permissionName) public constant returns (bool);&#13;
&#13;
  /**&#13;
   * @dev Modifier to use in derived contracts&#13;
   */&#13;
  modifier onlyAllowedManager(string _permissionName) {&#13;
    require(isManagerAllowed(msg.sender, _permissionName) == true);&#13;
    _;&#13;
  }&#13;
}&#13;
&#13;
&#13;
contract Manageable is OwnableInterface,&#13;
                       ManageableInterface {&#13;
&#13;
  /* Storage */&#13;
&#13;
  mapping (address =&gt; bool) managerEnabled;  // hard switch for a manager - on/off&#13;
  mapping (address =&gt; mapping (string =&gt; bool)) managerPermissions;  // detailed info about manager`s permissions&#13;
&#13;
&#13;
  /* Events */&#13;
&#13;
  event ManagerEnabledEvent(address indexed manager);&#13;
  event ManagerDisabledEvent(address indexed manager);&#13;
  event ManagerPermissionGrantedEvent(address indexed manager, bytes32 permission);&#13;
  event ManagerPermissionRevokedEvent(address indexed manager, bytes32 permission);&#13;
&#13;
&#13;
  /* Configure contract */&#13;
&#13;
  /**&#13;
   * @dev Function to add new manager&#13;
   * @param _manager address New manager&#13;
   */&#13;
  function enableManager(address _manager) external onlyOwner onlyValidManagerAddress(_manager) {&#13;
    require(managerEnabled[_manager] == false);&#13;
&#13;
    managerEnabled[_manager] = true;&#13;
&#13;
    emit ManagerEnabledEvent(_manager);&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Function to remove existing manager&#13;
   * @param _manager address Existing manager&#13;
   */&#13;
  function disableManager(address _manager) external onlyOwner onlyValidManagerAddress(_manager) {&#13;
    require(managerEnabled[_manager] == true);&#13;
&#13;
    managerEnabled[_manager] = false;&#13;
&#13;
    emit ManagerDisabledEvent(_manager);&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Function to grant new permission to the manager&#13;
   * @param _manager        address Existing manager&#13;
   * @param _permissionName string  Granted permission name&#13;
   */&#13;
  function grantManagerPermission(&#13;
    address _manager, string _permissionName&#13;
  )&#13;
    external&#13;
    onlyOwner&#13;
    onlyValidManagerAddress(_manager)&#13;
    onlyValidPermissionName(_permissionName)&#13;
  {&#13;
    require(managerPermissions[_manager][_permissionName] == false);&#13;
&#13;
    managerPermissions[_manager][_permissionName] = true;&#13;
&#13;
    emit ManagerPermissionGrantedEvent(_manager, keccak256(_permissionName));&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Function to revoke permission of the manager&#13;
   * @param _manager        address Existing manager&#13;
   * @param _permissionName string  Revoked permission name&#13;
   */&#13;
  function revokeManagerPermission(&#13;
    address _manager, string _permissionName&#13;
  )&#13;
    external&#13;
    onlyOwner&#13;
    onlyValidManagerAddress(_manager)&#13;
    onlyValidPermissionName(_permissionName)&#13;
  {&#13;
    require(managerPermissions[_manager][_permissionName] == true);&#13;
&#13;
    managerPermissions[_manager][_permissionName] = false;&#13;
&#13;
    emit ManagerPermissionRevokedEvent(_manager, keccak256(_permissionName));&#13;
  }&#13;
&#13;
&#13;
  /* Getters */&#13;
&#13;
  /**&#13;
   * @dev Function to check manager status&#13;
   * @param _manager address Manager`s address&#13;
   * @return True if manager is enabled&#13;
   */&#13;
  function isManagerEnabled(&#13;
    address _manager&#13;
  )&#13;
    public&#13;
    constant&#13;
    onlyValidManagerAddress(_manager)&#13;
    returns (bool)&#13;
  {&#13;
    return managerEnabled[_manager];&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Function to check permissions of a manager&#13;
   * @param _manager        address Manager`s address&#13;
   * @param _permissionName string  Permission name&#13;
   * @return True if manager has been granted needed permission&#13;
   */&#13;
  function isPermissionGranted(&#13;
    address _manager, string _permissionName&#13;
  )&#13;
    public&#13;
    constant&#13;
    onlyValidManagerAddress(_manager)&#13;
    onlyValidPermissionName(_permissionName)&#13;
    returns (bool)&#13;
  {&#13;
    return managerPermissions[_manager][_permissionName];&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Function to check if the manager can perform the action or not&#13;
   * @param _manager        address Manager`s address&#13;
   * @param _permissionName string  Permission name&#13;
   * @return True if manager is enabled and has been granted needed permission&#13;
   */&#13;
  function isManagerAllowed(&#13;
    address _manager, string _permissionName&#13;
  )&#13;
    public&#13;
    constant&#13;
    onlyValidManagerAddress(_manager)&#13;
    onlyValidPermissionName(_permissionName)&#13;
    returns (bool)&#13;
  {&#13;
    return (managerEnabled[_manager] &amp;&amp; managerPermissions[_manager][_permissionName]);&#13;
  }&#13;
&#13;
&#13;
  /* Helpers */&#13;
&#13;
  /**&#13;
   * @dev Modifier to check manager address&#13;
   */&#13;
  modifier onlyValidManagerAddress(address _manager) {&#13;
    require(_manager != address(0x0));&#13;
    _;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Modifier to check name of manager permission&#13;
   */&#13;
  modifier onlyValidPermissionName(string _permissionName) {&#13;
    require(bytes(_permissionName).length != 0);&#13;
    _;&#13;
  }&#13;
}&#13;
&#13;
&#13;
/**&#13;
 * @title PausableInterface&#13;
 * @dev Base contract which allows children to implement an emergency stop mechanism.&#13;
 * @dev Based on zeppelin's Pausable, but integrated with Manageable&#13;
 * @dev Contract is in paused state by default and should be explicitly unlocked&#13;
 */&#13;
contract PausableInterface {&#13;
&#13;
  /**&#13;
   * Events&#13;
   */&#13;
&#13;
  event PauseEvent();&#13;
  event UnpauseEvent();&#13;
&#13;
&#13;
  /**&#13;
   * @dev called by the manager to pause, triggers stopped state&#13;
   */&#13;
  function pauseContract() public;&#13;
&#13;
  /**&#13;
   * @dev called by the manager to unpause, returns to normal state&#13;
   */&#13;
  function unpauseContract() public;&#13;
&#13;
  /**&#13;
   * @dev The getter for "paused" contract variable&#13;
   */&#13;
  function getPaused() public constant returns (bool);&#13;
&#13;
&#13;
  /**&#13;
   * @dev modifier to allow actions only when the contract IS paused&#13;
   */&#13;
  modifier whenContractNotPaused() {&#13;
    require(getPaused() == false);&#13;
    _;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev modifier to allow actions only when the contract IS NOT paused&#13;
   */&#13;
  modifier whenContractPaused {&#13;
    require(getPaused() == true);&#13;
    _;&#13;
  }&#13;
}&#13;
&#13;
&#13;
/**&#13;
 * @title Pausable&#13;
 * @dev Base contract which allows children to implement an emergency stop mechanism.&#13;
 * @dev Based on zeppelin's Pausable, but integrated with Manageable&#13;
 * @dev Contract is in paused state by default and should be explicitly unlocked&#13;
 */&#13;
contract Pausable is ManageableInterface,&#13;
                     PausableInterface {&#13;
&#13;
  /**&#13;
   * Storage&#13;
   */&#13;
&#13;
  bool paused = true;&#13;
&#13;
&#13;
  /**&#13;
   * @dev called by the manager to pause, triggers stopped state&#13;
   */&#13;
  function pauseContract() public onlyAllowedManager('pause_contract') whenContractNotPaused {&#13;
    paused = true;&#13;
    emit PauseEvent();&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev called by the manager to unpause, returns to normal state&#13;
   */&#13;
  function unpauseContract() public onlyAllowedManager('unpause_contract') whenContractPaused {&#13;
    paused = false;&#13;
    emit UnpauseEvent();&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev The getter for "paused" contract variable&#13;
   */&#13;
  function getPaused() public constant returns (bool) {&#13;
    return paused;&#13;
  }&#13;
}&#13;
&#13;
&#13;
&#13;
/**&#13;
 * @title CrydrViewERC20Interface&#13;
 * @dev ERC20 interface to use in applications&#13;
 */&#13;
contract CrydrViewERC20Interface {&#13;
  event Transfer(address indexed from, address indexed to, uint256 value);&#13;
  event Approval(address indexed owner, address indexed spender, uint256 value);&#13;
&#13;
  function transfer(address _to, uint256 _value) external returns (bool);&#13;
  function totalSupply() external constant returns (uint256);&#13;
  function balanceOf(address _owner) external constant returns (uint256);&#13;
&#13;
  function approve(address _spender, uint256 _value) external returns (bool);&#13;
  function transferFrom(address _from, address _to, uint256 _value) external returns (bool);&#13;
  function allowance(address _owner, address _spender) external constant returns (uint256);&#13;
}&#13;
&#13;
&#13;
/**&#13;
 * @title CrydrViewERC20LoggableInterface&#13;
 * @dev Contract is able to create Transfer/Approval events with the cal from controller&#13;
 */&#13;
contract CrydrViewERC20LoggableInterface {&#13;
&#13;
  function emitTransferEvent(address _from, address _to, uint256 _value) external;&#13;
  function emitApprovalEvent(address _owner, address _spender, uint256 _value) external;&#13;
}&#13;
&#13;
&#13;
/**&#13;
 * @title CrydrStorageERC20Interface interface&#13;
 * @dev Interface of a contract that manages balance of an CryDR and have optimization for ERC20 controllers&#13;
 */&#13;
contract CrydrStorageERC20Interface {&#13;
&#13;
  /* Events */&#13;
&#13;
  event CrydrTransferredEvent(address indexed from, address indexed to, uint256 value);&#13;
  event CrydrTransferredFromEvent(address indexed spender, address indexed from, address indexed to, uint256 value);&#13;
  event CrydrSpendingApprovedEvent(address indexed owner, address indexed spender, uint256 value);&#13;
&#13;
&#13;
  /* ERC20 optimization. _msgsender - account that invoked CrydrView */&#13;
&#13;
  function transfer(address _msgsender, address _to, uint256 _value) public;&#13;
  function transferFrom(address _msgsender, address _from, address _to, uint256 _value) public;&#13;
  function approve(address _msgsender, address _spender, uint256 _value) public;&#13;
}&#13;
&#13;
&#13;
/**&#13;
 * @title CrydrControllerBaseInterface interface&#13;
 * @dev Interface of a contract that implement business-logic of an CryDR, mediates CryDR views and storage&#13;
 */&#13;
contract CrydrControllerBaseInterface {&#13;
&#13;
  /* Events */&#13;
&#13;
  event CrydrStorageChangedEvent(address indexed crydrstorage);&#13;
  event CrydrViewAddedEvent(address indexed crydrview, bytes32 standardname);&#13;
  event CrydrViewRemovedEvent(address indexed crydrview, bytes32 standardname);&#13;
&#13;
&#13;
  /* Configuration */&#13;
&#13;
  function setCrydrStorage(address _newStorage) external;&#13;
  function getCrydrStorageAddress() public constant returns (address);&#13;
&#13;
  function setCrydrView(address _newCrydrView, string _viewApiStandardName) external;&#13;
  function removeCrydrView(string _viewApiStandardName) external;&#13;
  function getCrydrViewAddress(string _viewApiStandardName) public constant returns (address);&#13;
&#13;
  function isCrydrViewAddress(address _crydrViewAddress) public constant returns (bool);&#13;
  function isCrydrViewRegistered(string _viewApiStandardName) public constant returns (bool);&#13;
&#13;
&#13;
  /* Helpers */&#13;
&#13;
  modifier onlyValidCrydrViewStandardName(string _viewApiStandard) {&#13;
    require(bytes(_viewApiStandard).length &gt; 0);&#13;
    _;&#13;
  }&#13;
&#13;
  modifier onlyCrydrView() {&#13;
    require(isCrydrViewAddress(msg.sender) == true);&#13;
    _;&#13;
  }&#13;
}&#13;
&#13;
&#13;
/**&#13;
 * @title JNTPaymentGatewayInterface&#13;
 * @dev Allows to charge users by JNT&#13;
 */&#13;
contract JNTPaymentGatewayInterface {&#13;
&#13;
  /* Events */&#13;
&#13;
  event JNTChargedEvent(address indexed payableservice, address indexed from, address indexed to, uint256 value);&#13;
&#13;
&#13;
  /* Actions */&#13;
&#13;
  function chargeJNT(address _from, address _to, uint256 _value) public;&#13;
}&#13;
&#13;
&#13;
/**&#13;
 * @title JNTPaymentGateway&#13;
 * @dev Allows to charge users by JNT&#13;
 */&#13;
contract JNTPaymentGateway is ManageableInterface,&#13;
                              CrydrControllerBaseInterface,&#13;
                              JNTPaymentGatewayInterface {&#13;
&#13;
  function chargeJNT(&#13;
    address _from,&#13;
    address _to,&#13;
    uint256 _value&#13;
  )&#13;
    public&#13;
    onlyAllowedManager('jnt_payable_service')&#13;
  {&#13;
    CrydrStorageERC20Interface(getCrydrStorageAddress()).transfer(_from, _to, _value);&#13;
&#13;
    emit JNTChargedEvent(msg.sender, _from, _to, _value);&#13;
    if (isCrydrViewRegistered('erc20') == true) {&#13;
      CrydrViewERC20LoggableInterface(getCrydrViewAddress('erc20')).emitTransferEvent(_from, _to, _value);&#13;
    }&#13;
  }&#13;
}&#13;
&#13;
&#13;
&#13;
/**&#13;
 * @title JNTPayableService interface&#13;
 * @dev Interface of a contract that charge JNT for actions&#13;
 */&#13;
contract JNTPayableServiceInterface {&#13;
&#13;
  /* Events */&#13;
&#13;
  event JNTControllerChangedEvent(address jntcontroller);&#13;
  event JNTBeneficiaryChangedEvent(address jntbeneficiary);&#13;
  event JNTChargedEvent(address indexed payer, address indexed to, uint256 value, bytes32 actionname);&#13;
&#13;
&#13;
  /* Configuration */&#13;
&#13;
  function setJntController(address _jntController) external;&#13;
  function getJntController() public constant returns (address);&#13;
&#13;
  function setJntBeneficiary(address _jntBeneficiary) external;&#13;
  function getJntBeneficiary() public constant returns (address);&#13;
&#13;
  function setActionPrice(string _actionName, uint256 _jntPriceWei) external;&#13;
  function getActionPrice(string _actionName) public constant returns (uint256);&#13;
&#13;
&#13;
  /* Actions */&#13;
&#13;
  function initChargeJNT(address _payer, string _actionName) internal;&#13;
}&#13;
&#13;
&#13;
contract JNTPayableService is CommonModifiersInterface,&#13;
                              ManageableInterface,&#13;
                              PausableInterface,&#13;
                              JNTPayableServiceInterface {&#13;
&#13;
  /* Storage */&#13;
&#13;
  JNTPaymentGateway jntController;&#13;
  address jntBeneficiary;&#13;
  mapping (string =&gt; uint256) actionPrice;&#13;
&#13;
&#13;
  /* Configuration */&#13;
&#13;
  function setJntController(&#13;
    address _jntController&#13;
  )&#13;
    external&#13;
    onlyContractAddress(_jntController)&#13;
    onlyAllowedManager('set_jnt_controller')&#13;
    whenContractPaused&#13;
  {&#13;
    require(_jntController != address(jntController));&#13;
&#13;
    jntController = JNTPaymentGateway(_jntController);&#13;
&#13;
    emit JNTControllerChangedEvent(_jntController);&#13;
  }&#13;
&#13;
  function getJntController() public constant returns (address) {&#13;
    return address(jntController);&#13;
  }&#13;
&#13;
&#13;
  function setJntBeneficiary(&#13;
    address _jntBeneficiary&#13;
  )&#13;
    external&#13;
    onlyValidJntBeneficiary(_jntBeneficiary)&#13;
    onlyAllowedManager('set_jnt_beneficiary')&#13;
    whenContractPaused&#13;
  {&#13;
    require(_jntBeneficiary != jntBeneficiary);&#13;
    require(_jntBeneficiary != address(this));&#13;
&#13;
    jntBeneficiary = _jntBeneficiary;&#13;
&#13;
    emit JNTBeneficiaryChangedEvent(jntBeneficiary);&#13;
  }&#13;
&#13;
  function getJntBeneficiary() public constant returns (address) {&#13;
    return jntBeneficiary;&#13;
  }&#13;
&#13;
&#13;
  function setActionPrice(&#13;
    string _actionName,&#13;
    uint256 _jntPriceWei&#13;
  )&#13;
    external&#13;
    onlyAllowedManager('set_action_price')&#13;
    onlyValidActionName(_actionName)&#13;
    whenContractPaused&#13;
  {&#13;
    require (_jntPriceWei &gt; 0);&#13;
&#13;
    actionPrice[_actionName] = _jntPriceWei;&#13;
  }&#13;
&#13;
  function getActionPrice(&#13;
    string _actionName&#13;
  )&#13;
    public&#13;
    constant&#13;
    onlyValidActionName(_actionName)&#13;
    returns (uint256)&#13;
  {&#13;
    return actionPrice[_actionName];&#13;
  }&#13;
&#13;
&#13;
  /* Actions */&#13;
&#13;
  function initChargeJNT(&#13;
    address _from,&#13;
    string _actionName&#13;
  )&#13;
    internal&#13;
    onlyValidActionName(_actionName)&#13;
    whenContractNotPaused&#13;
  {&#13;
    require(_from != address(0x0));&#13;
    require(_from != jntBeneficiary);&#13;
&#13;
    uint256 _actionPrice = getActionPrice(_actionName);&#13;
    require (_actionPrice &gt; 0);&#13;
&#13;
    jntController.chargeJNT(_from, jntBeneficiary, _actionPrice);&#13;
&#13;
    emit JNTChargedEvent(_from, jntBeneficiary, _actionPrice, keccak256(_actionName));&#13;
  }&#13;
&#13;
&#13;
  /* Pausable */&#13;
&#13;
  /**&#13;
   * @dev Override method to ensure that contract properly configured before it is unpaused&#13;
   */&#13;
  function unpauseContract()&#13;
    public&#13;
    onlyContractAddress(jntController)&#13;
    onlyValidJntBeneficiary(jntBeneficiary)&#13;
  {&#13;
    super.unpauseContract();&#13;
  }&#13;
&#13;
&#13;
  /* Modifiers */&#13;
&#13;
  modifier onlyValidJntBeneficiary(address _jntBeneficiary) {&#13;
    require(_jntBeneficiary != address(0x0));&#13;
    _;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Modifier to check name of manager permission&#13;
   */&#13;
  modifier onlyValidActionName(string _actionName) {&#13;
    require(bytes(_actionName).length != 0);&#13;
    _;&#13;
  }&#13;
}&#13;
&#13;
&#13;
/**&#13;
 * @title JcashRegistrarInterface&#13;
 * @dev Interface of a contract that can receives ETH&amp;ERC20, refunds ETH&amp;ERC20 and logs these operations&#13;
 */&#13;
contract JcashRegistrarInterface {&#13;
&#13;
  /* Events */&#13;
&#13;
  event ReceiveEthEvent(address indexed from, uint256 value);&#13;
  event RefundEthEvent(bytes32 txhash, address indexed to, uint256 value);&#13;
  event TransferEthEvent(bytes32 txhash, address indexed to, uint256 value);&#13;
&#13;
  event RefundTokenEvent(bytes32 txhash, address indexed tokenaddress, address indexed to, uint256 value);&#13;
  event TransferTokenEvent(bytes32 txhash, address indexed tokenaddress, address indexed to, uint256 value);&#13;
&#13;
  event ReplenishEthEvent(address indexed from, uint256 value);&#13;
  event WithdrawEthEvent(address indexed to, uint256 value);&#13;
  event WithdrawTokenEvent(address indexed tokenaddress, address indexed to, uint256 value);&#13;
&#13;
  event PauseEvent();&#13;
  event UnpauseEvent();&#13;
&#13;
&#13;
  /* Replenisher actions */&#13;
&#13;
  /**&#13;
   * @dev Allows to withdraw ETH by Replenisher.&#13;
   */&#13;
  function withdrawEth(uint256 _weivalue) external;&#13;
&#13;
  /**&#13;
   * @dev Allows to withdraw tokens by Replenisher.&#13;
   */&#13;
  function withdrawToken(address _tokenAddress, uint256 _weivalue) external;&#13;
&#13;
&#13;
  /* Processing of exchange operations */&#13;
&#13;
  /**&#13;
   * @dev Allows to perform refund ETH.&#13;
   */&#13;
  function refundEth(bytes32 _txHash, address _to, uint256 _weivalue) external;&#13;
&#13;
  /**&#13;
   * @dev Allows to perform refund ERC20 tokens.&#13;
   */&#13;
  function refundToken(bytes32 _txHash, address _tokenAddress, address _to, uint256 _weivalue) external;&#13;
&#13;
  /**&#13;
   * @dev Allows to perform transfer ETH.&#13;
   *&#13;
   */&#13;
  function transferEth(bytes32 _txHash, address _to, uint256 _weivalue) external;&#13;
&#13;
  /**&#13;
   * @dev Allows to perform transfer ERC20 tokens.&#13;
   */&#13;
  function transferToken(bytes32 _txHash, address _tokenAddress, address _to, uint256 _weivalue) external;&#13;
&#13;
&#13;
  /* Getters */&#13;
&#13;
  /**&#13;
   * @dev The getter returns true if tx hash is processed&#13;
   */&#13;
  function isProcessedTx(bytes32 _txHash) public view returns (bool);&#13;
}&#13;
&#13;
&#13;
/**&#13;
 * @title JcashRegistrar&#13;
 * @dev Implementation of a contract that can receives ETH&amp;ERC20, refunds ETH&amp;ERC20 and logs these operations&#13;
 */&#13;
contract JcashRegistrar is CommonModifiers,&#13;
                           Ownable,&#13;
                           Manageable,&#13;
                           Pausable,&#13;
                           JNTPayableService,&#13;
                           JcashRegistrarInterface {&#13;
&#13;
  /* Storage */&#13;
&#13;
  mapping (bytes32 =&gt; bool) processedTxs;&#13;
&#13;
&#13;
  /* Events */&#13;
&#13;
  event ReceiveEthEvent(address indexed from, uint256 value);&#13;
  event RefundEthEvent(bytes32 txhash, address indexed to, uint256 value);&#13;
  event TransferEthEvent(bytes32 txhash, address indexed to, uint256 value);&#13;
  event RefundTokenEvent(bytes32 txhash, address indexed tokenaddress, address indexed to, uint256 value);&#13;
  event TransferTokenEvent(bytes32 txhash, address indexed tokenaddress, address indexed to, uint256 value);&#13;
&#13;
  event ReplenishEthEvent(address indexed from, uint256 value);&#13;
  event WithdrawEthEvent(address indexed to, uint256 value);&#13;
  event WithdrawTokenEvent(address indexed tokenaddress, address indexed to, uint256 value);&#13;
&#13;
  event PauseEvent();&#13;
  event UnpauseEvent();&#13;
&#13;
&#13;
  /* Modifiers */&#13;
&#13;
  /**&#13;
   * @dev Fix for the ERC20 short address attack.&#13;
   */&#13;
  modifier onlyPayloadSize(uint256 size) {&#13;
    require(msg.data.length == (size + 4));&#13;
&#13;
    _;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Fallback function allowing the contract to receive funds, if contract haven't already been paused.&#13;
   */&#13;
  function () external payable {&#13;
    if (isManagerAllowed(msg.sender, 'replenish_eth')==true) {&#13;
      emit ReplenishEthEvent(msg.sender, msg.value);&#13;
    } else {&#13;
      require (getPaused() == false);&#13;
      emit ReceiveEthEvent(msg.sender, msg.value);&#13;
    }&#13;
  }&#13;
&#13;
&#13;
  /* Replenisher actions */&#13;
&#13;
  /**&#13;
   * @dev Allows to withdraw ETH by Replenisher.&#13;
   */&#13;
  function withdrawEth(&#13;
    uint256 _weivalue&#13;
  )&#13;
    external&#13;
    onlyAllowedManager('replenish_eth')&#13;
    onlyPayloadSize(1 * 32)&#13;
  {&#13;
    require (_weivalue &gt; 0);&#13;
&#13;
    address(msg.sender).transfer(_weivalue);&#13;
    emit WithdrawEthEvent(msg.sender, _weivalue);&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Allows to withdraw tokens by Replenisher.&#13;
   */&#13;
  function withdrawToken(&#13;
    address _tokenAddress,&#13;
    uint256 _weivalue&#13;
  )&#13;
    external&#13;
    onlyAllowedManager('replenish_token')&#13;
    onlyPayloadSize(2 * 32)&#13;
  {&#13;
    require (_tokenAddress != address(0x0));&#13;
    require (_tokenAddress != address(this));&#13;
    require (_weivalue &gt; 0);&#13;
&#13;
    CrydrViewERC20Interface(_tokenAddress).transfer(msg.sender, _weivalue);&#13;
    emit WithdrawTokenEvent(_tokenAddress, msg.sender, _weivalue);&#13;
  }&#13;
&#13;
&#13;
  /* Processing of exchange operations */&#13;
&#13;
  /**&#13;
   * @dev Allows to perform refund ETH.&#13;
   */&#13;
  function refundEth(&#13;
    bytes32 _txHash,&#13;
    address _to,&#13;
    uint256 _weivalue&#13;
  )&#13;
    external&#13;
    onlyAllowedManager('refund_eth')&#13;
    whenContractNotPaused&#13;
    onlyPayloadSize(3 * 32)&#13;
  {&#13;
    require (_txHash != bytes32(0));&#13;
    require (processedTxs[_txHash] == false);&#13;
    require (_to != address(0x0));&#13;
    require (_to != address(this));&#13;
    require (_weivalue &gt; 0);&#13;
&#13;
    processedTxs[_txHash] = true;&#13;
    _to.transfer(_weivalue);&#13;
&#13;
    emit RefundEthEvent(_txHash, _to, _weivalue);&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Allows to perform refund ERC20 tokens.&#13;
   */&#13;
  function refundToken(&#13;
    bytes32 _txHash,&#13;
    address _tokenAddress,&#13;
    address _to,&#13;
    uint256 _weivalue&#13;
  )&#13;
    external&#13;
    onlyAllowedManager('refund_token')&#13;
    whenContractNotPaused&#13;
    onlyPayloadSize(4 * 32)&#13;
  {&#13;
    require (_txHash != bytes32(0));&#13;
    require (processedTxs[_txHash] == false);&#13;
    require (_tokenAddress != address(0x0));&#13;
    require (_tokenAddress != address(this));&#13;
    require (_to != address(0x0));&#13;
    require (_to != address(this));&#13;
    require (_weivalue &gt; 0);&#13;
&#13;
    processedTxs[_txHash] = true;&#13;
    CrydrViewERC20Interface(_tokenAddress).transfer(_to, _weivalue);&#13;
&#13;
    emit RefundTokenEvent(_txHash, _tokenAddress, _to, _weivalue);&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Allows to perform transfer ETH.&#13;
   *&#13;
   */&#13;
  function transferEth(&#13;
    bytes32 _txHash,&#13;
    address _to,&#13;
    uint256 _weivalue&#13;
  )&#13;
    external&#13;
    onlyAllowedManager('transfer_eth')&#13;
    whenContractNotPaused&#13;
    onlyPayloadSize(3 * 32)&#13;
  {&#13;
    require (_txHash != bytes32(0));&#13;
    require (processedTxs[_txHash] == false);&#13;
    require (_to != address(0x0));&#13;
    require (_to != address(this));&#13;
    require (_weivalue &gt; 0);&#13;
&#13;
    processedTxs[_txHash] = true;&#13;
    _to.transfer(_weivalue);&#13;
&#13;
    if (getActionPrice('transfer_eth') &gt; 0) {&#13;
      initChargeJNT(_to, 'transfer_eth');&#13;
    }&#13;
&#13;
    emit TransferEthEvent(_txHash, _to, _weivalue);&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Allows to perform transfer ERC20 tokens.&#13;
   */&#13;
  function transferToken(&#13;
    bytes32 _txHash,&#13;
    address _tokenAddress,&#13;
    address _to,&#13;
    uint256 _weivalue&#13;
  )&#13;
    external&#13;
    onlyAllowedManager('transfer_token')&#13;
    whenContractNotPaused&#13;
    onlyPayloadSize(4 * 32)&#13;
  {&#13;
    require (_txHash != bytes32(0));&#13;
    require (processedTxs[_txHash] == false);&#13;
    require (_tokenAddress != address(0x0));&#13;
    require (_tokenAddress != address(this));&#13;
    require (_to != address(0x0));&#13;
    require (_to != address(this));&#13;
&#13;
    processedTxs[_txHash] = true;&#13;
    CrydrViewERC20Interface(_tokenAddress).transfer(_to, _weivalue);&#13;
&#13;
    if (getActionPrice('transfer_token') &gt; 0) {&#13;
      initChargeJNT(_to, 'transfer_token');&#13;
    }&#13;
&#13;
    emit TransferTokenEvent(_txHash, _tokenAddress, _to, _weivalue);&#13;
  }&#13;
&#13;
&#13;
  /* Getters */&#13;
&#13;
  /**&#13;
   * @dev The getter returns true if tx hash is processed&#13;
   */&#13;
  function isProcessedTx(&#13;
    bytes32 _txHash&#13;
  )&#13;
    public&#13;
    view&#13;
    onlyPayloadSize(1 * 32)&#13;
    returns (bool)&#13;
  {&#13;
    require (_txHash != bytes32(0));&#13;
    return processedTxs[_txHash];&#13;
  }&#13;
}