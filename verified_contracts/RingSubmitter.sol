/*

  Copyright 2017 Loopring Project Ltd (Loopring Foundation).

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*/
pragma solidity 0.5.0;


/// @title Utility Functions for bytes
/// @author Daniel Wang - <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="385c5956515d5478545757484a51565f16574a5f">[email protected]</a>&gt;&#13;
library BytesUtil {&#13;
    function bytesToBytes32(&#13;
        bytes memory b,&#13;
        uint offset&#13;
        )&#13;
        internal&#13;
        pure&#13;
        returns (bytes32)&#13;
    {&#13;
        return bytes32(bytesToUintX(b, offset, 32));&#13;
    }&#13;
&#13;
    function bytesToUint(&#13;
        bytes memory b,&#13;
        uint offset&#13;
        )&#13;
        internal&#13;
        pure&#13;
        returns (uint)&#13;
    {&#13;
        return bytesToUintX(b, offset, 32);&#13;
    }&#13;
&#13;
    function bytesToAddress(&#13;
        bytes memory b,&#13;
        uint offset&#13;
        )&#13;
        internal&#13;
        pure&#13;
        returns (address)&#13;
    {&#13;
        return address(bytesToUintX(b, offset, 20) &amp; 0x00FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);&#13;
    }&#13;
&#13;
    function bytesToUint16(&#13;
        bytes memory b,&#13;
        uint offset&#13;
        )&#13;
        internal&#13;
        pure&#13;
        returns (uint16)&#13;
    {&#13;
        return uint16(bytesToUintX(b, offset, 2) &amp; 0xFFFF);&#13;
    }&#13;
&#13;
    function bytesToUintX(&#13;
        bytes memory b,&#13;
        uint offset,&#13;
        uint numBytes&#13;
        )&#13;
        private&#13;
        pure&#13;
        returns (uint data)&#13;
    {&#13;
        require(b.length &gt;= offset + numBytes, "INVALID_SIZE");&#13;
        assembly {&#13;
            data := mload(add(add(b, numBytes), offset))&#13;
        }&#13;
    }&#13;
&#13;
    function subBytes(&#13;
        bytes memory b,&#13;
        uint offset&#13;
        )&#13;
        internal&#13;
        pure&#13;
        returns (bytes memory data)&#13;
    {&#13;
        require(b.length &gt;= offset + 32, "INVALID_SIZE");&#13;
        assembly {&#13;
            data := add(add(b, 32), offset)&#13;
        }&#13;
    }&#13;
}&#13;
/*&#13;
&#13;
  Copyright 2017 Loopring Project Ltd (Loopring Foundation).&#13;
&#13;
  Licensed under the Apache License, Version 2.0 (the "License");&#13;
  you may not use this file except in compliance with the License.&#13;
  You may obtain a copy of the License at&#13;
&#13;
  http://www.apache.org/licenses/LICENSE-2.0&#13;
&#13;
  Unless required by applicable law or agreed to in writing, software&#13;
  distributed under the License is distributed on an "AS IS" BASIS,&#13;
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#13;
  See the License for the specific language governing permissions and&#13;
  limitations under the License.&#13;
*/&#13;
&#13;
&#13;
&#13;
/// @title Utility Functions for uint&#13;
/// @author Daniel Wang - &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="1b7f7a75727e775b7774746b6972757c3574697c">[email protected]</a>&gt;&#13;
library MathUint {&#13;
&#13;
    function mul(&#13;
        uint a,&#13;
        uint b&#13;
        )&#13;
        internal&#13;
        pure&#13;
        returns (uint c)&#13;
    {&#13;
        c = a * b;&#13;
        require(a == 0 || c / a == b, "INVALID_VALUE");&#13;
    }&#13;
&#13;
    function sub(&#13;
        uint a,&#13;
        uint b&#13;
        )&#13;
        internal&#13;
        pure&#13;
        returns (uint)&#13;
    {&#13;
        require(b &lt;= a, "INVALID_VALUE");&#13;
        return a - b;&#13;
    }&#13;
&#13;
    function add(&#13;
        uint a,&#13;
        uint b&#13;
        )&#13;
        internal&#13;
        pure&#13;
        returns (uint c)&#13;
    {&#13;
        c = a + b;&#13;
        require(c &gt;= a, "INVALID_VALUE");&#13;
    }&#13;
&#13;
    function hasRoundingError(&#13;
        uint value,&#13;
        uint numerator,&#13;
        uint denominator&#13;
        )&#13;
        internal&#13;
        pure&#13;
        returns (bool)&#13;
    {&#13;
        uint multiplied = mul(value, numerator);&#13;
        uint remainder = multiplied % denominator;&#13;
        // Return true if the rounding error is larger than 1%&#13;
        return mul(remainder, 100) &gt; multiplied;&#13;
    }&#13;
}&#13;
/*&#13;
&#13;
  Copyright 2017 Loopring Project Ltd (Loopring Foundation).&#13;
&#13;
  Licensed under the Apache License, Version 2.0 (the "License");&#13;
  you may not use this file except in compliance with the License.&#13;
  You may obtain a copy of the License at&#13;
&#13;
  http://www.apache.org/licenses/LICENSE-2.0&#13;
&#13;
  Unless required by applicable law or agreed to in writing, software&#13;
  distributed under the License is distributed on an "AS IS" BASIS,&#13;
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#13;
  See the License for the specific language governing permissions and&#13;
  limitations under the License.&#13;
*/&#13;
&#13;
&#13;
&#13;
/// @title ITradeHistory&#13;
/// @dev Stores the trade history and cancelled data of orders&#13;
/// @author Brecht Devos - &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="e4869681878c90a4888b8b94968d8a83ca8b9683">[email protected]</a>&gt;.&#13;
contract ITradeHistory {&#13;
&#13;
    // The following map is used to keep trace of order fill and cancellation&#13;
    // history.&#13;
    mapping (bytes32 =&gt; uint) public filled;&#13;
&#13;
    // This map is used to keep trace of order's cancellation history.&#13;
    mapping (address =&gt; mapping (bytes32 =&gt; bool)) public cancelled;&#13;
&#13;
    // A map from a broker to its cutoff timestamp.&#13;
    mapping (address =&gt; uint) public cutoffs;&#13;
&#13;
    // A map from a broker to its trading-pair cutoff timestamp.&#13;
    mapping (address =&gt; mapping (bytes20 =&gt; uint)) public tradingPairCutoffs;&#13;
&#13;
    // A map from a broker to an order owner to its cutoff timestamp.&#13;
    mapping (address =&gt; mapping (address =&gt; uint)) public cutoffsOwner;&#13;
&#13;
    // A map from a broker to an order owner to its trading-pair cutoff timestamp.&#13;
    mapping (address =&gt; mapping (address =&gt; mapping (bytes20 =&gt; uint))) public tradingPairCutoffsOwner;&#13;
&#13;
&#13;
    function batchUpdateFilled(&#13;
        bytes32[] calldata filledInfo&#13;
        )&#13;
        external;&#13;
&#13;
    function setCancelled(&#13;
        address broker,&#13;
        bytes32 orderHash&#13;
        )&#13;
        external;&#13;
&#13;
    function setCutoffs(&#13;
        address broker,&#13;
        uint cutoff&#13;
        )&#13;
        external;&#13;
&#13;
    function setTradingPairCutoffs(&#13;
        address broker,&#13;
        bytes20 tokenPair,&#13;
        uint cutoff&#13;
        )&#13;
        external;&#13;
&#13;
    function setCutoffsOfOwner(&#13;
        address broker,&#13;
        address owner,&#13;
        uint cutoff&#13;
        )&#13;
        external;&#13;
&#13;
    function setTradingPairCutoffsOfOwner(&#13;
        address broker,&#13;
        address owner,&#13;
        bytes20 tokenPair,&#13;
        uint cutoff&#13;
        )&#13;
        external;&#13;
&#13;
    function batchGetFilledAndCheckCancelled(&#13;
        bytes32[] calldata orderInfo&#13;
        )&#13;
        external&#13;
        view&#13;
        returns (uint[] memory fills);&#13;
&#13;
&#13;
    /// @dev Add a Loopring protocol address.&#13;
    /// @param addr A loopring protocol address.&#13;
    function authorizeAddress(&#13;
        address addr&#13;
        )&#13;
        external;&#13;
&#13;
    /// @dev Remove a Loopring protocol address.&#13;
    /// @param addr A loopring protocol address.&#13;
    function deauthorizeAddress(&#13;
        address addr&#13;
        )&#13;
        external;&#13;
&#13;
    function isAddressAuthorized(&#13;
        address addr&#13;
        )&#13;
        public&#13;
        view&#13;
        returns (bool);&#13;
&#13;
&#13;
    function suspend()&#13;
        external;&#13;
&#13;
    function resume()&#13;
        external;&#13;
&#13;
    function kill()&#13;
        external;&#13;
}&#13;
/*&#13;
&#13;
  Copyright 2017 Loopring Project Ltd (Loopring Foundation).&#13;
&#13;
  Licensed under the Apache License, Version 2.0 (the "License");&#13;
  you may not use this file except in compliance with the License.&#13;
  You may obtain a copy of the License at&#13;
&#13;
  http://www.apache.org/licenses/LICENSE-2.0&#13;
&#13;
  Unless required by applicable law or agreed to in writing, software&#13;
  distributed under the License is distributed on an "AS IS" BASIS,&#13;
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#13;
  See the License for the specific language governing permissions and&#13;
  limitations under the License.&#13;
*/&#13;
&#13;
&#13;
&#13;
/// @title ITradeDelegate&#13;
/// @dev Acts as a middle man to transfer ERC20 tokens on behalf of different&#13;
/// versions of Loopring protocol to avoid ERC20 re-authorization.&#13;
/// @author Daniel Wang - &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="b8dcd9d6d1ddd4f8d4d7d7c8cad1d6df96d7cadf">[email protected]</a>&gt;.&#13;
contract ITradeDelegate {&#13;
&#13;
    function batchTransfer(&#13;
        bytes32[] calldata batch&#13;
        )&#13;
        external;&#13;
&#13;
&#13;
    /// @dev Add a Loopring protocol address.&#13;
    /// @param addr A loopring protocol address.&#13;
    function authorizeAddress(&#13;
        address addr&#13;
        )&#13;
        external;&#13;
&#13;
    /// @dev Remove a Loopring protocol address.&#13;
    /// @param addr A loopring protocol address.&#13;
    function deauthorizeAddress(&#13;
        address addr&#13;
        )&#13;
        external;&#13;
&#13;
    function isAddressAuthorized(&#13;
        address addr&#13;
        )&#13;
        public&#13;
        view&#13;
        returns (bool);&#13;
&#13;
&#13;
    function suspend()&#13;
        external;&#13;
&#13;
    function resume()&#13;
        external;&#13;
&#13;
    function kill()&#13;
        external;&#13;
}&#13;
/*&#13;
&#13;
  Copyright 2017 Loopring Project Ltd (Loopring Foundation).&#13;
&#13;
  Licensed under the Apache License, Version 2.0 (the "License");&#13;
  you may not use this file except in compliance with the License.&#13;
  You may obtain a copy of the License at&#13;
&#13;
  http://www.apache.org/licenses/LICENSE-2.0&#13;
&#13;
  Unless required by applicable law or agreed to in writing, software&#13;
  distributed under the License is distributed on an "AS IS" BASIS,&#13;
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#13;
  See the License for the specific language governing permissions and&#13;
  limitations under the License.&#13;
*/&#13;
&#13;
&#13;
&#13;
/// @title IOrderRegistry&#13;
/// @author Daniel Wang - &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="c6a2a7a8afa3aa86aaa9a9b6b4afa8a1e8a9b4a1">[email protected]</a>&gt;.&#13;
contract IOrderRegistry {&#13;
&#13;
    /// @dev   Returns wether the order hash was registered in the registry.&#13;
    /// @param broker The broker of the order&#13;
    /// @param orderHash The hash of the order&#13;
    /// @return True if the order hash was registered, else false.&#13;
    function isOrderHashRegistered(&#13;
        address broker,&#13;
        bytes32 orderHash&#13;
        )&#13;
        external&#13;
        view&#13;
        returns (bool);&#13;
&#13;
    /// @dev   Registers an order in the registry.&#13;
    ///        msg.sender needs to be the broker of the order.&#13;
    /// @param orderHash The hash of the order&#13;
    function registerOrderHash(&#13;
        bytes32 orderHash&#13;
        )&#13;
        external;&#13;
}&#13;
/*&#13;
&#13;
  Copyright 2017 Loopring Project Ltd (Loopring Foundation).&#13;
&#13;
  Licensed under the Apache License, Version 2.0 (the "License");&#13;
  you may not use this file except in compliance with the License.&#13;
  You may obtain a copy of the License at&#13;
&#13;
  http://www.apache.org/licenses/LICENSE-2.0&#13;
&#13;
  Unless required by applicable law or agreed to in writing, software&#13;
  distributed under the License is distributed on an "AS IS" BASIS,&#13;
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#13;
  See the License for the specific language governing permissions and&#13;
  limitations under the License.&#13;
*/&#13;
&#13;
&#13;
&#13;
/// @title IOrderBook&#13;
/// @author Daniel Wang - &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="f69297989f939ab69a999986849f9891d8998491">[email protected]</a>&gt;.&#13;
/// @author Kongliang Zhong - &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="472c2829202b2e262920072b282837352e292069283520">[email protected]</a>&gt;.&#13;
contract IOrderBook {&#13;
    // The map of registered order hashes&#13;
    mapping(bytes32 =&gt; bool) public orderSubmitted;&#13;
&#13;
    /// @dev  Event emitted when an order was successfully submitted&#13;
    ///        orderHash      The hash of the order&#13;
    ///        orderData      The data of the order as passed to submitOrder()&#13;
    event OrderSubmitted(&#13;
        bytes32 orderHash,&#13;
        bytes   orderData&#13;
    );&#13;
&#13;
    /// @dev   Submits an order to the on-chain order book.&#13;
    ///        No signature is needed. The order can only be sumbitted by its&#13;
    ///        owner or its broker (the owner can be the address of a contract).&#13;
    /// @param orderData The data of the order. Contains all fields that are used&#13;
    ///        for the order hash calculation.&#13;
    ///        See OrderHelper.updateHash() for detailed information.&#13;
    function submitOrder(&#13;
        bytes calldata orderData&#13;
        )&#13;
        external&#13;
        returns (bytes32);&#13;
}&#13;
/*&#13;
&#13;
  Copyright 2017 Loopring Project Ltd (Loopring Foundation).&#13;
&#13;
  Licensed under the Apache License, Version 2.0 (the "License");&#13;
  you may not use this file except in compliance with the License.&#13;
  You may obtain a copy of the License at&#13;
&#13;
  http://www.apache.org/licenses/LICENSE-2.0&#13;
&#13;
  Unless required by applicable law or agreed to in writing, software&#13;
  distributed under the License is distributed on an "AS IS" BASIS,&#13;
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#13;
  See the License for the specific language governing permissions and&#13;
  limitations under the License.&#13;
*/&#13;
&#13;
&#13;
&#13;
/// @author Kongliang Zhong - &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="7b1014151c17121a151c3b1714140b0912151c5514091c">[email protected]</a>&gt;&#13;
/// @title IFeeHolder - A contract holding fees.&#13;
contract IFeeHolder {&#13;
&#13;
    event TokenWithdrawn(&#13;
        address owner,&#13;
        address token,&#13;
        uint value&#13;
    );&#13;
&#13;
    // A map of all fee balances&#13;
    mapping(address =&gt; mapping(address =&gt; uint)) public feeBalances;&#13;
&#13;
    /// @dev   Allows withdrawing the tokens to be burned by&#13;
    ///        authorized contracts.&#13;
    /// @param token The token to be used to burn buy and burn LRC&#13;
    /// @param value The amount of tokens to withdraw&#13;
    function withdrawBurned(&#13;
        address token,&#13;
        uint value&#13;
        )&#13;
        external&#13;
        returns (bool success);&#13;
&#13;
    /// @dev   Allows withdrawing the fee payments funds&#13;
    ///        msg.sender is the recipient of the fee and the address&#13;
    ///        to which the tokens will be sent.&#13;
    /// @param token The token to withdraw&#13;
    /// @param value The amount of tokens to withdraw&#13;
    function withdrawToken(&#13;
        address token,&#13;
        uint value&#13;
        )&#13;
        external&#13;
        returns (bool success);&#13;
&#13;
    function batchAddFeeBalances(&#13;
        bytes32[] calldata batch&#13;
        )&#13;
        external;&#13;
}&#13;
/*&#13;
&#13;
  Copyright 2017 Loopring Project Ltd (Loopring Foundation).&#13;
&#13;
  Licensed under the Apache License, Version 2.0 (the "License");&#13;
  you may not use this file except in compliance with the License.&#13;
  You may obtain a copy of the License at&#13;
&#13;
  http://www.apache.org/licenses/LICENSE-2.0&#13;
&#13;
  Unless required by applicable law or agreed to in writing, software&#13;
  distributed under the License is distributed on an "AS IS" BASIS,&#13;
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#13;
  See the License for the specific language governing permissions and&#13;
  limitations under the License.&#13;
*/&#13;
&#13;
&#13;
&#13;
/// @author Brecht Devos - &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="d4b6a6b1b7bca094b8bbbba4a6bdbab3fabba6b3">[email protected]</a>&gt;&#13;
/// @title IBurnRateTable - A contract for managing burn rates for tokens&#13;
contract IBurnRateTable {&#13;
&#13;
    struct TokenData {&#13;
        uint    tier;&#13;
        uint    validUntil;&#13;
    }&#13;
&#13;
    mapping(address =&gt; TokenData) public tokens;&#13;
&#13;
    uint public constant YEAR_TO_SECONDS = 31556952;&#13;
&#13;
    // Tiers&#13;
    uint8 public constant TIER_4 = 0;&#13;
    uint8 public constant TIER_3 = 1;&#13;
    uint8 public constant TIER_2 = 2;&#13;
    uint8 public constant TIER_1 = 3;&#13;
&#13;
    uint16 public constant BURN_BASE_PERCENTAGE           =                 100 * 10; // 100%&#13;
&#13;
    // Cost of upgrading the tier level of a token in a percentage of the total LRC supply&#13;
    uint16 public constant TIER_UPGRADE_COST_PERCENTAGE   =                        1; // 0.1%&#13;
&#13;
    // Burn rates&#13;
    // Matching&#13;
    uint16 public constant BURN_MATCHING_TIER1            =                       25; // 2.5%&#13;
    uint16 public constant BURN_MATCHING_TIER2            =                  15 * 10; //  15%&#13;
    uint16 public constant BURN_MATCHING_TIER3            =                  30 * 10; //  30%&#13;
    uint16 public constant BURN_MATCHING_TIER4            =                  50 * 10; //  50%&#13;
    // P2P&#13;
    uint16 public constant BURN_P2P_TIER1                 =                       25; // 2.5%&#13;
    uint16 public constant BURN_P2P_TIER2                 =                  15 * 10; //  15%&#13;
    uint16 public constant BURN_P2P_TIER3                 =                  30 * 10; //  30%&#13;
    uint16 public constant BURN_P2P_TIER4                 =                  50 * 10; //  50%&#13;
&#13;
    event TokenTierUpgraded(&#13;
        address indexed addr,&#13;
        uint            tier&#13;
    );&#13;
&#13;
    /// @dev   Returns the P2P and matching burn rate for the token.&#13;
    /// @param token The token to get the burn rate for.&#13;
    /// @return The burn rate. The P2P burn rate and matching burn rate&#13;
    ///         are packed together in the lowest 4 bytes.&#13;
    ///         (2 bytes P2P, 2 bytes matching)&#13;
    function getBurnRate(&#13;
        address token&#13;
        )&#13;
        external&#13;
        view&#13;
        returns (uint32 burnRate);&#13;
&#13;
    /// @dev   Returns the tier of a token.&#13;
    /// @param token The token to get the token tier for.&#13;
    /// @return The tier of the token&#13;
    function getTokenTier(&#13;
        address token&#13;
        )&#13;
        public&#13;
        view&#13;
        returns (uint);&#13;
&#13;
    /// @dev   Upgrades the tier of a token. Before calling this function,&#13;
    ///        msg.sender needs to approve this contract for the neccessary funds.&#13;
    /// @param token The token to upgrade the tier for.&#13;
    /// @return True if successful, false otherwise.&#13;
    function upgradeTokenTier(&#13;
        address token&#13;
        )&#13;
        external&#13;
        returns (bool);&#13;
&#13;
}&#13;
/*&#13;
&#13;
  Copyright 2017 Loopring Project Ltd (Loopring Foundation).&#13;
&#13;
  Licensed under the Apache License, Version 2.0 (the "License");&#13;
  you may not use this file except in compliance with the License.&#13;
  You may obtain a copy of the License at&#13;
&#13;
  http://www.apache.org/licenses/LICENSE-2.0&#13;
&#13;
  Unless required by applicable law or agreed to in writing, software&#13;
  distributed under the License is distributed on an "AS IS" BASIS,&#13;
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#13;
  See the License for the specific language governing permissions and&#13;
  limitations under the License.&#13;
*/&#13;
&#13;
&#13;
&#13;
/// @title IBrokerRegistry&#13;
/// @dev A broker is an account that can submit orders on behalf of other&#13;
///      accounts. When registering a broker, the owner can also specify a&#13;
///      pre-deployed BrokerInterceptor to hook into the exchange smart contracts.&#13;
/// @author Daniel Wang - &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="dcb8bdb2b5b9b09cb0b3b3acaeb5b2bbf2b3aebb">[email protected]</a>&gt;.&#13;
contract IBrokerRegistry {&#13;
    event BrokerRegistered(&#13;
        address owner,&#13;
        address broker,&#13;
        address interceptor&#13;
    );&#13;
&#13;
    event BrokerUnregistered(&#13;
        address owner,&#13;
        address broker,&#13;
        address interceptor&#13;
    );&#13;
&#13;
    event AllBrokersUnregistered(&#13;
        address owner&#13;
    );&#13;
&#13;
    /// @dev   Validates if the broker was registered for the order owner and&#13;
    ///        returns the possible BrokerInterceptor to be used.&#13;
    /// @param owner The owner of the order&#13;
    /// @param broker The broker of the order&#13;
    /// @return True if the broker was registered for the owner&#13;
    ///         and the BrokerInterceptor to use.&#13;
    function getBroker(&#13;
        address owner,&#13;
        address broker&#13;
        )&#13;
        external&#13;
        view&#13;
        returns(&#13;
            bool registered,&#13;
            address interceptor&#13;
        );&#13;
&#13;
    /// @dev   Gets all registered brokers for an owner.&#13;
    /// @param owner The owner&#13;
    /// @param start The start index of the list of brokers&#13;
    /// @param count The number of brokers to return&#13;
    /// @return The list of requested brokers and corresponding BrokerInterceptors&#13;
    function getBrokers(&#13;
        address owner,&#13;
        uint    start,&#13;
        uint    count&#13;
        )&#13;
        external&#13;
        view&#13;
        returns (&#13;
            address[] memory brokers,&#13;
            address[] memory interceptors&#13;
        );&#13;
&#13;
    /// @dev   Registers a broker for msg.sender and an optional&#13;
    ///        corresponding BrokerInterceptor.&#13;
    /// @param broker The broker to register&#13;
    /// @param interceptor The optional BrokerInterceptor to use (0x0 allowed)&#13;
    function registerBroker(&#13;
        address broker,&#13;
        address interceptor&#13;
        )&#13;
        external;&#13;
&#13;
    /// @dev   Unregisters a broker for msg.sender&#13;
    /// @param broker The broker to unregister&#13;
    function unregisterBroker(&#13;
        address broker&#13;
        )&#13;
        external;&#13;
&#13;
    /// @dev   Unregisters all brokers for msg.sender&#13;
    function unregisterAllBrokers(&#13;
        )&#13;
        external;&#13;
}&#13;
/*&#13;
&#13;
  Copyright 2017 Loopring Project Ltd (Loopring Foundation).&#13;
&#13;
  Licensed under the Apache License, Version 2.0 (the "License");&#13;
  you may not use this file except in compliance with the License.&#13;
  You may obtain a copy of the License at&#13;
&#13;
  http://www.apache.org/licenses/LICENSE-2.0&#13;
&#13;
  Unless required by applicable law or agreed to in writing, software&#13;
  distributed under the License is distributed on an "AS IS" BASIS,&#13;
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#13;
  See the License for the specific language governing permissions and&#13;
  limitations under the License.&#13;
*/&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
/// @title Utility Functions for Multihash signature verificaiton&#13;
/// @author Daniel Wang - &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="4226232c2b272e022e2d2d32302b2c256c2d3025">[email protected]</a>&gt;&#13;
/// For more information:&#13;
///   - https://github.com/saurfang/ipfs-multihash-on-solidity&#13;
///   - https://github.com/multiformats/multihash&#13;
///   - https://github.com/multiformats/js-multihash&#13;
library MultihashUtil {&#13;
&#13;
    enum HashAlgorithm { Ethereum, EIP712 }&#13;
&#13;
    string public constant SIG_PREFIX = "\x19Ethereum Signed Message:\n32";&#13;
&#13;
    function verifySignature(&#13;
        address signer,&#13;
        bytes32 plaintext,&#13;
        bytes memory multihash&#13;
        )&#13;
        internal&#13;
        pure&#13;
        returns (bool)&#13;
    {&#13;
        uint length = multihash.length;&#13;
        require(length &gt;= 2, "invalid multihash format");&#13;
        uint8 algorithm;&#13;
        uint8 size;&#13;
        assembly {&#13;
            algorithm := mload(add(multihash, 1))&#13;
            size := mload(add(multihash, 2))&#13;
        }&#13;
        require(length == (2 + size), "bad multihash size");&#13;
&#13;
        if (algorithm == uint8(HashAlgorithm.Ethereum)) {&#13;
            require(signer != address(0x0), "invalid signer address");&#13;
            require(size == 65, "bad Ethereum multihash size");&#13;
            bytes32 hash;&#13;
            uint8 v;&#13;
            bytes32 r;&#13;
            bytes32 s;&#13;
            assembly {&#13;
                let data := mload(0x40)&#13;
                mstore(data, 0x19457468657265756d205369676e6564204d6573736167653a0a333200000000) // SIG_PREFIX&#13;
                mstore(add(data, 28), plaintext)                                                 // plaintext&#13;
                hash := keccak256(data, 60)                                                      // 28 + 32&#13;
                // Extract v, r and s from the multihash data&#13;
                v := mload(add(multihash, 3))&#13;
                r := mload(add(multihash, 35))&#13;
                s := mload(add(multihash, 67))&#13;
            }&#13;
            return signer == ecrecover(&#13;
                hash,&#13;
                v,&#13;
                r,&#13;
                s&#13;
            );&#13;
        } else if (algorithm == uint8(HashAlgorithm.EIP712)) {&#13;
            require(signer != address(0x0), "invalid signer address");&#13;
            require(size == 65, "bad EIP712 multihash size");&#13;
            uint8 v;&#13;
            bytes32 r;&#13;
            bytes32 s;&#13;
            assembly {&#13;
                // Extract v, r and s from the multihash data&#13;
                v := mload(add(multihash, 3))&#13;
                r := mload(add(multihash, 35))&#13;
                s := mload(add(multihash, 67))&#13;
            }&#13;
            return signer == ecrecover(&#13;
                plaintext,&#13;
                v,&#13;
                r,&#13;
                s&#13;
            );&#13;
        } else {&#13;
            return false;&#13;
        }&#13;
    }&#13;
}&#13;
&#13;
/*&#13;
&#13;
  Copyright 2017 Loopring Project Ltd (Loopring Foundation).&#13;
&#13;
  Licensed under the Apache License, Version 2.0 (the "License");&#13;
  you may not use this file except in compliance with the License.&#13;
  You may obtain a copy of the License at&#13;
&#13;
  http://www.apache.org/licenses/LICENSE-2.0&#13;
&#13;
  Unless required by applicable law or agreed to in writing, software&#13;
  distributed under the License is distributed on an "AS IS" BASIS,&#13;
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#13;
  See the License for the specific language governing permissions and&#13;
  limitations under the License.&#13;
*/&#13;
&#13;
&#13;
&#13;
/// @title ERC20 Token Interface&#13;
/// @dev see https://github.com/ethereum/EIPs/issues/20&#13;
/// @author Daniel Wang - &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="7317121d1a161f331f1c1c03011a1d145d1c0114">[email protected]</a>&gt;&#13;
contract ERC20 {&#13;
    function totalSupply()&#13;
        public&#13;
        view&#13;
        returns (uint256);&#13;
&#13;
    function balanceOf(&#13;
        address who&#13;
        )&#13;
        public&#13;
        view&#13;
        returns (uint256);&#13;
&#13;
    function allowance(&#13;
        address owner,&#13;
        address spender&#13;
        )&#13;
        public&#13;
        view&#13;
        returns (uint256);&#13;
&#13;
    function transfer(&#13;
        address to,&#13;
        uint256 value&#13;
        )&#13;
        public&#13;
        returns (bool);&#13;
&#13;
    function transferFrom(&#13;
        address from,&#13;
        address to,&#13;
        uint256 value&#13;
        )&#13;
        public&#13;
        returns (bool);&#13;
&#13;
    function approve(&#13;
        address spender,&#13;
        uint256 value&#13;
        )&#13;
        public&#13;
        returns (bool);&#13;
}&#13;
/*&#13;
&#13;
  Copyright 2017 Loopring Project Ltd (Loopring Foundation).&#13;
&#13;
  Licensed under the Apache License, Version 2.0 (the "License");&#13;
  you may not use this file except in compliance with the License.&#13;
  You may obtain a copy of the License at&#13;
&#13;
  http://www.apache.org/licenses/LICENSE-2.0&#13;
&#13;
  Unless required by applicable law or agreed to in writing, software&#13;
  distributed under the License is distributed on an "AS IS" BASIS,&#13;
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#13;
  See the License for the specific language governing permissions and&#13;
  limitations under the License.&#13;
*/&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
library Data {&#13;
&#13;
    enum TokenType { ERC20 }&#13;
&#13;
    struct Header {&#13;
        uint version;&#13;
        uint numOrders;&#13;
        uint numRings;&#13;
        uint numSpendables;&#13;
    }&#13;
&#13;
    struct Context {&#13;
        address lrcTokenAddress;&#13;
        ITradeDelegate  delegate;&#13;
        ITradeHistory   tradeHistory;&#13;
        IBrokerRegistry orderBrokerRegistry;&#13;
        IOrderRegistry  orderRegistry;&#13;
        IFeeHolder feeHolder;&#13;
        IOrderBook orderBook;&#13;
        IBurnRateTable burnRateTable;&#13;
        uint64 ringIndex;&#13;
        uint feePercentageBase;&#13;
        bytes32[] tokenBurnRates;&#13;
        uint feeData;&#13;
        uint feePtr;&#13;
        uint transferData;&#13;
        uint transferPtr;&#13;
    }&#13;
&#13;
    struct Mining {&#13;
        // required fields&#13;
        address feeRecipient;&#13;
&#13;
        // optional fields&#13;
        address miner;&#13;
        bytes   sig;&#13;
&#13;
        // computed fields&#13;
        bytes32 hash;&#13;
        address interceptor;&#13;
    }&#13;
&#13;
    struct Spendable {&#13;
        bool initialized;&#13;
        uint amount;&#13;
        uint reserved;&#13;
    }&#13;
&#13;
    struct Order {&#13;
        uint      version;&#13;
&#13;
        // required fields&#13;
        address   owner;&#13;
        address   tokenS;&#13;
        address   tokenB;&#13;
        uint      amountS;&#13;
        uint      amountB;&#13;
        uint      validSince;&#13;
        Spendable tokenSpendableS;&#13;
        Spendable tokenSpendableFee;&#13;
&#13;
        // optional fields&#13;
        address   dualAuthAddr;&#13;
        address   broker;&#13;
        Spendable brokerSpendableS;&#13;
        Spendable brokerSpendableFee;&#13;
        address   orderInterceptor;&#13;
        address   wallet;&#13;
        uint      validUntil;&#13;
        bytes     sig;&#13;
        bytes     dualAuthSig;&#13;
        bool      allOrNone;&#13;
        address   feeToken;&#13;
        uint      feeAmount;&#13;
        int16     waiveFeePercentage;&#13;
        uint16    tokenSFeePercentage;    // Pre-trading&#13;
        uint16    tokenBFeePercentage;   // Post-trading&#13;
        address   tokenRecipient;&#13;
        uint16    walletSplitPercentage;&#13;
&#13;
        // computed fields&#13;
        bool    P2P;&#13;
        bytes32 hash;&#13;
        address brokerInterceptor;&#13;
        uint    filledAmountS;&#13;
        uint    initialFilledAmountS;&#13;
        bool    valid;&#13;
&#13;
        TokenType tokenTypeS;&#13;
        TokenType tokenTypeB;&#13;
        TokenType tokenTypeFee;&#13;
        bytes32 trancheS;&#13;
        bytes32 trancheB;&#13;
        bytes   transferDataS;&#13;
    }&#13;
&#13;
    struct Participation {&#13;
        // required fields&#13;
        Order order;&#13;
&#13;
        // computed fields&#13;
        uint splitS;&#13;
        uint feeAmount;&#13;
        uint feeAmountS;&#13;
        uint feeAmountB;&#13;
        uint rebateFee;&#13;
        uint rebateS;&#13;
        uint rebateB;&#13;
        uint fillAmountS;&#13;
        uint fillAmountB;&#13;
    }&#13;
&#13;
    struct Ring{&#13;
        uint size;&#13;
        Participation[] participations;&#13;
        bytes32 hash;&#13;
        uint minerFeesToOrdersPercentage;&#13;
        bool valid;&#13;
    }&#13;
&#13;
    struct FeeContext {&#13;
        Data.Ring ring;&#13;
        Data.Context ctx;&#13;
        address feeRecipient;&#13;
        uint walletPercentage;&#13;
        int16 waiveFeePercentage;&#13;
        address owner;&#13;
        address wallet;&#13;
        bool P2P;&#13;
    }&#13;
}&#13;
/*&#13;
&#13;
  Copyright 2017 Loopring Project Ltd (Loopring Foundation).&#13;
&#13;
  Licensed under the Apache License, Version 2.0 (the "License");&#13;
  you may not use this file except in compliance with the License.&#13;
  You may obtain a copy of the License at&#13;
&#13;
  http://www.apache.org/licenses/LICENSE-2.0&#13;
&#13;
  Unless required by applicable law or agreed to in writing, software&#13;
  distributed under the License is distributed on an "AS IS" BASIS,&#13;
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#13;
  See the License for the specific language governing permissions and&#13;
  limitations under the License.&#13;
*/&#13;
&#13;
&#13;
&#13;
/// @title IRingSubmitter&#13;
/// @author Daniel Wang - &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="2b4f4a45424e476b4744445b5942454c0544594c">[email protected]</a>&gt;&#13;
/// @author Kongliang Zhong - &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="177c7879707b7e767970577b787867657e797039786570">[email protected]</a>&gt;&#13;
contract IRingSubmitter {&#13;
    uint16  public constant FEE_PERCENTAGE_BASE = 1000;&#13;
&#13;
    /// @dev  Event emitted when a ring was successfully mined&#13;
    ///        _ringIndex     The index of the ring&#13;
    ///        _ringHash      The hash of the ring&#13;
    ///        _feeRecipient  The recipient of the matching fee&#13;
    ///        _fills         The info of the orders in the ring stored like:&#13;
    ///                       [orderHash, owner, tokenS, amountS, split, feeAmount, feeAmountS, feeAmountB]&#13;
    event RingMined(&#13;
        uint            _ringIndex,&#13;
        bytes32 indexed _ringHash,&#13;
        address indexed _feeRecipient,&#13;
        bytes           _fills&#13;
    );&#13;
&#13;
    /// @dev   Event emitted when a ring was not successfully mined&#13;
    ///         _ringHash  The hash of the ring&#13;
    event InvalidRing(&#13;
        bytes32 _ringHash&#13;
    );&#13;
&#13;
    /// @dev   Submit order-rings for validation and settlement.&#13;
    /// @param data Packed data of all rings.&#13;
    function submitRings(&#13;
        bytes calldata data&#13;
        )&#13;
        external;&#13;
}&#13;
/*&#13;
&#13;
  Copyright 2017 Loopring Project Ltd (Loopring Foundation).&#13;
&#13;
  Licensed under the Apache License, Version 2.0 (the "License");&#13;
  you may not use this file except in compliance with the License.&#13;
  You may obtain a copy of the License at&#13;
&#13;
  http://www.apache.org/licenses/LICENSE-2.0&#13;
&#13;
  Unless required by applicable law or agreed to in writing, software&#13;
  distributed under the License is distributed on an "AS IS" BASIS,&#13;
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#13;
  See the License for the specific language governing permissions and&#13;
  limitations under the License.&#13;
*/&#13;
&#13;
&#13;
/*&#13;
&#13;
  Copyright 2017 Loopring Project Ltd (Loopring Foundation).&#13;
&#13;
  Licensed under the Apache License, Version 2.0 (the "License");&#13;
  you may not use this file except in compliance with the License.&#13;
  You may obtain a copy of the License at&#13;
&#13;
  http://www.apache.org/licenses/LICENSE-2.0&#13;
&#13;
  Unless required by applicable law or agreed to in writing, software&#13;
  distributed under the License is distributed on an "AS IS" BASIS,&#13;
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#13;
  See the License for the specific language governing permissions and&#13;
  limitations under the License.&#13;
*/&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
/// @title MiningHelper&#13;
/// @author Daniel Wang - &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="2440454a4d414864484b4b54564d4a430a4b5643">[email protected]</a>&gt;.&#13;
library MiningHelper {&#13;
&#13;
    function updateMinerAndInterceptor(&#13;
        Data.Mining memory mining&#13;
        )&#13;
        internal&#13;
        pure&#13;
    {&#13;
&#13;
        if (mining.miner == address(0x0)) {&#13;
            mining.miner = mining.feeRecipient;&#13;
        }&#13;
&#13;
        // We do not support any interceptors for now&#13;
        /* else { */&#13;
        /*     (bool registered, address interceptor) = ctx.minerBrokerRegistry.getBroker( */&#13;
        /*         mining.feeRecipient, */&#13;
        /*         mining.miner */&#13;
        /*     ); */&#13;
        /*     if (registered) { */&#13;
        /*         mining.interceptor = interceptor; */&#13;
        /*     } */&#13;
        /* } */&#13;
    }&#13;
&#13;
    function updateHash(&#13;
        Data.Mining memory mining,&#13;
        Data.Ring[] memory rings&#13;
        )&#13;
        internal&#13;
        pure&#13;
    {&#13;
        bytes32 hash;&#13;
        assembly {&#13;
            let ring := mload(add(rings, 32))                               // rings[0]&#13;
            let ringHashes := mload(add(ring, 64))                          // ring.hash&#13;
            for { let i := 1 } lt(i, mload(rings)) { i := add(i, 1) } {&#13;
                ring := mload(add(rings, mul(add(i, 1), 32)))               // rings[i]&#13;
                ringHashes := xor(ringHashes, mload(add(ring, 64)))         // ring.hash&#13;
            }&#13;
            let data := mload(0x40)&#13;
            data := add(data, 12)&#13;
            // Store data back to front to allow overwriting data at the front because of padding&#13;
            mstore(add(data, 40), ringHashes)                               // ringHashes&#13;
            mstore(sub(add(data, 20), 12), mload(add(mining, 32)))          // mining.miner&#13;
            mstore(sub(data, 12),          mload(add(mining,  0)))          // mining.feeRecipient&#13;
            hash := keccak256(data, 72)                                     // 20 + 20 + 32&#13;
        }&#13;
        mining.hash = hash;&#13;
    }&#13;
&#13;
    function checkMinerSignature(&#13;
        Data.Mining memory mining&#13;
        )&#13;
        internal&#13;
        view&#13;
        returns (bool)&#13;
    {&#13;
        if (mining.sig.length == 0) {&#13;
            return (msg.sender == mining.miner);&#13;
        } else {&#13;
            return MultihashUtil.verifySignature(&#13;
                mining.miner,&#13;
                mining.hash,&#13;
                mining.sig&#13;
            );&#13;
        }&#13;
    }&#13;
&#13;
}&#13;
&#13;
/*&#13;
&#13;
  Copyright 2017 Loopring Project Ltd (Loopring Foundation).&#13;
&#13;
  Licensed under the Apache License, Version 2.0 (the "License");&#13;
  you may not use this file except in compliance with the License.&#13;
  You may obtain a copy of the License at&#13;
&#13;
  http://www.apache.org/licenses/LICENSE-2.0&#13;
&#13;
  Unless required by applicable law or agreed to in writing, software&#13;
  distributed under the License is distributed on an "AS IS" BASIS,&#13;
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#13;
  See the License for the specific language governing permissions and&#13;
  limitations under the License.&#13;
*/&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
/// @title OrderHelper&#13;
/// @author Daniel Wang - &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="d6b2b7b8bfb3ba96bab9b9a6a4bfb8b1f8b9a4b1">[email protected]</a>&gt;.&#13;
library OrderHelper {&#13;
    using MathUint      for uint;&#13;
&#13;
    string constant internal EIP191_HEADER = "\x19\x01";&#13;
    string constant internal EIP712_DOMAIN_NAME = "Loopring Protocol";&#13;
    string constant internal EIP712_DOMAIN_VERSION = "2";&#13;
    bytes32 constant internal EIP712_DOMAIN_SEPARATOR_SCHEMA_HASH = keccak256(&#13;
        abi.encodePacked(&#13;
            "EIP712Domain(",&#13;
            "string name,",&#13;
            "string version",&#13;
            ")"&#13;
        )&#13;
    );&#13;
    bytes32 constant internal EIP712_ORDER_SCHEMA_HASH = keccak256(&#13;
        abi.encodePacked(&#13;
            "Order(",&#13;
            "uint amountS,",&#13;
            "uint amountB,",&#13;
            "uint feeAmount,",&#13;
            "uint validSince,",&#13;
            "uint validUntil,",&#13;
            "address owner,",&#13;
            "address tokenS,",&#13;
            "address tokenB,",&#13;
            "address dualAuthAddr,",&#13;
            "address broker,",&#13;
            "address orderInterceptor,",&#13;
            "address wallet,",&#13;
            "address tokenRecipient,",&#13;
            "address feeToken,",&#13;
            "uint16 walletSplitPercentage,",&#13;
            "uint16 tokenSFeePercentage,",&#13;
            "uint16 tokenBFeePercentage,",&#13;
            "bool allOrNone,",&#13;
            "uint8 tokenTypeS,",&#13;
            "uint8 tokenTypeB,",&#13;
            "uint8 tokenTypeFee,",&#13;
            "bytes32 trancheS,",&#13;
            "bytes32 trancheB,",&#13;
            "bytes transferDataS",&#13;
            ")"&#13;
        )&#13;
    );&#13;
    bytes32 constant internal EIP712_DOMAIN_HASH = keccak256(&#13;
        abi.encodePacked(&#13;
            EIP712_DOMAIN_SEPARATOR_SCHEMA_HASH,&#13;
            keccak256(bytes(EIP712_DOMAIN_NAME)),&#13;
            keccak256(bytes(EIP712_DOMAIN_VERSION))&#13;
        )&#13;
    );&#13;
&#13;
    function updateHash(Data.Order memory order)&#13;
        internal&#13;
        pure&#13;
    {&#13;
        /* bytes32 message = keccak256( */&#13;
        /*     abi.encode( */&#13;
        /*         EIP712_ORDER_SCHEMA_HASH, */&#13;
        /*         order.amountS, */&#13;
        /*         order.amountB, */&#13;
        /*         order.feeAmount, */&#13;
        /*         order.validSince, */&#13;
        /*         order.validUntil, */&#13;
        /*         order.owner, */&#13;
        /*         order.tokenS, */&#13;
        /*         order.tokenB, */&#13;
        /*         order.dualAuthAddr, */&#13;
        /*         order.broker, */&#13;
        /*         order.orderInterceptor, */&#13;
        /*         order.wallet, */&#13;
        /*         order.tokenRecipient */&#13;
        /*         order.feeToken, */&#13;
        /*         order.walletSplitPercentage, */&#13;
        /*         order.tokenSFeePercentage, */&#13;
        /*         order.tokenBFeePercentage, */&#13;
        /*         order.allOrNone, */&#13;
        /*         order.tokenTypeS, */&#13;
        /*         order.tokenTypeB, */&#13;
        /*         order.tokenTypeFee, */&#13;
        /*         order.trancheS, */&#13;
        /*         order.trancheB, */&#13;
        /*         order.transferDataS */&#13;
        /*     ) */&#13;
        /* ); */&#13;
        /* order.hash = keccak256( */&#13;
        /*    abi.encodePacked( */&#13;
        /*        EIP191_HEADER, */&#13;
        /*        EIP712_DOMAIN_HASH, */&#13;
        /*        message */&#13;
        /*    ) */&#13;
        /*); */&#13;
&#13;
        // Precalculated EIP712_ORDER_SCHEMA_HASH amd EIP712_DOMAIN_HASH because&#13;
        // the solidity compiler doesn't correctly precalculate them for us.&#13;
        bytes32 _EIP712_ORDER_SCHEMA_HASH = 0x40b942178d2a51f1f61934268590778feb8114db632db7d88537c98d2b05c5f2;&#13;
        bytes32 _EIP712_DOMAIN_HASH = 0xaea25658c273c666156bd427f83a666135fcde6887a6c25fc1cd1562bc4f3f34;&#13;
&#13;
        bytes32 hash;&#13;
        assembly {&#13;
            // Calculate the hash for transferDataS separately&#13;
            let transferDataS := mload(add(order, 1184))              // order.transferDataS&#13;
            let transferDataSHash := keccak256(add(transferDataS, 32), mload(transferDataS))&#13;
&#13;
            let ptr := mload(64)&#13;
            mstore(add(ptr,   0), _EIP712_ORDER_SCHEMA_HASH)     // EIP712_ORDER_SCHEMA_HASH&#13;
            mstore(add(ptr,  32), mload(add(order, 128)))        // order.amountS&#13;
            mstore(add(ptr,  64), mload(add(order, 160)))        // order.amountB&#13;
            mstore(add(ptr,  96), mload(add(order, 640)))        // order.feeAmount&#13;
            mstore(add(ptr, 128), mload(add(order, 192)))        // order.validSince&#13;
            mstore(add(ptr, 160), mload(add(order, 480)))        // order.validUntil&#13;
            mstore(add(ptr, 192), mload(add(order,  32)))        // order.owner&#13;
            mstore(add(ptr, 224), mload(add(order,  64)))        // order.tokenS&#13;
            mstore(add(ptr, 256), mload(add(order,  96)))        // order.tokenB&#13;
            mstore(add(ptr, 288), mload(add(order, 288)))        // order.dualAuthAddr&#13;
            mstore(add(ptr, 320), mload(add(order, 320)))        // order.broker&#13;
            mstore(add(ptr, 352), mload(add(order, 416)))        // order.orderInterceptor&#13;
            mstore(add(ptr, 384), mload(add(order, 448)))        // order.wallet&#13;
            mstore(add(ptr, 416), mload(add(order, 768)))        // order.tokenRecipient&#13;
            mstore(add(ptr, 448), mload(add(order, 608)))        // order.feeToken&#13;
            mstore(add(ptr, 480), mload(add(order, 800)))        // order.walletSplitPercentage&#13;
            mstore(add(ptr, 512), mload(add(order, 704)))        // order.tokenSFeePercentage&#13;
            mstore(add(ptr, 544), mload(add(order, 736)))        // order.tokenBFeePercentage&#13;
            mstore(add(ptr, 576), mload(add(order, 576)))        // order.allOrNone&#13;
            mstore(add(ptr, 608), mload(add(order, 1024)))       // order.tokenTypeS&#13;
            mstore(add(ptr, 640), mload(add(order, 1056)))       // order.tokenTypeB&#13;
            mstore(add(ptr, 672), mload(add(order, 1088)))       // order.tokenTypeFee&#13;
            mstore(add(ptr, 704), mload(add(order, 1120)))       // order.trancheS&#13;
            mstore(add(ptr, 736), mload(add(order, 1152)))       // order.trancheB&#13;
            mstore(add(ptr, 768), transferDataSHash)             // keccak256(order.transferDataS)&#13;
            let message := keccak256(ptr, 800)                   // 25 * 32&#13;
&#13;
            mstore(add(ptr,  0), 0x1901)                         // EIP191_HEADER&#13;
            mstore(add(ptr, 32), _EIP712_DOMAIN_HASH)            // EIP712_DOMAIN_HASH&#13;
            mstore(add(ptr, 64), message)                        // message&#13;
            hash := keccak256(add(ptr, 30), 66)                  // 2 + 32 + 32&#13;
        }&#13;
        order.hash = hash;&#13;
    }&#13;
&#13;
    function updateBrokerAndInterceptor(&#13;
        Data.Order memory order,&#13;
        Data.Context memory ctx&#13;
        )&#13;
        internal&#13;
        view&#13;
    {&#13;
        if (order.broker == address(0x0)) {&#13;
            order.broker = order.owner;&#13;
        } else {&#13;
            bool registered;&#13;
            (registered, /*order.brokerInterceptor*/) = ctx.orderBrokerRegistry.getBroker(&#13;
                order.owner,&#13;
                order.broker&#13;
            );&#13;
            order.valid = order.valid &amp;&amp; registered;&#13;
        }&#13;
    }&#13;
&#13;
    function check(&#13;
        Data.Order memory order,&#13;
        Data.Context memory ctx&#13;
        )&#13;
        internal&#13;
        view&#13;
    {&#13;
        // If the order was already partially filled&#13;
        // we don't have to check all of the infos and the signature again&#13;
        if(order.filledAmountS == 0) {&#13;
            validateAllInfo(order, ctx);&#13;
            checkBrokerSignature(order, ctx);&#13;
        } else {&#13;
            validateUnstableInfo(order, ctx);&#13;
        }&#13;
&#13;
        checkP2P(order);&#13;
    }&#13;
&#13;
    function validateAllInfo(&#13;
        Data.Order memory order,&#13;
        Data.Context memory ctx&#13;
        )&#13;
        internal&#13;
        view&#13;
    {&#13;
        bool valid = true;&#13;
        valid = valid &amp;&amp; (order.version == 0); // unsupported order version&#13;
        valid = valid &amp;&amp; (order.owner != address(0x0)); // invalid order owner&#13;
        valid = valid &amp;&amp; (order.tokenS != address(0x0)); // invalid order tokenS&#13;
        valid = valid &amp;&amp; (order.tokenB != address(0x0)); // invalid order tokenB&#13;
        valid = valid &amp;&amp; (order.amountS != 0); // invalid order amountS&#13;
        valid = valid &amp;&amp; (order.amountB != 0); // invalid order amountB&#13;
        valid = valid &amp;&amp; (order.feeToken != address(0x0)); // invalid fee token&#13;
&#13;
        valid = valid &amp;&amp; (order.tokenSFeePercentage &lt; ctx.feePercentageBase); // invalid tokenS percentage&#13;
        valid = valid &amp;&amp; (order.tokenBFeePercentage &lt; ctx.feePercentageBase); // invalid tokenB percentage&#13;
        valid = valid &amp;&amp; (order.walletSplitPercentage &lt;= 100); // invalid wallet split percentage&#13;
&#13;
        // We only support ERC20 for now&#13;
        valid = valid &amp;&amp; (order.tokenTypeS == Data.TokenType.ERC20 &amp;&amp; order.trancheS == 0x0);&#13;
        valid = valid &amp;&amp; (order.tokenTypeB == Data.TokenType.ERC20 &amp;&amp; order.trancheB == 0x0);&#13;
        valid = valid &amp;&amp; (order.tokenTypeFee == Data.TokenType.ERC20);&#13;
        valid = valid &amp;&amp; (order.transferDataS.length == 0);&#13;
&#13;
        valid = valid &amp;&amp; (order.validSince &lt;= now); // order is too early to match&#13;
&#13;
        order.valid = order.valid &amp;&amp; valid;&#13;
&#13;
        validateUnstableInfo(order, ctx);&#13;
    }&#13;
&#13;
&#13;
    function validateUnstableInfo(&#13;
        Data.Order memory order,&#13;
        Data.Context memory ctx&#13;
        )&#13;
        internal&#13;
        view&#13;
    {&#13;
        bool valid = true;&#13;
        valid = valid &amp;&amp; (order.validUntil == 0 || order.validUntil &gt; now);  // order is expired&#13;
        valid = valid &amp;&amp; (order.waiveFeePercentage &lt;= int16(ctx.feePercentageBase)); // invalid waive percentage&#13;
        valid = valid &amp;&amp; (order.waiveFeePercentage &gt;= -int16(ctx.feePercentageBase)); // invalid waive percentage&#13;
        if (order.dualAuthAddr != address(0x0)) { // if dualAuthAddr exists, dualAuthSig must be exist.&#13;
            valid = valid &amp;&amp; (order.dualAuthSig.length &gt; 0);&#13;
        }&#13;
        order.valid = order.valid &amp;&amp; valid;&#13;
    }&#13;
&#13;
&#13;
    function checkP2P(&#13;
        Data.Order memory order&#13;
        )&#13;
        internal&#13;
        pure&#13;
    {&#13;
        order.P2P = (order.tokenSFeePercentage &gt; 0 || order.tokenBFeePercentage &gt; 0);&#13;
    }&#13;
&#13;
&#13;
    function checkBrokerSignature(&#13;
        Data.Order memory order,&#13;
        Data.Context memory ctx&#13;
        )&#13;
        internal&#13;
        view&#13;
    {&#13;
        if (order.sig.length == 0) {&#13;
            bool registered = ctx.orderRegistry.isOrderHashRegistered(&#13;
                order.broker,&#13;
                order.hash&#13;
            );&#13;
&#13;
            if (!registered) {&#13;
                order.valid = order.valid &amp;&amp; ctx.orderBook.orderSubmitted(order.hash);&#13;
            }&#13;
        } else {&#13;
            order.valid = order.valid &amp;&amp; MultihashUtil.verifySignature(&#13;
                order.broker,&#13;
                order.hash,&#13;
                order.sig&#13;
            );&#13;
        }&#13;
    }&#13;
&#13;
    function checkDualAuthSignature(&#13;
        Data.Order memory order,&#13;
        bytes32 miningHash&#13;
        )&#13;
        internal&#13;
        pure&#13;
    {&#13;
        if (order.dualAuthSig.length != 0) {&#13;
            order.valid = order.valid &amp;&amp; MultihashUtil.verifySignature(&#13;
                order.dualAuthAddr,&#13;
                miningHash,&#13;
                order.dualAuthSig&#13;
            );&#13;
        }&#13;
    }&#13;
&#13;
    function validateAllOrNone(&#13;
        Data.Order memory order&#13;
        )&#13;
        internal&#13;
        pure&#13;
    {&#13;
        // Check if this order needs to be completely filled&#13;
        if(order.allOrNone) {&#13;
            order.valid = order.valid &amp;&amp; (order.filledAmountS == order.amountS);&#13;
        }&#13;
    }&#13;
&#13;
    function getSpendableS(&#13;
        Data.Order memory order,&#13;
        Data.Context memory ctx&#13;
        )&#13;
        internal&#13;
        view&#13;
        returns (uint)&#13;
    {&#13;
        return getSpendable(&#13;
            ctx.delegate,&#13;
            order.tokenS,&#13;
            order.owner,&#13;
            order.tokenSpendableS&#13;
        );&#13;
    }&#13;
&#13;
    function getSpendableFee(&#13;
        Data.Order memory order,&#13;
        Data.Context memory ctx&#13;
        )&#13;
        internal&#13;
        view&#13;
        returns (uint)&#13;
    {&#13;
        return getSpendable(&#13;
            ctx.delegate,&#13;
            order.feeToken,&#13;
            order.owner,&#13;
            order.tokenSpendableFee&#13;
        );&#13;
    }&#13;
&#13;
    function reserveAmountS(&#13;
        Data.Order memory order,&#13;
        uint amount&#13;
        )&#13;
        internal&#13;
        pure&#13;
    {&#13;
        order.tokenSpendableS.reserved += amount;&#13;
    }&#13;
&#13;
    function reserveAmountFee(&#13;
        Data.Order memory order,&#13;
        uint amount&#13;
        )&#13;
        internal&#13;
        pure&#13;
    {&#13;
        order.tokenSpendableFee.reserved += amount;&#13;
    }&#13;
&#13;
    function resetReservations(&#13;
        Data.Order memory order&#13;
        )&#13;
        internal&#13;
        pure&#13;
    {&#13;
        order.tokenSpendableS.reserved = 0;&#13;
        order.tokenSpendableFee.reserved = 0;&#13;
    }&#13;
&#13;
    /// @return Amount of ERC20 token that can be spent by this contract.&#13;
    function getERC20Spendable(&#13;
        ITradeDelegate delegate,&#13;
        address tokenAddress,&#13;
        address owner&#13;
        )&#13;
        private&#13;
        view&#13;
        returns (uint spendable)&#13;
    {&#13;
        ERC20 token = ERC20(tokenAddress);&#13;
        spendable = token.allowance(&#13;
            owner,&#13;
            address(delegate)&#13;
        );&#13;
        if (spendable != 0) {&#13;
            uint balance = token.balanceOf(owner);&#13;
            spendable = (balance &lt; spendable) ? balance : spendable;&#13;
        }&#13;
    }&#13;
&#13;
    function getSpendable(&#13;
        ITradeDelegate delegate,&#13;
        address tokenAddress,&#13;
        address owner,&#13;
        Data.Spendable memory tokenSpendable&#13;
        )&#13;
        private&#13;
        view&#13;
        returns (uint spendable)&#13;
    {&#13;
        if (!tokenSpendable.initialized) {&#13;
            tokenSpendable.amount = getERC20Spendable(&#13;
                delegate,&#13;
                tokenAddress,&#13;
                owner&#13;
            );&#13;
            tokenSpendable.initialized = true;&#13;
        }&#13;
        spendable = tokenSpendable.amount.sub(tokenSpendable.reserved);&#13;
    }&#13;
}&#13;
&#13;
/*&#13;
&#13;
  Copyright 2017 Loopring Project Ltd (Loopring Foundation).&#13;
&#13;
  Licensed under the Apache License, Version 2.0 (the "License");&#13;
  you may not use this file except in compliance with the License.&#13;
  You may obtain a copy of the License at&#13;
&#13;
  http://www.apache.org/licenses/LICENSE-2.0&#13;
&#13;
  Unless required by applicable law or agreed to in writing, software&#13;
  distributed under the License is distributed on an "AS IS" BASIS,&#13;
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#13;
  See the License for the specific language governing permissions and&#13;
  limitations under the License.&#13;
*/&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
/*&#13;
&#13;
  Copyright 2017 Loopring Project Ltd (Loopring Foundation).&#13;
&#13;
  Licensed under the Apache License, Version 2.0 (the "License");&#13;
  you may not use this file except in compliance with the License.&#13;
  You may obtain a copy of the License at&#13;
&#13;
  http://www.apache.org/licenses/LICENSE-2.0&#13;
&#13;
  Unless required by applicable law or agreed to in writing, software&#13;
  distributed under the License is distributed on an "AS IS" BASIS,&#13;
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#13;
  See the License for the specific language governing permissions and&#13;
  limitations under the License.&#13;
*/&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
/// @title ParticipationHelper&#13;
/// @author Daniel Wang - &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="2d494c434448416d4142425d5f44434a03425f4a">[email protected]</a>&gt;.&#13;
library ParticipationHelper {&#13;
    using MathUint for uint;&#13;
    using OrderHelper for Data.Order;&#13;
&#13;
    function setMaxFillAmounts(&#13;
        Data.Participation memory p,&#13;
        Data.Context memory ctx&#13;
        )&#13;
        internal&#13;
        view&#13;
    {&#13;
        uint spendableS = p.order.getSpendableS(ctx);&#13;
        uint remainingS = p.order.amountS.sub(p.order.filledAmountS);&#13;
        p.fillAmountS = (spendableS &lt; remainingS) ? spendableS : remainingS;&#13;
&#13;
        if (!p.order.P2P) {&#13;
            // No need to check the fee balance of the owner if feeToken == tokenB,&#13;
            // fillAmountB will be used to pay the fee.&#13;
            if (!(p.order.feeToken == p.order.tokenB &amp;&amp;&#13;
                  p.order.owner == p.order.tokenRecipient &amp;&amp;&#13;
                  p.order.feeAmount &lt;= p.order.amountB)) {&#13;
                // Check how much fee needs to be paid. We limit fillAmountS to how much&#13;
                // fee the order owner can pay.&#13;
                uint feeAmount = p.order.feeAmount.mul(p.fillAmountS) / p.order.amountS;&#13;
                if (feeAmount &gt; 0) {&#13;
                    uint spendableFee = p.order.getSpendableFee(ctx);&#13;
                    if (p.order.feeToken == p.order.tokenS &amp;&amp; p.fillAmountS + feeAmount &gt; spendableS) {&#13;
                        assert(spendableFee == spendableS);&#13;
                        // Equally divide the available tokens between fillAmountS and feeAmount&#13;
                        uint totalAmount = p.order.amountS.add(p.order.feeAmount);&#13;
                        p.fillAmountS = spendableS.mul(p.order.amountS) / totalAmount;&#13;
                        feeAmount = spendableS.mul(p.order.feeAmount) / totalAmount;&#13;
                    } else if (feeAmount &gt; spendableFee) {&#13;
                        // Scale down fillAmountS so the available feeAmount is sufficient&#13;
                        feeAmount = spendableFee;&#13;
                        p.fillAmountS = feeAmount.mul(p.order.amountS) / p.order.feeAmount;&#13;
                    }&#13;
                }&#13;
            }&#13;
        }&#13;
&#13;
        p.fillAmountB = p.fillAmountS.mul(p.order.amountB) / p.order.amountS;&#13;
    }&#13;
&#13;
    function calculateFees(&#13;
        Data.Participation memory p,&#13;
        Data.Participation memory prevP,&#13;
        Data.Context memory ctx&#13;
        )&#13;
        internal&#13;
        view&#13;
        returns (bool)&#13;
    {&#13;
        if (p.order.P2P) {&#13;
            // Calculate P2P fees&#13;
            p.feeAmount = 0;&#13;
            p.feeAmountS = p.fillAmountS.mul(p.order.tokenSFeePercentage) / ctx.feePercentageBase;&#13;
            p.feeAmountB = p.fillAmountB.mul(p.order.tokenBFeePercentage) / ctx.feePercentageBase;&#13;
        } else {&#13;
            // Calculate matching fees&#13;
            p.feeAmount = p.order.feeAmount.mul(p.fillAmountS) / p.order.amountS;&#13;
            p.feeAmountS = 0;&#13;
            p.feeAmountB = 0;&#13;
&#13;
            // If feeToken == tokenB AND owner == tokenRecipient, try to pay using fillAmountB&#13;
&#13;
            if (p.order.feeToken == p.order.tokenB &amp;&amp;&#13;
                p.order.owner == p.order.tokenRecipient &amp;&amp;&#13;
                p.fillAmountB &gt;= p.feeAmount) {&#13;
                p.feeAmountB = p.feeAmount;&#13;
                p.feeAmount = 0;&#13;
            }&#13;
&#13;
            if (p.feeAmount &gt; 0) {&#13;
                // Make sure we can pay the feeAmount&#13;
                uint spendableFee = p.order.getSpendableFee(ctx);&#13;
                if (p.feeAmount &gt; spendableFee) {&#13;
                    // This normally should not happen, but this is possible when self-trading&#13;
                    return false;&#13;
                } else {&#13;
                    p.order.reserveAmountFee(p.feeAmount);&#13;
                }&#13;
            }&#13;
        }&#13;
&#13;
        if ((p.fillAmountS - p.feeAmountS) &gt;= prevP.fillAmountB) {&#13;
            // The miner (or in a P2P case, the taker) gets the margin&#13;
            p.splitS = (p.fillAmountS - p.feeAmountS) - prevP.fillAmountB;&#13;
            p.fillAmountS = prevP.fillAmountB + p.feeAmountS;&#13;
            return true;&#13;
        } else {&#13;
            return false;&#13;
        }&#13;
    }&#13;
&#13;
    function checkFills(&#13;
        Data.Participation memory p&#13;
        )&#13;
        internal&#13;
        pure&#13;
        returns (bool valid)&#13;
    {&#13;
        // Check if the rounding error of the calculated fillAmountB is larger than 1%.&#13;
        // If that's the case, this partipation in invalid&#13;
        // p.fillAmountB := p.fillAmountS.mul(p.order.amountB) / p.order.amountS&#13;
        valid = !MathUint.hasRoundingError(&#13;
            p.fillAmountS,&#13;
            p.order.amountB,&#13;
            p.order.amountS&#13;
        );&#13;
&#13;
        // We at least need to buy and sell something&#13;
        valid = valid &amp;&amp; p.fillAmountS &gt; 0;&#13;
        valid = valid &amp;&amp; p.fillAmountB &gt; 0;&#13;
    }&#13;
&#13;
    function adjustOrderState(&#13;
        Data.Participation memory p&#13;
        )&#13;
        internal&#13;
        pure&#13;
    {&#13;
        // Update filled amount&#13;
        p.order.filledAmountS += p.fillAmountS + p.splitS;&#13;
&#13;
        // Update spendables&#13;
        uint totalAmountS = p.fillAmountS + p.splitS;&#13;
        uint totalAmountFee = p.feeAmount;&#13;
        p.order.tokenSpendableS.amount = p.order.tokenSpendableS.amount.sub(totalAmountS);&#13;
        p.order.tokenSpendableFee.amount = p.order.tokenSpendableFee.amount.sub(totalAmountFee);&#13;
        if (p.order.brokerInterceptor != address(0x0)) {&#13;
            p.order.brokerSpendableS.amount = p.order.brokerSpendableS.amount.sub(totalAmountS);&#13;
            p.order.brokerSpendableFee.amount = p.order.brokerSpendableFee.amount.sub(totalAmountFee);&#13;
        }&#13;
    }&#13;
&#13;
    function revertOrderState(&#13;
        Data.Participation memory p&#13;
        )&#13;
        internal&#13;
        pure&#13;
    {&#13;
        // Revert filled amount&#13;
        p.order.filledAmountS = p.order.filledAmountS.sub(p.fillAmountS + p.splitS);&#13;
&#13;
        // We do not revert any spendables. Rings will not get rebalanced so this doesn't matter.&#13;
    }&#13;
&#13;
}&#13;
&#13;
&#13;
&#13;
/// @title RingHelper&#13;
library RingHelper {&#13;
    using MathUint for uint;&#13;
    using OrderHelper for Data.Order;&#13;
    using ParticipationHelper for Data.Participation;&#13;
&#13;
    function updateHash(&#13;
        Data.Ring memory ring&#13;
        )&#13;
        internal&#13;
        pure&#13;
    {&#13;
        uint ringSize = ring.size;&#13;
        bytes32 hash;&#13;
        assembly {&#13;
            let data := mload(0x40)&#13;
            let ptr := data&#13;
            let participations := mload(add(ring, 32))                                  // ring.participations&#13;
            for { let i := 0 } lt(i, ringSize) { i := add(i, 1) } {&#13;
                let participation := mload(add(participations, add(32, mul(i, 32))))    // participations[i]&#13;
                let order := mload(participation)                                       // participation.order&#13;
&#13;
                let waiveFeePercentage := and(mload(add(order, 672)), 0xFFFF)           // order.waiveFeePercentage&#13;
                let orderHash := mload(add(order, 864))                                 // order.hash&#13;
&#13;
                mstore(add(ptr, 2), waiveFeePercentage)&#13;
                mstore(ptr, orderHash)&#13;
&#13;
                ptr := add(ptr, 34)&#13;
            }&#13;
            hash := keccak256(data, sub(ptr, data))&#13;
        }&#13;
        ring.hash = hash;&#13;
    }&#13;
&#13;
    function calculateFillAmountAndFee(&#13;
        Data.Ring memory ring,&#13;
        Data.Context memory ctx&#13;
        )&#13;
        internal&#13;
        view&#13;
    {&#13;
        // Invalid order data could cause a divide by zero in the calculations&#13;
        if (!ring.valid) {&#13;
            return;&#13;
        }&#13;
&#13;
        uint i;&#13;
        int j;&#13;
        uint prevIndex;&#13;
&#13;
        for (i = 0; i &lt; ring.size; i++) {&#13;
            ring.participations[i].setMaxFillAmounts(&#13;
                ctx&#13;
            );&#13;
        }&#13;
&#13;
        uint smallest = 0;&#13;
        for (j = int(ring.size) - 1; j &gt;= 0; j--) {&#13;
            prevIndex = (uint(j) + ring.size - 1) % ring.size;&#13;
            smallest = calculateOrderFillAmounts(&#13;
                ctx,&#13;
                ring.participations[uint(j)],&#13;
                ring.participations[prevIndex],&#13;
                uint(j),&#13;
                smallest&#13;
            );&#13;
        }&#13;
        for (j = int(ring.size) - 1; j &gt;= int(smallest); j--) {&#13;
            prevIndex = (uint(j) + ring.size - 1) % ring.size;&#13;
            calculateOrderFillAmounts(&#13;
                ctx,&#13;
                ring.participations[uint(j)],&#13;
                ring.participations[prevIndex],&#13;
                uint(j),&#13;
                smallest&#13;
            );&#13;
        }&#13;
&#13;
        for (i = 0; i &lt; ring.size; i++) {&#13;
            // Check if the fill amounts of the participation are valid&#13;
            ring.valid = ring.valid &amp;&amp; ring.participations[i].checkFills();&#13;
&#13;
            // Reserve the total amount tokenS used for all the orders&#13;
            // (e.g. the owner of order 0 could use LRC as feeToken in order 0, while&#13;
            // the same owner can also sell LRC in order 2).&#13;
            ring.participations[i].order.reserveAmountS(ring.participations[i].fillAmountS);&#13;
        }&#13;
&#13;
        for (i = 0; i &lt; ring.size; i++) {&#13;
            prevIndex = (i + ring.size - 1) % ring.size;&#13;
&#13;
            bool valid = ring.participations[i].calculateFees(ring.participations[prevIndex], ctx);&#13;
            if (!valid) {&#13;
                ring.valid = false;&#13;
                break;&#13;
            }&#13;
&#13;
            int16 waiveFeePercentage = ring.participations[i].order.waiveFeePercentage;&#13;
            if (waiveFeePercentage &lt; 0) {&#13;
                ring.minerFeesToOrdersPercentage += uint(-waiveFeePercentage);&#13;
            }&#13;
        }&#13;
        // Miner can only distribute 100% of its fees to all orders combined&#13;
        ring.valid = ring.valid &amp;&amp; (ring.minerFeesToOrdersPercentage &lt;= ctx.feePercentageBase);&#13;
&#13;
        // Ring calculations are done. Make sure te remove all spendable reservations for this ring&#13;
        for (i = 0; i &lt; ring.size; i++) {&#13;
            ring.participations[i].order.resetReservations();&#13;
        }&#13;
    }&#13;
&#13;
    function calculateOrderFillAmounts(&#13;
        Data.Context memory ctx,&#13;
        Data.Participation memory p,&#13;
        Data.Participation memory prevP,&#13;
        uint i,&#13;
        uint smallest&#13;
        )&#13;
        internal&#13;
        pure&#13;
        returns (uint smallest_)&#13;
    {&#13;
        // Default to the same smallest index&#13;
        smallest_ = smallest;&#13;
&#13;
        uint postFeeFillAmountS = p.fillAmountS;&#13;
        uint tokenSFeePercentage = p.order.tokenSFeePercentage;&#13;
        if (tokenSFeePercentage &gt; 0) {&#13;
            uint feeAmountS = p.fillAmountS.mul(tokenSFeePercentage) / ctx.feePercentageBase;&#13;
            postFeeFillAmountS = p.fillAmountS - feeAmountS;&#13;
        }&#13;
&#13;
        if (prevP.fillAmountB &gt; postFeeFillAmountS) {&#13;
            smallest_ = i;&#13;
            prevP.fillAmountB = postFeeFillAmountS;&#13;
            prevP.fillAmountS = postFeeFillAmountS.mul(prevP.order.amountS) / prevP.order.amountB;&#13;
        }&#13;
    }&#13;
&#13;
    function checkOrdersValid(&#13;
        Data.Ring memory ring&#13;
        )&#13;
        internal&#13;
        pure&#13;
    {&#13;
        ring.valid = ring.valid &amp;&amp; (ring.size &gt; 1 &amp;&amp; ring.size &lt;= 8); // invalid ring size&#13;
        for (uint i = 0; i &lt; ring.size; i++) {&#13;
            uint prev = (i + ring.size - 1) % ring.size;&#13;
            ring.valid = ring.valid &amp;&amp; ring.participations[i].order.valid;&#13;
            ring.valid = ring.valid &amp;&amp; ring.participations[i].order.tokenS == ring.participations[prev].order.tokenB;&#13;
        }&#13;
    }&#13;
&#13;
    function checkForSubRings(&#13;
        Data.Ring memory ring&#13;
        )&#13;
        internal&#13;
        pure&#13;
    {&#13;
        for (uint i = 0; i &lt; ring.size - 1; i++) {&#13;
            address tokenS = ring.participations[i].order.tokenS;&#13;
            for (uint j = i + 1; j &lt; ring.size; j++) {&#13;
                ring.valid = ring.valid &amp;&amp; (tokenS != ring.participations[j].order.tokenS);&#13;
            }&#13;
        }&#13;
    }&#13;
&#13;
    function adjustOrderStates(&#13;
        Data.Ring memory ring&#13;
        )&#13;
        internal&#13;
        pure&#13;
    {&#13;
        // Adjust the orders&#13;
        for (uint i = 0; i &lt; ring.size; i++) {&#13;
            ring.participations[i].adjustOrderState();&#13;
        }&#13;
    }&#13;
&#13;
&#13;
    function revertOrderStats(&#13;
        Data.Ring memory ring&#13;
        )&#13;
        internal&#13;
        pure&#13;
    {&#13;
        for (uint i = 0; i &lt; ring.size; i++) {&#13;
            ring.participations[i].revertOrderState();&#13;
        }&#13;
    }&#13;
&#13;
    function doPayments(&#13;
        Data.Ring memory ring,&#13;
        Data.Context memory ctx,&#13;
        Data.Mining memory mining&#13;
        )&#13;
        internal&#13;
        view&#13;
    {&#13;
        payFees(ring, ctx, mining);&#13;
        transferTokens(ring, ctx, mining.feeRecipient);&#13;
    }&#13;
&#13;
    function generateFills(&#13;
        Data.Ring memory ring,&#13;
        uint destPtr&#13;
        )&#13;
        internal&#13;
        pure&#13;
        returns (uint fill)&#13;
    {&#13;
        uint ringSize = ring.size;&#13;
        uint fillSize = 8 * 32;&#13;
        assembly {&#13;
            fill := destPtr&#13;
            let participations := mload(add(ring, 32))                                 // ring.participations&#13;
&#13;
            for { let i := 0 } lt(i, ringSize) { i := add(i, 1) } {&#13;
                let participation := mload(add(participations, add(32, mul(i, 32))))   // participations[i]&#13;
                let order := mload(participation)                                      // participation.order&#13;
&#13;
                // Calculate the actual fees paid after rebate&#13;
                let feeAmount := sub(&#13;
                    mload(add(participation, 64)),                                      // participation.feeAmount&#13;
                    mload(add(participation, 160))                                      // participation.rebateFee&#13;
                )&#13;
                let feeAmountS := sub(&#13;
                    mload(add(participation, 96)),                                      // participation.feeAmountS&#13;
                    mload(add(participation, 192))                                      // participation.rebateFeeS&#13;
                )&#13;
                let feeAmountB := sub(&#13;
                    mload(add(participation, 128)),                                     // participation.feeAmountB&#13;
                    mload(add(participation, 224))                                      // participation.rebateFeeB&#13;
                )&#13;
&#13;
                mstore(add(fill,   0), mload(add(order, 864)))                         // order.hash&#13;
                mstore(add(fill,  32), mload(add(order,  32)))                         // order.owner&#13;
                mstore(add(fill,  64), mload(add(order,  64)))                         // order.tokenS&#13;
                mstore(add(fill,  96), mload(add(participation, 256)))                 // participation.fillAmountS&#13;
                mstore(add(fill, 128), mload(add(participation,  32)))                 // participation.splitS&#13;
                mstore(add(fill, 160), feeAmount)                                      // feeAmount&#13;
                mstore(add(fill, 192), feeAmountS)                                     // feeAmountS&#13;
                mstore(add(fill, 224), feeAmountB)                                     // feeAmountB&#13;
&#13;
                fill := add(fill, fillSize)&#13;
            }&#13;
        }&#13;
    }&#13;
&#13;
    function transferTokens(&#13;
        Data.Ring memory ring,&#13;
        Data.Context memory ctx,&#13;
        address feeRecipient&#13;
        )&#13;
        internal&#13;
        pure&#13;
    {&#13;
        for (uint i = 0; i &lt; ring.size; i++) {&#13;
            transferTokensForParticipation(&#13;
                ctx,&#13;
                feeRecipient,&#13;
                ring.participations[i],&#13;
                ring.participations[(i + ring.size - 1) % ring.size]&#13;
            );&#13;
        }&#13;
    }&#13;
&#13;
    function transferTokensForParticipation(&#13;
        Data.Context memory ctx,&#13;
        address feeRecipient,&#13;
        Data.Participation memory p,&#13;
        Data.Participation memory prevP&#13;
        )&#13;
        internal&#13;
        pure&#13;
        returns (uint)&#13;
    {&#13;
        uint buyerFeeAmountAfterRebateB = prevP.feeAmountB.sub(prevP.rebateB);&#13;
&#13;
        // If the buyer needs to pay fees in tokenB, the seller needs&#13;
        // to send the tokenS amount to the fee holder contract&#13;
        uint amountSToBuyer = p.fillAmountS&#13;
            .sub(p.feeAmountS)&#13;
            .sub(buyerFeeAmountAfterRebateB);&#13;
&#13;
        uint amountSToFeeHolder = p.feeAmountS&#13;
            .sub(p.rebateS)&#13;
            .add(buyerFeeAmountAfterRebateB);&#13;
&#13;
        uint amountFeeToFeeHolder = p.feeAmount&#13;
            .sub(p.rebateFee);&#13;
&#13;
        if (p.order.tokenS == p.order.feeToken) {&#13;
            amountSToFeeHolder = amountSToFeeHolder.add(amountFeeToFeeHolder);&#13;
            amountFeeToFeeHolder = 0;&#13;
        }&#13;
&#13;
        // Transfers&#13;
        ctx.transferPtr = addTokenTransfer(&#13;
            ctx.transferData,&#13;
            ctx.transferPtr,&#13;
            p.order.feeToken,&#13;
            p.order.owner,&#13;
            address(ctx.feeHolder),&#13;
            amountFeeToFeeHolder&#13;
        );&#13;
        ctx.transferPtr = addTokenTransfer(&#13;
            ctx.transferData,&#13;
            ctx.transferPtr,&#13;
            p.order.tokenS,&#13;
            p.order.owner,&#13;
            address(ctx.feeHolder),&#13;
            amountSToFeeHolder&#13;
        );&#13;
        ctx.transferPtr = addTokenTransfer(&#13;
            ctx.transferData,&#13;
            ctx.transferPtr,&#13;
            p.order.tokenS,&#13;
            p.order.owner,&#13;
            prevP.order.tokenRecipient,&#13;
            amountSToBuyer&#13;
        );&#13;
&#13;
        // Miner (or for P2P the taker) gets the margin without sharing it with the wallet or burning&#13;
        ctx.transferPtr = addTokenTransfer(&#13;
            ctx.transferData,&#13;
            ctx.transferPtr,&#13;
            p.order.tokenS,&#13;
            p.order.owner,&#13;
            feeRecipient,&#13;
            p.splitS&#13;
        );&#13;
    }&#13;
&#13;
    function addTokenTransfer(&#13;
        uint data,&#13;
        uint ptr,&#13;
        address token,&#13;
        address from,&#13;
        address to,&#13;
        uint amount&#13;
        )&#13;
        internal&#13;
        pure&#13;
        returns (uint)&#13;
    {&#13;
        if (amount &gt; 0 &amp;&amp; from != to) {&#13;
            assembly {&#13;
                // Try to find an existing fee payment of the same token to the same owner&#13;
                let addNew := 1&#13;
                for { let p := data } lt(p, ptr) { p := add(p, 128) } {&#13;
                    let dataToken := mload(add(p,  0))&#13;
                    let dataFrom := mload(add(p, 32))&#13;
                    let dataTo := mload(add(p, 64))&#13;
                    // if(token == dataToken &amp;&amp; from == dataFrom &amp;&amp; to == dataTo)&#13;
                    if and(and(eq(token, dataToken), eq(from, dataFrom)), eq(to, dataTo)) {&#13;
                        let dataAmount := mload(add(p, 96))&#13;
                        // dataAmount = amount.add(dataAmount);&#13;
                        dataAmount := add(amount, dataAmount)&#13;
                        // require(dataAmount &gt;= amount) (safe math)&#13;
                        if lt(dataAmount, amount) {&#13;
                            revert(0, 0)&#13;
                        }&#13;
                        mstore(add(p, 96), dataAmount)&#13;
                        addNew := 0&#13;
                        // End the loop&#13;
                        p := ptr&#13;
                    }&#13;
                }&#13;
                // Add a new transfer&#13;
                if eq(addNew, 1) {&#13;
                    mstore(add(ptr,  0), token)&#13;
                    mstore(add(ptr, 32), from)&#13;
                    mstore(add(ptr, 64), to)&#13;
                    mstore(add(ptr, 96), amount)&#13;
                    ptr := add(ptr, 128)&#13;
                }&#13;
            }&#13;
            return ptr;&#13;
        } else {&#13;
            return ptr;&#13;
        }&#13;
    }&#13;
&#13;
    function payFees(&#13;
        Data.Ring memory ring,&#13;
        Data.Context memory ctx,&#13;
        Data.Mining memory mining&#13;
        )&#13;
        internal&#13;
        view&#13;
    {&#13;
        Data.FeeContext memory feeCtx;&#13;
        feeCtx.ring = ring;&#13;
        feeCtx.ctx = ctx;&#13;
        feeCtx.feeRecipient = mining.feeRecipient;&#13;
        for (uint i = 0; i &lt; ring.size; i++) {&#13;
            payFeesForParticipation(&#13;
                feeCtx,&#13;
                ring.participations[i]&#13;
            );&#13;
        }&#13;
    }&#13;
&#13;
    function payFeesForParticipation(&#13;
        Data.FeeContext memory feeCtx,&#13;
        Data.Participation memory p&#13;
        )&#13;
        internal&#13;
        view&#13;
        returns (uint)&#13;
    {&#13;
        feeCtx.walletPercentage = p.order.P2P ? 100 : (&#13;
            (p.order.wallet == address(0x0) ? 0 : p.order.walletSplitPercentage)&#13;
        );&#13;
        feeCtx.waiveFeePercentage = p.order.waiveFeePercentage;&#13;
        feeCtx.owner = p.order.owner;&#13;
        feeCtx.wallet = p.order.wallet;&#13;
        feeCtx.P2P = p.order.P2P;&#13;
&#13;
        p.rebateFee = payFeesAndBurn(&#13;
            feeCtx,&#13;
            p.order.feeToken,&#13;
            p.feeAmount&#13;
        );&#13;
        p.rebateS = payFeesAndBurn(&#13;
            feeCtx,&#13;
            p.order.tokenS,&#13;
            p.feeAmountS&#13;
        );&#13;
        p.rebateB = payFeesAndBurn(&#13;
            feeCtx,&#13;
            p.order.tokenB,&#13;
            p.feeAmountB&#13;
        );&#13;
    }&#13;
&#13;
    function payFeesAndBurn(&#13;
        Data.FeeContext memory feeCtx,&#13;
        address token,&#13;
        uint totalAmount&#13;
        )&#13;
        internal&#13;
        view&#13;
        returns (uint)&#13;
    {&#13;
        if (totalAmount == 0) {&#13;
            return 0;&#13;
        }&#13;
&#13;
        uint amount = totalAmount;&#13;
        // No need to pay any fees in a P2P order without a wallet&#13;
        // (but the fee amount is a part of amountS of the order, so the fee amount is rebated).&#13;
        if (feeCtx.P2P &amp;&amp; feeCtx.wallet == address(0x0)) {&#13;
            amount = 0;&#13;
        }&#13;
&#13;
        uint feeToWallet = 0;&#13;
        uint minerFee = 0;&#13;
        uint minerFeeBurn = 0;&#13;
        uint walletFeeBurn = 0;&#13;
        if (amount &gt; 0) {&#13;
            feeToWallet = amount.mul(feeCtx.walletPercentage) / 100;&#13;
            minerFee = amount - feeToWallet;&#13;
&#13;
            // Miner can waive fees for this order. If waiveFeePercentage &gt; 0 this is a simple reduction in fees.&#13;
            if (feeCtx.waiveFeePercentage &gt; 0) {&#13;
                minerFee = minerFee.mul(&#13;
                    feeCtx.ctx.feePercentageBase - uint(feeCtx.waiveFeePercentage)) /&#13;
                    feeCtx.ctx.feePercentageBase;&#13;
            } else if (feeCtx.waiveFeePercentage &lt; 0) {&#13;
                // No fees need to be paid by this order&#13;
                minerFee = 0;&#13;
            }&#13;
&#13;
            uint32 burnRate = getBurnRate(feeCtx, token);&#13;
            assert(burnRate &lt;= feeCtx.ctx.feePercentageBase);&#13;
&#13;
            // Miner fee&#13;
            minerFeeBurn = minerFee.mul(burnRate) / feeCtx.ctx.feePercentageBase;&#13;
            minerFee = minerFee - minerFeeBurn;&#13;
            // Wallet fee&#13;
            walletFeeBurn = feeToWallet.mul(burnRate) / feeCtx.ctx.feePercentageBase;&#13;
            feeToWallet = feeToWallet - walletFeeBurn;&#13;
&#13;
            // Pay the wallet&#13;
            feeCtx.ctx.feePtr = addFeePayment(&#13;
                feeCtx.ctx.feeData,&#13;
                feeCtx.ctx.feePtr,&#13;
                token,&#13;
                feeCtx.wallet,&#13;
                feeToWallet&#13;
            );&#13;
&#13;
            // Pay the burn rate with the feeHolder as owner&#13;
            feeCtx.ctx.feePtr = addFeePayment(&#13;
                feeCtx.ctx.feeData,&#13;
                feeCtx.ctx.feePtr,&#13;
                token,&#13;
                address(feeCtx.ctx.feeHolder),&#13;
                minerFeeBurn + walletFeeBurn&#13;
            );&#13;
&#13;
            // Fees can be paid out in different tokens so we can't easily accumulate the total fee&#13;
            // that needs to be paid out to order owners. So we pay out each part out here to all&#13;
            // orders that need it.&#13;
            uint feeToMiner = minerFee;&#13;
            if (feeCtx.ring.minerFeesToOrdersPercentage &gt; 0 &amp;&amp; minerFee &gt; 0) {&#13;
                // Pay out the fees to the orders&#13;
                distributeMinerFeeToOwners(&#13;
                    feeCtx,&#13;
                    token,&#13;
                    minerFee&#13;
                );&#13;
                // Subtract all fees the miner pays to the orders&#13;
                feeToMiner = minerFee.mul(feeCtx.ctx.feePercentageBase -&#13;
                    feeCtx.ring.minerFeesToOrdersPercentage) /&#13;
                    feeCtx.ctx.feePercentageBase;&#13;
            }&#13;
&#13;
            // Pay the miner&#13;
            feeCtx.ctx.feePtr = addFeePayment(&#13;
                feeCtx.ctx.feeData,&#13;
                feeCtx.ctx.feePtr,&#13;
                token,&#13;
                feeCtx.feeRecipient,&#13;
                feeToMiner&#13;
            );&#13;
        }&#13;
&#13;
        // Calculate the total fee payment after possible discounts (burn rebate + fee waiving)&#13;
        // and return the total rebate&#13;
        return totalAmount.sub((feeToWallet + minerFee) + (minerFeeBurn + walletFeeBurn));&#13;
    }&#13;
&#13;
    function getBurnRate(&#13;
        Data.FeeContext memory feeCtx,&#13;
        address token&#13;
        )&#13;
        internal&#13;
        view&#13;
        returns (uint32)&#13;
    {&#13;
        bytes32[] memory tokenBurnRates = feeCtx.ctx.tokenBurnRates;&#13;
        uint length = tokenBurnRates.length;&#13;
        for (uint i = 0; i &lt; length; i += 2) {&#13;
            if (token == address(bytes20(tokenBurnRates[i]))) {&#13;
                uint32 burnRate = uint32(bytes4(tokenBurnRates[i + 1]));&#13;
                return feeCtx.P2P ? (burnRate / 0x10000) : (burnRate &amp; 0xFFFF);&#13;
            }&#13;
        }&#13;
        // Not found, add it to the list&#13;
        uint32 burnRate = feeCtx.ctx.burnRateTable.getBurnRate(token);&#13;
        assembly {&#13;
            let ptr := add(tokenBurnRates, mul(add(1, length), 32))&#13;
            mstore(ptr, token)                              // token&#13;
            mstore(add(ptr, 32), burnRate)                  // burn rate&#13;
            mstore(tokenBurnRates, add(length, 2))          // length&#13;
        }&#13;
        return feeCtx.P2P ? (burnRate / 0x10000) : (burnRate &amp; 0xFFFF);&#13;
    }&#13;
&#13;
    function distributeMinerFeeToOwners(&#13;
        Data.FeeContext memory feeCtx,&#13;
        address token,&#13;
        uint minerFee&#13;
        )&#13;
        internal&#13;
        pure&#13;
    {&#13;
        for (uint i = 0; i &lt; feeCtx.ring.size; i++) {&#13;
            if (feeCtx.ring.participations[i].order.waiveFeePercentage &lt; 0) {&#13;
                uint feeToOwner = minerFee&#13;
                    .mul(uint(-feeCtx.ring.participations[i].order.waiveFeePercentage)) / feeCtx.ctx.feePercentageBase;&#13;
&#13;
                feeCtx.ctx.feePtr = addFeePayment(&#13;
                    feeCtx.ctx.feeData,&#13;
                    feeCtx.ctx.feePtr,&#13;
                    token,&#13;
                    feeCtx.ring.participations[i].order.owner,&#13;
                    feeToOwner);&#13;
            }&#13;
        }&#13;
    }&#13;
&#13;
    function addFeePayment(&#13;
        uint data,&#13;
        uint ptr,&#13;
        address token,&#13;
        address owner,&#13;
        uint amount&#13;
        )&#13;
        internal&#13;
        pure&#13;
        returns (uint)&#13;
    {&#13;
        if (amount == 0) {&#13;
            return ptr;&#13;
        } else {&#13;
            assembly {&#13;
                // Try to find an existing fee payment of the same token to the same owner&#13;
                let addNew := 1&#13;
                for { let p := data } lt(p, ptr) { p := add(p, 96) } {&#13;
                    let dataToken := mload(add(p,  0))&#13;
                    let dataOwner := mload(add(p, 32))&#13;
                    // if(token == dataToken &amp;&amp; owner == dataOwner)&#13;
                    if and(eq(token, dataToken), eq(owner, dataOwner)) {&#13;
                        let dataAmount := mload(add(p, 64))&#13;
                        // dataAmount = amount.add(dataAmount);&#13;
                        dataAmount := add(amount, dataAmount)&#13;
                        // require(dataAmount &gt;= amount) (safe math)&#13;
                        if lt(dataAmount, amount) {&#13;
                            revert(0, 0)&#13;
                        }&#13;
                        mstore(add(p, 64), dataAmount)&#13;
                        addNew := 0&#13;
                        // End the loop&#13;
                        p := ptr&#13;
                    }&#13;
                }&#13;
                // Add a new fee payment&#13;
                if eq(addNew, 1) {&#13;
                    mstore(add(ptr,  0), token)&#13;
                    mstore(add(ptr, 32), owner)&#13;
                    mstore(add(ptr, 64), amount)&#13;
                    ptr := add(ptr, 96)&#13;
                }&#13;
            }&#13;
            return ptr;&#13;
        }&#13;
    }&#13;
&#13;
}&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
/*&#13;
&#13;
  Copyright 2017 Loopring Project Ltd (Loopring Foundation).&#13;
&#13;
  Licensed under the Apache License, Version 2.0 (the "License");&#13;
  you may not use this file except in compliance with the License.&#13;
  You may obtain a copy of the License at&#13;
&#13;
  http://www.apache.org/licenses/LICENSE-2.0&#13;
&#13;
  Unless required by applicable law or agreed to in writing, software&#13;
  distributed under the License is distributed on an "AS IS" BASIS,&#13;
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#13;
  See the License for the specific language governing permissions and&#13;
  limitations under the License.&#13;
*/&#13;
&#13;
&#13;
/*&#13;
&#13;
  Copyright 2017 Loopring Project Ltd (Loopring Foundation).&#13;
&#13;
  Licensed under the Apache License, Version 2.0 (the "License");&#13;
  you may not use this file except in compliance with the License.&#13;
  You may obtain a copy of the License at&#13;
&#13;
  http://www.apache.org/licenses/LICENSE-2.0&#13;
&#13;
  Unless required by applicable law or agreed to in writing, software&#13;
  distributed under the License is distributed on an "AS IS" BASIS,&#13;
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#13;
  See the License for the specific language governing permissions and&#13;
  limitations under the License.&#13;
*/&#13;
&#13;
&#13;
&#13;
/// @title Errors&#13;
contract Errors {&#13;
    string constant ZERO_VALUE                 = "ZERO_VALUE";&#13;
    string constant ZERO_ADDRESS               = "ZERO_ADDRESS";&#13;
    string constant INVALID_VALUE              = "INVALID_VALUE";&#13;
    string constant INVALID_ADDRESS            = "INVALID_ADDRESS";&#13;
    string constant INVALID_SIZE               = "INVALID_SIZE";&#13;
    string constant INVALID_SIG                = "INVALID_SIG";&#13;
    string constant INVALID_STATE              = "INVALID_STATE";&#13;
    string constant NOT_FOUND                  = "NOT_FOUND";&#13;
    string constant ALREADY_EXIST              = "ALREADY_EXIST";&#13;
    string constant REENTRY                    = "REENTRY";&#13;
    string constant UNAUTHORIZED               = "UNAUTHORIZED";&#13;
    string constant UNIMPLEMENTED              = "UNIMPLEMENTED";&#13;
    string constant UNSUPPORTED                = "UNSUPPORTED";&#13;
    string constant TRANSFER_FAILURE           = "TRANSFER_FAILURE";&#13;
    string constant WITHDRAWAL_FAILURE         = "WITHDRAWAL_FAILURE";&#13;
    string constant BURN_FAILURE               = "BURN_FAILURE";&#13;
    string constant BURN_RATE_FROZEN           = "BURN_RATE_FROZEN";&#13;
    string constant BURN_RATE_MINIMIZED        = "BURN_RATE_MINIMIZED";&#13;
    string constant UNAUTHORIZED_ONCHAIN_ORDER = "UNAUTHORIZED_ONCHAIN_ORDER";&#13;
    string constant INVALID_CANDIDATE          = "INVALID_CANDIDATE";&#13;
    string constant ALREADY_VOTED              = "ALREADY_VOTED";&#13;
    string constant NOT_OWNER                  = "NOT_OWNER";&#13;
}&#13;
&#13;
&#13;
&#13;
/// @title NoDefaultFunc&#13;
/// @dev Disable default functions.&#13;
contract NoDefaultFunc is Errors {&#13;
    function ()&#13;
        external&#13;
        payable&#13;
    {&#13;
        revert(UNSUPPORTED);&#13;
    }&#13;
}&#13;
&#13;
&#13;
&#13;
/*&#13;
&#13;
  Copyright 2017 Loopring Project Ltd (Loopring Foundation).&#13;
&#13;
  Licensed under the Apache License, Version 2.0 (the "License");&#13;
  you may not use this file except in compliance with the License.&#13;
  You may obtain a copy of the License at&#13;
&#13;
  http://www.apache.org/licenses/LICENSE-2.0&#13;
&#13;
  Unless required by applicable law or agreed to in writing, software&#13;
  distributed under the License is distributed on an "AS IS" BASIS,&#13;
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#13;
  See the License for the specific language governing permissions and&#13;
  limitations under the License.&#13;
*/&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
/// @title Deserializes the data passed to submitRings&#13;
/// @author Daniel Wang - &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="cda9aca3a4a8a18da1a2a2bdbfa4a3aae3a2bfaa">[email protected]</a>&gt;,&#13;
library ExchangeDeserializer {&#13;
    using BytesUtil     for bytes;&#13;
&#13;
    function deserialize(&#13;
        address lrcTokenAddress,&#13;
        bytes memory data&#13;
        )&#13;
        internal&#13;
        view&#13;
        returns (&#13;
            Data.Mining memory mining,&#13;
            Data.Order[] memory orders,&#13;
            Data.Ring[] memory rings&#13;
        )&#13;
    {&#13;
        // Read the header&#13;
        Data.Header memory header;&#13;
        header.version = data.bytesToUint16(0);&#13;
        header.numOrders = data.bytesToUint16(2);&#13;
        header.numRings = data.bytesToUint16(4);&#13;
        header.numSpendables = data.bytesToUint16(6);&#13;
&#13;
        // Validation&#13;
        require(header.version == 0, "Unsupported serialization format");&#13;
        require(header.numOrders &gt; 0, "Invalid number of orders");&#13;
        require(header.numRings &gt; 0, "Invalid number of rings");&#13;
        require(header.numSpendables &gt; 0, "Invalid number of spendables");&#13;
&#13;
        // Calculate data pointers&#13;
        uint dataPtr;&#13;
        assembly {&#13;
            dataPtr := data&#13;
        }&#13;
        uint miningDataPtr = dataPtr + 8;&#13;
        uint orderDataPtr = miningDataPtr + 3 * 2;&#13;
        uint ringDataPtr = orderDataPtr + (30 * header.numOrders) * 2;&#13;
        uint dataBlobPtr = ringDataPtr + (header.numRings * 9) + 32;&#13;
&#13;
        // The data stream needs to be at least large enough for the&#13;
        // header/mining/orders/rings data + 64 bytes of zeros in the data blob.&#13;
        require(data.length &gt;= (dataBlobPtr - dataPtr) + 32, "Invalid input data");&#13;
&#13;
        // Setup the rings&#13;
        mining = setupMiningData(dataBlobPtr, miningDataPtr + 2);&#13;
        orders = setupOrders(dataBlobPtr, orderDataPtr + 2, header.numOrders, header.numSpendables, lrcTokenAddress);&#13;
        rings = assembleRings(ringDataPtr + 1, header.numRings, orders);&#13;
    }&#13;
&#13;
    function setupMiningData(&#13;
        uint data,&#13;
        uint tablesPtr&#13;
        )&#13;
        internal&#13;
        view&#13;
        returns (Data.Mining memory mining)&#13;
    {&#13;
        bytes memory emptyBytes = new bytes(0);&#13;
        uint offset;&#13;
&#13;
        assembly {&#13;
            // Default to transaction origin for feeRecipient&#13;
            mstore(add(data, 20), origin)&#13;
&#13;
            // mining.feeRecipient&#13;
            offset := mul(and(mload(add(tablesPtr,  0)), 0xFFFF), 4)&#13;
            mstore(&#13;
                add(mining,   0),&#13;
                mload(add(add(data, 20), offset))&#13;
            )&#13;
&#13;
            // Restore default to 0&#13;
            mstore(add(data, 20), 0)&#13;
&#13;
            // mining.miner&#13;
            offset := mul(and(mload(add(tablesPtr,  2)), 0xFFFF), 4)&#13;
            mstore(&#13;
                add(mining,  32),&#13;
                mload(add(add(data, 20), offset))&#13;
            )&#13;
&#13;
            // Default to empty bytes array&#13;
            mstore(add(data, 32), emptyBytes)&#13;
&#13;
            // mining.sig&#13;
            offset := mul(and(mload(add(tablesPtr,  4)), 0xFFFF), 4)&#13;
            mstore(&#13;
                add(mining, 64),&#13;
                add(data, add(offset, 32))&#13;
            )&#13;
&#13;
            // Restore default to 0&#13;
            mstore(add(data, 32), 0)&#13;
        }&#13;
    }&#13;
&#13;
    function setupOrders(&#13;
        uint data,&#13;
        uint tablesPtr,&#13;
        uint numOrders,&#13;
        uint numSpendables,&#13;
        address lrcTokenAddress&#13;
        )&#13;
        internal&#13;
        pure&#13;
        returns (Data.Order[] memory orders)&#13;
    {&#13;
        bytes memory emptyBytes = new bytes(0);&#13;
        uint orderStructSize = 38 * 32;&#13;
        // Memory for orders length + numOrders order pointers&#13;
        uint arrayDataSize = (1 + numOrders) * 32;&#13;
        Data.Spendable[] memory spendableList = new Data.Spendable[](numSpendables);&#13;
        uint offset;&#13;
&#13;
        assembly {&#13;
            // Allocate memory for all orders&#13;
            orders := mload(0x40)&#13;
            mstore(add(orders, 0), numOrders)                       // orders.length&#13;
            // Reserve the memory for the orders array&#13;
            mstore(0x40, add(orders, add(arrayDataSize, mul(orderStructSize, numOrders))))&#13;
&#13;
            for { let i := 0 } lt(i, numOrders) { i := add(i, 1) } {&#13;
                let order := add(orders, add(arrayDataSize, mul(orderStructSize, i)))&#13;
&#13;
                // Store the memory location of this order in the orders array&#13;
                mstore(add(orders, mul(add(1, i), 32)), order)&#13;
&#13;
                // order.version&#13;
                offset := and(mload(add(tablesPtr,  0)), 0xFFFF)&#13;
                mstore(&#13;
                    add(order,   0),&#13;
                    offset&#13;
                )&#13;
&#13;
                // order.owner&#13;
                offset := mul(and(mload(add(tablesPtr,  2)), 0xFFFF), 4)&#13;
                mstore(&#13;
                    add(order,  32),&#13;
                    and(mload(add(add(data, 20), offset)), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)&#13;
                )&#13;
&#13;
                // order.tokenS&#13;
                offset := mul(and(mload(add(tablesPtr,  4)), 0xFFFF), 4)&#13;
                mstore(&#13;
                    add(order,  64),&#13;
                    and(mload(add(add(data, 20), offset)), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)&#13;
                )&#13;
&#13;
                // order.tokenB&#13;
                offset := mul(and(mload(add(tablesPtr,  6)), 0xFFFF), 4)&#13;
                mstore(&#13;
                    add(order,  96),&#13;
                    and(mload(add(add(data, 20), offset)), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)&#13;
                )&#13;
&#13;
                // order.amountS&#13;
                offset := mul(and(mload(add(tablesPtr,  8)), 0xFFFF), 4)&#13;
                mstore(&#13;
                    add(order, 128),&#13;
                    mload(add(add(data, 32), offset))&#13;
                )&#13;
&#13;
                // order.amountB&#13;
                offset := mul(and(mload(add(tablesPtr, 10)), 0xFFFF), 4)&#13;
                mstore(&#13;
                    add(order, 160),&#13;
                    mload(add(add(data, 32), offset))&#13;
                )&#13;
&#13;
                // order.validSince&#13;
                offset := mul(and(mload(add(tablesPtr, 12)), 0xFFFF), 4)&#13;
                mstore(&#13;
                    add(order, 192),&#13;
                    and(mload(add(add(data, 4), offset)), 0xFFFFFFFF)&#13;
                )&#13;
&#13;
                // order.tokenSpendableS&#13;
                offset := and(mload(add(tablesPtr, 14)), 0xFFFF)&#13;
                // Force the spendable index to 0 if it's invalid&#13;
                offset := mul(offset, lt(offset, numSpendables))&#13;
                mstore(&#13;
                    add(order, 224),&#13;
                    mload(add(spendableList, mul(add(offset, 1), 32)))&#13;
                )&#13;
&#13;
                // order.tokenSpendableFee&#13;
                offset := and(mload(add(tablesPtr, 16)), 0xFFFF)&#13;
                // Force the spendable index to 0 if it's invalid&#13;
                offset := mul(offset, lt(offset, numSpendables))&#13;
                mstore(&#13;
                    add(order, 256),&#13;
                    mload(add(spendableList, mul(add(offset, 1), 32)))&#13;
                )&#13;
&#13;
                // order.dualAuthAddr&#13;
                offset := mul(and(mload(add(tablesPtr, 18)), 0xFFFF), 4)&#13;
                mstore(&#13;
                    add(order, 288),&#13;
                    and(mload(add(add(data, 20), offset)), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)&#13;
                )&#13;
&#13;
                // order.broker&#13;
                offset := mul(and(mload(add(tablesPtr, 20)), 0xFFFF), 4)&#13;
                mstore(&#13;
                    add(order, 320),&#13;
                    and(mload(add(add(data, 20), offset)), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)&#13;
                )&#13;
&#13;
                // order.orderInterceptor&#13;
                offset := mul(and(mload(add(tablesPtr, 22)), 0xFFFF), 4)&#13;
                mstore(&#13;
                    add(order, 416),&#13;
                    and(mload(add(add(data, 20), offset)), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)&#13;
                )&#13;
&#13;
                // order.wallet&#13;
                offset := mul(and(mload(add(tablesPtr, 24)), 0xFFFF), 4)&#13;
                mstore(&#13;
                    add(order, 448),&#13;
                    and(mload(add(add(data, 20), offset)), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)&#13;
                )&#13;
&#13;
                // order.validUntil&#13;
                offset := mul(and(mload(add(tablesPtr, 26)), 0xFFFF), 4)&#13;
                mstore(&#13;
                    add(order, 480),&#13;
                    and(mload(add(add(data,  4), offset)), 0xFFFFFFFF)&#13;
                )&#13;
&#13;
                // Default to empty bytes array for value sig and dualAuthSig&#13;
                mstore(add(data, 32), emptyBytes)&#13;
&#13;
                // order.sig&#13;
                offset := mul(and(mload(add(tablesPtr, 28)), 0xFFFF), 4)&#13;
                mstore(&#13;
                    add(order, 512),&#13;
                    add(data, add(offset, 32))&#13;
                )&#13;
&#13;
                // order.dualAuthSig&#13;
                offset := mul(and(mload(add(tablesPtr, 30)), 0xFFFF), 4)&#13;
                mstore(&#13;
                    add(order, 544),&#13;
                    add(data, add(offset, 32))&#13;
                )&#13;
&#13;
                // Restore default to 0&#13;
                mstore(add(data, 32), 0)&#13;
&#13;
                // order.allOrNone&#13;
                offset := and(mload(add(tablesPtr, 32)), 0xFFFF)&#13;
                mstore(&#13;
                    add(order, 576),&#13;
                    gt(offset, 0)&#13;
                )&#13;
&#13;
                // lrcTokenAddress is the default value for feeToken&#13;
                mstore(add(data, 20), lrcTokenAddress)&#13;
&#13;
                // order.feeToken&#13;
                offset := mul(and(mload(add(tablesPtr, 34)), 0xFFFF), 4)&#13;
                mstore(&#13;
                    add(order, 608),&#13;
                    and(mload(add(add(data, 20), offset)), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)&#13;
                )&#13;
&#13;
                // Restore default to 0&#13;
                mstore(add(data, 20), 0)&#13;
&#13;
                // order.feeAmount&#13;
                offset := mul(and(mload(add(tablesPtr, 36)), 0xFFFF), 4)&#13;
                mstore(&#13;
                    add(order, 640),&#13;
                    mload(add(add(data, 32), offset))&#13;
                )&#13;
&#13;
                // order.waiveFeePercentage&#13;
                offset := and(mload(add(tablesPtr, 38)), 0xFFFF)&#13;
                mstore(&#13;
                    add(order, 672),&#13;
                    offset&#13;
                )&#13;
&#13;
                // order.tokenSFeePercentage&#13;
                offset := and(mload(add(tablesPtr, 40)), 0xFFFF)&#13;
                mstore(&#13;
                    add(order, 704),&#13;
                    offset&#13;
                )&#13;
&#13;
                // order.tokenBFeePercentage&#13;
                offset := and(mload(add(tablesPtr, 42)), 0xFFFF)&#13;
                mstore(&#13;
                    add(order, 736),&#13;
                    offset&#13;
                )&#13;
&#13;
                // The owner is the default value of tokenRecipient&#13;
                mstore(add(data, 20), mload(add(order, 32)))                // order.owner&#13;
&#13;
                // order.tokenRecipient&#13;
                offset := mul(and(mload(add(tablesPtr, 44)), 0xFFFF), 4)&#13;
                mstore(&#13;
                    add(order, 768),&#13;
                    and(mload(add(add(data, 20), offset)), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)&#13;
                )&#13;
&#13;
                // Restore default to 0&#13;
                mstore(add(data, 20), 0)&#13;
&#13;
                // order.walletSplitPercentage&#13;
                offset := and(mload(add(tablesPtr, 46)), 0xFFFF)&#13;
                mstore(&#13;
                    add(order, 800),&#13;
                    offset&#13;
                )&#13;
&#13;
                // order.tokenTypeS&#13;
                offset := and(mload(add(tablesPtr, 48)), 0xFFFF)&#13;
                mstore(&#13;
                    add(order, 1024),&#13;
                    offset&#13;
                )&#13;
&#13;
                // order.tokenTypeB&#13;
                offset := and(mload(add(tablesPtr, 50)), 0xFFFF)&#13;
                mstore(&#13;
                    add(order, 1056),&#13;
                    offset&#13;
                )&#13;
&#13;
                // order.tokenTypeFee&#13;
                offset := and(mload(add(tablesPtr, 52)), 0xFFFF)&#13;
                mstore(&#13;
                    add(order, 1088),&#13;
                    offset&#13;
                )&#13;
&#13;
                // order.trancheS&#13;
                offset := mul(and(mload(add(tablesPtr, 54)), 0xFFFF), 4)&#13;
                mstore(&#13;
                    add(order, 1120),&#13;
                    mload(add(add(data, 32), offset))&#13;
                )&#13;
&#13;
                // order.trancheB&#13;
                offset := mul(and(mload(add(tablesPtr, 56)), 0xFFFF), 4)&#13;
                mstore(&#13;
                    add(order, 1152),&#13;
                    mload(add(add(data, 32), offset))&#13;
                )&#13;
&#13;
                // Default to empty bytes array for transferDataS&#13;
                mstore(add(data, 32), emptyBytes)&#13;
&#13;
                // order.transferDataS&#13;
                offset := mul(and(mload(add(tablesPtr, 58)), 0xFFFF), 4)&#13;
                mstore(&#13;
                    add(order, 1184),&#13;
                    add(data, add(offset, 32))&#13;
                )&#13;
&#13;
                // Restore default to 0&#13;
                mstore(add(data, 32), 0)&#13;
&#13;
                // Set default  values&#13;
                mstore(add(order, 832), 0)         // order.P2P&#13;
                mstore(add(order, 864), 0)         // order.hash&#13;
                mstore(add(order, 896), 0)         // order.brokerInterceptor&#13;
                mstore(add(order, 928), 0)         // order.filledAmountS&#13;
                mstore(add(order, 960), 0)         // order.initialFilledAmountS&#13;
                mstore(add(order, 992), 1)         // order.valid&#13;
&#13;
                // Advance to the next order&#13;
                tablesPtr := add(tablesPtr, 60)&#13;
            }&#13;
        }&#13;
    }&#13;
&#13;
    function assembleRings(&#13;
        uint data,&#13;
        uint numRings,&#13;
        Data.Order[] memory orders&#13;
        )&#13;
        internal&#13;
        pure&#13;
        returns (Data.Ring[] memory rings)&#13;
    {&#13;
        uint ringsArrayDataSize = (1 + numRings) * 32;&#13;
        uint ringStructSize = 5 * 32;&#13;
        uint participationStructSize = 10 * 32;&#13;
&#13;
        assembly {&#13;
            // Allocate memory for all rings&#13;
            rings := mload(0x40)&#13;
            mstore(add(rings, 0), numRings)                      // rings.length&#13;
            // Reserve the memory for the rings array&#13;
            mstore(0x40, add(rings, add(ringsArrayDataSize, mul(ringStructSize, numRings))))&#13;
&#13;
            for { let r := 0 } lt(r, numRings) { r := add(r, 1) } {&#13;
                let ring := add(rings, add(ringsArrayDataSize, mul(ringStructSize, r)))&#13;
&#13;
                // Store the memory location of this ring in the rings array&#13;
                mstore(add(rings, mul(add(r, 1), 32)), ring)&#13;
&#13;
                // Get the ring size&#13;
                let ringSize := and(mload(data), 0xFF)&#13;
                data := add(data, 1)&#13;
&#13;
                // require(ringsSize &lt;= 8)&#13;
                if gt(ringSize, 8) {&#13;
                    revert(0, 0)&#13;
                }&#13;
&#13;
                // Allocate memory for all participations&#13;
                let participations := mload(0x40)&#13;
                mstore(add(participations, 0), ringSize)         // participations.length&#13;
                // Memory for participations length + ringSize participation pointers&#13;
                let participationsData := add(participations, mul(add(1, ringSize), 32))&#13;
                // Reserve the memory for the participations&#13;
                mstore(0x40, add(participationsData, mul(participationStructSize, ringSize)))&#13;
&#13;
                // Initialize ring properties&#13;
                mstore(add(ring,   0), ringSize)                 // ring.size&#13;
                mstore(add(ring,  32), participations)           // ring.participations&#13;
                mstore(add(ring,  64), 0)                        // ring.hash&#13;
                mstore(add(ring,  96), 0)                        // ring.minerFeesToOrdersPercentage&#13;
                mstore(add(ring, 128), 1)                        // ring.valid&#13;
&#13;
                for { let i := 0 } lt(i, ringSize) { i := add(i, 1) } {&#13;
                    let participation := add(participationsData, mul(participationStructSize, i))&#13;
&#13;
                    // Store the memory location of this participation in the participations array&#13;
                    mstore(add(participations, mul(add(i, 1), 32)), participation)&#13;
&#13;
                    // Get the order index&#13;
                    let orderIndex := and(mload(data), 0xFF)&#13;
                    // require(orderIndex &lt; orders.length)&#13;
                    if iszero(lt(orderIndex, mload(orders))) {&#13;
                        revert(0, 0)&#13;
                    }&#13;
                    data := add(data, 1)&#13;
&#13;
                    // participation.order&#13;
                    mstore(&#13;
                        add(participation,   0),&#13;
                        mload(add(orders, mul(add(orderIndex, 1), 32)))&#13;
                    )&#13;
&#13;
                    // Set default values&#13;
                    mstore(add(participation,  32), 0)          // participation.splitS&#13;
                    mstore(add(participation,  64), 0)          // participation.feeAmount&#13;
                    mstore(add(participation,  96), 0)          // participation.feeAmountS&#13;
                    mstore(add(participation, 128), 0)          // participation.feeAmountB&#13;
                    mstore(add(participation, 160), 0)          // participation.rebateFee&#13;
                    mstore(add(participation, 192), 0)          // participation.rebateS&#13;
                    mstore(add(participation, 224), 0)          // participation.rebateB&#13;
                    mstore(add(participation, 256), 0)          // participation.fillAmountS&#13;
                    mstore(add(participation, 288), 0)          // participation.fillAmountB&#13;
                }&#13;
&#13;
                // Advance to the next ring&#13;
                data := add(data, sub(8, ringSize))&#13;
            }&#13;
        }&#13;
    }&#13;
}&#13;
&#13;
&#13;
&#13;
/// @title An Implementation of IRingSubmitter.&#13;
/// @author Daniel Wang - &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="2f4b4e41464a436f4340405f5d46414801405d48">[email protected]</a>&gt;,&#13;
/// @author Kongliang Zhong - &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="94fffbfaf3f8fdf5faf3d4f8fbfbe4e6fdfaf3bafbe6f3">[email protected]</a>&gt;&#13;
/// @author Brechtpd - &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="14766671777c6054787b7b64667d7a733a7b6673">[email protected]</a>&gt;&#13;
/// Recognized contributing developers from the community:&#13;
///     https://github.com/rainydio&#13;
///     https://github.com/BenjaminPrice&#13;
///     https://github.com/jonasshen&#13;
///     https://github.com/Hephyrius&#13;
contract RingSubmitter is IRingSubmitter, NoDefaultFunc {&#13;
    using MathUint      for uint;&#13;
    using BytesUtil     for bytes;&#13;
    using OrderHelper     for Data.Order;&#13;
    using RingHelper      for Data.Ring;&#13;
    using MiningHelper    for Data.Mining;&#13;
&#13;
    address public constant lrcTokenAddress             = 0xEF68e7C694F40c8202821eDF525dE3782458639f;&#13;
    address public constant wethTokenAddress            = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;&#13;
    address public constant delegateAddress             = 0xb258f5C190faDAB30B5fF0D6ab7E32a646A4BaAe;&#13;
    address public constant tradeHistoryAddress         = 0xBF5a37670B3DE1E606EC68bE3558c536b2008669;&#13;
    address public constant orderBrokerRegistryAddress  = 0x4e1E917F030556788AB3C9d8D0971Ebf0d5439E9;&#13;
    address public constant orderRegistryAddress        = 0x6fb707F15Ab3657Dc52776b057B33cB7D95e4E90;&#13;
    address public constant feeHolderAddress            = 0x5beaEA36efA78F43a6d61145817FDFf6A9929e60;&#13;
    address public constant orderBookAddress            = 0xaC0F8a27012fe8dc5a0bB7f5fc7170934F7e3577;&#13;
    address public constant burnRateTableAddress        = 0x20D90aefBA13F044C5d23c48C3b07e2E43a006DB;&#13;
&#13;
    uint64  public  ringIndex                   = 0;&#13;
&#13;
    uint    public constant MAX_RING_SIZE       = 8;&#13;
&#13;
    struct SubmitRingsParam {&#13;
        uint16[]    encodeSpecs;&#13;
        uint16      miningSpec;&#13;
        uint16[]    orderSpecs;&#13;
        uint8[][]   ringSpecs;&#13;
        address[]   addressList;&#13;
        uint[]      uintList;&#13;
        bytes[]     bytesList;&#13;
    }&#13;
&#13;
    /* constructor( */&#13;
    /*     address _lrcTokenAddress, */&#13;
    /*     address _wethTokenAddress, */&#13;
    /*     address _delegateAddress, */&#13;
    /*     address _tradeHistoryAddress, */&#13;
    /*     address _orderBrokerRegistryAddress, */&#13;
    /*     address _orderRegistryAddress, */&#13;
    /*     address _feeHolderAddress, */&#13;
    /*     address _orderBookAddress, */&#13;
    /*     address _burnRateTableAddress */&#13;
    /*     ) */&#13;
    /*     public */&#13;
    /* { */&#13;
    /*     require(_lrcTokenAddress != address(0x0), ZERO_ADDRESS); */&#13;
    /*     require(_wethTokenAddress != address(0x0), ZERO_ADDRESS); */&#13;
    /*     require(_delegateAddress != address(0x0), ZERO_ADDRESS); */&#13;
    /*     require(_tradeHistoryAddress != address(0x0), ZERO_ADDRESS); */&#13;
    /*     require(_orderBrokerRegistryAddress != address(0x0), ZERO_ADDRESS); */&#13;
    /*     require(_orderRegistryAddress != address(0x0), ZERO_ADDRESS); */&#13;
    /*     require(_feeHolderAddress != address(0x0), ZERO_ADDRESS); */&#13;
    /*     require(_orderBookAddress != address(0x0), ZERO_ADDRESS); */&#13;
    /*     require(_burnRateTableAddress != address(0x0), ZERO_ADDRESS); */&#13;
&#13;
    /*     lrcTokenAddress = _lrcTokenAddress; */&#13;
    /*     wethTokenAddress = _wethTokenAddress; */&#13;
    /*     delegateAddress = _delegateAddress; */&#13;
    /*     tradeHistoryAddress = _tradeHistoryAddress; */&#13;
    /*     orderBrokerRegistryAddress = _orderBrokerRegistryAddress; */&#13;
    /*     orderRegistryAddress = _orderRegistryAddress; */&#13;
    /*     feeHolderAddress = _feeHolderAddress; */&#13;
    /*     orderBookAddress = _orderBookAddress; */&#13;
    /*     burnRateTableAddress = _burnRateTableAddress; */&#13;
    /* } */&#13;
&#13;
    function submitRings(&#13;
        bytes calldata data&#13;
        )&#13;
        external&#13;
    {&#13;
        uint i;&#13;
        bytes32[] memory tokenBurnRates;&#13;
        Data.Context memory ctx = Data.Context(&#13;
            lrcTokenAddress,&#13;
            ITradeDelegate(delegateAddress),&#13;
            ITradeHistory(tradeHistoryAddress),&#13;
            IBrokerRegistry(orderBrokerRegistryAddress),&#13;
            IOrderRegistry(orderRegistryAddress),&#13;
            IFeeHolder(feeHolderAddress),&#13;
            IOrderBook(orderBookAddress),&#13;
            IBurnRateTable(burnRateTableAddress),&#13;
            ringIndex,&#13;
            FEE_PERCENTAGE_BASE,&#13;
            tokenBurnRates,&#13;
            0,&#13;
            0,&#13;
            0,&#13;
            0&#13;
        );&#13;
&#13;
        // Check if the highest bit of ringIndex is '1'&#13;
        require((ctx.ringIndex &gt;&gt; 63) == 0, REENTRY);&#13;
&#13;
        // Set the highest bit of ringIndex to '1' (IN STORAGE!)&#13;
        ringIndex = ctx.ringIndex | (1 &lt;&lt; 63);&#13;
&#13;
        (&#13;
            Data.Mining  memory mining,&#13;
            Data.Order[] memory orders,&#13;
            Data.Ring[]  memory rings&#13;
        ) = ExchangeDeserializer.deserialize(lrcTokenAddress, data);&#13;
&#13;
        // Allocate memory that is used to batch things for all rings&#13;
        setupLists(ctx, orders, rings);&#13;
&#13;
        for (i = 0; i &lt; orders.length; i++) {&#13;
            orders[i].updateHash();&#13;
            orders[i].updateBrokerAndInterceptor(ctx);&#13;
        }&#13;
&#13;
        batchGetFilledAndCheckCancelled(ctx, orders);&#13;
&#13;
        for (i = 0; i &lt; orders.length; i++) {&#13;
            orders[i].check(ctx);&#13;
        }&#13;
&#13;
        for (i = 0; i &lt; rings.length; i++) {&#13;
            rings[i].updateHash();&#13;
        }&#13;
&#13;
        mining.updateHash(rings);&#13;
        mining.updateMinerAndInterceptor();&#13;
        require(mining.checkMinerSignature(), INVALID_SIG);&#13;
&#13;
        for (i = 0; i &lt; orders.length; i++) {&#13;
            // We don't need to verify the dual author signature again if it uses the same&#13;
            // dual author address as the previous order (the miner can optimize the order of the orders&#13;
            // so this happens as much as possible). We don't need to check if the signature is the same&#13;
            // because the same mining hash is signed for all orders.&#13;
            if(i &gt; 0 &amp;&amp; orders[i].dualAuthAddr == orders[i - 1].dualAuthAddr) {&#13;
                continue;&#13;
            }&#13;
            orders[i].checkDualAuthSignature(mining.hash);&#13;
        }&#13;
&#13;
        for (i = 0; i &lt; rings.length; i++) {&#13;
            Data.Ring memory ring = rings[i];&#13;
            ring.checkOrdersValid();&#13;
            ring.checkForSubRings();&#13;
            ring.calculateFillAmountAndFee(ctx);&#13;
            if (ring.valid) {&#13;
                ring.adjustOrderStates();&#13;
            }&#13;
        }&#13;
&#13;
        // Check if the allOrNone orders are completely filled over all rings&#13;
        // This can invalidate rings&#13;
        checkRings(orders, rings);&#13;
&#13;
        for (i = 0; i &lt; rings.length; i++) {&#13;
            Data.Ring memory ring = rings[i];&#13;
            if (ring.valid) {&#13;
                // Only settle rings we have checked to be valid&#13;
                ring.doPayments(ctx, mining);&#13;
                emitRingMinedEvent(&#13;
                    ring,&#13;
                    ctx.ringIndex++,&#13;
                    mining.feeRecipient&#13;
                );&#13;
            } else {&#13;
                emit InvalidRing(ring.hash);&#13;
            }&#13;
        }&#13;
&#13;
        // Do all token transfers for all rings&#13;
        batchTransferTokens(ctx);&#13;
        // Do all fee payments for all rings&#13;
        batchPayFees(ctx);&#13;
        // Update all order stats&#13;
        updateOrdersStats(ctx, orders);&#13;
&#13;
        // Update ringIndex while setting the highest bit of ringIndex back to '0'&#13;
        ringIndex = ctx.ringIndex;&#13;
    }&#13;
&#13;
    function checkRings(&#13;
        Data.Order[] memory orders,&#13;
        Data.Ring[] memory rings&#13;
        )&#13;
        internal&#13;
        pure&#13;
    {&#13;
        // Check if allOrNone orders are completely filled&#13;
        // When a ring is turned invalid because of an allOrNone order we have to&#13;
        // recheck the other rings again because they may contain other allOrNone orders&#13;
        // that may not be completely filled anymore.&#13;
        bool reevaluateRings = true;&#13;
        while (reevaluateRings) {&#13;
            reevaluateRings = false;&#13;
            for (uint i = 0; i &lt; orders.length; i++) {&#13;
                if (orders[i].valid) {&#13;
                    orders[i].validateAllOrNone();&#13;
                    // Check if the order valid status has changed&#13;
                    reevaluateRings = reevaluateRings || !orders[i].valid;&#13;
                }&#13;
            }&#13;
            if (reevaluateRings) {&#13;
                for (uint i = 0; i &lt; rings.length; i++) {&#13;
                    Data.Ring memory ring = rings[i];&#13;
                    if (ring.valid) {&#13;
                        ring.checkOrdersValid();&#13;
                        if (!ring.valid) {&#13;
                            // If the ring was valid before the completely filled check we have to revert the filled amountS&#13;
                            // of the orders in the ring. This is a bit awkward so maybe there's a better solution.&#13;
                            ring.revertOrderStats();&#13;
                        }&#13;
                    }&#13;
                }&#13;
            }&#13;
        }&#13;
    }&#13;
&#13;
    function emitRingMinedEvent(&#13;
        Data.Ring memory ring,&#13;
        uint _ringIndex,&#13;
        address feeRecipient&#13;
        )&#13;
        internal&#13;
    {&#13;
        bytes32 ringHash = ring.hash;&#13;
        // keccak256("RingMined(uint256,bytes32,address,bytes)")&#13;
        bytes32 ringMinedSignature = 0xb2ef4bc5209dff0c46d5dfddb2b68a23bd4820e8f33107fde76ed15ba90695c9;&#13;
        uint fillsSize = ring.size * 8 * 32;&#13;
&#13;
        uint data;&#13;
        uint ptr;&#13;
        assembly {&#13;
            data := mload(0x40)&#13;
            ptr := data&#13;
            mstore(ptr, _ringIndex)                     // ring index data&#13;
            mstore(add(ptr, 32), 0x40)                  // offset to fills data&#13;
            mstore(add(ptr, 64), fillsSize)             // fills length&#13;
            ptr := add(ptr, 96)&#13;
        }&#13;
        ptr = ring.generateFills(ptr);&#13;
&#13;
        assembly {&#13;
            log3(&#13;
                data,                                   // data start&#13;
                sub(ptr, data),                         // data length&#13;
                ringMinedSignature,                     // Topic 0: RingMined signature&#13;
                ringHash,                               // Topic 1: ring hash&#13;
                feeRecipient                            // Topic 2: feeRecipient&#13;
            )&#13;
        }&#13;
    }&#13;
&#13;
    function setupLists(&#13;
        Data.Context memory ctx,&#13;
        Data.Order[] memory orders,&#13;
        Data.Ring[] memory rings&#13;
        )&#13;
        internal&#13;
        pure&#13;
    {&#13;
        setupTokenBurnRateList(ctx, orders);&#13;
        setupFeePaymentList(ctx, rings);&#13;
        setupTokenTransferList(ctx, rings);&#13;
    }&#13;
&#13;
    function setupTokenBurnRateList(&#13;
        Data.Context memory ctx,&#13;
        Data.Order[] memory orders&#13;
        )&#13;
        internal&#13;
        pure&#13;
    {&#13;
        // Allocate enough memory to store burn rates for all tokens even&#13;
        // if every token is unique (max 2 unique tokens / order)&#13;
        uint maxNumTokenBurnRates = orders.length * 2;&#13;
        bytes32[] memory tokenBurnRates;&#13;
        assembly {&#13;
            tokenBurnRates := mload(0x40)&#13;
            mstore(tokenBurnRates, 0)                               // tokenBurnRates.length&#13;
            mstore(0x40, add(&#13;
                tokenBurnRates,&#13;
                add(32, mul(maxNumTokenBurnRates, 64))&#13;
            ))&#13;
        }&#13;
        ctx.tokenBurnRates = tokenBurnRates;&#13;
    }&#13;
&#13;
    function setupFeePaymentList(&#13;
        Data.Context memory ctx,&#13;
        Data.Ring[] memory rings&#13;
        )&#13;
        internal&#13;
        pure&#13;
    {&#13;
        uint totalMaxSizeFeePayments = 0;&#13;
        for (uint i = 0; i &lt; rings.length; i++) {&#13;
            // Up to (ringSize + 3) * 3 payments per order (because of fee sharing by miner)&#13;
            // (3 x 32 bytes for every fee payment)&#13;
            uint ringSize = rings[i].size;&#13;
            uint maxSize = (ringSize + 3) * 3 * ringSize * 3;&#13;
            totalMaxSizeFeePayments += maxSize;&#13;
        }&#13;
        // Store the data directly in the call data format as expected by batchAddFeeBalances:&#13;
        // - 0x00: batchAddFeeBalances selector (4 bytes)&#13;
        // - 0x04: parameter offset (batchAddFeeBalances has a single function parameter) (32 bytes)&#13;
        // - 0x24: length of the array passed into the function (32 bytes)&#13;
        // - 0x44: the array data (32 bytes x length)&#13;
        bytes4 batchAddFeeBalancesSelector = ctx.feeHolder.batchAddFeeBalances.selector;&#13;
        uint ptr;&#13;
        assembly {&#13;
            let data := mload(0x40)&#13;
            mstore(data, batchAddFeeBalancesSelector)&#13;
            mstore(add(data, 4), 32)&#13;
            ptr := add(data, 68)&#13;
            mstore(0x40, add(ptr, mul(totalMaxSizeFeePayments, 32)))&#13;
        }&#13;
        ctx.feeData = ptr;&#13;
        ctx.feePtr = ptr;&#13;
    }&#13;
&#13;
    function setupTokenTransferList(&#13;
        Data.Context memory ctx,&#13;
        Data.Ring[] memory rings&#13;
        )&#13;
        internal&#13;
        pure&#13;
    {&#13;
        uint totalMaxSizeTransfers = 0;&#13;
        for (uint i = 0; i &lt; rings.length; i++) {&#13;
            // Up to 4 transfers per order&#13;
            // (4 x 32 bytes for every transfer)&#13;
            uint maxSize = 4 * rings[i].size * 4;&#13;
            totalMaxSizeTransfers += maxSize;&#13;
        }&#13;
        // Store the data directly in the call data format as expected by batchTransfer:&#13;
        // - 0x00: batchTransfer selector (4 bytes)&#13;
        // - 0x04: parameter offset (batchTransfer has a single function parameter) (32 bytes)&#13;
        // - 0x24: length of the array passed into the function (32 bytes)&#13;
        // - 0x44: the array data (32 bytes x length)&#13;
        bytes4 batchTransferSelector = ctx.delegate.batchTransfer.selector;&#13;
        uint ptr;&#13;
        assembly {&#13;
            let data := mload(0x40)&#13;
            mstore(data, batchTransferSelector)&#13;
            mstore(add(data, 4), 32)&#13;
            ptr := add(data, 68)&#13;
            mstore(0x40, add(ptr, mul(totalMaxSizeTransfers, 32)))&#13;
        }&#13;
        ctx.transferData = ptr;&#13;
        ctx.transferPtr = ptr;&#13;
    }&#13;
&#13;
    function updateOrdersStats(&#13;
        Data.Context memory ctx,&#13;
        Data.Order[] memory orders&#13;
        )&#13;
        internal&#13;
    {&#13;
        // Store the data directly in the call data format as expected by batchUpdateFilled:&#13;
        // - 0x00: batchUpdateFilled selector (4 bytes)&#13;
        // - 0x04: parameter offset (batchUpdateFilled has a single function parameter) (32 bytes)&#13;
        // - 0x24: length of the array passed into the function (32 bytes)&#13;
        // - 0x44: the array data (32 bytes x length)&#13;
        // For every (valid) order we store 2 words:&#13;
        // - order.hash&#13;
        // - order.filledAmountS after all rings&#13;
        bytes4 batchUpdateFilledSelector = ctx.tradeHistory.batchUpdateFilled.selector;&#13;
        address _tradeHistoryAddress = address(ctx.tradeHistory);&#13;
        assembly {&#13;
            let data := mload(0x40)&#13;
            mstore(data, batchUpdateFilledSelector)&#13;
            mstore(add(data, 4), 32)&#13;
            let ptr := add(data, 68)&#13;
            let arrayLength := 0&#13;
            for { let i := 0 } lt(i, mload(orders)) { i := add(i, 1) } {&#13;
                let order := mload(add(orders, mul(add(i, 1), 32)))&#13;
                let filledAmount := mload(add(order, 928))                               // order.filledAmountS&#13;
                let initialFilledAmount := mload(add(order, 960))                        // order.initialFilledAmountS&#13;
                let filledAmountChanged := iszero(eq(filledAmount, initialFilledAmount))&#13;
                // if (order.valid &amp;&amp; filledAmountChanged)&#13;
                if and(gt(mload(add(order, 992)), 0), filledAmountChanged) {             // order.valid&#13;
                    mstore(add(ptr,   0), mload(add(order, 864)))                        // order.hash&#13;
                    mstore(add(ptr,  32), filledAmount)&#13;
&#13;
                    ptr := add(ptr, 64)&#13;
                    arrayLength := add(arrayLength, 2)&#13;
                }&#13;
            }&#13;
&#13;
            // Only do the external call if the list is not empty&#13;
            if gt(arrayLength, 0) {&#13;
                mstore(add(data, 36), arrayLength)      // filledInfo.length&#13;
&#13;
                let success := call(&#13;
                    gas,                                // forward all gas&#13;
                    _tradeHistoryAddress,               // external address&#13;
                    0,                                  // wei&#13;
                    data,                               // input start&#13;
                    sub(ptr, data),                     // input length&#13;
                    data,                               // output start&#13;
                    0                                   // output length&#13;
                )&#13;
                if eq(success, 0) {&#13;
                    // Propagate the revert message&#13;
                    returndatacopy(0, 0, returndatasize())&#13;
                    revert(0, returndatasize())&#13;
                }&#13;
            }&#13;
        }&#13;
    }&#13;
&#13;
    function batchGetFilledAndCheckCancelled(&#13;
        Data.Context memory ctx,&#13;
        Data.Order[] memory orders&#13;
        )&#13;
        internal&#13;
    {&#13;
        // Store the data in the call data format as expected by batchGetFilledAndCheckCancelled:&#13;
        // - 0x00: batchGetFilledAndCheckCancelled selector (4 bytes)&#13;
        // - 0x04: parameter offset (batchGetFilledAndCheckCancelled has a single function parameter) (32 bytes)&#13;
        // - 0x24: length of the array passed into the function (32 bytes)&#13;
        // - 0x44: the array data (32 bytes x length)&#13;
        // For every order we store 5 words:&#13;
        // - order.broker&#13;
        // - order.owner&#13;
        // - order.hash&#13;
        // - order.validSince&#13;
        // - The trading pair of the order: order.tokenS ^ order.tokenB&#13;
        bytes4 batchGetFilledAndCheckCancelledSelector = ctx.tradeHistory.batchGetFilledAndCheckCancelled.selector;&#13;
        address _tradeHistoryAddress = address(ctx.tradeHistory);&#13;
        assembly {&#13;
            let data := mload(0x40)&#13;
            mstore(data, batchGetFilledAndCheckCancelledSelector)&#13;
            mstore(add(data,  4), 32)&#13;
            mstore(add(data, 36), mul(mload(orders), 5))                // orders.length&#13;
            let ptr := add(data, 68)&#13;
            for { let i := 0 } lt(i, mload(orders)) { i := add(i, 1) } {&#13;
                let order := mload(add(orders, mul(add(i, 1), 32)))     // orders[i]&#13;
                mstore(add(ptr,   0), mload(add(order, 320)))           // order.broker&#13;
                mstore(add(ptr,  32), mload(add(order,  32)))           // order.owner&#13;
                mstore(add(ptr,  64), mload(add(order, 864)))           // order.hash&#13;
                mstore(add(ptr,  96), mload(add(order, 192)))           // order.validSince&#13;
                // bytes20(order.tokenS) ^ bytes20(order.tokenB)        // tradingPair&#13;
                mstore(add(ptr, 128), mul(&#13;
                    xor(&#13;
                        mload(add(order, 64)),                 // order.tokenS&#13;
                        mload(add(order, 96))                  // order.tokenB&#13;
                    ),&#13;
                    0x1000000000000000000000000)               // shift left 12 bytes (bytes20 is padded on the right)&#13;
                )&#13;
                ptr := add(ptr, 160)                                    // 5 * 32&#13;
            }&#13;
            // Return data is stored just like the call data without the signature:&#13;
            // 0x00: Offset to data&#13;
            // 0x20: Array length&#13;
            // 0x40: Array data&#13;
            let returnDataSize := mul(add(2, mload(orders)), 32)&#13;
            let success := call(&#13;
                gas,                                // forward all gas&#13;
                _tradeHistoryAddress,               // external address&#13;
                0,                                  // wei&#13;
                data,                               // input start&#13;
                sub(ptr, data),                     // input length&#13;
                data,                               // output start&#13;
                returnDataSize                      // output length&#13;
            )&#13;
            // Check if the call was successful and the return data is the expected size&#13;
            if or(eq(success, 0), iszero(eq(returndatasize(), returnDataSize))) {&#13;
                if eq(success, 0) {&#13;
                    // Propagate the revert message&#13;
                    returndatacopy(0, 0, returndatasize())&#13;
                    revert(0, returndatasize())&#13;
                }&#13;
                revert(0, 0)&#13;
            }&#13;
            for { let i := 0 } lt(i, mload(orders)) { i := add(i, 1) } {&#13;
                let order := mload(add(orders, mul(add(i, 1), 32)))     // orders[i]&#13;
                let fill := mload(add(data,  mul(add(i, 2), 32)))       // fills[i]&#13;
                mstore(add(order, 928), fill)                           // order.filledAmountS&#13;
                mstore(add(order, 960), fill)                           // order.initialFilledAmountS&#13;
                // If fills[i] == ~uint(0) the order was cancelled&#13;
                // order.valid = order.valid &amp;&amp; (order.filledAmountS != ~uint(0))&#13;
                mstore(add(order, 992),                                 // order.valid&#13;
                    and(&#13;
                        gt(mload(add(order, 992)), 0),                  // order.valid&#13;
                        iszero(eq(fill, not(0)))                        // fill != ~uint(0&#13;
                    )&#13;
                )&#13;
            }&#13;
        }&#13;
    }&#13;
&#13;
    function batchTransferTokens(&#13;
        Data.Context memory ctx&#13;
        )&#13;
        internal&#13;
    {&#13;
        // Check if there are any transfers&#13;
        if (ctx.transferData == ctx.transferPtr) {&#13;
            return;&#13;
        }&#13;
        // We stored the token transfers in the call data as expected by batchTransfer.&#13;
        // The only thing we still need to do is update the final length of the array and call&#13;
        // the function on the TradeDelegate contract with the generated data.&#13;
        address _tradeDelegateAddress = address(ctx.delegate);&#13;
        uint arrayLength = (ctx.transferPtr - ctx.transferData) / 32;&#13;
        uint data = ctx.transferData - 68;&#13;
        uint ptr = ctx.transferPtr;&#13;
        assembly {&#13;
            mstore(add(data, 36), arrayLength)      // batch.length&#13;
&#13;
            let success := call(&#13;
                gas,                                // forward all gas&#13;
                _tradeDelegateAddress,              // external address&#13;
                0,                                  // wei&#13;
                data,                               // input start&#13;
                sub(ptr, data),                     // input length&#13;
                data,                               // output start&#13;
                0                                   // output length&#13;
            )&#13;
            if eq(success, 0) {&#13;
                // Propagate the revert message&#13;
                returndatacopy(0, 0, returndatasize())&#13;
                revert(0, returndatasize())&#13;
            }&#13;
        }&#13;
    }&#13;
&#13;
    function batchPayFees(&#13;
        Data.Context memory ctx&#13;
        )&#13;
        internal&#13;
    {&#13;
        // Check if there are any fee payments&#13;
        if (ctx.feeData == ctx.feePtr) {&#13;
            return;&#13;
        }&#13;
        // We stored the fee payments in the call data as expected by batchAddFeeBalances.&#13;
        // The only thing we still need to do is update the final length of the array and call&#13;
        // the function on the FeeHolder contract with the generated data.&#13;
        address _feeHolderAddress = address(ctx.feeHolder);&#13;
        uint arrayLength = (ctx.feePtr - ctx.feeData) / 32;&#13;
        uint data = ctx.feeData - 68;&#13;
        uint ptr = ctx.feePtr;&#13;
        assembly {&#13;
            mstore(add(data, 36), arrayLength)      // batch.length&#13;
&#13;
            let success := call(&#13;
                gas,                                // forward all gas&#13;
                _feeHolderAddress,                  // external address&#13;
                0,                                  // wei&#13;
                data,                               // input start&#13;
                sub(ptr, data),                     // input length&#13;
                data,                               // output start&#13;
                0                                   // output length&#13;
            )&#13;
            if eq(success, 0) {&#13;
                // Propagate the revert message&#13;
                returndatacopy(0, 0, returndatasize())&#13;
                revert(0, returndatasize())&#13;
            }&#13;
        }&#13;
    }&#13;
&#13;
}