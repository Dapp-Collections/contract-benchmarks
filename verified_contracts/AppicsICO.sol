// Appics tokensale smart contract.
// Developed by Phenom.Team <<span class="__cf_email__" data-cfemail="71181f171e310119141f1e1c5f0514101c">[emailÂ protected]</span>&gt;&#13;
&#13;
pragma solidity ^ 0.4.15;&#13;
&#13;
/**&#13;
 *   @title SafeMath&#13;
 *   @dev Math operations with safety checks that throw on error&#13;
 */&#13;
library SafeMath {&#13;
    function mul(uint256 a, uint256 b) internal constant returns (uint256) {&#13;
        uint256 c = a * b;&#13;
        assert(a == 0 || c / a == b);&#13;
        return c;&#13;
    }&#13;
&#13;
    function div(uint256 a, uint256 b) internal constant returns(uint256) {&#13;
        assert(b &gt; 0);&#13;
        uint256 c = a / b;&#13;
        assert(a == b * c + a % b);&#13;
        return c;&#13;
    }&#13;
&#13;
    function sub(uint256 a, uint256 b) internal constant returns(uint256) {&#13;
        assert(b &lt;= a);&#13;
        return a - b;&#13;
    }&#13;
&#13;
    function add(uint256 a, uint256 b) internal constant returns(uint256) {&#13;
        uint256 c = a + b;&#13;
        assert(c &gt;= a);&#13;
        return c;&#13;
    }&#13;
}&#13;
&#13;
&#13;
/**&#13;
 *   @title ERC20&#13;
 *   @dev Standart ERC20 token interface&#13;
 */&#13;
contract ERC20 {&#13;
    uint256 public totalSupply = 0;&#13;
    mapping(address =&gt; uint256) balances;&#13;
    mapping(address =&gt; mapping(address =&gt; uint256)) allowed;&#13;
    function balanceOf(address _owner) public constant returns(uint256);&#13;
    function transfer(address _to, uint256 _value) public returns(bool);&#13;
    function transferFrom(address _from, address _to, uint256 _value) public returns(bool);&#13;
    function approve(address _spender, uint256 _value) public returns(bool);&#13;
    function allowance(address _owner, address _spender) public constant returns(uint256);&#13;
    event Transfer(address indexed _from, address indexed _to, uint256 _value);&#13;
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);&#13;
}&#13;
&#13;
/**&#13;
*   @title AppicsICO contract  - takes funds from users and issues tokens&#13;
*/&#13;
contract AppicsICO {&#13;
    // XAP - Appics token contract&#13;
    AppicsToken public XAP = new AppicsToken(this);&#13;
    using SafeMath for uint256;&#13;
    mapping (address =&gt; string) public  keys;&#13;
&#13;
    // Token price parameters&#13;
    // These parametes can be changed only by manager of contract&#13;
    uint256 public Rate_Eth = 700; // Rate USD per ETH&#13;
    uint256 public Tokens_Per_Dollar_Numerator = 20;// Appics token = 0.15$&#13;
    uint256 public Tokens_Per_Dollar_Denominator = 3;// Appics token = 0.15$&#13;
    &#13;
    // Crowdfunding parameters&#13;
    uint256 constant AppicsPart = 20; // 20% of TotalSupply for Appics&#13;
    uint256 constant EcosystemPart = 20; // 20% of TotalSupply for Ecosystem&#13;
    uint256 constant SteemitPart = 5; // 5% of TotalSupply for Steemit&#13;
    uint256 constant BountyPart = 5; // 5% of TotalSupply for Bounty&#13;
    uint256 constant icoPart = 50; // 50% of TotalSupply for PublicICO and PrivateOffer&#13;
    uint256 constant PreSaleHardCap = 12500000*1e18;&#13;
    uint256 constant RoundAHardCap = 25000000*1e18;&#13;
    uint256 constant RoundBHardCap = 30000000*1e18;&#13;
    uint256 constant RoundCHardCap = 30000000*1e18;&#13;
    uint256 constant RoundDHardCap = 22500000*1e18;&#13;
    uint256 public PreSaleSold = 0;&#13;
    uint256 public RoundASold = 0;&#13;
    uint256 public RoundBSold = 0;&#13;
    uint256 public RoundCSold = 0;&#13;
    uint256 public RoundDSold = 0;        &#13;
    uint256 constant TENTHOUSENDLIMIT = 66666666666666666666666;&#13;
    // Output ethereum addresses&#13;
    address public Company;&#13;
    address public AppicsFund;&#13;
    address public EcosystemFund;&#13;
    address public SteemitFund;&#13;
    address public BountyFund;&#13;
    address public Manager; // Manager controls contract&#13;
    address public Controller_Address1; // First address that is used to buy tokens for other cryptos&#13;
    address public Controller_Address2; // Second address that is used to buy tokens for other cryptos&#13;
    address public Controller_Address3; // Third address that is used to buy tokens for other cryptos&#13;
    address public Oracle; // Oracle address&#13;
&#13;
    // Possible ICO statuses&#13;
    enum StatusICO {&#13;
        Created,&#13;
        PreSaleStarted,&#13;
        PreSalePaused,&#13;
        PreSaleFinished,&#13;
        RoundAStarted,&#13;
        RoundAPaused,&#13;
        RoundAFinished,&#13;
        RoundBStarted,&#13;
        RoundBPaused,&#13;
        RoundBFinished,&#13;
        RoundCStarted,&#13;
        RoundCPaused,&#13;
        RoundCFinished,&#13;
        RoundDStarted,&#13;
        RoundDPaused,&#13;
        RoundDFinished&#13;
    }&#13;
&#13;
    StatusICO statusICO = StatusICO.Created;&#13;
&#13;
    // Events Log&#13;
    event LogStartPreSaleRound();&#13;
    event LogPausePreSaleRound();&#13;
    event LogFinishPreSaleRound(&#13;
        address AppicsFund, &#13;
        address EcosystemFund,&#13;
        address SteemitFund,&#13;
        address BountyFund&#13;
    );&#13;
    event LogStartRoundA();&#13;
    event LogPauseRoundA();&#13;
    event LogFinishRoundA(&#13;
        address AppicsFund, &#13;
        address EcosystemFund,&#13;
        address SteemitFund,&#13;
        address BountyFund&#13;
    );&#13;
    event LogStartRoundB();&#13;
    event LogPauseRoundB();&#13;
    event LogFinishRoundB(&#13;
        address AppicsFund, &#13;
        address EcosystemFund,&#13;
        address SteemitFund,&#13;
        address BountyFund&#13;
    );&#13;
    event LogStartRoundC();&#13;
    event LogPauseRoundC();&#13;
    event LogFinishRoundC(&#13;
        address AppicsFund, &#13;
        address EcosystemFund,&#13;
        address SteemitFund,&#13;
        address BountyFund&#13;
    );&#13;
    event LogStartRoundD();&#13;
    event LogPauseRoundD();&#13;
    event LogFinishRoundD(&#13;
        address AppicsFund, &#13;
        address EcosystemFund,&#13;
        address SteemitFund,&#13;
        address BountyFund&#13;
    );&#13;
    event LogBuyForInvestor(address investor, uint256 aidValue, string txHash);&#13;
    event LogRegister(address investor, string key);&#13;
&#13;
    // Modifiers&#13;
    // Allows execution by the oracle only&#13;
    modifier oracleOnly {&#13;
        require(msg.sender == Oracle);&#13;
        _;&#13;
    }&#13;
    // Allows execution by the contract manager only&#13;
    modifier managerOnly {&#13;
        require(msg.sender == Manager);&#13;
        _;&#13;
    }&#13;
    // Allows execution by the one of controllers only&#13;
    modifier controllersOnly {&#13;
        require(&#13;
            (msg.sender == Controller_Address1) || &#13;
            (msg.sender == Controller_Address2) || &#13;
            (msg.sender == Controller_Address3)&#13;
        );&#13;
        _;&#13;
    }&#13;
    // Allows execution if the any round started only&#13;
    modifier startedOnly {&#13;
        require(&#13;
            (statusICO == StatusICO.PreSaleStarted) || &#13;
            (statusICO == StatusICO.RoundAStarted) || &#13;
            (statusICO == StatusICO.RoundBStarted) ||&#13;
            (statusICO == StatusICO.RoundCStarted) ||&#13;
            (statusICO == StatusICO.RoundDStarted)&#13;
        );&#13;
        _;&#13;
    }&#13;
    // Allows execution if the any round finished only&#13;
    modifier finishedOnly {&#13;
        require(&#13;
            (statusICO == StatusICO.PreSaleFinished) || &#13;
            (statusICO == StatusICO.RoundAFinished) || &#13;
            (statusICO == StatusICO.RoundBFinished) ||&#13;
            (statusICO == StatusICO.RoundCFinished) ||&#13;
            (statusICO == StatusICO.RoundDFinished)&#13;
        );&#13;
        _;&#13;
    }&#13;
&#13;
&#13;
   /**&#13;
    *   @dev Contract constructor function&#13;
    */&#13;
    function AppicsICO(&#13;
        address _Company,&#13;
        address _AppicsFund,&#13;
        address _EcosystemFund,&#13;
        address _SteemitFund,&#13;
        address _BountyFund,&#13;
        address _Manager,&#13;
        address _Controller_Address1,&#13;
        address _Controller_Address2,&#13;
        address _Controller_Address3,&#13;
        address _Oracle&#13;
    )&#13;
        public {&#13;
        Company = _Company;&#13;
        AppicsFund = _AppicsFund;&#13;
        EcosystemFund = _EcosystemFund;&#13;
        SteemitFund = _SteemitFund;&#13;
        BountyFund = _BountyFund;&#13;
        Manager = _Manager;&#13;
        Controller_Address1 = _Controller_Address1;&#13;
        Controller_Address2 = _Controller_Address2;&#13;
        Controller_Address3 = _Controller_Address3;&#13;
        Oracle = _Oracle;&#13;
    }&#13;
&#13;
   /**&#13;
    *   @dev Set rate of ETH and update token price&#13;
    *   @param _RateEth       current ETH rate&#13;
    */&#13;
    function setRate(uint256 _RateEth) external oracleOnly {&#13;
        Rate_Eth = _RateEth;&#13;
    }&#13;
&#13;
   /**&#13;
    *   @dev Start Pre-Sale&#13;
    *   Set ICO status to PreSaleStarted&#13;
    */&#13;
    function startPreSaleRound() external managerOnly {&#13;
        require(statusICO == StatusICO.Created || statusICO == StatusICO.PreSalePaused);&#13;
        statusICO = StatusICO.PreSaleStarted;&#13;
        LogStartPreSaleRound();&#13;
    }&#13;
&#13;
   /**&#13;
    *   @dev Pause Pre-Sale&#13;
    *   Set Ico status to PreSalePaused&#13;
    */&#13;
    function pausePreSaleRound() external managerOnly {&#13;
        require(statusICO == StatusICO.PreSaleStarted);&#13;
        statusICO = StatusICO.PreSalePaused;&#13;
        LogPausePreSaleRound();&#13;
    }&#13;
&#13;
&#13;
   /**&#13;
    *   @dev Finish Pre-Sale and mint tokens for AppicsFund, EcosystemFund, SteemitFund,&#13;
        RewardFund and ReferralFund&#13;
    *   Set Ico status to PreSaleFinished&#13;
    */&#13;
    function finishPreSaleRound() external managerOnly {&#13;
        require(statusICO == StatusICO.PreSaleStarted || statusICO == StatusICO.PreSalePaused);&#13;
        uint256 totalAmount = PreSaleSold.mul(100).div(icoPart);&#13;
        XAP.mintTokens(AppicsFund, AppicsPart.mul(totalAmount).div(100));&#13;
        XAP.mintTokens(EcosystemFund, EcosystemPart.mul(totalAmount).div(100));&#13;
        XAP.mintTokens(SteemitFund, SteemitPart.mul(totalAmount).div(100));&#13;
        XAP.mintTokens(BountyFund, BountyPart.mul(totalAmount).div(100));&#13;
        statusICO = StatusICO.PreSaleFinished;&#13;
        LogFinishPreSaleRound(AppicsFund, EcosystemFund, SteemitFund, BountyFund);&#13;
&#13;
    }&#13;
   &#13;
   /**&#13;
    *   @dev Start Round A&#13;
    *   Set ICO status to RoundAStarted&#13;
    */&#13;
    function startRoundA() external managerOnly {&#13;
        require(statusICO == StatusICO.PreSaleFinished || statusICO == StatusICO.RoundAPaused);&#13;
        statusICO = StatusICO.RoundAStarted;&#13;
        LogStartRoundA();&#13;
    }&#13;
&#13;
   /**&#13;
    *   @dev Pause Round A&#13;
    *   Set Ico status to RoundAPaused&#13;
    */&#13;
    function pauseRoundA() external managerOnly {&#13;
        require(statusICO == StatusICO.RoundAStarted);&#13;
        statusICO = StatusICO.RoundAPaused;&#13;
        LogPauseRoundA();&#13;
    }&#13;
&#13;
&#13;
   /**&#13;
    *   @dev Finish Round A and mint tokens AppicsFund, EcosystemFund, SteemitFund,&#13;
        RewardFund and ReferralFund&#13;
    *   Set Ico status to RoundAFinished&#13;
    */&#13;
    function finishRoundA() external managerOnly {&#13;
        require(statusICO == StatusICO.RoundAStarted || statusICO == StatusICO.RoundAPaused);&#13;
        uint256 totalAmount = RoundASold.mul(100).div(icoPart);&#13;
        XAP.mintTokens(AppicsFund, AppicsPart.mul(totalAmount).div(100));&#13;
        XAP.mintTokens(EcosystemFund, EcosystemPart.mul(totalAmount).div(100));&#13;
        XAP.mintTokens(SteemitFund, SteemitPart.mul(totalAmount).div(100));&#13;
        XAP.mintTokens(BountyFund, BountyPart.mul(totalAmount).div(100));&#13;
        statusICO = StatusICO.RoundAFinished;&#13;
        LogFinishRoundA(AppicsFund, EcosystemFund, SteemitFund, BountyFund);&#13;
    }&#13;
&#13;
   /**&#13;
    *   @dev Start Round B&#13;
    *   Set ICO status to RoundBStarted&#13;
    */&#13;
    function startRoundB() external managerOnly {&#13;
        require(statusICO == StatusICO.RoundAFinished || statusICO == StatusICO.RoundBPaused);&#13;
        statusICO = StatusICO.RoundBStarted;&#13;
        LogStartRoundB();&#13;
    }&#13;
&#13;
   /**&#13;
    *   @dev Pause Round B&#13;
    *   Set Ico status to RoundBPaused&#13;
    */&#13;
    function pauseRoundB() external managerOnly {&#13;
        require(statusICO == StatusICO.RoundBStarted);&#13;
        statusICO = StatusICO.RoundBPaused;&#13;
        LogPauseRoundB();&#13;
    }&#13;
&#13;
&#13;
   /**&#13;
    *   @dev Finish Round B and mint tokens AppicsFund, EcosystemFund, SteemitFund,&#13;
        RewardFund and ReferralFund&#13;
    *   Set Ico status to RoundBFinished&#13;
    */&#13;
    function finishRoundB() external managerOnly {&#13;
        require(statusICO == StatusICO.RoundBStarted || statusICO == StatusICO.RoundBPaused);&#13;
        uint256 totalAmount = RoundBSold.mul(100).div(icoPart);&#13;
        XAP.mintTokens(AppicsFund, AppicsPart.mul(totalAmount).div(100));&#13;
        XAP.mintTokens(EcosystemFund, EcosystemPart.mul(totalAmount).div(100));&#13;
        XAP.mintTokens(SteemitFund, SteemitPart.mul(totalAmount).div(100));&#13;
        XAP.mintTokens(BountyFund, BountyPart.mul(totalAmount).div(100));&#13;
        statusICO = StatusICO.RoundBFinished;&#13;
        LogFinishRoundB(AppicsFund, EcosystemFund, SteemitFund, BountyFund);&#13;
    }&#13;
&#13;
   /**&#13;
    *   @dev Start Round C&#13;
    *   Set ICO status to RoundCStarted&#13;
    */&#13;
    function startRoundC() external managerOnly {&#13;
        require(statusICO == StatusICO.RoundBFinished || statusICO == StatusICO.RoundCPaused);&#13;
        statusICO = StatusICO.RoundCStarted;&#13;
        LogStartRoundC();&#13;
    }&#13;
&#13;
   /**&#13;
    *   @dev Pause Round C&#13;
    *   Set Ico status to RoundCPaused&#13;
    */&#13;
    function pauseRoundC() external managerOnly {&#13;
        require(statusICO == StatusICO.RoundCStarted);&#13;
        statusICO = StatusICO.RoundCPaused;&#13;
        LogPauseRoundC();&#13;
    }&#13;
&#13;
&#13;
   /**&#13;
    *   @dev Finish Round C and mint tokens AppicsFund, EcosystemFund, SteemitFund,&#13;
        RewardFund and ReferralFund&#13;
    *   Set Ico status to RoundCStarted&#13;
    */&#13;
    function finishRoundC() external managerOnly {&#13;
        require(statusICO == StatusICO.RoundCStarted || statusICO == StatusICO.RoundCPaused);&#13;
        uint256 totalAmount = RoundCSold.mul(100).div(icoPart);&#13;
        XAP.mintTokens(AppicsFund, AppicsPart.mul(totalAmount).div(100));&#13;
        XAP.mintTokens(EcosystemFund, EcosystemPart.mul(totalAmount).div(100));&#13;
        XAP.mintTokens(SteemitFund, SteemitPart.mul(totalAmount).div(100));&#13;
        XAP.mintTokens(BountyFund, BountyPart.mul(totalAmount).div(100));&#13;
        statusICO = StatusICO.RoundCFinished;&#13;
        LogFinishRoundC(AppicsFund, EcosystemFund, SteemitFund, BountyFund);&#13;
    }&#13;
&#13;
   /**&#13;
    *   @dev Start Round D&#13;
    *   Set ICO status to RoundDStarted&#13;
    */&#13;
    function startRoundD() external managerOnly {&#13;
        require(statusICO == StatusICO.RoundCFinished || statusICO == StatusICO.RoundDPaused);&#13;
        statusICO = StatusICO.RoundDStarted;&#13;
        LogStartRoundD();&#13;
    }&#13;
&#13;
   /**&#13;
    *   @dev Pause Round D&#13;
    *   Set Ico status to RoundDPaused&#13;
    */&#13;
    function pauseRoundD() external managerOnly {&#13;
        require(statusICO == StatusICO.RoundDStarted);&#13;
        statusICO = StatusICO.RoundDPaused;&#13;
        LogPauseRoundD();&#13;
    }&#13;
&#13;
&#13;
   /**&#13;
    *   @dev Finish Round D and mint tokens AppicsFund, EcosystemFund, SteemitFund,&#13;
        RewardFund and ReferralFund&#13;
    *   Set Ico status to RoundDFinished&#13;
    */&#13;
    function finishRoundD() external managerOnly {&#13;
        require(statusICO == StatusICO.RoundDStarted || statusICO == StatusICO.RoundDPaused);&#13;
        uint256 totalAmount = RoundDSold.mul(100).div(icoPart);&#13;
        XAP.mintTokens(AppicsFund, AppicsPart.mul(totalAmount).div(100));&#13;
        XAP.mintTokens(EcosystemFund, EcosystemPart.mul(totalAmount).div(100));&#13;
        XAP.mintTokens(SteemitFund, SteemitPart.mul(totalAmount).div(100));&#13;
        XAP.mintTokens(BountyFund, BountyPart.mul(totalAmount).div(100));&#13;
        statusICO = StatusICO.RoundDFinished;&#13;
        LogFinishRoundD(AppicsFund, EcosystemFund, SteemitFund, BountyFund);&#13;
    }    &#13;
&#13;
&#13;
   /**&#13;
    *   @dev Enable token transfers&#13;
    */&#13;
    function unfreeze() external managerOnly {&#13;
        XAP.defrostTokens();&#13;
    }&#13;
&#13;
   /**&#13;
    *   @dev Disable token transfers&#13;
    */&#13;
    function freeze() external managerOnly {&#13;
        XAP.frostTokens();&#13;
    }&#13;
&#13;
   /**&#13;
    *   @dev Fallback function calls buyTokens() function to buy tokens&#13;
    *        when investor sends ETH to address of ICO contract&#13;
    */&#13;
    function() external payable {&#13;
        uint256 tokens; &#13;
        tokens = msg.value.mul(Tokens_Per_Dollar_Numerator).mul(Rate_Eth);&#13;
        // rounding tokens amount:&#13;
        tokens = tokens.div(Tokens_Per_Dollar_Denominator);&#13;
        buyTokens(msg.sender, tokens);&#13;
    }&#13;
&#13;
   /**&#13;
    *   @dev Issues tokens for users who made purchases in other cryptocurrencies&#13;
    *   @param _investor     address the tokens will be issued to&#13;
    *   @param _xapValue     number of Appics tokens&#13;
    *   @param _txHash       transaction hash of investor's payment&#13;
    */&#13;
    function buyForInvestor(&#13;
        address _investor,&#13;
        uint256 _xapValue,&#13;
        string _txHash&#13;
    )&#13;
        external&#13;
        controllersOnly&#13;
        startedOnly {&#13;
        buyTokens(_investor, _xapValue);        &#13;
        LogBuyForInvestor(_investor, _xapValue, _txHash);&#13;
    }&#13;
&#13;
&#13;
   /**&#13;
    *   @dev Issue tokens for investors who paid in ether&#13;
    *   @param _investor     address which the tokens will be issued to&#13;
    *   @param _xapValue     number of Appics tokens&#13;
    */&#13;
    function buyTokens(address _investor, uint256 _xapValue) internal startedOnly {&#13;
        require(_xapValue &gt; 0);&#13;
        uint256 bonus = getBonus(_xapValue);&#13;
        uint256 total = _xapValue.add(bonus);&#13;
        if (statusICO == StatusICO.PreSaleStarted) {&#13;
            require (PreSaleSold.add(total) &lt;= PreSaleHardCap);&#13;
            require(_xapValue &gt; TENTHOUSENDLIMIT);&#13;
            PreSaleSold = PreSaleSold.add(total);&#13;
        }&#13;
        if (statusICO == StatusICO.RoundAStarted) {&#13;
            require (RoundASold.add(total) &lt;= RoundAHardCap);&#13;
            RoundASold = RoundASold.add(total);&#13;
        }&#13;
        if (statusICO == StatusICO.RoundBStarted) {&#13;
            require (RoundBSold.add(total) &lt;= RoundBHardCap);&#13;
            RoundBSold = RoundBSold.add(total);&#13;
        }&#13;
        if (statusICO == StatusICO.RoundCStarted) {&#13;
            require (RoundCSold.add(total) &lt;= RoundCHardCap);&#13;
            RoundCSold = RoundCSold.add(total);&#13;
        }&#13;
        if (statusICO == StatusICO.RoundDStarted) {&#13;
            require (RoundDSold.add(total) &lt;= RoundDHardCap);&#13;
            RoundDSold = RoundDSold.add(total);&#13;
        }&#13;
        XAP.mintTokens(_investor, total);&#13;
    }&#13;
&#13;
   /**&#13;
    *   @dev Calculates bonus&#13;
    *   @param _value        amount of tokens&#13;
    *   @return              bonus value&#13;
    */&#13;
    function getBonus(uint256 _value)&#13;
        public&#13;
        constant&#13;
        returns(uint256)&#13;
    {&#13;
        uint256 bonus = 0;&#13;
        if (statusICO == StatusICO.PreSaleStarted) {&#13;
            bonus = _value.mul(20).div(100);&#13;
        }&#13;
        if (statusICO == StatusICO.RoundAStarted) {&#13;
            bonus = _value.mul(15).div(100); &#13;
        }&#13;
        if (statusICO == StatusICO.RoundBStarted) {&#13;
            bonus = _value.mul(10).div(100); &#13;
        }&#13;
        if (statusICO == StatusICO.RoundCStarted) {&#13;
            bonus = _value.mul(5).div(100); &#13;
        }&#13;
        return bonus;&#13;
    }&#13;
    &#13;
    function register(string _key) public {&#13;
        keys[msg.sender] = _key;&#13;
        LogRegister(msg.sender, _key);&#13;
    }&#13;
&#13;
&#13;
   /**&#13;
    *   @dev Allows Company withdraw investments when round is over&#13;
    */&#13;
    function withdrawEther() external managerOnly finishedOnly{&#13;
        Company.transfer(this.balance);&#13;
    }&#13;
&#13;
}&#13;
&#13;
&#13;
/**&#13;
 *   @title &#13;
 *   @dev Appics token contract&#13;
 */&#13;
contract AppicsToken is ERC20 {&#13;
    using SafeMath for uint256;&#13;
    string public name = "Appics";&#13;
    string public symbol = "XAP";&#13;
    uint256 public decimals = 18;&#13;
&#13;
    // Ico contract address&#13;
    address public ico;&#13;
    event Burn(address indexed from, uint256 value);&#13;
&#13;
    // Disables/enables token transfers&#13;
    bool public tokensAreFrozen = true;&#13;
&#13;
    // Allows execution by the ico only&#13;
    modifier icoOnly {&#13;
        require(msg.sender == ico);&#13;
        _;&#13;
    }&#13;
&#13;
   /**&#13;
    *   @dev Contract constructor function sets Ico address&#13;
    *   @param _ico          ico address&#13;
    */&#13;
    function AppicsToken(address _ico) public {&#13;
        ico = _ico;&#13;
    }&#13;
&#13;
   /**&#13;
    *   @dev Mint tokens&#13;
    *   @param _holder       beneficiary address the tokens will be issued to&#13;
    *   @param _value        number of tokens to issue&#13;
    */&#13;
    function mintTokens(address _holder, uint256 _value) external icoOnly {&#13;
        require(_value &gt; 0);&#13;
        balances[_holder] = balances[_holder].add(_value);&#13;
        totalSupply = totalSupply.add(_value);&#13;
        Transfer(0x0, _holder, _value);&#13;
    }&#13;
&#13;
   /**&#13;
    *   @dev Enables token transfers&#13;
    */&#13;
    function defrostTokens() external icoOnly {&#13;
      tokensAreFrozen = false;&#13;
    }&#13;
&#13;
    /**&#13;
    *   @dev Disables token transfers&#13;
    */&#13;
    function frostTokens() external icoOnly {&#13;
      tokensAreFrozen = true;&#13;
    }&#13;
&#13;
   /**&#13;
    *   @dev Burn Tokens&#13;
    *   @param _investor     token holder address which the tokens will be burnt&#13;
    *   @param _value        number of tokens to burn&#13;
    */&#13;
    function burnTokens(address _investor, uint256 _value) external icoOnly {&#13;
        require(balances[_investor] &gt; 0);&#13;
        totalSupply = totalSupply.sub(_value);&#13;
        balances[_investor] = balances[_investor].sub(_value);&#13;
        Burn(_investor, _value);&#13;
    }&#13;
&#13;
   /**&#13;
    *   @dev Get balance of investor&#13;
    *   @param _owner        investor's address&#13;
    *   @return              balance of investor&#13;
    */&#13;
    function balanceOf(address _owner) public constant returns(uint256) {&#13;
      return balances[_owner];&#13;
    }&#13;
&#13;
   /**&#13;
    *   @dev Send coins&#13;
    *   throws on any error rather then return a false flag to minimize&#13;
    *   user errors&#13;
    *   @param _to           target address&#13;
    *   @param _amount       transfer amount&#13;
    *&#13;
    *   @return true if the transfer was successful&#13;
    */&#13;
    function transfer(address _to, uint256 _amount) public returns(bool) {&#13;
        require(!tokensAreFrozen);&#13;
        balances[msg.sender] = balances[msg.sender].sub(_amount);&#13;
        balances[_to] = balances[_to].add(_amount);&#13;
        Transfer(msg.sender, _to, _amount);&#13;
        return true;&#13;
    }&#13;
&#13;
   /**&#13;
    *   @dev An account/contract attempts to get the coins&#13;
    *   throws on any error rather then return a false flag to minimize user errors&#13;
    *&#13;
    *   @param _from         source address&#13;
    *   @param _to           target address&#13;
    *   @param _amount       transfer amount&#13;
    *&#13;
    *   @return true if the transfer was successful&#13;
    */&#13;
    function transferFrom(address _from, address _to, uint256 _amount) public returns(bool) {&#13;
        require(!tokensAreFrozen);&#13;
        balances[_from] = balances[_from].sub(_amount);&#13;
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);&#13;
        balances[_to] = balances[_to].add(_amount);&#13;
        Transfer(_from, _to, _amount);&#13;
        return true;&#13;
    }&#13;
&#13;
   /**&#13;
    *   @dev Allows another account/contract to spend some tokens on its behalf&#13;
    *   throws on any error rather then return a false flag to minimize user errors&#13;
    *&#13;
    *   also, to minimize the risk of the approve/transferFrom attack vector&#13;
    *   approve has to be called twice in 2 separate transactions - once to&#13;
    *   change the allowance to 0 and secondly to change it to the new allowance&#13;
    *   value&#13;
    *&#13;
    *   @param _spender      approved address&#13;
    *   @param _amount       allowance amount&#13;
    *&#13;
    *   @return true if the approval was successful&#13;
    */&#13;
    function approve(address _spender, uint256 _amount) public returns(bool) {&#13;
        require((_amount == 0) || (allowed[msg.sender][_spender] == 0));&#13;
        allowed[msg.sender][_spender] = _amount;&#13;
        Approval(msg.sender, _spender, _amount);&#13;
        return true;&#13;
    }&#13;
&#13;
   /**&#13;
    *   @dev Function to check the amount of tokens that an owner allowed to a spender.&#13;
    *&#13;
    *   @param _owner        the address which owns the funds&#13;
    *   @param _spender      the address which will spend the funds&#13;
    *&#13;
    *   @return              the amount of tokens still avaible for the spender&#13;
    */&#13;
    function allowance(address _owner, address _spender) public constant returns(uint256) {&#13;
        return allowed[_owner][_spender];&#13;
    }&#13;
}