pragma solidity ^0.4.17;

/*

 * source       https://github.com/blockbitsio/

 * @name        Application Entity Generic Contract
 * @package     BlockBitsIO
 * @author      Micky Socaci <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="2a47434941536a44455d46435c4f045845">[email protected]</a>&gt;&#13;
&#13;
    Used for the ABI interface when assets need to call Application Entity.&#13;
&#13;
    This is required, otherwise we end up loading the assets themselves when we load the ApplicationEntity contract&#13;
    and end up in a loop&#13;
*/&#13;
&#13;
&#13;
&#13;
contract ApplicationEntityABI {&#13;
&#13;
    address public ProposalsEntity;&#13;
    address public FundingEntity;&#13;
    address public MilestonesEntity;&#13;
    address public MeetingsEntity;&#13;
    address public BountyManagerEntity;&#13;
    address public TokenManagerEntity;&#13;
    address public ListingContractEntity;&#13;
    address public FundingManagerEntity;&#13;
    address public NewsContractEntity;&#13;
&#13;
    bool public _initialized = false;&#13;
    bool public _locked = false;&#13;
    uint8 public CurrentEntityState;&#13;
    uint8 public AssetCollectionNum;&#13;
    address public GatewayInterfaceAddress;&#13;
    address public deployerAddress;&#13;
    address testAddressAllowUpgradeFrom;&#13;
    mapping (bytes32 =&gt; uint8) public EntityStates;&#13;
    mapping (bytes32 =&gt; address) public AssetCollection;&#13;
    mapping (uint8 =&gt; bytes32) public AssetCollectionIdToName;&#13;
    mapping (bytes32 =&gt; uint256) public BylawsUint256;&#13;
    mapping (bytes32 =&gt; bytes32) public BylawsBytes32;&#13;
&#13;
    function ApplicationEntity() public;&#13;
    function getEntityState(bytes32 name) public view returns (uint8);&#13;
    function linkToGateway( address _GatewayInterfaceAddress, bytes32 _sourceCodeUrl ) external;&#13;
    function setUpgradeState(uint8 state) public ;&#13;
    function addAssetProposals(address _assetAddresses) external;&#13;
    function addAssetFunding(address _assetAddresses) external;&#13;
    function addAssetMilestones(address _assetAddresses) external;&#13;
    function addAssetMeetings(address _assetAddresses) external;&#13;
    function addAssetBountyManager(address _assetAddresses) external;&#13;
    function addAssetTokenManager(address _assetAddresses) external;&#13;
    function addAssetFundingManager(address _assetAddresses) external;&#13;
    function addAssetListingContract(address _assetAddresses) external;&#13;
    function addAssetNewsContract(address _assetAddresses) external;&#13;
    function getAssetAddressByName(bytes32 _name) public view returns (address);&#13;
    function setBylawUint256(bytes32 name, uint256 value) public;&#13;
    function getBylawUint256(bytes32 name) public view returns (uint256);&#13;
    function setBylawBytes32(bytes32 name, bytes32 value) public;&#13;
    function getBylawBytes32(bytes32 name) public view returns (bytes32);&#13;
    function initialize() external returns (bool);&#13;
    function getParentAddress() external view returns(address);&#13;
    function createCodeUpgradeProposal( address _newAddress, bytes32 _sourceCodeUrl ) external returns (uint256);&#13;
    function acceptCodeUpgradeProposal(address _newAddress) external;&#13;
    function initializeAssetsToThisApplication() external returns (bool);&#13;
    function transferAssetsToNewApplication(address _newAddress) external returns (bool);&#13;
    function lock() external returns (bool);&#13;
    function canInitiateCodeUpgrade(address _sender) public view returns(bool);&#13;
    function doStateChanges() public;&#13;
    function hasRequiredStateChanges() public view returns (bool);&#13;
    function anyAssetHasChanges() public view returns (bool);&#13;
    function extendedAnyAssetHasChanges() internal view returns (bool);&#13;
    function getRequiredStateChanges() public view returns (uint8, uint8);&#13;
    function getTimestamp() view public returns (uint256);&#13;
&#13;
}&#13;
&#13;
/*&#13;
&#13;
 * source       https://github.com/blockbitsio/&#13;
&#13;
 * @name        Application Asset Contract&#13;
 * @package     BlockBitsIO&#13;
 * @author      Micky Socaci &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="ff92969c9486bf9190889396899ad18d90">[email protected]</a>&gt;&#13;
&#13;
 Any contract inheriting this will be usable as an Asset in the Application Entity&#13;
&#13;
*/&#13;
&#13;
&#13;
&#13;
&#13;
contract ApplicationAsset {&#13;
&#13;
    event EventAppAssetOwnerSet(bytes32 indexed _name, address indexed _owner);&#13;
    event EventRunBeforeInit(bytes32 indexed _name);&#13;
    event EventRunBeforeApplyingSettings(bytes32 indexed _name);&#13;
&#13;
&#13;
    mapping (bytes32 =&gt; uint8) public EntityStates;&#13;
    mapping (bytes32 =&gt; uint8) public RecordStates;&#13;
    uint8 public CurrentEntityState;&#13;
&#13;
    event EventEntityProcessor(bytes32 indexed _assetName, uint8 indexed _current, uint8 indexed _required);&#13;
    event DebugEntityRequiredChanges( bytes32 _assetName, uint8 indexed _current, uint8 indexed _required );&#13;
&#13;
    bytes32 public assetName;&#13;
&#13;
    /* Asset records */&#13;
    uint8 public RecordNum = 0;&#13;
&#13;
    /* Asset initialised or not */&#13;
    bool public _initialized = false;&#13;
&#13;
    /* Asset settings present or not */&#13;
    bool public _settingsApplied = false;&#13;
&#13;
    /* Asset owner ( ApplicationEntity address ) */&#13;
    address public owner = address(0x0) ;&#13;
    address public deployerAddress;&#13;
&#13;
    function ApplicationAsset() public {&#13;
        deployerAddress = msg.sender;&#13;
    }&#13;
&#13;
    function setInitialApplicationAddress(address _ownerAddress) public onlyDeployer requireNotInitialised {&#13;
        owner = _ownerAddress;&#13;
    }&#13;
&#13;
    function setInitialOwnerAndName(bytes32 _name) external&#13;
        requireNotInitialised&#13;
        onlyOwner&#13;
        returns (bool)&#13;
    {&#13;
        // init states&#13;
        setAssetStates();&#13;
        assetName = _name;&#13;
        // set initial state&#13;
        CurrentEntityState = getEntityState("NEW");&#13;
        runBeforeInitialization();&#13;
        _initialized = true;&#13;
        EventAppAssetOwnerSet(_name, owner);&#13;
        return true;&#13;
    }&#13;
&#13;
    function setAssetStates() internal {&#13;
        // Asset States&#13;
        EntityStates["__IGNORED__"]     = 0;&#13;
        EntityStates["NEW"]             = 1;&#13;
        // Funding Stage States&#13;
        RecordStates["__IGNORED__"]     = 0;&#13;
    }&#13;
&#13;
    function getRecordState(bytes32 name) public view returns (uint8) {&#13;
        return RecordStates[name];&#13;
    }&#13;
&#13;
    function getEntityState(bytes32 name) public view returns (uint8) {&#13;
        return EntityStates[name];&#13;
    }&#13;
&#13;
    function runBeforeInitialization() internal requireNotInitialised  {&#13;
        EventRunBeforeInit(assetName);&#13;
    }&#13;
&#13;
    function applyAndLockSettings()&#13;
        public&#13;
        onlyDeployer&#13;
        requireInitialised&#13;
        requireSettingsNotApplied&#13;
        returns(bool)&#13;
    {&#13;
        runBeforeApplyingSettings();&#13;
        _settingsApplied = true;&#13;
        return true;&#13;
    }&#13;
&#13;
    function runBeforeApplyingSettings() internal requireInitialised requireSettingsNotApplied  {&#13;
        EventRunBeforeApplyingSettings(assetName);&#13;
    }&#13;
&#13;
    function transferToNewOwner(address _newOwner) public requireInitialised onlyOwner returns (bool) {&#13;
        require(owner != address(0x0) &amp;&amp; _newOwner != address(0x0));&#13;
        owner = _newOwner;&#13;
        EventAppAssetOwnerSet(assetName, owner);&#13;
        return true;&#13;
    }&#13;
&#13;
    function getApplicationAssetAddressByName(bytes32 _name)&#13;
        public&#13;
        view&#13;
        returns(address)&#13;
    {&#13;
        address asset = ApplicationEntityABI(owner).getAssetAddressByName(_name);&#13;
        if( asset != address(0x0) ) {&#13;
            return asset;&#13;
        } else {&#13;
            revert();&#13;
        }&#13;
    }&#13;
&#13;
    function getApplicationState() public view returns (uint8) {&#13;
        return ApplicationEntityABI(owner).CurrentEntityState();&#13;
    }&#13;
&#13;
    function getApplicationEntityState(bytes32 name) public view returns (uint8) {&#13;
        return ApplicationEntityABI(owner).getEntityState(name);&#13;
    }&#13;
&#13;
    function getAppBylawUint256(bytes32 name) public view requireInitialised returns (uint256) {&#13;
        ApplicationEntityABI CurrentApp = ApplicationEntityABI(owner);&#13;
        return CurrentApp.getBylawUint256(name);&#13;
    }&#13;
&#13;
    function getAppBylawBytes32(bytes32 name) public view requireInitialised returns (bytes32) {&#13;
        ApplicationEntityABI CurrentApp = ApplicationEntityABI(owner);&#13;
        return CurrentApp.getBylawBytes32(name);&#13;
    }&#13;
&#13;
    modifier onlyOwner() {&#13;
        require(msg.sender == owner);&#13;
        _;&#13;
    }&#13;
&#13;
    modifier onlyApplicationEntity() {&#13;
        require(msg.sender == owner);&#13;
        _;&#13;
    }&#13;
&#13;
    modifier requireInitialised() {&#13;
        require(_initialized == true);&#13;
        _;&#13;
    }&#13;
&#13;
    modifier requireNotInitialised() {&#13;
        require(_initialized == false);&#13;
        _;&#13;
    }&#13;
&#13;
    modifier requireSettingsApplied() {&#13;
        require(_settingsApplied == true);&#13;
        _;&#13;
    }&#13;
&#13;
    modifier requireSettingsNotApplied() {&#13;
        require(_settingsApplied == false);&#13;
        _;&#13;
    }&#13;
&#13;
    modifier onlyDeployer() {&#13;
        require(msg.sender == deployerAddress);&#13;
        _;&#13;
    }&#13;
&#13;
    modifier onlyAsset(bytes32 _name) {&#13;
        address AssetAddress = getApplicationAssetAddressByName(_name);&#13;
        require( msg.sender == AssetAddress);&#13;
        _;&#13;
    }&#13;
&#13;
    function getTimestamp() view public returns (uint256) {&#13;
        return now;&#13;
    }&#13;
&#13;
&#13;
}&#13;
&#13;
/*&#13;
&#13;
 * source       https://github.com/blockbitsio/&#13;
&#13;
 * @name        Application Asset Contract ABI&#13;
 * @package     BlockBitsIO&#13;
 * @author      Micky Socaci &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="b1dcd8d2dac8f1dfdec6ddd8c7d49fc3de">[email protected]</a>&gt;&#13;
&#13;
 Any contract inheriting this will be usable as an Asset in the Application Entity&#13;
&#13;
*/&#13;
&#13;
&#13;
&#13;
contract ABIApplicationAsset {&#13;
&#13;
    bytes32 public assetName;&#13;
    uint8 public CurrentEntityState;&#13;
    uint8 public RecordNum;&#13;
    bool public _initialized;&#13;
    bool public _settingsApplied;&#13;
    address public owner;&#13;
    address public deployerAddress;&#13;
    mapping (bytes32 =&gt; uint8) public EntityStates;&#13;
    mapping (bytes32 =&gt; uint8) public RecordStates;&#13;
&#13;
    function setInitialApplicationAddress(address _ownerAddress) public;&#13;
    function setInitialOwnerAndName(bytes32 _name) external returns (bool);&#13;
    function getRecordState(bytes32 name) public view returns (uint8);&#13;
    function getEntityState(bytes32 name) public view returns (uint8);&#13;
    function applyAndLockSettings() public returns(bool);&#13;
    function transferToNewOwner(address _newOwner) public returns (bool);&#13;
    function getApplicationAssetAddressByName(bytes32 _name) public returns(address);&#13;
    function getApplicationState() public view returns (uint8);&#13;
    function getApplicationEntityState(bytes32 name) public view returns (uint8);&#13;
    function getAppBylawUint256(bytes32 name) public view returns (uint256);&#13;
    function getAppBylawBytes32(bytes32 name) public view returns (bytes32);&#13;
    function getTimestamp() view public returns (uint256);&#13;
&#13;
&#13;
}&#13;
&#13;
/*&#13;
&#13;
 * source       https://github.com/blockbitsio/&#13;
&#13;
 * @name        Token Manager Contract&#13;
 * @package     BlockBitsIO&#13;
 * @author      Micky Socaci &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="deb3b7bdb5a79eb0b1a9b2b7a8bbf0acb1">[email protected]</a>&gt;&#13;
&#13;
*/&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
contract ABITokenManager is ABIApplicationAsset {&#13;
&#13;
    address public TokenSCADAEntity;&#13;
    address public TokenEntity;&#13;
    address public MarketingMethodAddress;&#13;
    bool OwnerTokenBalancesReleased = false;&#13;
&#13;
    function addSettings(address _scadaAddress, address _tokenAddress, address _marketing ) public;&#13;
    function getTokenSCADARequiresHardCap() public view returns (bool);&#13;
    function mint(address _to, uint256 _amount) public returns (bool);&#13;
    function finishMinting() public returns (bool);&#13;
    function mintForMarketingPool(address _to, uint256 _amount) external returns (bool);&#13;
    function ReleaseOwnersLockedTokens(address _multiSigOutputAddress) public returns (bool);&#13;
&#13;
}&#13;
&#13;
/*&#13;
&#13;
 * source       https://github.com/blockbitsio/&#13;
&#13;
 * @name        Proposals Contract&#13;
 * @package     BlockBitsIO&#13;
 * @author      Micky Socaci &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="5f32363c34261f3130283336293a712d30">[email protected]</a>&gt;&#13;
&#13;
 Contains the Proposals Contract code deployed and linked to the Application Entity&#13;
&#13;
*/&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
contract ABIProposals is ABIApplicationAsset {&#13;
&#13;
    address public Application;&#13;
    address public ListingContractEntity;&#13;
    address public FundingEntity;&#13;
    address public FundingManagerEntity;&#13;
    address public TokenManagerEntity;&#13;
    address public TokenEntity;&#13;
    address public MilestonesEntity;&#13;
&#13;
    struct ProposalRecord {&#13;
        address creator;&#13;
        bytes32 name;&#13;
        uint8 actionType;&#13;
        uint8 state;&#13;
        bytes32 hash;                       // action name + args hash&#13;
        address addr;&#13;
        bytes32 sourceCodeUrl;&#13;
        uint256 extra;&#13;
        uint256 time_start;&#13;
        uint256 time_end;&#13;
        uint256 index;&#13;
    }&#13;
&#13;
    struct VoteStruct {&#13;
        address voter;&#13;
        uint256 time;&#13;
        bool    vote;&#13;
        uint256 power;&#13;
        bool    annulled;&#13;
        uint256 index;&#13;
    }&#13;
&#13;
    struct ResultRecord {&#13;
        uint256 totalAvailable;&#13;
        uint256 requiredForResult;&#13;
        uint256 totalSoFar;&#13;
        uint256 yes;&#13;
        uint256 no;&#13;
        bool    requiresCounting;&#13;
    }&#13;
&#13;
    uint8 public ActiveProposalNum;&#13;
    uint256 public VoteCountPerProcess;&#13;
    bool public EmergencyFundingReleaseApproved;&#13;
&#13;
    mapping (bytes32 =&gt; uint8) public ActionTypes;&#13;
    mapping (uint8 =&gt; uint256) public ActiveProposalIds;&#13;
    mapping (uint256 =&gt; bool) public ExpiredProposalIds;&#13;
    mapping (uint256 =&gt; ProposalRecord) public ProposalsById;&#13;
    mapping (bytes32 =&gt; uint256) public ProposalIdByHash;&#13;
    mapping (uint256 =&gt; mapping (uint256 =&gt; VoteStruct) ) public VotesByProposalId;&#13;
    mapping (uint256 =&gt; mapping (address =&gt; VoteStruct) ) public VotesByCaster;&#13;
    mapping (uint256 =&gt; uint256) public VotesNumByProposalId;&#13;
    mapping (uint256 =&gt; ResultRecord ) public ResultsByProposalId;&#13;
    mapping (uint256 =&gt; uint256) public lastProcessedVoteIdByProposal;&#13;
    mapping (uint256 =&gt; uint256) public ProcessedVotesByProposal;&#13;
    mapping (uint256 =&gt; uint256) public VoteCountAtProcessingStartByProposal;&#13;
&#13;
    function getRecordState(bytes32 name) public view returns (uint8);&#13;
    function getActionType(bytes32 name) public view returns (uint8);&#13;
    function getProposalState(uint256 _proposalId) public view returns (uint8);&#13;
    function getBylawsProposalVotingDuration() public view returns (uint256);&#13;
    function getBylawsMilestoneMinPostponing() public view returns (uint256);&#13;
    function getBylawsMilestoneMaxPostponing() public view returns (uint256);&#13;
    function getHash(uint8 actionType, bytes32 arg1, bytes32 arg2) public pure returns ( bytes32 );&#13;
    function process() public;&#13;
    function hasRequiredStateChanges() public view returns (bool);&#13;
    function getRequiredStateChanges() public view returns (uint8);&#13;
    function addCodeUpgradeProposal(address _addr, bytes32 _sourceCodeUrl) external returns (uint256);&#13;
    function createMilestoneAcceptanceProposal() external returns (uint256);&#13;
    function createMilestonePostponingProposal(uint256 _duration) external returns (uint256);&#13;
    function getCurrentMilestonePostponingProposalDuration() public view returns (uint256);&#13;
    function getCurrentMilestoneProposalStatusForType(uint8 _actionType ) public view returns (uint8);&#13;
    function createEmergencyFundReleaseProposal() external returns (uint256);&#13;
    function createDelistingProposal(uint256 _projectId) external returns (uint256);&#13;
    function RegisterVote(uint256 _proposalId, bool _myVote) public;&#13;
    function hasPreviousVote(uint256 _proposalId, address _voter) public view returns (bool);&#13;
    function getTotalTokenVotingPower(address _voter) public view returns ( uint256 );&#13;
    function getVotingPower(uint256 _proposalId, address _voter) public view returns ( uint256 );&#13;
    function setVoteCountPerProcess(uint256 _perProcess) external;&#13;
    function ProcessVoteTotals(uint256 _proposalId, uint256 length) public;&#13;
    function canEndVoting(uint256 _proposalId) public view returns (bool);&#13;
    function getProposalType(uint256 _proposalId) public view returns (uint8);&#13;
    function expiryChangesState(uint256 _proposalId) public view returns (bool);&#13;
    function needsProcessing(uint256 _proposalId) public view returns (bool);&#13;
    function getMyVoteForCurrentMilestoneRelease(address _voter) public view returns (bool);&#13;
    function getHasVoteForCurrentMilestoneRelease(address _voter) public view returns (bool);&#13;
    function getMyVote(uint256 _proposalId, address _voter) public view returns (bool);&#13;
&#13;
}&#13;
&#13;
/*&#13;
&#13;
 * source       https://github.com/blockbitsio/&#13;
&#13;
 * @name        Milestones Contract&#13;
 * @package     BlockBitsIO&#13;
 * @author      Micky Socaci &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="95f8fcf6feecd5fbfae2f9fce3f0bbe7fa">[email protected]</a>&gt;&#13;
&#13;
 Contains the Milestones Contract code deployed and linked to the Application Entity&#13;
&#13;
*/&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
contract ABIMilestones is ABIApplicationAsset {&#13;
&#13;
    struct Record {&#13;
        bytes32 name;&#13;
        string description;                     // will change to hash pointer ( external storage )&#13;
        uint8 state;&#13;
        uint256 duration;&#13;
        uint256 time_start;                     // start at unixtimestamp&#13;
        uint256 last_state_change_time;         // time of last state change&#13;
        uint256 time_end;                       // estimated end time &gt;&gt; can be increased by proposal&#13;
        uint256 time_ended;                     // actual end time&#13;
        uint256 meeting_time;&#13;
        uint8 funding_percentage;&#13;
        uint8 index;&#13;
    }&#13;
&#13;
    uint8 public currentRecord;&#13;
    uint256 public MilestoneCashBackTime = 0;&#13;
    mapping (uint8 =&gt; Record) public Collection;&#13;
    mapping (bytes32 =&gt; bool) public MilestonePostponingHash;&#13;
    mapping (bytes32 =&gt; uint256) public ProposalIdByHash;&#13;
&#13;
    function getBylawsProjectDevelopmentStart() public view returns (uint256);&#13;
    function getBylawsMinTimeInTheFutureForMeetingCreation() public view returns (uint256);&#13;
    function getBylawsCashBackVoteRejectedDuration() public view returns (uint256);&#13;
    function addRecord( bytes32 _name, string _description, uint256 _duration, uint8 _perc ) public;&#13;
    function getMilestoneFundingPercentage(uint8 recordId) public view returns (uint8);&#13;
    function doStateChanges() public;&#13;
    function getRecordStateRequiredChanges() public view returns (uint8);&#13;
    function hasRequiredStateChanges() public view returns (bool);&#13;
    function afterVoteNoCashBackTime() public view returns ( bool );&#13;
    function getHash(uint8 actionType, bytes32 arg1, bytes32 arg2) public pure returns ( bytes32 );&#13;
    function getCurrentHash() public view returns ( bytes32 );&#13;
    function getCurrentProposalId() internal view returns ( uint256 );&#13;
    function setCurrentMilestoneMeetingTime(uint256 _meeting_time) public;&#13;
    function isRecordUpdateAllowed(uint8 _new_state ) public view returns (bool);&#13;
    function getRequiredStateChanges() public view returns (uint8, uint8, uint8);&#13;
    function ApplicationIsInDevelopment() public view returns(bool);&#13;
    function MeetingTimeSetFailure() public view returns (bool);&#13;
&#13;
}&#13;
&#13;
/*&#13;
&#13;
 * source       https://github.com/blockbitsio/&#13;
&#13;
 * @name        Funding Contract ABI&#13;
 * @package     BlockBitsIO&#13;
 * @author      Micky Socaci &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="eb8682888092ab85849c87829d8ec59984">[email protected]</a>&gt;&#13;
&#13;
 Contains the Funding Contract code deployed and linked to the Application Entity&#13;
&#13;
&#13;
    !!! Links directly to Milestones&#13;
&#13;
*/&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
contract ABIFunding is ABIApplicationAsset {&#13;
&#13;
    address public multiSigOutputAddress;&#13;
    address public DirectInput;&#13;
    address public MilestoneInput;&#13;
    address public TokenManagerEntity;&#13;
    address public FundingManagerEntity;&#13;
&#13;
    struct FundingStage {&#13;
        bytes32 name;&#13;
        uint8   state;&#13;
        uint256 time_start;&#13;
        uint256 time_end;&#13;
        uint256 amount_cap_soft;            // 0 = not enforced&#13;
        uint256 amount_cap_hard;            // 0 = not enforced&#13;
        uint256 amount_raised;              // 0 = not enforced&#13;
        // funding method settings&#13;
        uint256 minimum_entry;&#13;
        uint8   methods;                    // FundingMethodIds&#13;
        // token settings&#13;
        uint256 fixed_tokens;&#13;
        uint8   price_addition_percentage;  //&#13;
        uint8   token_share_percentage;&#13;
        uint8   index;&#13;
    }&#13;
&#13;
    mapping (uint8 =&gt; FundingStage) public Collection;&#13;
    uint8 public FundingStageNum;&#13;
    uint8 public currentFundingStage;&#13;
    uint256 public AmountRaised;&#13;
    uint256 public MilestoneAmountRaised;&#13;
    uint256 public GlobalAmountCapSoft;&#13;
    uint256 public GlobalAmountCapHard;&#13;
    uint8 public TokenSellPercentage;&#13;
    uint256 public Funding_Setting_funding_time_start;&#13;
    uint256 public Funding_Setting_funding_time_end;&#13;
    uint256 public Funding_Setting_cashback_time_start;&#13;
    uint256 public Funding_Setting_cashback_time_end;&#13;
    uint256 public Funding_Setting_cashback_before_start_wait_duration;&#13;
    uint256 public Funding_Setting_cashback_duration;&#13;
&#13;
&#13;
    function addFundingStage(&#13;
        bytes32 _name,&#13;
        uint256 _time_start,&#13;
        uint256 _time_end,&#13;
        uint256 _amount_cap_soft,&#13;
        uint256 _amount_cap_hard,   // required &gt; 0&#13;
        uint8   _methods,&#13;
        uint256 _minimum_entry,&#13;
        uint256 _fixed_tokens,&#13;
        uint8   _price_addition_percentage,&#13;
        uint8   _token_share_percentage&#13;
    )&#13;
    public;&#13;
&#13;
    function addSettings(address _outputAddress, uint256 soft_cap, uint256 hard_cap, uint8 sale_percentage, address _direct, address _milestone ) public;&#13;
    function getStageAmount(uint8 StageId) public view returns ( uint256 );&#13;
    function allowedPaymentMethod(uint8 _payment_method) public pure returns (bool);&#13;
    function receivePayment(address _sender, uint8 _payment_method) payable public returns(bool);&#13;
    function canAcceptPayment(uint256 _amount) public view returns (bool);&#13;
    function getValueOverCurrentCap(uint256 _amount) public view returns (uint256);&#13;
    function isFundingStageUpdateAllowed(uint8 _new_state ) public view returns (bool);&#13;
    function getRecordStateRequiredChanges() public view returns (uint8);&#13;
    function doStateChanges() public;&#13;
    function hasRequiredStateChanges() public view returns (bool);&#13;
    function getRequiredStateChanges() public view returns (uint8, uint8, uint8);&#13;
&#13;
}&#13;
&#13;
/*&#13;
&#13;
 * source       https://github.com/blockbitsio/&#13;
&#13;
 * @name        Token Contract&#13;
 * @package     BlockBitsIO&#13;
 * @author      Micky Socaci &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="e984808a8290a987869e85809f8cc79b86">[email protected]</a>&gt;&#13;
&#13;
 Zeppelin ERC20 Standard Token&#13;
&#13;
*/&#13;
&#13;
&#13;
&#13;
contract ABIToken {&#13;
&#13;
    string public  symbol;&#13;
    string public  name;&#13;
    uint8 public   decimals;&#13;
    uint256 public totalSupply;&#13;
    string public  version;&#13;
    mapping (address =&gt; uint256) public balances;&#13;
    mapping (address =&gt; mapping (address =&gt; uint256)) allowed;&#13;
    address public manager;&#13;
    address public deployer;&#13;
    bool public mintingFinished = false;&#13;
    bool public initialized = false;&#13;
&#13;
    function transfer(address _to, uint256 _value) public returns (bool);&#13;
    function balanceOf(address _owner) public view returns (uint256 balance);&#13;
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool);&#13;
    function approve(address _spender, uint256 _value) public returns (bool);&#13;
    function allowance(address _owner, address _spender) public view returns (uint256 remaining);&#13;
    function increaseApproval(address _spender, uint _addedValue) public returns (bool success);&#13;
    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool success);&#13;
    function mint(address _to, uint256 _amount) public returns (bool);&#13;
    function finishMinting() public returns (bool);&#13;
&#13;
    event Transfer(address indexed from, address indexed to, uint256 indexed value);&#13;
    event Approval(address indexed owner, address indexed spender, uint256 indexed value);&#13;
    event Mint(address indexed to, uint256 amount);&#13;
    event MintFinished();&#13;
}&#13;
&#13;
/*&#13;
&#13;
 * source       https://github.com/blockbitsio/&#13;
&#13;
 * @name        Token Stake Calculation And Distribution Algorithm - Type 3 - Sell a variable amount of tokens for a fixed price&#13;
 * @package     BlockBitsIO&#13;
 * @author      Micky Socaci &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="2944404a42506947465e45405f4c075b46">[email protected]</a>&gt;&#13;
&#13;
&#13;
    Inputs:&#13;
&#13;
    Defined number of tokens per wei ( X Tokens = 1 wei )&#13;
    Received amount of ETH&#13;
    Generates:&#13;
&#13;
    Total Supply of tokens available in Funding Phase respectively Project&#13;
    Observations:&#13;
&#13;
    Will sell the whole supply of Tokens available to Current Funding Phase&#13;
    Use cases:&#13;
&#13;
    Any Funding Phase where you want the first Funding Phase to determine the token supply of the whole Project&#13;
&#13;
*/&#13;
&#13;
&#13;
&#13;
&#13;
contract ABITokenSCADAVariable {&#13;
    bool public SCADA_requires_hard_cap = true;&#13;
    bool public initialized;&#13;
    address public deployerAddress;&#13;
    function addSettings(address _fundingContract) public;&#13;
    function requiresHardCap() public view returns (bool);&#13;
    function getTokensForValueInCurrentStage(uint256 _value) public view returns (uint256);&#13;
    function getTokensForValueInStage(uint8 _stage, uint256 _value) public view returns (uint256);&#13;
    function getBoughtTokens( address _vaultAddress, bool _direct ) public view returns (uint256);&#13;
}&#13;
&#13;
/*&#13;
&#13;
 * source       https://github.com/blockbitsio/&#13;
&#13;
 * @name        Funding Contract ABI&#13;
 * @package     BlockBitsIO&#13;
 * @author      Micky Socaci &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="94f9fdf7ffedd4fafbe3f8fde2f1bae6fb">[email protected]</a>&gt;&#13;
&#13;
 Contains the Funding Contract code deployed and linked to the Application Entity&#13;
&#13;
*/&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
contract ABIFundingManager is ABIApplicationAsset {&#13;
&#13;
    bool public fundingProcessed;&#13;
    bool FundingPoolBalancesAllocated;&#13;
    uint8 public VaultCountPerProcess;&#13;
    uint256 public lastProcessedVaultId;&#13;
    uint256 public vaultNum;&#13;
    uint256 public LockedVotingTokens;&#13;
    bytes32 public currentTask;&#13;
    mapping (bytes32 =&gt; bool) public taskByHash;&#13;
    mapping  (address =&gt; address) public vaultList;&#13;
    mapping  (uint256 =&gt; address) public vaultById;&#13;
&#13;
    function receivePayment(address _sender, uint8 _payment_method, uint8 _funding_stage) payable public returns(bool);&#13;
    function getMyVaultAddress(address _sender) public view returns (address);&#13;
    function setVaultCountPerProcess(uint8 _perProcess) external;&#13;
    function getHash(bytes32 actionType, bytes32 arg1) public pure returns ( bytes32 );&#13;
    function getCurrentMilestoneProcessed() public view returns (bool);&#13;
    function processFundingFailedFinished() public view returns (bool);&#13;
    function processFundingSuccessfulFinished() public view returns (bool);&#13;
    function getCurrentMilestoneIdHash() internal view returns (bytes32);&#13;
    function processMilestoneFinished() public view returns (bool);&#13;
    function processEmergencyFundReleaseFinished() public view returns (bool);&#13;
    function getAfterTransferLockedTokenBalances(address vaultAddress, bool excludeCurrent) public view returns (uint256);&#13;
    function VaultRequestedUpdateForLockedVotingTokens(address owner) public;&#13;
    function doStateChanges() public;&#13;
    function hasRequiredStateChanges() public view returns (bool);&#13;
    function getRequiredStateChanges() public view returns (uint8, uint8);&#13;
    function ApplicationInFundingOrDevelopment() public view returns(bool);&#13;
&#13;
}&#13;
&#13;
/*&#13;
&#13;
 * source       https://github.com/blockbitsio/&#13;
&#13;
 * @name        Funding Vault&#13;
 * @package     BlockBitsIO&#13;
 * @author      Micky Socaci &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="55383c363e2c153b3a22393c23307b273a">[email protected]</a>&gt;&#13;
&#13;
    each purchase creates a separate funding vault contract&#13;
*/&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
contract FundingVault {&#13;
&#13;
    /* Asset initialised or not */&#13;
    bool public _initialized = false;&#13;
&#13;
    /*&#13;
        Addresses:&#13;
        vaultOwner - the address of the wallet that stores purchases in this vault ( investor address )&#13;
        outputAddress - address where funds go upon successful funding or successful milestone release&#13;
        managerAddress - address of the "FundingManager"&#13;
    */&#13;
    address public vaultOwner ;&#13;
    address public outputAddress;&#13;
    address public managerAddress;&#13;
&#13;
    /*&#13;
        Lock and BlackHole settings&#13;
    */&#13;
&#13;
    bool public allFundingProcessed = false;&#13;
    bool public DirectFundingProcessed = false;&#13;
&#13;
    /*&#13;
        Assets&#13;
    */&#13;
    // ApplicationEntityABI public ApplicationEntity;&#13;
    ABIFunding FundingEntity;&#13;
    ABIFundingManager FundingManagerEntity;&#13;
    ABIMilestones MilestonesEntity;&#13;
    ABIProposals ProposalsEntity;&#13;
    ABITokenSCADAVariable TokenSCADAEntity;&#13;
    ABIToken TokenEntity ;&#13;
&#13;
    /*&#13;
        Globals&#13;
    */&#13;
    uint256 public amount_direct = 0;&#13;
    uint256 public amount_milestone = 0;&#13;
&#13;
    // bylaws&#13;
    bool public emergencyFundReleased = false;&#13;
    uint8 emergencyFundPercentage = 0;&#13;
    uint256 BylawsCashBackOwnerMiaDuration;&#13;
    uint256 BylawsCashBackVoteRejectedDuration;&#13;
    uint256 BylawsProposalVotingDuration;&#13;
&#13;
    struct PurchaseStruct {&#13;
        uint256 unix_time;&#13;
        uint8 payment_method;&#13;
        uint256 amount;&#13;
        uint8 funding_stage;&#13;
        uint16 index;&#13;
    }&#13;
&#13;
    mapping(uint16 =&gt; PurchaseStruct) public purchaseRecords;&#13;
    uint16 public purchaseRecordsNum;&#13;
&#13;
    event EventPaymentReceived(uint8 indexed _payment_method, uint256 indexed _amount, uint16 indexed _index );&#13;
    event VaultInitialized(address indexed _owner);&#13;
&#13;
    function initialize(&#13;
        address _owner,&#13;
        address _output,&#13;
        address _fundingAddress,&#13;
        address _milestoneAddress,&#13;
        address _proposalsAddress&#13;
    )&#13;
        public&#13;
        requireNotInitialised&#13;
        returns(bool)&#13;
    {&#13;
        VaultInitialized(_owner);&#13;
&#13;
        outputAddress = _output;&#13;
        vaultOwner = _owner;&#13;
&#13;
        // whomever creates this contract is the manager.&#13;
        managerAddress = msg.sender;&#13;
&#13;
        // assets&#13;
        FundingEntity = ABIFunding(_fundingAddress);&#13;
        FundingManagerEntity = ABIFundingManager(managerAddress);&#13;
        MilestonesEntity = ABIMilestones(_milestoneAddress);&#13;
        ProposalsEntity = ABIProposals(_proposalsAddress);&#13;
&#13;
        address TokenManagerAddress = FundingEntity.getApplicationAssetAddressByName("TokenManager");&#13;
        ABITokenManager TokenManagerEntity = ABITokenManager(TokenManagerAddress);&#13;
&#13;
        address TokenAddress = TokenManagerEntity.TokenEntity();&#13;
        TokenEntity = ABIToken(TokenAddress);&#13;
&#13;
        address TokenSCADAAddress = TokenManagerEntity.TokenSCADAEntity();&#13;
        TokenSCADAEntity = ABITokenSCADAVariable(TokenSCADAAddress);&#13;
&#13;
        // set Emergency Fund Percentage if available.&#13;
        address ApplicationEntityAddress = TokenManagerEntity.owner();&#13;
        ApplicationEntityABI ApplicationEntity = ApplicationEntityABI(ApplicationEntityAddress);&#13;
&#13;
        // get Application Bylaws&#13;
        emergencyFundPercentage             = uint8( ApplicationEntity.getBylawUint256("emergency_fund_percentage") );&#13;
        BylawsCashBackOwnerMiaDuration      = ApplicationEntity.getBylawUint256("cashback_owner_mia_dur") ;&#13;
        BylawsCashBackVoteRejectedDuration  = ApplicationEntity.getBylawUint256("cashback_investor_no") ;&#13;
        BylawsProposalVotingDuration        = ApplicationEntity.getBylawUint256("proposal_voting_duration") ;&#13;
&#13;
        // init&#13;
        _initialized = true;&#13;
        return true;&#13;
    }&#13;
&#13;
&#13;
&#13;
    /*&#13;
        The funding contract decides if a vault should receive payments or not, since it's the one that creates them,&#13;
        no point in creating one if you can't accept payments.&#13;
    */&#13;
&#13;
    mapping (uint8 =&gt; uint256) public stageAmounts;&#13;
    mapping (uint8 =&gt; uint256) public stageAmountsDirect;&#13;
&#13;
    function addPayment(&#13;
        uint8 _payment_method,&#13;
        uint8 _funding_stage&#13;
    )&#13;
        public&#13;
        payable&#13;
        requireInitialised&#13;
        onlyManager&#13;
        returns (bool)&#13;
    {&#13;
        if(msg.value &gt; 0 &amp;&amp; FundingEntity.allowedPaymentMethod(_payment_method)) {&#13;
&#13;
            // store payment&#13;
            PurchaseStruct storage purchase = purchaseRecords[++purchaseRecordsNum];&#13;
                purchase.unix_time = now;&#13;
                purchase.payment_method = _payment_method;&#13;
                purchase.amount = msg.value;&#13;
                purchase.funding_stage = _funding_stage;&#13;
                purchase.index = purchaseRecordsNum;&#13;
&#13;
            // assign payment to direct or milestone&#13;
            if(_payment_method == 1) {&#13;
                amount_direct+= purchase.amount;&#13;
                stageAmountsDirect[_funding_stage]+=purchase.amount;&#13;
            }&#13;
&#13;
            if(_payment_method == 2) {&#13;
                amount_milestone+= purchase.amount;&#13;
            }&#13;
&#13;
            // in order to not iterate through purchase records, we just increase funding stage amount.&#13;
            // issue with iterating over them, while processing vaults, would be that someone could create a large&#13;
            // number of payments, which would result in an "out of gas" / stack overflow issue, that would lock&#13;
            // our contract, so we don't really want to do that.&#13;
            // doing it this way also saves some gas&#13;
            stageAmounts[_funding_stage]+=purchase.amount;&#13;
&#13;
            EventPaymentReceived( purchase.payment_method, purchase.amount, purchase.index );&#13;
            return true;&#13;
        } else {&#13;
            revert();&#13;
        }&#13;
    }&#13;
&#13;
    function getBoughtTokens() public view returns (uint256) {&#13;
        return TokenSCADAEntity.getBoughtTokens( address(this), false );&#13;
    }&#13;
&#13;
    function getDirectBoughtTokens() public view returns (uint256) {&#13;
        return TokenSCADAEntity.getBoughtTokens( address(this), true );&#13;
    }&#13;
&#13;
&#13;
    mapping (uint8 =&gt; uint256) public etherBalances;&#13;
    mapping (uint8 =&gt; uint256) public tokenBalances;&#13;
    uint8 public BalanceNum = 0;&#13;
&#13;
    bool public BalancesInitialised = false;&#13;
    function initMilestoneTokenAndEtherBalances() internal&#13;
    {&#13;
        if(BalancesInitialised == false) {&#13;
&#13;
            uint256 milestoneTokenBalance = TokenEntity.balanceOf(address(this));&#13;
            uint256 milestoneEtherBalance = this.balance;&#13;
&#13;
            // no need to worry about fractions because at the last milestone, we send everything that's left.&#13;
&#13;
            // emergency fund takes it's percentage from initial balances.&#13;
            if(emergencyFundPercentage &gt; 0) {&#13;
                tokenBalances[0] = milestoneTokenBalance / 100 * emergencyFundPercentage;&#13;
                etherBalances[0] = milestoneEtherBalance / 100 * emergencyFundPercentage;&#13;
&#13;
                milestoneTokenBalance-=tokenBalances[0];&#13;
                milestoneEtherBalance-=etherBalances[0];&#13;
            }&#13;
&#13;
            // milestones percentages are then taken from what's left.&#13;
            for(uint8 i = 1; i &lt;= MilestonesEntity.RecordNum(); i++) {&#13;
&#13;
                uint8 perc = MilestonesEntity.getMilestoneFundingPercentage(i);&#13;
                tokenBalances[i] = milestoneTokenBalance / 100 * perc;&#13;
                etherBalances[i] = milestoneEtherBalance / 100 * perc;&#13;
            }&#13;
&#13;
            BalanceNum = i;&#13;
            BalancesInitialised = true;&#13;
        }&#13;
    }&#13;
&#13;
    function ReleaseFundsAndTokens()&#13;
        public&#13;
        requireInitialised&#13;
        onlyManager&#13;
        returns (bool)&#13;
    {&#13;
        // first make sure cashback is not possible, and that we've not processed everything in this vault&#13;
        if(!canCashBack() &amp;&amp; allFundingProcessed == false) {&#13;
&#13;
            if(FundingManagerEntity.CurrentEntityState() == FundingManagerEntity.getEntityState("FUNDING_SUCCESSFUL_PROGRESS")) {&#13;
&#13;
                // case 1, direct funding only&#13;
                if(amount_direct &gt; 0 &amp;&amp; amount_milestone == 0) {&#13;
&#13;
                    // if we have direct funding and no milestone balance, transfer everything and lock vault&#13;
                    // to save gas in future processing runs.&#13;
&#13;
                    // transfer tokens to the investor&#13;
                    TokenEntity.transfer(vaultOwner, TokenEntity.balanceOf( address(this) ) );&#13;
&#13;
                    // transfer ether to the owner's wallet&#13;
                    outputAddress.transfer(this.balance);&#13;
&#13;
                    // lock vault.. and enable black hole methods&#13;
                    allFundingProcessed = true;&#13;
&#13;
                } else {&#13;
                // case 2 and 3, direct funding only&#13;
&#13;
                    if(amount_direct &gt; 0 &amp;&amp; DirectFundingProcessed == false ) {&#13;
                        TokenEntity.transfer(vaultOwner, getDirectBoughtTokens() );&#13;
                        // transfer "direct funding" ether to the owner's wallet&#13;
                        outputAddress.transfer(amount_direct);&#13;
                        DirectFundingProcessed = true;&#13;
                    }&#13;
&#13;
                    // process and initialize milestone balances, emergency fund, etc, once&#13;
                    initMilestoneTokenAndEtherBalances();&#13;
                }&#13;
                return true;&#13;
&#13;
            } else if(FundingManagerEntity.CurrentEntityState() == FundingManagerEntity.getEntityState("MILESTONE_PROCESS_PROGRESS")) {&#13;
&#13;
                // get current milestone so we know which one we need to release funds for.&#13;
                uint8 milestoneId = MilestonesEntity.currentRecord();&#13;
&#13;
                uint256 transferTokens = tokenBalances[milestoneId];&#13;
                uint256 transferEther = etherBalances[milestoneId];&#13;
&#13;
                if(milestoneId == BalanceNum - 1) {&#13;
                    // we're processing the last milestone and balance, this means we're transferring everything left.&#13;
                    // this is done to make sure we've transferred everything, even "ether that got mistakenly sent to this address"&#13;
                    // as well as the emergency fund if it has not been used.&#13;
                    transferTokens = TokenEntity.balanceOf(address(this));&#13;
                    transferEther = this.balance;&#13;
                }&#13;
&#13;
                // set balances to 0 so we can't transfer multiple times.&#13;
                // tokenBalances[milestoneId] = 0;&#13;
                // etherBalances[milestoneId] = 0;&#13;
&#13;
                // transfer tokens to the investor&#13;
                TokenEntity.transfer(vaultOwner, transferTokens );&#13;
&#13;
                // transfer ether to the owner's wallet&#13;
                outputAddress.transfer(transferEther);&#13;
&#13;
                if(milestoneId == BalanceNum - 1) {&#13;
                    // lock vault.. and enable black hole methods&#13;
                    allFundingProcessed = true;&#13;
                }&#13;
&#13;
                return true;&#13;
            }&#13;
        }&#13;
&#13;
        return false;&#13;
    }&#13;
&#13;
&#13;
    function releaseTokensAndEtherForEmergencyFund()&#13;
        public&#13;
        requireInitialised&#13;
        onlyManager&#13;
        returns (bool)&#13;
    {&#13;
        if( emergencyFundReleased == false &amp;&amp; emergencyFundPercentage &gt; 0) {&#13;
&#13;
            // transfer tokens to the investor&#13;
            TokenEntity.transfer(vaultOwner, tokenBalances[0] );&#13;
&#13;
            // transfer ether to the owner's wallet&#13;
            outputAddress.transfer(etherBalances[0]);&#13;
&#13;
            emergencyFundReleased = true;&#13;
            return true;&#13;
        }&#13;
        return false;&#13;
    }&#13;
&#13;
    function ReleaseFundsToInvestor()&#13;
        public&#13;
        requireInitialised&#13;
        isOwner&#13;
    {&#13;
        if(canCashBack()) {&#13;
&#13;
            // IF we're doing a cashback&#13;
            // transfer vault tokens back to owner address&#13;
            // send all ether to wallet owner&#13;
&#13;
            // get token balance&#13;
            uint256 myBalance = TokenEntity.balanceOf(address(this));&#13;
            // transfer all vault tokens to owner&#13;
            if(myBalance &gt; 0) {&#13;
                TokenEntity.transfer(outputAddress, myBalance );&#13;
            }&#13;
&#13;
            // now transfer all remaining ether back to investor address&#13;
            vaultOwner.transfer(this.balance);&#13;
&#13;
            // update FundingManager Locked Token Amount, so we don't break voting&#13;
            FundingManagerEntity.VaultRequestedUpdateForLockedVotingTokens( vaultOwner );&#13;
&#13;
            // disallow further processing, so we don't break Funding Manager.&#13;
            // this method can still be called to collect future black hole ether to this vault.&#13;
            allFundingProcessed = true;&#13;
        }&#13;
    }&#13;
&#13;
    /*&#13;
        1 - if the funding of the project Failed, allows investors to claim their locked ether back.&#13;
        2 - if the Investor votes NO to a Development Milestone Completion Proposal, where the majority&#13;
            also votes NO allows investors to claim their locked ether back.&#13;
        3 - project owner misses to set the time for a Development Milestone Completion Meeting allows investors&#13;
        to claim their locked ether back.&#13;
    */&#13;
    function canCashBack() public view requireInitialised returns (bool) {&#13;
&#13;
        // case 1&#13;
        if(checkFundingStateFailed()) {&#13;
            return true;&#13;
        }&#13;
        // case 2&#13;
        if(checkMilestoneStateInvestorVotedNoVotingEndedNo()) {&#13;
            return true;&#13;
        }&#13;
        // case 3&#13;
        if(checkOwnerFailedToSetTimeOnMeeting()) {&#13;
            return true;&#13;
        }&#13;
&#13;
        return false;&#13;
    }&#13;
&#13;
    function checkFundingStateFailed() public view returns (bool) {&#13;
        if(FundingEntity.CurrentEntityState() == FundingEntity.getEntityState("FAILED_FINAL") ) {&#13;
            return true;&#13;
        }&#13;
&#13;
        // also check if funding period ended, and 7 days have passed and no processing was done.&#13;
        if( FundingEntity.getTimestamp() &gt;= FundingEntity.Funding_Setting_cashback_time_start() ) {&#13;
&#13;
            // should only be possible if funding entity has been stuck in processing for more than 7 days.&#13;
            if( FundingEntity.CurrentEntityState() != FundingEntity.getEntityState("SUCCESSFUL_FINAL") ) {&#13;
                return true;&#13;
            }&#13;
        }&#13;
&#13;
        return false;&#13;
    }&#13;
&#13;
    function checkMilestoneStateInvestorVotedNoVotingEndedNo() public view returns (bool) {&#13;
        if(MilestonesEntity.CurrentEntityState() == MilestonesEntity.getEntityState("VOTING_ENDED_NO") ) {&#13;
            // first we need to make sure we actually voted.&#13;
            if( ProposalsEntity.getHasVoteForCurrentMilestoneRelease(vaultOwner) == true) {&#13;
                // now make sure we voted NO, and if so return true&#13;
                if( ProposalsEntity.getMyVoteForCurrentMilestoneRelease( vaultOwner ) == false) {&#13;
                    return true;&#13;
                }&#13;
            }&#13;
        }&#13;
        return false;&#13;
    }&#13;
&#13;
    function checkOwnerFailedToSetTimeOnMeeting() public view returns (bool) {&#13;
        // Looks like the project owner is missing in action&#13;
        // they only have to do 1 thing, which is set the meeting time 7 days before the end of the milestone so that&#13;
        // investors know when they need to show up for a progress report meeting&#13;
&#13;
        // as they did not, we consider them missing in action and allow investors to retrieve their locked ether back&#13;
        if( MilestonesEntity.CurrentEntityState() == MilestonesEntity.getEntityState("DEADLINE_MEETING_TIME_FAILED") ) {&#13;
            return true;&#13;
        }&#13;
        return false;&#13;
    }&#13;
&#13;
&#13;
    modifier isOwner() {&#13;
        require(msg.sender == vaultOwner);&#13;
        _;&#13;
    }&#13;
&#13;
    modifier onlyManager() {&#13;
        require(msg.sender == managerAddress);&#13;
        _;&#13;
    }&#13;
&#13;
    modifier requireInitialised() {&#13;
        require(_initialized == true);&#13;
        _;&#13;
    }&#13;
&#13;
    modifier requireNotInitialised() {&#13;
        require(_initialized == false);&#13;
        _;&#13;
    }&#13;
}&#13;
&#13;
/*&#13;
&#13;
 * source       https://github.com/blockbitsio/&#13;
&#13;
 * @name        Funding Contract&#13;
 * @package     BlockBitsIO&#13;
 * @author      Micky Socaci &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="89e4e0eae2f0c9e7e6fee5e0ffeca7fbe6">[email protected]</a>&gt;&#13;
&#13;
 Contains the Funding Contract code deployed and linked to the Application Entity&#13;
&#13;
*/&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
contract FundingManager is ApplicationAsset {&#13;
&#13;
    ABIFunding FundingEntity;&#13;
    ABITokenManager TokenManagerEntity;&#13;
    ABIToken TokenEntity;&#13;
    ABITokenSCADAVariable TokenSCADAEntity;&#13;
    ABIProposals ProposalsEntity;&#13;
    ABIMilestones MilestonesEntity;&#13;
&#13;
    uint256 public LockedVotingTokens = 0;&#13;
&#13;
    event EventFundingManagerReceivedPayment(address indexed _vault, uint8 indexed _payment_method, uint256 indexed _amount );&#13;
    event EventFundingManagerProcessedVault(address _vault, uint256 id );&#13;
&#13;
    mapping  (address =&gt; address) public vaultList;&#13;
    mapping  (uint256 =&gt; address) public vaultById;&#13;
    uint256 public vaultNum = 0;&#13;
&#13;
    function setAssetStates() internal {&#13;
        // Asset States&#13;
        EntityStates["__IGNORED__"]                 = 0;&#13;
        EntityStates["NEW"]                         = 1;&#13;
        EntityStates["WAITING"]                     = 2;&#13;
&#13;
        EntityStates["FUNDING_FAILED_START"]        = 10;&#13;
        EntityStates["FUNDING_FAILED_PROGRESS"]     = 11;&#13;
        EntityStates["FUNDING_FAILED_DONE"]         = 12;&#13;
&#13;
        EntityStates["FUNDING_SUCCESSFUL_START"]    = 20;&#13;
        EntityStates["FUNDING_SUCCESSFUL_PROGRESS"] = 21;&#13;
        EntityStates["FUNDING_SUCCESSFUL_DONE"]     = 22;&#13;
        EntityStates["FUNDING_SUCCESSFUL_ALLOCATE"] = 25;&#13;
&#13;
&#13;
        EntityStates["MILESTONE_PROCESS_START"]     = 30;&#13;
        EntityStates["MILESTONE_PROCESS_PROGRESS"]  = 31;&#13;
        EntityStates["MILESTONE_PROCESS_DONE"]      = 32;&#13;
&#13;
        EntityStates["EMERGENCY_PROCESS_START"]     = 40;&#13;
        EntityStates["EMERGENCY_PROCESS_PROGRESS"]  = 41;&#13;
        EntityStates["EMERGENCY_PROCESS_DONE"]      = 42;&#13;
&#13;
&#13;
        EntityStates["COMPLETE_PROCESS_START"]     = 100;&#13;
        EntityStates["COMPLETE_PROCESS_PROGRESS"]  = 101;&#13;
        EntityStates["COMPLETE_PROCESS_DONE"]      = 102;&#13;
&#13;
        // Funding Stage States&#13;
        RecordStates["__IGNORED__"]     = 0;&#13;
&#13;
    }&#13;
&#13;
    function runBeforeApplyingSettings()&#13;
        internal&#13;
        requireInitialised&#13;
        requireSettingsNotApplied&#13;
    {&#13;
        address FundingAddress = getApplicationAssetAddressByName('Funding');&#13;
        FundingEntity = ABIFunding(FundingAddress);&#13;
        EventRunBeforeApplyingSettings(assetName);&#13;
&#13;
        address TokenManagerAddress = getApplicationAssetAddressByName('TokenManager');&#13;
        TokenManagerEntity = ABITokenManager(TokenManagerAddress);&#13;
&#13;
        TokenEntity = ABIToken(TokenManagerEntity.TokenEntity());&#13;
&#13;
        address TokenSCADAAddress = TokenManagerEntity.TokenSCADAEntity();&#13;
        TokenSCADAEntity = ABITokenSCADAVariable(TokenSCADAAddress) ;&#13;
&#13;
        address MilestonesAddress = getApplicationAssetAddressByName('Milestones');&#13;
        MilestonesEntity = ABIMilestones(MilestonesAddress) ;&#13;
&#13;
        address ProposalsAddress = getApplicationAssetAddressByName('Proposals');&#13;
        ProposalsEntity = ABIProposals(ProposalsAddress) ;&#13;
    }&#13;
&#13;
&#13;
&#13;
    function receivePayment(address _sender, uint8 _payment_method, uint8 _funding_stage)&#13;
        payable&#13;
        public&#13;
        requireInitialised&#13;
        onlyAsset('Funding')&#13;
        returns(bool)&#13;
    {&#13;
        // check that msg.value is higher than 0, don't really want to have to deal with minus in case the network breaks this somehow&#13;
        if(msg.value &gt; 0) {&#13;
            FundingVault vault;&#13;
&#13;
            // no vault present&#13;
            if(!hasVault(_sender)) {&#13;
                // create and initialize a new one&#13;
                vault = new FundingVault();&#13;
                if(vault.initialize(&#13;
                    _sender,&#13;
                    FundingEntity.multiSigOutputAddress(),&#13;
                    address(FundingEntity),&#13;
                    address(getApplicationAssetAddressByName('Milestones')),&#13;
                    address(getApplicationAssetAddressByName('Proposals'))&#13;
                )) {&#13;
                    // store new vault address.&#13;
                    vaultList[_sender] = vault;&#13;
                    // increase internal vault number&#13;
                    vaultNum++;&#13;
                    // assign vault to by int registry&#13;
                    vaultById[vaultNum] = vault;&#13;
&#13;
                } else {&#13;
                    revert();&#13;
                }&#13;
            } else {&#13;
                // use existing vault&#13;
                vault = FundingVault(vaultList[_sender]);&#13;
            }&#13;
&#13;
            EventFundingManagerReceivedPayment(vault, _payment_method, msg.value);&#13;
&#13;
            if( vault.addPayment.value(msg.value)( _payment_method, _funding_stage ) ) {&#13;
&#13;
                // if payment is received in the vault then mint tokens based on the received value!&#13;
                TokenManagerEntity.mint( vault, TokenSCADAEntity.getTokensForValueInCurrentStage(msg.value) );&#13;
&#13;
                return true;&#13;
            } else {&#13;
                revert();&#13;
            }&#13;
        } else {&#13;
            revert();&#13;
        }&#13;
    }&#13;
&#13;
    function getMyVaultAddress(address _sender) public view returns (address) {&#13;
        return vaultList[_sender];&#13;
    }&#13;
&#13;
    function hasVault(address _sender) internal view returns(bool) {&#13;
        if(vaultList[_sender] != address(0x0)) {&#13;
            return true;&#13;
        } else {&#13;
            return false;&#13;
        }&#13;
    }&#13;
&#13;
    bool public fundingProcessed = false;&#13;
    uint256 public lastProcessedVaultId = 0;&#13;
    uint8 public VaultCountPerProcess = 10;&#13;
    bytes32 public currentTask = "";&#13;
&#13;
    mapping (bytes32 =&gt; bool) public taskByHash;&#13;
&#13;
    function setVaultCountPerProcess(uint8 _perProcess) external onlyDeployer {&#13;
        if(_perProcess &gt; 0) {&#13;
            VaultCountPerProcess = _perProcess;&#13;
        } else {&#13;
            revert();&#13;
        }&#13;
    }&#13;
&#13;
    function getHash(bytes32 actionType, bytes32 arg1) public pure returns ( bytes32 ) {&#13;
        return keccak256(actionType, arg1);&#13;
    }&#13;
&#13;
    function getCurrentMilestoneProcessed() public view returns (bool) {&#13;
        return taskByHash[ getHash("MILESTONE_PROCESS_START", getCurrentMilestoneIdHash() ) ];&#13;
    }&#13;
&#13;
&#13;
&#13;
    function ProcessVaultList(uint8 length) internal {&#13;
&#13;
        if(taskByHash[currentTask] == false) {&#13;
            if(&#13;
                CurrentEntityState == getEntityState("FUNDING_FAILED_PROGRESS") ||&#13;
                CurrentEntityState == getEntityState("FUNDING_SUCCESSFUL_PROGRESS") ||&#13;
                CurrentEntityState == getEntityState("MILESTONE_PROCESS_PROGRESS") ||&#13;
                CurrentEntityState == getEntityState("EMERGENCY_PROCESS_PROGRESS") ||&#13;
                CurrentEntityState == getEntityState("COMPLETE_PROCESS_PROGRESS")&#13;
            ) {&#13;
&#13;
                uint256 start = lastProcessedVaultId + 1;&#13;
                uint256 end = start + length - 1;&#13;
&#13;
                if(end &gt; vaultNum) {&#13;
                    end = vaultNum;&#13;
                }&#13;
&#13;
                // first run&#13;
                if(start == 1) {&#13;
                    // reset LockedVotingTokens, as we reindex them&#13;
                    LockedVotingTokens = 0;&#13;
                }&#13;
&#13;
                for(uint256 i = start; i &lt;= end; i++) {&#13;
                    address currentVault = vaultById[i];&#13;
                    EventFundingManagerProcessedVault(currentVault, i);&#13;
                    ProcessFundingVault(currentVault);&#13;
                    lastProcessedVaultId++;&#13;
                }&#13;
                if(lastProcessedVaultId &gt;= vaultNum ) {&#13;
                    // reset iterator and set task state to true so we can't call it again.&#13;
                    lastProcessedVaultId = 0;&#13;
                    taskByHash[currentTask] = true;&#13;
                }&#13;
            } else {&#13;
                revert();&#13;
            }&#13;
        } else {&#13;
            revert();&#13;
        }&#13;
    }&#13;
&#13;
    function processFundingFailedFinished() public view returns (bool) {&#13;
        bytes32 thisHash = getHash("FUNDING_FAILED_START", "");&#13;
        return taskByHash[thisHash];&#13;
    }&#13;
&#13;
    function processFundingSuccessfulFinished() public view returns (bool) {&#13;
        bytes32 thisHash = getHash("FUNDING_SUCCESSFUL_START", "");&#13;
        return taskByHash[thisHash];&#13;
    }&#13;
&#13;
    function getCurrentMilestoneIdHash() internal view returns (bytes32) {&#13;
        return bytes32(MilestonesEntity.currentRecord());&#13;
    }&#13;
&#13;
    function processMilestoneFinished() public view returns (bool) {&#13;
        bytes32 thisHash = getHash("MILESTONE_PROCESS_START", getCurrentMilestoneIdHash());&#13;
        return taskByHash[thisHash];&#13;
    }&#13;
&#13;
    function processEmergencyFundReleaseFinished() public view returns (bool) {&#13;
        bytes32 thisHash = getHash("EMERGENCY_PROCESS_START", bytes32(0));&#13;
        return taskByHash[thisHash];&#13;
    }&#13;
&#13;
    function ProcessFundingVault(address vaultAddress ) internal {&#13;
        FundingVault vault = FundingVault(vaultAddress);&#13;
&#13;
        if(vault.allFundingProcessed() == false) {&#13;
&#13;
            if(CurrentEntityState == getEntityState("FUNDING_SUCCESSFUL_PROGRESS")) {&#13;
&#13;
                // tokens are minted and allocated to this vault when it receives payments.&#13;
                // vault should now hold as many tokens as the investor bought using direct and milestone funding,&#13;
                // as well as the ether they sent&#13;
                // "direct funding" release -&gt; funds to owner / tokens to investor&#13;
                if(!vault.ReleaseFundsAndTokens()) {&#13;
                    revert();&#13;
                }&#13;
&#13;
            } else if(CurrentEntityState == getEntityState("MILESTONE_PROCESS_PROGRESS")) {&#13;
                // release funds to owner / tokens to investor&#13;
                if(!vault.ReleaseFundsAndTokens()) {&#13;
                    revert();&#13;
                }&#13;
&#13;
            } else if(CurrentEntityState == getEntityState("EMERGENCY_PROCESS_PROGRESS")) {&#13;
                // release emergency funds to owner / tokens to investor&#13;
                if(!vault.releaseTokensAndEtherForEmergencyFund()) {&#13;
                    revert();&#13;
                }&#13;
            }&#13;
&#13;
            // For proposal voting, we need to know how many investor locked tokens remain.&#13;
            LockedVotingTokens+= getAfterTransferLockedTokenBalances(vaultAddress, true);&#13;
&#13;
        }&#13;
    }&#13;
&#13;
    function getAfterTransferLockedTokenBalances(address vaultAddress, bool excludeCurrent) public view returns (uint256) {&#13;
        FundingVault vault = FundingVault(vaultAddress);&#13;
        uint8 currentMilestone = MilestonesEntity.currentRecord();&#13;
&#13;
        uint256 LockedBalance = 0;&#13;
        // handle emergency funding first&#13;
        if(vault.emergencyFundReleased() == false) {&#13;
            LockedBalance+=vault.tokenBalances(0);&#13;
        }&#13;
&#13;
        // get token balances starting from current&#13;
        uint8 start = currentMilestone;&#13;
&#13;
        if(CurrentEntityState != getEntityState("FUNDING_SUCCESSFUL_PROGRESS")) {&#13;
            if(excludeCurrent == true) {&#13;
                start++;&#13;
            }&#13;
        }&#13;
&#13;
        for(uint8 i = start; i &lt; vault.BalanceNum() ; i++) {&#13;
            LockedBalance+=vault.tokenBalances(i);&#13;
        }&#13;
        return LockedBalance;&#13;
&#13;
    }&#13;
&#13;
    function VaultRequestedUpdateForLockedVotingTokens(address owner) public {&#13;
        // validate sender&#13;
        address vaultAddress = vaultList[owner];&#13;
        if(msg.sender == vaultAddress){&#13;
            // get token balances starting from current&#13;
            LockedVotingTokens-= getAfterTransferLockedTokenBalances(vaultAddress, false);&#13;
        }&#13;
    }&#13;
&#13;
    bool FundingPoolBalancesAllocated = false;&#13;
&#13;
    function AllocateAfterFundingBalances() internal {&#13;
        // allocate owner, advisor, bounty pools&#13;
        if(FundingPoolBalancesAllocated == false) {&#13;
&#13;
            // mint em!&#13;
            uint256 mintedSupply = TokenEntity.totalSupply();&#13;
            uint256 salePercent = getAppBylawUint256("token_sale_percentage");&#13;
&#13;
            // find one percent&#13;
            uint256 onePercent = (mintedSupply * 1 / salePercent * 100) / 100;&#13;
&#13;
            // bounty tokens&#13;
            uint256 bountyPercent = getAppBylawUint256("token_bounty_percentage");&#13;
            uint256 bountyValue = onePercent * bountyPercent;&#13;
&#13;
            address BountyManagerAddress = getApplicationAssetAddressByName("BountyManager");&#13;
            TokenManagerEntity.mint( BountyManagerAddress, bountyValue );&#13;
&#13;
            // project tokens&#13;
            // should be 40&#13;
            uint256 projectPercent = 100 - salePercent - bountyPercent;&#13;
            uint256 projectValue = onePercent * projectPercent;&#13;
&#13;
            // project tokens get minted to Token Manager's address, and are locked there&#13;
            TokenManagerEntity.mint( TokenManagerEntity, projectValue );&#13;
            TokenManagerEntity.finishMinting();&#13;
&#13;
            FundingPoolBalancesAllocated = true;&#13;
        }&#13;
    }&#13;
&#13;
&#13;
    function doStateChanges() public {&#13;
&#13;
        var (returnedCurrentEntityState, EntityStateRequired) = getRequiredStateChanges();&#13;
        bool callAgain = false;&#13;
&#13;
        DebugEntityRequiredChanges( assetName, returnedCurrentEntityState, EntityStateRequired );&#13;
&#13;
        if(EntityStateRequired != getEntityState("__IGNORED__") ) {&#13;
            EntityProcessor(EntityStateRequired);&#13;
            callAgain = true;&#13;
        }&#13;
    }&#13;
&#13;
    function hasRequiredStateChanges() public view returns (bool) {&#13;
        bool hasChanges = false;&#13;
        var (returnedCurrentEntityState, EntityStateRequired) = getRequiredStateChanges();&#13;
        // suppress unused local variable warning&#13;
        returnedCurrentEntityState = 0;&#13;
        if(EntityStateRequired != getEntityState("__IGNORED__") ) {&#13;
            hasChanges = true;&#13;
        }&#13;
        return hasChanges;&#13;
    }&#13;
&#13;
    function EntityProcessor(uint8 EntityStateRequired) internal {&#13;
&#13;
        EventEntityProcessor( assetName, CurrentEntityState, EntityStateRequired );&#13;
&#13;
        // Update our Entity State&#13;
        CurrentEntityState = EntityStateRequired;&#13;
        // Do State Specific Updates&#13;
&#13;
// Funding Failed&#13;
        if ( EntityStateRequired == getEntityState("FUNDING_FAILED_START") ) {&#13;
            // set ProcessVaultList Task&#13;
            currentTask = getHash("FUNDING_FAILED_START", "");&#13;
            CurrentEntityState = getEntityState("FUNDING_FAILED_PROGRESS");&#13;
        } else if ( EntityStateRequired == getEntityState("FUNDING_FAILED_PROGRESS") ) {&#13;
            ProcessVaultList(VaultCountPerProcess);&#13;
&#13;
// Funding Successful&#13;
        } else if ( EntityStateRequired == getEntityState("FUNDING_SUCCESSFUL_START") ) {&#13;
&#13;
            // init SCADA variable cache.&#13;
            //if(TokenSCADAEntity.initCacheForVariables()) {&#13;
&#13;
            // start processing vaults&#13;
            currentTask = getHash("FUNDING_SUCCESSFUL_START", "");&#13;
            CurrentEntityState = getEntityState("FUNDING_SUCCESSFUL_PROGRESS");&#13;
&#13;
        } else if ( EntityStateRequired == getEntityState("FUNDING_SUCCESSFUL_PROGRESS") ) {&#13;
            ProcessVaultList(VaultCountPerProcess);&#13;
&#13;
        } else if ( EntityStateRequired == getEntityState("FUNDING_SUCCESSFUL_ALLOCATE") ) {&#13;
            AllocateAfterFundingBalances();&#13;
&#13;
// Milestones&#13;
        } else if ( EntityStateRequired == getEntityState("MILESTONE_PROCESS_START") ) {&#13;
            currentTask = getHash("MILESTONE_PROCESS_START", getCurrentMilestoneIdHash() );&#13;
            CurrentEntityState = getEntityState("MILESTONE_PROCESS_PROGRESS");&#13;
&#13;
        } else if ( EntityStateRequired == getEntityState("MILESTONE_PROCESS_PROGRESS") ) {&#13;
            ProcessVaultList(VaultCountPerProcess);&#13;
&#13;
// Emergency funding release&#13;
        } else if ( EntityStateRequired == getEntityState("EMERGENCY_PROCESS_START") ) {&#13;
            currentTask = getHash("EMERGENCY_PROCESS_START", bytes32(0) );&#13;
            CurrentEntityState = getEntityState("EMERGENCY_PROCESS_PROGRESS");&#13;
        } else if ( EntityStateRequired == getEntityState("EMERGENCY_PROCESS_PROGRESS") ) {&#13;
            ProcessVaultList(VaultCountPerProcess);&#13;
&#13;
// Completion&#13;
        } else if ( EntityStateRequired == getEntityState("COMPLETE_PROCESS_START") ) {&#13;
            currentTask = getHash("COMPLETE_PROCESS_START", "");&#13;
            CurrentEntityState = getEntityState("COMPLETE_PROCESS_PROGRESS");&#13;
&#13;
        } else if ( EntityStateRequired == getEntityState("COMPLETE_PROCESS_PROGRESS") ) {&#13;
            // release platform owner tokens from token manager&#13;
            TokenManagerEntity.ReleaseOwnersLockedTokens( FundingEntity.multiSigOutputAddress() );&#13;
            CurrentEntityState = getEntityState("COMPLETE_PROCESS_DONE");&#13;
        }&#13;
&#13;
    }&#13;
&#13;
    /*&#13;
     * Method: Get Entity Required State Changes&#13;
     *&#13;
     * @access       public&#13;
     * @type         method&#13;
     *&#13;
     * @return       ( uint8 CurrentEntityState, uint8 EntityStateRequired )&#13;
     */&#13;
    function getRequiredStateChanges() public view returns (uint8, uint8) {&#13;
&#13;
        uint8 EntityStateRequired = getEntityState("__IGNORED__");&#13;
&#13;
        if(ApplicationInFundingOrDevelopment()) {&#13;
&#13;
            if ( CurrentEntityState == getEntityState("WAITING") ) {&#13;
                /*&#13;
                    This is where we decide if we should process something&#13;
                */&#13;
&#13;
                // For funding&#13;
                if(FundingEntity.CurrentEntityState() == FundingEntity.getEntityState("FAILED")) {&#13;
                    EntityStateRequired = getEntityState("FUNDING_FAILED_START");&#13;
                }&#13;
                else if(FundingEntity.CurrentEntityState() == FundingEntity.getEntityState("SUCCESSFUL")) {&#13;
                    // make sure we haven't processed this yet&#13;
                    if(taskByHash[ getHash("FUNDING_SUCCESSFUL_START", "") ] == false) {&#13;
                        EntityStateRequired = getEntityState("FUNDING_SUCCESSFUL_START");&#13;
                    }&#13;
                }&#13;
                else if(FundingEntity.CurrentEntityState() == FundingEntity.getEntityState("SUCCESSFUL_FINAL")) {&#13;
&#13;
                    if ( processMilestoneFinished() == false) {&#13;
                        if(&#13;
                            MilestonesEntity.CurrentEntityState() == MilestonesEntity.getEntityState("VOTING_ENDED_YES") ||&#13;
                            MilestonesEntity.CurrentEntityState() == MilestonesEntity.getEntityState("VOTING_ENDED_NO_FINAL")&#13;
                        ) {&#13;
                            EntityStateRequired = getEntityState("MILESTONE_PROCESS_START");&#13;
                        }&#13;
                    }&#13;
&#13;
                    if(processEmergencyFundReleaseFinished() == false) {&#13;
                        if(ProposalsEntity.EmergencyFundingReleaseApproved() == true) {&#13;
                            EntityStateRequired = getEntityState("EMERGENCY_PROCESS_START");&#13;
                        }&#13;
                    }&#13;
&#13;
                    // else, check if all milestones have been processed and try finalising development process&#13;
                    // EntityStateRequired = getEntityState("COMPLETE_PROCESS_START");&#13;
&#13;
&#13;
                }&#13;
&#13;
            } else if ( CurrentEntityState == getEntityState("FUNDING_SUCCESSFUL_PROGRESS") ) {&#13;
                // still in progress? check if we should move to done&#13;
                if ( processFundingSuccessfulFinished() ) {&#13;
                    EntityStateRequired = getEntityState("FUNDING_SUCCESSFUL_ALLOCATE");&#13;
                } else {&#13;
                    EntityStateRequired = getEntityState("FUNDING_SUCCESSFUL_PROGRESS");&#13;
                }&#13;
&#13;
            } else if ( CurrentEntityState == getEntityState("FUNDING_SUCCESSFUL_ALLOCATE") ) {&#13;
&#13;
                if(FundingPoolBalancesAllocated) {&#13;
                    EntityStateRequired = getEntityState("FUNDING_SUCCESSFUL_DONE");&#13;
                }&#13;
&#13;
            } else if ( CurrentEntityState == getEntityState("FUNDING_SUCCESSFUL_DONE") ) {&#13;
                EntityStateRequired = getEntityState("WAITING");&#13;
&#13;
    // Funding Failed&#13;
            } else if ( CurrentEntityState == getEntityState("FUNDING_FAILED_PROGRESS") ) {&#13;
                // still in progress? check if we should move to done&#13;
                if ( processFundingFailedFinished() ) {&#13;
                    EntityStateRequired = getEntityState("FUNDING_FAILED_DONE");&#13;
                } else {&#13;
                    EntityStateRequired = getEntityState("FUNDING_FAILED_PROGRESS");&#13;
                }&#13;
&#13;
    // Milestone process&#13;
            } else if ( CurrentEntityState == getEntityState("MILESTONE_PROCESS_PROGRESS") ) {&#13;
                // still in progress? check if we should move to done&#13;
&#13;
                if ( processMilestoneFinished() ) {&#13;
                    EntityStateRequired = getEntityState("MILESTONE_PROCESS_DONE");&#13;
                } else {&#13;
                    EntityStateRequired = getEntityState("MILESTONE_PROCESS_PROGRESS");&#13;
                }&#13;
&#13;
            } else if ( CurrentEntityState == getEntityState("MILESTONE_PROCESS_DONE") ) {&#13;
&#13;
                if(processMilestoneFinished() == false) {&#13;
                    EntityStateRequired = getEntityState("WAITING");&#13;
&#13;
                } else if(MilestonesEntity.currentRecord() == MilestonesEntity.RecordNum()) {&#13;
                    EntityStateRequired = getEntityState("COMPLETE_PROCESS_START");&#13;
                }&#13;
&#13;
    // Emergency funding release&#13;
            } else if ( CurrentEntityState == getEntityState("EMERGENCY_PROCESS_PROGRESS") ) {&#13;
                // still in progress? check if we should move to done&#13;
&#13;
                if ( processEmergencyFundReleaseFinished() ) {&#13;
                    EntityStateRequired = getEntityState("EMERGENCY_PROCESS_DONE");&#13;
                } else {&#13;
                    EntityStateRequired = getEntityState("EMERGENCY_PROCESS_PROGRESS");&#13;
                }&#13;
            } else if ( CurrentEntityState == getEntityState("EMERGENCY_PROCESS_DONE") ) {&#13;
                EntityStateRequired = getEntityState("WAITING");&#13;
&#13;
    // Completion&#13;
            } else if ( CurrentEntityState == getEntityState("COMPLETE_PROCESS_PROGRESS") ) {&#13;
                EntityStateRequired = getEntityState("COMPLETE_PROCESS_PROGRESS");&#13;
            }&#13;
        } else {&#13;
&#13;
            if( CurrentEntityState == getEntityState("NEW") ) {&#13;
                // general so we know we initialized&#13;
                EntityStateRequired = getEntityState("WAITING");&#13;
            }&#13;
        }&#13;
&#13;
        return (CurrentEntityState, EntityStateRequired);&#13;
    }&#13;
&#13;
    function ApplicationInFundingOrDevelopment() public view returns(bool) {&#13;
        uint8 AppState = getApplicationState();&#13;
        if(&#13;
            AppState == getApplicationEntityState("IN_FUNDING") ||&#13;
            AppState == getApplicationEntityState("IN_DEVELOPMENT")&#13;
        ) {&#13;
            return true;&#13;
        }&#13;
        return false;&#13;
    }&#13;
&#13;
&#13;
&#13;
}