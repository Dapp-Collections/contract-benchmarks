pragma solidity ^0.4.24;

/*******************************************************************************
 *
 * Copyright (c) 2018 Decentralization Authority MDAO.
 * Released under the MIT License.
 *
 * ZeroGold POW Mining
 * 
 * An ERC20 token wallet which dispenses tokens via Proof of Work mining.
 * Based on recommendation from /u/diego_91
 * 
 * Version 18.8.19
 *
 * Web    : https://d14na.org
 * Email  : <span class="__cf_email__" data-cfemail="61121411110e1315210550550f004f0e1306">[emailÂ protected]</span>&#13;
 */&#13;
&#13;
&#13;
/*******************************************************************************&#13;
 *&#13;
 * SafeMath&#13;
 */&#13;
library SafeMath {&#13;
    function add(uint a, uint b) internal pure returns (uint c) {&#13;
        c = a + b;&#13;
        require(c &gt;= a);&#13;
    }&#13;
    function sub(uint a, uint b) internal pure returns (uint c) {&#13;
        require(b &lt;= a);&#13;
        c = a - b;&#13;
    }&#13;
    function mul(uint a, uint b) internal pure returns (uint c) {&#13;
        c = a * b;&#13;
        require(a == 0 || c / a == b);&#13;
    }&#13;
    function div(uint a, uint b) internal pure returns (uint c) {&#13;
        require(b &gt; 0);&#13;
        c = a / b;&#13;
    }&#13;
}&#13;
&#13;
&#13;
/*******************************************************************************&#13;
 *&#13;
 * Owned contract&#13;
 */&#13;
contract Owned {&#13;
    address public owner;&#13;
    address public newOwner;&#13;
&#13;
    event OwnershipTransferred(address indexed _from, address indexed _to);&#13;
&#13;
    constructor() public {&#13;
        owner = msg.sender;&#13;
    }&#13;
&#13;
    modifier onlyOwner {&#13;
        require(msg.sender == owner);&#13;
        _;&#13;
    }&#13;
&#13;
    function transferOwnership(address _newOwner) public onlyOwner {&#13;
        newOwner = _newOwner;&#13;
    }&#13;
&#13;
    function acceptOwnership() public {&#13;
        require(msg.sender == newOwner);&#13;
&#13;
        emit OwnershipTransferred(owner, newOwner);&#13;
&#13;
        owner = newOwner;&#13;
&#13;
        newOwner = address(0);&#13;
    }&#13;
}&#13;
&#13;
&#13;
/*******************************************************************************&#13;
 *&#13;
 * ERC Token Standard #20 Interface&#13;
 * https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md&#13;
 */&#13;
contract ERC20Interface {&#13;
    function totalSupply() public constant returns (uint);&#13;
    function balanceOf(address tokenOwner) public constant returns (uint balance);&#13;
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);&#13;
    function transfer(address to, uint tokens) public returns (bool success);&#13;
    function approve(address spender, uint tokens) public returns (bool success);&#13;
    function transferFrom(address from, address to, uint tokens) public returns (bool success);&#13;
&#13;
    event Transfer(address indexed from, address indexed to, uint tokens);&#13;
    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);&#13;
}&#13;
&#13;
&#13;
/*******************************************************************************&#13;
 *&#13;
 * ERC 918 Mineable Token Interface&#13;
 * https://github.com/ethereum/EIPs/blob/master/EIPS/eip-918.md&#13;
 */&#13;
contract ERC918Interface {&#13;
    function getChallengeNumber() public constant returns (bytes32);&#13;
    function getMiningDifficulty() public constant returns (uint);&#13;
    function getMiningTarget() public constant returns (uint);&#13;
    function getMiningReward() public constant returns (uint);&#13;
&#13;
    function mint(uint256 nonce, bytes32 challenge_digest) public returns (bool success);&#13;
    event Mint(address indexed from, uint reward_amount, uint epochCount, bytes32 newChallengeNumber);&#13;
&#13;
    address public lastRewardTo;&#13;
    uint public lastRewardAmount;&#13;
    uint public lastRewardEthBlockNumber;&#13;
    bytes32 public challengeNumber;&#13;
}&#13;
&#13;
/*******************************************************************************&#13;
 *&#13;
 * @notice ZeroGoldDust - Merged Mining Contract&#13;
 *&#13;
 * @dev This is a standard ERC20 mineable token contract.&#13;
 */&#13;
contract ZeroGoldPOWMining is Owned {&#13;
    using SafeMath for uint;&#13;
&#13;
    /* Initialize the ZeroGold contract. */&#13;
    ERC20Interface zeroGold;&#13;
    &#13;
    /* Initialize the Mining Leader contract. */&#13;
    ERC918Interface public miningLeader;&#13;
    &#13;
    /* Initialize the Mint Helper. */&#13;
    address public mintHelper = 0x0;&#13;
&#13;
    modifier onlyMintHelper {&#13;
        require(msg.sender == mintHelper);&#13;
        _;&#13;
    }&#13;
    &#13;
    /* Reward divisor. */&#13;
    // NOTE A value of 20 means the reward is 1/20 (5%) &#13;
    //      of current tokens held in the quarry. &#13;
    uint rewardDivisor = 20;&#13;
&#13;
    /* Number of times this has been mined. */&#13;
    uint epochCount = 0;&#13;
    &#13;
    /* Initialize last reward value. */&#13;
    uint public lastRewardAmount = 0;&#13;
&#13;
    mapping(bytes32 =&gt; bytes32) solutionForChallenge;&#13;
&#13;
    event Mint(address indexed from, uint reward_amount, uint epochCount, bytes32 newChallengeNumber);&#13;
&#13;
    constructor(address _miningLeader, address _mintHelper) public  {&#13;
        /* Initialize the mining leader. */&#13;
        miningLeader = ERC918Interface(_miningLeader);&#13;
&#13;
        /* Initialize the mint helper (address ONLY). */&#13;
        mintHelper = _mintHelper;&#13;
&#13;
        /* Initialize the ZeroGold contract. */&#13;
        // NOTE We hard-code the address here, since it should never change.&#13;
        zeroGold = ERC20Interface(0x6ef5bca539A4A01157af842B4823F54F9f7E9968);&#13;
    }&#13;
&#13;
    /**&#13;
     * Merge&#13;
     * (called from our mining leader)&#13;
     * &#13;
     * Ensure that mergeMint() can only be called once per Parent::mint().&#13;
     * Do this by ensuring that the "new" challenge number from &#13;
     * Parent::challenge post mint can be called once and that this block time &#13;
     * is the same as this mint, and the caller is msg.sender.&#13;
     * &#13;
     * Only allow one reward for each challenge. Do this by calculating what &#13;
     * the new challenge will be in _startNewMiningEpoch, and verify that &#13;
     * it is not that value this checks happen in the local contract, not in the parent&#13;
     * &#13;
     */&#13;
    function merge() external onlyMintHelper returns (bool success) {&#13;
        /* Retrieve the future challenge number from mining leader. */&#13;
        bytes32 futureChallengeNumber = blockhash(block.number - 1);&#13;
&#13;
        /* Retrieve the challenge number from the mining leader. */&#13;
        bytes32 challengeNumber = miningLeader.getChallengeNumber();&#13;
&#13;
        /* Verify the next challenge is different from the current. */&#13;
        if (challengeNumber == futureChallengeNumber) {&#13;
            // NOTE This is likely the second time that merge() has been&#13;
            //      called in a transaction, so return false (don't revert).&#13;
            return false; &#13;
        }&#13;
&#13;
        /* Verify Parent::lastRewardTo == msg.sender. */&#13;
        if (miningLeader.lastRewardTo() != msg.sender) {&#13;
            // NOTE A different address called mint last &#13;
            //      so return false (don't revert).&#13;
            return false;&#13;
        }&#13;
            &#13;
        /* Verify Parent::lastRewardEthBlockNumber == block.number. */&#13;
        if (miningLeader.lastRewardEthBlockNumber() != block.number) {&#13;
            // NOTE parent::mint() was called in a different block number &#13;
            //      so return false (don't revert).&#13;
            return false;&#13;
        }&#13;
&#13;
        // We now update the solutionForChallenge hashmap with the value of &#13;
        // parent::challengeNumber when a solution is merge minted. Only allow &#13;
        // one reward for each challenge based on parent::challengeNumber.&#13;
        bytes32 parentChallengeNumber = miningLeader.challengeNumber();&#13;
        bytes32 solution = solutionForChallenge[parentChallengeNumber];&#13;
        if (solution != 0x0) return false; // prevent the same answer from awarding twice&#13;
        &#13;
        bytes32 digest = 'merge';&#13;
        solutionForChallenge[parentChallengeNumber] = digest;&#13;
&#13;
        // We may safely run the relevant logic to give an award to the sender, &#13;
        // and update the contract.&#13;
        &#13;
        /* Retrieve the reward value. */&#13;
        uint rewardAmount = getRewardAmount();&#13;
&#13;
        /* Retrieve our ZeroGold balance. */&#13;
        uint balance = zeroGold.balanceOf(address(this));&#13;
&#13;
        /* Verify that we are not trying to transfer more than we HODL. */&#13;
        assert(rewardAmount &lt;= balance);&#13;
&#13;
        /* Set last reward amount. */&#13;
        // NOTE `lastRewardAmount` is called from MintHelper during `merge` &#13;
        //      to assign `merge_totalReward`.&#13;
        lastRewardAmount = rewardAmount;&#13;
        &#13;
        /* Increment the epoch count. */&#13;
        epochCount = epochCount.add(1);&#13;
&#13;
        // NOTE: Use 0 to indicate a merge mine.&#13;
        emit Mint(msg.sender, rewardAmount, epochCount, 0);&#13;
&#13;
        return true;&#13;
    }&#13;
&#13;
    /* Transfer the ZeroGold reward to our mining leader's payout wallets. */&#13;
    // NOTE This function will be called twice by MintHelper.merge(), &#13;
    //      once for `minterWallet` and once for `payoutsWallet`.&#13;
    function transfer(&#13;
        address _wallet, &#13;
        uint _reward&#13;
    ) external onlyMintHelper returns (bool) {&#13;
        /* Verify our mining leader isn't trying to over reward its wallets. */&#13;
        if (_reward &gt; lastRewardAmount) {&#13;
            return false;&#13;
        }&#13;
            &#13;
        /* Reduce the last reward amount. */&#13;
        lastRewardAmount = lastRewardAmount.sub(_reward);&#13;
&#13;
        /* Transfer the ZeroGold to mining leader. */&#13;
        zeroGold.transfer(_wallet, _reward);&#13;
    }&#13;
&#13;
    /* Calculate the current reward value. */&#13;
    function getRewardAmount() public constant returns (uint) {&#13;
        /* Retrieve the balance of the mineable token. */&#13;
        uint totalBalance = zeroGold.balanceOf(address(this));&#13;
&#13;
        return totalBalance.div(rewardDivisor);&#13;
    }&#13;
&#13;
    /* Set the mining leader. */&#13;
    function setMiningLeader(address _miningLeader) external onlyOwner {&#13;
        miningLeader = ERC918Interface(_miningLeader);&#13;
    }&#13;
&#13;
    /* Set the mint helper. */&#13;
    function setMintHelper(address _mintHelper) external onlyOwner {&#13;
        mintHelper = _mintHelper;&#13;
    }&#13;
&#13;
    /* Set the reward divisor. */&#13;
    function setRewardDivisor(uint _rewardDivisor) external onlyOwner {&#13;
        rewardDivisor = _rewardDivisor;&#13;
    }&#13;
&#13;
    /**&#13;
     * THIS CONTRACT DOES NOT ACCEPT DIRECT ETHER&#13;
     */&#13;
    function () public payable {&#13;
        /* Cancel this transaction. */&#13;
        revert('Oops! Direct payments are NOT permitted here.');&#13;
    }&#13;
&#13;
    /**&#13;
     * Transfer Any ERC20 Token&#13;
     *&#13;
     * @notice Owner can transfer out any accidentally sent ERC20 tokens.&#13;
     *&#13;
     * @dev Provides an ERC20 interface, which allows for the recover&#13;
     *      of any accidentally sent ERC20 tokens.&#13;
     */&#13;
    function transferAnyERC20Token(&#13;
        address tokenAddress, uint tokens&#13;
    ) public onlyOwner returns (bool success) {&#13;
        return ERC20Interface(tokenAddress).transfer(owner, tokens);&#13;
    }&#13;
}