pragma solidity ^0.4.15;

/**
 *
 * @author  David Rosen <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="264d47474842494f52664b45494808495441">[emailÂ protected]</a>&gt;&#13;
 *&#13;
 * Version Test-D&#13;
 *&#13;
 * Overview:&#13;
 * This contract impliments a blind auction for burnable tokens. Each secret bid consists&#13;
 * of a hashed bid-tuple, (`price`, `quantity`, `salt`), where price is the maximum amount&#13;
 * of ether (in wei) a user is willing to pay per token, quantity is the number of tokens&#13;
 * the user wants to buy, and salt is an arbitrary value. Together with the hashed bid-tuple,&#13;
 * the user includes an encrypted bid tuple, using the public key of the party running the&#13;
 * auction, and of course a deposit sufficient to pay for the bid.&#13;
 *&#13;
 * At the end of the bidding period, the party running the auction sets a 'strike price',&#13;
 * thereby signaling the start of the sale period. During this period all bidders must&#13;
 * execute their bids. To execute a bid a user reveals their bid-tuple. All bids with a&#13;
 * price at least as high as the strike price are filled, and all bids under the strike&#13;
 * price are returned. Bids that are exactly equal to the strike price are partially filled,&#13;
 * so that the maximum number of tokens generated does not exceed the total supply.&#13;
 *&#13;
 * Strike Price:&#13;
 * The strike price is calculated offchain by the party running the auction. When each&#13;
 * secret bid is submitted an event is generated, which includes the sender address, hashed&#13;
 * bid-tuple, encrypted bid-tuple and deposit amount. the party running the auction decrypts&#13;
 * the encrypted bid-tuple, and regenerates the hash. If the regenerated hash does not match&#13;
 * the hash that was submitted with the secret bid, or if the desposited funds are not&#13;
 * sufficient to cover the bid, then the bid is disqualified. (presumably disqualifying&#13;
 * invalid bids will be cheaper than validating all the valid bids).&#13;
 *&#13;
 * The auction is structured with a fixed maximum number of tokens. So to raise the maximum&#13;
 * funds the bids are sorted, highest to lowest. Starting the strike-price at the highest&#13;
 * bid, it is reduced, bid by bid, to include more bids. The quantity of tokens sold increases&#13;
 * each time a new bid is included; but the the token price is reduced. At each step the&#13;
 * total raise (token-price times quantity-of-tokens-sold) is computed. And the process ends&#13;
 * whenever the total raise decreases, or when the total number of tokens exceeds the total&#13;
 * supply.&#13;
 *&#13;
 * Notes:&#13;
 * The `salt` is included in the bid-tuple to discourage brute-force attacks on the inputs&#13;
 * to the secret bid.&#13;
 *&#13;
 * A user cannot submit multiple bids from the same Ether account.&#13;
 *&#13;
 * Users are required to execute their bids. If a user fails to execute their bid before the&#13;
 * end of the sale period, then they forfeit half of their deposit, and receive no tokens.&#13;
 * This rule was adopted to prevent users from placing several bids, and only revealing one&#13;
 * of them. With this rule, all bids must be executed.&#13;
 *&#13;
 */&#13;
&#13;
// Token standard API&#13;
// https://github.com/ethereum/EIPs/issues/20&#13;
&#13;
contract iERC20Token {&#13;
  function totalSupply() constant returns (uint supply);&#13;
  function balanceOf( address who ) constant returns (uint value);&#13;
  function allowance( address owner, address spender ) constant returns (uint remaining);&#13;
&#13;
  function transfer( address to, uint value) returns (bool ok);&#13;
  function transferFrom( address from, address to, uint value) returns (bool ok);&#13;
  function approve( address spender, uint value ) returns (bool ok);&#13;
&#13;
  event Transfer( address indexed from, address indexed to, uint value);&#13;
  event Approval( address indexed owner, address indexed spender, uint value);&#13;
}&#13;
&#13;
//Burnable Token interface&#13;
&#13;
contract iBurnableToken is iERC20Token {&#13;
  function burnTokens(uint _burnCount) public;&#13;
  function unPaidBurnTokens(uint _burnCount) public;&#13;
}&#13;
&#13;
&#13;
/*&#13;
    Overflow protected math functions&#13;
*/&#13;
contract SafeMath {&#13;
    /**&#13;
        constructor&#13;
    */&#13;
    function SafeMath() {&#13;
    }&#13;
&#13;
    /**&#13;
        @dev returns the sum of _x and _y, asserts if the calculation overflows&#13;
&#13;
        @param _x   value 1&#13;
        @param _y   value 2&#13;
&#13;
        @return sum&#13;
    */&#13;
    function safeAdd(uint256 _x, uint256 _y) internal returns (uint256) {&#13;
        uint256 z = _x + _y;&#13;
        assert(z &gt;= _x);&#13;
        return z;&#13;
    }&#13;
&#13;
    /**&#13;
        @dev returns the difference of _x minus _y, asserts if the subtraction results in a negative number&#13;
&#13;
        @param _x   minuend&#13;
        @param _y   subtrahend&#13;
&#13;
        @return difference&#13;
    */&#13;
    function safeSub(uint256 _x, uint256 _y) internal returns (uint256) {&#13;
        assert(_x &gt;= _y);&#13;
        return _x - _y;&#13;
    }&#13;
&#13;
    /**&#13;
        @dev returns the product of multiplying _x by _y, asserts if the calculation overflows&#13;
&#13;
        @param _x   factor 1&#13;
        @param _y   factor 2&#13;
&#13;
        @return product&#13;
    */&#13;
    function safeMul(uint256 _x, uint256 _y) internal returns (uint256) {&#13;
        uint256 z = _x * _y;&#13;
        assert(_x == 0 || z / _x == _y);&#13;
        return z;&#13;
    }&#13;
}&#13;
&#13;
contract TokenAuction is SafeMath {&#13;
&#13;
  struct SecretBid {&#13;
    bool disqualified;     // flag set if hash does not match encrypted bid&#13;
    uint deposit;          // funds deposited by bidder&#13;
    uint refund;           // funds to be returned to bidder&#13;
    uint tokens;           // structure has been allocated&#13;
    bytes32 hash;          // hash of price, quantity, secret&#13;
  }&#13;
  uint constant  AUCTION_START_EVENT = 0x01;&#13;
  uint constant  AUCTION_END_EVENT   = 0x02;&#13;
  uint constant  SALE_START_EVENT    = 0x04;&#13;
  uint constant  SALE_END_EVENT      = 0x08;&#13;
&#13;
  event SecretBidEvent(uint indexed batch, address indexed bidder, uint deposit, bytes32 hash, bytes message);&#13;
  event ExecuteEvent(uint indexed batch, address indexed bidder, uint cost, uint refund);&#13;
  event ExpireEvent(uint indexed batch, address indexed bidder, uint cost, uint refund);&#13;
  event BizarreEvent(address indexed addr, string message, uint val);&#13;
  event StateChangeEvent(uint mask);&#13;
  //&#13;
  //event MessageEvent(string message);&#13;
  //event MessageUintEvent(string message, uint val);&#13;
  //event MessageAddrEvent(string message, address val);&#13;
  //event MessageBytes32Event(string message, bytes32 val);&#13;
&#13;
  bool public isLocked;&#13;
  uint public stateMask;&#13;
  address public owner;&#13;
  address public developers;&#13;
  address public underwriter;&#13;
  iBurnableToken public token;&#13;
  uint public proceeds;&#13;
  uint public strikePrice;&#13;
  uint public strikePricePctX10;&#13;
  uint public developerReserve;&#13;
  uint public developerPctX10;&#13;
  uint public purchasedCount;&#13;
  uint public secretBidCount;&#13;
  uint public executedCount;&#13;
  uint public expiredCount;&#13;
  uint public saleDuration;&#13;
  uint public auctionStart;&#13;
  uint public auctionEnd;&#13;
  uint public saleEnd;&#13;
  mapping (address =&gt; SecretBid) public secretBids;&#13;
&#13;
  //&#13;
  //tunables&#13;
  uint batchSize = 4;&#13;
  uint contractSendGas = 100000;&#13;
&#13;
  modifier ownerOnly {&#13;
    require(msg.sender == owner);&#13;
    _;&#13;
  }&#13;
&#13;
  modifier unlockedOnly {&#13;
    require(!isLocked);&#13;
    _;&#13;
  }&#13;
&#13;
  modifier duringAuction {&#13;
    require((stateMask &amp; (AUCTION_START_EVENT | AUCTION_END_EVENT)) == AUCTION_START_EVENT);&#13;
    _;&#13;
  }&#13;
&#13;
  modifier afterAuction {&#13;
    require((stateMask &amp; AUCTION_END_EVENT) != 0);&#13;
    _;&#13;
  }&#13;
&#13;
  modifier duringSale {&#13;
    require((stateMask &amp; (SALE_START_EVENT | SALE_END_EVENT)) == SALE_START_EVENT);&#13;
    _;&#13;
  }&#13;
&#13;
  modifier afterSale {&#13;
    require((stateMask &amp; SALE_END_EVENT) != 0);&#13;
    _;&#13;
  }&#13;
&#13;
&#13;
  //&#13;
  //constructor&#13;
  //&#13;
  function TokenAuction() {&#13;
    owner = msg.sender;&#13;
  }&#13;
&#13;
  function lock() public ownerOnly {&#13;
    isLocked = true;&#13;
  }&#13;
&#13;
  function setAuctionParms(iBurnableToken _token, address _underwriter, uint _auctionStart, uint _auctionDuration, uint _saleDuration) public ownerOnly unlockedOnly {&#13;
    token = _token;&#13;
    underwriter = _underwriter;&#13;
    auctionStart = _auctionStart;&#13;
    auctionEnd = safeAdd(_auctionStart, _auctionDuration);&#13;
    saleDuration = _saleDuration;&#13;
    if (stateMask != 0) {&#13;
      //handy for debug&#13;
      stateMask = 0;&#13;
      strikePrice = 0;&#13;
      purchasedCount = 0;&#13;
      houseKeep();&#13;
    }&#13;
  }&#13;
&#13;
  function reserveDeveloperTokens(address _developers, uint _developerPctX10) public ownerOnly unlockedOnly {&#13;
    developers = _developers;&#13;
    developerPctX10 = _developerPctX10;&#13;
    uint _tokenCount = token.balanceOf(this);&#13;
    developerReserve = (safeMul(_tokenCount, developerPctX10) / 1000);&#13;
  }&#13;
&#13;
  function tune(uint _batchSize, uint _contractSendGas) public ownerOnly {&#13;
    batchSize = _batchSize;&#13;
    contractSendGas = _contractSendGas;&#13;
  }&#13;
&#13;
&#13;
  //&#13;
  //called by owner (or any other concerned party) to generate a SatateChangeEvent&#13;
  //&#13;
  function houseKeep() public {&#13;
    uint _oldMask = stateMask;&#13;
    if (now &gt;= auctionStart) {&#13;
      stateMask |= AUCTION_START_EVENT;&#13;
      if (now &gt;= auctionEnd) {&#13;
        stateMask |= AUCTION_END_EVENT;&#13;
        if (strikePrice &gt; 0) {&#13;
          stateMask |= SALE_START_EVENT;&#13;
          if (now &gt;= saleEnd)&#13;
            stateMask |= SALE_END_EVENT;&#13;
        }&#13;
      }&#13;
    }&#13;
    if (stateMask != _oldMask)&#13;
      StateChangeEvent(stateMask);&#13;
  }&#13;
&#13;
&#13;
&#13;
  //&#13;
  //setting the strike price starts the sale period, during which bidders must call executeBid.&#13;
  //the strike price should only be set once.... at any rate it cannot be changed once anyone has executed a bid.&#13;
  //strikePricePctX10 specifies what percentage (x10) of requested tokens should be awarded to each bidder that&#13;
  //bid exactly equal to the strike price.&#13;
  //&#13;
  function setStrikePrice(uint _strikePrice, uint _strikePricePctX10) public ownerOnly afterAuction {&#13;
    require(executedCount == 0);&#13;
    strikePrice = _strikePrice;&#13;
    strikePricePctX10 = _strikePricePctX10;&#13;
    saleEnd = safeAdd(now, saleDuration);&#13;
    houseKeep();&#13;
  }&#13;
&#13;
&#13;
  //&#13;
  // nobody should be sending funds via this function.... bizarre...&#13;
  // the fact that we adjust proceeds here means that this fcn will OOG if called with a send or transfer. that's&#13;
  // probably good, cuz it prevents the caller from losing their funds.&#13;
  //&#13;
  function () payable {&#13;
    proceeds = safeAdd(proceeds, msg.value);&#13;
    BizarreEvent(msg.sender, "bizarre payment", msg.value);&#13;
  }&#13;
&#13;
&#13;
  function depositSecretBid(bytes32 _hash, bytes _message) public duringAuction payable {&#13;
    //each address can only submit one bid -- and once a bid is submitted it is imutable&#13;
    //for testing, an exception is made for the owner -- but only while the contract is unlocked&#13;
    if (!(msg.sender == owner &amp;&amp; !isLocked) &amp;&amp;&#13;
         (_hash == 0 || secretBids[msg.sender].hash != 0) )&#13;
        revert();&#13;
    secretBids[msg.sender].hash = _hash;&#13;
    secretBids[msg.sender].deposit = msg.value;&#13;
    secretBidCount += 1;&#13;
    uint _batch = secretBidCount / batchSize;&#13;
    SecretBidEvent(_batch, msg.sender, msg.value, _hash, _message);&#13;
  }&#13;
&#13;
&#13;
  //&#13;
  // the owner may disqualify a bid if it is bogus. for example if the hash does not correspond&#13;
  // to the hash that is generated from the encyrpted bid tuple. when a disqualified bid is&#13;
  // executed all the deposited funds will be returned to the bidder, as if the bid was below&#13;
  // the strike-price.&#13;
  function disqualifyBid(address _from) public ownerOnly duringAuction {&#13;
    secretBids[msg.sender].disqualified = true;&#13;
  }&#13;
&#13;
&#13;
  //&#13;
  // execute a bid.&#13;
  // * purchases tokens if the specified price is above the strike price&#13;
  // * refunds whatever remains of the deposit&#13;
  //&#13;
  // call only during the sale period (strikePrice &gt; 0)&#13;
  //&#13;
  function executeBid(uint256 _secret, uint256 _price, uint256 _quantity) public duringSale {&#13;
    executeBidFor(msg.sender, _secret, _price, _quantity);&#13;
  }&#13;
  function executeBidFor(address _addr, uint256 _secret, uint256 _price, uint256 _quantity) public duringSale {&#13;
    bytes32 computedHash = keccak256(_secret, _price, _quantity);&#13;
    //MessageBytes32Event("computedHash", computedHash);&#13;
    require(secretBids[_addr].hash == computedHash);&#13;
    //&#13;
    if (secretBids[_addr].deposit &gt; 0) {&#13;
      uint _cost = 0;&#13;
      uint _refund = 0;&#13;
      if (_price &gt;= strikePrice &amp;&amp; !secretBids[_addr].disqualified) {&#13;
        uint256 _purchaseCount = (_price &gt; strikePrice) ? _quantity : (safeMul(strikePricePctX10, _quantity) / 1000);&#13;
        var _maxPurchase = token.balanceOf(this) - developerReserve;&#13;
        if (_purchaseCount &gt; _maxPurchase)&#13;
          _purchaseCount = _maxPurchase;&#13;
        _cost = safeMul(_purchaseCount, strikePrice);&#13;
        if (secretBids[_addr].deposit &gt;= _cost) {&#13;
          secretBids[_addr].deposit -= _cost;&#13;
          proceeds = safeAdd(proceeds, _cost);&#13;
          secretBids[_addr].tokens += _purchaseCount;&#13;
          purchasedCount += _purchaseCount;&#13;
          //transfer tokens to this bidder&#13;
          if (!token.transfer(_addr, _purchaseCount))&#13;
            revert();&#13;
        }&#13;
      }&#13;
      //refund whatever remains&#13;
      //use pull here, to prevent any bidder from reverting their purchase&#13;
      if (secretBids[_addr].deposit &gt; 0) {&#13;
        _refund = secretBids[_addr].deposit;&#13;
        secretBids[_addr].refund += _refund;&#13;
        secretBids[_addr].deposit = 0;&#13;
      }&#13;
      executedCount += 1;&#13;
      uint _batch = executedCount / batchSize;&#13;
      ExecuteEvent(_batch, _addr, _cost, _refund);&#13;
    }&#13;
  }&#13;
&#13;
&#13;
  //&#13;
  // expireBid&#13;
  // if a bid is not executed during the sale period, then the owner can mark the bid as expired. in this case:&#13;
  // * the bidder gets a refund of half of his deposit&#13;
  // * the bidder forfeits the other half of his deposit&#13;
  // * the bidder does not receive an tokens&#13;
  //&#13;
  function expireBid(address _addr) public ownerOnly afterSale {&#13;
    if (secretBids[_addr].deposit &gt; 0) {&#13;
      uint _forfeit = secretBids[_addr].deposit / 2;&#13;
      proceeds = safeAdd(proceeds, _forfeit);&#13;
      //refund whatever remains&#13;
      uint _refund = safeSub(secretBids[_addr].deposit, _forfeit);&#13;
      //use pull here, to prevent any bidder from reverting the expire&#13;
      secretBids[msg.sender].refund += _refund;&#13;
      secretBids[_addr].deposit = 0;&#13;
      expiredCount += 1;&#13;
      uint _batch = expiredCount / batchSize;&#13;
      ExpireEvent(_batch, _addr, _forfeit, _refund);&#13;
    }&#13;
  }&#13;
&#13;
&#13;
  //&#13;
  // bidder withdraw excess funds (or all funds if bid was too low)&#13;
  //&#13;
  function withdrawRefund() public {&#13;
    uint _amount = secretBids[msg.sender].refund;&#13;
    secretBids[msg.sender].refund = 0;&#13;
    msg.sender.transfer(_amount);&#13;
  }&#13;
&#13;
&#13;
  //&#13;
  // grant developer tokens, equal to a percentage of purchased tokens.&#13;
  // once called, any remaining tokens will be burned.&#13;
  //&#13;
  function doDeveloperGrant() public afterSale {&#13;
    uint _quantity = purchasedCount * developerPctX10 / 1000;&#13;
    var _tokensLeft = token.balanceOf(this);&#13;
    if (_quantity &gt; _tokensLeft)&#13;
      _quantity = _tokensLeft;&#13;
    if (_quantity &gt; 0) {&#13;
      //transfer pct tokens to developers&#13;
      _tokensLeft -= _quantity;&#13;
      if (!token.transfer(developers, _quantity))&#13;
        revert();&#13;
    }&#13;
    //and burn everthing that remains&#13;
    token.unPaidBurnTokens(_tokensLeft);&#13;
  }&#13;
&#13;
&#13;
  //&#13;
  // pay auction proceeds to the underwriter&#13;
  // may be called by underwriter or owner (fbo underwriter)&#13;
  //&#13;
  function payUnderwriter() public {&#13;
    require(msg.sender == owner || msg.sender == underwriter);&#13;
    uint _amount = proceeds;&#13;
    proceeds = 0;&#13;
    if (!underwriter.call.gas(contractSendGas).value(_amount)())&#13;
      revert();&#13;
  }&#13;
&#13;
&#13;
  //for debug&#13;
  //only available before the contract is locked&#13;
  function haraKiri() ownerOnly unlockedOnly {&#13;
    selfdestruct(owner);&#13;
  }&#13;
}