pragma solidity ^0.4.15;
// Grove v0.3


/// @title GroveLib - Library for queriable indexed ordered data.
/// @author PiperMerriam - <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="74041d041106191106061d1519341319151d185a171b19">[emailÂ protected]</a>&gt;&#13;
library GroveLib {&#13;
        /*&#13;
         *  Indexes for ordered data&#13;
         *&#13;
         *  Address: 0x7c1eb207c07e7ab13cf245585bd03d0fa478d034&#13;
         */&#13;
        struct Index {&#13;
                bytes32 root;&#13;
                mapping (bytes32 =&gt; Node) nodes;&#13;
        }&#13;
&#13;
        struct Node {&#13;
                bytes32 id;&#13;
                int value;&#13;
                bytes32 parent;&#13;
                bytes32 left;&#13;
                bytes32 right;&#13;
                uint height;&#13;
        }&#13;
&#13;
        function max(uint a, uint b) internal returns (uint) {&#13;
            if (a &gt;= b) {&#13;
                return a;&#13;
            }&#13;
            return b;&#13;
        }&#13;
&#13;
        /*&#13;
         *  Node getters&#13;
         */&#13;
        /// @dev Retrieve the unique identifier for the node.&#13;
        /// @param index The index that the node is part of.&#13;
        /// @param id The id for the node to be looked up.&#13;
        function getNodeId(Index storage index, bytes32 id) constant returns (bytes32) {&#13;
            return index.nodes[id].id;&#13;
        }&#13;
&#13;
        /// @dev Retrieve the value for the node.&#13;
        /// @param index The index that the node is part of.&#13;
        /// @param id The id for the node to be looked up.&#13;
        function getNodeValue(Index storage index, bytes32 id) constant returns (int) {&#13;
            return index.nodes[id].value;&#13;
        }&#13;
&#13;
        /// @dev Retrieve the height of the node.&#13;
        /// @param index The index that the node is part of.&#13;
        /// @param id The id for the node to be looked up.&#13;
        function getNodeHeight(Index storage index, bytes32 id) constant returns (uint) {&#13;
            return index.nodes[id].height;&#13;
        }&#13;
&#13;
        /// @dev Retrieve the parent id of the node.&#13;
        /// @param index The index that the node is part of.&#13;
        /// @param id The id for the node to be looked up.&#13;
        function getNodeParent(Index storage index, bytes32 id) constant returns (bytes32) {&#13;
            return index.nodes[id].parent;&#13;
        }&#13;
&#13;
        /// @dev Retrieve the left child id of the node.&#13;
        /// @param index The index that the node is part of.&#13;
        /// @param id The id for the node to be looked up.&#13;
        function getNodeLeftChild(Index storage index, bytes32 id) constant returns (bytes32) {&#13;
            return index.nodes[id].left;&#13;
        }&#13;
&#13;
        /// @dev Retrieve the right child id of the node.&#13;
        /// @param index The index that the node is part of.&#13;
        /// @param id The id for the node to be looked up.&#13;
        function getNodeRightChild(Index storage index, bytes32 id) constant returns (bytes32) {&#13;
            return index.nodes[id].right;&#13;
        }&#13;
&#13;
        /// @dev Retrieve the node id of the next node in the tree.&#13;
        /// @param index The index that the node is part of.&#13;
        /// @param id The id for the node to be looked up.&#13;
        function getPreviousNode(Index storage index, bytes32 id) constant returns (bytes32) {&#13;
            Node storage currentNode = index.nodes[id];&#13;
&#13;
            if (currentNode.id == 0x0) {&#13;
                // Unknown node, just return 0x0;&#13;
                return 0x0;&#13;
            }&#13;
&#13;
            Node memory child;&#13;
&#13;
            if (currentNode.left != 0x0) {&#13;
                // Trace left to latest child in left tree.&#13;
                child = index.nodes[currentNode.left];&#13;
&#13;
                while (child.right != 0) {&#13;
                    child = index.nodes[child.right];&#13;
                }&#13;
                return child.id;&#13;
            }&#13;
&#13;
            if (currentNode.parent != 0x0) {&#13;
                // Now we trace back up through parent relationships, looking&#13;
                // for a link where the child is the right child of it's&#13;
                // parent.&#13;
                Node storage parent = index.nodes[currentNode.parent];&#13;
                child = currentNode;&#13;
&#13;
                while (true) {&#13;
                    if (parent.right == child.id) {&#13;
                        return parent.id;&#13;
                    }&#13;
&#13;
                    if (parent.parent == 0x0) {&#13;
                        break;&#13;
                    }&#13;
                    child = parent;&#13;
                    parent = index.nodes[parent.parent];&#13;
                }&#13;
            }&#13;
&#13;
            // This is the first node, and has no previous node.&#13;
            return 0x0;&#13;
        }&#13;
&#13;
        /// @dev Retrieve the node id of the previous node in the tree.&#13;
        /// @param index The index that the node is part of.&#13;
        /// @param id The id for the node to be looked up.&#13;
        function getNextNode(Index storage index, bytes32 id) constant returns (bytes32) {&#13;
            Node storage currentNode = index.nodes[id];&#13;
&#13;
            if (currentNode.id == 0x0) {&#13;
                // Unknown node, just return 0x0;&#13;
                return 0x0;&#13;
            }&#13;
&#13;
            Node memory child;&#13;
&#13;
            if (currentNode.right != 0x0) {&#13;
                // Trace right to earliest child in right tree.&#13;
                child = index.nodes[currentNode.right];&#13;
&#13;
                while (child.left != 0) {&#13;
                    child = index.nodes[child.left];&#13;
                }&#13;
                return child.id;&#13;
            }&#13;
&#13;
            if (currentNode.parent != 0x0) {&#13;
                // if the node is the left child of it's parent, then the&#13;
                // parent is the next one.&#13;
                Node storage parent = index.nodes[currentNode.parent];&#13;
                child = currentNode;&#13;
&#13;
                while (true) {&#13;
                    if (parent.left == child.id) {&#13;
                        return parent.id;&#13;
                    }&#13;
&#13;
                    if (parent.parent == 0x0) {&#13;
                        break;&#13;
                    }&#13;
                    child = parent;&#13;
                    parent = index.nodes[parent.parent];&#13;
                }&#13;
&#13;
                // Now we need to trace all the way up checking to see if any parent is the&#13;
            }&#13;
&#13;
            // This is the final node.&#13;
            return 0x0;&#13;
        }&#13;
&#13;
&#13;
        /// @dev Updates or Inserts the id into the index at its appropriate location based on the value provided.&#13;
        /// @param index The index that the node is part of.&#13;
        /// @param id The unique identifier of the data element the index node will represent.&#13;
        /// @param value The value of the data element that represents it's total ordering with respect to other elementes.&#13;
        function insert(Index storage index, bytes32 id, int value) public {&#13;
                if (index.nodes[id].id == id) {&#13;
                    // A node with this id already exists.  If the value is&#13;
                    // the same, then just return early, otherwise, remove it&#13;
                    // and reinsert it.&#13;
                    if (index.nodes[id].value == value) {&#13;
                        return;&#13;
                    }&#13;
                    remove(index, id);&#13;
                }&#13;
&#13;
                bytes32 previousNodeId = 0x0;&#13;
&#13;
                if (index.root == 0x0) {&#13;
                    index.root = id;&#13;
                }&#13;
                Node storage currentNode = index.nodes[index.root];&#13;
&#13;
                // Do insertion&#13;
                while (true) {&#13;
                    if (currentNode.id == 0x0) {&#13;
                        // This is a new unpopulated node.&#13;
                        currentNode.id = id;&#13;
                        currentNode.parent = previousNodeId;&#13;
                        currentNode.value = value;&#13;
                        break;&#13;
                    }&#13;
&#13;
                    // Set the previous node id.&#13;
                    previousNodeId = currentNode.id;&#13;
&#13;
                    // The new node belongs in the right subtree&#13;
                    if (value &gt;= currentNode.value) {&#13;
                        if (currentNode.right == 0x0) {&#13;
                            currentNode.right = id;&#13;
                        }&#13;
                        currentNode = index.nodes[currentNode.right];&#13;
                        continue;&#13;
                    }&#13;
&#13;
                    // The new node belongs in the left subtree.&#13;
                    if (currentNode.left == 0x0) {&#13;
                        currentNode.left = id;&#13;
                    }&#13;
                    currentNode = index.nodes[currentNode.left];&#13;
                }&#13;
&#13;
                // Rebalance the tree&#13;
                _rebalanceTree(index, currentNode.id);&#13;
        }&#13;
&#13;
        /// @dev Checks whether a node for the given unique identifier exists within the given index.&#13;
        /// @param index The index that should be searched&#13;
        /// @param id The unique identifier of the data element to check for.&#13;
        function exists(Index storage index, bytes32 id) constant returns (bool) {&#13;
            return (index.nodes[id].height &gt; 0);&#13;
        }&#13;
&#13;
        /// @dev Remove the node for the given unique identifier from the index.&#13;
        /// @param index The index that should be removed&#13;
        /// @param id The unique identifier of the data element to remove.&#13;
        function remove(Index storage index, bytes32 id) public {&#13;
            bytes32 rebalanceOrigin;&#13;
&#13;
            Node storage nodeToDelete = index.nodes[id];&#13;
&#13;
            if (nodeToDelete.id != id) {&#13;
                // The id does not exist in the tree.&#13;
                return;&#13;
            }&#13;
&#13;
            if (nodeToDelete.left != 0x0 || nodeToDelete.right != 0x0) {&#13;
                // This node is not a leaf node and thus must replace itself in&#13;
                // it's tree by either the previous or next node.&#13;
                if (nodeToDelete.left != 0x0) {&#13;
                    // This node is guaranteed to not have a right child.&#13;
                    Node storage replacementNode = index.nodes[getPreviousNode(index, nodeToDelete.id)];&#13;
                }&#13;
                else {&#13;
                    // This node is guaranteed to not have a left child.&#13;
                    replacementNode = index.nodes[getNextNode(index, nodeToDelete.id)];&#13;
                }&#13;
                // The replacementNode is guaranteed to have a parent.&#13;
                Node storage parent = index.nodes[replacementNode.parent];&#13;
&#13;
                // Keep note of the location that our tree rebalancing should&#13;
                // start at.&#13;
                rebalanceOrigin = replacementNode.id;&#13;
&#13;
                // Join the parent of the replacement node with any subtree of&#13;
                // the replacement node.  We can guarantee that the replacement&#13;
                // node has at most one subtree because of how getNextNode and&#13;
                // getPreviousNode are used.&#13;
                if (parent.left == replacementNode.id) {&#13;
                    parent.left = replacementNode.right;&#13;
                    if (replacementNode.right != 0x0) {&#13;
                        Node storage child = index.nodes[replacementNode.right];&#13;
                        child.parent = parent.id;&#13;
                    }&#13;
                }&#13;
                if (parent.right == replacementNode.id) {&#13;
                    parent.right = replacementNode.left;&#13;
                    if (replacementNode.left != 0x0) {&#13;
                        child = index.nodes[replacementNode.left];&#13;
                        child.parent = parent.id;&#13;
                    }&#13;
                }&#13;
&#13;
                // Now we replace the nodeToDelete with the replacementNode.&#13;
                // This includes parent/child relationships for all of the&#13;
                // parent, the left child, and the right child.&#13;
                replacementNode.parent = nodeToDelete.parent;&#13;
                if (nodeToDelete.parent != 0x0) {&#13;
                    parent = index.nodes[nodeToDelete.parent];&#13;
                    if (parent.left == nodeToDelete.id) {&#13;
                        parent.left = replacementNode.id;&#13;
                    }&#13;
                    if (parent.right == nodeToDelete.id) {&#13;
                        parent.right = replacementNode.id;&#13;
                    }&#13;
                }&#13;
                else {&#13;
                    // If the node we are deleting is the root node update the&#13;
                    // index root node pointer.&#13;
                    index.root = replacementNode.id;&#13;
                }&#13;
&#13;
                replacementNode.left = nodeToDelete.left;&#13;
                if (nodeToDelete.left != 0x0) {&#13;
                    child = index.nodes[nodeToDelete.left];&#13;
                    child.parent = replacementNode.id;&#13;
                }&#13;
&#13;
                replacementNode.right = nodeToDelete.right;&#13;
                if (nodeToDelete.right != 0x0) {&#13;
                    child = index.nodes[nodeToDelete.right];&#13;
                    child.parent = replacementNode.id;&#13;
                }&#13;
            }&#13;
            else if (nodeToDelete.parent != 0x0) {&#13;
                // The node being deleted is a leaf node so we only erase it's&#13;
                // parent linkage.&#13;
                parent = index.nodes[nodeToDelete.parent];&#13;
&#13;
                if (parent.left == nodeToDelete.id) {&#13;
                    parent.left = 0x0;&#13;
                }&#13;
                if (parent.right == nodeToDelete.id) {&#13;
                    parent.right = 0x0;&#13;
                }&#13;
&#13;
                // keep note of where the rebalancing should begin.&#13;
                rebalanceOrigin = parent.id;&#13;
            }&#13;
            else {&#13;
                // This is both a leaf node and the root node, so we need to&#13;
                // unset the root node pointer.&#13;
                index.root = 0x0;&#13;
            }&#13;
&#13;
            // Now we zero out all of the fields on the nodeToDelete.&#13;
            nodeToDelete.id = 0x0;&#13;
            nodeToDelete.value = 0;&#13;
            nodeToDelete.parent = 0x0;&#13;
            nodeToDelete.left = 0x0;&#13;
            nodeToDelete.right = 0x0;&#13;
            nodeToDelete.height = 0;&#13;
&#13;
            // Walk back up the tree rebalancing&#13;
            if (rebalanceOrigin != 0x0) {&#13;
                _rebalanceTree(index, rebalanceOrigin);&#13;
            }&#13;
        }&#13;
&#13;
        bytes2 constant GT = "&gt;";&#13;
        bytes2 constant LT = "&lt;";&#13;
        bytes2 constant GTE = "&gt;=";&#13;
        bytes2 constant LTE = "&lt;=";&#13;
        bytes2 constant EQ = "==";&#13;
&#13;
        function _compare(int left, bytes2 operator, int right) internal returns (bool) {&#13;
            require(&#13;
                operator == GT || operator == LT || operator == GTE ||&#13;
                operator == LTE || operator == EQ&#13;
            );&#13;
&#13;
            if (operator == GT) {&#13;
                return (left &gt; right);&#13;
            }&#13;
            if (operator == LT) {&#13;
                return (left &lt; right);&#13;
            }&#13;
            if (operator == GTE) {&#13;
                return (left &gt;= right);&#13;
            }&#13;
            if (operator == LTE) {&#13;
                return (left &lt;= right);&#13;
            }&#13;
            if (operator == EQ) {&#13;
                return (left == right);&#13;
            }&#13;
        }&#13;
&#13;
        function _getMaximum(Index storage index, bytes32 id) internal returns (int) {&#13;
                Node storage currentNode = index.nodes[id];&#13;
&#13;
                while (true) {&#13;
                    if (currentNode.right == 0x0) {&#13;
                        return currentNode.value;&#13;
                    }&#13;
                    currentNode = index.nodes[currentNode.right];&#13;
                }&#13;
        }&#13;
&#13;
        function _getMinimum(Index storage index, bytes32 id) internal returns (int) {&#13;
                Node storage currentNode = index.nodes[id];&#13;
&#13;
                while (true) {&#13;
                    if (currentNode.left == 0x0) {&#13;
                        return currentNode.value;&#13;
                    }&#13;
                    currentNode = index.nodes[currentNode.left];&#13;
                }&#13;
        }&#13;
&#13;
&#13;
        /** @dev Query the index for the edge-most node that satisfies the&#13;
         *  given query.  For &gt;, &gt;=, and ==, this will be the left-most node&#13;
         *  that satisfies the comparison.  For &lt; and &lt;= this will be the&#13;
         *  right-most node that satisfies the comparison.&#13;
         */&#13;
        /// @param index The index that should be queried&#13;
        /** @param operator One of '&gt;', '&gt;=', '&lt;', '&lt;=', '==' to specify what&#13;
         *  type of comparison operator should be used.&#13;
         */&#13;
        function query(Index storage index, bytes2 operator, int value) public returns (bytes32) {&#13;
                bytes32 rootNodeId = index.root;&#13;
&#13;
                if (rootNodeId == 0x0) {&#13;
                    // Empty tree.&#13;
                    return 0x0;&#13;
                }&#13;
&#13;
                Node storage currentNode = index.nodes[rootNodeId];&#13;
&#13;
                while (true) {&#13;
                    if (_compare(currentNode.value, operator, value)) {&#13;
                        // We have found a match but it might not be the&#13;
                        // *correct* match.&#13;
                        if ((operator == LT) || (operator == LTE)) {&#13;
                            // Need to keep traversing right until this is no&#13;
                            // longer true.&#13;
                            if (currentNode.right == 0x0) {&#13;
                                return currentNode.id;&#13;
                            }&#13;
                            if (_compare(_getMinimum(index, currentNode.right), operator, value)) {&#13;
                                // There are still nodes to the right that&#13;
                                // match.&#13;
                                currentNode = index.nodes[currentNode.right];&#13;
                                continue;&#13;
                            }&#13;
                            return currentNode.id;&#13;
                        }&#13;
&#13;
                        if ((operator == GT) || (operator == GTE) || (operator == EQ)) {&#13;
                            // Need to keep traversing left until this is no&#13;
                            // longer true.&#13;
                            if (currentNode.left == 0x0) {&#13;
                                return currentNode.id;&#13;
                            }&#13;
                            if (_compare(_getMaximum(index, currentNode.left), operator, value)) {&#13;
                                currentNode = index.nodes[currentNode.left];&#13;
                                continue;&#13;
                            }&#13;
                            return currentNode.id;&#13;
                        }&#13;
                    }&#13;
&#13;
                    if ((operator == LT) || (operator == LTE)) {&#13;
                        if (currentNode.left == 0x0) {&#13;
                            // There are no nodes that are less than the value&#13;
                            // so return null.&#13;
                            return 0x0;&#13;
                        }&#13;
                        currentNode = index.nodes[currentNode.left];&#13;
                        continue;&#13;
                    }&#13;
&#13;
                    if ((operator == GT) || (operator == GTE)) {&#13;
                        if (currentNode.right == 0x0) {&#13;
                            // There are no nodes that are greater than the value&#13;
                            // so return null.&#13;
                            return 0x0;&#13;
                        }&#13;
                        currentNode = index.nodes[currentNode.right];&#13;
                        continue;&#13;
                    }&#13;
&#13;
                    if (operator == EQ) {&#13;
                        if (currentNode.value &lt; value) {&#13;
                            if (currentNode.right == 0x0) {&#13;
                                return 0x0;&#13;
                            }&#13;
                            currentNode = index.nodes[currentNode.right];&#13;
                            continue;&#13;
                        }&#13;
&#13;
                        if (currentNode.value &gt; value) {&#13;
                            if (currentNode.left == 0x0) {&#13;
                                return 0x0;&#13;
                            }&#13;
                            currentNode = index.nodes[currentNode.left];&#13;
                            continue;&#13;
                        }&#13;
                    }&#13;
                }&#13;
        }&#13;
&#13;
        function _rebalanceTree(Index storage index, bytes32 id) internal {&#13;
            // Trace back up rebalancing the tree and updating heights as&#13;
            // needed..&#13;
            Node storage currentNode = index.nodes[id];&#13;
&#13;
            while (true) {&#13;
                int balanceFactor = _getBalanceFactor(index, currentNode.id);&#13;
&#13;
                if (balanceFactor == 2) {&#13;
                    // Right rotation (tree is heavy on the left)&#13;
                    if (_getBalanceFactor(index, currentNode.left) == -1) {&#13;
                        // The subtree is leaning right so it need to be&#13;
                        // rotated left before the current node is rotated&#13;
                        // right.&#13;
                        _rotateLeft(index, currentNode.left);&#13;
                    }&#13;
                    _rotateRight(index, currentNode.id);&#13;
                }&#13;
&#13;
                if (balanceFactor == -2) {&#13;
                    // Left rotation (tree is heavy on the right)&#13;
                    if (_getBalanceFactor(index, currentNode.right) == 1) {&#13;
                        // The subtree is leaning left so it need to be&#13;
                        // rotated right before the current node is rotated&#13;
                        // left.&#13;
                        _rotateRight(index, currentNode.right);&#13;
                    }&#13;
                    _rotateLeft(index, currentNode.id);&#13;
                }&#13;
&#13;
                if ((-1 &lt;= balanceFactor) &amp;&amp; (balanceFactor &lt;= 1)) {&#13;
                    _updateNodeHeight(index, currentNode.id);&#13;
                }&#13;
&#13;
                if (currentNode.parent == 0x0) {&#13;
                    // Reached the root which may be new due to tree&#13;
                    // rotation, so set it as the root and then break.&#13;
                    break;&#13;
                }&#13;
&#13;
                currentNode = index.nodes[currentNode.parent];&#13;
            }&#13;
        }&#13;
&#13;
        function _getBalanceFactor(Index storage index, bytes32 id) internal returns (int) {&#13;
                Node storage node = index.nodes[id];&#13;
&#13;
                return int(index.nodes[node.left].height) - int(index.nodes[node.right].height);&#13;
        }&#13;
&#13;
        function _updateNodeHeight(Index storage index, bytes32 id) internal {&#13;
                Node storage node = index.nodes[id];&#13;
&#13;
                node.height = max(index.nodes[node.left].height, index.nodes[node.right].height) + 1;&#13;
        }&#13;
&#13;
        function _rotateLeft(Index storage index, bytes32 id) internal {&#13;
            Node storage originalRoot = index.nodes[id];&#13;
&#13;
            // Cannot rotate left if there is no right originalRoot to rotate into&#13;
            // place.&#13;
            assert(originalRoot.right != 0x0);&#13;
&#13;
            // The right child is the new root, so it gets the original&#13;
            // `originalRoot.parent` as it's parent.&#13;
            Node storage newRoot = index.nodes[originalRoot.right];&#13;
            newRoot.parent = originalRoot.parent;&#13;
&#13;
            // The original root needs to have it's right child nulled out.&#13;
            originalRoot.right = 0x0;&#13;
&#13;
            if (originalRoot.parent != 0x0) {&#13;
                // If there is a parent node, it needs to now point downward at&#13;
                // the newRoot which is rotating into the place where `node` was.&#13;
                Node storage parent = index.nodes[originalRoot.parent];&#13;
&#13;
                // figure out if we're a left or right child and have the&#13;
                // parent point to the new node.&#13;
                if (parent.left == originalRoot.id) {&#13;
                    parent.left = newRoot.id;&#13;
                }&#13;
                if (parent.right == originalRoot.id) {&#13;
                    parent.right = newRoot.id;&#13;
                }&#13;
            }&#13;
&#13;
&#13;
            if (newRoot.left != 0) {&#13;
                // If the new root had a left child, that moves to be the&#13;
                // new right child of the original root node&#13;
                Node storage leftChild = index.nodes[newRoot.left];&#13;
                originalRoot.right = leftChild.id;&#13;
                leftChild.parent = originalRoot.id;&#13;
            }&#13;
&#13;
            // Update the newRoot's left node to point at the original node.&#13;
            originalRoot.parent = newRoot.id;&#13;
            newRoot.left = originalRoot.id;&#13;
&#13;
            if (newRoot.parent == 0x0) {&#13;
                index.root = newRoot.id;&#13;
            }&#13;
&#13;
            // TODO: are both of these updates necessary?&#13;
            _updateNodeHeight(index, originalRoot.id);&#13;
            _updateNodeHeight(index, newRoot.id);&#13;
        }&#13;
&#13;
        function _rotateRight(Index storage index, bytes32 id) internal {&#13;
            Node storage originalRoot = index.nodes[id];&#13;
&#13;
            // Cannot rotate right if there is no left node to rotate into&#13;
            // place.&#13;
            assert(originalRoot.left != 0x0);&#13;
&#13;
            // The left child is taking the place of node, so we update it's&#13;
            // parent to be the original parent of the node.&#13;
            Node storage newRoot = index.nodes[originalRoot.left];&#13;
            newRoot.parent = originalRoot.parent;&#13;
&#13;
            // Null out the originalRoot.left&#13;
            originalRoot.left = 0x0;&#13;
&#13;
            if (originalRoot.parent != 0x0) {&#13;
                // If the node has a parent, update the correct child to point&#13;
                // at the newRoot now.&#13;
                Node storage parent = index.nodes[originalRoot.parent];&#13;
&#13;
                if (parent.left == originalRoot.id) {&#13;
                    parent.left = newRoot.id;&#13;
                }&#13;
                if (parent.right == originalRoot.id) {&#13;
                    parent.right = newRoot.id;&#13;
                }&#13;
            }&#13;
&#13;
            if (newRoot.right != 0x0) {&#13;
                Node storage rightChild = index.nodes[newRoot.right];&#13;
                originalRoot.left = newRoot.right;&#13;
                rightChild.parent = originalRoot.id;&#13;
            }&#13;
&#13;
            // Update the new root's right node to point to the original node.&#13;
            originalRoot.parent = newRoot.id;&#13;
            newRoot.right = originalRoot.id;&#13;
&#13;
            if (newRoot.parent == 0x0) {&#13;
                index.root = newRoot.id;&#13;
            }&#13;
&#13;
            // Recompute heights.&#13;
            _updateNodeHeight(index, originalRoot.id);&#13;
            _updateNodeHeight(index, newRoot.id);&#13;
        }&#13;
}