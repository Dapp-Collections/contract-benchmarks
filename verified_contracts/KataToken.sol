// Sources flattened with buidler v0.1.5
pragma solidity 0.4.24;


// File openzeppelin-solidity/contracts/token/ERC20/<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="430a06110071736d302c2f0335726d72716d73">[email protected]</a>&#13;
&#13;
/**&#13;
 * @title ERC20 interface&#13;
 * @dev see https://github.com/ethereum/EIPs/issues/20&#13;
 */&#13;
interface IERC20 {&#13;
  function totalSupply() external view returns (uint256);&#13;
&#13;
  function balanceOf(address _who) external view returns (uint256);&#13;
&#13;
  function allowance(address _owner, address _spender)&#13;
    external view returns (uint256);&#13;
&#13;
  function transfer(address _to, uint256 _value) external returns (bool);&#13;
&#13;
  function approve(address _spender, uint256 _value)&#13;
    external returns (bool);&#13;
&#13;
  function transferFrom(address _from, address _to, uint256 _value)&#13;
    external returns (bool);&#13;
&#13;
  event Transfer(&#13;
    address indexed from,&#13;
    address indexed to,&#13;
    uint256 value&#13;
  );&#13;
&#13;
  event Approval(&#13;
    address indexed owner,&#13;
    address indexed spender,&#13;
    uint256 value&#13;
  );&#13;
}&#13;
&#13;
&#13;
// File openzeppelin-solidity/contracts/math/<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="9dcefcfbf8d0fce9f5b3eef2f1ddebacb3acafb3ad">[email protected]</a>&#13;
&#13;
/**&#13;
 * @title SafeMath&#13;
 * @dev Math operations with safety checks that revert on error&#13;
 */&#13;
library SafeMath {&#13;
&#13;
  /**&#13;
  * @dev Multiplies two numbers, reverts on overflow.&#13;
  */&#13;
  function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {&#13;
    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the&#13;
    // benefit is lost if 'b' is also tested.&#13;
    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522&#13;
    if (_a == 0) {&#13;
      return 0;&#13;
    }&#13;
&#13;
    uint256 c = _a * _b;&#13;
    require(c / _a == _b);&#13;
&#13;
    return c;&#13;
  }&#13;
&#13;
  /**&#13;
  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.&#13;
  */&#13;
  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {&#13;
    require(_b &gt; 0); // Solidity only automatically asserts when dividing by 0&#13;
    uint256 c = _a / _b;&#13;
    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold&#13;
&#13;
    return c;&#13;
  }&#13;
&#13;
  /**&#13;
  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).&#13;
  */&#13;
  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {&#13;
    require(_b &lt;= _a);&#13;
    uint256 c = _a - _b;&#13;
&#13;
    return c;&#13;
  }&#13;
&#13;
  /**&#13;
  * @dev Adds two numbers, reverts on overflow.&#13;
  */&#13;
  function add(uint256 _a, uint256 _b) internal pure returns (uint256) {&#13;
    uint256 c = _a + _b;&#13;
    require(c &gt;= _a);&#13;
&#13;
    return c;&#13;
  }&#13;
&#13;
  /**&#13;
  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),&#13;
  * reverts when dividing by zero.&#13;
  */&#13;
  function mod(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
    require(b != 0);&#13;
    return a % b;&#13;
  }&#13;
}&#13;
&#13;
&#13;
// File openzeppelin-solidity/contracts/token/ERC20/<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="83c6d1c0b1b3adf0ecefc3f5b2adb2b1adb3">[email protected]</a>&#13;
&#13;
/**&#13;
 * @title Standard ERC20 token&#13;
 *&#13;
 * @dev Implementation of the basic standard token.&#13;
 * https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md&#13;
 * Originally based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol&#13;
 */&#13;
contract ERC20 is IERC20 {&#13;
  using SafeMath for uint256;&#13;
&#13;
  mapping (address =&gt; uint256) private balances_;&#13;
&#13;
  mapping (address =&gt; mapping (address =&gt; uint256)) private allowed_;&#13;
&#13;
  uint256 private totalSupply_;&#13;
&#13;
  /**&#13;
  * @dev Total number of tokens in existence&#13;
  */&#13;
  function totalSupply() public view returns (uint256) {&#13;
    return totalSupply_;&#13;
  }&#13;
&#13;
  /**&#13;
  * @dev Gets the balance of the specified address.&#13;
  * @param _owner The address to query the the balance of.&#13;
  * @return An uint256 representing the amount owned by the passed address.&#13;
  */&#13;
  function balanceOf(address _owner) public view returns (uint256) {&#13;
    return balances_[_owner];&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Function to check the amount of tokens that an owner allowed to a spender.&#13;
   * @param _owner address The address which owns the funds.&#13;
   * @param _spender address The address which will spend the funds.&#13;
   * @return A uint256 specifying the amount of tokens still available for the spender.&#13;
   */&#13;
  function allowance(&#13;
    address _owner,&#13;
    address _spender&#13;
   )&#13;
    public&#13;
    view&#13;
    returns (uint256)&#13;
  {&#13;
    return allowed_[_owner][_spender];&#13;
  }&#13;
&#13;
  /**&#13;
  * @dev Transfer token for a specified address&#13;
  * @param _to The address to transfer to.&#13;
  * @param _value The amount to be transferred.&#13;
  */&#13;
  function transfer(address _to, uint256 _value) public returns (bool) {&#13;
    require(_value &lt;= balances_[msg.sender]);&#13;
    require(_to != address(0));&#13;
&#13;
    balances_[msg.sender] = balances_[msg.sender].sub(_value);&#13;
    balances_[_to] = balances_[_to].add(_value);&#13;
    emit Transfer(msg.sender, _to, _value);&#13;
    return true;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.&#13;
   * Beware that changing an allowance with this method brings the risk that someone may use both the old&#13;
   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this&#13;
   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:&#13;
   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729&#13;
   * @param _spender The address which will spend the funds.&#13;
   * @param _value The amount of tokens to be spent.&#13;
   */&#13;
  function approve(address _spender, uint256 _value) public returns (bool) {&#13;
    allowed_[msg.sender][_spender] = _value;&#13;
    emit Approval(msg.sender, _spender, _value);&#13;
    return true;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Transfer tokens from one address to another&#13;
   * @param _from address The address which you want to send tokens from&#13;
   * @param _to address The address which you want to transfer to&#13;
   * @param _value uint256 the amount of tokens to be transferred&#13;
   */&#13;
  function transferFrom(&#13;
    address _from,&#13;
    address _to,&#13;
    uint256 _value&#13;
  )&#13;
    public&#13;
    returns (bool)&#13;
  {&#13;
    require(_value &lt;= balances_[_from]);&#13;
    require(_value &lt;= allowed_[_from][msg.sender]);&#13;
    require(_to != address(0));&#13;
&#13;
    balances_[_from] = balances_[_from].sub(_value);&#13;
    balances_[_to] = balances_[_to].add(_value);&#13;
    allowed_[_from][msg.sender] = allowed_[_from][msg.sender].sub(_value);&#13;
    emit Transfer(_from, _to, _value);&#13;
    return true;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Increase the amount of tokens that an owner allowed to a spender.&#13;
   * approve should be called when allowed_[_spender] == 0. To increment&#13;
   * allowed value is better to use this function to avoid 2 calls (and wait until&#13;
   * the first transaction is mined)&#13;
   * From MonolithDAO Token.sol&#13;
   * @param _spender The address which will spend the funds.&#13;
   * @param _addedValue The amount of tokens to increase the allowance by.&#13;
   */&#13;
  function increaseApproval(&#13;
    address _spender,&#13;
    uint256 _addedValue&#13;
  )&#13;
    public&#13;
    returns (bool)&#13;
  {&#13;
    allowed_[msg.sender][_spender] = (&#13;
      allowed_[msg.sender][_spender].add(_addedValue));&#13;
    emit Approval(msg.sender, _spender, allowed_[msg.sender][_spender]);&#13;
    return true;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Decrease the amount of tokens that an owner allowed to a spender.&#13;
   * approve should be called when allowed_[_spender] == 0. To decrement&#13;
   * allowed value is better to use this function to avoid 2 calls (and wait until&#13;
   * the first transaction is mined)&#13;
   * From MonolithDAO Token.sol&#13;
   * @param _spender The address which will spend the funds.&#13;
   * @param _subtractedValue The amount of tokens to decrease the allowance by.&#13;
   */&#13;
  function decreaseApproval(&#13;
    address _spender,&#13;
    uint256 _subtractedValue&#13;
  )&#13;
    public&#13;
    returns (bool)&#13;
  {&#13;
    uint256 oldValue = allowed_[msg.sender][_spender];&#13;
    if (_subtractedValue &gt;= oldValue) {&#13;
      allowed_[msg.sender][_spender] = 0;&#13;
    } else {&#13;
      allowed_[msg.sender][_spender] = oldValue.sub(_subtractedValue);&#13;
    }&#13;
    emit Approval(msg.sender, _spender, allowed_[msg.sender][_spender]);&#13;
    return true;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Internal function that mints an amount of the token and assigns it to&#13;
   * an account. This encapsulates the modification of balances such that the&#13;
   * proper events are emitted.&#13;
   * @param _account The account that will receive the created tokens.&#13;
   * @param _amount The amount that will be created.&#13;
   */&#13;
  function _mint(address _account, uint256 _amount) internal {&#13;
    require(_account != 0);&#13;
    totalSupply_ = totalSupply_.add(_amount);&#13;
    balances_[_account] = balances_[_account].add(_amount);&#13;
    emit Transfer(address(0), _account, _amount);&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Internal function that burns an amount of the token of a given&#13;
   * account.&#13;
   * @param _account The account whose tokens will be burnt.&#13;
   * @param _amount The amount that will be burnt.&#13;
   */&#13;
  function _burn(address _account, uint256 _amount) internal {&#13;
    require(_account != 0);&#13;
    require(_amount &lt;= balances_[_account]);&#13;
&#13;
    totalSupply_ = totalSupply_.sub(_amount);&#13;
    balances_[_account] = balances_[_account].sub(_amount);&#13;
    emit Transfer(_account, address(0), _amount);&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Internal function that burns an amount of the token of a given&#13;
   * account, deducting from the sender's allowance for said account. Uses the&#13;
   * internal _burn function.&#13;
   * @param _account The account whose tokens will be burnt.&#13;
   * @param _amount The amount that will be burnt.&#13;
   */&#13;
  function _burnFrom(address _account, uint256 _amount) internal {&#13;
    require(_amount &lt;= allowed_[_account][msg.sender]);&#13;
&#13;
    // Should https://github.com/OpenZeppelin/zeppelin-solidity/issues/707 be accepted,&#13;
    // this function needs to emit an event with the updated approval.&#13;
    allowed_[_account][msg.sender] = allowed_[_account][msg.sender].sub(&#13;
      _amount);&#13;
    _burn(_account, _amount);&#13;
  }&#13;
}&#13;
&#13;
&#13;
// File openzeppelin-solidity/contracts/token/ERC20/<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="752614131030273647455b061a193503445b44475b45">[email protected]</a>&#13;
&#13;
/**&#13;
 * @title SafeERC20&#13;
 * @dev Wrappers around ERC20 operations that throw on failure.&#13;
 * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,&#13;
 * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.&#13;
 */&#13;
library SafeERC20 {&#13;
  function safeTransfer(&#13;
    IERC20 _token,&#13;
    address _to,&#13;
    uint256 _value&#13;
  )&#13;
    internal&#13;
  {&#13;
    require(_token.transfer(_to, _value));&#13;
  }&#13;
&#13;
  function safeTransferFrom(&#13;
    IERC20 _token,&#13;
    address _from,&#13;
    address _to,&#13;
    uint256 _value&#13;
  )&#13;
    internal&#13;
  {&#13;
    require(_token.transferFrom(_from, _to, _value));&#13;
  }&#13;
&#13;
  function safeApprove(&#13;
    IERC20 _token,&#13;
    address _spender,&#13;
    uint256 _value&#13;
  )&#13;
    internal&#13;
  {&#13;
    require(_token.approve(_spender, _value));&#13;
  }&#13;
}&#13;
&#13;
&#13;
// File openzeppelin-solidity/contracts/ownership/<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="6728100906050b024914080b2711564956554957">[email protected]</a>&#13;
&#13;
/**&#13;
 * @title Ownable&#13;
 * @dev The Ownable contract has an owner address, and provides basic authorization control&#13;
 * functions, this simplifies the implementation of "user permissions".&#13;
 */&#13;
contract Ownable {&#13;
  address public owner;&#13;
&#13;
&#13;
  event OwnershipRenounced(address indexed previousOwner);&#13;
  event OwnershipTransferred(&#13;
    address indexed previousOwner,&#13;
    address indexed newOwner&#13;
  );&#13;
&#13;
&#13;
  /**&#13;
   * @dev The Ownable constructor sets the original `owner` of the contract to the sender&#13;
   * account.&#13;
   */&#13;
  constructor() public {&#13;
    owner = msg.sender;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Throws if called by any account other than the owner.&#13;
   */&#13;
  modifier onlyOwner() {&#13;
    require(msg.sender == owner);&#13;
    _;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Allows the current owner to relinquish control of the contract.&#13;
   * @notice Renouncing to ownership will leave the contract without an owner.&#13;
   * It will not be possible to call the functions with the `onlyOwner`&#13;
   * modifier anymore.&#13;
   */&#13;
  function renounceOwnership() public onlyOwner {&#13;
    emit OwnershipRenounced(owner);&#13;
    owner = address(0);&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Allows the current owner to transfer control of the contract to a newOwner.&#13;
   * @param _newOwner The address to transfer ownership to.&#13;
   */&#13;
  function transferOwnership(address _newOwner) public onlyOwner {&#13;
    _transferOwnership(_newOwner);&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Transfers control of the contract to a newOwner.&#13;
   * @param _newOwner The address to transfer ownership to.&#13;
   */&#13;
  function _transferOwnership(address _newOwner) internal {&#13;
    require(_newOwner != address(0));&#13;
    emit OwnershipTransferred(owner, _newOwner);&#13;
    owner = _newOwner;&#13;
  }&#13;
}&#13;
&#13;
&#13;
// File openzeppelin-solidity/contracts/access/rbac/<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="e8ba87848d9bc69b8784a89ed9c6d9dac6d8">[email protected]</a>&#13;
&#13;
/**&#13;
 * @title Roles&#13;
 * @author Francisco Giordano (@frangio)&#13;
 * @dev Library for managing addresses assigned to a Role.&#13;
 * See RBAC.sol for example usage.&#13;
 */&#13;
library Roles {&#13;
  struct Role {&#13;
    mapping (address =&gt; bool) bearer;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev give an account access to this role&#13;
   */&#13;
  function add(Role storage _role, address _account)&#13;
    internal&#13;
  {&#13;
    _role.bearer[_account] = true;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev remove an account's access to this role&#13;
   */&#13;
  function remove(Role storage _role, address _account)&#13;
    internal&#13;
  {&#13;
    _role.bearer[_account] = false;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev check if an account has this role&#13;
   * // reverts&#13;
   */&#13;
  function check(Role storage _role, address _account)&#13;
    internal&#13;
    view&#13;
  {&#13;
    require(has(_role, _account));&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev check if an account has this role&#13;
   * @return bool&#13;
   */&#13;
  function has(Role storage _role, address _account)&#13;
    internal&#13;
    view&#13;
    returns (bool)&#13;
  {&#13;
    return _role.bearer[_account];&#13;
  }&#13;
}&#13;
&#13;
&#13;
// File openzeppelin-solidity/contracts/access/rbac/<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="8ddfcfcccea3fee2e1cdfbbca3bcbfa3bd">[email protected]</a>&#13;
&#13;
/**&#13;
 * @title RBAC (Role-Based Access Control)&#13;
 * @author Matt Condon (@Shrugs)&#13;
 * @dev Stores and provides setters and getters for roles and addresses.&#13;
 * Supports unlimited numbers of roles and addresses.&#13;
 * See //contracts/mocks/RBACMock.sol for an example of usage.&#13;
 * This RBAC method uses strings to key roles. It may be beneficial&#13;
 * for you to write your own implementation of this interface using Enums or similar.&#13;
 */&#13;
contract RBAC {&#13;
  using Roles for Roles.Role;&#13;
&#13;
  mapping (string =&gt; Roles.Role) private roles;&#13;
&#13;
  event RoleAdded(address indexed operator, string role);&#13;
  event RoleRemoved(address indexed operator, string role);&#13;
&#13;
  /**&#13;
   * @dev reverts if addr does not have role&#13;
   * @param _operator address&#13;
   * @param _role the name of the role&#13;
   * // reverts&#13;
   */&#13;
  function checkRole(address _operator, string _role)&#13;
    public&#13;
    view&#13;
  {&#13;
    roles[_role].check(_operator);&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev determine if addr has role&#13;
   * @param _operator address&#13;
   * @param _role the name of the role&#13;
   * @return bool&#13;
   */&#13;
  function hasRole(address _operator, string _role)&#13;
    public&#13;
    view&#13;
    returns (bool)&#13;
  {&#13;
    return roles[_role].has(_operator);&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev add a role to an address&#13;
   * @param _operator address&#13;
   * @param _role the name of the role&#13;
   */&#13;
  function _addRole(address _operator, string _role)&#13;
    internal&#13;
  {&#13;
    roles[_role].add(_operator);&#13;
    emit RoleAdded(_operator, _role);&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev remove a role from an address&#13;
   * @param _operator address&#13;
   * @param _role the name of the role&#13;
   */&#13;
  function _removeRole(address _operator, string _role)&#13;
    internal&#13;
  {&#13;
    roles[_role].remove(_operator);&#13;
    emit RoleRemoved(_operator, _role);&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev modifier to scope access to a single role (uses msg.sender as addr)&#13;
   * @param _role the name of the role&#13;
   * // reverts&#13;
   */&#13;
  modifier onlyRole(string _role)&#13;
  {&#13;
    checkRole(msg.sender, _role);&#13;
    _;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev modifier to scope access to a set of roles (uses msg.sender as addr)&#13;
   * @param _roles the names of the roles to scope access to&#13;
   * // reverts&#13;
   *&#13;
   * @TODO - when solidity supports dynamic arrays as arguments to modifiers, provide this&#13;
   *  see: https://github.com/ethereum/solidity/issues/2467&#13;
   */&#13;
  // modifier onlyRoles(string[] _roles) {&#13;
  //     bool hasAnyRole = false;&#13;
  //     for (uint8 i = 0; i &lt; _roles.length; i++) {&#13;
  //         if (hasRole(msg.sender, _roles[i])) {&#13;
  //             hasAnyRole = true;&#13;
  //             break;&#13;
  //         }&#13;
  //     }&#13;
&#13;
  //     require(hasAnyRole);&#13;
&#13;
  //     _;&#13;
  // }&#13;
}&#13;
&#13;
&#13;
// File openzeppelin-solidity/contracts/cryptography/<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="5613151205177825393a1620677867647866">[email protected]</a>&#13;
&#13;
/**&#13;
 * @title Elliptic curve signature operations&#13;
 * @dev Based on https://gist.github.com/axic/5b33912c6f61ae6fd96d6c4a47afde6d&#13;
 * TODO Remove this library once solidity supports passing a signature to ecrecover.&#13;
 * See https://github.com/ethereum/solidity/issues/864&#13;
 */&#13;
&#13;
library ECDSA {&#13;
&#13;
  /**&#13;
   * @dev Recover signer address from a message by using their signature&#13;
   * @param _hash bytes32 message, the hash is the signed message. What is recovered is the signer address.&#13;
   * @param _signature bytes signature, the signature is generated using web3.eth.sign()&#13;
   */&#13;
  function recover(bytes32 _hash, bytes _signature)&#13;
    internal&#13;
    pure&#13;
    returns (address)&#13;
  {&#13;
    bytes32 r;&#13;
    bytes32 s;&#13;
    uint8 v;&#13;
&#13;
    // Check the signature length&#13;
    if (_signature.length != 65) {&#13;
      return (address(0));&#13;
    }&#13;
&#13;
    // Divide the signature in r, s and v variables&#13;
    // ecrecover takes the signature parameters, and the only way to get them&#13;
    // currently is to use assembly.&#13;
    // solium-disable-next-line security/no-inline-assembly&#13;
    assembly {&#13;
      r := mload(add(_signature, 32))&#13;
      s := mload(add(_signature, 64))&#13;
      v := byte(0, mload(add(_signature, 96)))&#13;
    }&#13;
&#13;
    // Version of signature should be 27 or 28, but 0 and 1 are also possible versions&#13;
    if (v &lt; 27) {&#13;
      v += 27;&#13;
    }&#13;
&#13;
    // If the version is correct return the signer address&#13;
    if (v != 27 &amp;&amp; v != 28) {&#13;
      return (address(0));&#13;
    } else {&#13;
      // solium-disable-next-line arg-overflow&#13;
      return ecrecover(_hash, v, r, s);&#13;
    }&#13;
  }&#13;
&#13;
  /**&#13;
   * toEthSignedMessageHash&#13;
   * @dev prefix a bytes32 value with "\x19Ethereum Signed Message:"&#13;
   * and hash the result&#13;
   */&#13;
  function toEthSignedMessageHash(bytes32 _hash)&#13;
    internal&#13;
    pure&#13;
    returns (bytes32)&#13;
  {&#13;
    // 32 is the length in bytes of hash,&#13;
    // enforced by the type signature above&#13;
    return keccak256(&#13;
      abi.encodePacked("\x19Ethereum Signed Message:\n32", _hash)&#13;
    );&#13;
  }&#13;
}&#13;
&#13;
&#13;
// File openzeppelin-solidity/contracts/access/<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="095a606e67687d7c7b6c4b667c676a6c7b277a6665497f3827383b2739">[email protected]</a>&#13;
&#13;
/**&#13;
 * @title SignatureBouncer&#13;
 * @author PhABC, Shrugs and aflesher&#13;
 * @dev Bouncer allows users to submit a signature as a permission to do an action.&#13;
 * If the signature is from one of the authorized bouncer addresses, the signature&#13;
 * is valid. The owner of the contract adds/removes bouncers.&#13;
 * Bouncer addresses can be individual servers signing grants or different&#13;
 * users within a decentralized club that have permission to invite other members.&#13;
 * This technique is useful for whitelists and airdrops; instead of putting all&#13;
 * valid addresses on-chain, simply sign a grant of the form&#13;
 * keccak256(abi.encodePacked(`:contractAddress` + `:granteeAddress`)) using a valid bouncer address.&#13;
 * Then restrict access to your crowdsale/whitelist/airdrop using the&#13;
 * `onlyValidSignature` modifier (or implement your own using _isValidSignature).&#13;
 * In addition to `onlyValidSignature`, `onlyValidSignatureAndMethod` and&#13;
 * `onlyValidSignatureAndData` can be used to restrict access to only a given method&#13;
 * or a given method with given parameters respectively.&#13;
 * See the tests Bouncer.test.js for specific usage examples.&#13;
 * @notice A method that uses the `onlyValidSignatureAndData` modifier must make the _signature&#13;
 * parameter the "last" parameter. You cannot sign a message that has its own&#13;
 * signature in it so the last 128 bytes of msg.data (which represents the&#13;
 * length of the _signature data and the _signaature data itself) is ignored when validating.&#13;
 * Also non fixed sized parameters make constructing the data in the signature&#13;
 * much more complex. See https://ethereum.stackexchange.com/a/50616 for more details.&#13;
 */&#13;
contract SignatureBouncer is Ownable, RBAC {&#13;
  using ECDSA for bytes32;&#13;
&#13;
  // Name of the bouncer role.&#13;
  string private constant ROLE_BOUNCER = "bouncer";&#13;
  // Function selectors are 4 bytes long, as documented in&#13;
  // https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector&#13;
  uint256 private constant METHOD_ID_SIZE = 4;&#13;
  // Signature size is 65 bytes (tightly packed v + r + s), but gets padded to 96 bytes&#13;
  uint256 private constant SIGNATURE_SIZE = 96;&#13;
&#13;
  /**&#13;
   * @dev requires that a valid signature of a bouncer was provided&#13;
   */&#13;
  modifier onlyValidSignature(bytes _signature)&#13;
  {&#13;
    require(_isValidSignature(msg.sender, _signature));&#13;
    _;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev requires that a valid signature with a specifed method of a bouncer was provided&#13;
   */&#13;
  modifier onlyValidSignatureAndMethod(bytes _signature)&#13;
  {&#13;
    require(_isValidSignatureAndMethod(msg.sender, _signature));&#13;
    _;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev requires that a valid signature with a specifed method and params of a bouncer was provided&#13;
   */&#13;
  modifier onlyValidSignatureAndData(bytes _signature)&#13;
  {&#13;
    require(_isValidSignatureAndData(msg.sender, _signature));&#13;
    _;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Determine if an account has the bouncer role.&#13;
   * @return true if the account is a bouncer, false otherwise.&#13;
   */&#13;
  function isBouncer(address _account) public view returns(bool) {&#13;
    return hasRole(_account, ROLE_BOUNCER);&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev allows the owner to add additional bouncer addresses&#13;
   */&#13;
  function addBouncer(address _bouncer)&#13;
    public&#13;
    onlyOwner&#13;
  {&#13;
    require(_bouncer != address(0));&#13;
    _addRole(_bouncer, ROLE_BOUNCER);&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev allows the owner to remove bouncer addresses&#13;
   */&#13;
  function removeBouncer(address _bouncer)&#13;
    public&#13;
    onlyOwner&#13;
  {&#13;
    _removeRole(_bouncer, ROLE_BOUNCER);&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev is the signature of `this + sender` from a bouncer?&#13;
   * @return bool&#13;
   */&#13;
  function _isValidSignature(address _address, bytes _signature)&#13;
    internal&#13;
    view&#13;
    returns (bool)&#13;
  {&#13;
    return _isValidDataHash(&#13;
      keccak256(abi.encodePacked(address(this), _address)),&#13;
      _signature&#13;
    );&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev is the signature of `this + sender + methodId` from a bouncer?&#13;
   * @return bool&#13;
   */&#13;
  function _isValidSignatureAndMethod(address _address, bytes _signature)&#13;
    internal&#13;
    view&#13;
    returns (bool)&#13;
  {&#13;
    bytes memory data = new bytes(METHOD_ID_SIZE);&#13;
    for (uint i = 0; i &lt; data.length; i++) {&#13;
      data[i] = msg.data[i];&#13;
    }&#13;
    return _isValidDataHash(&#13;
      keccak256(abi.encodePacked(address(this), _address, data)),&#13;
      _signature&#13;
    );&#13;
  }&#13;
&#13;
  /**&#13;
    * @dev is the signature of `this + sender + methodId + params(s)` from a bouncer?&#13;
    * @notice the _signature parameter of the method being validated must be the "last" parameter&#13;
    * @return bool&#13;
    */&#13;
  function _isValidSignatureAndData(address _address, bytes _signature)&#13;
    internal&#13;
    view&#13;
    returns (bool)&#13;
  {&#13;
    require(msg.data.length &gt; SIGNATURE_SIZE);&#13;
    bytes memory data = new bytes(msg.data.length - SIGNATURE_SIZE);&#13;
    for (uint i = 0; i &lt; data.length; i++) {&#13;
      data[i] = msg.data[i];&#13;
    }&#13;
    return _isValidDataHash(&#13;
      keccak256(abi.encodePacked(address(this), _address, data)),&#13;
      _signature&#13;
    );&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev internal function to convert a hash to an eth signed message&#13;
   * and then recover the signature and check it against the bouncer role&#13;
   * @return bool&#13;
   */&#13;
  function _isValidDataHash(bytes32 _hash, bytes _signature)&#13;
    internal&#13;
    view&#13;
    returns (bool)&#13;
  {&#13;
    address signer = _hash&#13;
      .toEthSignedMessageHash()&#13;
      .recover(_signature);&#13;
    return isBouncer(signer);&#13;
  }&#13;
}&#13;
&#13;
&#13;
// File contracts/bouncers/EscrowedERC20Bouncer.sol&#13;
&#13;
contract EscrowedERC20Bouncer is SignatureBouncer {&#13;
  using SafeERC20 for IERC20;&#13;
&#13;
  uint256 public nonce;&#13;
&#13;
  modifier onlyBouncer()&#13;
  {&#13;
    require(isBouncer(msg.sender), "DOES_NOT_HAVE_BOUNCER_ROLE");&#13;
    _;&#13;
  }&#13;
&#13;
  modifier validDataWithoutSender(bytes _signature)&#13;
  {&#13;
    require(_isValidSignatureAndData(address(this), _signature), "INVALID_SIGNATURE");&#13;
    _;&#13;
  }&#13;
&#13;
  constructor(address _bouncer)&#13;
    public&#13;
  {&#13;
    addBouncer(_bouncer);&#13;
  }&#13;
&#13;
  /**&#13;
   * allow anyone with a valid bouncer signature for the msg data to send `_amount` of `_token` to `_to`&#13;
   */&#13;
  function withdraw(uint256 _nonce, IERC20 _token, address _to, uint256 _amount, bytes _signature)&#13;
    public&#13;
    validDataWithoutSender(_signature)&#13;
  {&#13;
    require(_nonce &gt; nonce, "NONCE_GT_NONCE_REQUIRED");&#13;
    nonce = _nonce;&#13;
    _token.safeTransfer(_to, _amount);&#13;
  }&#13;
&#13;
  /**&#13;
   * Allow the bouncer to withdraw all of the ERC20 tokens in the contract&#13;
   */&#13;
  function withdrawAll(IERC20 _token, address _to)&#13;
    public&#13;
    onlyBouncer&#13;
  {&#13;
    _token.safeTransfer(_to, _token.balanceOf(address(this)));&#13;
  }&#13;
}&#13;
&#13;
&#13;
// File openzeppelin-solidity/contracts/token/ERC20/<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="f6b3a4b5c4c6bb9f988297949a93d885999ab680c7d8c7c4d8c6">[email protected]</a>&#13;
&#13;
/**&#13;
 * @title Mintable token&#13;
 * @dev Simple ERC20 Token example, with mintable token creation&#13;
 * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol&#13;
 */&#13;
contract ERC20Mintable is ERC20, Ownable {&#13;
  event Mint(address indexed to, uint256 amount);&#13;
  event MintFinished();&#13;
&#13;
  bool public mintingFinished = false;&#13;
&#13;
&#13;
  modifier canMint() {&#13;
    require(!mintingFinished);&#13;
    _;&#13;
  }&#13;
&#13;
  modifier hasMintPermission() {&#13;
    require(msg.sender == owner);&#13;
    _;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Function to mint tokens&#13;
   * @param _to The address that will receive the minted tokens.&#13;
   * @param _amount The amount of tokens to mint.&#13;
   * @return A boolean that indicates if the operation was successful.&#13;
   */&#13;
  function mint(&#13;
    address _to,&#13;
    uint256 _amount&#13;
  )&#13;
    public&#13;
    hasMintPermission&#13;
    canMint&#13;
    returns (bool)&#13;
  {&#13;
    _mint(_to, _amount);&#13;
    emit Mint(_to, _amount);&#13;
    return true;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Function to stop minting new tokens.&#13;
   * @return True if the operation was successful.&#13;
   */&#13;
  function finishMinting() public onlyOwner canMint returns (bool) {&#13;
    mintingFinished = true;&#13;
    emit MintFinished();&#13;
    return true;&#13;
  }&#13;
}&#13;
&#13;
&#13;
// File contracts/bouncers/MintableERC20Bouncer.sol&#13;
&#13;
contract MintableERC20Bouncer is SignatureBouncer {&#13;
&#13;
  uint256 public nonce;&#13;
&#13;
  modifier validDataWithoutSender(bytes _signature)&#13;
  {&#13;
    require(_isValidSignatureAndData(address(this), _signature), "INVALID_SIGNATURE");&#13;
    _;&#13;
  }&#13;
&#13;
  constructor(address _bouncer)&#13;
    public&#13;
  {&#13;
    addBouncer(_bouncer);&#13;
  }&#13;
&#13;
  /**&#13;
   * allow anyone with a valid bouncer signature for the msg data to mint `_amount` of `_token` to `_to`&#13;
   */&#13;
  function mint(uint256 _nonce, ERC20Mintable _token, address _to, uint256 _amount, bytes _signature)&#13;
    public&#13;
    validDataWithoutSender(_signature)&#13;
  {&#13;
    require(_nonce &gt; nonce, "NONCE_GT_NONCE_REQUIRED");&#13;
    nonce = _nonce;&#13;
    _token.mint(_to, _amount);&#13;
  }&#13;
}&#13;
&#13;
&#13;
// File openzeppelin-solidity/contracts/token/ERC20/<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="9edbccddacaedafbeafff7f2fbfab0edf1f2dee8afb0afacb0ae">[email protected]</a>&#13;
&#13;
/**&#13;
 * @title ERC20Detailed token&#13;
 * @dev The decimals are only for visualization purposes.&#13;
 * All the operations are done using the smallest and indivisible token unit,&#13;
 * just as on Ethereum all the operations are done in wei.&#13;
 */&#13;
contract ERC20Detailed is IERC20 {&#13;
  string public name;&#13;
  string public symbol;&#13;
  uint8 public decimals;&#13;
&#13;
  constructor(string _name, string _symbol, uint8 _decimals) public {&#13;
    name = _name;&#13;
    symbol = _symbol;&#13;
    decimals = _decimals;&#13;
  }&#13;
}&#13;
&#13;
&#13;
// File openzeppelin-solidity/contracts/proposals/ERC1046/<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="9acef5f1fff4d7ffeefbfefbeefbb4e9f5f6daecabb4aba8b4aa">[email protected]</a>&#13;
&#13;
/**&#13;
 * @title ERC-1047 Token Metadata&#13;
 * @dev See https://eips.ethereum.org/EIPS/eip-1046&#13;
 * @dev tokenURI must respond with a URI that implements https://eips.ethereum.org/EIPS/eip-1047&#13;
 * @dev TODO - update https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/token/ERC721/IERC721.sol#L17 when 1046 is finalized&#13;
 */&#13;
contract ERC20TokenMetadata is IERC20 {&#13;
  function tokenURI() external view returns (string);&#13;
}&#13;
&#13;
&#13;
contract ERC20WithMetadata is ERC20TokenMetadata {&#13;
  string private tokenURI_ = "";&#13;
&#13;
  constructor(string _tokenURI)&#13;
    public&#13;
  {&#13;
    tokenURI_ = _tokenURI;&#13;
  }&#13;
&#13;
  function tokenURI() external view returns (string) {&#13;
    return tokenURI_;&#13;
  }&#13;
}&#13;
&#13;
&#13;
// File contracts/tokens/KataToken.sol&#13;
&#13;
contract KataToken is ERC20, ERC20Detailed, ERC20Mintable, ERC20WithMetadata {&#13;
  constructor(&#13;
    string _name,&#13;
    string _symbol,&#13;
    uint8 _decimals,&#13;
    string _tokenURI&#13;
  )&#13;
    ERC20WithMetadata(_tokenURI)&#13;
    ERC20Detailed(_name, _symbol, _decimals)&#13;
    public&#13;
  {}&#13;
}&#13;
&#13;
&#13;
// File contracts/deploy/TokenAndBouncerDeployer.sol&#13;
&#13;
contract TokenAndBouncerDeployer is Ownable {&#13;
  event Deployed(address indexed token, address indexed bouncer);&#13;
&#13;
  function deploy(&#13;
    string _name,&#13;
    string _symbol,&#13;
    uint8 _decimals,&#13;
    string _tokenURI,&#13;
    address _signer&#13;
  )&#13;
    public&#13;
    onlyOwner&#13;
  {&#13;
    MintableERC20Bouncer bouncer = new MintableERC20Bouncer(_signer);&#13;
    KataToken token = new KataToken(_name, _symbol, _decimals, _tokenURI);&#13;
    token.transferOwnership(address(bouncer));&#13;
&#13;
    emit Deployed(address(token), address(bouncer));&#13;
&#13;
    selfdestruct(msg.sender);&#13;
  }&#13;
}&#13;
&#13;
&#13;
// File contracts/mocks/MockToken.sol&#13;
&#13;
contract MockToken is ERC20Detailed, ERC20Mintable {&#13;
  constructor(string _name, string _symbol, uint8 _decimals)&#13;
    ERC20Detailed(_name, _symbol, _decimals)&#13;
    ERC20Mintable()&#13;
    ERC20()&#13;
    public&#13;
  {&#13;
&#13;
  }&#13;
}&#13;
&#13;
&#13;
// File contracts/old/ClaimableToken.sol&#13;
&#13;
// import "./MintableERC721Token.sol";&#13;
// import "openzeppelin-solidity/contracts/token/ERC721/DefaultTokenURI.sol";&#13;
&#13;
&#13;
// contract ClaimableToken is DefaultTokenURI, MintableERC721Token {&#13;
&#13;
//   constructor(string _name, string _symbol, string _tokenURI)&#13;
//     MintableERC721Token(_name, _symbol)&#13;
//     DefaultTokenURI(_tokenURI)&#13;
//     public&#13;
//   {&#13;
&#13;
//   }&#13;
// }&#13;
&#13;
&#13;
// File contracts/old/ClaimableTokenDeployer.sol&#13;
&#13;
// import "./ClaimableTokenMinter.sol";&#13;
// import "./ClaimableToken.sol";&#13;
&#13;
&#13;
// contract ClaimableTokenDeployer {&#13;
//   ClaimableToken public token;&#13;
//   ClaimableTokenMinter public minter;&#13;
&#13;
//   constructor(&#13;
//     string _name,&#13;
//     string _symbol,&#13;
//     string _tokenURI,&#13;
//     address _bouncer&#13;
//   )&#13;
//     public&#13;
//   {&#13;
//     token = new ClaimableToken(_name, _symbol, _tokenURI);&#13;
//     minter = new ClaimableTokenMinter(token);&#13;
//     token.addOwner(msg.sender);&#13;
//     token.addMinter(address(minter));&#13;
//     minter.addOwner(msg.sender);&#13;
//     minter.addBouncer(_bouncer);&#13;
//   }&#13;
// }&#13;
&#13;
&#13;
// File contracts/old/ClaimableTokenMinter.sol&#13;
&#13;
// import "./ClaimableToken.sol";&#13;
// import "openzeppelin-solidity/contracts/access/ERC721Minter.sol";&#13;
// import "openzeppelin-solidity/contracts/access/NonceTracker.sol";&#13;
&#13;
&#13;
// contract ClaimableTokenMinter is NonceTracker, ERC721Minter {&#13;
&#13;
//   constructor(ClaimableToken _token)&#13;
//     ERC721Minter(_token)&#13;
//     public&#13;
//   {&#13;
&#13;
//   }&#13;
&#13;
//   function mint(bytes _sig)&#13;
//     withAccess(msg.sender, 1)&#13;
//     public&#13;
//     returns (uint256)&#13;
//   {&#13;
//     return super.mint(_sig);&#13;
//   }&#13;
// }