pragma solidity ^0.4.17;

/*

 * source       https://github.com/blockbitsio/

 * @name        Application Entity Generic Contract
 * @package     BlockBitsIO
 * @author      Micky Socaci <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="b6dbdfd5ddcff6d8d9c1dadfc0d398c4d9">[email protected]</a>&gt;&#13;
&#13;
    Used for the ABI interface when assets need to call Application Entity.&#13;
&#13;
    This is required, otherwise we end up loading the assets themselves when we load the ApplicationEntity contract&#13;
    and end up in a loop&#13;
*/&#13;
&#13;
&#13;
&#13;
contract ApplicationEntityABI {&#13;
&#13;
    address public ProposalsEntity;&#13;
    address public FundingEntity;&#13;
    address public MilestonesEntity;&#13;
    address public MeetingsEntity;&#13;
    address public BountyManagerEntity;&#13;
    address public TokenManagerEntity;&#13;
    address public ListingContractEntity;&#13;
    address public FundingManagerEntity;&#13;
    address public NewsContractEntity;&#13;
&#13;
    bool public _initialized = false;&#13;
    bool public _locked = false;&#13;
    uint8 public CurrentEntityState;&#13;
    uint8 public AssetCollectionNum;&#13;
    address public GatewayInterfaceAddress;&#13;
    address public deployerAddress;&#13;
    address testAddressAllowUpgradeFrom;&#13;
    mapping (bytes32 =&gt; uint8) public EntityStates;&#13;
    mapping (bytes32 =&gt; address) public AssetCollection;&#13;
    mapping (uint8 =&gt; bytes32) public AssetCollectionIdToName;&#13;
    mapping (bytes32 =&gt; uint256) public BylawsUint256;&#13;
    mapping (bytes32 =&gt; bytes32) public BylawsBytes32;&#13;
&#13;
    function ApplicationEntity() public;&#13;
    function getEntityState(bytes32 name) public view returns (uint8);&#13;
    function linkToGateway( address _GatewayInterfaceAddress, bytes32 _sourceCodeUrl ) external;&#13;
    function setUpgradeState(uint8 state) public ;&#13;
    function addAssetProposals(address _assetAddresses) external;&#13;
    function addAssetFunding(address _assetAddresses) external;&#13;
    function addAssetMilestones(address _assetAddresses) external;&#13;
    function addAssetMeetings(address _assetAddresses) external;&#13;
    function addAssetBountyManager(address _assetAddresses) external;&#13;
    function addAssetTokenManager(address _assetAddresses) external;&#13;
    function addAssetFundingManager(address _assetAddresses) external;&#13;
    function addAssetListingContract(address _assetAddresses) external;&#13;
    function addAssetNewsContract(address _assetAddresses) external;&#13;
    function getAssetAddressByName(bytes32 _name) public view returns (address);&#13;
    function setBylawUint256(bytes32 name, uint256 value) public;&#13;
    function getBylawUint256(bytes32 name) public view returns (uint256);&#13;
    function setBylawBytes32(bytes32 name, bytes32 value) public;&#13;
    function getBylawBytes32(bytes32 name) public view returns (bytes32);&#13;
    function initialize() external returns (bool);&#13;
    function getParentAddress() external view returns(address);&#13;
    function createCodeUpgradeProposal( address _newAddress, bytes32 _sourceCodeUrl ) external returns (uint256);&#13;
    function acceptCodeUpgradeProposal(address _newAddress) external;&#13;
    function initializeAssetsToThisApplication() external returns (bool);&#13;
    function transferAssetsToNewApplication(address _newAddress) external returns (bool);&#13;
    function lock() external returns (bool);&#13;
    function canInitiateCodeUpgrade(address _sender) public view returns(bool);&#13;
    function doStateChanges() public;&#13;
    function hasRequiredStateChanges() public view returns (bool);&#13;
    function anyAssetHasChanges() public view returns (bool);&#13;
    function extendedAnyAssetHasChanges() internal view returns (bool);&#13;
    function getRequiredStateChanges() public view returns (uint8, uint8);&#13;
    function getTimestamp() view public returns (uint256);&#13;
&#13;
}&#13;
&#13;
/*&#13;
&#13;
 * source       https://github.com/blockbitsio/&#13;
&#13;
 * @name        Application Asset Contract&#13;
 * @package     BlockBitsIO&#13;
 * @author      Micky Socaci &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="9cf1f5fff7e5dcf2f3ebf0f5eaf9b2eef3">[email protected]</a>&gt;&#13;
&#13;
 Any contract inheriting this will be usable as an Asset in the Application Entity&#13;
&#13;
*/&#13;
&#13;
&#13;
&#13;
&#13;
contract ApplicationAsset {&#13;
&#13;
    event EventAppAssetOwnerSet(bytes32 indexed _name, address indexed _owner);&#13;
    event EventRunBeforeInit(bytes32 indexed _name);&#13;
    event EventRunBeforeApplyingSettings(bytes32 indexed _name);&#13;
&#13;
&#13;
    mapping (bytes32 =&gt; uint8) public EntityStates;&#13;
    mapping (bytes32 =&gt; uint8) public RecordStates;&#13;
    uint8 public CurrentEntityState;&#13;
&#13;
    event EventEntityProcessor(bytes32 indexed _assetName, uint8 indexed _current, uint8 indexed _required);&#13;
    event DebugEntityRequiredChanges( bytes32 _assetName, uint8 indexed _current, uint8 indexed _required );&#13;
&#13;
    bytes32 public assetName;&#13;
&#13;
    /* Asset records */&#13;
    uint8 public RecordNum = 0;&#13;
&#13;
    /* Asset initialised or not */&#13;
    bool public _initialized = false;&#13;
&#13;
    /* Asset settings present or not */&#13;
    bool public _settingsApplied = false;&#13;
&#13;
    /* Asset owner ( ApplicationEntity address ) */&#13;
    address public owner = address(0x0) ;&#13;
    address public deployerAddress;&#13;
&#13;
    function ApplicationAsset() public {&#13;
        deployerAddress = msg.sender;&#13;
    }&#13;
&#13;
    function setInitialApplicationAddress(address _ownerAddress) public onlyDeployer requireNotInitialised {&#13;
        owner = _ownerAddress;&#13;
    }&#13;
&#13;
    function setInitialOwnerAndName(bytes32 _name) external&#13;
        requireNotInitialised&#13;
        onlyOwner&#13;
        returns (bool)&#13;
    {&#13;
        // init states&#13;
        setAssetStates();&#13;
        assetName = _name;&#13;
        // set initial state&#13;
        CurrentEntityState = getEntityState("NEW");&#13;
        runBeforeInitialization();&#13;
        _initialized = true;&#13;
        EventAppAssetOwnerSet(_name, owner);&#13;
        return true;&#13;
    }&#13;
&#13;
    function setAssetStates() internal {&#13;
        // Asset States&#13;
        EntityStates["__IGNORED__"]     = 0;&#13;
        EntityStates["NEW"]             = 1;&#13;
        // Funding Stage States&#13;
        RecordStates["__IGNORED__"]     = 0;&#13;
    }&#13;
&#13;
    function getRecordState(bytes32 name) public view returns (uint8) {&#13;
        return RecordStates[name];&#13;
    }&#13;
&#13;
    function getEntityState(bytes32 name) public view returns (uint8) {&#13;
        return EntityStates[name];&#13;
    }&#13;
&#13;
    function runBeforeInitialization() internal requireNotInitialised  {&#13;
        EventRunBeforeInit(assetName);&#13;
    }&#13;
&#13;
    function applyAndLockSettings()&#13;
        public&#13;
        onlyDeployer&#13;
        requireInitialised&#13;
        requireSettingsNotApplied&#13;
        returns(bool)&#13;
    {&#13;
        runBeforeApplyingSettings();&#13;
        _settingsApplied = true;&#13;
        return true;&#13;
    }&#13;
&#13;
    function runBeforeApplyingSettings() internal requireInitialised requireSettingsNotApplied  {&#13;
        EventRunBeforeApplyingSettings(assetName);&#13;
    }&#13;
&#13;
    function transferToNewOwner(address _newOwner) public requireInitialised onlyOwner returns (bool) {&#13;
        require(owner != address(0x0) &amp;&amp; _newOwner != address(0x0));&#13;
        owner = _newOwner;&#13;
        EventAppAssetOwnerSet(assetName, owner);&#13;
        return true;&#13;
    }&#13;
&#13;
    function getApplicationAssetAddressByName(bytes32 _name)&#13;
        public&#13;
        view&#13;
        returns(address)&#13;
    {&#13;
        address asset = ApplicationEntityABI(owner).getAssetAddressByName(_name);&#13;
        if( asset != address(0x0) ) {&#13;
            return asset;&#13;
        } else {&#13;
            revert();&#13;
        }&#13;
    }&#13;
&#13;
    function getApplicationState() public view returns (uint8) {&#13;
        return ApplicationEntityABI(owner).CurrentEntityState();&#13;
    }&#13;
&#13;
    function getApplicationEntityState(bytes32 name) public view returns (uint8) {&#13;
        return ApplicationEntityABI(owner).getEntityState(name);&#13;
    }&#13;
&#13;
    function getAppBylawUint256(bytes32 name) public view requireInitialised returns (uint256) {&#13;
        ApplicationEntityABI CurrentApp = ApplicationEntityABI(owner);&#13;
        return CurrentApp.getBylawUint256(name);&#13;
    }&#13;
&#13;
    function getAppBylawBytes32(bytes32 name) public view requireInitialised returns (bytes32) {&#13;
        ApplicationEntityABI CurrentApp = ApplicationEntityABI(owner);&#13;
        return CurrentApp.getBylawBytes32(name);&#13;
    }&#13;
&#13;
    modifier onlyOwner() {&#13;
        require(msg.sender == owner);&#13;
        _;&#13;
    }&#13;
&#13;
    modifier onlyApplicationEntity() {&#13;
        require(msg.sender == owner);&#13;
        _;&#13;
    }&#13;
&#13;
    modifier requireInitialised() {&#13;
        require(_initialized == true);&#13;
        _;&#13;
    }&#13;
&#13;
    modifier requireNotInitialised() {&#13;
        require(_initialized == false);&#13;
        _;&#13;
    }&#13;
&#13;
    modifier requireSettingsApplied() {&#13;
        require(_settingsApplied == true);&#13;
        _;&#13;
    }&#13;
&#13;
    modifier requireSettingsNotApplied() {&#13;
        require(_settingsApplied == false);&#13;
        _;&#13;
    }&#13;
&#13;
    modifier onlyDeployer() {&#13;
        require(msg.sender == deployerAddress);&#13;
        _;&#13;
    }&#13;
&#13;
    modifier onlyAsset(bytes32 _name) {&#13;
        address AssetAddress = getApplicationAssetAddressByName(_name);&#13;
        require( msg.sender == AssetAddress);&#13;
        _;&#13;
    }&#13;
&#13;
    function getTimestamp() view public returns (uint256) {&#13;
        return now;&#13;
    }&#13;
&#13;
&#13;
}&#13;
&#13;
/*&#13;
&#13;
 * source       https://github.com/blockbitsio/&#13;
&#13;
 * @name        Token Contract&#13;
 * @package     BlockBitsIO&#13;
 * @author      Micky Socaci &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="701d19131b09301e1f071c1906155e021f">[email protected]</a>&gt;&#13;
&#13;
 Zeppelin ERC20 Standard Token&#13;
&#13;
*/&#13;
&#13;
&#13;
&#13;
contract ABIToken {&#13;
&#13;
    string public  symbol;&#13;
    string public  name;&#13;
    uint8 public   decimals;&#13;
    uint256 public totalSupply;&#13;
    string public  version;&#13;
    mapping (address =&gt; uint256) public balances;&#13;
    mapping (address =&gt; mapping (address =&gt; uint256)) allowed;&#13;
    address public manager;&#13;
    address public deployer;&#13;
    bool public mintingFinished = false;&#13;
    bool public initialized = false;&#13;
&#13;
    function transfer(address _to, uint256 _value) public returns (bool);&#13;
    function balanceOf(address _owner) public view returns (uint256 balance);&#13;
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool);&#13;
    function approve(address _spender, uint256 _value) public returns (bool);&#13;
    function allowance(address _owner, address _spender) public view returns (uint256 remaining);&#13;
    function increaseApproval(address _spender, uint _addedValue) public returns (bool success);&#13;
    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool success);&#13;
    function mint(address _to, uint256 _amount) public returns (bool);&#13;
    function finishMinting() public returns (bool);&#13;
&#13;
    event Transfer(address indexed from, address indexed to, uint256 indexed value);&#13;
    event Approval(address indexed owner, address indexed spender, uint256 indexed value);&#13;
    event Mint(address indexed to, uint256 amount);&#13;
    event MintFinished();&#13;
}&#13;
&#13;
/*&#13;
&#13;
 * source       https://github.com/blockbitsio/&#13;
&#13;
 * @name        Application Asset Contract ABI&#13;
 * @package     BlockBitsIO&#13;
 * @author      Micky Socaci &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="b3dedad0d8caf3dddcc4dfdac5d69dc1dc">[email protected]</a>&gt;&#13;
&#13;
 Any contract inheriting this will be usable as an Asset in the Application Entity&#13;
&#13;
*/&#13;
&#13;
&#13;
&#13;
contract ABIApplicationAsset {&#13;
&#13;
    bytes32 public assetName;&#13;
    uint8 public CurrentEntityState;&#13;
    uint8 public RecordNum;&#13;
    bool public _initialized;&#13;
    bool public _settingsApplied;&#13;
    address public owner;&#13;
    address public deployerAddress;&#13;
    mapping (bytes32 =&gt; uint8) public EntityStates;&#13;
    mapping (bytes32 =&gt; uint8) public RecordStates;&#13;
&#13;
    function setInitialApplicationAddress(address _ownerAddress) public;&#13;
    function setInitialOwnerAndName(bytes32 _name) external returns (bool);&#13;
    function getRecordState(bytes32 name) public view returns (uint8);&#13;
    function getEntityState(bytes32 name) public view returns (uint8);&#13;
    function applyAndLockSettings() public returns(bool);&#13;
    function transferToNewOwner(address _newOwner) public returns (bool);&#13;
    function getApplicationAssetAddressByName(bytes32 _name) public returns(address);&#13;
    function getApplicationState() public view returns (uint8);&#13;
    function getApplicationEntityState(bytes32 name) public view returns (uint8);&#13;
    function getAppBylawUint256(bytes32 name) public view returns (uint256);&#13;
    function getAppBylawBytes32(bytes32 name) public view returns (bytes32);&#13;
    function getTimestamp() view public returns (uint256);&#13;
&#13;
&#13;
}&#13;
&#13;
/*&#13;
&#13;
 * source       https://github.com/blockbitsio/&#13;
&#13;
 * @name        Token Manager Contract&#13;
 * @package     BlockBitsIO&#13;
 * @author      Micky Socaci &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="523f3b31392b123c3d253e3b24377c203d">[email protected]</a>&gt;&#13;
&#13;
*/&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
contract ABITokenManager is ABIApplicationAsset {&#13;
&#13;
    address public TokenSCADAEntity;&#13;
    address public TokenEntity;&#13;
    address public MarketingMethodAddress;&#13;
    bool OwnerTokenBalancesReleased = false;&#13;
&#13;
    function addSettings(address _scadaAddress, address _tokenAddress, address _marketing ) public;&#13;
    function getTokenSCADARequiresHardCap() public view returns (bool);&#13;
    function mint(address _to, uint256 _amount) public returns (bool);&#13;
    function finishMinting() public returns (bool);&#13;
    function mintForMarketingPool(address _to, uint256 _amount) external returns (bool);&#13;
    function ReleaseOwnersLockedTokens(address _multiSigOutputAddress) public returns (bool);&#13;
&#13;
}&#13;
&#13;
/*&#13;
&#13;
 * source       https://github.com/blockbitsio/&#13;
&#13;
 * @name        Listing Contract ABI&#13;
 * @package     BlockBitsIO&#13;
 * @author      Micky Socaci &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="35585c565e4c755b5a42595c43501b475a">[email protected]</a>&gt;&#13;
&#13;
*/&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
contract ABIListingContract is ABIApplicationAsset {&#13;
&#13;
    address public managerAddress;&#13;
    // child items&#13;
    struct item {&#13;
        bytes32 name;&#13;
        address itemAddress;&#13;
        bool    status;&#13;
        uint256 index;&#13;
    }&#13;
&#13;
    mapping ( uint256 =&gt; item ) public items;&#13;
    uint256 public itemNum;&#13;
&#13;
    function setManagerAddress(address _manager) public;&#13;
    function addItem(bytes32 _name, address _address) public;&#13;
    function getNewsContractAddress(uint256 _childId) external view returns (address);&#13;
    function canBeDelisted(uint256 _childId) public view returns (bool);&#13;
    function getChildStatus( uint256 _childId ) public view returns (bool);&#13;
    function delistChild( uint256 _childId ) public;&#13;
&#13;
}&#13;
&#13;
/*&#13;
&#13;
 * source       https://github.com/blockbitsio/&#13;
&#13;
 * @name        Funding Contract ABI&#13;
 * @package     BlockBitsIO&#13;
 * @author      Micky Socaci &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="711c18121a08311f1e061d1807145f031e">[email protected]</a>&gt;&#13;
&#13;
 Contains the Funding Contract code deployed and linked to the Application Entity&#13;
&#13;
&#13;
    !!! Links directly to Milestones&#13;
&#13;
*/&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
contract ABIFunding is ABIApplicationAsset {&#13;
&#13;
    address public multiSigOutputAddress;&#13;
    address public DirectInput;&#13;
    address public MilestoneInput;&#13;
    address public TokenManagerEntity;&#13;
    address public FundingManagerEntity;&#13;
&#13;
    struct FundingStage {&#13;
        bytes32 name;&#13;
        uint8   state;&#13;
        uint256 time_start;&#13;
        uint256 time_end;&#13;
        uint256 amount_cap_soft;            // 0 = not enforced&#13;
        uint256 amount_cap_hard;            // 0 = not enforced&#13;
        uint256 amount_raised;              // 0 = not enforced&#13;
        // funding method settings&#13;
        uint256 minimum_entry;&#13;
        uint8   methods;                    // FundingMethodIds&#13;
        // token settings&#13;
        uint256 fixed_tokens;&#13;
        uint8   price_addition_percentage;  //&#13;
        uint8   token_share_percentage;&#13;
        uint8   index;&#13;
    }&#13;
&#13;
    mapping (uint8 =&gt; FundingStage) public Collection;&#13;
    uint8 public FundingStageNum;&#13;
    uint8 public currentFundingStage;&#13;
    uint256 public AmountRaised;&#13;
    uint256 public MilestoneAmountRaised;&#13;
    uint256 public GlobalAmountCapSoft;&#13;
    uint256 public GlobalAmountCapHard;&#13;
    uint8 public TokenSellPercentage;&#13;
    uint256 public Funding_Setting_funding_time_start;&#13;
    uint256 public Funding_Setting_funding_time_end;&#13;
    uint256 public Funding_Setting_cashback_time_start;&#13;
    uint256 public Funding_Setting_cashback_time_end;&#13;
    uint256 public Funding_Setting_cashback_before_start_wait_duration;&#13;
    uint256 public Funding_Setting_cashback_duration;&#13;
&#13;
&#13;
    function addFundingStage(&#13;
        bytes32 _name,&#13;
        uint256 _time_start,&#13;
        uint256 _time_end,&#13;
        uint256 _amount_cap_soft,&#13;
        uint256 _amount_cap_hard,   // required &gt; 0&#13;
        uint8   _methods,&#13;
        uint256 _minimum_entry,&#13;
        uint256 _fixed_tokens,&#13;
        uint8   _price_addition_percentage,&#13;
        uint8   _token_share_percentage&#13;
    )&#13;
    public;&#13;
&#13;
    function addSettings(address _outputAddress, uint256 soft_cap, uint256 hard_cap, uint8 sale_percentage, address _direct, address _milestone ) public;&#13;
    function getStageAmount(uint8 StageId) public view returns ( uint256 );&#13;
    function allowedPaymentMethod(uint8 _payment_method) public pure returns (bool);&#13;
    function receivePayment(address _sender, uint8 _payment_method) payable public returns(bool);&#13;
    function canAcceptPayment(uint256 _amount) public view returns (bool);&#13;
    function getValueOverCurrentCap(uint256 _amount) public view returns (uint256);&#13;
    function isFundingStageUpdateAllowed(uint8 _new_state ) public view returns (bool);&#13;
    function getRecordStateRequiredChanges() public view returns (uint8);&#13;
    function doStateChanges() public;&#13;
    function hasRequiredStateChanges() public view returns (bool);&#13;
    function getRequiredStateChanges() public view returns (uint8, uint8, uint8);&#13;
&#13;
}&#13;
&#13;
/*&#13;
&#13;
 * source       https://github.com/blockbitsio/&#13;
&#13;
 * @name        Funding Contract ABI&#13;
 * @package     BlockBitsIO&#13;
 * @author      Micky Socaci &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="1d70747e76645d73726a71746b78336f72">[email protected]</a>&gt;&#13;
&#13;
 Contains the Funding Contract code deployed and linked to the Application Entity&#13;
&#13;
*/&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
contract ABIFundingManager is ABIApplicationAsset {&#13;
&#13;
    bool public fundingProcessed;&#13;
    bool FundingPoolBalancesAllocated;&#13;
    uint8 public VaultCountPerProcess;&#13;
    uint256 public lastProcessedVaultId;&#13;
    uint256 public vaultNum;&#13;
    uint256 public LockedVotingTokens;&#13;
    bytes32 public currentTask;&#13;
    mapping (bytes32 =&gt; bool) public taskByHash;&#13;
    mapping  (address =&gt; address) public vaultList;&#13;
    mapping  (uint256 =&gt; address) public vaultById;&#13;
&#13;
    function receivePayment(address _sender, uint8 _payment_method, uint8 _funding_stage) payable public returns(bool);&#13;
    function getMyVaultAddress(address _sender) public view returns (address);&#13;
    function setVaultCountPerProcess(uint8 _perProcess) external;&#13;
    function getHash(bytes32 actionType, bytes32 arg1) public pure returns ( bytes32 );&#13;
    function getCurrentMilestoneProcessed() public view returns (bool);&#13;
    function processFundingFailedFinished() public view returns (bool);&#13;
    function processFundingSuccessfulFinished() public view returns (bool);&#13;
    function getCurrentMilestoneIdHash() internal view returns (bytes32);&#13;
    function processMilestoneFinished() public view returns (bool);&#13;
    function processEmergencyFundReleaseFinished() public view returns (bool);&#13;
    function getAfterTransferLockedTokenBalances(address vaultAddress, bool excludeCurrent) public view returns (uint256);&#13;
    function VaultRequestedUpdateForLockedVotingTokens(address owner) public;&#13;
    function doStateChanges() public;&#13;
    function hasRequiredStateChanges() public view returns (bool);&#13;
    function getRequiredStateChanges() public view returns (uint8, uint8);&#13;
    function ApplicationInFundingOrDevelopment() public view returns(bool);&#13;
&#13;
}&#13;
&#13;
/*&#13;
&#13;
 * source       https://github.com/blockbitsio/&#13;
&#13;
 * @name        Milestones Contract&#13;
 * @package     BlockBitsIO&#13;
 * @author      Micky Socaci &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="80ede9e3ebf9c0eeeff7ece9f6e5aef2ef">[email protected]</a>&gt;&#13;
&#13;
 Contains the Milestones Contract code deployed and linked to the Application Entity&#13;
&#13;
*/&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
contract ABIMilestones is ABIApplicationAsset {&#13;
&#13;
    struct Record {&#13;
        bytes32 name;&#13;
        string description;                     // will change to hash pointer ( external storage )&#13;
        uint8 state;&#13;
        uint256 duration;&#13;
        uint256 time_start;                     // start at unixtimestamp&#13;
        uint256 last_state_change_time;         // time of last state change&#13;
        uint256 time_end;                       // estimated end time &gt;&gt; can be increased by proposal&#13;
        uint256 time_ended;                     // actual end time&#13;
        uint256 meeting_time;&#13;
        uint8 funding_percentage;&#13;
        uint8 index;&#13;
    }&#13;
&#13;
    uint8 public currentRecord;&#13;
    uint256 public MilestoneCashBackTime = 0;&#13;
    mapping (uint8 =&gt; Record) public Collection;&#13;
    mapping (bytes32 =&gt; bool) public MilestonePostponingHash;&#13;
    mapping (bytes32 =&gt; uint256) public ProposalIdByHash;&#13;
&#13;
    function getBylawsProjectDevelopmentStart() public view returns (uint256);&#13;
    function getBylawsMinTimeInTheFutureForMeetingCreation() public view returns (uint256);&#13;
    function getBylawsCashBackVoteRejectedDuration() public view returns (uint256);&#13;
    function addRecord( bytes32 _name, string _description, uint256 _duration, uint8 _perc ) public;&#13;
    function getMilestoneFundingPercentage(uint8 recordId) public view returns (uint8);&#13;
    function doStateChanges() public;&#13;
    function getRecordStateRequiredChanges() public view returns (uint8);&#13;
    function hasRequiredStateChanges() public view returns (bool);&#13;
    function afterVoteNoCashBackTime() public view returns ( bool );&#13;
    function getHash(uint8 actionType, bytes32 arg1, bytes32 arg2) public pure returns ( bytes32 );&#13;
    function getCurrentHash() public view returns ( bytes32 );&#13;
    function getCurrentProposalId() internal view returns ( uint256 );&#13;
    function setCurrentMilestoneMeetingTime(uint256 _meeting_time) public;&#13;
    function isRecordUpdateAllowed(uint8 _new_state ) public view returns (bool);&#13;
    function getRequiredStateChanges() public view returns (uint8, uint8, uint8);&#13;
    function ApplicationIsInDevelopment() public view returns(bool);&#13;
    function MeetingTimeSetFailure() public view returns (bool);&#13;
&#13;
}&#13;
&#13;
/*&#13;
&#13;
 * source       https://github.com/blockbitsio/&#13;
&#13;
 * @name        Proposals Contract&#13;
 * @package     BlockBitsIO&#13;
 * @author      Micky Socaci &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="e5888c868e9ca58b8a92898c9380cb978a">[email protected]</a>&gt;&#13;
&#13;
 Contains the Proposals Contract code deployed and linked to the Application Entity&#13;
&#13;
*/&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
contract Proposals is ApplicationAsset {&#13;
&#13;
    ApplicationEntityABI public Application;&#13;
    ABIListingContract public ListingContractEntity;&#13;
    ABIFunding public FundingEntity;&#13;
    ABIFundingManager public FundingManagerEntity;&#13;
    ABITokenManager public TokenManagerEntity;&#13;
    ABIToken public TokenEntity;&#13;
    ABIMilestones public MilestonesEntity;&#13;
&#13;
    function getRecordState(bytes32 name) public view returns (uint8) {&#13;
        return RecordStates[name];&#13;
    }&#13;
&#13;
    function getActionType(bytes32 name) public view returns (uint8) {&#13;
        return ActionTypes[name];&#13;
    }&#13;
&#13;
    function getProposalState(uint256 _proposalId) public view returns (uint8) {&#13;
        return ProposalsById[_proposalId].state;&#13;
    }&#13;
&#13;
    mapping (bytes32 =&gt; uint8) public ActionTypes;&#13;
&#13;
    function setActionTypes() internal {&#13;
        // owner initiated&#13;
        ActionTypes["MILESTONE_DEADLINE"] = 1;&#13;
        ActionTypes["MILESTONE_POSTPONING"] = 2;&#13;
        ActionTypes["EMERGENCY_FUND_RELEASE"] = 60;&#13;
        ActionTypes["IN_DEVELOPMENT_CODE_UPGRADE"] = 50;&#13;
&#13;
        // shareholder initiated&#13;
        ActionTypes["AFTER_COMPLETE_CODE_UPGRADE"] = 51;&#13;
        ActionTypes["PROJECT_DELISTING"] = 75;&#13;
    }&#13;
&#13;
&#13;
    function setAssetStates() internal {&#13;
&#13;
        setActionTypes();&#13;
&#13;
        RecordStates["NEW"]                 = 1;&#13;
        RecordStates["ACCEPTING_VOTES"]     = 2;&#13;
        RecordStates["VOTING_ENDED"]        = 3;&#13;
        RecordStates["VOTING_RESULT_YES"]   = 10;&#13;
        RecordStates["VOTING_RESULT_NO"]    = 20;&#13;
    }&#13;
&#13;
    event EventNewProposalCreated ( bytes32 indexed _hash, uint256 indexed _proposalId );&#13;
&#13;
    function runBeforeApplyingSettings()&#13;
        internal&#13;
        requireInitialised&#13;
        requireSettingsNotApplied&#13;
    {&#13;
        address FundingAddress = getApplicationAssetAddressByName('Funding');&#13;
        FundingEntity = ABIFunding(FundingAddress);&#13;
&#13;
        address FundingManagerAddress = getApplicationAssetAddressByName('FundingManager');&#13;
        FundingManagerEntity = ABIFundingManager(FundingManagerAddress);&#13;
&#13;
        address TokenManagerAddress = getApplicationAssetAddressByName('TokenManager');&#13;
        TokenManagerEntity = ABITokenManager(TokenManagerAddress);&#13;
        TokenEntity = ABIToken(TokenManagerEntity.TokenEntity());&#13;
&#13;
        address ListingContractAddress = getApplicationAssetAddressByName('ListingContract');&#13;
        ListingContractEntity = ABIListingContract(ListingContractAddress);&#13;
&#13;
        address MilestonesContractAddress = getApplicationAssetAddressByName('Milestones');&#13;
        MilestonesEntity = ABIMilestones(MilestonesContractAddress);&#13;
&#13;
        EventRunBeforeApplyingSettings(assetName);&#13;
    }&#13;
&#13;
    function getBylawsProposalVotingDuration() public view returns (uint256) {&#13;
        return getAppBylawUint256("proposal_voting_duration");&#13;
    }&#13;
&#13;
    function getBylawsMilestoneMinPostponing() public view returns (uint256) {&#13;
        return getAppBylawUint256("min_postponing");&#13;
    }&#13;
&#13;
    function getBylawsMilestoneMaxPostponing() public view returns (uint256) {&#13;
        return getAppBylawUint256("max_postponing");&#13;
    }&#13;
&#13;
    function getHash(uint8 actionType, bytes32 arg1, bytes32 arg2) public pure returns ( bytes32 ) {&#13;
        return keccak256(actionType, arg1, arg2);&#13;
    }&#13;
&#13;
&#13;
    // need to implement a way to just iterate through active proposals, and remove the ones we already processed&#13;
    // otherwise someone with malicious intent could add a ton of proposals, just to make our contract cost a ton of gas.&#13;
&#13;
    // to that end, we allow individual proposal processing. so that we don't get affected by people with too much&#13;
    // money and time on their hands.&#13;
&#13;
    // whenever the system created a proposal, it will store the id, and process it when required.&#13;
&#13;
    // not that much of an issue at this stage because:&#13;
    // NOW:&#13;
    // - only the system can create - MILESTONE_DEADLINE&#13;
    // - only the deployer can create - MILESTONE_POSTPONING / EMERGENCY_FUND_RELEASE / IN_DEVELOPMENT_CODE_UPGRADE&#13;
&#13;
    // FUTURE:&#13;
    // - PROJECT_DELISTING is tied into an existing "listing id" which will be created by the system ( if requested by&#13;
    // someone, but at quite a significant cost )&#13;
    // - AFTER_COMPLETE_CODE_UPGRADE&#13;
&#13;
    mapping (uint8 =&gt; uint256) public ActiveProposalIds;&#13;
    uint8 public ActiveProposalNum = 0;&#13;
&#13;
    mapping (uint256 =&gt; bool) public ExpiredProposalIds;&#13;
&#13;
    function process() public onlyApplicationEntity {&#13;
        for(uint8 i = 0; i &lt; ActiveProposalNum; i++) {&#13;
&#13;
            if(&#13;
                getProposalType(ActiveProposalIds[i]) == getActionType("PROJECT_DELISTING") ||&#13;
                getProposalType(ActiveProposalIds[i]) == getActionType("AFTER_COMPLETE_CODE_UPGRADE")&#13;
            ) {&#13;
                ProcessVoteTotals( ActiveProposalIds[i], VoteCountPerProcess );&#13;
            } else {&#13;
                // try expiry ending&#13;
                tryEndVoting(ActiveProposalIds[i]);&#13;
            }&#13;
&#13;
        }&#13;
    }&#13;
&#13;
    function hasRequiredStateChanges() public view returns (bool) {&#13;
        for(uint8 i = 0; i &lt; ActiveProposalNum; i++) {&#13;
            if( needsProcessing( ActiveProposalIds[i] ) ) {&#13;
                return true;&#13;
            }&#13;
        }&#13;
        return false;&#13;
    }&#13;
&#13;
    function getRequiredStateChanges() public view returns (uint8) {&#13;
        if(hasRequiredStateChanges()) {&#13;
            return ActiveProposalNum;&#13;
        }&#13;
        return 0;&#13;
    }&#13;
&#13;
    function addCodeUpgradeProposal(address _addr, bytes32 _sourceCodeUrl)&#13;
        external&#13;
        onlyApplicationEntity   // shareholder check is done directly in Gateway by calling applicationEntity to confirm&#13;
        returns (uint256)&#13;
    {&#13;
&#13;
        // hash enforces only 1 possible voting of this type per record.&#13;
        // basically if a vote failed, you need to deploy it with changes to a new address. that simple.&#13;
&#13;
        // depending on the application overall state, we have 2 different voting implementations.&#13;
&#13;
        uint8 thisAction;&#13;
&#13;
        if(getApplicationState() == getApplicationEntityState("IN_DEVELOPMENT") ) {&#13;
            thisAction = getActionType("IN_DEVELOPMENT_CODE_UPGRADE");&#13;
&#13;
        } else if(getApplicationState() == getApplicationEntityState("DEVELOPMENT_COMPLETE") ) {&#13;
            thisAction = getActionType("AFTER_COMPLETE_CODE_UPGRADE");&#13;
        }&#13;
&#13;
        return createProposal(&#13;
            msg.sender,&#13;
            "CODE_UPGRADE",&#13;
            getHash( thisAction, bytes32(_addr), 0 ),&#13;
            thisAction,&#13;
            _addr,&#13;
            _sourceCodeUrl,&#13;
            0&#13;
        );&#13;
    }&#13;
&#13;
&#13;
    function createMilestoneAcceptanceProposal()&#13;
        external&#13;
        onlyAsset("Milestones")&#13;
        returns (uint256)&#13;
    {&#13;
&#13;
        uint8 recordId = MilestonesEntity.currentRecord();&#13;
        return createProposal(&#13;
            msg.sender,&#13;
            "MILESTONE_DEADLINE",&#13;
            getHash( getActionType("MILESTONE_DEADLINE"), bytes32( recordId ), 0 ),&#13;
            getActionType("MILESTONE_DEADLINE"),&#13;
            0,&#13;
            0,&#13;
            uint256(recordId)&#13;
        );&#13;
    }&#13;
&#13;
    function createMilestonePostponingProposal(uint256 _duration)&#13;
        external&#13;
        onlyDeployer&#13;
        returns (uint256)&#13;
    {&#13;
        if(_duration &gt;= getBylawsMilestoneMinPostponing() &amp;&amp; _duration &lt;= getBylawsMilestoneMaxPostponing() ) {&#13;
&#13;
            uint8 recordId = MilestonesEntity.currentRecord();&#13;
            return createProposal(&#13;
                msg.sender,&#13;
                "MILESTONE_POSTPONING",&#13;
                getHash( getActionType("MILESTONE_POSTPONING"), bytes32( recordId ), 0 ),&#13;
                getActionType("MILESTONE_POSTPONING"),&#13;
                0,&#13;
                0,&#13;
                _duration&#13;
            );&#13;
        } else {&#13;
            revert();&#13;
        }&#13;
    }&#13;
&#13;
    function getCurrentMilestonePostponingProposalDuration() public view returns (uint256) {&#13;
        uint8 recordId = MilestonesEntity.currentRecord();&#13;
        bytes32 hash = getHash( getActionType("MILESTONE_POSTPONING"), bytes32( recordId ), 0 );&#13;
        ProposalRecord memory proposal = ProposalsById[ ProposalIdByHash[hash] ];&#13;
        return proposal.extra;&#13;
    }&#13;
&#13;
    function getCurrentMilestoneProposalStatusForType(uint8 _actionType ) public view returns (uint8) {&#13;
&#13;
        if(_actionType == getActionType("MILESTONE_DEADLINE") || _actionType == getActionType("MILESTONE_POSTPONING")) {&#13;
            uint8 recordId = MilestonesEntity.currentRecord();&#13;
            bytes32 hash = getHash( _actionType, bytes32( recordId ), 0 );&#13;
            uint256 ProposalId = ProposalIdByHash[hash];&#13;
            ProposalRecord memory proposal = ProposalsById[ProposalId];&#13;
            return proposal.state;&#13;
        }&#13;
        return 0;&#13;
    }&#13;
&#13;
    function createEmergencyFundReleaseProposal()&#13;
        external&#13;
        onlyDeployer&#13;
        returns (uint256)&#13;
    {&#13;
        return createProposal(&#13;
            msg.sender,&#13;
            "EMERGENCY_FUND_RELEASE",&#13;
            getHash( getActionType("EMERGENCY_FUND_RELEASE"), 0, 0 ),&#13;
            getActionType("EMERGENCY_FUND_RELEASE"),&#13;
            0,&#13;
            0,&#13;
            0&#13;
        );&#13;
    }&#13;
&#13;
    function createDelistingProposal(uint256 _projectId)&#13;
        external&#13;
        onlyTokenHolder&#13;
        returns (uint256)&#13;
    {&#13;
        // let's validate the project is actually listed first in order to remove any spamming ability.&#13;
        if( ListingContractEntity.canBeDelisted(_projectId) == true) {&#13;
&#13;
            return createProposal(&#13;
                msg.sender,&#13;
                "PROJECT_DELISTING",&#13;
                getHash( getActionType("PROJECT_DELISTING"), bytes32(_projectId), 0 ),&#13;
                getActionType("PROJECT_DELISTING"),&#13;
                0,&#13;
                0,&#13;
                _projectId&#13;
            );&#13;
        } else {&#13;
            revert();&#13;
        }&#13;
    }&#13;
&#13;
    modifier onlyTokenHolder() {&#13;
        require( getTotalTokenVotingPower(msg.sender) &gt; 0 );&#13;
        _;&#13;
    }&#13;
&#13;
    struct ProposalRecord {&#13;
        address creator;&#13;
        bytes32 name;&#13;
        uint8 actionType;&#13;
        uint8 state;&#13;
        bytes32 hash;                       // action name + args hash&#13;
        address addr;&#13;
        bytes32 sourceCodeUrl;&#13;
        uint256 extra;&#13;
        uint256 time_start;&#13;
        uint256 time_end;&#13;
        uint256 index;&#13;
    }&#13;
&#13;
    mapping (uint256 =&gt; ProposalRecord) public ProposalsById;&#13;
    mapping (bytes32 =&gt; uint256) public ProposalIdByHash;&#13;
&#13;
    function createProposal(&#13;
        address _creator,&#13;
        bytes32 _name,&#13;
        bytes32 _hash,&#13;
        uint8   _action,&#13;
        address _addr,&#13;
        bytes32 _sourceCodeUrl,&#13;
        uint256 _extra&#13;
    )&#13;
        internal&#13;
        returns (uint256)&#13;
    {&#13;
&#13;
        // if(_action &gt; 0) {&#13;
&#13;
        if(ProposalIdByHash[_hash] == 0) {&#13;
&#13;
            ProposalRecord storage proposal = ProposalsById[++RecordNum];&#13;
            proposal.creator        = _creator;&#13;
            proposal.name           = _name;&#13;
            proposal.actionType     = _action;&#13;
            proposal.addr           = _addr;&#13;
            proposal.sourceCodeUrl  = _sourceCodeUrl;&#13;
            proposal.extra          = _extra;&#13;
            proposal.hash           = _hash;&#13;
            proposal.state          = getRecordState("NEW");&#13;
            proposal.time_start     = getTimestamp();&#13;
            proposal.time_end       = getTimestamp() + getBylawsProposalVotingDuration();&#13;
            proposal.index          = RecordNum;&#13;
&#13;
            ProposalIdByHash[_hash] = RecordNum;&#13;
&#13;
        } else {&#13;
            // already exists!&#13;
            revert();&#13;
        }&#13;
&#13;
        initProposalVoting(RecordNum);&#13;
        EventNewProposalCreated ( _hash, RecordNum );&#13;
        return RecordNum;&#13;
&#13;
        /*&#13;
        } else {&#13;
            // no action?!&#13;
            revert();&#13;
        }&#13;
        */&#13;
    }&#13;
&#13;
    function acceptCodeUpgrade(uint256 _proposalId) internal {&#13;
        ProposalRecord storage proposal = ProposalsById[_proposalId];&#13;
        // reinitialize this each time, because we rely on "owner" as the address, and it will change&#13;
        Application = ApplicationEntityABI(owner);&#13;
        Application.acceptCodeUpgradeProposal(proposal.addr);&#13;
    }&#13;
&#13;
&#13;
    function initProposalVoting(uint256 _proposalId) internal {&#13;
&#13;
        ResultRecord storage result = ResultsByProposalId[_proposalId];&#13;
        ProposalRecord storage proposal = ProposalsById[_proposalId];&#13;
&#13;
        if(getApplicationState() == getApplicationEntityState("IN_DEVELOPMENT") ) {&#13;
&#13;
            if(proposal.actionType == getActionType("PROJECT_DELISTING") ) {&#13;
                // while in development project delisting can be voted by all available tokens, except owner&#13;
                uint256 ownerLockedTokens = TokenEntity.balanceOf(TokenManagerEntity);&#13;
                result.totalAvailable = TokenEntity.totalSupply() - ownerLockedTokens;&#13;
&#13;
                // since we're counting unlocked tokens, we need to recount votes each time we want to end the voting period&#13;
                result.requiresCounting = true;&#13;
&#13;
            } else {&#13;
                // any other proposal is only voted by "locked ether", thus we use locked tokens&#13;
                result.totalAvailable = FundingManagerEntity.LockedVotingTokens();&#13;
&#13;
                // locked tokens do not require recounting.&#13;
                result.requiresCounting = false;&#13;
            }&#13;
&#13;
        } else if(getApplicationState() == getApplicationEntityState("DEVELOPMENT_COMPLETE") ) {&#13;
            // remove residual token balance from TokenManagerEntity.&#13;
            uint256 residualLockedTokens = TokenEntity.balanceOf(TokenManagerEntity);&#13;
            result.totalAvailable = TokenEntity.totalSupply() - residualLockedTokens;&#13;
&#13;
            // since we're counting unlocked tokens, we need to recount votes each time we want to end the voting period&#13;
            result.requiresCounting = true;&#13;
        }&#13;
        result.requiredForResult = result.totalAvailable / 2;   // 50%&#13;
&#13;
        proposal.state = getRecordState("ACCEPTING_VOTES");&#13;
        addActiveProposal(_proposalId);&#13;
&#13;
        tryFinaliseNonLockedTokensProposal(_proposalId);&#13;
    }&#13;
&#13;
&#13;
&#13;
    /*&#13;
&#13;
    Voting&#13;
&#13;
    */&#13;
&#13;
    struct VoteStruct {&#13;
        address voter;&#13;
        uint256 time;&#13;
        bool    vote;&#13;
        uint256 power;&#13;
        bool    annulled;&#13;
        uint256 index;&#13;
    }&#13;
&#13;
    struct ResultRecord {&#13;
        uint256 totalAvailable;&#13;
        uint256 requiredForResult;&#13;
        uint256 totalSoFar;&#13;
        uint256 yes;&#13;
        uint256 no;&#13;
        bool    requiresCounting;&#13;
    }&#13;
&#13;
&#13;
    mapping (uint256 =&gt; mapping (uint256 =&gt; VoteStruct) ) public VotesByProposalId;&#13;
    mapping (uint256 =&gt; mapping (address =&gt; VoteStruct) ) public VotesByCaster;&#13;
    mapping (uint256 =&gt; uint256 ) public VotesNumByProposalId;&#13;
    mapping (uint256 =&gt; ResultRecord ) public ResultsByProposalId;&#13;
&#13;
    function RegisterVote(uint256 _proposalId, bool _myVote) public {&#13;
        address Voter = msg.sender;&#13;
&#13;
        // get voting power&#13;
        uint256 VoterPower = getVotingPower(_proposalId, Voter);&#13;
&#13;
        // get proposal for state&#13;
        ProposalRecord storage proposal = ProposalsById[_proposalId];&#13;
&#13;
        // make sure voting power is greater than 0&#13;
        // make sure proposal.state allows receiving votes&#13;
        // make sure proposal.time_end has not passed.&#13;
&#13;
        if(VoterPower &gt; 0 &amp;&amp; proposal.state == getRecordState("ACCEPTING_VOTES")) {&#13;
&#13;
            // first check if this Voter has a record registered,&#13;
            // and if they did, annul initial vote, update results, and add new one&#13;
            if( hasPreviousVote(_proposalId, Voter) ) {&#13;
                undoPreviousVote(_proposalId, Voter);&#13;
            }&#13;
&#13;
            registerNewVote(_proposalId, Voter, _myVote, VoterPower);&#13;
&#13;
            // this is where we can end voting before time if result.yes or result.no &gt; totalSoFar&#13;
            tryEndVoting(_proposalId);&#13;
&#13;
        } else {&#13;
            revert();&#13;
        }&#13;
    }&#13;
&#13;
    function hasPreviousVote(uint256 _proposalId, address _voter) public view returns (bool) {&#13;
        VoteStruct storage previousVoteByCaster = VotesByCaster[_proposalId][_voter];&#13;
        if( previousVoteByCaster.power &gt; 0 ) {&#13;
            return true;&#13;
        }&#13;
        return false;&#13;
    }&#13;
&#13;
    function undoPreviousVote(uint256 _proposalId, address _voter) internal {&#13;
&#13;
        VoteStruct storage previousVoteByCaster = VotesByCaster[_proposalId][_voter];&#13;
&#13;
        // if( previousVoteByCaster.power &gt; 0 ) {&#13;
            previousVoteByCaster.annulled = true;&#13;
&#13;
            VoteStruct storage previousVoteByProposalId = VotesByProposalId[_proposalId][previousVoteByCaster.index];&#13;
            previousVoteByProposalId.annulled = true;&#13;
&#13;
            ResultRecord storage result = ResultsByProposalId[_proposalId];&#13;
&#13;
            // update total so far as well&#13;
            result.totalSoFar-= previousVoteByProposalId.power;&#13;
&#13;
            if(previousVoteByProposalId.vote == true) {&#13;
                result.yes-= previousVoteByProposalId.power;&#13;
            // } else if(previousVoteByProposalId.vote == false) {&#13;
            } else {&#13;
                result.no-= previousVoteByProposalId.power;&#13;
            }&#13;
        // }&#13;
&#13;
    }&#13;
&#13;
    function registerNewVote(uint256 _proposalId, address _voter, bool _myVote, uint256 _power) internal {&#13;
&#13;
        // handle new vote&#13;
        uint256 currentVoteId = VotesNumByProposalId[_proposalId]++;&#13;
        VoteStruct storage vote = VotesByProposalId[_proposalId][currentVoteId];&#13;
            vote.voter = _voter;&#13;
            vote.time = getTimestamp();&#13;
            vote.vote = _myVote;&#13;
            vote.power = _power;&#13;
            vote.index = currentVoteId;&#13;
&#13;
        VotesByCaster[_proposalId][_voter] = VotesByProposalId[_proposalId][currentVoteId];&#13;
&#13;
        addVoteIntoResult(_proposalId, _myVote, _power );&#13;
    }&#13;
&#13;
    event EventAddVoteIntoResult ( uint256 indexed _proposalId, bool indexed _type, uint256 indexed _power );&#13;
&#13;
    function addVoteIntoResult(uint256 _proposalId, bool _type, uint256 _power ) internal {&#13;
&#13;
        EventAddVoteIntoResult(_proposalId, _type, _power );&#13;
&#13;
        ResultRecord storage newResult = ResultsByProposalId[_proposalId];&#13;
        newResult.totalSoFar+= _power;&#13;
        if(_type == true) {&#13;
            newResult.yes+= _power;&#13;
        } else {&#13;
            newResult.no+= _power;&#13;
        }&#13;
    }&#13;
&#13;
    function getTotalTokenVotingPower(address _voter) public view returns ( uint256 ) {&#13;
        address VaultAddress = FundingManagerEntity.getMyVaultAddress(_voter);&#13;
        uint256 VotingPower = TokenEntity.balanceOf(VaultAddress);&#13;
        VotingPower+= TokenEntity.balanceOf(_voter);&#13;
        return VotingPower;&#13;
    }&#13;
&#13;
    function getVotingPower(uint256 _proposalId, address _voter) public view returns ( uint256 ) {&#13;
        uint256 VotingPower = 0;&#13;
        ProposalRecord storage proposal = ProposalsById[_proposalId];&#13;
&#13;
        if(proposal.actionType == getActionType("AFTER_COMPLETE_CODE_UPGRADE")) {&#13;
&#13;
            return TokenEntity.balanceOf(_voter);&#13;
&#13;
        } else {&#13;
&#13;
            address VaultAddress = FundingManagerEntity.getMyVaultAddress(_voter);&#13;
            if(VaultAddress != address(0x0)) {&#13;
                VotingPower = TokenEntity.balanceOf(VaultAddress);&#13;
&#13;
                if( proposal.actionType == getActionType("PROJECT_DELISTING") ) {&#13;
                    // for project delisting, we want to also include tokens in the voter's wallet.&#13;
                    VotingPower+= TokenEntity.balanceOf(_voter);&#13;
                }&#13;
            }&#13;
        }&#13;
        return VotingPower;&#13;
    }&#13;
&#13;
&#13;
    mapping( uint256 =&gt; uint256 ) public lastProcessedVoteIdByProposal;&#13;
    mapping( uint256 =&gt; uint256 ) public ProcessedVotesByProposal;&#13;
    mapping( uint256 =&gt; uint256 ) public VoteCountAtProcessingStartByProposal;&#13;
    uint256 public VoteCountPerProcess = 10;&#13;
&#13;
    function setVoteCountPerProcess(uint256 _perProcess) external onlyDeployer {&#13;
        if(_perProcess &gt; 0) {&#13;
            VoteCountPerProcess = _perProcess;&#13;
        } else {&#13;
            revert();&#13;
        }&#13;
    }&#13;
&#13;
    event EventProcessVoteTotals ( uint256 indexed _proposalId, uint256 indexed start, uint256 indexed end );&#13;
&#13;
    function ProcessVoteTotals(uint256 _proposalId, uint256 length) public onlyApplicationEntity {&#13;
&#13;
        uint256 start = lastProcessedVoteIdByProposal[_proposalId] + 1;&#13;
        uint256 end = start + length - 1;&#13;
        if(end &gt; VotesNumByProposalId[_proposalId]) {&#13;
            end = VotesNumByProposalId[_proposalId];&#13;
        }&#13;
&#13;
        EventProcessVoteTotals(_proposalId, start, end);&#13;
&#13;
        // first run&#13;
        if(start == 1) {&#13;
            // save vote count at start, so we can reset if it changes&#13;
            VoteCountAtProcessingStartByProposal[_proposalId] = VotesNumByProposalId[_proposalId];&#13;
&#13;
            // reset vote totals to 0&#13;
            ResultRecord storage result = ResultsByProposalId[_proposalId];&#13;
            result.yes = 0;&#13;
            result.no = 0;&#13;
            result.totalSoFar = 0;&#13;
        }&#13;
&#13;
        // reset to start if vote count has changed in the middle of processing run&#13;
        if(VoteCountAtProcessingStartByProposal[_proposalId] != VotesNumByProposalId[_proposalId]) {&#13;
            // we received votes while counting&#13;
            // reset from start&#13;
            lastProcessedVoteIdByProposal[_proposalId] = 0;&#13;
            // exit&#13;
            return;&#13;
        }&#13;
&#13;
        for(uint256 i = start; i &lt;= end; i++) {&#13;
&#13;
            VoteStruct storage vote = VotesByProposalId[_proposalId][i - 1];&#13;
            // process vote into totals.&#13;
            if(vote.annulled != true) {&#13;
                addVoteIntoResult(_proposalId, vote.vote, vote.power );&#13;
            }&#13;
&#13;
            lastProcessedVoteIdByProposal[_proposalId]++;&#13;
        }&#13;
&#13;
        // reset iterator so we can call it again.&#13;
        if(lastProcessedVoteIdByProposal[_proposalId] &gt;= VotesNumByProposalId[_proposalId] ) {&#13;
&#13;
            ProcessedVotesByProposal[_proposalId] = lastProcessedVoteIdByProposal[_proposalId];&#13;
            lastProcessedVoteIdByProposal[_proposalId] = 0;&#13;
            tryEndVoting(_proposalId);&#13;
        }&#13;
    }&#13;
&#13;
    function canEndVoting(uint256 _proposalId) public view returns (bool) {&#13;
&#13;
        ResultRecord memory result = ResultsByProposalId[_proposalId];&#13;
        if(result.requiresCounting == false) {&#13;
            if(result.yes &gt; result.requiredForResult || result.no &gt; result.requiredForResult) {&#13;
                return true;&#13;
            }&#13;
        }&#13;
        else {&#13;
&#13;
            if(ProcessedVotesByProposal[_proposalId] == VotesNumByProposalId[_proposalId]) {&#13;
                if(result.yes &gt; result.requiredForResult || result.no &gt; result.requiredForResult) {&#13;
                    return true;&#13;
                }&#13;
            }&#13;
&#13;
        }&#13;
        return false;&#13;
    }&#13;
&#13;
    function getProposalType(uint256 _proposalId) public view returns (uint8) {&#13;
        return ProposalsById[_proposalId].actionType;&#13;
    }&#13;
&#13;
    function expiryChangesState(uint256 _proposalId) public view returns (bool) {&#13;
        ProposalRecord memory proposal = ProposalsById[_proposalId];&#13;
        if( proposal.state == getRecordState("ACCEPTING_VOTES") &amp;&amp; proposal.time_end &lt; getTimestamp() ) {&#13;
            return true;&#13;
        }&#13;
        return false;&#13;
    }&#13;
&#13;
    function needsProcessing(uint256 _proposalId) public view returns (bool) {&#13;
        if( expiryChangesState(_proposalId) ) {&#13;
            return true;&#13;
        }&#13;
&#13;
        ResultRecord memory result = ResultsByProposalId[_proposalId];&#13;
        if(result.requiresCounting == true) {&#13;
            if( lastProcessedVoteIdByProposal[_proposalId] &lt; VotesNumByProposalId[_proposalId] ) {&#13;
                if(ProcessedVotesByProposal[_proposalId] == VotesNumByProposalId[_proposalId]) {&#13;
                    return false;&#13;
                }&#13;
            }&#13;
&#13;
        } else {&#13;
            return false;&#13;
        }&#13;
&#13;
        return true;&#13;
    }&#13;
&#13;
    function tryEndVoting(uint256 _proposalId) internal {&#13;
        if(canEndVoting(_proposalId)) {&#13;
            finaliseProposal(_proposalId);&#13;
        }&#13;
&#13;
        if(expiryChangesState(_proposalId) ) {&#13;
            finaliseExpiredProposal(_proposalId);&#13;
        }&#13;
    }&#13;
&#13;
    function finaliseProposal(uint256 _proposalId) internal {&#13;
&#13;
        ResultRecord storage result = ResultsByProposalId[_proposalId];&#13;
        ProposalRecord storage proposal = ProposalsById[_proposalId];&#13;
&#13;
        // Milestone Deadline proposals cannot be ended "by majority vote", we rely on finaliseExpiredProposal here&#13;
        // because we want to allow everyone to be able to vote "NO" if they choose to cashback.&#13;
&#13;
        if( proposal.actionType != getActionType("MILESTONE_DEADLINE")) {&#13;
            // read results,&#13;
            if(result.yes &gt; result.requiredForResult) {&#13;
                // voting resulted in YES&#13;
                proposal.state = getRecordState("VOTING_RESULT_YES");&#13;
            } else if (result.no &gt;= result.requiredForResult) {&#13;
                // voting resulted in NO&#13;
                proposal.state = getRecordState("VOTING_RESULT_NO");&#13;
            }&#13;
        }&#13;
&#13;
        runActionAfterResult(_proposalId);&#13;
    }&#13;
&#13;
    function finaliseExpiredProposal(uint256 _proposalId) internal {&#13;
&#13;
        ResultRecord storage result = ResultsByProposalId[_proposalId];&#13;
        ProposalRecord storage proposal = ProposalsById[_proposalId];&#13;
&#13;
        // an expired proposal with no votes will end as YES&#13;
        if(result.yes == 0 &amp;&amp; result.no == 0) {&#13;
            proposal.state = getRecordState("VOTING_RESULT_YES");&#13;
        } else {&#13;
            // read results,&#13;
            if(result.yes &gt; result.no) {&#13;
                // voting resulted in YES&#13;
                proposal.state = getRecordState("VOTING_RESULT_YES");&#13;
            } else if (result.no &gt;= result.yes) {&#13;
                // tie equals no&#13;
                // voting resulted in NO&#13;
                proposal.state = getRecordState("VOTING_RESULT_NO");&#13;
            }&#13;
        }&#13;
        runActionAfterResult(_proposalId);&#13;
    }&#13;
&#13;
    function tryFinaliseNonLockedTokensProposal(uint256 _proposalId) internal {&#13;
&#13;
        ResultRecord storage result = ResultsByProposalId[_proposalId];&#13;
        ProposalRecord storage proposal = ProposalsById[_proposalId];&#13;
&#13;
        if(result.requiredForResult == 0) {&#13;
            proposal.state = getRecordState("VOTING_RESULT_YES");&#13;
            runActionAfterResult(_proposalId);&#13;
        }&#13;
    }&#13;
&#13;
    function addActiveProposal(uint256 _proposalId) internal {&#13;
        ActiveProposalIds[ActiveProposalNum++]= _proposalId;&#13;
    }&#13;
&#13;
    function removeAndReindexActive(uint256 _proposalId) internal {&#13;
&#13;
        bool found = false;&#13;
        for (uint8 i = 0; i &lt; ActiveProposalNum; i++) {&#13;
            if(ActiveProposalIds[i] == _proposalId) {&#13;
                found = true;&#13;
            }&#13;
            if(found) {&#13;
                ActiveProposalIds[i] = ActiveProposalIds[i+1];&#13;
            }&#13;
        }&#13;
&#13;
        ActiveProposalNum--;&#13;
    }&#13;
&#13;
&#13;
    bool public EmergencyFundingReleaseApproved = false;&#13;
&#13;
    function runActionAfterResult(uint256 _proposalId) internal {&#13;
&#13;
        ProposalRecord storage proposal = ProposalsById[_proposalId];&#13;
&#13;
        if(proposal.state == getRecordState("VOTING_RESULT_YES")) {&#13;
&#13;
            if(proposal.actionType == getActionType("MILESTONE_DEADLINE")) {&#13;
&#13;
            } else if (proposal.actionType == getActionType("MILESTONE_POSTPONING")) {&#13;
&#13;
            } else if (proposal.actionType == getActionType("EMERGENCY_FUND_RELEASE")) {&#13;
                EmergencyFundingReleaseApproved = true;&#13;
&#13;
            } else if (proposal.actionType == getActionType("PROJECT_DELISTING")) {&#13;
&#13;
                ListingContractEntity.delistChild( proposal.extra );&#13;
&#13;
            } else if (&#13;
                proposal.actionType == getActionType("IN_DEVELOPMENT_CODE_UPGRADE") ||&#13;
                proposal.actionType == getActionType("AFTER_COMPLETE_CODE_UPGRADE")&#13;
            ) {&#13;
&#13;
                // initiate code upgrade&#13;
                acceptCodeUpgrade(_proposalId);&#13;
            }&#13;
&#13;
            removeAndReindexActive(_proposalId);&#13;
&#13;
        } else if(proposal.state == getRecordState("VOTING_RESULT_NO")) {&#13;
&#13;
            //&#13;
            if(proposal.actionType == getActionType("MILESTONE_DEADLINE")) {&#13;
&#13;
            } else {&#13;
                removeAndReindexActive(_proposalId);&#13;
            }&#13;
        }&#13;
    }&#13;
&#13;
    // used by vault cash back&#13;
    function getMyVoteForCurrentMilestoneRelease(address _voter) public view returns (bool) {&#13;
        // find proposal id for current milestone&#13;
        uint8 recordId = MilestonesEntity.currentRecord();&#13;
        bytes32 hash = getHash( getActionType("MILESTONE_DEADLINE"), bytes32( recordId ), 0 );&#13;
        uint256 proposalId = ProposalIdByHash[hash];&#13;
        // based on that proposal id, find my vote&#13;
        VoteStruct memory vote = VotesByCaster[proposalId][_voter];&#13;
        return vote.vote;&#13;
    }&#13;
&#13;
    function getHasVoteForCurrentMilestoneRelease(address _voter) public view returns (bool) {&#13;
        // find proposal id for current milestone&#13;
        uint8 recordId = MilestonesEntity.currentRecord();&#13;
        bytes32 hash = getHash( getActionType("MILESTONE_DEADLINE"), bytes32( recordId ), 0 );&#13;
        uint256 proposalId = ProposalIdByHash[hash];&#13;
        return hasPreviousVote(proposalId, _voter);&#13;
    }&#13;
&#13;
    function getMyVote(uint256 _proposalId, address _voter) public view returns (bool) {&#13;
        VoteStruct memory vote = VotesByCaster[_proposalId][_voter];&#13;
        return vote.vote;&#13;
    }&#13;
&#13;
}