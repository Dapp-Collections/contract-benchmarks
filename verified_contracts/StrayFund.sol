pragma solidity ^0.4.24;
// produced by the Solididy File Flattener (c) David Appleton 2018
// contact : <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="9df9fcebf8ddfcf6f2f0fffcb3fef2f0">[emailÂ protected]</a>&#13;
// released under Apache 2.0 licence&#13;
&#13;
library SafeMath {&#13;
&#13;
  /**&#13;
  * @dev Multiplies two numbers, throws on overflow.&#13;
  */&#13;
  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {&#13;
    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the&#13;
    // benefit is lost if 'b' is also tested.&#13;
    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522&#13;
    if (a == 0) {&#13;
      return 0;&#13;
    }&#13;
&#13;
    c = a * b;&#13;
    assert(c / a == b);&#13;
    return c;&#13;
  }&#13;
&#13;
  /**&#13;
  * @dev Integer division of two numbers, truncating the quotient.&#13;
  */&#13;
  function div(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
    // assert(b &gt; 0); // Solidity automatically throws when dividing by 0&#13;
    // uint256 c = a / b;&#13;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold&#13;
    return a / b;&#13;
  }&#13;
&#13;
  /**&#13;
  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).&#13;
  */&#13;
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
    assert(b &lt;= a);&#13;
    return a - b;&#13;
  }&#13;
&#13;
  /**&#13;
  * @dev Adds two numbers, throws on overflow.&#13;
  */&#13;
  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {&#13;
    c = a + b;&#13;
    assert(c &gt;= a);&#13;
    return c;&#13;
  }&#13;
}&#13;
&#13;
contract Ownable {&#13;
  address public owner;&#13;
&#13;
&#13;
  event OwnershipRenounced(address indexed previousOwner);&#13;
  event OwnershipTransferred(&#13;
    address indexed previousOwner,&#13;
    address indexed newOwner&#13;
  );&#13;
&#13;
&#13;
  /**&#13;
   * @dev The Ownable constructor sets the original `owner` of the contract to the sender&#13;
   * account.&#13;
   */&#13;
  constructor() public {&#13;
    owner = msg.sender;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Throws if called by any account other than the owner.&#13;
   */&#13;
  modifier onlyOwner() {&#13;
    require(msg.sender == owner);&#13;
    _;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Allows the current owner to relinquish control of the contract.&#13;
   * @notice Renouncing to ownership will leave the contract without an owner.&#13;
   * It will not be possible to call the functions with the `onlyOwner`&#13;
   * modifier anymore.&#13;
   */&#13;
  function renounceOwnership() public onlyOwner {&#13;
    emit OwnershipRenounced(owner);&#13;
    owner = address(0);&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Allows the current owner to transfer control of the contract to a newOwner.&#13;
   * @param _newOwner The address to transfer ownership to.&#13;
   */&#13;
  function transferOwnership(address _newOwner) public onlyOwner {&#13;
    _transferOwnership(_newOwner);&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Transfers control of the contract to a newOwner.&#13;
   * @param _newOwner The address to transfer ownership to.&#13;
   */&#13;
  function _transferOwnership(address _newOwner) internal {&#13;
    require(_newOwner != address(0));&#13;
    emit OwnershipTransferred(owner, _newOwner);&#13;
    owner = _newOwner;&#13;
  }&#13;
}&#13;
&#13;
library DateTimeUtility {&#13;
    &#13;
    function toGMT(uint256 _unixtime) &#13;
        pure &#13;
        internal &#13;
        returns(uint32, uint8, uint8, uint8, uint8, uint8)&#13;
    {&#13;
        // http://ptspts.blogspot.com/2009/11/how-to-convert-unix-timestamp-to-civil.html&#13;
        uint256 secs = _unixtime % 86400;&#13;
        &#13;
        _unixtime /= 86400;&#13;
        uint256 e = (_unixtime * 4 + 102032) / 146097 + 15;&#13;
        e = _unixtime + 2442113 + e - (e / 4);&#13;
        uint256 c = (e * 20 - 2442) / 7305;&#13;
        uint256 d = e - 365 * c - c / 4;&#13;
        e = d * 1000 / 30601;&#13;
        &#13;
        if (e &lt; 14) {&#13;
            return (uint32(c - 4716)&#13;
                , uint8(e - 1)&#13;
                , uint8(d - e * 30 - e * 601 / 1000)&#13;
                , uint8(secs / 3600)&#13;
                , uint8(secs / 60 % 60)&#13;
                , uint8(secs % 60));&#13;
        } else {&#13;
            return (uint32(c - 4715)&#13;
                , uint8(e - 13)&#13;
                , uint8(d - e * 30 - e * 601 / 1000)&#13;
                , uint8(secs / 3600)&#13;
                , uint8(secs / 60 % 60)&#13;
                , uint8(secs % 60));&#13;
        }&#13;
    } &#13;
    &#13;
    function toUnixtime(uint32 _year, uint8 _month, uint8 _mday, uint8 _hour, uint8 _minute, uint8 _second) &#13;
        pure &#13;
        internal &#13;
        returns (uint256)&#13;
    {&#13;
        // http://ptspts.blogspot.com/2009/11/how-to-convert-unix-timestamp-to-civil.html&#13;
        &#13;
        uint256 m = uint256(_month);&#13;
        uint256 y = uint256(_year);&#13;
        if (m &lt;= 2) {&#13;
            y -= 1;&#13;
            m += 12;&#13;
        }&#13;
        &#13;
        return (365 * y + y / 4 -  y/ 100 + y / 400 + 3 * (m + 1) / 5 + 30 * m + uint256(_mday) - 719561) * 86400 &#13;
            + 3600 * uint256(_hour) + 60 * uint256(_minute) + uint256(_second);&#13;
    }&#13;
}&#13;
&#13;
contract ERC20Basic {&#13;
  function totalSupply() public view returns (uint256);&#13;
  function balanceOf(address who) public view returns (uint256);&#13;
  function transfer(address to, uint256 value) public returns (bool);&#13;
  event Transfer(address indexed from, address indexed to, uint256 value);&#13;
}&#13;
&#13;
library SafeERC20 {&#13;
  function safeTransfer(ERC20Basic token, address to, uint256 value) internal {&#13;
    require(token.transfer(to, value));&#13;
  }&#13;
&#13;
  function safeTransferFrom(&#13;
    ERC20 token,&#13;
    address from,&#13;
    address to,&#13;
    uint256 value&#13;
  )&#13;
    internal&#13;
  {&#13;
    require(token.transferFrom(from, to, value));&#13;
  }&#13;
&#13;
  function safeApprove(ERC20 token, address spender, uint256 value) internal {&#13;
    require(token.approve(spender, value));&#13;
  }&#13;
}&#13;
&#13;
contract BasicToken is ERC20Basic {&#13;
  using SafeMath for uint256;&#13;
&#13;
  mapping(address =&gt; uint256) balances;&#13;
&#13;
  uint256 totalSupply_;&#13;
&#13;
  /**&#13;
  * @dev Total number of tokens in existence&#13;
  */&#13;
  function totalSupply() public view returns (uint256) {&#13;
    return totalSupply_;&#13;
  }&#13;
&#13;
  /**&#13;
  * @dev Transfer token for a specified address&#13;
  * @param _to The address to transfer to.&#13;
  * @param _value The amount to be transferred.&#13;
  */&#13;
  function transfer(address _to, uint256 _value) public returns (bool) {&#13;
    require(_to != address(0));&#13;
    require(_value &lt;= balances[msg.sender]);&#13;
&#13;
    balances[msg.sender] = balances[msg.sender].sub(_value);&#13;
    balances[_to] = balances[_to].add(_value);&#13;
    emit Transfer(msg.sender, _to, _value);&#13;
    return true;&#13;
  }&#13;
&#13;
  /**&#13;
  * @dev Gets the balance of the specified address.&#13;
  * @param _owner The address to query the the balance of.&#13;
  * @return An uint256 representing the amount owned by the passed address.&#13;
  */&#13;
  function balanceOf(address _owner) public view returns (uint256) {&#13;
    return balances[_owner];&#13;
  }&#13;
&#13;
}&#13;
&#13;
contract ERC20 is ERC20Basic {&#13;
  function allowance(address owner, address spender)&#13;
    public view returns (uint256);&#13;
&#13;
  function transferFrom(address from, address to, uint256 value)&#13;
    public returns (bool);&#13;
&#13;
  function approve(address spender, uint256 value) public returns (bool);&#13;
  event Approval(&#13;
    address indexed owner,&#13;
    address indexed spender,&#13;
    uint256 value&#13;
  );&#13;
}&#13;
&#13;
contract StandardToken is ERC20, BasicToken {&#13;
&#13;
  mapping (address =&gt; mapping (address =&gt; uint256)) internal allowed;&#13;
&#13;
&#13;
  /**&#13;
   * @dev Transfer tokens from one address to another&#13;
   * @param _from address The address which you want to send tokens from&#13;
   * @param _to address The address which you want to transfer to&#13;
   * @param _value uint256 the amount of tokens to be transferred&#13;
   */&#13;
  function transferFrom(&#13;
    address _from,&#13;
    address _to,&#13;
    uint256 _value&#13;
  )&#13;
    public&#13;
    returns (bool)&#13;
  {&#13;
    require(_to != address(0));&#13;
    require(_value &lt;= balances[_from]);&#13;
    require(_value &lt;= allowed[_from][msg.sender]);&#13;
&#13;
    balances[_from] = balances[_from].sub(_value);&#13;
    balances[_to] = balances[_to].add(_value);&#13;
    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);&#13;
    emit Transfer(_from, _to, _value);&#13;
    return true;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.&#13;
   * Beware that changing an allowance with this method brings the risk that someone may use both the old&#13;
   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this&#13;
   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:&#13;
   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729&#13;
   * @param _spender The address which will spend the funds.&#13;
   * @param _value The amount of tokens to be spent.&#13;
   */&#13;
  function approve(address _spender, uint256 _value) public returns (bool) {&#13;
    allowed[msg.sender][_spender] = _value;&#13;
    emit Approval(msg.sender, _spender, _value);&#13;
    return true;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Function to check the amount of tokens that an owner allowed to a spender.&#13;
   * @param _owner address The address which owns the funds.&#13;
   * @param _spender address The address which will spend the funds.&#13;
   * @return A uint256 specifying the amount of tokens still available for the spender.&#13;
   */&#13;
  function allowance(&#13;
    address _owner,&#13;
    address _spender&#13;
   )&#13;
    public&#13;
    view&#13;
    returns (uint256)&#13;
  {&#13;
    return allowed[_owner][_spender];&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Increase the amount of tokens that an owner allowed to a spender.&#13;
   * approve should be called when allowed[_spender] == 0. To increment&#13;
   * allowed value is better to use this function to avoid 2 calls (and wait until&#13;
   * the first transaction is mined)&#13;
   * From MonolithDAO Token.sol&#13;
   * @param _spender The address which will spend the funds.&#13;
   * @param _addedValue The amount of tokens to increase the allowance by.&#13;
   */&#13;
  function increaseApproval(&#13;
    address _spender,&#13;
    uint256 _addedValue&#13;
  )&#13;
    public&#13;
    returns (bool)&#13;
  {&#13;
    allowed[msg.sender][_spender] = (&#13;
      allowed[msg.sender][_spender].add(_addedValue));&#13;
    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);&#13;
    return true;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Decrease the amount of tokens that an owner allowed to a spender.&#13;
   * approve should be called when allowed[_spender] == 0. To decrement&#13;
   * allowed value is better to use this function to avoid 2 calls (and wait until&#13;
   * the first transaction is mined)&#13;
   * From MonolithDAO Token.sol&#13;
   * @param _spender The address which will spend the funds.&#13;
   * @param _subtractedValue The amount of tokens to decrease the allowance by.&#13;
   */&#13;
  function decreaseApproval(&#13;
    address _spender,&#13;
    uint256 _subtractedValue&#13;
  )&#13;
    public&#13;
    returns (bool)&#13;
  {&#13;
    uint256 oldValue = allowed[msg.sender][_spender];&#13;
    if (_subtractedValue &gt; oldValue) {&#13;
      allowed[msg.sender][_spender] = 0;&#13;
    } else {&#13;
      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);&#13;
    }&#13;
    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);&#13;
    return true;&#13;
  }&#13;
&#13;
}&#13;
&#13;
contract BurnableToken is BasicToken {&#13;
&#13;
  event Burn(address indexed burner, uint256 value);&#13;
&#13;
  /**&#13;
   * @dev Burns a specific amount of tokens.&#13;
   * @param _value The amount of token to be burned.&#13;
   */&#13;
  function burn(uint256 _value) public {&#13;
    _burn(msg.sender, _value);&#13;
  }&#13;
&#13;
  function _burn(address _who, uint256 _value) internal {&#13;
    require(_value &lt;= balances[_who]);&#13;
    // no need to require value &lt;= totalSupply, since that would imply the&#13;
    // sender's balance is greater than the totalSupply, which *should* be an assertion failure&#13;
&#13;
    balances[_who] = balances[_who].sub(_value);&#13;
    totalSupply_ = totalSupply_.sub(_value);&#13;
    emit Burn(_who, _value);&#13;
    emit Transfer(_who, address(0), _value);&#13;
  }&#13;
}&#13;
&#13;
contract StrayToken is StandardToken, BurnableToken, Ownable {&#13;
	using SafeERC20 for ERC20;&#13;
	&#13;
	uint256 public INITIAL_SUPPLY = 1000000000;&#13;
	&#13;
	string public name = "Stray";&#13;
	string public symbol = "ST";&#13;
	uint8 public decimals = 18;&#13;
&#13;
	address public companyWallet;&#13;
	address public privateWallet;&#13;
	address public fund;&#13;
	&#13;
	/**&#13;
	 * @param _companyWallet The company wallet which reserves 15% of the token.&#13;
	 * @param _privateWallet Private wallet which reservers 25% of the token.&#13;
	 */&#13;
	constructor(address _companyWallet, address _privateWallet) public {&#13;
		require(_companyWallet != address(0));&#13;
		require(_privateWallet != address(0));&#13;
		&#13;
		totalSupply_ = INITIAL_SUPPLY * (10 ** uint256(decimals));&#13;
		companyWallet = _companyWallet;&#13;
		privateWallet = _privateWallet;&#13;
		&#13;
		// 15% of tokens for company reserved.&#13;
		_preSale(companyWallet, totalSupply_.mul(15).div(100));&#13;
		&#13;
		// 25% of tokens for private funding.&#13;
		_preSale(privateWallet, totalSupply_.mul(25).div(100));&#13;
		&#13;
		// 60% of tokens for crowdsale.&#13;
		uint256 sold = balances[companyWallet].add(balances[privateWallet]);&#13;
	    balances[msg.sender] = balances[msg.sender].add(totalSupply_.sub(sold));&#13;
	    emit Transfer(address(0), msg.sender, balances[msg.sender]);&#13;
	}&#13;
	&#13;
	/**&#13;
	 * @param _fund The DAICO fund contract address.&#13;
	 */&#13;
	function setFundContract(address _fund) onlyOwner public {&#13;
	    require(_fund != address(0));&#13;
	    //require(_fund != owner);&#13;
	    //require(_fund != msg.sender);&#13;
	    require(_fund != address(this));&#13;
	    &#13;
	    fund = _fund;&#13;
	}&#13;
	&#13;
	/**&#13;
	 * @dev The DAICO fund contract calls this function to burn the user's token&#13;
	 * to avoid over refund.&#13;
	 * @param _from The address which just took its refund.&#13;
	 */&#13;
	function burnAll(address _from) public {&#13;
	    require(fund == msg.sender);&#13;
	    require(0 != balances[_from]);&#13;
	    &#13;
	    _burn(_from, balances[_from]);&#13;
	}&#13;
	&#13;
	/**&#13;
	 * @param _to The address which will get the token.&#13;
	 * @param _value The token amount.&#13;
	 */&#13;
	function _preSale(address _to, uint256 _value) internal onlyOwner {&#13;
		balances[_to] = _value;&#13;
		emit Transfer(address(0), _to, _value);&#13;
	}&#13;
	&#13;
}&#13;
&#13;
contract StrayFund is Ownable {&#13;
	using SafeMath for uint256;&#13;
	using DateTimeUtility for uint256;&#13;
	&#13;
    // The fund state.&#13;
	enum State {&#13;
	    NotReady       // The fund is not ready for any operations.&#13;
	    , TeamWithdraw // The fund can be withdrawn and voting proposals.&#13;
	    , Refunding    // The fund only can be refund..&#13;
	    , Closed       // The fund is closed.&#13;
	}&#13;
	&#13;
&#13;
	// @dev Proposal type for voting.&#13;
	enum ProposalType { &#13;
	    Tap          // Tap proposal sponsored by token holder out of company.&#13;
	    , OfficalTap // Tap proposal sponsored by company.&#13;
	    , Refund     // Refund proposal.&#13;
	}&#13;
	&#13;
	// A special number indicates that no valid id.&#13;
	uint256 NON_UINT256 = (2 ** 256) - 1;&#13;
	&#13;
	// Data type represent a vote.&#13;
	struct Vote {&#13;
		address tokeHolder; // Voter address.&#13;
		bool inSupport;     // Support or not.&#13;
	}&#13;
	&#13;
	// Voting proposal.&#13;
	struct Proposal {              &#13;
	    ProposalType proposalType; // Proposal type.&#13;
	    address sponsor;           // Who proposed this vote.&#13;
	    uint256 openingTime;       // Opening time of the voting.&#13;
	    uint256 closingTime;       // Closing time of the voting.&#13;
	    Vote[] votes;              // All votes.&#13;
		mapping (address =&gt; bool) voted; // Prevent duplicate vote.&#13;
		bool isPassed;             // Final result.&#13;
		bool isFinialized;         // Proposal state.&#13;
		uint256 targetWei;         // Tap proposal target.&#13;
	}&#13;
	&#13;
	// Budget plan stands a budget period for the team to withdraw the funds.&#13;
	struct BudgetPlan {&#13;
	    uint256 proposalId;       // The tap proposal id.&#13;
	    uint256 budgetInWei;      // Budget in wei.&#13;
	    uint256 withdrawnWei;     // Withdrawn wei.&#13;
	    uint256 startTime;        // Start time of this budget plan. &#13;
	    uint256 endTime;          // End time of this budget plan.&#13;
	    uint256 officalVotingTime; // The offical tap voting time in this period.&#13;
	}&#13;
	&#13;
	// Team wallet to receive the budget.&#13;
	address public teamWallet;&#13;
	&#13;
	// Fund state.&#13;
	State public state;&#13;
	&#13;
	// Stary Token.&#13;
	StrayToken public token;&#13;
	&#13;
	// Proposal history.&#13;
	Proposal[] public proposals;&#13;
	&#13;
	// Budget plan history.&#13;
	BudgetPlan[] public budgetPlans;&#13;
	&#13;
	// Current budget plan id.&#13;
	uint256 currentBudgetPlanId;&#13;
	&#13;
	// The mininum budget.&#13;
	uint256 public MIN_WITHDRAW_WEI = 1 ether;&#13;
	&#13;
	// The fist withdraw rate when the crowdsale was successed.&#13;
	uint256 public FIRST_WITHDRAW_RATE = 20;&#13;
	&#13;
	// The voting duration.&#13;
	uint256 public VOTING_DURATION = 1 weeks;&#13;
	&#13;
	// Offical voting day of the last month of budget period. &#13;
	uint8 public OFFICAL_VOTING_DAY_OF_MONTH = 23;&#13;
	&#13;
	// Refund lock duration.&#13;
	uint256 public REFUND_LOCK_DURATION = 30 days;&#13;
	&#13;
	// Refund lock date.&#13;
	uint256 public refundLockDate = 0;&#13;
	&#13;
	event TeamWithdrawEnabled();&#13;
	event RefundsEnabled();&#13;
	event Closed();&#13;
	&#13;
	event TapVoted(address indexed voter, bool isSupported);&#13;
	event TapProposalAdded(uint256 openingTime, uint256 closingTime, uint256 targetWei);&#13;
	event TapProposalClosed(uint256 closingTime, uint256 targetWei, bool isPassed);&#13;
	&#13;
	event RefundVoted(address indexed voter, bool isSupported);&#13;
	event RefundProposalAdded(uint256 openingTime, uint256 closingTime);&#13;
	event RefundProposalClosed(uint256 closingTime, bool isPassed);&#13;
	&#13;
	event Withdrew(uint256 weiAmount);&#13;
	event Refund(address indexed holder, uint256 amount);&#13;
	&#13;
	modifier onlyTokenHolders {&#13;
		require(token.balanceOf(msg.sender) != 0);&#13;
		_;&#13;
	}&#13;
	&#13;
	modifier inWithdrawState {&#13;
	    require(state == State.TeamWithdraw);&#13;
	    _;&#13;
	}&#13;
	&#13;
	/**&#13;
	 * @param _teamWallet The wallet which receives the funds.&#13;
	 * @param _token Stray token address.&#13;
	 */&#13;
    constructor(address _teamWallet, address _token) public {&#13;
		require(_teamWallet != address(0));&#13;
		require(_token != address(0));&#13;
		&#13;
		teamWallet = _teamWallet;&#13;
		state = State.NotReady;&#13;
		token = StrayToken(_token);&#13;
	}&#13;
	&#13;
	/**&#13;
	 * @dev Enable the TeamWithdraw state.&#13;
	 */&#13;
	function enableTeamWithdraw() onlyOwner public {&#13;
		require(state == State.NotReady);&#13;
		state = State.TeamWithdraw;&#13;
		emit TeamWithdrawEnabled();&#13;
		&#13;
		budgetPlans.length++;&#13;
		BudgetPlan storage plan = budgetPlans[0];&#13;
		&#13;
	    plan.proposalId = NON_UINT256;&#13;
	    plan.budgetInWei = address(this).balance.mul(FIRST_WITHDRAW_RATE).div(100);&#13;
	    plan.withdrawnWei = 0;&#13;
	    plan.startTime = now;&#13;
	    (plan.endTime, plan.officalVotingTime) = _budgetEndAndOfficalVotingTime(now);&#13;
	    &#13;
	    currentBudgetPlanId = 0;&#13;
	}&#13;
	&#13;
	/**&#13;
	 * @dev Close the fund.&#13;
	 */&#13;
	function close() onlyOwner inWithdrawState public {&#13;
	    require(address(this).balance &lt; MIN_WITHDRAW_WEI);&#13;
	    &#13;
		state = State.Closed;&#13;
		emit Closed();&#13;
		&#13;
		teamWallet.transfer(address(this).balance);&#13;
	}&#13;
	&#13;
	/**&#13;
	 * @dev Check if there is an ongoing proposal.&#13;
	 */&#13;
	function isThereAnOnGoingProposal() public view returns (bool) {&#13;
	    if (proposals.length == 0 || state != State.TeamWithdraw) {&#13;
	        return false;&#13;
	    } else {&#13;
	        Proposal storage p = proposals[proposals.length - 1];&#13;
	        return now &lt; p.closingTime;&#13;
	    }&#13;
	}&#13;
	&#13;
	/**&#13;
	 * @dev Check if next budget period plan has been made.&#13;
	 */&#13;
	function isNextBudgetPlanMade() public view returns (bool) {&#13;
	    if (state != State.TeamWithdraw) {&#13;
	        return false;&#13;
	    } else {&#13;
	        return currentBudgetPlanId != budgetPlans.length - 1;&#13;
	    }&#13;
	}&#13;
	&#13;
	/**&#13;
	 * @dev Get number of proposals. &#13;
	 */&#13;
	function numberOfProposals() public view returns (uint256) {&#13;
	    return proposals.length;&#13;
	}&#13;
	&#13;
	/**&#13;
	 * @dev Get number of budget plans. &#13;
	 */&#13;
	function numberOfBudgetPlan() public view returns (uint256) {&#13;
	    return budgetPlans.length;&#13;
	}&#13;
	&#13;
	/**&#13;
	 * @dev Try to finialize the last proposal.&#13;
	 */&#13;
	function tryFinializeLastProposal() inWithdrawState public {&#13;
	    if (proposals.length == 0) {&#13;
	        return;&#13;
	    }&#13;
	    &#13;
	    uint256 id = proposals.length - 1;&#13;
	    Proposal storage p = proposals[id];&#13;
	    if (now &gt; p.closingTime &amp;&amp; !p.isFinialized) {&#13;
	        _countVotes(p);&#13;
	        if (p.isPassed) {&#13;
	            if (p.proposalType == ProposalType.Refund) {&#13;
	                _enableRefunds();&#13;
	            } else {&#13;
	                _makeBudgetPlan(p, id);&#13;
	            }&#13;
	        }&#13;
	    }&#13;
	}&#13;
	&#13;
	/**&#13;
	 * @dev Create new tap proposal by address out of company.&#13;
	 * @param _targetWei The voting target.&#13;
	 */&#13;
	function newTapProposalFromTokenHolders(uint256 _targetWei)&#13;
	    onlyTokenHolders &#13;
	    inWithdrawState &#13;
	    public&#13;
	{&#13;
	    // Sponsor cannot be stuff of company.&#13;
	    require(msg.sender != owner);&#13;
	    require(msg.sender != teamWallet);&#13;
	    &#13;
	    // Check the last result.&#13;
	    tryFinializeLastProposal();&#13;
	    require(state == State.TeamWithdraw);&#13;
	    &#13;
	    // Proposal is disable when the budget plan has been made.&#13;
	    require(!isNextBudgetPlanMade());&#13;
	    &#13;
	    // Proposal voting is exclusive.&#13;
	    require(!isThereAnOnGoingProposal());&#13;
	    &#13;
	    // Validation of time restriction.&#13;
	    BudgetPlan storage b = budgetPlans[currentBudgetPlanId];&#13;
		require(now &lt;= b.officalVotingTime &amp;&amp; now &gt;= b.startTime);&#13;
		&#13;
		// Sponsor is not allowed to propose repeatly in the same budget period.&#13;
		require(!_hasProposed(msg.sender, ProposalType.Tap));&#13;
		&#13;
		// Create a new proposal.&#13;
		_newTapProposal(ProposalType.Tap, _targetWei);&#13;
	}&#13;
	&#13;
	/**&#13;
	 * @dev Create new tap proposal by company.&#13;
	 * @param _targetWei The voting target.&#13;
	 */&#13;
	function newTapProposalFromCompany(uint256 _targetWei)&#13;
	    onlyOwner &#13;
	    inWithdrawState &#13;
	    public&#13;
	{&#13;
	    // Check the last result.&#13;
	    tryFinializeLastProposal();&#13;
	    require(state == State.TeamWithdraw);&#13;
	    &#13;
	    // Proposal is disable when the budget plan has been made.&#13;
	    require(!isNextBudgetPlanMade());&#13;
	    &#13;
	    // Proposal voting is exclusive.&#13;
	    require(!isThereAnOnGoingProposal());&#13;
	    &#13;
	    // Validation of time restriction.&#13;
	    BudgetPlan storage b = budgetPlans[currentBudgetPlanId];&#13;
		require(now &gt;= b.officalVotingTime);&#13;
		&#13;
		// Create a new proposal.&#13;
		_newTapProposal(ProposalType.OfficalTap, _targetWei);&#13;
	}&#13;
	&#13;
	/**&#13;
	 * @dev Create a refund proposal.&#13;
	 */&#13;
	function newRefundProposal() onlyTokenHolders inWithdrawState public {&#13;
	    // Check the last result.&#13;
	    tryFinializeLastProposal();&#13;
	    require(state == State.TeamWithdraw);&#13;
	    &#13;
	    // Proposal voting is exclusive.&#13;
	    require(!isThereAnOnGoingProposal());&#13;
	    &#13;
	    // Sponsor is not allowed to propose repeatly in the same budget period.&#13;
	    require(!_hasProposed(msg.sender, ProposalType.Refund));&#13;
	    &#13;
	    // Create proposals.&#13;
		uint256 id = proposals.length++;&#13;
		Proposal storage p = proposals[id];&#13;
		p.proposalType = ProposalType.Refund;&#13;
		p.sponsor = msg.sender;&#13;
		p.openingTime = now;&#13;
		p.closingTime = now + VOTING_DURATION;&#13;
		p.isPassed = false;&#13;
		p.isFinialized = false;&#13;
		&#13;
		// Signal the event.&#13;
		emit RefundProposalAdded(p.openingTime, p.closingTime);&#13;
	}&#13;
	&#13;
	/**&#13;
	 * @dev Vote for a tap proposal.&#13;
	 * @param _supportsProposal True if the vote supports the proposal.&#13;
	 */&#13;
	function voteForTap(bool _supportsProposal)&#13;
	    onlyTokenHolders&#13;
	    inWithdrawState&#13;
	    public&#13;
	{&#13;
	    // Check the last result.&#13;
	    tryFinializeLastProposal();&#13;
		require(isThereAnOnGoingProposal());&#13;
		&#13;
		// Check the ongoing proposal's type and reject the voted address.&#13;
		Proposal storage p = proposals[proposals.length - 1];&#13;
		require(p.proposalType != ProposalType.Refund);&#13;
		require(true != p.voted[msg.sender]);&#13;
		&#13;
		// Record the vote.&#13;
		uint256 voteId = p.votes.length++;&#13;
		p.votes[voteId].tokeHolder = msg.sender;&#13;
		p.votes[voteId].inSupport = _supportsProposal;&#13;
		p.voted[msg.sender] = true;&#13;
		&#13;
		// Signal the event.&#13;
		emit TapVoted(msg.sender, _supportsProposal);&#13;
	}&#13;
	&#13;
	/**&#13;
	 * @dev Vote for a tap proposal.&#13;
	 * @param _supportsProposal True if the vote supports the proposal.&#13;
	 */&#13;
	function voteForRefund(bool _supportsProposal)&#13;
	    onlyTokenHolders&#13;
	    inWithdrawState&#13;
	    public&#13;
	{&#13;
	    // Check the last result.&#13;
	    tryFinializeLastProposal();&#13;
		require(isThereAnOnGoingProposal());&#13;
		&#13;
		// Check the ongoing proposal's type and reject the voted address.&#13;
		Proposal storage p = proposals[proposals.length - 1];&#13;
		require(p.proposalType == ProposalType.Refund);&#13;
		require(true != p.voted[msg.sender]);&#13;
		&#13;
		// Record the vote.&#13;
		uint256 voteId = p.votes.length++;&#13;
		p.votes[voteId].tokeHolder = msg.sender;&#13;
		p.votes[voteId].inSupport = _supportsProposal;&#13;
		p.voted[msg.sender] = true;&#13;
		&#13;
		// Signal the event.&#13;
		emit RefundVoted(msg.sender, _supportsProposal);&#13;
	}&#13;
	&#13;
	/**&#13;
	 * @dev Withdraw the wei to team wallet.&#13;
	 * @param _amount Withdraw wei.&#13;
	 */&#13;
	function withdraw(uint256 _amount) onlyOwner inWithdrawState public {&#13;
	    // Check the last result.&#13;
	    tryFinializeLastProposal();&#13;
	    require(state == State.TeamWithdraw);&#13;
	    &#13;
	    // Try to update the budget plans.&#13;
	    BudgetPlan storage currentPlan = budgetPlans[currentBudgetPlanId];&#13;
	    if (now &gt; currentPlan.endTime) {&#13;
	        require(isNextBudgetPlanMade());&#13;
	        ++currentBudgetPlanId;&#13;
	    }&#13;
	    &#13;
	    // Withdraw the weis.&#13;
	    _withdraw(_amount);&#13;
	}&#13;
	&#13;
	/**&#13;
	 * @dev Withdraw when there is no budget plans.&#13;
	 */&#13;
	function withdrawOnNoAvailablePlan() onlyOwner inWithdrawState public {&#13;
	    require(address(this).balance &gt;= MIN_WITHDRAW_WEI);&#13;
	    &#13;
	    // Check the last result.&#13;
	    tryFinializeLastProposal();&#13;
	    require(state == State.TeamWithdraw);&#13;
	    &#13;
	    // Check if someone proposed a tap voting.&#13;
	    require(!_isThereAnOnGoingTapProposal());&#13;
	    &#13;
	    // There is no passed budget plan.&#13;
	    require(!isNextBudgetPlanMade());&#13;
	    &#13;
	    // Validate the time.&#13;
	    BudgetPlan storage currentPlan = budgetPlans[currentBudgetPlanId];&#13;
	    require(now &gt; currentPlan.endTime);&#13;
	    &#13;
	    // Create plan.&#13;
	    uint256 planId = budgetPlans.length++;&#13;
	    BudgetPlan storage plan = budgetPlans[planId];&#13;
	    plan.proposalId = NON_UINT256;&#13;
	    plan.budgetInWei = MIN_WITHDRAW_WEI;&#13;
	    plan.withdrawnWei = 0;&#13;
	    plan.startTime = now;&#13;
	    (plan.endTime, plan.officalVotingTime) = _budgetEndAndOfficalVotingTime(now);&#13;
	    &#13;
	    ++currentBudgetPlanId;&#13;
	    &#13;
	    // Withdraw the weis.&#13;
	    _withdraw(MIN_WITHDRAW_WEI);&#13;
	}&#13;
	&#13;
	/**&#13;
     * @dev Tokenholders can claim refunds here.&#13;
     */&#13;
	function claimRefund() onlyTokenHolders public {&#13;
	    // Check the state.&#13;
		require(state == State.Refunding);&#13;
		&#13;
		// Validate the time.&#13;
		require(now &gt; refundLockDate + REFUND_LOCK_DURATION);&#13;
		&#13;
		// Calculate the transfering wei and burn all the token of the refunder.&#13;
		uint256 amount = address(this).balance.mul(token.balanceOf(msg.sender)).div(token.totalSupply());&#13;
		token.burnAll(msg.sender);&#13;
		&#13;
		// Signal the event.&#13;
		msg.sender.transfer(amount);&#13;
	}&#13;
	&#13;
	/**&#13;
	 * @dev Check if refund is in lock period.&#13;
	 */&#13;
	 function isRefundLocked() public view returns (bool) {&#13;
	     return state == State.Refunding &amp;&amp; now &lt; refundLockDate + REFUND_LOCK_DURATION;&#13;
	 }&#13;
	&#13;
	/**&#13;
	 * @dev Get remaining funds.&#13;
	 */&#13;
	 function remainingFunds() public view returns (uint256) {&#13;
	     return address(this).balance;&#13;
	 }&#13;
	&#13;
	/**&#13;
     * @dev Receive the initial funds from crowdsale contract.&#13;
     */&#13;
	function receiveInitialFunds() payable public {&#13;
	    require(state == State.NotReady);&#13;
	}&#13;
	&#13;
	/**&#13;
     * @dev Fallback function to receive initial funds.&#13;
     */&#13;
	function () payable public {&#13;
	    receiveInitialFunds();&#13;
	}&#13;
	&#13;
	function _withdraw(uint256 _amount) internal {&#13;
	    BudgetPlan storage plan = budgetPlans[currentBudgetPlanId];&#13;
	    &#13;
	    // Validate the time.&#13;
	    require(now &lt;= plan.endTime);&#13;
	    &#13;
	    // Check the remaining wei.&#13;
	    require(_amount + plan.withdrawnWei &lt;= plan.budgetInWei);&#13;
	       &#13;
	    // Transfer the wei.&#13;
	    plan.withdrawnWei += _amount;&#13;
	    teamWallet.transfer(_amount);&#13;
	    &#13;
	    // Signal the event.&#13;
	    emit Withdrew(_amount);&#13;
	}&#13;
	&#13;
	function _countVotes(Proposal storage p)&#13;
	    internal &#13;
	    returns (bool)&#13;
	{&#13;
	    require(!p.isFinialized);&#13;
	    require(now &gt; p.closingTime);&#13;
	    &#13;
		uint256 yes = 0;&#13;
		uint256 no = 0;&#13;
		&#13;
		for (uint256 i = 0; i &lt; p.votes.length; ++i) {&#13;
			Vote storage v = p.votes[i];&#13;
			uint256 voteWeight = token.balanceOf(v.tokeHolder);&#13;
			if (v.inSupport) {&#13;
				yes += voteWeight;&#13;
			} else {&#13;
				no += voteWeight;&#13;
			}&#13;
		}&#13;
		&#13;
		p.isPassed = (yes &gt;= no);&#13;
		p.isFinialized = true;&#13;
		&#13;
		emit TapProposalClosed(p.closingTime&#13;
			, p.targetWei&#13;
			, p.isPassed);&#13;
		&#13;
		return p.isPassed;&#13;
	}&#13;
	&#13;
	function _enableRefunds() inWithdrawState internal {&#13;
	    state = State.Refunding;&#13;
		emit RefundsEnabled();&#13;
		&#13;
		refundLockDate = now;&#13;
	}&#13;
	&#13;
	function _makeBudgetPlan(Proposal storage p, uint256 proposalId) &#13;
	    internal&#13;
	{&#13;
	    require(p.proposalType != ProposalType.Refund);&#13;
	    require(p.isFinialized);&#13;
	    require(p.isPassed);&#13;
	    require(!isNextBudgetPlanMade());&#13;
	    &#13;
	    uint256 planId = budgetPlans.length++;&#13;
	    BudgetPlan storage plan = budgetPlans[planId];&#13;
	    plan.proposalId = proposalId;&#13;
	    plan.budgetInWei = p.targetWei;&#13;
	    plan.withdrawnWei = 0;&#13;
	    &#13;
	    if (now &gt; budgetPlans[currentBudgetPlanId].endTime) {&#13;
	        plan.startTime = now;&#13;
	        (plan.endTime, plan.officalVotingTime) = _budgetEndAndOfficalVotingTime(now);&#13;
	        ++currentBudgetPlanId;&#13;
	    } else {&#13;
	        (plan.startTime, plan.endTime, plan.officalVotingTime) = _nextBudgetStartAndEndAndOfficalVotingTime();&#13;
	    }&#13;
	}&#13;
	&#13;
	function _newTapProposal(ProposalType _proposalType, uint256 _targetWei) internal {&#13;
	    // The minimum wei requirement.&#13;
		require(_targetWei &gt;= MIN_WITHDRAW_WEI &amp;&amp; _targetWei &lt;= address(this).balance);&#13;
	    &#13;
	    uint256 id = proposals.length++;&#13;
        Proposal storage p = proposals[id];&#13;
        p.proposalType = _proposalType;&#13;
		p.sponsor = msg.sender;&#13;
		p.openingTime = now;&#13;
		p.closingTime = now + VOTING_DURATION;&#13;
		p.isPassed = false;&#13;
		p.isFinialized = false;&#13;
		p.targetWei = _targetWei;&#13;
		&#13;
		emit TapProposalAdded(p.openingTime&#13;
			, p.closingTime&#13;
			, p.targetWei);&#13;
	}&#13;
	&#13;
	function _isThereAnOnGoingTapProposal() internal view returns (bool) {&#13;
	    if (proposals.length == 0) {&#13;
	        return false;&#13;
	    } else {&#13;
	        Proposal storage p = proposals[proposals.length - 1];&#13;
	        return p.proposalType != ProposalType.Refund  &amp;&amp; now &lt; p.closingTime;&#13;
	    }&#13;
	}&#13;
	&#13;
	function _budgetEndAndOfficalVotingTime(uint256 _startTime)&#13;
	    view&#13;
	    internal&#13;
	    returns (uint256, uint256)&#13;
	{&#13;
	    // Decompose to datetime.&#13;
        uint32 year;&#13;
        uint8 month;&#13;
        uint8 mday;&#13;
        uint8 hour;&#13;
        uint8 minute;&#13;
        uint8 second;&#13;
        (year, month, mday, hour, minute, second) = _startTime.toGMT();&#13;
        &#13;
        // Calculate the next end time of budget period.&#13;
        month = ((month - 1) / 3 + 1) * 3 + 1;&#13;
        if (month &gt; 12) {&#13;
            month -= 12;&#13;
            year += 1;&#13;
        }&#13;
        &#13;
        mday = 1;&#13;
        hour = 0;&#13;
        minute = 0;&#13;
        second = 0;&#13;
        &#13;
        uint256 end = DateTimeUtility.toUnixtime(year, month, mday, hour, minute, second) - 1;&#13;
     &#13;
         // Calculate the offical voting time of the budget period.&#13;
        mday = OFFICAL_VOTING_DAY_OF_MONTH;&#13;
        hour = 0;&#13;
        minute = 0;&#13;
        second = 0;&#13;
        &#13;
        uint256 votingTime = DateTimeUtility.toUnixtime(year, month, mday, hour, minute, second);&#13;
        &#13;
        return (end, votingTime);&#13;
	}&#13;
    &#13;
    function _nextBudgetStartAndEndAndOfficalVotingTime() &#13;
        view &#13;
        internal &#13;
        returns (uint256, uint256, uint256)&#13;
    {&#13;
        // Decompose to datetime.&#13;
        uint32 year;&#13;
        uint8 month;&#13;
        uint8 mday;&#13;
        uint8 hour;&#13;
        uint8 minute;&#13;
        uint8 second;&#13;
        (year, month, mday, hour, minute, second) = now.toGMT();&#13;
        &#13;
        // Calculate the next start time of budget period. (1/1, 4/1, 7/1, 10/1)&#13;
        month = ((month - 1) / 3 + 1) * 3 + 1;&#13;
        if (month &gt; 12) {&#13;
            month -= 12;&#13;
            year += 1;&#13;
        }&#13;
        &#13;
        mday = 1;&#13;
        hour = 0;&#13;
        minute = 0;&#13;
        second = 0;&#13;
        &#13;
        uint256 start = DateTimeUtility.toUnixtime(year, month, mday, hour, minute, second);&#13;
        &#13;
        // Calculate the next end time of budget period.&#13;
        month = ((month - 1) / 3 + 1) * 3 + 1;&#13;
        if (month &gt; 12) {&#13;
            month -= 12;&#13;
            year += 1;&#13;
        }&#13;
        &#13;
        uint256 end = DateTimeUtility.toUnixtime(year, month, mday, hour, minute, second) - 1;&#13;
        &#13;
        // Calculate the offical voting time of the budget period.&#13;
        mday = OFFICAL_VOTING_DAY_OF_MONTH;&#13;
        hour = 0;&#13;
        minute = 0;&#13;
        second = 0;&#13;
        &#13;
        uint256 votingTime = DateTimeUtility.toUnixtime(year, month, mday, hour, minute, second);&#13;
        &#13;
        return (start, end, votingTime);&#13;
    } &#13;
    &#13;
    function _hasProposed(address _sponsor, ProposalType proposalType)&#13;
        internal&#13;
        view&#13;
        returns (bool)&#13;
    {&#13;
        if (proposals.length == 0) {&#13;
            return false;&#13;
        } else {&#13;
            BudgetPlan storage b = budgetPlans[currentBudgetPlanId];&#13;
            for (uint256 i = proposals.length - 1;; --i) {&#13;
                Proposal storage p = proposals[i];&#13;
                if (p.openingTime &lt; b.startTime) {&#13;
                    return false;&#13;
                } else if (p.openingTime &lt;= b.endTime &#13;
                            &amp;&amp; p.sponsor == _sponsor &#13;
                            &amp;&amp; p.proposalType == proposalType&#13;
                            &amp;&amp; !p.isPassed) {&#13;
                    return true;&#13;
                }&#13;
                &#13;
                if (i == 0)&#13;
                    break;&#13;
            }&#13;
            return false;&#13;
        }&#13;
    }&#13;
}