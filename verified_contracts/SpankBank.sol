pragma solidity 0.4.24;
// produced by the Solididy File Flattener (c) David Appleton 2018
// contact : <span class="__cf_email__" data-cfemail="573336213217363c383a35367934383a">[email protected]</span>&#13;
// released under Apache 2.0 licence&#13;
/*&#13;
// produced by the Solididy File Flattener (c) David Appleton 2018&#13;
// contact : <span class="__cf_email__" data-cfemail="204441564560414b4f4d42410e434f4d">[email protected]</span>&#13;
// released under Apache 2.0 licence&#13;
*/&#13;
// produced by the Solididy File Flattener (c) David Appleton 2018&#13;
// contact : <span class="__cf_email__" data-cfemail="cca8adbaa98cada7a3a1aeade2afa3a1">[email protected]</span>&#13;
// released under Apache 2.0 licence&#13;
contract Ownable {&#13;
  address public owner;&#13;
&#13;
&#13;
  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);&#13;
&#13;
&#13;
  /**&#13;
   * @dev The Ownable constructor sets the original `owner` of the contract to the sender&#13;
   * account.&#13;
   */&#13;
  constructor() public {&#13;
    owner = msg.sender;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Throws if called by any account other than the owner.&#13;
   */&#13;
  modifier onlyOwner() {&#13;
    require(msg.sender == owner);&#13;
    _;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Allows the current owner to transfer control of the contract to a newOwner.&#13;
   * @param newOwner The address to transfer ownership to.&#13;
   */&#13;
  function transferOwnership(address newOwner) public onlyOwner {&#13;
    require(newOwner != address(0));&#13;
    emit OwnershipTransferred(owner, newOwner);&#13;
    owner = newOwner;&#13;
  }&#13;
&#13;
}&#13;
&#13;
library SafeMath {&#13;
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
    uint256 c = a * b;&#13;
    assert(a == 0 || c / a == b);&#13;
    return c;&#13;
  }&#13;
&#13;
  function div(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
    // assert(b &gt; 0); // Solidity automatically throws when dividing by 0&#13;
    uint256 c = a / b;&#13;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold&#13;
    return c;&#13;
  }&#13;
&#13;
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
    assert(b &lt;= a);&#13;
    return a - b;&#13;
  }&#13;
&#13;
  function add(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
    uint256 c = a + b;&#13;
    assert(c &gt;= a);&#13;
    return c;&#13;
  }&#13;
}&#13;
&#13;
contract Token {&#13;
    /* This is a slight change to the ERC20 base standard.&#13;
    function totalSupply() constant returns (uint256 supply);&#13;
    is replaced with:&#13;
    uint256 public totalSupply;&#13;
    This automatically creates a getter function for the totalSupply.&#13;
    This is moved to the base contract since public getter functions are not&#13;
    currently recognised as an implementation of the matching abstract&#13;
    function by the compiler.&#13;
    */&#13;
    /// total amount of tokens&#13;
    uint256 public totalSupply;&#13;
&#13;
    /// @param _owner The address from which the balance will be retrieved&#13;
    /// @return The balance&#13;
    function balanceOf(address _owner) constant public returns (uint256 balance);&#13;
&#13;
    /// @notice send `_value` token to `_to` from `msg.sender`&#13;
    /// @param _to The address of the recipient&#13;
    /// @param _value The amount of token to be transferred&#13;
    /// @return Whether the transfer was successful or not&#13;
    function transfer(address _to, uint256 _value) public returns (bool success);&#13;
&#13;
    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`&#13;
    /// @param _from The address of the sender&#13;
    /// @param _to The address of the recipient&#13;
    /// @param _value The amount of token to be transferred&#13;
    /// @return Whether the transfer was successful or not&#13;
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);&#13;
&#13;
    /// @notice `msg.sender` approves `_spender` to spend `_value` tokens&#13;
    /// @param _spender The address of the account able to transfer the tokens&#13;
    /// @param _value The amount of tokens to be approved for transfer&#13;
    /// @return Whether the approval was successful or not&#13;
    function approve(address _spender, uint256 _value) public returns (bool success);&#13;
&#13;
    /// @param _owner The address of the account owning tokens&#13;
    /// @param _spender The address of the account able to transfer the tokens&#13;
    /// @return Amount of remaining tokens allowed to spent&#13;
    function allowance(address _owner, address _spender) public constant returns (uint256 remaining);&#13;
&#13;
    event Transfer(address indexed _from, address indexed _to, uint256 _value);&#13;
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);&#13;
}&#13;
&#13;
contract StandardToken is Token {&#13;
&#13;
    function transfer(address _to, uint256 _value) public returns (bool success) {&#13;
        //Default assumes totalSupply can't be over max (2^256 - 1).&#13;
        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.&#13;
        //Replace the if with this one instead.&#13;
        //require(balances[msg.sender] &gt;= _value &amp;&amp; balances[_to] + _value &gt; balances[_to]);&#13;
        require(balances[msg.sender] &gt;= _value);&#13;
        balances[msg.sender] -= _value;&#13;
        balances[_to] += _value;&#13;
        emit Transfer(msg.sender, _to, _value);&#13;
        return true;&#13;
    }&#13;
&#13;
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {&#13;
        //same as above. Replace this line with the following if you want to protect against wrapping uints.&#13;
        //require(balances[_from] &gt;= _value &amp;&amp; allowed[_from][msg.sender] &gt;= _value &amp;&amp; balances[_to] + _value &gt; balances[_to]);&#13;
        require(balances[_from] &gt;= _value &amp;&amp; allowed[_from][msg.sender] &gt;= _value);&#13;
        balances[_to] += _value;&#13;
        balances[_from] -= _value;&#13;
        allowed[_from][msg.sender] -= _value;&#13;
        emit Transfer(_from, _to, _value);&#13;
        return true;&#13;
    }&#13;
&#13;
    function balanceOf(address _owner) public constant returns (uint256 balance) {&#13;
        return balances[_owner];&#13;
    }&#13;
&#13;
    function approve(address _spender, uint256 _value) public returns (bool success) {&#13;
        allowed[msg.sender][_spender] = _value;&#13;
        emit Approval(msg.sender, _spender, _value);&#13;
        return true;&#13;
    }&#13;
&#13;
    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {&#13;
      return allowed[_owner][_spender];&#13;
    }&#13;
&#13;
    mapping (address =&gt; uint256) balances;&#13;
    mapping (address =&gt; mapping (address =&gt; uint256)) allowed;&#13;
}&#13;
&#13;
contract MintAndBurnToken is StandardToken, Ownable {&#13;
  event Mint(address indexed to, uint256 amount);&#13;
  event MintFinished();&#13;
&#13;
  bool public mintingFinished = false;&#13;
&#13;
&#13;
  modifier canMint() {&#13;
    require(!mintingFinished);&#13;
    _;&#13;
  }&#13;
&#13;
/* Public variables of the token */&#13;
&#13;
    /*&#13;
    NOTE:&#13;
    The following variables are OPTIONAL vanities. One does not have to include them.&#13;
    They allow one to customise the token contract &amp; in no way influences the core functionality.&#13;
    Some wallets/interfaces might not even bother to look at this information.&#13;
    */&#13;
    string public name;                   //fancy name: eg Simon Bucks&#13;
    uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.&#13;
    string public symbol;                 //An identifier: eg SBX&#13;
    string public version = 'H0.1';       //human 0.1 standard. Just an arbitrary versioning scheme.&#13;
&#13;
    constructor(&#13;
        string _tokenName,&#13;
        uint8 _decimalUnits,&#13;
        string _tokenSymbol&#13;
        ) public {&#13;
        name = _tokenName;                                   // Set the name for display purposes&#13;
        decimals = _decimalUnits;                            // Amount of decimals for display purposes&#13;
        symbol = _tokenSymbol;                               // Set the symbol for display purposes&#13;
    }&#13;
&#13;
  /**&#13;
   * @dev Function to mint tokens&#13;
   * @param _to The address that will receive the minted tokens.&#13;
   * @param _amount The amount of tokens to mint.&#13;
   * @return A boolean that indicates if the operation was successful.&#13;
   */&#13;
  function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) {&#13;
    totalSupply = SafeMath.add(_amount, totalSupply);&#13;
    balances[_to] = SafeMath.add(_amount,balances[_to]);&#13;
    emit Mint(_to, _amount);&#13;
    emit Transfer(address(0), _to, _amount);&#13;
    return true;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Function to stop minting new tokens.&#13;
   * @return True if the operation was successful.&#13;
   */&#13;
  function finishMinting() onlyOwner canMint public returns (bool) {&#13;
    mintingFinished = true;&#13;
    emit MintFinished();&#13;
    return true;&#13;
  }&#13;
&#13;
  // -----------------------------------&#13;
  // BURN FUNCTIONS BELOW&#13;
  // https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/token/ERC20/BurnableToken.sol&#13;
  // -----------------------------------&#13;
&#13;
  event Burn(address indexed burner, uint256 value);&#13;
&#13;
  /**&#13;
   * @dev Burns a specific amount of tokens.&#13;
   * @param _value The amount of token to be burned.&#13;
   */&#13;
  function burn(uint256 _value) onlyOwner public {&#13;
    _burn(msg.sender, _value);&#13;
  }&#13;
&#13;
  function _burn(address _who, uint256 _value) internal {&#13;
    require(_value &lt;= balances[_who]);&#13;
    // no need to require value &lt;= totalSupply, since that would imply the&#13;
    // sender's balance is greater than the totalSupply, which *should* be an assertion failure&#13;
&#13;
    balances[_who] = SafeMath.sub(balances[_who],_value);&#13;
    totalSupply = SafeMath.sub(totalSupply,_value);&#13;
    emit Burn(_who, _value);&#13;
    emit Transfer(_who, address(0), _value);&#13;
  }&#13;
}&#13;
&#13;
contract HumanStandardToken is StandardToken {&#13;
&#13;
    /* Public variables of the token */&#13;
&#13;
    /*&#13;
    NOTE:&#13;
    The following variables are OPTIONAL vanities. One does not have to include them.&#13;
    They allow one to customise the token contract &amp; in no way influences the core functionality.&#13;
    Some wallets/interfaces might not even bother to look at this information.&#13;
    */&#13;
    string public name;                   //fancy name: eg Simon Bucks&#13;
    uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.&#13;
    string public symbol;                 //An identifier: eg SBX&#13;
    string public version = 'H0.1';       //human 0.1 standard. Just an arbitrary versioning scheme.&#13;
&#13;
    constructor(&#13;
        uint256 _initialAmount,&#13;
        string _tokenName,&#13;
        uint8 _decimalUnits,&#13;
        string _tokenSymbol&#13;
        ) public {&#13;
        balances[msg.sender] = _initialAmount;               // Give the creator all initial tokens&#13;
        totalSupply = _initialAmount;                        // Update total supply&#13;
        name = _tokenName;                                   // Set the name for display purposes&#13;
        decimals = _decimalUnits;                            // Amount of decimals for display purposes&#13;
        symbol = _tokenSymbol;                               // Set the symbol for display purposes&#13;
    }&#13;
&#13;
    /* Approves and then calls the receiving contract */&#13;
    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {&#13;
        allowed[msg.sender][_spender] = _value;&#13;
        emit Approval(msg.sender, _spender, _value);&#13;
&#13;
        //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.&#13;
        //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)&#13;
        //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.&#13;
        require(_spender.call(bytes4(bytes32(keccak256("receiveApproval(address,uint256,address,bytes)"))), msg.sender, _value, this, _extraData));&#13;
        return true;&#13;
    }&#13;
}&#13;
&#13;
library BytesLib {&#13;
    function concat(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bytes) {&#13;
        bytes memory tempBytes;&#13;
&#13;
        assembly {&#13;
            // Get a location of some free memory and store it in tempBytes as&#13;
            // Solidity does for memory variables.&#13;
            tempBytes := mload(0x40)&#13;
&#13;
            // Store the length of the first bytes array at the beginning of&#13;
            // the memory for tempBytes.&#13;
            let length := mload(_preBytes)&#13;
            mstore(tempBytes, length)&#13;
&#13;
            // Maintain a memory counter for the current write location in the&#13;
            // temp bytes array by adding the 32 bytes for the array length to&#13;
            // the starting location.&#13;
            let mc := add(tempBytes, 0x20)&#13;
            // Stop copying when the memory counter reaches the length of the&#13;
            // first bytes array.&#13;
            let end := add(mc, length)&#13;
&#13;
            for {&#13;
                // Initialize a copy counter to the start of the _preBytes data,&#13;
                // 32 bytes into its memory.&#13;
                let cc := add(_preBytes, 0x20)&#13;
            } lt(mc, end) {&#13;
                // Increase both counters by 32 bytes each iteration.&#13;
                mc := add(mc, 0x20)&#13;
                cc := add(cc, 0x20)&#13;
            } {&#13;
                // Write the _preBytes data into the tempBytes memory 32 bytes&#13;
                // at a time.&#13;
                mstore(mc, mload(cc))&#13;
            }&#13;
&#13;
            // Add the length of _postBytes to the current length of tempBytes&#13;
            // and store it as the new length in the first 32 bytes of the&#13;
            // tempBytes memory.&#13;
            length := mload(_postBytes)&#13;
            mstore(tempBytes, add(length, mload(tempBytes)))&#13;
&#13;
            // Move the memory counter back from a multiple of 0x20 to the&#13;
            // actual end of the _preBytes data.&#13;
            mc := end&#13;
            // Stop copying when the memory counter reaches the new combined&#13;
            // length of the arrays.&#13;
            end := add(mc, length)&#13;
&#13;
            for {&#13;
                let cc := add(_postBytes, 0x20)&#13;
            } lt(mc, end) {&#13;
                mc := add(mc, 0x20)&#13;
                cc := add(cc, 0x20)&#13;
            } {&#13;
                mstore(mc, mload(cc))&#13;
            }&#13;
&#13;
            // Update the free-memory pointer by padding our last write location&#13;
            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the&#13;
            // next 32 byte block, then round down to the nearest multiple of&#13;
            // 32. If the sum of the length of the two arrays is zero then add &#13;
            // one before rounding down to leave a blank 32 bytes (the length block with 0).&#13;
            mstore(0x40, and(&#13;
              add(add(end, iszero(add(length, mload(_preBytes)))), 31),&#13;
              not(31) // Round down to the nearest 32 bytes.&#13;
            ))&#13;
        }&#13;
&#13;
        return tempBytes;&#13;
    }&#13;
&#13;
    function concatStorage(bytes storage _preBytes, bytes memory _postBytes) internal {&#13;
        assembly {&#13;
            // Read the first 32 bytes of _preBytes storage, which is the length&#13;
            // of the array. (We don't need to use the offset into the slot&#13;
            // because arrays use the entire slot.)&#13;
            let fslot := sload(_preBytes_slot)&#13;
            // Arrays of 31 bytes or less have an even value in their slot,&#13;
            // while longer arrays have an odd value. The actual length is&#13;
            // the slot divided by two for odd values, and the lowest order&#13;
            // byte divided by two for even values.&#13;
            // If the slot is even, bitwise and the slot with 255 and divide by&#13;
            // two to get the length. If the slot is odd, bitwise and the slot&#13;
            // with -1 and divide by two.&#13;
            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)&#13;
            let mlength := mload(_postBytes)&#13;
            let newlength := add(slength, mlength)&#13;
            // slength can contain both the length and contents of the array&#13;
            // if length &lt; 32 bytes so let's prepare for that&#13;
            // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage&#13;
            switch add(lt(slength, 32), lt(newlength, 32))&#13;
            case 2 {&#13;
                // Since the new array still fits in the slot, we just need to&#13;
                // update the contents of the slot.&#13;
                // uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length&#13;
                sstore(&#13;
                    _preBytes_slot,&#13;
                    // all the modifications to the slot are inside this&#13;
                    // next block&#13;
                    add(&#13;
                        // we can just add to the slot contents because the&#13;
                        // bytes we want to change are the LSBs&#13;
                        fslot,&#13;
                        add(&#13;
                            mul(&#13;
                                div(&#13;
                                    // load the bytes from memory&#13;
                                    mload(add(_postBytes, 0x20)),&#13;
                                    // zero all bytes to the right&#13;
                                    exp(0x100, sub(32, mlength))&#13;
                                ),&#13;
                                // and now shift left the number of bytes to&#13;
                                // leave space for the length in the slot&#13;
                                exp(0x100, sub(32, newlength))&#13;
                            ),&#13;
                            // increase length by the double of the memory&#13;
                            // bytes length&#13;
                            mul(mlength, 2)&#13;
                        )&#13;
                    )&#13;
                )&#13;
            }&#13;
            case 1 {&#13;
                // The stored value fits in the slot, but the combined value&#13;
                // will exceed it.&#13;
                // get the keccak hash to get the contents of the array&#13;
                mstore(0x0, _preBytes_slot)&#13;
                let sc := add(keccak256(0x0, 0x20), div(slength, 32))&#13;
&#13;
                // save new length&#13;
                sstore(_preBytes_slot, add(mul(newlength, 2), 1))&#13;
&#13;
                // The contents of the _postBytes array start 32 bytes into&#13;
                // the structure. Our first read should obtain the `submod`&#13;
                // bytes that can fit into the unused space in the last word&#13;
                // of the stored array. To get this, we read 32 bytes starting&#13;
                // from `submod`, so the data we read overlaps with the array&#13;
                // contents by `submod` bytes. Masking the lowest-order&#13;
                // `submod` bytes allows us to add that value directly to the&#13;
                // stored value.&#13;
&#13;
                let submod := sub(32, slength)&#13;
                let mc := add(_postBytes, submod)&#13;
                let end := add(_postBytes, mlength)&#13;
                let mask := sub(exp(0x100, submod), 1)&#13;
&#13;
                sstore(&#13;
                    sc,&#13;
                    add(&#13;
                        and(&#13;
                            fslot,&#13;
                            0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00&#13;
                        ),&#13;
                        and(mload(mc), mask)&#13;
                    )&#13;
                )&#13;
&#13;
                for {&#13;
                    mc := add(mc, 0x20)&#13;
                    sc := add(sc, 1)&#13;
                } lt(mc, end) {&#13;
                    sc := add(sc, 1)&#13;
                    mc := add(mc, 0x20)&#13;
                } {&#13;
                    sstore(sc, mload(mc))&#13;
                }&#13;
&#13;
                mask := exp(0x100, sub(mc, end))&#13;
&#13;
                sstore(sc, mul(div(mload(mc), mask), mask))&#13;
            }&#13;
            default {&#13;
                // get the keccak hash to get the contents of the array&#13;
                mstore(0x0, _preBytes_slot)&#13;
                // Start copying to the last used word of the stored array.&#13;
                let sc := add(keccak256(0x0, 0x20), div(slength, 32))&#13;
&#13;
                // save new length&#13;
                sstore(_preBytes_slot, add(mul(newlength, 2), 1))&#13;
&#13;
                // Copy over the first `submod` bytes of the new data as in&#13;
                // case 1 above.&#13;
                let slengthmod := mod(slength, 32)&#13;
                let mlengthmod := mod(mlength, 32)&#13;
                let submod := sub(32, slengthmod)&#13;
                let mc := add(_postBytes, submod)&#13;
                let end := add(_postBytes, mlength)&#13;
                let mask := sub(exp(0x100, submod), 1)&#13;
&#13;
                sstore(sc, add(sload(sc), and(mload(mc), mask)))&#13;
                &#13;
                for { &#13;
                    sc := add(sc, 1)&#13;
                    mc := add(mc, 0x20)&#13;
                } lt(mc, end) {&#13;
                    sc := add(sc, 1)&#13;
                    mc := add(mc, 0x20)&#13;
                } {&#13;
                    sstore(sc, mload(mc))&#13;
                }&#13;
&#13;
                mask := exp(0x100, sub(mc, end))&#13;
&#13;
                sstore(sc, mul(div(mload(mc), mask), mask))&#13;
            }&#13;
        }&#13;
    }&#13;
&#13;
    function slice(bytes _bytes, uint _start, uint _length) internal  pure returns (bytes) {&#13;
        require(_bytes.length &gt;= (_start + _length));&#13;
&#13;
        bytes memory tempBytes;&#13;
&#13;
        assembly {&#13;
            switch iszero(_length)&#13;
            case 0 {&#13;
                // Get a location of some free memory and store it in tempBytes as&#13;
                // Solidity does for memory variables.&#13;
                tempBytes := mload(0x40)&#13;
&#13;
                // The first word of the slice result is potentially a partial&#13;
                // word read from the original array. To read it, we calculate&#13;
                // the length of that partial word and start copying that many&#13;
                // bytes into the array. The first word we copy will start with&#13;
                // data we don't care about, but the last `lengthmod` bytes will&#13;
                // land at the beginning of the contents of the new array. When&#13;
                // we're done copying, we overwrite the full first word with&#13;
                // the actual length of the slice.&#13;
                let lengthmod := and(_length, 31)&#13;
&#13;
                // The multiplication in the next line is necessary&#13;
                // because when slicing multiples of 32 bytes (lengthmod == 0)&#13;
                // the following copy loop was copying the origin's length&#13;
                // and then ending prematurely not copying everything it should.&#13;
                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))&#13;
                let end := add(mc, _length)&#13;
&#13;
                for {&#13;
                    // The multiplication in the next line has the same exact purpose&#13;
                    // as the one above.&#13;
                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)&#13;
                } lt(mc, end) {&#13;
                    mc := add(mc, 0x20)&#13;
                    cc := add(cc, 0x20)&#13;
                } {&#13;
                    mstore(mc, mload(cc))&#13;
                }&#13;
&#13;
                mstore(tempBytes, _length)&#13;
&#13;
                //update free-memory pointer&#13;
                //allocating the array padded to 32 bytes like the compiler does now&#13;
                mstore(0x40, and(add(mc, 31), not(31)))&#13;
            }&#13;
            //if we want a zero-length slice let's just return a zero-length array&#13;
            default {&#13;
                tempBytes := mload(0x40)&#13;
&#13;
                mstore(0x40, add(tempBytes, 0x20))&#13;
            }&#13;
        }&#13;
&#13;
        return tempBytes;&#13;
    }&#13;
&#13;
    function toAddress(bytes _bytes, uint _start) internal  pure returns (address) {&#13;
        require(_bytes.length &gt;= (_start + 20));&#13;
        address tempAddress;&#13;
&#13;
        assembly {&#13;
            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)&#13;
        }&#13;
&#13;
        return tempAddress;&#13;
    }&#13;
&#13;
    function toUint(bytes _bytes, uint _start) internal  pure returns (uint256) {&#13;
        require(_bytes.length &gt;= (_start + 32));&#13;
        uint256 tempUint;&#13;
&#13;
        assembly {&#13;
            tempUint := mload(add(add(_bytes, 0x20), _start))&#13;
        }&#13;
&#13;
        return tempUint;&#13;
    }&#13;
&#13;
    function equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {&#13;
        bool success = true;&#13;
&#13;
        assembly {&#13;
            let length := mload(_preBytes)&#13;
&#13;
            // if lengths don't match the arrays are not equal&#13;
            switch eq(length, mload(_postBytes))&#13;
            case 1 {&#13;
                // cb is a circuit breaker in the for loop since there's&#13;
                //  no said feature for inline assembly loops&#13;
                // cb = 1 - don't breaker&#13;
                // cb = 0 - break&#13;
                let cb := 1&#13;
&#13;
                let mc := add(_preBytes, 0x20)&#13;
                let end := add(mc, length)&#13;
&#13;
                for {&#13;
                    let cc := add(_postBytes, 0x20)&#13;
                // the next line is the loop condition:&#13;
                // while(uint(mc &lt; end) + cb == 2)&#13;
                } eq(add(lt(mc, end), cb), 2) {&#13;
                    mc := add(mc, 0x20)&#13;
                    cc := add(cc, 0x20)&#13;
                } {&#13;
                    // if any of these checks fails then arrays are not equal&#13;
                    if iszero(eq(mload(mc), mload(cc))) {&#13;
                        // unsuccess:&#13;
                        success := 0&#13;
                        cb := 0&#13;
                    }&#13;
                }&#13;
            }&#13;
            default {&#13;
                // unsuccess:&#13;
                success := 0&#13;
            }&#13;
        }&#13;
&#13;
        return success;&#13;
    }&#13;
&#13;
    function equalStorage(bytes storage _preBytes, bytes memory _postBytes) internal view returns (bool) {&#13;
        bool success = true;&#13;
&#13;
        assembly {&#13;
            // we know _preBytes_offset is 0&#13;
            let fslot := sload(_preBytes_slot)&#13;
            // Decode the length of the stored array like in concatStorage().&#13;
            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)&#13;
            let mlength := mload(_postBytes)&#13;
&#13;
            // if lengths don't match the arrays are not equal&#13;
            switch eq(slength, mlength)&#13;
            case 1 {&#13;
                // slength can contain both the length and contents of the array&#13;
                // if length &lt; 32 bytes so let's prepare for that&#13;
                // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage&#13;
                if iszero(iszero(slength)) {&#13;
                    switch lt(slength, 32)&#13;
                    case 1 {&#13;
                        // blank the last byte which is the length&#13;
                        fslot := mul(div(fslot, 0x100), 0x100)&#13;
&#13;
                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {&#13;
                            // unsuccess:&#13;
                            success := 0&#13;
                        }&#13;
                    }&#13;
                    default {&#13;
                        // cb is a circuit breaker in the for loop since there's&#13;
                        //  no said feature for inline assembly loops&#13;
                        // cb = 1 - don't breaker&#13;
                        // cb = 0 - break&#13;
                        let cb := 1&#13;
&#13;
                        // get the keccak hash to get the contents of the array&#13;
                        mstore(0x0, _preBytes_slot)&#13;
                        let sc := keccak256(0x0, 0x20)&#13;
&#13;
                        let mc := add(_postBytes, 0x20)&#13;
                        let end := add(mc, mlength)&#13;
&#13;
                        // the next line is the loop condition:&#13;
                        // while(uint(mc &lt; end) + cb == 2)&#13;
                        for {} eq(add(lt(mc, end), cb), 2) {&#13;
                            sc := add(sc, 1)&#13;
                            mc := add(mc, 0x20)&#13;
                        } {&#13;
                            if iszero(eq(sload(sc), mload(mc))) {&#13;
                                // unsuccess:&#13;
                                success := 0&#13;
                                cb := 0&#13;
                            }&#13;
                        }&#13;
                    }&#13;
                }&#13;
            }&#13;
            default {&#13;
                // unsuccess:&#13;
                success := 0&#13;
            }&#13;
        }&#13;
&#13;
        return success;&#13;
    }&#13;
}&#13;
contract SpankBank {&#13;
    using BytesLib for bytes;&#13;
    using SafeMath for uint256;&#13;
&#13;
    event SpankBankCreated(&#13;
        uint256 periodLength,&#13;
        uint256 maxPeriods,&#13;
        address spankAddress,&#13;
        uint256 initialBootySupply,&#13;
        string bootyTokenName,&#13;
        uint8 bootyDecimalUnits,&#13;
        string bootySymbol&#13;
    );&#13;
&#13;
    event StakeEvent(&#13;
        address staker,&#13;
        uint256 period,&#13;
        uint256 spankPoints,&#13;
        uint256 spankAmount,&#13;
        uint256 stakePeriods,&#13;
        address delegateKey,&#13;
        address bootyBase&#13;
    );&#13;
&#13;
    event SendFeesEvent (&#13;
        address sender,&#13;
        uint256 bootyAmount&#13;
    );&#13;
&#13;
    event MintBootyEvent (&#13;
        uint256 targetBootySupply,&#13;
        uint256 totalBootySupply&#13;
    );&#13;
&#13;
    event CheckInEvent (&#13;
        address staker,&#13;
        uint256 period,&#13;
        uint256 spankPoints,&#13;
        uint256 stakerEndingPeriod&#13;
    );&#13;
&#13;
    event ClaimBootyEvent (&#13;
        address staker,&#13;
        uint256 period,&#13;
        uint256 bootyOwed&#13;
    );&#13;
&#13;
    event WithdrawStakeEvent (&#13;
        address staker,&#13;
        uint256 totalSpankToWithdraw&#13;
    );&#13;
&#13;
    event SplitStakeEvent (&#13;
        address staker,&#13;
        address newAddress,&#13;
        address newDelegateKey,&#13;
        address newBootyBase,&#13;
        uint256 spankAmount&#13;
    );&#13;
&#13;
    event VoteToCloseEvent (&#13;
        address staker,&#13;
        uint256 period&#13;
    );&#13;
&#13;
    event UpdateDelegateKeyEvent (&#13;
        address staker,&#13;
        address newDelegateKey&#13;
    );&#13;
&#13;
    event UpdateBootyBaseEvent (&#13;
        address staker,&#13;
        address newBootyBase&#13;
    );&#13;
&#13;
    event ReceiveApprovalEvent (&#13;
        address from,&#13;
        address tokenContract&#13;
    );&#13;
&#13;
    /***********************************&#13;
    VARIABLES SET AT CONTRACT DEPLOYMENT&#13;
    ************************************/&#13;
    // GLOBAL CONSTANT VARIABLES&#13;
    uint256 public periodLength; // time length of each period in seconds&#13;
    uint256 public maxPeriods; // the maximum # of periods a staker can stake for&#13;
    uint256 public totalSpankStaked; // the total SPANK staked across all stakers&#13;
    bool public isClosed; // true if voteToClose has passed, allows early withdrawals&#13;
&#13;
    // ERC-20 BASED TOKEN WITH SOME ADDED PROPERTIES FOR HUMAN READABILITY&#13;
    // https://github.com/ConsenSys/Tokens/blob/master/contracts/HumanStandardToken.sol&#13;
    HumanStandardToken public spankToken;&#13;
    MintAndBurnToken public bootyToken;&#13;
&#13;
    // LOOKUP TABLE FOR SPANKPOINTS BY PERIOD&#13;
    // 1 -&gt; 45%&#13;
    // 2 -&gt; 50%&#13;
    // ...&#13;
    // 12 -&gt; 100%&#13;
    mapping(uint256 =&gt; uint256) public pointsTable;&#13;
&#13;
    /*************************************&#13;
    INTERAL ACCOUNTING&#13;
    **************************************/&#13;
    uint256 public currentPeriod = 0;&#13;
&#13;
    struct Staker {&#13;
        uint256 spankStaked; // the amount of spank staked&#13;
        uint256 startingPeriod; // the period this staker started staking&#13;
        uint256 endingPeriod; // the period after which this stake expires&#13;
        mapping(uint256 =&gt; uint256) spankPoints; // the spankPoints per period&#13;
        mapping(uint256 =&gt; bool) didClaimBooty; // true if staker claimed BOOTY for that period&#13;
        mapping(uint256 =&gt; bool) votedToClose; // true if staker voted to close for that period&#13;
        address delegateKey; // address used to call checkIn and claimBooty&#13;
        address bootyBase; // destination address to receive BOOTY&#13;
    }&#13;
&#13;
    mapping(address =&gt; Staker) public stakers;&#13;
&#13;
    struct Period {&#13;
        uint256 bootyFees; // the amount of BOOTY collected in fees&#13;
        uint256 totalSpankPoints; // the total spankPoints of all stakers&#13;
        uint256 bootyMinted; // the amount of BOOTY minted&#13;
        bool mintingComplete; // true if BOOTY has already been minted for this period&#13;
        uint256 startTime; // the starting unix timestamp in seconds&#13;
        uint256 endTime; // the ending unix timestamp in seconds&#13;
        uint256 closingVotes; // the total votes to close this period&#13;
    }&#13;
&#13;
    mapping(uint256 =&gt; Period) public periods;&#13;
&#13;
    mapping(address =&gt; address) public stakerByDelegateKey;&#13;
&#13;
    modifier SpankBankIsOpen() {&#13;
        require(isClosed == false);&#13;
        _;&#13;
    }&#13;
&#13;
    constructor (&#13;
        uint256 _periodLength,&#13;
        uint256 _maxPeriods,&#13;
        address spankAddress,&#13;
        uint256 initialBootySupply,&#13;
        string bootyTokenName,&#13;
        uint8 bootyDecimalUnits,&#13;
        string bootySymbol&#13;
    )   public {&#13;
        periodLength = _periodLength;&#13;
        maxPeriods = _maxPeriods;&#13;
        spankToken = HumanStandardToken(spankAddress);&#13;
        bootyToken = new MintAndBurnToken(bootyTokenName, bootyDecimalUnits, bootySymbol);&#13;
        bootyToken.mint(this, initialBootySupply);&#13;
&#13;
        uint256 startTime = now;&#13;
&#13;
        periods[currentPeriod].startTime = startTime;&#13;
        periods[currentPeriod].endTime = SafeMath.add(startTime, periodLength);&#13;
&#13;
        bootyToken.transfer(msg.sender, initialBootySupply);&#13;
&#13;
        // initialize points table&#13;
        pointsTable[0] = 0;&#13;
        pointsTable[1] = 45;&#13;
        pointsTable[2] = 50;&#13;
        pointsTable[3] = 55;&#13;
        pointsTable[4] = 60;&#13;
        pointsTable[5] = 65;&#13;
        pointsTable[6] = 70;&#13;
        pointsTable[7] = 75;&#13;
        pointsTable[8] = 80;&#13;
        pointsTable[9] = 85;&#13;
        pointsTable[10] = 90;&#13;
        pointsTable[11] = 95;&#13;
        pointsTable[12] = 100;&#13;
&#13;
        emit SpankBankCreated(_periodLength, _maxPeriods, spankAddress, initialBootySupply, bootyTokenName, bootyDecimalUnits, bootySymbol);&#13;
    }&#13;
&#13;
    // Used to create a new staking position - verifies that the caller is not staking&#13;
    function stake(uint256 spankAmount, uint256 stakePeriods, address delegateKey, address bootyBase) SpankBankIsOpen public {&#13;
        doStake(msg.sender, spankAmount, stakePeriods, delegateKey, bootyBase);&#13;
    }&#13;
&#13;
    function doStake(address stakerAddress, uint256 spankAmount, uint256 stakePeriods, address delegateKey, address bootyBase) internal {&#13;
        updatePeriod();&#13;
        require(stakePeriods &gt; 0 &amp;&amp; stakePeriods &lt;= maxPeriods, "stake not between zero and maxPeriods"); // stake 1-12 (max) periods&#13;
        require(spankAmount &gt; 0, "stake is 0"); // stake must be greater than 0&#13;
&#13;
        // the staker must not have an active staking position&#13;
        require(stakers[stakerAddress].startingPeriod == 0, "staker already exists");&#13;
&#13;
        // transfer SPANK to this contract - assumes sender has already "allowed" the spankAmount&#13;
        require(spankToken.transferFrom(stakerAddress, this, spankAmount));&#13;
&#13;
        stakers[stakerAddress] = Staker(spankAmount, currentPeriod + 1, currentPeriod + stakePeriods, delegateKey, bootyBase);&#13;
&#13;
        _updateNextPeriodPoints(stakerAddress, stakePeriods);&#13;
&#13;
        totalSpankStaked = SafeMath.add(totalSpankStaked, spankAmount);&#13;
&#13;
        require(delegateKey != address(0), "delegateKey does not exist");&#13;
        require(bootyBase != address(0), "bootyBase does not exist");&#13;
        require(stakerByDelegateKey[delegateKey] == address(0), "delegateKey already used");&#13;
        stakerByDelegateKey[delegateKey] = stakerAddress;&#13;
&#13;
        emit StakeEvent(&#13;
            stakerAddress,&#13;
            currentPeriod + 1,&#13;
            stakers[stakerAddress].spankPoints[currentPeriod + 1],&#13;
            spankAmount,&#13;
            stakePeriods,&#13;
            delegateKey,&#13;
            bootyBase&#13;
        );&#13;
    }&#13;
&#13;
    // Called during stake and checkIn, assumes those functions prevent duplicate calls&#13;
    // for the same staker.&#13;
    function _updateNextPeriodPoints(address stakerAddress, uint256 stakingPeriods) internal {&#13;
        Staker storage staker = stakers[stakerAddress];&#13;
&#13;
        uint256 stakerPoints = SafeMath.div(SafeMath.mul(staker.spankStaked, pointsTable[stakingPeriods]), 100);&#13;
&#13;
        // add staker spankpoints to total spankpoints for the next period&#13;
        uint256 totalPoints = periods[currentPeriod + 1].totalSpankPoints;&#13;
        totalPoints = SafeMath.add(totalPoints, stakerPoints);&#13;
        periods[currentPeriod + 1].totalSpankPoints = totalPoints;&#13;
&#13;
        staker.spankPoints[currentPeriod + 1] = stakerPoints;&#13;
    }&#13;
&#13;
    function receiveApproval(address from, uint256 amount, address tokenContract, bytes extraData) SpankBankIsOpen public returns (bool success) {&#13;
        address delegateKeyFromBytes = extraData.toAddress(12);&#13;
        address bootyBaseFromBytes = extraData.toAddress(44);&#13;
        uint256 periodFromBytes = extraData.toUint(64);&#13;
&#13;
        emit ReceiveApprovalEvent(from, tokenContract);&#13;
&#13;
        doStake(from, amount, periodFromBytes, delegateKeyFromBytes, bootyBaseFromBytes);&#13;
        return true;&#13;
    }&#13;
&#13;
    function sendFees(uint256 bootyAmount) SpankBankIsOpen public {&#13;
        updatePeriod();&#13;
&#13;
        require(bootyAmount &gt; 0, "fee is zero"); // fees must be greater than 0&#13;
        require(bootyToken.transferFrom(msg.sender, this, bootyAmount));&#13;
&#13;
        bootyToken.burn(bootyAmount);&#13;
&#13;
        uint256 currentBootyFees = periods[currentPeriod].bootyFees;&#13;
        currentBootyFees = SafeMath.add(bootyAmount, currentBootyFees);&#13;
        periods[currentPeriod].bootyFees = currentBootyFees;&#13;
&#13;
        emit SendFeesEvent(msg.sender, bootyAmount);&#13;
    }&#13;
&#13;
    function mintBooty() SpankBankIsOpen public {&#13;
        updatePeriod();&#13;
&#13;
        // can't mint BOOTY during period 0 - would result in integer underflow&#13;
        require(currentPeriod &gt; 0, "current period is zero");&#13;
&#13;
        Period storage period = periods[currentPeriod - 1];&#13;
        require(!period.mintingComplete, "minting already complete"); // cant mint BOOTY twice&#13;
&#13;
        period.mintingComplete = true;&#13;
&#13;
        uint256 targetBootySupply = SafeMath.mul(period.bootyFees, 20);&#13;
        uint256 totalBootySupply = bootyToken.totalSupply();&#13;
&#13;
        if (targetBootySupply &gt; totalBootySupply) {&#13;
            uint256 bootyMinted = targetBootySupply - totalBootySupply;&#13;
            bootyToken.mint(this, bootyMinted);&#13;
            period.bootyMinted = bootyMinted;&#13;
            emit MintBootyEvent(targetBootySupply, totalBootySupply);&#13;
        }&#13;
    }&#13;
&#13;
    // This will check the current time and update the current period accordingly&#13;
    // - called from all write functions to ensure the period is always up to date before any writes&#13;
    // - can also be called externally, but there isn't a good reason for why you would want to&#13;
    // - the while loop protects against the edge case where we miss a period&#13;
&#13;
    function updatePeriod() public {&#13;
        while (now &gt;= periods[currentPeriod].endTime) {&#13;
            Period memory prevPeriod = periods[currentPeriod];&#13;
            currentPeriod += 1;&#13;
            periods[currentPeriod].startTime = prevPeriod.endTime;&#13;
            periods[currentPeriod].endTime = SafeMath.add(prevPeriod.endTime, periodLength);&#13;
        }&#13;
    }&#13;
&#13;
    // In order to receive Booty, each staker will have to check-in every period.&#13;
    // This check-in will compute the spankPoints locally and globally for each staker.&#13;
    function checkIn(uint256 updatedEndingPeriod) SpankBankIsOpen public {&#13;
        updatePeriod();&#13;
&#13;
        address stakerAddress =  stakerByDelegateKey[msg.sender];&#13;
&#13;
        Staker storage staker = stakers[stakerAddress];&#13;
&#13;
        require(staker.spankStaked &gt; 0, "staker stake is zero");&#13;
        require(currentPeriod &lt; staker.endingPeriod, "staker expired");&#13;
        require(staker.spankPoints[currentPeriod+1] == 0, "staker has points for next period");&#13;
&#13;
        // If updatedEndingPeriod is 0, don't update the ending period&#13;
        if (updatedEndingPeriod &gt; 0) {&#13;
            require(updatedEndingPeriod &gt; staker.endingPeriod, "updatedEndingPeriod less than or equal to staker endingPeriod");&#13;
            require(updatedEndingPeriod &lt;= currentPeriod + maxPeriods, "updatedEndingPeriod greater than currentPeriod and maxPeriods");&#13;
            staker.endingPeriod = updatedEndingPeriod;&#13;
        }&#13;
&#13;
        uint256 stakePeriods = staker.endingPeriod - currentPeriod;&#13;
&#13;
        _updateNextPeriodPoints(stakerAddress, stakePeriods);&#13;
&#13;
        emit CheckInEvent(stakerAddress, currentPeriod + 1, staker.spankPoints[currentPeriod + 1], staker.endingPeriod);&#13;
    }&#13;
&#13;
    function claimBooty(uint256 claimPeriod) public {&#13;
        updatePeriod();&#13;
&#13;
        Period memory period = periods[claimPeriod];&#13;
        require(period.mintingComplete, "booty not minted");&#13;
&#13;
        address stakerAddress = stakerByDelegateKey[msg.sender];&#13;
&#13;
        Staker storage staker = stakers[stakerAddress];&#13;
&#13;
        require(!staker.didClaimBooty[claimPeriod], "staker already claimed"); // can only claim booty once&#13;
&#13;
        uint256 stakerSpankPoints = staker.spankPoints[claimPeriod];&#13;
        require(stakerSpankPoints &gt; 0, "staker has no points"); // only stakers can claim&#13;
&#13;
        staker.didClaimBooty[claimPeriod] = true;&#13;
&#13;
        uint256 bootyMinted = period.bootyMinted;&#13;
        uint256 totalSpankPoints = period.totalSpankPoints;&#13;
&#13;
        uint256 bootyOwed = SafeMath.div(SafeMath.mul(stakerSpankPoints, bootyMinted), totalSpankPoints);&#13;
&#13;
        require(bootyToken.transfer(staker.bootyBase, bootyOwed));&#13;
&#13;
        emit ClaimBootyEvent(stakerAddress, claimPeriod, bootyOwed);&#13;
    }&#13;
&#13;
    function withdrawStake() public {&#13;
        updatePeriod();&#13;
&#13;
        Staker storage staker = stakers[msg.sender];&#13;
        require(staker.spankStaked &gt; 0, "staker has no stake");&#13;
&#13;
        require(isClosed || currentPeriod &gt; staker.endingPeriod, "currentPeriod less than endingPeriod or spankbank closed");&#13;
&#13;
        uint256 spankToWithdraw = staker.spankStaked;&#13;
&#13;
        totalSpankStaked = SafeMath.sub(totalSpankStaked, staker.spankStaked);&#13;
        staker.spankStaked = 0;&#13;
&#13;
        spankToken.transfer(msg.sender, spankToWithdraw);&#13;
&#13;
        emit WithdrawStakeEvent(msg.sender, spankToWithdraw);&#13;
    }&#13;
&#13;
    function splitStake(address newAddress, address newDelegateKey, address newBootyBase, uint256 spankAmount) public {&#13;
        updatePeriod();&#13;
&#13;
        require(newAddress != address(0), "newAddress is zero");&#13;
        require(newDelegateKey != address(0), "delegateKey is zero");&#13;
        require(newBootyBase != address(0), "bootyBase is zero");&#13;
        require(stakerByDelegateKey[newDelegateKey] == address(0), "delegateKey in use");&#13;
&#13;
        require(spankAmount &gt; 0, "spankAmount is zero");&#13;
&#13;
        Staker storage staker = stakers[msg.sender];&#13;
        require(currentPeriod &lt; staker.endingPeriod, "staker expired");&#13;
        require(spankAmount &lt;= staker.spankStaked, "spankAmount greater than stake");&#13;
        require(staker.spankPoints[currentPeriod+1] == 0, "staker has points for next period");&#13;
&#13;
        staker.spankStaked = SafeMath.sub(staker.spankStaked, spankAmount);&#13;
&#13;
        stakers[newAddress] = Staker(spankAmount, staker.startingPeriod, staker.endingPeriod, newDelegateKey, newBootyBase);&#13;
&#13;
        stakerByDelegateKey[newDelegateKey] = newAddress;&#13;
&#13;
        emit SplitStakeEvent(msg.sender, newAddress, newDelegateKey, newBootyBase, spankAmount);&#13;
    }&#13;
&#13;
    function voteToClose() public {&#13;
        updatePeriod();&#13;
&#13;
        Staker storage staker = stakers[msg.sender];&#13;
&#13;
        require(staker.spankStaked &gt; 0, "stake is zero");&#13;
        require(currentPeriod &lt; staker.endingPeriod , "staker expired");&#13;
        require(staker.votedToClose[currentPeriod] == false, "stake already voted");&#13;
        require(isClosed == false, "SpankBank already closed");&#13;
&#13;
        uint256 closingVotes = periods[currentPeriod].closingVotes;&#13;
        closingVotes = SafeMath.add(closingVotes, staker.spankStaked);&#13;
        periods[currentPeriod].closingVotes = closingVotes;&#13;
&#13;
        staker.votedToClose[currentPeriod] = true;&#13;
&#13;
        uint256 closingTrigger = SafeMath.div(totalSpankStaked, 2);&#13;
        if (closingVotes &gt; closingTrigger) {&#13;
            isClosed = true;&#13;
        }&#13;
&#13;
        emit VoteToCloseEvent(msg.sender, currentPeriod);&#13;
    }&#13;
&#13;
    function updateDelegateKey(address newDelegateKey) public {&#13;
        require(newDelegateKey != address(0), "delegateKey is zero");&#13;
        require(stakerByDelegateKey[newDelegateKey] == address(0), "delegateKey already exists");&#13;
&#13;
        Staker storage staker = stakers[msg.sender];&#13;
        require(staker.startingPeriod &gt; 0, "staker starting period is zero");&#13;
&#13;
        stakerByDelegateKey[staker.delegateKey] = address(0);&#13;
        staker.delegateKey = newDelegateKey;&#13;
        stakerByDelegateKey[newDelegateKey] = msg.sender;&#13;
&#13;
        emit UpdateDelegateKeyEvent(msg.sender, newDelegateKey);&#13;
    }&#13;
&#13;
    function updateBootyBase(address newBootyBase) public {&#13;
        Staker storage staker = stakers[msg.sender];&#13;
        require(staker.startingPeriod &gt; 0, "staker starting period is zero");&#13;
&#13;
        staker.bootyBase = newBootyBase;&#13;
&#13;
        emit UpdateBootyBaseEvent(msg.sender, newBootyBase);&#13;
    }&#13;
&#13;
    function getSpankPoints(address stakerAddress, uint256 period) public view returns (uint256)  {&#13;
        return stakers[stakerAddress].spankPoints[period];&#13;
    }&#13;
&#13;
    function getDidClaimBooty(address stakerAddress, uint256 period) public view returns (bool)  {&#13;
        return stakers[stakerAddress].didClaimBooty[period];&#13;
    }&#13;
&#13;
    function getVote(address stakerAddress, uint period) public view returns (bool) {&#13;
        return stakers[stakerAddress].votedToClose[period];&#13;
    }&#13;
&#13;
    function getStakerFromDelegateKey(address delegateAddress) public view returns (address) {&#13;
        return stakerByDelegateKey[delegateAddress];&#13;
    }&#13;
}