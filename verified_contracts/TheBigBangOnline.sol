/*
This software code is prohibited for copying and distribution. 
The violation of this requirement will be punished by law. 

Contact e-mail: <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="6805091a010c0d060c010d1a2807180d06050901040a071046071a0f">[emailÂ protected]</a>&#13;
&#13;
Project site: http://thebigbang.online/&#13;
&#13;
Developed by "Naumov Lab" http://smart-contracts.ru/&#13;
*/&#13;
&#13;
pragma solidity ^0.4.24;&#13;
&#13;
&#13;
library SafeMath {&#13;
    &#13;
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
    uint256 c = a * b;&#13;
    assert(a == 0 || c / a == b);&#13;
    return c;&#13;
  }&#13;
&#13;
  function div(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
    uint256 c = a / b;&#13;
    return c;&#13;
  }&#13;
&#13;
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
    assert(b &lt;= a);&#13;
    return a - b;&#13;
  }&#13;
&#13;
  function add(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
    uint256 c = a + b;&#13;
    assert(c &gt;= a);&#13;
    return c;&#13;
  }&#13;
  &#13;
}&#13;
&#13;
&#13;
contract Ownable {&#13;
&#13;
  address public owner;&#13;
&#13;
  constructor() public {&#13;
    owner = msg.sender;&#13;
  }&#13;
&#13;
}&#13;
&#13;
&#13;
contract TheBigBangOnline is Ownable {&#13;
        &#13;
    using SafeMath for uint256;&#13;
    &#13;
    event payEventLog(address indexed _address, uint value, uint periodCount, uint percent, uint time);&#13;
    event payRefEventLog(address indexed _addressFrom, address indexed _addressTo, uint value, uint percent, uint time);&#13;
    event payJackpotLog(address indexed _address, uint value, uint totalValue, uint userValue, uint time);    &#13;
    &#13;
    uint public period = 24 hours;&#13;
    uint public startTime = 1536537600; //  Mon, 10 Sep 2018 00:00:00 GMT&#13;
    &#13;
    uint public basicDayPercent = 300; //3%&#13;
    uint public bonusDayPercent = 330; //3.3%&#13;
    &#13;
    uint public referrerLevel1Percent = 250; //2.5%&#13;
    uint public referrerLevel2Percent = 500; //5%&#13;
    uint public referrerLevel3Percent = 1000; //10%    &#13;
    &#13;
    uint public referrerLevel2Ether = 1 ether;&#13;
    uint public referrerLevel3Ether = 10 ether;&#13;
    &#13;
    uint public minBet = 0.01  ether;&#13;
    &#13;
    uint public referrerAndOwnerPercent = 2000; //20%    &#13;
    &#13;
    uint public currBetID = 1;&#13;
    &#13;
    &#13;
    struct BetStruct {&#13;
        uint value;&#13;
        uint refValue;&#13;
        uint firstBetTime;&#13;
        uint lastBetTime;&#13;
        uint lastPaymentTime;&#13;
        uint nextPayAfterTime;&#13;
        bool isExist;&#13;
        uint id;&#13;
        uint referrerID;&#13;
    }&#13;
    &#13;
    mapping (address =&gt; BetStruct) public betsDatabase;&#13;
    mapping (uint =&gt; address) public addressList;&#13;
    &#13;
    // Jackpot&#13;
    uint public jackpotPercent = 1000; //10%&#13;
    uint public jackpotBank = 0;&#13;
    uint public jackpotMaxTime = 24 hours;&#13;
    uint public jackpotTime = startTime + jackpotMaxTime;  &#13;
    uint public increaseJackpotTimeAfterBet = 10 minutes;&#13;
    &#13;
    uint public gameRound = 1;   &#13;
    uint public currJackpotBetID = 0;&#13;
    &#13;
    struct BetStructForJackpot {&#13;
        uint value;&#13;
        address user;&#13;
    }&#13;
    mapping (uint =&gt; BetStructForJackpot) public betForJackpot;    &#13;
    &#13;
    &#13;
    &#13;
    &#13;
    constructor() public {&#13;
    &#13;
    }&#13;
&#13;
    &#13;
 function createBet(uint _referrerID) public payable {&#13;
     &#13;
        if( (_referrerID &gt;= currBetID)&amp;&amp;(_referrerID!=0)){&#13;
            revert("Incorrect _referrerID");&#13;
        }&#13;
&#13;
        if( msg.value &lt; minBet){&#13;
            revert("Amount beyond acceptable limits");&#13;
        }&#13;
        &#13;
            BetStruct memory betStruct;&#13;
            &#13;
            if(betsDatabase[msg.sender].isExist){&#13;
                betStruct = betsDatabase[msg.sender];&#13;
                &#13;
                if( (betStruct.nextPayAfterTime &lt; now) &amp;&amp; (gameRound==1) ){&#13;
                    getRewardForAddress(msg.sender);    &#13;
                }            &#13;
                &#13;
                betStruct.value += msg.value;&#13;
                betStruct.lastBetTime = now;&#13;
                &#13;
                betsDatabase[msg.sender] = betStruct;&#13;
                &#13;
            } else {&#13;
                &#13;
                uint nextPayAfterTime = startTime+((now.sub(startTime)).div(period)).mul(period)+period;&#13;
    &#13;
                betStruct = BetStruct({ &#13;
                    value : msg.value,&#13;
                    refValue : 0,&#13;
                    firstBetTime : now,&#13;
                    lastBetTime : now,&#13;
                    lastPaymentTime : 0,&#13;
                    nextPayAfterTime: nextPayAfterTime,&#13;
                    isExist : true,&#13;
                    id : currBetID,&#13;
                    referrerID : _referrerID&#13;
                });&#13;
            &#13;
                betsDatabase[msg.sender] = betStruct;&#13;
                addressList[currBetID] = msg.sender;&#13;
                &#13;
                currBetID++;&#13;
            }&#13;
            &#13;
            if(now &gt; jackpotTime){&#13;
                getJackpot();&#13;
            }            &#13;
            &#13;
            currJackpotBetID++;&#13;
            &#13;
            BetStructForJackpot memory betStructForJackpot;&#13;
            betStructForJackpot.user = msg.sender;&#13;
            betStructForJackpot.value = msg.value;&#13;
            &#13;
            betForJackpot[currJackpotBetID] = betStructForJackpot;&#13;
            &#13;
            jackpotTime += increaseJackpotTimeAfterBet;&#13;
            if( jackpotTime &gt; now + jackpotMaxTime ) {&#13;
                jackpotTime = now + jackpotMaxTime;&#13;
            }&#13;
            &#13;
            if(gameRound==1){&#13;
                jackpotBank += msg.value.mul(jackpotPercent).div(10000);&#13;
            }&#13;
            else {&#13;
                jackpotBank += msg.value.mul(10000-referrerAndOwnerPercent).div(10000);&#13;
            }&#13;
    &#13;
            if(betStruct.referrerID!=0){&#13;
                betsDatabase[addressList[betStruct.referrerID]].refValue += msg.value;&#13;
                &#13;
                uint currReferrerPercent;&#13;
                uint currReferrerValue = betsDatabase[addressList[betStruct.referrerID]].value.add(betsDatabase[addressList[betStruct.referrerID]].refValue);&#13;
                &#13;
                if (currReferrerValue &gt;= referrerLevel3Ether){&#13;
                    currReferrerPercent = referrerLevel3Percent;&#13;
                } else if (currReferrerValue &gt;= referrerLevel2Ether) {&#13;
                   currReferrerPercent = referrerLevel2Percent; &#13;
                } else {&#13;
                    currReferrerPercent = referrerLevel1Percent;&#13;
                }&#13;
                &#13;
                uint refToPay = msg.value.mul(currReferrerPercent).div(10000);&#13;
                &#13;
                addressList[betStruct.referrerID].transfer( refToPay );&#13;
                owner.transfer(msg.value.mul(referrerAndOwnerPercent - currReferrerPercent).div(10000));&#13;
                &#13;
                emit payRefEventLog(msg.sender, addressList[betStruct.referrerID], refToPay, currReferrerPercent, now);&#13;
            } else {&#13;
                owner.transfer(msg.value.mul(referrerAndOwnerPercent).div(10000));&#13;
            }&#13;
  }&#13;
    &#13;
  function () public payable {&#13;
        createBet(0);&#13;
  } &#13;
  &#13;
  &#13;
  function getReward() public {&#13;
        getRewardForAddress(msg.sender);&#13;
  }&#13;
  &#13;
  function getRewardForAddress(address _address) public {&#13;
        if(gameRound!=1){&#13;
             revert("The first round end");    &#13;
        }        &#13;
      &#13;
        if(!betsDatabase[_address].isExist){&#13;
             revert("Address are not an investor");    &#13;
        }&#13;
        &#13;
        if(betsDatabase[_address].nextPayAfterTime &gt;= now){&#13;
             revert("The payout time has not yet come");    &#13;
        }&#13;
&#13;
        uint periodCount = now.sub(betsDatabase[_address].nextPayAfterTime).div(period).add(1);&#13;
        uint percent = basicDayPercent;&#13;
        &#13;
        if(betsDatabase[_address].referrerID&gt;0){&#13;
            percent = bonusDayPercent;&#13;
        }&#13;
        &#13;
        uint toPay = periodCount.mul(betsDatabase[_address].value).div(10000).mul(percent);&#13;
        &#13;
        betsDatabase[_address].lastPaymentTime = now;&#13;
        betsDatabase[_address].nextPayAfterTime += periodCount.mul(period); &#13;
        &#13;
        if(toPay.add(jackpotBank) &gt;= address(this).balance ){&#13;
            toPay = address(this).balance.sub(jackpotBank);&#13;
            gameRound = 2;&#13;
        }&#13;
        &#13;
        _address.transfer(toPay);&#13;
        &#13;
        emit payEventLog(_address, toPay, periodCount, percent, now);&#13;
  }&#13;
  &#13;
  function getJackpot() public {&#13;
        if(now &lt;= jackpotTime){&#13;
            revert("Jackpot did not come");  &#13;
        }&#13;
        &#13;
        jackpotTime = now + jackpotMaxTime;&#13;
        &#13;
        if(currJackpotBetID &gt; 5){&#13;
            uint toPay = jackpotBank;&#13;
            jackpotBank = 0;            &#13;
            &#13;
            uint totalValue = betForJackpot[currJackpotBetID].value + betForJackpot[currJackpotBetID - 1].value + betForJackpot[currJackpotBetID - 2].value + betForJackpot[currJackpotBetID - 3].value + betForJackpot[currJackpotBetID - 4].value;&#13;
            &#13;
            betForJackpot[currJackpotBetID].user.transfer(toPay.mul(betForJackpot[currJackpotBetID].value).div(totalValue) );&#13;
            emit payJackpotLog(betForJackpot[currJackpotBetID].user, toPay.mul(betForJackpot[currJackpotBetID].value).div(totalValue), totalValue, betForJackpot[currJackpotBetID].value, now);&#13;
            &#13;
            betForJackpot[currJackpotBetID-1].user.transfer(toPay.mul(betForJackpot[currJackpotBetID-1].value).div(totalValue) );&#13;
            emit payJackpotLog(betForJackpot[currJackpotBetID-1].user, toPay.mul(betForJackpot[currJackpotBetID-1].value).div(totalValue), totalValue, betForJackpot[currJackpotBetID-1].value, now);&#13;
            &#13;
            betForJackpot[currJackpotBetID-2].user.transfer(toPay.mul(betForJackpot[currJackpotBetID-2].value).div(totalValue) );&#13;
            emit payJackpotLog(betForJackpot[currJackpotBetID-2].user, toPay.mul(betForJackpot[currJackpotBetID-2].value).div(totalValue), totalValue, betForJackpot[currJackpotBetID-2].value, now);&#13;
            &#13;
            betForJackpot[currJackpotBetID-3].user.transfer(toPay.mul(betForJackpot[currJackpotBetID-3].value).div(totalValue) );&#13;
            emit payJackpotLog(betForJackpot[currJackpotBetID-3].user, toPay.mul(betForJackpot[currJackpotBetID-3].value).div(totalValue), totalValue, betForJackpot[currJackpotBetID-3].value, now);&#13;
            &#13;
            betForJackpot[currJackpotBetID-4].user.transfer(toPay.mul(betForJackpot[currJackpotBetID-4].value).div(totalValue) );&#13;
            emit payJackpotLog(betForJackpot[currJackpotBetID-4].user, toPay.mul(betForJackpot[currJackpotBetID-4].value).div(totalValue), totalValue, betForJackpot[currJackpotBetID-4].value, now);&#13;
        }&#13;
        &#13;
  }&#13;
    &#13;
}