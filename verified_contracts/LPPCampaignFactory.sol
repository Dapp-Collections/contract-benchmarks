//File: node_modules/liquidpledging/contracts/ILiquidPledgingPlugin.sol
pragma solidity ^0.4.11;

/*
    Copyright 2017, Jordi Baylina
    Contributor: Adrià Massanet <<span class="__cf_email__" data-cfemail="751411071c1435161a1110161a1b01100d015b1c1a">[email protected]</span>&gt;&#13;
&#13;
    This program is free software: you can redistribute it and/or modify&#13;
    it under the terms of the GNU General Public License as published by&#13;
    the Free Software Foundation, either version 3 of the License, or&#13;
    (at your option) any later version.&#13;
&#13;
    This program is distributed in the hope that it will be useful,&#13;
    but WITHOUT ANY WARRANTY; without even the implied warranty of&#13;
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&#13;
    GNU General Public License for more details.&#13;
&#13;
    You should have received a copy of the GNU General Public License&#13;
    along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.&#13;
*/&#13;
&#13;
&#13;
/// @dev `ILiquidPledgingPlugin` is the basic interface for any&#13;
///  liquid pledging plugin&#13;
contract ILiquidPledgingPlugin {&#13;
&#13;
    /// @notice Plugins are used (much like web hooks) to initiate an action&#13;
    ///  upon any donation, delegation, or transfer; this is an optional feature&#13;
    ///  and allows for extreme customization of the contract. This function&#13;
    ///  implements any action that should be initiated before a transfer.&#13;
    /// @param pledgeManager The admin or current manager of the pledge&#13;
    /// @param pledgeFrom This is the Id from which value will be transfered.&#13;
    /// @param pledgeTo This is the Id that value will be transfered to.    &#13;
    /// @param context The situation that is triggering the plugin:&#13;
    ///  0 -&gt; Plugin for the owner transferring pledge to another party&#13;
    ///  1 -&gt; Plugin for the first delegate transferring pledge to another party&#13;
    ///  2 -&gt; Plugin for the second delegate transferring pledge to another party&#13;
    ///  ...&#13;
    ///  255 -&gt; Plugin for the intendedProject transferring pledge to another party&#13;
    ///&#13;
    ///  256 -&gt; Plugin for the owner receiving pledge to another party&#13;
    ///  257 -&gt; Plugin for the first delegate receiving pledge to another party&#13;
    ///  258 -&gt; Plugin for the second delegate receiving pledge to another party&#13;
    ///  ...&#13;
    ///  511 -&gt; Plugin for the intendedProject receiving pledge to another party&#13;
    /// @param amount The amount of value that will be transfered.&#13;
    function beforeTransfer(&#13;
        uint64 pledgeManager,&#13;
        uint64 pledgeFrom,&#13;
        uint64 pledgeTo,&#13;
        uint64 context,&#13;
        uint amount ) returns (uint maxAllowed);&#13;
&#13;
    /// @notice Plugins are used (much like web hooks) to initiate an action&#13;
    ///  upon any donation, delegation, or transfer; this is an optional feature&#13;
    ///  and allows for extreme customization of the contract. This function&#13;
    ///  implements any action that should be initiated after a transfer.&#13;
    /// @param pledgeManager The admin or current manager of the pledge&#13;
    /// @param pledgeFrom This is the Id from which value will be transfered.&#13;
    /// @param pledgeTo This is the Id that value will be transfered to.    &#13;
    /// @param context The situation that is triggering the plugin:&#13;
    ///  0 -&gt; Plugin for the owner transferring pledge to another party&#13;
    ///  1 -&gt; Plugin for the first delegate transferring pledge to another party&#13;
    ///  2 -&gt; Plugin for the second delegate transferring pledge to another party&#13;
    ///  ...&#13;
    ///  255 -&gt; Plugin for the intendedProject transferring pledge to another party&#13;
    ///&#13;
    ///  256 -&gt; Plugin for the owner receiving pledge to another party&#13;
    ///  257 -&gt; Plugin for the first delegate receiving pledge to another party&#13;
    ///  258 -&gt; Plugin for the second delegate receiving pledge to another party&#13;
    ///  ...&#13;
    ///  511 -&gt; Plugin for the intendedProject receiving pledge to another party&#13;
    ///  @param amount The amount of value that will be transfered.&#13;
    function afterTransfer(&#13;
        uint64 pledgeManager,&#13;
        uint64 pledgeFrom,&#13;
        uint64 pledgeTo,&#13;
        uint64 context,&#13;
        uint amount&#13;
    );&#13;
}&#13;
&#13;
//File: node_modules/giveth-common-contracts/contracts/Owned.sol&#13;
pragma solidity ^0.4.15;&#13;
&#13;
&#13;
/// @title Owned&#13;
/// @author Adrià Massanet &lt;<span class="__cf_email__" data-cfemail="f79693859e96b79498939294989983928f83d99e98">[email protected]</span>&gt;&#13;
/// @notice The Owned contract has an owner address, and provides basic &#13;
///  authorization control functions, this simplifies &amp; the implementation of&#13;
///  user permissions; this contract has three work flows for a change in&#13;
///  ownership, the first requires the new owner to validate that they have the&#13;
///  ability to accept ownership, the second allows the ownership to be&#13;
///  directly transfered without requiring acceptance, and the third allows for&#13;
///  the ownership to be removed to allow for decentralization &#13;
contract Owned {&#13;
&#13;
    address public owner;&#13;
    address public newOwnerCandidate;&#13;
&#13;
    event OwnershipRequested(address indexed by, address indexed to);&#13;
    event OwnershipTransferred(address indexed from, address indexed to);&#13;
    event OwnershipRemoved();&#13;
&#13;
    /// @dev The constructor sets the `msg.sender` as the`owner` of the contract&#13;
    function Owned() public {&#13;
        owner = msg.sender;&#13;
    }&#13;
&#13;
    /// @dev `owner` is the only address that can call a function with this&#13;
    /// modifier&#13;
    modifier onlyOwner() {&#13;
        require (msg.sender == owner);&#13;
        _;&#13;
    }&#13;
    &#13;
    /// @dev In this 1st option for ownership transfer `proposeOwnership()` must&#13;
    ///  be called first by the current `owner` then `acceptOwnership()` must be&#13;
    ///  called by the `newOwnerCandidate`&#13;
    /// @notice `onlyOwner` Proposes to transfer control of the contract to a&#13;
    ///  new owner&#13;
    /// @param _newOwnerCandidate The address being proposed as the new owner&#13;
    function proposeOwnership(address _newOwnerCandidate) public onlyOwner {&#13;
        newOwnerCandidate = _newOwnerCandidate;&#13;
        OwnershipRequested(msg.sender, newOwnerCandidate);&#13;
    }&#13;
&#13;
    /// @notice Can only be called by the `newOwnerCandidate`, accepts the&#13;
    ///  transfer of ownership&#13;
    function acceptOwnership() public {&#13;
        require(msg.sender == newOwnerCandidate);&#13;
&#13;
        address oldOwner = owner;&#13;
        owner = newOwnerCandidate;&#13;
        newOwnerCandidate = 0x0;&#13;
&#13;
        OwnershipTransferred(oldOwner, owner);&#13;
    }&#13;
&#13;
    /// @dev In this 2nd option for ownership transfer `changeOwnership()` can&#13;
    ///  be called and it will immediately assign ownership to the `newOwner`&#13;
    /// @notice `owner` can step down and assign some other address to this role&#13;
    /// @param _newOwner The address of the new owner&#13;
    function changeOwnership(address _newOwner) public onlyOwner {&#13;
        require(_newOwner != 0x0);&#13;
&#13;
        address oldOwner = owner;&#13;
        owner = _newOwner;&#13;
        newOwnerCandidate = 0x0;&#13;
&#13;
        OwnershipTransferred(oldOwner, owner);&#13;
    }&#13;
&#13;
    /// @dev In this 3rd option for ownership transfer `removeOwnership()` can&#13;
    ///  be called and it will immediately assign ownership to the 0x0 address;&#13;
    ///  it requires a 0xdece be input as a parameter to prevent accidental use&#13;
    /// @notice Decentralizes the contract, this operation cannot be undone &#13;
    /// @param _dac `0xdac` has to be entered for this function to work&#13;
    function removeOwnership(address _dac) public onlyOwner {&#13;
        require(_dac == 0xdac);&#13;
        owner = 0x0;&#13;
        newOwnerCandidate = 0x0;&#13;
        OwnershipRemoved();     &#13;
    }&#13;
} &#13;
&#13;
//File: node_modules/giveth-common-contracts/contracts/ERC20.sol&#13;
pragma solidity ^0.4.15;&#13;
&#13;
&#13;
/**&#13;
 * @title ERC20&#13;
 * @dev A standard interface for tokens.&#13;
 * @dev https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md&#13;
 */&#13;
contract ERC20 {&#13;
  &#13;
    /// @dev Returns the total token supply&#13;
    function totalSupply() public constant returns (uint256 supply);&#13;
&#13;
    /// @dev Returns the account balance of the account with address _owner&#13;
    function balanceOf(address _owner) public constant returns (uint256 balance);&#13;
&#13;
    /// @dev Transfers _value number of tokens to address _to&#13;
    function transfer(address _to, uint256 _value) public returns (bool success);&#13;
&#13;
    /// @dev Transfers _value number of tokens from address _from to address _to&#13;
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);&#13;
&#13;
    /// @dev Allows _spender to withdraw from the msg.sender's account up to the _value amount&#13;
    function approve(address _spender, uint256 _value) public returns (bool success);&#13;
&#13;
    /// @dev Returns the amount which _spender is still allowed to withdraw from _owner&#13;
    function allowance(address _owner, address _spender) public constant returns (uint256 remaining);&#13;
&#13;
    event Transfer(address indexed _from, address indexed _to, uint256 _value);&#13;
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);&#13;
&#13;
}&#13;
&#13;
//File: node_modules/giveth-common-contracts/contracts/Escapable.sol&#13;
pragma solidity ^0.4.15;&#13;
/*&#13;
    Copyright 2016, Jordi Baylina&#13;
    Contributor: Adrià Massanet &lt;<span class="__cf_email__" data-cfemail="88e9ecfae1e9c8ebe7ecedebe7e6fcedf0fca6e1e7">[email protected]</span>&gt;&#13;
&#13;
    This program is free software: you can redistribute it and/or modify&#13;
    it under the terms of the GNU General Public License as published by&#13;
    the Free Software Foundation, either version 3 of the License, or&#13;
    (at your option) any later version.&#13;
&#13;
    This program is distributed in the hope that it will be useful,&#13;
    but WITHOUT ANY WARRANTY; without even the implied warranty of&#13;
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&#13;
    GNU General Public License for more details.&#13;
&#13;
    You should have received a copy of the GNU General Public License&#13;
    along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.&#13;
*/&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
/// @dev `Escapable` is a base level contract built off of the `Owned`&#13;
///  contract; it creates an escape hatch function that can be called in an&#13;
///  emergency that will allow designated addresses to send any ether or tokens&#13;
///  held in the contract to an `escapeHatchDestination` as long as they were&#13;
///  not blacklisted&#13;
contract Escapable is Owned {&#13;
    address public escapeHatchCaller;&#13;
    address public escapeHatchDestination;&#13;
    mapping (address=&gt;bool) private escapeBlacklist; // Token contract addresses&#13;
&#13;
    /// @notice The Constructor assigns the `escapeHatchDestination` and the&#13;
    ///  `escapeHatchCaller`&#13;
    /// @param _escapeHatchCaller The address of a trusted account or contract&#13;
    ///  to call `escapeHatch()` to send the ether in this contract to the&#13;
    ///  `escapeHatchDestination` it would be ideal that `escapeHatchCaller`&#13;
    ///  cannot move funds out of `escapeHatchDestination`&#13;
    /// @param _escapeHatchDestination The address of a safe location (usu a&#13;
    ///  Multisig) to send the ether held in this contract; if a neutral address&#13;
    ///  is required, the WHG Multisig is an option:&#13;
    ///  0x8Ff920020c8AD673661c8117f2855C384758C572 &#13;
    function Escapable(address _escapeHatchCaller, address _escapeHatchDestination) public {&#13;
        escapeHatchCaller = _escapeHatchCaller;&#13;
        escapeHatchDestination = _escapeHatchDestination;&#13;
    }&#13;
&#13;
    /// @dev The addresses preassigned as `escapeHatchCaller` or `owner`&#13;
    ///  are the only addresses that can call a function with this modifier&#13;
    modifier onlyEscapeHatchCallerOrOwner {&#13;
        require ((msg.sender == escapeHatchCaller)||(msg.sender == owner));&#13;
        _;&#13;
    }&#13;
&#13;
    /// @notice Creates the blacklist of tokens that are not able to be taken&#13;
    ///  out of the contract; can only be done at the deployment, and the logic&#13;
    ///  to add to the blacklist will be in the constructor of a child contract&#13;
    /// @param _token the token contract address that is to be blacklisted &#13;
    function blacklistEscapeToken(address _token) internal {&#13;
        escapeBlacklist[_token] = true;&#13;
        EscapeHatchBlackistedToken(_token);&#13;
    }&#13;
&#13;
    /// @notice Checks to see if `_token` is in the blacklist of tokens&#13;
    /// @param _token the token address being queried&#13;
    /// @return False if `_token` is in the blacklist and can't be taken out of&#13;
    ///  the contract via the `escapeHatch()`&#13;
    function isTokenEscapable(address _token) constant public returns (bool) {&#13;
        return !escapeBlacklist[_token];&#13;
    }&#13;
&#13;
    /// @notice The `escapeHatch()` should only be called as a last resort if a&#13;
    /// security issue is uncovered or something unexpected happened&#13;
    /// @param _token to transfer, use 0x0 for ether&#13;
    function escapeHatch(address _token) public onlyEscapeHatchCallerOrOwner {   &#13;
        require(escapeBlacklist[_token]==false);&#13;
&#13;
        uint256 balance;&#13;
&#13;
        /// @dev Logic for ether&#13;
        if (_token == 0x0) {&#13;
            balance = this.balance;&#13;
            escapeHatchDestination.transfer(balance);&#13;
            EscapeHatchCalled(_token, balance);&#13;
            return;&#13;
        }&#13;
        /// @dev Logic for tokens&#13;
        ERC20 token = ERC20(_token);&#13;
        balance = token.balanceOf(this);&#13;
        require(token.transfer(escapeHatchDestination, balance));&#13;
        EscapeHatchCalled(_token, balance);&#13;
    }&#13;
&#13;
    /// @notice Changes the address assigned to call `escapeHatch()`&#13;
    /// @param _newEscapeHatchCaller The address of a trusted account or&#13;
    ///  contract to call `escapeHatch()` to send the value in this contract to&#13;
    ///  the `escapeHatchDestination`; it would be ideal that `escapeHatchCaller`&#13;
    ///  cannot move funds out of `escapeHatchDestination`&#13;
    function changeHatchEscapeCaller(address _newEscapeHatchCaller) public onlyEscapeHatchCallerOrOwner {&#13;
        escapeHatchCaller = _newEscapeHatchCaller;&#13;
    }&#13;
&#13;
    event EscapeHatchBlackistedToken(address token);&#13;
    event EscapeHatchCalled(address token, uint amount);&#13;
}&#13;
&#13;
//File: node_modules/liquidpledging/contracts/LiquidPledgingBase.sol&#13;
pragma solidity ^0.4.11;&#13;
/*&#13;
    Copyright 2017, Jordi Baylina&#13;
    Contributors: Adrià Massanet &lt;<span class="__cf_email__" data-cfemail="1f7e7b6d767e5f7c707b7a7c70716b7a676b317670">[email protected]</span>&gt;, RJ Ewing, Griff&#13;
    Green, Arthur Lunn&#13;
&#13;
    This program is free software: you can redistribute it and/or modify&#13;
    it under the terms of the GNU General Public License as published by&#13;
    the Free Software Foundation, either version 3 of the License, or&#13;
    (at your option) any later version.&#13;
&#13;
    This program is distributed in the hope that it will be useful,&#13;
    but WITHOUT ANY WARRANTY; without even the implied warranty of&#13;
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&#13;
    GNU General Public License for more details.&#13;
&#13;
    You should have received a copy of the GNU General Public License&#13;
    along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.&#13;
*/&#13;
&#13;
&#13;
&#13;
&#13;
/// @dev This is an interface for `LPVault` which serves as a secure storage for&#13;
///  the ETH that backs the Pledges, only after `LiquidPledging` authorizes&#13;
///  payments can Pledges be converted for ETH&#13;
interface LPVault {&#13;
    function authorizePayment(bytes32 _ref, address _dest, uint _amount);&#13;
    function () payable;&#13;
}&#13;
&#13;
/// @dev `LiquidPledgingBase` is the base level contract used to carry out&#13;
///  liquidPledging's most basic functions, mostly handling and searching the&#13;
///  data structures&#13;
contract LiquidPledgingBase is Escapable {&#13;
&#13;
    // Limits inserted to prevent large loops that could prevent canceling&#13;
    uint constant MAX_DELEGATES = 20;&#13;
    uint constant MAX_SUBPROJECT_LEVEL = 20;&#13;
    uint constant MAX_INTERPROJECT_LEVEL = 20;&#13;
&#13;
    enum PledgeAdminType { Giver, Delegate, Project }&#13;
    enum PledgeState { Pledged, Paying, Paid }&#13;
&#13;
    /// @dev This struct defines the details of a `PledgeAdmin` which are &#13;
    ///  commonly referenced by their index in the `admins` array&#13;
    ///  and can own pledges and act as delegates&#13;
    struct PledgeAdmin { &#13;
        PledgeAdminType adminType; // Giver, Delegate or Project&#13;
        address addr; // Account or contract address for admin&#13;
        string name;&#13;
        string url;  // Can be IPFS hash&#13;
        uint64 commitTime;  // In seconds, used for Givers' &amp; Delegates' vetos&#13;
        uint64 parentProject;  // Only for projects&#13;
        bool canceled;      //Always false except for canceled projects&#13;
&#13;
        /// @dev if the plugin is 0x0 then nothing happens, if its an address&#13;
        // than that smart contract is called when appropriate&#13;
        ILiquidPledgingPlugin plugin; &#13;
    }&#13;
&#13;
    struct Pledge {&#13;
        uint amount;&#13;
        uint64 owner; // PledgeAdmin&#13;
        uint64[] delegationChain; // List of delegates in order of authority&#13;
        uint64 intendedProject; // Used when delegates are sending to projects&#13;
        uint64 commitTime;  // When the intendedProject will become the owner  &#13;
        uint64 oldPledge; // Points to the id that this Pledge was derived from&#13;
        PledgeState pledgeState; //  Pledged, Paying, Paid&#13;
    }&#13;
&#13;
    Pledge[] pledges;&#13;
    PledgeAdmin[] admins; //The list of pledgeAdmins 0 means there is no admin&#13;
    LPVault public vault;&#13;
&#13;
    /// @dev this mapping allows you to search for a specific pledge's &#13;
    ///  index number by the hash of that pledge&#13;
    mapping (bytes32 =&gt; uint64) hPledge2idx;&#13;
    mapping (bytes32 =&gt; bool) pluginWhitelist;&#13;
    &#13;
    bool public usePluginWhitelist = true;&#13;
&#13;
/////////////&#13;
// Modifiers&#13;
/////////////&#13;
&#13;
&#13;
    /// @dev The `vault`is the only addresses that can call a function with this&#13;
    ///  modifier&#13;
    modifier onlyVault() {&#13;
        require(msg.sender == address(vault));&#13;
        _;&#13;
    }&#13;
&#13;
&#13;
///////////////&#13;
// Constructor&#13;
///////////////&#13;
&#13;
    /// @notice The Constructor creates `LiquidPledgingBase` on the blockchain&#13;
    /// @param _vault The vault where the ETH backing the pledges is stored&#13;
    function LiquidPledgingBase(&#13;
        address _vault,&#13;
        address _escapeHatchCaller,&#13;
        address _escapeHatchDestination&#13;
    ) Escapable(_escapeHatchCaller, _escapeHatchDestination) public {&#13;
        admins.length = 1; // we reserve the 0 admin&#13;
        pledges.length = 1; // we reserve the 0 pledge&#13;
        vault = LPVault(_vault); // Assigns the specified vault&#13;
    }&#13;
&#13;
&#13;
/////////////////////////&#13;
// PledgeAdmin functions&#13;
/////////////////////////&#13;
&#13;
    /// @notice Creates a Giver Admin with the `msg.sender` as the Admin address&#13;
    /// @param name The name used to identify the Giver&#13;
    /// @param url The link to the Giver's profile often an IPFS hash&#13;
    /// @param commitTime The length of time in seconds the Giver has to&#13;
    ///   veto when the Giver's delegates Pledge funds to a project&#13;
    /// @param plugin This is Giver's liquid pledge plugin allowing for &#13;
    ///  extended functionality&#13;
    /// @return idGiver The id number used to reference this Admin&#13;
    function addGiver(&#13;
        string name,&#13;
        string url,&#13;
        uint64 commitTime,&#13;
        ILiquidPledgingPlugin plugin&#13;
    ) returns (uint64 idGiver) {&#13;
&#13;
        require(isValidPlugin(plugin)); // Plugin check&#13;
&#13;
        idGiver = uint64(admins.length);&#13;
&#13;
        admins.push(PledgeAdmin(&#13;
            PledgeAdminType.Giver,&#13;
            msg.sender,&#13;
            name,&#13;
            url,&#13;
            commitTime,&#13;
            0,&#13;
            false,&#13;
            plugin));&#13;
&#13;
        GiverAdded(idGiver);&#13;
    }&#13;
&#13;
    event GiverAdded(uint64 indexed idGiver);&#13;
&#13;
    /// @notice Updates a Giver's info to change the address, name, url, or &#13;
    ///  commitTime, it cannot be used to change a plugin, and it must be called&#13;
    ///  by the current address of the Giver&#13;
    /// @param idGiver This is the Admin id number used to specify the Giver&#13;
    /// @param newAddr The new address that represents this Giver&#13;
    /// @param newName The new name used to identify the Giver&#13;
    /// @param newUrl The new link to the Giver's profile often an IPFS hash&#13;
    /// @param newCommitTime Sets the length of time in seconds the Giver has to&#13;
    ///   veto when the Giver's delegates Pledge funds to a project&#13;
    function updateGiver(&#13;
        uint64 idGiver,&#13;
        address newAddr,&#13;
        string newName,&#13;
        string newUrl,&#13;
        uint64 newCommitTime)&#13;
    {&#13;
        PledgeAdmin storage giver = findAdmin(idGiver);&#13;
        require(giver.adminType == PledgeAdminType.Giver); // Must be a Giver&#13;
        require(giver.addr == msg.sender); // Current addr had to send this tx&#13;
        giver.addr = newAddr;&#13;
        giver.name = newName;&#13;
        giver.url = newUrl;&#13;
        giver.commitTime = newCommitTime;&#13;
        GiverUpdated(idGiver);&#13;
    }&#13;
&#13;
    event GiverUpdated(uint64 indexed idGiver);&#13;
&#13;
    /// @notice Creates a Delegate Admin with the `msg.sender` as the Admin addr&#13;
    /// @param name The name used to identify the Delegate&#13;
    /// @param url The link to the Delegate's profile often an IPFS hash&#13;
    /// @param commitTime Sets the length of time in seconds that this delegate&#13;
    ///  can be vetoed. Whenever this delegate is in a delegate chain the time&#13;
    ///  allowed to veto any event must be greater than or equal to this time.&#13;
    /// @param plugin This is Delegate's liquid pledge plugin allowing for &#13;
    ///  extended functionality&#13;
    /// @return idxDelegate The id number used to reference this Delegate within&#13;
    ///  the admins array&#13;
    function addDelegate(&#13;
        string name,&#13;
        string url,&#13;
        uint64 commitTime,&#13;
        ILiquidPledgingPlugin plugin&#13;
    ) returns (uint64 idDelegate) { &#13;
&#13;
        require(isValidPlugin(plugin)); // Plugin check&#13;
&#13;
        idDelegate = uint64(admins.length);&#13;
&#13;
        admins.push(PledgeAdmin(&#13;
            PledgeAdminType.Delegate,&#13;
            msg.sender,&#13;
            name,&#13;
            url,&#13;
            commitTime,&#13;
            0,&#13;
            false,&#13;
            plugin));&#13;
&#13;
        DelegateAdded(idDelegate);&#13;
    }&#13;
&#13;
    event DelegateAdded(uint64 indexed idDelegate);&#13;
&#13;
    /// @notice Updates a Delegate's info to change the address, name, url, or &#13;
    ///  commitTime, it cannot be used to change a plugin, and it must be called&#13;
    ///  by the current address of the Delegate&#13;
    /// @param idDelegate The Admin id number used to specify the Delegate&#13;
    /// @param newAddr The new address that represents this Delegate&#13;
    /// @param newName The new name used to identify the Delegate&#13;
    /// @param newUrl The new link to the Delegate's profile often an IPFS hash&#13;
    /// @param newCommitTime Sets the length of time in seconds that this &#13;
    ///  delegate can be vetoed. Whenever this delegate is in a delegate chain &#13;
    ///  the time allowed to veto any event must be greater than or equal to&#13;
    ///  this time.&#13;
    function updateDelegate(&#13;
        uint64 idDelegate,&#13;
        address newAddr,&#13;
        string newName,&#13;
        string newUrl,&#13;
        uint64 newCommitTime) {&#13;
        PledgeAdmin storage delegate = findAdmin(idDelegate);&#13;
        require(delegate.adminType == PledgeAdminType.Delegate);&#13;
        require(delegate.addr == msg.sender);// Current addr had to send this tx&#13;
        delegate.addr = newAddr;&#13;
        delegate.name = newName;&#13;
        delegate.url = newUrl;&#13;
        delegate.commitTime = newCommitTime;&#13;
        DelegateUpdated(idDelegate);&#13;
    }&#13;
&#13;
    event DelegateUpdated(uint64 indexed idDelegate);&#13;
&#13;
    /// @notice Creates a Project Admin with the `msg.sender` as the Admin addr&#13;
    /// @param name The name used to identify the Project&#13;
    /// @param url The link to the Project's profile often an IPFS hash&#13;
    /// @param projectAdmin The address for the trusted project manager &#13;
    /// @param parentProject The Admin id number for the parent project or 0 if&#13;
    ///  there is no parentProject&#13;
    /// @param commitTime Sets the length of time in seconds the Project has to&#13;
    ///   veto when the Project delegates to another Delegate and they pledge &#13;
    ///   those funds to a project&#13;
    /// @param plugin This is Project's liquid pledge plugin allowing for &#13;
    ///  extended functionality&#13;
    /// @return idProject The id number used to reference this Admin&#13;
    function addProject(&#13;
        string name,&#13;
        string url,&#13;
        address projectAdmin,&#13;
        uint64 parentProject,&#13;
        uint64 commitTime,&#13;
        ILiquidPledgingPlugin plugin&#13;
    ) returns (uint64 idProject) {&#13;
        require(isValidPlugin(plugin));&#13;
&#13;
        if (parentProject != 0) {&#13;
            PledgeAdmin storage pa = findAdmin(parentProject);&#13;
            require(pa.adminType == PledgeAdminType.Project);&#13;
            require(getProjectLevel(pa) &lt; MAX_SUBPROJECT_LEVEL);&#13;
        }&#13;
&#13;
        idProject = uint64(admins.length);&#13;
&#13;
        admins.push(PledgeAdmin(&#13;
            PledgeAdminType.Project,&#13;
            projectAdmin,&#13;
            name,&#13;
            url,&#13;
            commitTime,&#13;
            parentProject,&#13;
            false,&#13;
            plugin));&#13;
&#13;
&#13;
        ProjectAdded(idProject);&#13;
    }&#13;
&#13;
    event ProjectAdded(uint64 indexed idProject);&#13;
&#13;
&#13;
    /// @notice Updates a Project's info to change the address, name, url, or &#13;
    ///  commitTime, it cannot be used to change a plugin or a parentProject,&#13;
    ///  and it must be called by the current address of the Project&#13;
    /// @param idProject The Admin id number used to specify the Project&#13;
    /// @param newAddr The new address that represents this Project&#13;
    /// @param newName The new name used to identify the Project&#13;
    /// @param newUrl The new link to the Project's profile often an IPFS hash&#13;
    /// @param newCommitTime Sets the length of time in seconds the Project has&#13;
    ///  to veto when the Project delegates to a Delegate and they pledge those&#13;
    ///  funds to a project&#13;
    function updateProject(&#13;
        uint64 idProject,&#13;
        address newAddr,&#13;
        string newName,&#13;
        string newUrl,&#13;
        uint64 newCommitTime)&#13;
    {&#13;
        PledgeAdmin storage project = findAdmin(idProject);&#13;
        require(project.adminType == PledgeAdminType.Project);&#13;
        require(project.addr == msg.sender);&#13;
        project.addr = newAddr;&#13;
        project.name = newName;&#13;
        project.url = newUrl;&#13;
        project.commitTime = newCommitTime;&#13;
        ProjectUpdated(idProject);&#13;
    }&#13;
&#13;
    event ProjectUpdated(uint64 indexed idAdmin);&#13;
&#13;
&#13;
//////////&#13;
// Public constant functions&#13;
//////////&#13;
&#13;
    /// @notice A constant getter that returns the total number of pledges&#13;
    /// @return The total number of Pledges in the system&#13;
    function numberOfPledges() constant returns (uint) {&#13;
        return pledges.length - 1;&#13;
    }&#13;
&#13;
    /// @notice A getter that returns the details of the specified pledge&#13;
    /// @param idPledge the id number of the pledge being queried&#13;
    /// @return the amount, owner, the number of delegates (but not the actual&#13;
    ///  delegates, the intendedProject (if any), the current commit time and&#13;
    ///  the previous pledge this pledge was derived from&#13;
    function getPledge(uint64 idPledge) constant returns(&#13;
        uint amount,&#13;
        uint64 owner,&#13;
        uint64 nDelegates,&#13;
        uint64 intendedProject,&#13;
        uint64 commitTime,&#13;
        uint64 oldPledge,&#13;
        PledgeState pledgeState&#13;
    ) {&#13;
        Pledge storage p = findPledge(idPledge);&#13;
        amount = p.amount;&#13;
        owner = p.owner;&#13;
        nDelegates = uint64(p.delegationChain.length);&#13;
        intendedProject = p.intendedProject;&#13;
        commitTime = p.commitTime;&#13;
        oldPledge = p.oldPledge;&#13;
        pledgeState = p.pledgeState;&#13;
    }&#13;
&#13;
    /// @notice Getter to find Delegate w/ the Pledge ID &amp; the Delegate index&#13;
    /// @param idPledge The id number representing the pledge being queried&#13;
    /// @param idxDelegate The index number for the delegate in this Pledge &#13;
    function getPledgeDelegate(uint64 idPledge, uint idxDelegate) constant returns(&#13;
        uint64 idDelegate,&#13;
        address addr,&#13;
        string name&#13;
    ) {&#13;
        Pledge storage p = findPledge(idPledge);&#13;
        idDelegate = p.delegationChain[idxDelegate - 1];&#13;
        PledgeAdmin storage delegate = findAdmin(idDelegate);&#13;
        addr = delegate.addr;&#13;
        name = delegate.name;&#13;
    }&#13;
&#13;
    /// @notice A constant getter used to check how many total Admins exist&#13;
    /// @return The total number of admins (Givers, Delegates and Projects) .&#13;
    function numberOfPledgeAdmins() constant returns(uint) {&#13;
        return admins.length - 1;&#13;
    }&#13;
&#13;
    /// @notice A constant getter to check the details of a specified Admin  &#13;
    /// @return addr Account or contract address for admin&#13;
    /// @return name Name of the pledgeAdmin&#13;
    /// @return url The link to the Project's profile often an IPFS hash&#13;
    /// @return commitTime The length of time in seconds the Admin has to veto&#13;
    ///   when the Admin delegates to a Delegate and that Delegate pledges those&#13;
    ///   funds to a project&#13;
    /// @return parentProject The Admin id number for the parent project or 0&#13;
    ///  if there is no parentProject&#13;
    /// @return canceled 0 for Delegates &amp; Givers, true if a Project has been &#13;
    ///  canceled&#13;
    /// @return plugin This is Project's liquidPledging plugin allowing for &#13;
    ///  extended functionality&#13;
    function getPledgeAdmin(uint64 idAdmin) constant returns (&#13;
        PledgeAdminType adminType,&#13;
        address addr,&#13;
        string name,&#13;
        string url,&#13;
        uint64 commitTime,&#13;
        uint64 parentProject,&#13;
        bool canceled,&#13;
        address plugin)&#13;
    {&#13;
        PledgeAdmin storage m = findAdmin(idAdmin);&#13;
        adminType = m.adminType;&#13;
        addr = m.addr;&#13;
        name = m.name;&#13;
        url = m.url;&#13;
        commitTime = m.commitTime;&#13;
        parentProject = m.parentProject;&#13;
        canceled = m.canceled;&#13;
        plugin = address(m.plugin);&#13;
    }&#13;
&#13;
////////&#13;
// Private methods&#13;
///////&#13;
&#13;
    /// @notice This creates a Pledge with an initial amount of 0 if one is not&#13;
    ///  created already; otherwise it finds the pledge with the specified&#13;
    ///  attributes; all pledges technically exist, if the pledge hasn't been&#13;
    ///  created in this system yet it simply isn't in the hash array&#13;
    ///  hPledge2idx[] yet&#13;
    /// @param owner The owner of the pledge being looked up&#13;
    /// @param delegationChain The list of delegates in order of authority&#13;
    /// @param intendedProject The project this pledge will Fund after the&#13;
    ///  commitTime has passed&#13;
    /// @param commitTime The length of time in seconds the Giver has to&#13;
    ///   veto when the Giver's delegates Pledge funds to a project&#13;
    /// @param oldPledge This value is used to store the pledge the current&#13;
    ///  pledge was came from, and in the case a Project is canceled, the Pledge&#13;
    ///  will revert back to it's previous state&#13;
    /// @param state The pledge state: Pledged, Paying, or state&#13;
    /// @return The hPledge2idx index number&#13;
    function findOrCreatePledge(&#13;
        uint64 owner,&#13;
        uint64[] delegationChain,&#13;
        uint64 intendedProject,&#13;
        uint64 commitTime,&#13;
        uint64 oldPledge,&#13;
        PledgeState state&#13;
        ) internal returns (uint64)&#13;
    {&#13;
        bytes32 hPledge = sha3(&#13;
            owner, delegationChain, intendedProject, commitTime, oldPledge, state);&#13;
        uint64 idx = hPledge2idx[hPledge];&#13;
        if (idx &gt; 0) return idx;&#13;
        idx = uint64(pledges.length);&#13;
        hPledge2idx[hPledge] = idx;&#13;
        pledges.push(Pledge(&#13;
            0, owner, delegationChain, intendedProject, commitTime, oldPledge, state));&#13;
        return idx;&#13;
    }&#13;
&#13;
    /// @notice A getter to look up a Admin's details&#13;
    /// @param idAdmin The id for the Admin to lookup&#13;
    /// @return The PledgeAdmin struct for the specified Admin&#13;
    function findAdmin(uint64 idAdmin) internal returns (PledgeAdmin storage) {&#13;
        require(idAdmin &lt; admins.length);&#13;
        return admins[idAdmin];&#13;
    }&#13;
&#13;
    /// @notice A getter to look up a Pledge's details&#13;
    /// @param idPledge The id for the Pledge to lookup&#13;
    /// @return The PledgeA struct for the specified Pledge&#13;
    function findPledge(uint64 idPledge) internal returns (Pledge storage) {&#13;
        require(idPledge &lt; pledges.length);&#13;
        return pledges[idPledge];&#13;
    }&#13;
&#13;
    // a constant for when a delegate is requested that is not in the system&#13;
    uint64 constant  NOTFOUND = 0xFFFFFFFFFFFFFFFF;&#13;
&#13;
    /// @notice A getter that searches the delegationChain for the level of&#13;
    ///  authority a specific delegate has within a Pledge&#13;
    /// @param p The Pledge that will be searched&#13;
    /// @param idDelegate The specified delegate that's searched for&#13;
    /// @return If the delegate chain contains the delegate with the&#13;
    ///  `admins` array index `idDelegate` this returns that delegates&#13;
    ///  corresponding index in the delegationChain. Otherwise it returns&#13;
    ///  the NOTFOUND constant&#13;
    function getDelegateIdx(Pledge p, uint64 idDelegate) internal returns(uint64) {&#13;
        for (uint i=0; i &lt; p.delegationChain.length; i++) {&#13;
            if (p.delegationChain[i] == idDelegate) return uint64(i);&#13;
        }&#13;
        return NOTFOUND;&#13;
    }&#13;
&#13;
    /// @notice A getter to find how many old "parent" pledges a specific Pledge&#13;
    ///  had using a self-referential loop&#13;
    /// @param p The Pledge being queried&#13;
    /// @return The number of old "parent" pledges a specific Pledge had&#13;
    function getPledgeLevel(Pledge p) internal returns(uint) {&#13;
        if (p.oldPledge == 0) return 0;&#13;
        Pledge storage oldN = findPledge(p.oldPledge);&#13;
        return getPledgeLevel(oldN) + 1; // a loop lookup&#13;
    }&#13;
&#13;
    /// @notice A getter to find the longest commitTime out of the owner and all&#13;
    ///  the delegates for a specified pledge&#13;
    /// @param p The Pledge being queried&#13;
    /// @return The maximum commitTime out of the owner and all the delegates&#13;
    function maxCommitTime(Pledge p) internal returns(uint commitTime) {&#13;
        PledgeAdmin storage m = findAdmin(p.owner);&#13;
        commitTime = m.commitTime; // start with the owner's commitTime&#13;
&#13;
        for (uint i=0; i&lt;p.delegationChain.length; i++) {&#13;
            m = findAdmin(p.delegationChain[i]);&#13;
&#13;
            // If a delegate's commitTime is longer, make it the new commitTime&#13;
            if (m.commitTime &gt; commitTime) commitTime = m.commitTime;&#13;
        }&#13;
    }&#13;
&#13;
    /// @notice A getter to find the level of authority a specific Project has&#13;
    ///  using a self-referential loop&#13;
    /// @param m The Project being queried&#13;
    /// @return The level of authority a specific Project has&#13;
    function getProjectLevel(PledgeAdmin m) internal returns(uint) {&#13;
        assert(m.adminType == PledgeAdminType.Project);&#13;
        if (m.parentProject == 0) return(1);&#13;
        PledgeAdmin storage parentNM = findAdmin(m.parentProject);&#13;
        return getProjectLevel(parentNM) + 1;&#13;
    }&#13;
&#13;
    /// @notice A getter to find if a specified Project has been canceled&#13;
    /// @param projectId The Admin id number used to specify the Project&#13;
    /// @return True if the Project has been canceled&#13;
    function isProjectCanceled(uint64 projectId) constant returns (bool) {&#13;
        PledgeAdmin storage m = findAdmin(projectId);&#13;
        if (m.adminType == PledgeAdminType.Giver) return false;&#13;
        assert(m.adminType == PledgeAdminType.Project);&#13;
        if (m.canceled) return true;&#13;
        if (m.parentProject == 0) return false;&#13;
        return isProjectCanceled(m.parentProject);&#13;
    }&#13;
&#13;
    /// @notice A getter to find the oldest pledge that hasn't been canceled&#13;
    /// @param idPledge The starting place to lookup the pledges &#13;
    /// @return The oldest idPledge that hasn't been canceled (DUH!)&#13;
    function getOldestPledgeNotCanceled(uint64 idPledge&#13;
        ) internal constant returns(uint64) {&#13;
        if (idPledge == 0) return 0;&#13;
        Pledge storage p = findPledge(idPledge);&#13;
        PledgeAdmin storage admin = findAdmin(p.owner);&#13;
        if (admin.adminType == PledgeAdminType.Giver) return idPledge;&#13;
&#13;
        assert(admin.adminType == PledgeAdminType.Project);&#13;
&#13;
        if (!isProjectCanceled(p.owner)) return idPledge;&#13;
&#13;
        return getOldestPledgeNotCanceled(p.oldPledge);&#13;
    }&#13;
&#13;
    /// @notice A check to see if the msg.sender is the owner or the&#13;
    ///  plugin contract for a specific Admin&#13;
    /// @param m The Admin being checked&#13;
    function checkAdminOwner(PledgeAdmin m) internal constant {&#13;
        require((msg.sender == m.addr) || (msg.sender == address(m.plugin)));&#13;
    }&#13;
///////////////////////////&#13;
// Plugin Whitelist Methods&#13;
///////////////////////////&#13;
&#13;
    function addValidPlugin(bytes32 contractHash) external onlyOwner {&#13;
        pluginWhitelist[contractHash] = true;&#13;
    }&#13;
&#13;
    function removeValidPlugin(bytes32 contractHash) external onlyOwner {&#13;
        pluginWhitelist[contractHash] = false;&#13;
    }&#13;
&#13;
    function useWhitelist(bool useWhitelist) external onlyOwner {&#13;
        usePluginWhitelist = useWhitelist;&#13;
    }&#13;
&#13;
    function isValidPlugin(address addr) public returns(bool) {&#13;
        if (!usePluginWhitelist || addr == 0x0) return true;&#13;
&#13;
        bytes32 contractHash = getCodeHash(addr);&#13;
&#13;
        return pluginWhitelist[contractHash];&#13;
    }&#13;
&#13;
    function getCodeHash(address addr) public returns(bytes32) {&#13;
        bytes memory o_code;&#13;
        assembly {&#13;
            // retrieve the size of the code, this needs assembly&#13;
            let size := extcodesize(addr)&#13;
            // allocate output byte array - this could also be done without assembly&#13;
            // by using o_code = new bytes(size)&#13;
            o_code := mload(0x40)&#13;
            // new "memory end" including padding&#13;
            mstore(0x40, add(o_code, and(add(add(size, 0x20), 0x1f), not(0x1f))))&#13;
            // store length in memory&#13;
            mstore(o_code, size)&#13;
            // actually retrieve the code, this needs assembly&#13;
            extcodecopy(addr, add(o_code, 0x20), 0, size)&#13;
        }&#13;
        return keccak256(o_code);&#13;
    }&#13;
}&#13;
&#13;
//File: node_modules/liquidpledging/contracts/LiquidPledging.sol&#13;
pragma solidity ^0.4.11;&#13;
&#13;
/*&#13;
    Copyright 2017, Jordi Baylina&#13;
    Contributor: Adrià Massanet &lt;<span class="__cf_email__" data-cfemail="f69792849f97b69599929395999882938e82d89f99">[email protected]</span>&gt;&#13;
&#13;
    This program is free software: you can redistribute it and/or modify&#13;
    it under the terms of the GNU General Public License as published by&#13;
    the Free Software Foundation, either version 3 of the License, or&#13;
    (at your option) any later version.&#13;
&#13;
    This program is distributed in the hope that it will be useful,&#13;
    but WITHOUT ANY WARRANTY; without even the implied warranty of&#13;
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&#13;
    GNU General Public License for more details.&#13;
&#13;
    You should have received a copy of the GNU General Public License&#13;
    along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.&#13;
*/&#13;
&#13;
// Contract Imports&#13;
&#13;
&#13;
/// @dev `LiquidPleding` allows for liquid pledging through the use of&#13;
///  internal id structures and delegate chaining. All basic operations for&#13;
///  handling liquid pledging are supplied as well as plugin features&#13;
///  to allow for expanded functionality.&#13;
contract LiquidPledging is LiquidPledgingBase {&#13;
&#13;
&#13;
//////&#13;
// Constructor&#13;
//////&#13;
&#13;
    /// @notice Basic constructor for LiquidPleding, also calls the&#13;
    ///  LiquidPledgingBase contract&#13;
    /// @dev This constructor  also calls the constructor &#13;
    ///  for `LiquidPledgingBase`&#13;
    /// @param _vault The vault where ETH backing this pledge is stored&#13;
    function LiquidPledging(&#13;
        address _vault,&#13;
        address _escapeHatchCaller,&#13;
        address _escapeHatchDestination&#13;
    ) LiquidPledgingBase(_vault, _escapeHatchCaller, _escapeHatchDestination) {&#13;
&#13;
    }&#13;
&#13;
    /// @notice This is how value enters into the system which creates pledges;&#13;
    ///  the token of value goes into the vault and the amount in the pledge&#13;
    ///  relevant to this Giver without delegates is increased, and a normal&#13;
    ///  transfer is done to the idReceiver&#13;
    /// @param idGiver Identifier of the giver thats donating.&#13;
    /// @param idReceiver To whom it's transfered. Can be the same giver,&#13;
    ///  another giver, a delegate or a project.&#13;
    function donate(uint64 idGiver, uint64 idReceiver) payable {&#13;
        if (idGiver == 0) {&#13;
            // default to 3 day commitTime&#13;
            idGiver = addGiver("", "", 259200, ILiquidPledgingPlugin(0x0));&#13;
        }&#13;
&#13;
        PledgeAdmin storage sender = findAdmin(idGiver);&#13;
&#13;
        checkAdminOwner(sender);&#13;
&#13;
        require(sender.adminType == PledgeAdminType.Giver);&#13;
&#13;
        uint amount = msg.value;&#13;
&#13;
        require(amount &gt; 0);&#13;
&#13;
        vault.transfer(amount); // transfers the baseToken to the Vault&#13;
        uint64 idPledge = findOrCreatePledge(&#13;
            idGiver,&#13;
            new uint64[](0), //what is new?&#13;
            0,&#13;
            0,&#13;
            0,&#13;
            PledgeState.Pledged&#13;
        );&#13;
&#13;
&#13;
        Pledge storage nTo = findPledge(idPledge);&#13;
        nTo.amount += amount;&#13;
&#13;
        Transfer(0, idPledge, amount);&#13;
&#13;
        transfer(idGiver, idPledge, amount, idReceiver);&#13;
    }&#13;
&#13;
&#13;
    /// @notice Moves value between pledges&#13;
    /// @param idSender ID of the giver, delegate or project admin that is &#13;
    ///  transferring the funds from Pledge to Pledge; this admin must have &#13;
    ///  permissions to move the value&#13;
    /// @param idPledge Id of the pledge that's moving the value&#13;
    /// @param amount Quantity of value that's being moved&#13;
    /// @param idReceiver Destination of the value, can be a giver sending to &#13;
    ///  a giver or a delegate, a delegate to another delegate or a project &#13;
    ///  to pre-commit it to that project if called from a delegate,&#13;
    ///  or to commit it to the project if called from the owner. &#13;
    function transfer(&#13;
        uint64 idSender,&#13;
        uint64 idPledge,&#13;
        uint amount,&#13;
        uint64 idReceiver&#13;
    )&#13;
    {&#13;
&#13;
        idPledge = normalizePledge(idPledge);&#13;
&#13;
        Pledge storage p = findPledge(idPledge);&#13;
        PledgeAdmin storage receiver = findAdmin(idReceiver);&#13;
        PledgeAdmin storage sender = findAdmin(idSender);&#13;
&#13;
        checkAdminOwner(sender);&#13;
        require(p.pledgeState == PledgeState.Pledged);&#13;
&#13;
        // If the sender is the owner&#13;
        if (p.owner == idSender) {&#13;
            if (receiver.adminType == PledgeAdminType.Giver) {&#13;
                transferOwnershipToGiver(idPledge, amount, idReceiver);&#13;
            } else if (receiver.adminType == PledgeAdminType.Project) {&#13;
                transferOwnershipToProject(idPledge, amount, idReceiver);&#13;
            } else if (receiver.adminType == PledgeAdminType.Delegate) {&#13;
                idPledge = undelegate(&#13;
                    idPledge,&#13;
                    amount,&#13;
                    p.delegationChain.length&#13;
                );&#13;
                appendDelegate(idPledge, amount, idReceiver);&#13;
            } else {&#13;
                assert(false);&#13;
            }&#13;
            return;&#13;
        }&#13;
&#13;
        // If the sender is a delegate&#13;
        uint senderDIdx = getDelegateIdx(p, idSender);&#13;
        if (senderDIdx != NOTFOUND) {&#13;
&#13;
            // If the receiver is another giver&#13;
            if (receiver.adminType == PledgeAdminType.Giver) {&#13;
                // Only accept to change to the original giver to&#13;
                // remove all delegates&#13;
                assert(p.owner == idReceiver);&#13;
                undelegate(idPledge, amount, p.delegationChain.length);&#13;
                return;&#13;
            }&#13;
&#13;
            // If the receiver is another delegate&#13;
            if (receiver.adminType == PledgeAdminType.Delegate) {&#13;
                uint receiverDIdx = getDelegateIdx(p, idReceiver);&#13;
&#13;
                // If the receiver is not in the delegate list&#13;
                if (receiverDIdx == NOTFOUND) {&#13;
                    idPledge = undelegate(&#13;
                        idPledge,&#13;
                        amount,&#13;
                        p.delegationChain.length - senderDIdx - 1&#13;
                    );&#13;
                    appendDelegate(idPledge, amount, idReceiver);&#13;
&#13;
                // If the receiver is already part of the delegate chain and is&#13;
                // after the sender, then all of the other delegates after the&#13;
                // sender are removed and the receiver is appended at the&#13;
                // end of the delegation chain&#13;
                } else if (receiverDIdx &gt; senderDIdx) {&#13;
                    idPledge = undelegate(&#13;
                        idPledge,&#13;
                        amount,&#13;
                        p.delegationChain.length - senderDIdx - 1&#13;
                    );&#13;
                    appendDelegate(idPledge, amount, idReceiver);&#13;
&#13;
                // If the receiver is already part of the delegate chain and is&#13;
                // before the sender, then the sender and all of the other&#13;
                // delegates after the RECEIVER are removed from the chain,&#13;
                // this is interesting because the delegate is removed from the&#13;
                // delegates that delegated to this delegate. Are there game theory&#13;
                // issues? should this be allowed?&#13;
                } else if (receiverDIdx &lt;= senderDIdx) {&#13;
                    undelegate(&#13;
                        idPledge,&#13;
                        amount,&#13;
                        p.delegationChain.length - receiverDIdx - 1&#13;
                    );&#13;
                }&#13;
                return;&#13;
            }&#13;
&#13;
            // If the delegate wants to support a project, they remove all&#13;
            // the delegates after them in the chain and choose a project&#13;
            if (receiver.adminType == PledgeAdminType.Project) {&#13;
                idPledge = undelegate(&#13;
                    idPledge,&#13;
                    amount,&#13;
                    p.delegationChain.length - senderDIdx - 1&#13;
                );&#13;
                proposeAssignProject(idPledge, amount, idReceiver);&#13;
                return;&#13;
            }&#13;
        }&#13;
        assert(false);  // It is not the owner nor any delegate.&#13;
    }&#13;
&#13;
    /// @notice This method is used to withdraw value from the system.&#13;
    ///  This can be used by the givers withdraw any un-commited donations.&#13;
    /// @param idPledge Id of the pledge that wants to be withdrawn.&#13;
    /// @param amount Quantity of Ether that wants to be withdrawn.&#13;
    function withdraw(uint64 idPledge, uint amount) {&#13;
&#13;
        idPledge = normalizePledge(idPledge);&#13;
&#13;
        Pledge storage p = findPledge(idPledge);&#13;
&#13;
        require(p.pledgeState == PledgeState.Pledged);&#13;
&#13;
        PledgeAdmin storage owner = findAdmin(p.owner);&#13;
&#13;
        checkAdminOwner(owner);&#13;
&#13;
        uint64 idNewPledge = findOrCreatePledge(&#13;
            p.owner,&#13;
            p.delegationChain,&#13;
            0,&#13;
            0,&#13;
            p.oldPledge,&#13;
            PledgeState.Paying&#13;
        );&#13;
&#13;
        doTransfer(idPledge, idNewPledge, amount);&#13;
&#13;
        vault.authorizePayment(bytes32(idNewPledge), owner.addr, amount);&#13;
    }&#13;
&#13;
    /// @notice Method called by the vault to confirm a payment.&#13;
    /// @param idPledge Id of the pledge that wants to be withdrawn.&#13;
    /// @param amount Quantity of Ether that wants to be withdrawn.&#13;
    function confirmPayment(uint64 idPledge, uint amount) onlyVault {&#13;
        Pledge storage p = findPledge(idPledge);&#13;
&#13;
        require(p.pledgeState == PledgeState.Paying);&#13;
&#13;
        uint64 idNewPledge = findOrCreatePledge(&#13;
            p.owner,&#13;
            p.delegationChain,&#13;
            0,&#13;
            0,&#13;
            p.oldPledge,&#13;
            PledgeState.Paid&#13;
        );&#13;
&#13;
        doTransfer(idPledge, idNewPledge, amount);&#13;
    }&#13;
&#13;
    /// @notice Method called by the vault to cancel a payment.&#13;
    /// @param idPledge Id of the pledge that wants to be canceled for withdraw.&#13;
    /// @param amount Quantity of Ether that wants to be rolled back.&#13;
    function cancelPayment(uint64 idPledge, uint amount) onlyVault {&#13;
        Pledge storage p = findPledge(idPledge);&#13;
&#13;
        require(p.pledgeState == PledgeState.Paying); //TODO change to revert&#13;
&#13;
        // When a payment is canceled, never is assigned to a project.&#13;
        uint64 oldPledge = findOrCreatePledge(&#13;
            p.owner,&#13;
            p.delegationChain,&#13;
            0,&#13;
            0,&#13;
            p.oldPledge,&#13;
            PledgeState.Pledged&#13;
        );&#13;
&#13;
        oldPledge = normalizePledge(oldPledge);&#13;
&#13;
        doTransfer(idPledge, oldPledge, amount);&#13;
    }&#13;
&#13;
    /// @notice Method called to cancel this project.&#13;
    /// @param idProject Id of the projct that wants to be canceled.&#13;
    function cancelProject(uint64 idProject) {&#13;
        PledgeAdmin storage project = findAdmin(idProject);&#13;
        checkAdminOwner(project);&#13;
        project.canceled = true;&#13;
&#13;
        CancelProject(idProject);&#13;
    }&#13;
&#13;
    /// @notice Method called to cancel specific pledge.&#13;
    /// @param idPledge Id of the pledge that should be canceled.&#13;
    /// @param amount Quantity of Ether that wants to be rolled back.&#13;
    function cancelPledge(uint64 idPledge, uint amount) {&#13;
        idPledge = normalizePledge(idPledge);&#13;
&#13;
        Pledge storage p = findPledge(idPledge);&#13;
        require(p.oldPledge != 0);&#13;
&#13;
        PledgeAdmin storage m = findAdmin(p.owner);&#13;
        checkAdminOwner(m);&#13;
&#13;
        uint64 oldPledge = getOldestPledgeNotCanceled(p.oldPledge);&#13;
        doTransfer(idPledge, oldPledge, amount);&#13;
    }&#13;
&#13;
&#13;
////////&#13;
// Multi pledge methods&#13;
////////&#13;
&#13;
    // @dev This set of functions makes moving a lot of pledges around much more&#13;
    // efficient (saves gas) than calling these functions in series&#13;
    &#13;
    &#13;
    /// Bit mask used for dividing pledge amounts in Multi pledge methods&#13;
    uint constant D64 = 0x10000000000000000;&#13;
&#13;
    /// @notice `mTransfer` allows for multiple pledges to be transferred&#13;
    ///  efficiently&#13;
    /// @param idSender ID of the giver, delegate or project admin that is&#13;
    ///  transferring the funds from Pledge to Pledge. This admin must have &#13;
    ///  permissions to move the value&#13;
    /// @param pledgesAmounts An array of pledge amounts and IDs which are extrapolated&#13;
    ///  using the D64 bitmask&#13;
    /// @param idReceiver Destination of the value, can be a giver sending&#13;
    ///  to a giver or a delegate or a delegate to another delegate or a&#13;
    ///  project to pre-commit it to that project&#13;
    function mTransfer(&#13;
        uint64 idSender,&#13;
        uint[] pledgesAmounts,&#13;
        uint64 idReceiver&#13;
    ) {&#13;
        for (uint i = 0; i &lt; pledgesAmounts.length; i++ ) {&#13;
            uint64 idPledge = uint64( pledgesAmounts[i] &amp; (D64-1) );&#13;
            uint amount = pledgesAmounts[i] / D64;&#13;
&#13;
            transfer(idSender, idPledge, amount, idReceiver);&#13;
        }&#13;
    }&#13;
&#13;
    /// @notice `mWithdraw` allows for multiple pledges to be&#13;
    ///  withdrawn efficiently&#13;
    /// @param pledgesAmounts An array of pledge amounts and IDs which are&#13;
    ///  extrapolated using the D64 bitmask&#13;
    function mWithdraw(uint[] pledgesAmounts) {&#13;
        for (uint i = 0; i &lt; pledgesAmounts.length; i++ ) {&#13;
            uint64 idPledge = uint64( pledgesAmounts[i] &amp; (D64-1) );&#13;
            uint amount = pledgesAmounts[i] / D64;&#13;
&#13;
            withdraw(idPledge, amount);&#13;
        }&#13;
    }&#13;
&#13;
    /// @notice `mConfirmPayment` allows for multiple pledges to be confirmed&#13;
    ///  efficiently&#13;
    /// @param pledgesAmounts An array of pledge amounts and IDs which are extrapolated&#13;
    ///  using the D64 bitmask&#13;
    function mConfirmPayment(uint[] pledgesAmounts) {&#13;
        for (uint i = 0; i &lt; pledgesAmounts.length; i++ ) {&#13;
            uint64 idPledge = uint64( pledgesAmounts[i] &amp; (D64-1) );&#13;
            uint amount = pledgesAmounts[i] / D64;&#13;
&#13;
            confirmPayment(idPledge, amount);&#13;
        }&#13;
    }&#13;
&#13;
    /// @notice `mCancelPayment` allows for multiple pledges to be canceled&#13;
    ///  efficiently&#13;
    /// @param pledgesAmounts An array of pledge amounts and IDs which are extrapolated&#13;
    ///  using the D64 bitmask&#13;
    function mCancelPayment(uint[] pledgesAmounts) {&#13;
        for (uint i = 0; i &lt; pledgesAmounts.length; i++ ) {&#13;
            uint64 idPledge = uint64( pledgesAmounts[i] &amp; (D64-1) );&#13;
            uint amount = pledgesAmounts[i] / D64;&#13;
&#13;
            cancelPayment(idPledge, amount);&#13;
        }&#13;
    }&#13;
&#13;
    /// @notice `mNormalizePledge` allows for multiple pledges to be&#13;
    ///  normalized efficiently&#13;
    /// @param pledges An array of pledge IDs&#13;
    function mNormalizePledge(uint64[] pledges) {&#13;
        for (uint i = 0; i &lt; pledges.length; i++ ) {&#13;
            normalizePledge( pledges[i] );&#13;
        }&#13;
    }&#13;
&#13;
////////&#13;
// Private methods&#13;
///////&#13;
&#13;
    /// @notice `transferOwnershipToProject` allows for the transfer of&#13;
    ///  ownership to the project, but it can also be called by a project&#13;
    ///  to un-delegate everyone by setting one's own id for the idReceiver&#13;
    /// @param idPledge Id of the pledge to be transfered.&#13;
    /// @param amount Quantity of value that's being transfered&#13;
    /// @param idReceiver The new owner of the project (or self to un-delegate)&#13;
    function transferOwnershipToProject(&#13;
        uint64 idPledge,&#13;
        uint amount,&#13;
        uint64 idReceiver&#13;
    ) internal {&#13;
        Pledge storage p = findPledge(idPledge);&#13;
&#13;
        // Ensure that the pledge is not already at max pledge depth&#13;
        // and the project has not been canceled&#13;
        require(getPledgeLevel(p) &lt; MAX_INTERPROJECT_LEVEL);&#13;
        require(!isProjectCanceled(idReceiver));&#13;
&#13;
        uint64 oldPledge = findOrCreatePledge(&#13;
            p.owner,&#13;
            p.delegationChain,&#13;
            0,&#13;
            0,&#13;
            p.oldPledge,&#13;
            PledgeState.Pledged&#13;
        );&#13;
        uint64 toPledge = findOrCreatePledge(&#13;
            idReceiver,                     // Set the new owner&#13;
            new uint64[](0),                // clear the delegation chain&#13;
            0,&#13;
            0,&#13;
            oldPledge,&#13;
            PledgeState.Pledged&#13;
        );&#13;
        doTransfer(idPledge, toPledge, amount);&#13;
    }   &#13;
&#13;
&#13;
    /// @notice `transferOwnershipToGiver` allows for the transfer of&#13;
    ///  value back to the Giver, value is placed in a pledged state&#13;
    ///  without being attached to a project, delegation chain, or time line.&#13;
    /// @param idPledge Id of the pledge to be transfered.&#13;
    /// @param amount Quantity of value that's being transfered&#13;
    /// @param idReceiver The new owner of the pledge&#13;
    function transferOwnershipToGiver(&#13;
        uint64 idPledge,&#13;
        uint amount,&#13;
        uint64 idReceiver&#13;
    ) internal {&#13;
        uint64 toPledge = findOrCreatePledge(&#13;
            idReceiver,&#13;
            new uint64[](0),&#13;
            0,&#13;
            0,&#13;
            0,&#13;
            PledgeState.Pledged&#13;
        );&#13;
        doTransfer(idPledge, toPledge, amount);&#13;
    }&#13;
&#13;
    /// @notice `appendDelegate` allows for a delegate to be added onto the&#13;
    ///  end of the delegate chain for a given Pledge.&#13;
    /// @param idPledge Id of the pledge thats delegate chain will be modified.&#13;
    /// @param amount Quantity of value that's being chained.&#13;
    /// @param idReceiver The delegate to be added at the end of the chain&#13;
    function appendDelegate(&#13;
        uint64 idPledge,&#13;
        uint amount,&#13;
        uint64 idReceiver&#13;
    ) internal {&#13;
        Pledge storage p = findPledge(idPledge);&#13;
&#13;
        require(p.delegationChain.length &lt; MAX_DELEGATES);&#13;
        uint64[] memory newDelegationChain = new uint64[](&#13;
            p.delegationChain.length + 1&#13;
        );&#13;
        for (uint i = 0; i&lt;p.delegationChain.length; i++) {&#13;
            newDelegationChain[i] = p.delegationChain[i];&#13;
        }&#13;
&#13;
        // Make the last item in the array the idReceiver&#13;
        newDelegationChain[p.delegationChain.length] = idReceiver;&#13;
&#13;
        uint64 toPledge = findOrCreatePledge(&#13;
            p.owner,&#13;
            newDelegationChain,&#13;
            0,&#13;
            0,&#13;
            p.oldPledge,&#13;
            PledgeState.Pledged&#13;
        );&#13;
        doTransfer(idPledge, toPledge, amount);&#13;
    }&#13;
&#13;
    /// @notice `appendDelegate` allows for a delegate to be added onto the&#13;
    ///  end of the delegate chain for a given Pledge.&#13;
    /// @param idPledge Id of the pledge thats delegate chain will be modified.&#13;
    /// @param amount Quantity of value that's shifted from delegates.&#13;
    /// @param q Number (or depth) to remove as delegates&#13;
    function undelegate(&#13;
        uint64 idPledge,&#13;
        uint amount,&#13;
        uint q&#13;
    ) internal returns (uint64){&#13;
        Pledge storage p = findPledge(idPledge);&#13;
        uint64[] memory newDelegationChain = new uint64[](&#13;
            p.delegationChain.length - q&#13;
        );&#13;
        for (uint i=0; i&lt;p.delegationChain.length - q; i++) {&#13;
            newDelegationChain[i] = p.delegationChain[i];&#13;
        }&#13;
        uint64 toPledge = findOrCreatePledge(&#13;
            p.owner,&#13;
            newDelegationChain,&#13;
            0,&#13;
            0,&#13;
            p.oldPledge,&#13;
            PledgeState.Pledged&#13;
        );&#13;
        doTransfer(idPledge, toPledge, amount);&#13;
&#13;
        return toPledge;&#13;
    }&#13;
&#13;
    /// @notice `proposeAssignProject` proposes the assignment of a pledge&#13;
    ///  to a specific project.&#13;
    /// @dev This function should potentially be named more specifically.&#13;
    /// @param idPledge Id of the pledge that will be assigned.&#13;
    /// @param amount Quantity of value this pledge leader would be assigned.&#13;
    /// @param idReceiver The project this pledge will potentially &#13;
    ///  be assigned to.&#13;
    function proposeAssignProject(&#13;
        uint64 idPledge,&#13;
        uint amount,&#13;
        uint64 idReceiver&#13;
    ) internal {&#13;
        Pledge storage p = findPledge(idPledge);&#13;
&#13;
        require(getPledgeLevel(p) &lt; MAX_INTERPROJECT_LEVEL);&#13;
        require(!isProjectCanceled(idReceiver));&#13;
&#13;
        uint64 toPledge = findOrCreatePledge(&#13;
            p.owner,&#13;
            p.delegationChain,&#13;
            idReceiver,&#13;
            uint64(getTime() + maxCommitTime(p)),&#13;
            p.oldPledge,&#13;
            PledgeState.Pledged&#13;
        );&#13;
        doTransfer(idPledge, toPledge, amount);&#13;
    }&#13;
&#13;
    /// @notice `doTransfer` is designed to allow for pledge amounts to be &#13;
    ///  shifted around internally.&#13;
    /// @param from This is the Id from which value will be transfered.&#13;
    /// @param to This is the Id that value will be transfered to.&#13;
    /// @param _amount The amount of value that will be transfered.&#13;
    function doTransfer(uint64 from, uint64 to, uint _amount) internal {&#13;
        uint amount = callPlugins(true, from, to, _amount);&#13;
        if (from == to) { &#13;
            return;&#13;
        }&#13;
        if (amount == 0) {&#13;
            return;&#13;
        }&#13;
        Pledge storage nFrom = findPledge(from);&#13;
        Pledge storage nTo = findPledge(to);&#13;
        require(nFrom.amount &gt;= amount);&#13;
        nFrom.amount -= amount;&#13;
        nTo.amount += amount;&#13;
&#13;
        Transfer(from, to, amount);&#13;
        callPlugins(false, from, to, amount);&#13;
    }&#13;
&#13;
    /// @notice `normalizePledge` only affects pledges with the Pledged PledgeState&#13;
    /// and does 2 things:&#13;
    ///   #1: Checks if the pledge should be committed. This means that&#13;
    ///       if the pledge has an intendedProject and it is past the&#13;
    ///       commitTime, it changes the owner to be the proposed project&#13;
    ///       (The UI will have to read the commit time and manually do what&#13;
    ///       this function does to the pledge for the end user&#13;
    ///       at the expiration of the commitTime)&#13;
    ///&#13;
    ///   #2: Checks to make sure that if there has been a cancellation in the&#13;
    ///       chain of projects, the pledge's owner has been changed&#13;
    ///       appropriately.&#13;
    ///&#13;
    /// This function can be called by anybody at anytime on any pledge.&#13;
    /// In general it can be called to force the calls of the affected &#13;
    /// plugins, which also need to be predicted by the UI&#13;
    /// @param idPledge This is the id of the pledge that will be normalized&#13;
    function normalizePledge(uint64 idPledge) returns(uint64) {&#13;
&#13;
        Pledge storage p = findPledge(idPledge);&#13;
&#13;
        // Check to make sure this pledge hasn't already been used &#13;
        // or is in the process of being used&#13;
        if (p.pledgeState != PledgeState.Pledged) {&#13;
            return idPledge;&#13;
        }&#13;
&#13;
        // First send to a project if it's proposed and committed&#13;
        if ((p.intendedProject &gt; 0) &amp;&amp; ( getTime() &gt; p.commitTime)) {&#13;
            uint64 oldPledge = findOrCreatePledge(&#13;
                p.owner,&#13;
                p.delegationChain,&#13;
                0,&#13;
                0,&#13;
                p.oldPledge,&#13;
                PledgeState.Pledged&#13;
            );&#13;
            uint64 toPledge = findOrCreatePledge(&#13;
                p.intendedProject,&#13;
                new uint64[](0),&#13;
                0,&#13;
                0,&#13;
                oldPledge,&#13;
                PledgeState.Pledged&#13;
            );&#13;
            doTransfer(idPledge, toPledge, p.amount);&#13;
            idPledge = toPledge;&#13;
            p = findPledge(idPledge);&#13;
        }&#13;
&#13;
        toPledge = getOldestPledgeNotCanceled(idPledge);&#13;
        if (toPledge != idPledge) {&#13;
            doTransfer(idPledge, toPledge, p.amount);&#13;
        }&#13;
&#13;
        return toPledge;&#13;
    }&#13;
&#13;
/////////////&#13;
// Plugins&#13;
/////////////&#13;
&#13;
    /// @notice `callPlugin` is used to trigger the general functions in the&#13;
    ///  plugin for any actions needed before and after a transfer happens.&#13;
    ///  Specifically what this does in relation to the plugin is something&#13;
    ///  that largely depends on the functions of that plugin. This function&#13;
    ///  is generally called in pairs, once before, and once after a transfer.&#13;
    /// @param before This toggle determines whether the plugin call is occurring&#13;
    ///  before or after a transfer.&#13;
    /// @param adminId This should be the Id of the *trusted* individual&#13;
    ///  who has control over this plugin.&#13;
    /// @param fromPledge This is the Id from which value is being transfered.&#13;
    /// @param toPledge This is the Id that value is being transfered to.&#13;
    /// @param context The situation that is triggering the plugin. See plugin&#13;
    ///  for a full description of contexts.&#13;
    /// @param amount The amount of value that is being transfered.&#13;
    function callPlugin(&#13;
        bool before,&#13;
        uint64 adminId,&#13;
        uint64 fromPledge,&#13;
        uint64 toPledge,&#13;
        uint64 context,&#13;
        uint amount&#13;
    ) internal returns (uint allowedAmount) {&#13;
&#13;
        uint newAmount;&#13;
        allowedAmount = amount;&#13;
        PledgeAdmin storage admin = findAdmin(adminId);&#13;
        // Checks admin has a plugin assigned and a non-zero amount is requested&#13;
        if ((address(admin.plugin) != 0) &amp;&amp; (allowedAmount &gt; 0)) {&#13;
            // There are two seperate functions called in the plugin.&#13;
            // One is called before the transfer and one after&#13;
            if (before) {&#13;
                newAmount = admin.plugin.beforeTransfer(&#13;
                    adminId,&#13;
                    fromPledge,&#13;
                    toPledge,&#13;
                    context,&#13;
                    amount&#13;
                );&#13;
                require(newAmount &lt;= allowedAmount);&#13;
                allowedAmount = newAmount;&#13;
            } else {&#13;
                admin.plugin.afterTransfer(&#13;
                    adminId,&#13;
                    fromPledge,&#13;
                    toPledge,&#13;
                    context,&#13;
                    amount&#13;
                );&#13;
            }&#13;
        }&#13;
    }&#13;
&#13;
    /// @notice `callPluginsPledge` is used to apply plugin calls to&#13;
    ///  the delegate chain and the intended project if there is one.&#13;
    ///  It does so in either a transferring or receiving context based&#13;
    ///  on the `idPledge` and  `fromPledge` parameters.&#13;
    /// @param before This toggle determines whether the plugin call is occuring&#13;
    ///  before or after a transfer.&#13;
    /// @param idPledge This is the Id of the pledge on which this plugin&#13;
    ///  is being called.&#13;
    /// @param fromPledge This is the Id from which value is being transfered.&#13;
    /// @param toPledge This is the Id that value is being transfered to.&#13;
    /// @param amount The amount of value that is being transfered.&#13;
    function callPluginsPledge(&#13;
        bool before,&#13;
        uint64 idPledge,&#13;
        uint64 fromPledge,&#13;
        uint64 toPledge,&#13;
        uint amount&#13;
    ) internal returns (uint allowedAmount) {&#13;
        // Determine if callPlugin is being applied in a receiving&#13;
        // or transferring context&#13;
        uint64 offset = idPledge == fromPledge ? 0 : 256;&#13;
        allowedAmount = amount;&#13;
        Pledge storage p = findPledge(idPledge);&#13;
&#13;
        // Always call the plugin on the owner&#13;
        allowedAmount = callPlugin(&#13;
            before,&#13;
            p.owner,&#13;
            fromPledge,&#13;
            toPledge,&#13;
            offset,&#13;
            allowedAmount&#13;
        );&#13;
&#13;
        // Apply call plugin to all delegates&#13;
        for (uint64 i=0; i&lt;p.delegationChain.length; i++) {&#13;
            allowedAmount = callPlugin(&#13;
                before,&#13;
                p.delegationChain[i],&#13;
                fromPledge,&#13;
                toPledge,&#13;
                offset + i+1,&#13;
                allowedAmount&#13;
            );&#13;
        }&#13;
&#13;
        // If there is an intended project also call the plugin in&#13;
        // either a transferring or receiving context based on offset&#13;
        // on the intended project&#13;
        if (p.intendedProject &gt; 0) {&#13;
            allowedAmount = callPlugin(&#13;
                before,&#13;
                p.intendedProject,&#13;
                fromPledge,&#13;
                toPledge,&#13;
                offset + 255,&#13;
                allowedAmount&#13;
            );&#13;
        }&#13;
    }&#13;
&#13;
&#13;
    /// @notice `callPlugins` calls `callPluginsPledge` once for the transfer&#13;
    ///  context and once for the receiving context. The aggregated &#13;
    ///  allowed amount is then returned.&#13;
    /// @param before This toggle determines whether the plugin call is occurring&#13;
    ///  before or after a transfer.&#13;
    /// @param fromPledge This is the Id from which value is being transferred.&#13;
    /// @param toPledge This is the Id that value is being transferred to.&#13;
    /// @param amount The amount of value that is being transferred.&#13;
    function callPlugins(&#13;
        bool before,&#13;
        uint64 fromPledge,&#13;
        uint64 toPledge,&#13;
        uint amount&#13;
    ) internal returns (uint allowedAmount) {&#13;
        allowedAmount = amount;&#13;
&#13;
        // Call the pledges plugins in the transfer context&#13;
        allowedAmount = callPluginsPledge(&#13;
            before,&#13;
            fromPledge,&#13;
            fromPledge,&#13;
            toPledge,&#13;
            allowedAmount&#13;
        );&#13;
&#13;
        // Call the pledges plugins in the receive context&#13;
        allowedAmount = callPluginsPledge(&#13;
            before,&#13;
            toPledge,&#13;
            fromPledge,&#13;
            toPledge,&#13;
            allowedAmount&#13;
        );&#13;
    }&#13;
&#13;
/////////////&#13;
// Test functions&#13;
/////////////&#13;
&#13;
    /// @notice Basic helper function to return the current time&#13;
    function getTime() internal returns (uint) {&#13;
        return now;&#13;
    }&#13;
&#13;
    // Event Delcerations&#13;
    event Transfer(uint64 indexed from, uint64 indexed to, uint amount);&#13;
    event CancelProject(uint64 indexed idProject);&#13;
&#13;
}&#13;
&#13;
//File: node_modules/minimetoken/contracts/Controlled.sol&#13;
pragma solidity ^0.4.18;&#13;
&#13;
contract Controlled {&#13;
    /// @notice The address of the controller is the only address that can call&#13;
    ///  a function with this modifier&#13;
    modifier onlyController { require(msg.sender == controller); _; }&#13;
&#13;
    address public controller;&#13;
&#13;
    function Controlled() public { controller = msg.sender;}&#13;
&#13;
    /// @notice Changes the controller of the contract&#13;
    /// @param _newController The new controller of the contract&#13;
    function changeController(address _newController) public onlyController {&#13;
        controller = _newController;&#13;
    }&#13;
}&#13;
&#13;
//File: node_modules/minimetoken/contracts/TokenController.sol&#13;
pragma solidity ^0.4.18;&#13;
&#13;
/// @dev The token controller contract must implement these functions&#13;
contract TokenController {&#13;
    /// @notice Called when `_owner` sends ether to the MiniMe Token contract&#13;
    /// @param _owner The address that sent the ether to create tokens&#13;
    /// @return True if the ether is accepted, false if it throws&#13;
    function proxyPayment(address _owner) public payable returns(bool);&#13;
&#13;
    /// @notice Notifies the controller about a token transfer allowing the&#13;
    ///  controller to react if desired&#13;
    /// @param _from The origin of the transfer&#13;
    /// @param _to The destination of the transfer&#13;
    /// @param _amount The amount of the transfer&#13;
    /// @return False if the controller does not authorize the transfer&#13;
    function onTransfer(address _from, address _to, uint _amount) public returns(bool);&#13;
&#13;
    /// @notice Notifies the controller about an approval allowing the&#13;
    ///  controller to react if desired&#13;
    /// @param _owner The address that calls `approve()`&#13;
    /// @param _spender The spender in the `approve()` call&#13;
    /// @param _amount The amount in the `approve()` call&#13;
    /// @return False if the controller does not authorize the approval&#13;
    function onApprove(address _owner, address _spender, uint _amount) public&#13;
        returns(bool);&#13;
}&#13;
&#13;
//File: node_modules/minimetoken/contracts/MiniMeToken.sol&#13;
pragma solidity ^0.4.18;&#13;
&#13;
/*&#13;
    Copyright 2016, Jordi Baylina&#13;
&#13;
    This program is free software: you can redistribute it and/or modify&#13;
    it under the terms of the GNU General Public License as published by&#13;
    the Free Software Foundation, either version 3 of the License, or&#13;
    (at your option) any later version.&#13;
&#13;
    This program is distributed in the hope that it will be useful,&#13;
    but WITHOUT ANY WARRANTY; without even the implied warranty of&#13;
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&#13;
    GNU General Public License for more details.&#13;
&#13;
    You should have received a copy of the GNU General Public License&#13;
    along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.&#13;
 */&#13;
&#13;
/// @title MiniMeToken Contract&#13;
/// @author Jordi Baylina&#13;
/// @dev This token contract's goal is to make it easy for anyone to clone this&#13;
///  token using the token distribution at a given block, this will allow DAO's&#13;
///  and DApps to upgrade their features in a decentralized manner without&#13;
///  affecting the original token&#13;
/// @dev It is ERC20 compliant, but still needs to under go further testing.&#13;
&#13;
&#13;
&#13;
&#13;
contract ApproveAndCallFallBack {&#13;
    function receiveApproval(address from, uint256 _amount, address _token, bytes _data) public;&#13;
}&#13;
&#13;
/// @dev The actual token contract, the default controller is the msg.sender&#13;
///  that deploys the contract, so usually this token will be deployed by a&#13;
///  token controller contract, which Giveth will call a "Campaign"&#13;
contract MiniMeToken is Controlled {&#13;
&#13;
    string public name;                //The Token's name: e.g. DigixDAO Tokens&#13;
    uint8 public decimals;             //Number of decimals of the smallest unit&#13;
    string public symbol;              //An identifier: e.g. REP&#13;
    string public version = 'MMT_0.2'; //An arbitrary versioning scheme&#13;
&#13;
&#13;
    /// @dev `Checkpoint` is the structure that attaches a block number to a&#13;
    ///  given value, the block number attached is the one that last changed the&#13;
    ///  value&#13;
    struct  Checkpoint {&#13;
&#13;
        // `fromBlock` is the block number that the value was generated from&#13;
        uint128 fromBlock;&#13;
&#13;
        // `value` is the amount of tokens at a specific block number&#13;
        uint128 value;&#13;
    }&#13;
&#13;
    // `parentToken` is the Token address that was cloned to produce this token;&#13;
    //  it will be 0x0 for a token that was not cloned&#13;
    MiniMeToken public parentToken;&#13;
&#13;
    // `parentSnapShotBlock` is the block number from the Parent Token that was&#13;
    //  used to determine the initial distribution of the Clone Token&#13;
    uint public parentSnapShotBlock;&#13;
&#13;
    // `creationBlock` is the block number that the Clone Token was created&#13;
    uint public creationBlock;&#13;
&#13;
    // `balances` is the map that tracks the balance of each address, in this&#13;
    //  contract when the balance changes the block number that the change&#13;
    //  occurred is also included in the map&#13;
    mapping (address =&gt; Checkpoint[]) balances;&#13;
&#13;
    // `allowed` tracks any extra transfer rights as in all ERC20 tokens&#13;
    mapping (address =&gt; mapping (address =&gt; uint256)) allowed;&#13;
&#13;
    // Tracks the history of the `totalSupply` of the token&#13;
    Checkpoint[] totalSupplyHistory;&#13;
&#13;
    // Flag that determines if the token is transferable or not.&#13;
    bool public transfersEnabled;&#13;
&#13;
    // The factory used to create new clone tokens&#13;
    MiniMeTokenFactory public tokenFactory;&#13;
&#13;
////////////////&#13;
// Constructor&#13;
////////////////&#13;
&#13;
    /// @notice Constructor to create a MiniMeToken&#13;
    /// @param _tokenFactory The address of the MiniMeTokenFactory contract that&#13;
    ///  will create the Clone token contracts, the token factory needs to be&#13;
    ///  deployed first&#13;
    /// @param _parentToken Address of the parent token, set to 0x0 if it is a&#13;
    ///  new token&#13;
    /// @param _parentSnapShotBlock Block of the parent token that will&#13;
    ///  determine the initial distribution of the clone token, set to 0 if it&#13;
    ///  is a new token&#13;
    /// @param _tokenName Name of the new token&#13;
    /// @param _decimalUnits Number of decimals of the new token&#13;
    /// @param _tokenSymbol Token Symbol for the new token&#13;
    /// @param _transfersEnabled If true, tokens will be able to be transferred&#13;
    function MiniMeToken(&#13;
        address _tokenFactory,&#13;
        address _parentToken,&#13;
        uint _parentSnapShotBlock,&#13;
        string _tokenName,&#13;
        uint8 _decimalUnits,&#13;
        string _tokenSymbol,&#13;
        bool _transfersEnabled&#13;
    ) public {&#13;
        tokenFactory = MiniMeTokenFactory(_tokenFactory);&#13;
        name = _tokenName;                                 // Set the name&#13;
        decimals = _decimalUnits;                          // Set the decimals&#13;
        symbol = _tokenSymbol;                             // Set the symbol&#13;
        parentToken = MiniMeToken(_parentToken);&#13;
        parentSnapShotBlock = _parentSnapShotBlock;&#13;
        transfersEnabled = _transfersEnabled;&#13;
        creationBlock = block.number;&#13;
    }&#13;
&#13;
&#13;
///////////////////&#13;
// ERC20 Methods&#13;
///////////////////&#13;
&#13;
    /// @notice Send `_amount` tokens to `_to` from `msg.sender`&#13;
    /// @param _to The address of the recipient&#13;
    /// @param _amount The amount of tokens to be transferred&#13;
    /// @return Whether the transfer was successful or not&#13;
    function transfer(address _to, uint256 _amount) public returns (bool success) {&#13;
        require(transfersEnabled);&#13;
        return doTransfer(msg.sender, _to, _amount);&#13;
    }&#13;
&#13;
    /// @notice Send `_amount` tokens to `_to` from `_from` on the condition it&#13;
    ///  is approved by `_from`&#13;
    /// @param _from The address holding the tokens being transferred&#13;
    /// @param _to The address of the recipient&#13;
    /// @param _amount The amount of tokens to be transferred&#13;
    /// @return True if the transfer was successful&#13;
    function transferFrom(address _from, address _to, uint256 _amount&#13;
    ) public returns (bool success) {&#13;
&#13;
        // The controller of this contract can move tokens around at will,&#13;
        //  this is important to recognize! Confirm that you trust the&#13;
        //  controller of this contract, which in most situations should be&#13;
        //  another open source smart contract or 0x0&#13;
        if (msg.sender != controller) {&#13;
            require(transfersEnabled);&#13;
&#13;
            // The standard ERC 20 transferFrom functionality&#13;
            if (allowed[_from][msg.sender] &lt; _amount) return false;&#13;
            allowed[_from][msg.sender] -= _amount;&#13;
        }&#13;
        return doTransfer(_from, _to, _amount);&#13;
    }&#13;
&#13;
    /// @dev This is the actual transfer function in the token contract, it can&#13;
    ///  only be called by other functions in this contract.&#13;
    /// @param _from The address holding the tokens being transferred&#13;
    /// @param _to The address of the recipient&#13;
    /// @param _amount The amount of tokens to be transferred&#13;
    /// @return True if the transfer was successful&#13;
    function doTransfer(address _from, address _to, uint _amount&#13;
    ) internal returns(bool) {&#13;
&#13;
           if (_amount == 0) {&#13;
               return true;&#13;
           }&#13;
&#13;
           require(parentSnapShotBlock &lt; block.number);&#13;
&#13;
           // Do not allow transfer to 0x0 or the token contract itself&#13;
           require((_to != 0) &amp;&amp; (_to != address(this)));&#13;
&#13;
           // If the amount being transfered is more than the balance of the&#13;
           //  account the transfer returns false&#13;
           var previousBalanceFrom = balanceOfAt(_from, block.number);&#13;
           if (previousBalanceFrom &lt; _amount) {&#13;
               return false;&#13;
           }&#13;
&#13;
           // Alerts the token controller of the transfer&#13;
           if (isContract(controller)) {&#13;
               require(TokenController(controller).onTransfer(_from, _to, _amount));&#13;
           }&#13;
&#13;
           // First update the balance array with the new value for the address&#13;
           //  sending the tokens&#13;
           updateValueAtNow(balances[_from], previousBalanceFrom - _amount);&#13;
&#13;
           // Then update the balance array with the new value for the address&#13;
           //  receiving the tokens&#13;
           var previousBalanceTo = balanceOfAt(_to, block.number);&#13;
           require(previousBalanceTo + _amount &gt;= previousBalanceTo); // Check for overflow&#13;
           updateValueAtNow(balances[_to], previousBalanceTo + _amount);&#13;
&#13;
           // An event to make the transfer easy to find on the blockchain&#13;
           Transfer(_from, _to, _amount);&#13;
&#13;
           return true;&#13;
    }&#13;
&#13;
    /// @param _owner The address that's balance is being requested&#13;
    /// @return The balance of `_owner` at the current block&#13;
    function balanceOf(address _owner) public constant returns (uint256 balance) {&#13;
        return balanceOfAt(_owner, block.number);&#13;
    }&#13;
&#13;
    /// @notice `msg.sender` approves `_spender` to spend `_amount` tokens on&#13;
    ///  its behalf. This is a modified version of the ERC20 approve function&#13;
    ///  to be a little bit safer&#13;
    /// @param _spender The address of the account able to transfer the tokens&#13;
    /// @param _amount The amount of tokens to be approved for transfer&#13;
    /// @return True if the approval was successful&#13;
    function approve(address _spender, uint256 _amount) public returns (bool success) {&#13;
        require(transfersEnabled);&#13;
&#13;
        // To change the approve amount you first have to reduce the addresses`&#13;
        //  allowance to zero by calling `approve(_spender,0)` if it is not&#13;
        //  already 0 to mitigate the race condition described here:&#13;
        //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729&#13;
        require((_amount == 0) || (allowed[msg.sender][_spender] == 0));&#13;
&#13;
        // Alerts the token controller of the approve function call&#13;
        if (isContract(controller)) {&#13;
            require(TokenController(controller).onApprove(msg.sender, _spender, _amount));&#13;
        }&#13;
&#13;
        allowed[msg.sender][_spender] = _amount;&#13;
        Approval(msg.sender, _spender, _amount);&#13;
        return true;&#13;
    }&#13;
&#13;
    /// @dev This function makes it easy to read the `allowed[]` map&#13;
    /// @param _owner The address of the account that owns the token&#13;
    /// @param _spender The address of the account able to transfer the tokens&#13;
    /// @return Amount of remaining tokens of _owner that _spender is allowed&#13;
    ///  to spend&#13;
    function allowance(address _owner, address _spender&#13;
    ) public constant returns (uint256 remaining) {&#13;
        return allowed[_owner][_spender];&#13;
    }&#13;
&#13;
    /// @notice `msg.sender` approves `_spender` to send `_amount` tokens on&#13;
    ///  its behalf, and then a function is triggered in the contract that is&#13;
    ///  being approved, `_spender`. This allows users to use their tokens to&#13;
    ///  interact with contracts in one function call instead of two&#13;
    /// @param _spender The address of the contract able to transfer the tokens&#13;
    /// @param _amount The amount of tokens to be approved for transfer&#13;
    /// @return True if the function call was successful&#13;
    function approveAndCall(address _spender, uint256 _amount, bytes _extraData&#13;
    ) public returns (bool success) {&#13;
        require(approve(_spender, _amount));&#13;
&#13;
        ApproveAndCallFallBack(_spender).receiveApproval(&#13;
            msg.sender,&#13;
            _amount,&#13;
            this,&#13;
            _extraData&#13;
        );&#13;
&#13;
        return true;&#13;
    }&#13;
&#13;
    /// @dev This function makes it easy to get the total number of tokens&#13;
    /// @return The total number of tokens&#13;
    function totalSupply() public constant returns (uint) {&#13;
        return totalSupplyAt(block.number);&#13;
    }&#13;
&#13;
&#13;
////////////////&#13;
// Query balance and totalSupply in History&#13;
////////////////&#13;
&#13;
    /// @dev Queries the balance of `_owner` at a specific `_blockNumber`&#13;
    /// @param _owner The address from which the balance will be retrieved&#13;
    /// @param _blockNumber The block number when the balance is queried&#13;
    /// @return The balance at `_blockNumber`&#13;
    function balanceOfAt(address _owner, uint _blockNumber) public constant&#13;
        returns (uint) {&#13;
&#13;
        // These next few lines are used when the balance of the token is&#13;
        //  requested before a check point was ever created for this token, it&#13;
        //  requires that the `parentToken.balanceOfAt` be queried at the&#13;
        //  genesis block for that token as this contains initial balance of&#13;
        //  this token&#13;
        if ((balances[_owner].length == 0)&#13;
            || (balances[_owner][0].fromBlock &gt; _blockNumber)) {&#13;
            if (address(parentToken) != 0) {&#13;
                return parentToken.balanceOfAt(_owner, min(_blockNumber, parentSnapShotBlock));&#13;
            } else {&#13;
                // Has no parent&#13;
                return 0;&#13;
            }&#13;
&#13;
        // This will return the expected balance during normal situations&#13;
        } else {&#13;
            return getValueAt(balances[_owner], _blockNumber);&#13;
        }&#13;
    }&#13;
&#13;
    /// @notice Total amount of tokens at a specific `_blockNumber`.&#13;
    /// @param _blockNumber The block number when the totalSupply is queried&#13;
    /// @return The total amount of tokens at `_blockNumber`&#13;
    function totalSupplyAt(uint _blockNumber) public constant returns(uint) {&#13;
&#13;
        // These next few lines are used when the totalSupply of the token is&#13;
        //  requested before a check point was ever created for this token, it&#13;
        //  requires that the `parentToken.totalSupplyAt` be queried at the&#13;
        //  genesis block for this token as that contains totalSupply of this&#13;
        //  token at this block number.&#13;
        if ((totalSupplyHistory.length == 0)&#13;
            || (totalSupplyHistory[0].fromBlock &gt; _blockNumber)) {&#13;
            if (address(parentToken) != 0) {&#13;
                return parentToken.totalSupplyAt(min(_blockNumber, parentSnapShotBlock));&#13;
            } else {&#13;
                return 0;&#13;
            }&#13;
&#13;
        // This will return the expected totalSupply during normal situations&#13;
        } else {&#13;
            return getValueAt(totalSupplyHistory, _blockNumber);&#13;
        }&#13;
    }&#13;
&#13;
////////////////&#13;
// Clone Token Method&#13;
////////////////&#13;
&#13;
    /// @notice Creates a new clone token with the initial distribution being&#13;
    ///  this token at `_snapshotBlock`&#13;
    /// @param _cloneTokenName Name of the clone token&#13;
    /// @param _cloneDecimalUnits Number of decimals of the smallest unit&#13;
    /// @param _cloneTokenSymbol Symbol of the clone token&#13;
    /// @param _snapshotBlock Block when the distribution of the parent token is&#13;
    ///  copied to set the initial distribution of the new clone token;&#13;
    ///  if the block is zero than the actual block, the current block is used&#13;
    /// @param _transfersEnabled True if transfers are allowed in the clone&#13;
    /// @return The address of the new MiniMeToken Contract&#13;
    function createCloneToken(&#13;
        string _cloneTokenName,&#13;
        uint8 _cloneDecimalUnits,&#13;
        string _cloneTokenSymbol,&#13;
        uint _snapshotBlock,&#13;
        bool _transfersEnabled&#13;
        ) public returns(address) {&#13;
        if (_snapshotBlock == 0) _snapshotBlock = block.number;&#13;
        MiniMeToken cloneToken = tokenFactory.createCloneToken(&#13;
            this,&#13;
            _snapshotBlock,&#13;
            _cloneTokenName,&#13;
            _cloneDecimalUnits,&#13;
            _cloneTokenSymbol,&#13;
            _transfersEnabled&#13;
            );&#13;
&#13;
        cloneToken.changeController(msg.sender);&#13;
&#13;
        // An event to make the token easy to find on the blockchain&#13;
        NewCloneToken(address(cloneToken), _snapshotBlock);&#13;
        return address(cloneToken);&#13;
    }&#13;
&#13;
////////////////&#13;
// Generate and destroy tokens&#13;
////////////////&#13;
&#13;
    /// @notice Generates `_amount` tokens that are assigned to `_owner`&#13;
    /// @param _owner The address that will be assigned the new tokens&#13;
    /// @param _amount The quantity of tokens generated&#13;
    /// @return True if the tokens are generated correctly&#13;
    function generateTokens(address _owner, uint _amount&#13;
    ) public onlyController returns (bool) {&#13;
        uint curTotalSupply = totalSupply();&#13;
        require(curTotalSupply + _amount &gt;= curTotalSupply); // Check for overflow&#13;
        uint previousBalanceTo = balanceOf(_owner);&#13;
        require(previousBalanceTo + _amount &gt;= previousBalanceTo); // Check for overflow&#13;
        updateValueAtNow(totalSupplyHistory, curTotalSupply + _amount);&#13;
        updateValueAtNow(balances[_owner], previousBalanceTo + _amount);&#13;
        Transfer(0, _owner, _amount);&#13;
        return true;&#13;
    }&#13;
&#13;
&#13;
    /// @notice Burns `_amount` tokens from `_owner`&#13;
    /// @param _owner The address that will lose the tokens&#13;
    /// @param _amount The quantity of tokens to burn&#13;
    /// @return True if the tokens are burned correctly&#13;
    function destroyTokens(address _owner, uint _amount&#13;
    ) onlyController public returns (bool) {&#13;
        uint curTotalSupply = totalSupply();&#13;
        require(curTotalSupply &gt;= _amount);&#13;
        uint previousBalanceFrom = balanceOf(_owner);&#13;
        require(previousBalanceFrom &gt;= _amount);&#13;
        updateValueAtNow(totalSupplyHistory, curTotalSupply - _amount);&#13;
        updateValueAtNow(balances[_owner], previousBalanceFrom - _amount);&#13;
        Transfer(_owner, 0, _amount);&#13;
        return true;&#13;
    }&#13;
&#13;
////////////////&#13;
// Enable tokens transfers&#13;
////////////////&#13;
&#13;
&#13;
    /// @notice Enables token holders to transfer their tokens freely if true&#13;
    /// @param _transfersEnabled True if transfers are allowed in the clone&#13;
    function enableTransfers(bool _transfersEnabled) public onlyController {&#13;
        transfersEnabled = _transfersEnabled;&#13;
    }&#13;
&#13;
////////////////&#13;
// Internal helper functions to query and set a value in a snapshot array&#13;
////////////////&#13;
&#13;
    /// @dev `getValueAt` retrieves the number of tokens at a given block number&#13;
    /// @param checkpoints The history of values being queried&#13;
    /// @param _block The block number to retrieve the value at&#13;
    /// @return The number of tokens being queried&#13;
    function getValueAt(Checkpoint[] storage checkpoints, uint _block&#13;
    ) constant internal returns (uint) {&#13;
        if (checkpoints.length == 0) return 0;&#13;
&#13;
        // Shortcut for the actual value&#13;
        if (_block &gt;= checkpoints[checkpoints.length-1].fromBlock)&#13;
            return checkpoints[checkpoints.length-1].value;&#13;
        if (_block &lt; checkpoints[0].fromBlock) return 0;&#13;
&#13;
        // Binary search of the value in the array&#13;
        uint min = 0;&#13;
        uint max = checkpoints.length-1;&#13;
        while (max &gt; min) {&#13;
            uint mid = (max + min + 1)/ 2;&#13;
            if (checkpoints[mid].fromBlock&lt;=_block) {&#13;
                min = mid;&#13;
            } else {&#13;
                max = mid-1;&#13;
            }&#13;
        }&#13;
        return checkpoints[min].value;&#13;
    }&#13;
&#13;
    /// @dev `updateValueAtNow` used to update the `balances` map and the&#13;
    ///  `totalSupplyHistory`&#13;
    /// @param checkpoints The history of data being updated&#13;
    /// @param _value The new number of tokens&#13;
    function updateValueAtNow(Checkpoint[] storage checkpoints, uint _value&#13;
    ) internal  {&#13;
        if ((checkpoints.length == 0)&#13;
        || (checkpoints[checkpoints.length -1].fromBlock &lt; block.number)) {&#13;
               Checkpoint storage newCheckPoint = checkpoints[ checkpoints.length++ ];&#13;
               newCheckPoint.fromBlock =  uint128(block.number);&#13;
               newCheckPoint.value = uint128(_value);&#13;
           } else {&#13;
               Checkpoint storage oldCheckPoint = checkpoints[checkpoints.length-1];&#13;
               oldCheckPoint.value = uint128(_value);&#13;
           }&#13;
    }&#13;
&#13;
    /// @dev Internal function to determine if an address is a contract&#13;
    /// @param _addr The address being queried&#13;
    /// @return True if `_addr` is a contract&#13;
    function isContract(address _addr) constant internal returns(bool) {&#13;
        uint size;&#13;
        if (_addr == 0) return false;&#13;
        assembly {&#13;
            size := extcodesize(_addr)&#13;
        }&#13;
        return size&gt;0;&#13;
    }&#13;
&#13;
    /// @dev Helper function to return a min betwen the two uints&#13;
    function min(uint a, uint b) pure internal returns (uint) {&#13;
        return a &lt; b ? a : b;&#13;
    }&#13;
&#13;
    /// @notice The fallback function: If the contract's controller has not been&#13;
    ///  set to 0, then the `proxyPayment` method is called which relays the&#13;
    ///  ether and creates tokens as described in the token controller contract&#13;
    function () public payable {&#13;
        require(isContract(controller));&#13;
        require(TokenController(controller).proxyPayment.value(msg.value)(msg.sender));&#13;
    }&#13;
&#13;
//////////&#13;
// Safety Methods&#13;
//////////&#13;
&#13;
    /// @notice This method can be used by the controller to extract mistakenly&#13;
    ///  sent tokens to this contract.&#13;
    /// @param _token The address of the token contract that you want to recover&#13;
    ///  set to 0 in case you want to extract ether.&#13;
    function claimTokens(address _token) public onlyController {&#13;
        if (_token == 0x0) {&#13;
            controller.transfer(this.balance);&#13;
            return;&#13;
        }&#13;
&#13;
        MiniMeToken token = MiniMeToken(_token);&#13;
        uint balance = token.balanceOf(this);&#13;
        token.transfer(controller, balance);&#13;
        ClaimedTokens(_token, controller, balance);&#13;
    }&#13;
&#13;
////////////////&#13;
// Events&#13;
////////////////&#13;
    event ClaimedTokens(address indexed _token, address indexed _controller, uint _amount);&#13;
    event Transfer(address indexed _from, address indexed _to, uint256 _amount);&#13;
    event NewCloneToken(address indexed _cloneToken, uint _snapshotBlock);&#13;
    event Approval(&#13;
        address indexed _owner,&#13;
        address indexed _spender,&#13;
        uint256 _amount&#13;
        );&#13;
&#13;
}&#13;
&#13;
&#13;
////////////////&#13;
// MiniMeTokenFactory&#13;
////////////////&#13;
&#13;
/// @dev This contract is used to generate clone contracts from a contract.&#13;
///  In solidity this is the way to create a contract from a contract of the&#13;
///  same class&#13;
contract MiniMeTokenFactory {&#13;
&#13;
    /// @notice Update the DApp by creating a new token with new functionalities&#13;
    ///  the msg.sender becomes the controller of this clone token&#13;
    /// @param _parentToken Address of the token being cloned&#13;
    /// @param _snapshotBlock Block of the parent token that will&#13;
    ///  determine the initial distribution of the clone token&#13;
    /// @param _tokenName Name of the new token&#13;
    /// @param _decimalUnits Number of decimals of the new token&#13;
    /// @param _tokenSymbol Token Symbol for the new token&#13;
    /// @param _transfersEnabled If true, tokens will be able to be transferred&#13;
    /// @return The address of the new token contract&#13;
    function createCloneToken(&#13;
        address _parentToken,&#13;
        uint _snapshotBlock,&#13;
        string _tokenName,&#13;
        uint8 _decimalUnits,&#13;
        string _tokenSymbol,&#13;
        bool _transfersEnabled&#13;
    ) public returns (MiniMeToken) {&#13;
        MiniMeToken newToken = new MiniMeToken(&#13;
            this,&#13;
            _parentToken,&#13;
            _snapshotBlock,&#13;
            _tokenName,&#13;
            _decimalUnits,&#13;
            _tokenSymbol,&#13;
            _transfersEnabled&#13;
            );&#13;
&#13;
        newToken.changeController(msg.sender);&#13;
        return newToken;&#13;
    }&#13;
}&#13;
&#13;
//File: contracts/LPPCampaign.sol&#13;
pragma solidity ^0.4.13;&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
/// @title LPPCampaign&#13;
/// @author perissology &lt;<span class="__cf_email__" data-cfemail="f8889d8a918b8b9794979f81b8888a978c979695999194d69b9795">[email protected]</span>&gt;&#13;
/// @notice The LPPCampaign contract is a plugin contract for liquidPledging,&#13;
///  extending the functionality of a liquidPledging project. This contract&#13;
///  prevents withdrawals from any pledges this contract is the owner of.&#13;
///  This contract has 2 roles. The owner and a reviewer. The owner can transfer or cancel&#13;
///  any pledges this contract owns. The reviewer can only cancel the pledges.&#13;
///  If this contract is canceled, all pledges will be rolled back to the previous owner&#13;
///  and will reject all future pledge transfers to the pledgeAdmin represented by this contract&#13;
contract LPPCampaign is Escapable, TokenController {&#13;
    uint constant FROM_OWNER = 0;&#13;
    uint constant FROM_PROPOSEDPROJECT = 255;&#13;
    uint constant TO_OWNER = 256;&#13;
    uint constant TO_PROPOSEDPROJECT = 511;&#13;
&#13;
    LiquidPledging public liquidPledging;&#13;
    MiniMeToken public token;&#13;
    bool public initPending;&#13;
    uint64 public idProject;&#13;
    address public reviewer;&#13;
    address public newReviewer;&#13;
&#13;
    event GenerateTokens(address indexed liquidPledging, address addr, uint amount);&#13;
&#13;
    function LPPCampaign(&#13;
        LiquidPledging _liquidPledging,&#13;
        string tokenName,&#13;
        string tokenSymbol,&#13;
        address _escapeHatchCaller,&#13;
        address _escapeHatchDestination&#13;
    ) Escapable(_escapeHatchCaller, _escapeHatchDestination) public&#13;
    {&#13;
      require(msg.sender != tx.origin);&#13;
      liquidPledging = _liquidPledging;&#13;
      MiniMeTokenFactory tokenFactory = new MiniMeTokenFactory();&#13;
      token = new MiniMeToken(tokenFactory, 0x0, 0, tokenName, 18, tokenSymbol, false);&#13;
      initPending = true;&#13;
    }&#13;
&#13;
    function init(&#13;
        string name,&#13;
        string url,&#13;
        uint64 parentProject,&#13;
        address _reviewer&#13;
    ) {&#13;
        require(initPending);&#13;
        idProject = liquidPledging.addProject(name, url, address(this), parentProject, 0, ILiquidPledgingPlugin(this));&#13;
        reviewer = _reviewer;&#13;
        initPending = false;&#13;
    }&#13;
&#13;
    modifier initialized() {&#13;
      require(!initPending);&#13;
      _;&#13;
    }&#13;
&#13;
    modifier onlyReviewer() {&#13;
        require(msg.sender == reviewer);&#13;
        _;&#13;
    }&#13;
&#13;
    modifier onlyOwnerOrReviewer() {&#13;
        require( msg.sender == owner || msg.sender == reviewer );&#13;
        _;&#13;
    }&#13;
&#13;
    function changeReviewer(address _newReviewer) public initialized onlyReviewer {&#13;
        newReviewer = _newReviewer;&#13;
    }&#13;
&#13;
    function acceptNewReviewer() public initialized {&#13;
        require(newReviewer == msg.sender);&#13;
        reviewer = newReviewer;&#13;
        newReviewer = 0;&#13;
    }&#13;
&#13;
    function beforeTransfer(&#13;
        uint64 pledgeAdmin,&#13;
        uint64 pledgeFrom,&#13;
        uint64 pledgeTo,&#13;
        uint64 context,&#13;
        uint amount&#13;
    ) external initialized returns (uint maxAllowed) {&#13;
        require(msg.sender == address(liquidPledging));&#13;
        var (, , , fromProposedProject , , , ) = liquidPledging.getPledge(pledgeFrom);&#13;
        var (, , , , , , toPledgeState ) = liquidPledging.getPledge(pledgeTo);&#13;
&#13;
        // campaigns can not withdraw funds&#13;
        if ( (context == TO_OWNER) &amp;&amp; (toPledgeState != LiquidPledgingBase.PledgeState.Pledged) ) return 0;&#13;
&#13;
        // If this campaign is the proposed recipient of delegated funds or funds are being directly&#13;
        // transferred to me, ensure that the campaign has not been canceled&#13;
        if ( (context == TO_PROPOSEDPROJECT)&#13;
            || ( (context == TO_OWNER) &amp;&amp; (fromProposedProject != idProject) ))&#13;
        {&#13;
            if (isCanceled()) return 0;&#13;
        }&#13;
        return amount;&#13;
    }&#13;
&#13;
    function afterTransfer(&#13;
        uint64 pledgeAdmin,&#13;
        uint64 pledgeFrom,&#13;
        uint64 pledgeTo,&#13;
        uint64 context,&#13;
        uint amount&#13;
    ) external initialized {&#13;
      require(msg.sender == address(liquidPledging));&#13;
      var (, , , , , , toPledgeState) = liquidPledging.getPledge(pledgeTo);&#13;
      var (, fromOwner, , , , , ) = liquidPledging.getPledge(pledgeFrom);&#13;
&#13;
      // only issue tokens when pledge is committed to this campaign&#13;
      if ( (context == TO_OWNER) &amp;&amp;&#13;
              (toPledgeState == LiquidPledgingBase.PledgeState.Pledged)) {&#13;
        var (, fromAddr , , , , , , ) = liquidPledging.getPledgeAdmin(fromOwner);&#13;
&#13;
        token.generateTokens(fromAddr, amount);&#13;
        GenerateTokens(liquidPledging, fromAddr, amount);&#13;
      }&#13;
    }&#13;
&#13;
    function cancelCampaign() public initialized onlyOwnerOrReviewer {&#13;
        require( !isCanceled() );&#13;
&#13;
        liquidPledging.cancelProject(idProject);&#13;
    }&#13;
&#13;
    function transfer(uint64 idPledge, uint amount, uint64 idReceiver) public initialized onlyOwner {&#13;
      require( !isCanceled() );&#13;
&#13;
      liquidPledging.transfer(idProject, idPledge, amount, idReceiver);&#13;
    }&#13;
&#13;
    function isCanceled() public constant initialized returns (bool) {&#13;
      return liquidPledging.isProjectCanceled(idProject);&#13;
    }&#13;
&#13;
    // allows the owner to send any tx, similar to a multi-sig&#13;
    // this is necessary b/c the campaign may receive dac/campaign tokens&#13;
    // if they transfer a pledge they own to another dac/campaign.&#13;
    // this allows the owner to participate in governance with the tokens&#13;
    // it holds.&#13;
    function sendTransaction(address destination, uint value, bytes data) public initialized onlyOwner {&#13;
      require(destination.call.value(value)(data));&#13;
    }&#13;
&#13;
////////////////&#13;
// TokenController&#13;
////////////////&#13;
&#13;
  /// @notice Called when `_owner` sends ether to the MiniMe Token contract&#13;
  /// @param _owner The address that sent the ether to create tokens&#13;
  /// @return True if the ether is accepted, false if it throws&#13;
  function proxyPayment(address _owner) public payable initialized returns(bool) {&#13;
    return false;&#13;
  }&#13;
&#13;
  /// @notice Notifies the controller about a token transfer allowing the&#13;
  ///  controller to react if desired&#13;
  /// @param _from The origin of the transfer&#13;
  /// @param _to The destination of the transfer&#13;
  /// @param _amount The amount of the transfer&#13;
  /// @return False if the controller does not authorize the transfer&#13;
  function onTransfer(address _from, address _to, uint _amount) public initialized returns(bool) {&#13;
    return false;&#13;
  }&#13;
&#13;
  /// @notice Notifies the controller about an approval allowing the&#13;
  ///  controller to react if desired&#13;
  /// @param _owner The address that calls `approve()`&#13;
  /// @param _spender The spender in the `approve()` call&#13;
  /// @param _amount The amount in the `approve()` call&#13;
  /// @return False if the controller does not authorize the approval&#13;
  function onApprove(address _owner, address _spender, uint _amount) public initialized returns(bool) {&#13;
    return false;&#13;
  }&#13;
}&#13;
&#13;
//File: contracts/LPPCampaignFactory.sol&#13;
pragma solidity ^0.4.13;&#13;
&#13;
&#13;
&#13;
contract LPPCampaignFactory is Escapable {&#13;
&#13;
    function LPPCampaignFactory(address _escapeHatchCaller, address _escapeHatchDestination)&#13;
        Escapable(_escapeHatchCaller, _escapeHatchDestination)&#13;
    {&#13;
    }&#13;
&#13;
    function deploy(&#13;
        LiquidPledging liquidPledging,&#13;
        string name,&#13;
        string url,&#13;
        uint64 parentProject,&#13;
        address reviewer,&#13;
        string tokenName,&#13;
        string tokenSymbol,&#13;
        address escapeHatchCaller,&#13;
        address escapeHatchDestination&#13;
  ) {&#13;
        LPPCampaign campaign = new LPPCampaign(liquidPledging, tokenName, tokenSymbol, escapeHatchCaller, escapeHatchDestination);&#13;
        campaign.init(name, url, parentProject, reviewer);&#13;
        campaign.changeOwnership(msg.sender);&#13;
    }&#13;
}