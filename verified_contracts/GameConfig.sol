pragma solidity ^0.4.18;

/// @notice define the game's configuration
/// @author rainysiu <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="a4d6c5cdcadde4c8cdd2c1d7d0c5d68ac7cbc9">[emailÂ protected]</a>&#13;
/// @dev MagicAcademy Games &#13;
contract GameConfig {&#13;
  using SafeMath for SafeMath;&#13;
  address public owner;&#13;
&#13;
  /**event**/&#13;
  event newCard(uint256 cardId,uint256 baseCoinCost,uint256 coinCostIncreaseHalf,uint256 ethCost,uint256 baseCoinProduction);&#13;
  event newBattleCard(uint256 cardId,uint256 baseCoinCost,uint256 coinCostIncreaseHalf,uint256 ethCost,uint256 attackValue,uint256 defenseValue,uint256 coinStealingCapacity);&#13;
  event newUpgradeCard(uint256 upgradecardId, uint256 coinCost, uint256 ethCost, uint256 upgradeClass, uint256 cardId, uint256 upgradeValue, uint256 increase);&#13;
  &#13;
  struct Card {&#13;
    uint256 cardId;&#13;
    uint256 baseCoinCost;&#13;
    uint256 coinCostIncreaseHalf; // Halfed to make maths slightly less (cancels a 2 out)&#13;
    uint256 ethCost;&#13;
    uint256 baseCoinProduction;&#13;
    bool unitSellable; // Rare units (from raffle) not sellable&#13;
  }&#13;
&#13;
  struct BattleCard {&#13;
    uint256 cardId;&#13;
    uint256 baseCoinCost;&#13;
    uint256 coinCostIncreaseHalf; // Halfed to make maths slightly less (cancels a 2 out)&#13;
    uint256 ethCost;&#13;
    uint256 attackValue;&#13;
    uint256 defenseValue;&#13;
    uint256 coinStealingCapacity;&#13;
    bool unitSellable; // Rare units (from raffle) not sellable&#13;
  }&#13;
  &#13;
  struct UpgradeCard {&#13;
    uint256 upgradecardId;&#13;
    uint256 coinCost;&#13;
    uint256 ethCost;&#13;
    uint256 upgradeClass;&#13;
    uint256 cardId;&#13;
    uint256 upgradeValue;&#13;
    uint256 increase;&#13;
  }&#13;
  &#13;
  /** mapping**/&#13;
  mapping(uint256 =&gt; Card) private cardInfo;  //normal card&#13;
  mapping(uint256 =&gt; BattleCard) private battlecardInfo;  //battle card&#13;
  mapping(uint256 =&gt; UpgradeCard) private upgradeInfo;  //upgrade card&#13;
     &#13;
  uint256 public currNumOfCards;  &#13;
  uint256 public currNumOfBattleCards;  &#13;
  uint256 public currNumOfUpgrades; &#13;
&#13;
  uint256 public Max_CAP = 99;&#13;
  uint256 PLATPrice = 65000;&#13;
    &#13;
  // Constructor &#13;
  function GameConfig() public {&#13;
    owner = msg.sender;&#13;
  }&#13;
  modifier onlyOwner() {&#13;
    require(msg.sender == owner);&#13;
    _;&#13;
  }&#13;
&#13;
  address allowed; &#13;
  function setAllowedAddress(address _address) external onlyOwner {&#13;
    require(_address != address(0));&#13;
    allowed = _address;&#13;
  }&#13;
  modifier onlyAccess() {&#13;
    require(msg.sender == allowed || msg.sender == owner);&#13;
    _;&#13;
  }&#13;
&#13;
  function setMaxCAP(uint256 iMax) external onlyOwner {&#13;
    Max_CAP = iMax;&#13;
  }&#13;
  function getMaxCAP() external view returns (uint256) {&#13;
    return Max_CAP;&#13;
  }&#13;
  function setPLATPrice(uint256 price) external onlyOwner {&#13;
    PLATPrice = price;&#13;
  }&#13;
  function getPLATPrice() external view returns (uint256) {&#13;
    return PLATPrice;&#13;
  }&#13;
&#13;
  function CreateBattleCards(uint256 _cardId, uint256 _baseCoinCost, uint256 _coinCostIncreaseHalf, uint256 _ethCost, uint _attackValue, uint256 _defenseValue, uint256 _coinStealingCapacity, bool _unitSellable) external onlyAccess {&#13;
    BattleCard memory _battlecard = BattleCard({&#13;
      cardId: _cardId,&#13;
      baseCoinCost: _baseCoinCost,&#13;
      coinCostIncreaseHalf: _coinCostIncreaseHalf,&#13;
      ethCost: _ethCost,&#13;
      attackValue: _attackValue,&#13;
      defenseValue: _defenseValue,&#13;
      coinStealingCapacity: _coinStealingCapacity,&#13;
      unitSellable: _unitSellable&#13;
    });&#13;
    battlecardInfo[_cardId] = _battlecard;&#13;
    currNumOfBattleCards = SafeMath.add(currNumOfBattleCards,1);&#13;
    newBattleCard(_cardId,_baseCoinCost,_coinCostIncreaseHalf,_ethCost,_attackValue,_defenseValue,_coinStealingCapacity);&#13;
    &#13;
  }&#13;
&#13;
  function CreateCards(uint256 _cardId, uint256 _baseCoinCost, uint256 _coinCostIncreaseHalf, uint256 _ethCost, uint256 _baseCoinProduction, bool _unitSellable) external onlyAccess {&#13;
    Card memory _card = Card({&#13;
      cardId: _cardId,&#13;
      baseCoinCost: _baseCoinCost,&#13;
      coinCostIncreaseHalf: _coinCostIncreaseHalf,&#13;
      ethCost: _ethCost,&#13;
      baseCoinProduction: _baseCoinProduction,&#13;
      unitSellable: _unitSellable&#13;
    });&#13;
    cardInfo[_cardId] = _card;&#13;
    currNumOfCards = SafeMath.add(currNumOfCards,1);&#13;
    newCard(_cardId,_baseCoinCost,_coinCostIncreaseHalf,_ethCost,_baseCoinProduction);&#13;
  }&#13;
&#13;
  function CreateUpgradeCards(uint256 _upgradecardId, uint256 _coinCost, uint256 _ethCost, uint256 _upgradeClass, uint256 _cardId, uint256 _upgradeValue, uint256 _increase) external onlyAccess {&#13;
    UpgradeCard memory _upgradecard = UpgradeCard({&#13;
      upgradecardId: _upgradecardId,&#13;
      coinCost: _coinCost,&#13;
      ethCost: _ethCost,&#13;
      upgradeClass: _upgradeClass,&#13;
      cardId: _cardId,&#13;
      upgradeValue: _upgradeValue,&#13;
      increase: _increase&#13;
    });&#13;
    upgradeInfo[_upgradecardId] = _upgradecard;&#13;
    currNumOfUpgrades = SafeMath.add(currNumOfUpgrades,1);&#13;
    newUpgradeCard(_upgradecardId,_coinCost,_ethCost,_upgradeClass,_cardId,_upgradeValue,_increase); &#13;
  }&#13;
&#13;
  function getCostForCards(uint256 cardId, uint256 existing, uint256 amount) public constant returns (uint256) {&#13;
    uint256 icount = existing;&#13;
    if (amount == 1) { &#13;
      if (existing == 0) {  &#13;
        return cardInfo[cardId].baseCoinCost; &#13;
      } else {&#13;
        return cardInfo[cardId].baseCoinCost + (existing * cardInfo[cardId].coinCostIncreaseHalf * 2);&#13;
            }&#13;
    } else if (amount &gt; 1) { &#13;
      uint256 existingCost;&#13;
      if (existing &gt; 0) {&#13;
        existingCost = (cardInfo[cardId].baseCoinCost * existing) + (existing * (existing - 1) * cardInfo[cardId].coinCostIncreaseHalf);&#13;
      }&#13;
      icount = SafeMath.add(existing,amount);  &#13;
      uint256 newCost = SafeMath.add(SafeMath.mul(cardInfo[cardId].baseCoinCost, icount), SafeMath.mul(SafeMath.mul(icount, (icount - 1)), cardInfo[cardId].coinCostIncreaseHalf));&#13;
      return newCost - existingCost;&#13;
      }&#13;
  }&#13;
&#13;
  function getCostForBattleCards(uint256 cardId, uint256 existing, uint256 amount) public constant returns (uint256) {&#13;
    uint256 icount = existing;&#13;
    if (amount == 1) { &#13;
      if (existing == 0) {  &#13;
        return battlecardInfo[cardId].baseCoinCost; &#13;
      } else {&#13;
        return battlecardInfo[cardId].baseCoinCost + (existing * battlecardInfo[cardId].coinCostIncreaseHalf * 2);&#13;
            }&#13;
    } else if (amount &gt; 1) {&#13;
      uint256 existingCost;&#13;
      if (existing &gt; 0) {&#13;
        existingCost = (battlecardInfo[cardId].baseCoinCost * existing) + (existing * (existing - 1) * battlecardInfo[cardId].coinCostIncreaseHalf);&#13;
      }&#13;
      icount = SafeMath.add(existing,amount);  &#13;
      uint256 newCost = SafeMath.add(SafeMath.mul(battlecardInfo[cardId].baseCoinCost, icount), SafeMath.mul(SafeMath.mul(icount, (icount - 1)), battlecardInfo[cardId].coinCostIncreaseHalf));&#13;
      return newCost - existingCost;&#13;
    }&#13;
  }&#13;
&#13;
  function getCostForUprade(uint256 cardId, uint256 existing, uint256 amount) public constant returns (uint256) {&#13;
    if (amount == 1) { &#13;
      if (existing == 0) {  &#13;
        return upgradeInfo[cardId].coinCost; &#13;
      } else {&#13;
        return upgradeInfo[cardId].coinCost + (existing * upgradeInfo[cardId].increase * 2);&#13;
      }&#13;
    } &#13;
  }&#13;
&#13;
  function getWeakenedDefensePower(uint256 defendingPower) external pure returns (uint256) {&#13;
    return SafeMath.div(defendingPower,2);&#13;
  }&#13;
 &#13;
    /// @notice get the production card's ether cost&#13;
  function unitEthCost(uint256 cardId) external constant returns (uint256) {&#13;
    return cardInfo[cardId].ethCost;&#13;
  }&#13;
&#13;
    /// @notice get the battle card's ether cost&#13;
  function unitBattleEthCost(uint256 cardId) external constant returns (uint256) {&#13;
    return battlecardInfo[cardId].ethCost;&#13;
  }&#13;
  /// @notice get the battle card's plat cost&#13;
  function unitBattlePLATCost(uint256 cardId) external constant returns (uint256) {&#13;
    return SafeMath.mul(battlecardInfo[cardId].ethCost,PLATPrice);&#13;
  }&#13;
&#13;
    /// @notice normal production plat value&#13;
  function unitPLATCost(uint256 cardId) external constant returns (uint256) {&#13;
    return SafeMath.mul(cardInfo[cardId].ethCost,PLATPrice);&#13;
  }&#13;
&#13;
  function unitCoinProduction(uint256 cardId) external constant returns (uint256) {&#13;
    return cardInfo[cardId].baseCoinProduction;&#13;
  }&#13;
&#13;
  function unitAttack(uint256 cardId) external constant returns (uint256) {&#13;
    return battlecardInfo[cardId].attackValue;&#13;
  }&#13;
    &#13;
  function unitDefense(uint256 cardId) external constant returns (uint256) {&#13;
    return battlecardInfo[cardId].defenseValue;&#13;
  }&#13;
&#13;
  function unitStealingCapacity(uint256 cardId) external constant returns (uint256) {&#13;
    return battlecardInfo[cardId].coinStealingCapacity;&#13;
  }&#13;
  &#13;
  function productionCardIdRange() external constant returns (uint256, uint256) {&#13;
    return (1, currNumOfCards);&#13;
  }&#13;
&#13;
  function battleCardIdRange() external constant returns (uint256, uint256) {&#13;
    uint256 battleMax = SafeMath.add(39,currNumOfBattleCards);&#13;
    return (40, battleMax);&#13;
  }&#13;
&#13;
  function upgradeIdRange() external constant returns (uint256, uint256) {&#13;
    return (1, currNumOfUpgrades);&#13;
  }&#13;
 &#13;
  // get the detail info of card &#13;
  function getCardsInfo(uint256 cardId) external constant returns (&#13;
    uint256 baseCoinCost,&#13;
    uint256 coinCostIncreaseHalf,&#13;
    uint256 ethCost, &#13;
    uint256 baseCoinProduction,&#13;
    uint256 platCost, &#13;
    bool  unitSellable&#13;
  ) {&#13;
    baseCoinCost = cardInfo[cardId].baseCoinCost;&#13;
    coinCostIncreaseHalf = cardInfo[cardId].coinCostIncreaseHalf;&#13;
    ethCost = cardInfo[cardId].ethCost;&#13;
    baseCoinProduction = cardInfo[cardId].baseCoinProduction;&#13;
    platCost = SafeMath.mul(ethCost,PLATPrice);&#13;
    unitSellable = cardInfo[cardId].unitSellable;&#13;
  }&#13;
  //for production card&#13;
  function getCardInfo(uint256 cardId, uint256 existing, uint256 amount) external constant returns (uint256, uint256, uint256, uint256, bool) {&#13;
    return (cardInfo[cardId].cardId, cardInfo[cardId].baseCoinProduction, getCostForCards(cardId, existing, amount), SafeMath.mul(cardInfo[cardId].ethCost, amount),cardInfo[cardId].unitSellable);&#13;
  }&#13;
&#13;
   //for battle card&#13;
  function getBattleCardInfo(uint256 cardId, uint256 existing, uint256 amount) external constant returns (uint256, uint256, uint256, bool) {&#13;
    return (battlecardInfo[cardId].cardId, getCostForBattleCards(cardId, existing, amount), SafeMath.mul(battlecardInfo[cardId].ethCost, amount),battlecardInfo[cardId].unitSellable);&#13;
  }&#13;
&#13;
  //Battle Cards&#13;
  function getBattleCardsInfo(uint256 cardId) external constant returns (&#13;
    uint256 baseCoinCost,&#13;
    uint256 coinCostIncreaseHalf,&#13;
    uint256 ethCost, &#13;
    uint256 attackValue,&#13;
    uint256 defenseValue,&#13;
    uint256 coinStealingCapacity,&#13;
    uint256 platCost,&#13;
    bool  unitSellable&#13;
  ) {&#13;
    baseCoinCost = battlecardInfo[cardId].baseCoinCost;&#13;
    coinCostIncreaseHalf = battlecardInfo[cardId].coinCostIncreaseHalf;&#13;
    ethCost = battlecardInfo[cardId].ethCost;&#13;
    attackValue = battlecardInfo[cardId].attackValue;&#13;
    defenseValue = battlecardInfo[cardId].defenseValue;&#13;
    coinStealingCapacity = battlecardInfo[cardId].coinStealingCapacity;&#13;
    platCost = SafeMath.mul(ethCost,PLATPrice);&#13;
    unitSellable = battlecardInfo[cardId].unitSellable;&#13;
  }&#13;
&#13;
  //upgrade cards&#13;
  function getUpgradeCardsInfo(uint256 upgradecardId, uint256 existing) external constant returns (&#13;
    uint256 coinCost, &#13;
    uint256 ethCost, &#13;
    uint256 upgradeClass, &#13;
    uint256 cardId, &#13;
    uint256 upgradeValue,&#13;
    uint256 platCost&#13;
    ) {  &#13;
    coinCost = getCostForUprade(upgradecardId, existing, 1);&#13;
    ethCost = upgradeInfo[upgradecardId].ethCost * (100 + 10 * existing)/100;&#13;
    upgradeClass = upgradeInfo[upgradecardId].upgradeClass;&#13;
    cardId = upgradeInfo[upgradecardId].cardId;&#13;
    upgradeValue = upgradeInfo[upgradecardId].upgradeValue + existing;&#13;
    platCost = SafeMath.mul(ethCost,PLATPrice);&#13;
  }&#13;
}&#13;
&#13;
library SafeMath {&#13;
&#13;
  /**&#13;
  * @dev Multiplies two numbers, throws on overflow.&#13;
  */&#13;
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
    if (a == 0) {&#13;
      return 0;&#13;
    }&#13;
    uint256 c = a * b;&#13;
    assert(c / a == b);&#13;
    return c;&#13;
  }&#13;
&#13;
  /**&#13;
  * @dev Integer division of two numbers, truncating the quotient.&#13;
  */&#13;
  function div(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
    // assert(b &gt; 0); // Solidity automatically throws when dividing by 0&#13;
    uint256 c = a / b;&#13;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold&#13;
    return c;&#13;
  }&#13;
&#13;
  /**&#13;
  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).&#13;
  */&#13;
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
    assert(b &lt;= a);&#13;
    return a - b;&#13;
  }&#13;
&#13;
  /**&#13;
  * @dev Adds two numbers, throws on overflow.&#13;
  */&#13;
  function add(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
    uint256 c = a + b;&#13;
    assert(c &gt;= a);&#13;
    return c;&#13;
  }&#13;
}