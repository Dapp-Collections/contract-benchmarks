/* ==================================================================== */
/* Copyright (c) 2018 The TokenTycoon Project.  All rights reserved.
/* 
/* https://tokentycoon.io
/*  
/* authors <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="592b303a32312c372d3c2b772a313c37193e34383035773a3634">[email protected]</a>   &#13;
/*         <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="06757563757368626f686146616b676f6a2865696b">[email protected]</a>            &#13;
/* ==================================================================== */&#13;
pragma solidity ^0.4.23;&#13;
&#13;
/// @title ERC-165 Standard Interface Detection&#13;
/// @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-165.md&#13;
interface ERC165 {&#13;
    function supportsInterface(bytes4 interfaceID) external view returns (bool);&#13;
}&#13;
&#13;
/// @title ERC-721 Non-Fungible Token Standard&#13;
/// @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md&#13;
contract ERC721 is ERC165 {&#13;
    event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);&#13;
    event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);&#13;
    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);&#13;
    function balanceOf(address _owner) external view returns (uint256);&#13;
    function ownerOf(uint256 _tokenId) external view returns (address);&#13;
    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data) external;&#13;
    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external;&#13;
    function transferFrom(address _from, address _to, uint256 _tokenId) external;&#13;
    function approve(address _approved, uint256 _tokenId) public;&#13;
    function setApprovalForAll(address _operator, bool _approved) external;&#13;
    function getApproved(uint256 _tokenId) external view returns (address);&#13;
    function isApprovedForAll(address _owner, address _operator) external view returns (bool);&#13;
}&#13;
&#13;
/// @title ERC-721 Non-Fungible Token Standard&#13;
interface ERC721TokenReceiver {&#13;
	function onERC721Received(address _from, uint256 _tokenId, bytes data) external returns(bytes4);&#13;
}&#13;
&#13;
/// @title ERC-721 Non-Fungible Token Standard, optional metadata extension&#13;
interface ERC721Metadata /* is ERC721 */ {&#13;
    function name() external pure returns (string _name);&#13;
    function symbol() external pure returns (string _symbol);&#13;
    function tokenURI(uint256 _tokenId) external view returns (string);&#13;
}&#13;
&#13;
/// @title ERC-721 Non-Fungible Token Standard, optional enumeration extension&#13;
interface ERC721Enumerable /* is ERC721 */ {&#13;
    function totalSupply() external view returns (uint256);&#13;
    function tokenByIndex(uint256 _index) external view returns (uint256);&#13;
    function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256);&#13;
}&#13;
&#13;
interface ERC721MetadataProvider {&#13;
    function tokenURI(uint256 _tokenId) external view returns (string);&#13;
}&#13;
&#13;
contract AccessAdmin {&#13;
    bool public isPaused = false;&#13;
    address public addrAdmin;  &#13;
&#13;
    event AdminTransferred(address indexed preAdmin, address indexed newAdmin);&#13;
&#13;
    constructor() public {&#13;
        addrAdmin = msg.sender;&#13;
    }  &#13;
&#13;
&#13;
    modifier onlyAdmin() {&#13;
        require(msg.sender == addrAdmin);&#13;
        _;&#13;
    }&#13;
&#13;
    modifier whenNotPaused() {&#13;
        require(!isPaused);&#13;
        _;&#13;
    }&#13;
&#13;
    modifier whenPaused {&#13;
        require(isPaused);&#13;
        _;&#13;
    }&#13;
&#13;
    function setAdmin(address _newAdmin) external onlyAdmin {&#13;
        require(_newAdmin != address(0));&#13;
        emit AdminTransferred(addrAdmin, _newAdmin);&#13;
        addrAdmin = _newAdmin;&#13;
    }&#13;
&#13;
    function doPause() external onlyAdmin whenNotPaused {&#13;
        isPaused = true;&#13;
    }&#13;
&#13;
    function doUnpause() external onlyAdmin whenPaused {&#13;
        isPaused = false;&#13;
    }&#13;
}&#13;
&#13;
interface TokenRecipient { &#13;
    function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external;&#13;
}&#13;
&#13;
contract ManagerToken is ERC721, ERC721Metadata, ERC721Enumerable, AccessAdmin {&#13;
    /// @dev All manangers array(tokenId =&gt; gene)&#13;
    uint256[] public managerArray;&#13;
    /// @dev Mananger tokenId vs owner address&#13;
    mapping (uint256 =&gt; address) tokenIdToOwner;&#13;
    /// @dev Manangers owner by the owner (array)&#13;
    mapping (address =&gt; uint256[]) ownerToManagerArray;&#13;
    /// @dev Mananger token ID search in owner array&#13;
    mapping (uint256 =&gt; uint256) tokenIdToOwnerIndex;&#13;
    /// @dev The authorized address for each TTM&#13;
    mapping (uint256 =&gt; address) tokenIdToApprovals;&#13;
    /// @dev The authorized operators for each address&#13;
    mapping (address =&gt; mapping (address =&gt; bool)) operatorToApprovals;&#13;
    /// @dev Trust contract&#13;
    mapping (address =&gt; bool) safeContracts;&#13;
    /// @dev Metadata provider&#13;
    ERC721MetadataProvider public providerContract;&#13;
&#13;
    /// @dev This emits when the approved address for an TTM is changed or reaffirmed.&#13;
    event Approval&#13;
    (&#13;
        address indexed _owner, &#13;
        address indexed _approved,&#13;
        uint256 _tokenId&#13;
    );&#13;
&#13;
    /// @dev This emits when an operator is enabled or disabled for an owner.&#13;
    event ApprovalForAll&#13;
    (&#13;
        address indexed _owner,&#13;
        address indexed _operator,&#13;
        bool _approved&#13;
    );&#13;
&#13;
    /// @dev This emits when the equipment ownership changed &#13;
    event Transfer&#13;
    (&#13;
        address indexed from,&#13;
        address indexed to,&#13;
        uint256 tokenId&#13;
    );&#13;
    &#13;
    constructor() public {&#13;
        addrAdmin = msg.sender;&#13;
        managerArray.length += 1;&#13;
    }&#13;
&#13;
    // modifier&#13;
    /// @dev Check if token ID is valid&#13;
    modifier isValidToken(uint256 _tokenId) {&#13;
        require(_tokenId &gt;= 1 &amp;&amp; _tokenId &lt;= managerArray.length, "TokenId out of range");&#13;
        require(tokenIdToOwner[_tokenId] != address(0), "Token have no owner"); &#13;
        _;&#13;
    }&#13;
&#13;
    modifier canTransfer(uint256 _tokenId) {&#13;
        address owner = tokenIdToOwner[_tokenId];&#13;
        require(msg.sender == owner || msg.sender == tokenIdToApprovals[_tokenId] || operatorToApprovals[owner][msg.sender], "Can not transfer");&#13;
        _;&#13;
    }&#13;
&#13;
    // ERC721&#13;
    function supportsInterface(bytes4 _interfaceId) external view returns(bool) {&#13;
        // ERC165 || ERC721 || ERC165^ERC721&#13;
        return (_interfaceId == 0x01ffc9a7 || _interfaceId == 0x80ac58cd || _interfaceId == 0x8153916a) &amp;&amp; (_interfaceId != 0xffffffff);&#13;
    }&#13;
&#13;
    function name() public pure returns(string) {&#13;
        return "Token Tycoon Managers";&#13;
    }&#13;
&#13;
    function symbol() public pure returns(string) {&#13;
        return "TTM";&#13;
    }&#13;
&#13;
    function tokenURI(uint256 _tokenId) external view returns (string) {&#13;
        if (address(providerContract) == address(0)) {&#13;
            return "";&#13;
        }&#13;
        return providerContract.tokenURI(_tokenId);&#13;
    }&#13;
&#13;
    /// @dev Search for token quantity address&#13;
    /// @param _owner Address that needs to be searched&#13;
    /// @return Returns token quantity&#13;
    function balanceOf(address _owner) external view returns(uint256) {&#13;
        require(_owner != address(0), "Owner is 0");&#13;
        return ownerToManagerArray[_owner].length;&#13;
    }&#13;
&#13;
    /// @dev Find the owner of an TTM&#13;
    /// @param _tokenId The tokenId of TTM&#13;
    /// @return Give The address of the owner of this TTM&#13;
    function ownerOf(uint256 _tokenId) external view returns (address owner) {&#13;
        return tokenIdToOwner[_tokenId];&#13;
    }&#13;
&#13;
    /// @dev Transfers the ownership of an TTM from one address to another address&#13;
    /// @param _from The current owner of the TTM&#13;
    /// @param _to The new owner&#13;
    /// @param _tokenId The TTM to transfer&#13;
    /// @param data Additional data with no specified format, sent in call to `_to`&#13;
    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data) &#13;
        external&#13;
        whenNotPaused&#13;
    {&#13;
        _safeTransferFrom(_from, _to, _tokenId, data);&#13;
    }&#13;
&#13;
    /// @dev Transfers the ownership of an TTM from one address to another address&#13;
    /// @param _from The current owner of the TTM&#13;
    /// @param _to The new owner&#13;
    /// @param _tokenId The TTM to transfer&#13;
    function safeTransferFrom(address _from, address _to, uint256 _tokenId) &#13;
        external&#13;
        whenNotPaused&#13;
    {&#13;
        _safeTransferFrom(_from, _to, _tokenId, "");&#13;
    }&#13;
&#13;
    /// @dev Transfer ownership of an TTM, '_to' must be a vaild address, or the TTM will lost&#13;
    /// @param _from The current owner of the TTM&#13;
    /// @param _to The new owner&#13;
    /// @param _tokenId The TTM to transfer&#13;
    function transferFrom(address _from, address _to, uint256 _tokenId)&#13;
        external&#13;
        whenNotPaused&#13;
        isValidToken(_tokenId)&#13;
        canTransfer(_tokenId)&#13;
    {&#13;
        address owner = tokenIdToOwner[_tokenId];&#13;
        require(owner != address(0), "Owner is 0");&#13;
        require(_to != address(0), "Transfer target address is 0");&#13;
        require(owner == _from, "Transfer to self");&#13;
        &#13;
        _transfer(_from, _to, _tokenId);&#13;
    }&#13;
&#13;
    /// @dev Set or reaffirm the approved address for an TTM&#13;
    /// @param _approved The new approved TTM controller&#13;
    /// @param _tokenId The TTM to approve&#13;
    function approve(address _approved, uint256 _tokenId) public whenNotPaused {&#13;
        address owner = tokenIdToOwner[_tokenId];&#13;
        require(owner != address(0));&#13;
        require(msg.sender == owner || operatorToApprovals[owner][msg.sender]);&#13;
&#13;
        tokenIdToApprovals[_tokenId] = _approved;&#13;
        emit Approval(owner, _approved, _tokenId);&#13;
    }&#13;
&#13;
    /// @dev Enable or disable approval for a third party ("operator") to manage all your asset.&#13;
    /// @param _operator Address to add to the set of authorized operators.&#13;
    /// @param _approved True if the operators is approved, false to revoke approval&#13;
    function setApprovalForAll(address _operator, bool _approved) &#13;
        external &#13;
        whenNotPaused&#13;
    {&#13;
        operatorToApprovals[msg.sender][_operator] = _approved;&#13;
        emit ApprovalForAll(msg.sender, _operator, _approved);&#13;
    }&#13;
&#13;
    /// @dev Get the approved address for a single TTM&#13;
    /// @param _tokenId The TTM to find the approved address for&#13;
    /// @return The approved address for this TTM, or the zero address if there is none&#13;
    function getApproved(uint256 _tokenId) &#13;
        external &#13;
        view &#13;
        isValidToken(_tokenId) &#13;
        returns (address) &#13;
    {&#13;
        return tokenIdToApprovals[_tokenId];&#13;
    }&#13;
&#13;
    /// @dev Query if an address is an authorized operator for another address&#13;
    /// @param _owner The address that owns the TTMs&#13;
    /// @param _operator The address that acts on behalf of the owner&#13;
    /// @return True if `_operator` is an approved operator for `_owner`, false otherwise&#13;
    function isApprovedForAll(address _owner, address _operator) external view returns (bool) {&#13;
        return operatorToApprovals[_owner][_operator];&#13;
    }&#13;
&#13;
    /// @dev Count TTMs tracked by this contract&#13;
    /// @return A count of valid TTMs tracked by this contract, where each one of&#13;
    ///  them has an assigned and queryable owner not equal to the zero address&#13;
    function totalSupply() external view returns (uint256) {&#13;
        return managerArray.length - 1;&#13;
    }&#13;
&#13;
    /// @dev Enumerate valid TTMs&#13;
    /// @param _index A counter less than totalSupply&#13;
    /// @return The token identifier for the `_index`th TTM,&#13;
    function tokenByIndex(uint256 _index) &#13;
        external&#13;
        view &#13;
        returns (uint256) &#13;
    {&#13;
        require(_index &lt; managerArray.length);&#13;
        return _index;&#13;
    }&#13;
&#13;
    /// @notice Enumerate TTMs assigned to an owner&#13;
    /// @param _owner Token owner address&#13;
    /// @param _index A counter less than balanceOf(_owner)&#13;
    /// @return The TTM tokenId&#13;
    function tokenOfOwnerByIndex(address _owner, uint256 _index) &#13;
        external &#13;
        view &#13;
        returns (uint256) &#13;
    {&#13;
        require(_owner != address(0));&#13;
        require(_index &lt; ownerToManagerArray[_owner].length);&#13;
        return ownerToManagerArray[_owner][_index];&#13;
    }&#13;
&#13;
    /// @dev Do the real transfer with out any condition checking&#13;
    /// @param _from The old owner of this TTM(If created: 0x0)&#13;
    /// @param _to The new owner of this TTM &#13;
    /// @param _tokenId The tokenId of the TTM&#13;
    function _transfer(address _from, address _to, uint256 _tokenId) internal {&#13;
        if (_from != address(0)) {&#13;
            uint256 indexFrom = tokenIdToOwnerIndex[_tokenId];&#13;
            uint256[] storage ttmArray = ownerToManagerArray[_from];&#13;
            require(ttmArray[indexFrom] == _tokenId);&#13;
&#13;
            if (indexFrom != ttmArray.length - 1) {&#13;
                uint256 lastTokenId = ttmArray[ttmArray.length - 1];&#13;
                ttmArray[indexFrom] = lastTokenId; &#13;
                tokenIdToOwnerIndex[lastTokenId] = indexFrom;&#13;
            }&#13;
            ttmArray.length -= 1; &#13;
            &#13;
            if (tokenIdToApprovals[_tokenId] != address(0)) {&#13;
                delete tokenIdToApprovals[_tokenId];&#13;
            }      &#13;
        }&#13;
&#13;
        tokenIdToOwner[_tokenId] = _to;&#13;
        ownerToManagerArray[_to].push(_tokenId);&#13;
        tokenIdToOwnerIndex[_tokenId] = ownerToManagerArray[_to].length - 1;&#13;
        &#13;
        emit Transfer(_from != address(0) ? _from : this, _to, _tokenId);&#13;
    }&#13;
&#13;
    /// @dev Actually perform the safeTransferFrom&#13;
    function _safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data) &#13;
        internal&#13;
        isValidToken(_tokenId) &#13;
        canTransfer(_tokenId)&#13;
    {&#13;
        address owner = tokenIdToOwner[_tokenId];&#13;
        require(owner != address(0));&#13;
        require(_to != address(0));&#13;
        require(owner == _from);&#13;
        &#13;
        _transfer(_from, _to, _tokenId);&#13;
&#13;
        // Do the callback after everything is done to avoid reentrancy attack&#13;
        uint256 codeSize;&#13;
        assembly { codeSize := extcodesize(_to) }&#13;
        if (codeSize == 0) {&#13;
            return;&#13;
        }&#13;
        bytes4 retval = ERC721TokenReceiver(_to).onERC721Received(_from, _tokenId, data);&#13;
        // bytes4(keccak256("onERC721Received(address,uint256,bytes)")) = 0xf0b9e5ba;&#13;
        require(retval == 0xf0b9e5ba);&#13;
    }&#13;
    &#13;
    function setSafeContract(address _actionAddr, bool _useful) external onlyAdmin {&#13;
        safeContracts[_actionAddr] = _useful;&#13;
    }&#13;
&#13;
    function getSafeContract(address _actionAddr) external view onlyAdmin returns(bool) {&#13;
        return safeContracts[_actionAddr];&#13;
    }&#13;
&#13;
    function setMetadataProvider(address _provider) external onlyAdmin {&#13;
        providerContract = ERC721MetadataProvider(_provider);&#13;
    }&#13;
&#13;
    function getOwnTokens(address _owner) external view returns(uint256[]) {&#13;
        require(_owner != address(0));&#13;
        return ownerToManagerArray[_owner];&#13;
    }&#13;
&#13;
    function safeGiveByContract(uint256 _tokenId, address _to) &#13;
        external &#13;
        whenNotPaused&#13;
    {&#13;
        require(safeContracts[msg.sender]);&#13;
        // Only the token's owner is this can use this function&#13;
        require(tokenIdToOwner[_tokenId] == address(this));&#13;
        require(_to != address(0));&#13;
&#13;
        _transfer(address(this), _to, _tokenId);&#13;
    }&#13;
&#13;
    /// @dev Safe transfer by trust contracts&#13;
    function safeTransferByContract(uint256 _tokenId, address _to) &#13;
        external&#13;
        whenNotPaused&#13;
    {&#13;
        require(safeContracts[msg.sender]);&#13;
&#13;
        require(_tokenId &gt;= 1 &amp;&amp; _tokenId &lt;= managerArray.length);&#13;
        address owner = tokenIdToOwner[_tokenId];&#13;
        require(owner != address(0));&#13;
        require(_to != address(0));&#13;
        require(owner != _to);&#13;
&#13;
        _transfer(owner, _to, _tokenId);&#13;
    }&#13;
&#13;
    function initManager(uint256 _gene, uint256 _count) external {&#13;
        require(safeContracts[msg.sender] || msg.sender == addrAdmin);&#13;
        require(_gene &gt; 0 &amp;&amp; _count &lt;= 128);&#13;
        &#13;
        address owner = address(this);&#13;
        uint256[] storage ttmArray = ownerToManagerArray[owner];&#13;
        uint256 newTokenId;&#13;
        for (uint256 i = 0; i &lt; _count; ++i) {&#13;
            newTokenId = managerArray.length;&#13;
            managerArray.push(_gene);&#13;
            tokenIdToOwner[newTokenId] = owner;&#13;
            tokenIdToOwnerIndex[newTokenId] = ttmArray.length;&#13;
            ttmArray.push(newTokenId);&#13;
            emit Transfer(address(0), owner, newTokenId);&#13;
        }&#13;
    }&#13;
&#13;
    function approveAndCall(address _spender, uint256 _tokenId, bytes _extraData)&#13;
        external&#13;
        whenNotPaused&#13;
        returns (bool success) &#13;
    {&#13;
        TokenRecipient spender = TokenRecipient(_spender);&#13;
        approve(_spender, _tokenId);&#13;
        spender.receiveApproval(msg.sender, _tokenId, this, _extraData);&#13;
        return true;&#13;
    }&#13;
&#13;
    function getProtoIdByTokenId(uint256 _tokenId)&#13;
        external &#13;
        view &#13;
        returns(uint256 protoId) &#13;
    {&#13;
        if (_tokenId &gt; 0 &amp;&amp; _tokenId &lt; managerArray.length) {&#13;
            return managerArray[_tokenId];&#13;
        }&#13;
    }&#13;
&#13;
    function getOwnerTokens(address _owner)&#13;
        external&#13;
        view &#13;
        returns(uint256[] tokenIdArray, uint256[] protoIdArray) &#13;
    {&#13;
        uint256[] storage ownTokens = ownerToManagerArray[_owner];&#13;
        uint256 count = ownTokens.length;&#13;
        tokenIdArray = new uint256[](count);&#13;
        protoIdArray = new uint256[](count);&#13;
        for (uint256 i = 0; i &lt; count; ++i) {&#13;
            tokenIdArray[i] = ownTokens[i];&#13;
            protoIdArray[i] = managerArray[tokenIdArray[i]];&#13;
        }&#13;
    }&#13;
}