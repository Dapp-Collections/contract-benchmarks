pragma solidity ^0.4.18;

// Created by Roman Oznobin (<span class="__cf_email__" data-cfemail="d3bca98ca193beb2babffda1a6">[email protected]</span>) - http://code-expert.pro&#13;
// Owner is Alexey Malashkin (<span class="__cf_email__" data-cfemail="3a565f5453545d485b5e0b027a435b545e5f4214484f">[email protected]</span>)&#13;
// Smart contract for BasisToken of Ltd "KKM" (<span class="__cf_email__" data-cfemail="1e7f6c737f6a6b6c7f6e726b6d5e737f7772306c6b">[email protected]</span>) - http://ruarmatura.ru/&#13;
&#13;
library SafeMath {&#13;
&#13;
  function mul(uint a, uint b) internal pure returns (uint) {&#13;
    uint256 c = a * b;&#13;
    assert(a == 0 || c / a == b);&#13;
    return c;&#13;
  }&#13;
&#13;
  function div(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
    // assert(b &gt; 0); // Solidity automatically throws when dividing by 0&#13;
    uint256 c = a / b;&#13;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold&#13;
    return c;&#13;
  }&#13;
&#13;
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
    assert(b &lt;= a);&#13;
    return a - b;&#13;
  }&#13;
&#13;
  function add(uint a, uint b) internal pure returns (uint256) {&#13;
    uint256 c = a + b;&#13;
    assert(c &gt;= a);&#13;
    return c;&#13;
  }&#13;
&#13;
}&#13;
&#13;
/**&#13;
 * @title Ownable&#13;
 * @dev The Ownable contract has an owner address, and provides basic authorization control&#13;
 * functions, this simplifies the implementation of "user permissions".&#13;
 */&#13;
contract Ownable {&#13;
&#13;
  address public owner;&#13;
&#13;
  /**&#13;
   * @dev The Ownable constructor sets the original `owner` of the contract to the sender&#13;
   * account.&#13;
   */&#13;
  function Ownable() public {&#13;
    owner = msg.sender;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Throws if called by any account other than the owner.&#13;
   */&#13;
  modifier onlyOwner() {&#13;
     address inp_sender = msg.sender;&#13;
     bool chekk = msg.sender == owner;&#13;
    require(chekk);&#13;
    _;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Allows the current owner to transfer control of the contract to a newOwner.&#13;
   * @param newOwner The address to transfer ownership to.&#13;
   */&#13;
  function transferOwnership(address newOwner) public onlyOwner {&#13;
    require(newOwner != address(0));&#13;
    owner = newOwner;&#13;
  }&#13;
&#13;
}&#13;
&#13;
// The contract...&#13;
&#13;
contract BasisIco  {&#13;
&#13;
  using SafeMath for uint;&#13;
  &#13;
    string public constant name = "Basis Token";&#13;
&#13;
    string public constant symbol = "BSS";&#13;
&#13;
    uint32 public constant decimals = 0;  &#13;
    &#13;
    struct Investor {&#13;
        address holder;&#13;
        uint tokens;&#13;
&#13;
    }&#13;
  &#13;
    Investor[] internal Cast_Arr;&#13;
     &#13;
    Investor tmp_investor;  &#13;
      &#13;
  &#13;
  // Used to set wallet for owner, bounty and developer&#13;
  // To that address Ether will be sended if Ico will have sucsess done&#13;
  // Untill Ico is no finish and is no sucsess, all Ether are closed from anybody on ICO contract wallet&#13;
  address internal constant owner_wallet = 0x79d8af6eEA6Aeeaf7a3a92D348457a5C4f0eEe1B;&#13;
  address public constant owner = 0x79d8af6eEA6Aeeaf7a3a92D348457a5C4f0eEe1B;&#13;
  address internal constant developer = 0xf2F1A92AD7f1124ef8900931ED00683f0B3A5da7;&#13;
&#13;
  //&#13;
  //address public bounty_wallet = 0x79d8af6eEA6Aeeaf7a3a92D348457a5C4f0eEe1B;&#13;
&#13;
  uint public constant bountyPercent = 4;&#13;
  &#13;
&#13;
  //address public bounty_reatricted_addr;&#13;
  //Base price for BSS ICO. Show how much Wei is in 1 BSS. During ICO price calculate from the $rate&#13;
  uint internal constant rate = 3300000000000000;&#13;
  &#13;
    uint public token_iso_price;&#13;
// Генерируется в Crowdsale constructor&#13;
//  BasisToken public token = new BasisToken();&#13;
&#13;
  // Time sructure of Basis ico&#13;
  // start_declaration of first round of Basis ico - Presale ( start_declaration of token creation and ico Presale )&#13;
  uint public start_declaration = 1511384400;&#13;
  // The period for calculate the time structure of Basis ico, amount of the days&#13;
  uint public ico_period = 15;&#13;
  // First round finish - Presale finish&#13;
  uint public presale_finish;&#13;
  // ico Second raund start.&#13;
  uint public second_round_start;&#13;
  // Basis ico finish, all mint are closed&#13;
  uint public ico_finish = start_declaration + (ico_period * 1 days).mul(6);&#13;
&#13;
&#13;
  // Limmits and callculation of total minted Basis token&#13;
    uint public constant hardcap = 1536000;&#13;
    // minimal for softcap&#13;
    uint public softcap = 150000;&#13;
    // Total suplied Basis token during ICO&#13;
    uint public bssTotalSuply;&#13;
    // Wei raised during ICO&#13;
    uint public weiRaised;&#13;
  //  list of owners and token balances &#13;
    mapping(address =&gt; uint) public ico_balances;&#13;
  //  list of owners and ether balances for refund    &#13;
    mapping(address =&gt; uint) public ico_investor;&#13;
   &#13;
    event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);&#13;
    event  Finalized();  &#13;
    event Transfer(address indexed from, address indexed to, uint256 value);    &#13;
    event Approval(address indexed owner, address indexed spender, uint256 value);&#13;
&#13;
    &#13;
    bool RefundICO =false;&#13;
    bool isFinalized =false;&#13;
    // The map of allowed tokens for external address access&#13;
    mapping (address =&gt; mapping (address =&gt; uint256)) allowed;&#13;
    &#13;
// The constractor of contract ...&#13;
  function BasisIco() public     {&#13;
&#13;
 &#13;
    weiRaised = 0;&#13;
    bssTotalSuply = 0;&#13;
  &#13;
    &#13;
    token_iso_price = rate.mul(80).div(100); &#13;
&#13;
&#13;
&#13;
    presale_finish = start_declaration + (ico_period * 1 days);&#13;
    second_round_start = start_declaration + (ico_period * 1 days).mul(2);&#13;
  }&#13;
  &#13;
    modifier saleIsOn() {&#13;
      require(now &gt; start_declaration &amp;&amp; now &lt; ico_finish);&#13;
      _;&#13;
    }&#13;
&#13;
    modifier NoBreak() {&#13;
      require(now &lt; presale_finish  || now &gt; second_round_start);&#13;
      _;&#13;
    }&#13;
&#13;
    modifier isUnderHardCap() {&#13;
      require (bssTotalSuply &lt;= hardcap);&#13;
      _;&#13;
    }  &#13;
    &#13;
    modifier onlyOwner() {&#13;
         address inp_sender = msg.sender;&#13;
         bool chekk = msg.sender == owner;&#13;
        require(chekk);&#13;
    _;&#13;
     }&#13;
  &#13;
    function setPrice () public isUnderHardCap saleIsOn {&#13;
          if  (now &lt; presale_finish ){&#13;
               // Chek total supply BSS for price level changes&#13;
              if( bssTotalSuply &gt; 50000 &amp;&amp; bssTotalSuply &lt;= 100000 ) {&#13;
                  token_iso_price = rate.mul(85).div(100);&#13;
              }&#13;
                if( bssTotalSuply &gt; 100000 &amp;&amp; bssTotalSuply &lt;= 150000 ) {&#13;
                  token_iso_price = rate.mul(90).div(100);&#13;
                  }&#13;
&#13;
          }&#13;
          else {&#13;
               if(bssTotalSuply &lt;= 200000) {&#13;
                   token_iso_price = rate.mul(90).div(100);&#13;
               } else { if(bssTotalSuply &lt;= 400000) {&#13;
                        token_iso_price = rate.mul(95).div(100);&#13;
                        }&#13;
                        else {&#13;
                        token_iso_price = rate;&#13;
                        }&#13;
                      }&#13;
           }&#13;
    } &#13;
    &#13;
    function getActualPrice() public returns (uint) {&#13;
        setPrice ();        &#13;
        return token_iso_price;&#13;
    }  &#13;
    &#13;
     function validPurchase(uint _msg_value) internal constant returns (bool) {&#13;
     bool withinPeriod = now &gt;= start_declaration &amp;&amp; now &lt;= ico_finish;&#13;
     bool nonZeroPurchase = _msg_value != 0;&#13;
     return withinPeriod &amp;&amp; nonZeroPurchase;&#13;
   }&#13;
   &#13;
   function token_mint(address _investor, uint _tokens, uint _wei) internal {&#13;
       &#13;
       ico_balances[_investor] = ico_balances[_investor].add(_tokens);&#13;
       tmp_investor.holder = _investor;&#13;
       tmp_investor.tokens = _tokens;&#13;
       Cast_Arr.push(tmp_investor);&#13;
       ico_investor[_investor]= ico_investor[_investor].add(_wei);&#13;
   }&#13;
    &#13;
   function buyTokens() external payable saleIsOn NoBreak {&#13;
     &#13;
     //require(beneficiary != address(0));&#13;
     require(validPurchase(msg.value));&#13;
&#13;
     uint256 weiAmount = msg.value;&#13;
&#13;
     // calculate token amount to be created&#13;
     uint256 tokens = weiAmount.div(token_iso_price);&#13;
     if  (now &lt; presale_finish ){&#13;
         require ((bssTotalSuply + tokens) &lt;= softcap);&#13;
     }&#13;
    require ((bssTotalSuply + tokens) &lt; hardcap);&#13;
     // update state&#13;
     weiRaised = weiRaised.add(weiAmount);&#13;
&#13;
     token_mint( msg.sender, tokens, msg.value);&#13;
     TokenPurchase(msg.sender, msg.sender, weiAmount, tokens);&#13;
&#13;
     //forwardFunds();&#13;
     bssTotalSuply += tokens;&#13;
    }&#13;
&#13;
   // fallback function can be used to buy tokens&#13;
   function () external payable {&#13;
     buyTokensFor(msg.sender);&#13;
   } &#13;
&#13;
   function buyTokensFor(address beneficiary) public payable saleIsOn NoBreak {&#13;
     &#13;
     require(beneficiary != address(0));&#13;
     require(validPurchase(msg.value));&#13;
&#13;
     uint256 weiAmount = msg.value;&#13;
&#13;
     // calculate token amount to be created&#13;
     uint256 tokens = weiAmount.div(token_iso_price);&#13;
      if  (now &lt; presale_finish ){&#13;
         require ((bssTotalSuply + tokens) &lt;= softcap);&#13;
     }&#13;
    require ((bssTotalSuply + tokens) &lt; hardcap);&#13;
     // update state&#13;
     weiRaised = weiRaised.add(weiAmount);&#13;
&#13;
     token_mint( beneficiary, tokens, msg.value);&#13;
     TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);&#13;
&#13;
     //forwardFunds();&#13;
     bssTotalSuply += tokens;&#13;
 }&#13;
 &#13;
   function extraTokenMint(address beneficiary, uint _tokens) external payable saleIsOn onlyOwner {&#13;
     &#13;
    require(beneficiary != address(0));&#13;
    require ((bssTotalSuply + _tokens) &lt; hardcap);&#13;
    &#13;
    uint weiAmount = _tokens.mul(token_iso_price);&#13;
     // update state&#13;
    weiRaised = weiRaised.add(weiAmount);&#13;
&#13;
     token_mint( beneficiary, _tokens, msg.value);&#13;
     TokenPurchase(msg.sender, beneficiary, weiAmount, _tokens);&#13;
&#13;
     //forwardFunds();&#13;
     bssTotalSuply += _tokens;&#13;
  }&#13;
&#13;
  function goalReached() public constant returns (bool) {&#13;
    return bssTotalSuply &gt;= softcap;&#13;
  }&#13;
  &#13;
  function bounty_mining () internal {&#13;
    uint bounty_tokens = bssTotalSuply.mul(bountyPercent).div(100);&#13;
    uint tmp_z = 0;&#13;
    token_mint(owner_wallet, bounty_tokens, tmp_z);&#13;
    bssTotalSuply += bounty_tokens;&#13;
    }  &#13;
  &#13;
  // vault finalization task, called when owner calls finalize()&#13;
  function finalization() public onlyOwner {&#13;
    require (now &gt; ico_finish);&#13;
    if (goalReached()) {&#13;
        bounty_mining ();&#13;
        EtherTakeAfterSoftcap ();&#13;
        } &#13;
    else {&#13;
        RefundICO = true;    &#13;
    }&#13;
    isFinalized = true;&#13;
    Finalized();&#13;
  }  &#13;
&#13;
  function investor_Refund()  public {&#13;
        require (RefundICO &amp;&amp; isFinalized);&#13;
        address investor = msg.sender;&#13;
        uint for_refund = ico_investor[msg.sender];&#13;
        investor.transfer(for_refund);&#13;
&#13;
  }&#13;
  &#13;
  function EtherTakeAfterSoftcap () onlyOwner public {&#13;
      require ( bssTotalSuply &gt;= softcap );&#13;
      uint for_developer = this.balance;&#13;
      for_developer = for_developer.mul(6).div(100);&#13;
      developer.transfer(for_developer);&#13;
      owner.transfer(this.balance);&#13;
  }&#13;
&#13;
  function balanceOf(address _owner) constant public returns (uint256 balance) {&#13;
    return ico_balances[_owner];&#13;
  }&#13;
  &#13;
   function transfer(address _to, uint256 _value) public returns (bool) {&#13;
    ico_balances[msg.sender] = ico_balances[msg.sender].sub(_value);&#13;
    ico_balances[_to] = ico_balances[_to].add(_value);&#13;
    Transfer(msg.sender, _to, _value);&#13;
    return true;&#13;
  } &#13;
&#13;
  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {&#13;
    var _allowance = allowed[_from][msg.sender];&#13;
&#13;
    // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met&#13;
    require (_value &lt;= _allowance);&#13;
&#13;
    ico_balances[_to] = ico_balances[_to].add(_value);&#13;
    ico_balances[_from] = ico_balances[_from].sub(_value);&#13;
    allowed[_from][msg.sender] = _allowance.sub(_value);&#13;
    Transfer(_from, _to, _value);&#13;
    return true;&#13;
  }&#13;
  &#13;
  function approve(address _spender, uint256 _value) public returns (bool) {&#13;
&#13;
    require((_value == 0) || (allowed[msg.sender][_spender] == 0));&#13;
&#13;
    allowed[msg.sender][_spender] = _value;&#13;
    Approval(msg.sender, _spender, _value);&#13;
    return true;&#13;
  }  &#13;
&#13;
  function allowance(address _owner, address _spender) constant public returns (uint256 remaining) {&#13;
    return allowed[_owner][_spender];&#13;
  }&#13;
&#13;
}