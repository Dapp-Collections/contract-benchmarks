/*
 * Safe Math Smart Contract.
 * Author: Mikhail Vladimirov <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="2c414547444d4540025a404d484541455e435a6c4b414d4540024f4341">[email protected]</a>&gt;&#13;
 */&#13;
pragma solidity ^0.4.16;&#13;
&#13;
/**&#13;
 * Provides methods to safely add, subtract and multiply uint256 numbers.&#13;
 */&#13;
contract SafeMath {&#13;
  uint256 constant private MAX_UINT256 =&#13;
    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;&#13;
&#13;
  /**&#13;
   * Add two uint256 values, throw in case of overflow.&#13;
   *&#13;
   * @param x first value to add&#13;
   * @param y second value to add&#13;
   * @return x + y&#13;
   */&#13;
  function safeAdd (uint256 x, uint256 y)&#13;
  constant internal&#13;
  returns (uint256 z) {&#13;
    assert (x &lt;= MAX_UINT256 - y);&#13;
    return x + y;&#13;
  }&#13;
&#13;
  /**&#13;
   * Subtract one uint256 value from another, throw in case of underflow.&#13;
   *&#13;
   * @param x value to subtract from&#13;
   * @param y value to subtract&#13;
   * @return x - y&#13;
   */&#13;
  function safeSub (uint256 x, uint256 y)&#13;
  constant internal&#13;
  returns (uint256 z) {&#13;
    assert (x &gt;= y);&#13;
    return x - y;&#13;
  }&#13;
&#13;
  /**&#13;
   * Multiply two uint256 values, throw in case of overflow.&#13;
   *&#13;
   * @param x first value to multiply&#13;
   * @param y second value to multiply&#13;
   * @return x * y&#13;
   */&#13;
  function safeMul (uint256 x, uint256 y)&#13;
  constant internal&#13;
  returns (uint256 z) {&#13;
    if (y == 0) return 0; // Prevent division by zero at the next line&#13;
    assert (x &lt;= MAX_UINT256 / y);&#13;
    return x * y;&#13;
  }&#13;
} &#13;
&#13;
/*&#13;
 * ERC-20 Standard Token Smart Contract Interface.&#13;
 * Author: Mikhail Vladimirov &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="711c181a1910181d5f071d1015181c18031e0731161c10181d5f121e1c">[email protected]</a>&gt;&#13;
 */&#13;
pragma solidity ^0.4.16;&#13;
&#13;
/**&#13;
 * ERC-20 standard token interface, as defined&#13;
 * &lt;a href="http://github.com/ethereum/EIPs/issues/20"&gt;here&lt;/a&gt;.&#13;
 */&#13;
contract Token {&#13;
  /**&#13;
   * Get total number of tokens in circulation.&#13;
   *&#13;
   * @return total number of tokens in circulation&#13;
   */&#13;
  function totalSupply () constant returns (uint256 supply);&#13;
&#13;
  /**&#13;
   * Get number of tokens currently belonging to given owner.&#13;
   *&#13;
   * @param _owner address to get number of tokens currently belonging to the&#13;
   *        owner of&#13;
   * @return number of tokens currently belonging to the owner of given address&#13;
   */&#13;
  function balanceOf (address _owner) constant returns (uint256 balance);&#13;
&#13;
  /**&#13;
   * Transfer given number of tokens from message sender to given recipient.&#13;
   *&#13;
   * @param _to address to transfer tokens to the owner of&#13;
   * @param _value number of tokens to transfer to the owner of given address&#13;
   * @return true if tokens were transferred successfully, false otherwise&#13;
   */&#13;
  function transfer (address _to, uint256 _value) returns (bool success);&#13;
&#13;
  /**&#13;
   * Transfer given number of tokens from given owner to given recipient.&#13;
   *&#13;
   * @param _from address to transfer tokens from the owner of&#13;
   * @param _to address to transfer tokens to the owner of&#13;
   * @param _value number of tokens to transfer from given owner to given&#13;
   *        recipient&#13;
   * @return true if tokens were transferred successfully, false otherwise&#13;
   */&#13;
  function transferFrom (address _from, address _to, uint256 _value)&#13;
  returns (bool success);&#13;
&#13;
  /**&#13;
   * Allow given spender to transfer given number of tokens from message sender.&#13;
   *&#13;
   * @param _spender address to allow the owner of to transfer tokens from&#13;
   *        message sender&#13;
   * @param _value number of tokens to allow to transfer&#13;
   * @return true if token transfer was successfully approved, false otherwise&#13;
   */&#13;
  function approve (address _spender, uint256 _value) returns (bool success);&#13;
&#13;
  /**&#13;
   * Tell how many tokens given spender is currently allowed to transfer from&#13;
   * given owner.&#13;
   *&#13;
   * @param _owner address to get number of tokens allowed to be transferred&#13;
   *        from the owner of&#13;
   * @param _spender address to get number of tokens allowed to be transferred&#13;
   *        by the owner of&#13;
   * @return number of tokens given spender is currently allowed to transfer&#13;
   *         from given owner&#13;
   */&#13;
  function allowance (address _owner, address _spender) constant&#13;
  returns (uint256 remaining);&#13;
&#13;
  /**&#13;
   * Logged when tokens were transferred from one owner to another.&#13;
   *&#13;
   * @param _from address of the owner, tokens were transferred from&#13;
   * @param _to address of the owner, tokens were transferred to&#13;
   * @param _value number of tokens transferred&#13;
   */&#13;
  event Transfer (address indexed _from, address indexed _to, uint256 _value);&#13;
&#13;
  /**&#13;
   * Logged when owner approved his tokens to be transferred by some spender.&#13;
   *&#13;
   * @param _owner owner who approved his tokens to be transferred&#13;
   * @param _spender spender who were allowed to transfer the tokens belonging&#13;
   *        to the owner&#13;
   * @param _value number of tokens belonging to the owner, approved to be&#13;
   *        transferred by the spender&#13;
   */&#13;
  event Approval (&#13;
    address indexed _owner, address indexed _spender, uint256 _value);&#13;
} &#13;
&#13;
/*&#13;
 * Abstract base contract for Token Smart Contracts that may create snapshots of&#13;
 * token holder balances.&#13;
 * Author: Mikhail Vladimirov &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="85e8eceeede4ece9abf3e9e4e1ece8ecf7eaf3c5e2e8e4ece9abe6eae8">[email protected]</a>&gt;&#13;
 */&#13;
pragma solidity ^0.4.16;&#13;
&#13;
&#13;
/**&#13;
 * Abstract base contract Token Smart Contracts that support snapshots of token&#13;
 * holder balances.&#13;
 */&#13;
contract AbstractSnapshottableToken is SafeMath, Token {&#13;
  /**&#13;
   * Maximum number of tokens in circulation (2^256 - 1).&#13;
   */&#13;
  uint256 constant MAX_TOKENS = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;&#13;
&#13;
  /**&#13;
   * Maximum value of uint256 type, i.e. 2^256-1.&#13;
   */&#13;
  uint256 constant MAX_UINT256 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;&#13;
&#13;
  /**&#13;
   * Maximum value of address represented as uint256, i.e. 2^160-1.&#13;
   */&#13;
  uint256 constant MAX_ADDRESS = 0x00FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;&#13;
&#13;
  /**&#13;
   * 2^160.&#13;
   */&#13;
  uint256 constant TWO_160 = 0x00010000000000000000000000000000000000000000;&#13;
&#13;
  /**&#13;
   * Create new Abstract Snapshottable Token smart contract.&#13;
   */&#13;
  function AbstractSnapshottableToken () {&#13;
    snapshots.length = 1; // Reserve zero ID.&#13;
  }&#13;
&#13;
  /**&#13;
   * Get total number of tokens in circulation.&#13;
   *&#13;
   * @return total number of tokens in circulation&#13;
   */&#13;
  function totalSupply () constant returns (uint256 supply) {&#13;
    return tokensCount;&#13;
  }&#13;
&#13;
  /**&#13;
   * Get total number of tokens in circulation as is was at the moment when&#13;
   * snapshot with given index was created.&#13;
   *&#13;
   * @param _index index of the snapshot to get total number of tokens in&#13;
   *        circulation at the moment of&#13;
   * @return total number of tokens in circulation at the moment snapshot with&#13;
   *         given index was created&#13;
   */&#13;
  function totalSupplyAt (uint256 _index) constant returns (uint256 supply) {&#13;
    require (_index &gt; 0);&#13;
    require (_index &lt; snapshots.length);&#13;
&#13;
    return snapshots [_index].tokensCount;&#13;
  }&#13;
&#13;
  /**&#13;
   * Get number of tokens currently belonging to the owner of given address.&#13;
   *&#13;
   * @param _owner address to get number of tokens currently belonging to the&#13;
   *        owner of&#13;
   * @return number of tokens currently belonging to the owner of given address&#13;
   */&#13;
  function balanceOf (address _owner) constant returns (uint256 balance) {&#13;
    return accounts [_owner].balance;&#13;
  }&#13;
&#13;
  /**&#13;
   * Get number of tokens owner of the given address had at the moment when&#13;
   * snapshot with given index was created.&#13;
   *&#13;
   * @param _owner address to get number of tokens for the owner of&#13;
   * @param _index index of the snapshot to get number of tokens at the time of&#13;
   * @return number of tokens owner of the given address had at the moment the&#13;
   *         snapshot with given index was created&#13;
   */&#13;
  function balanceOfAt (address _owner, uint256 _index)&#13;
    constant returns (uint256 balance) {&#13;
    require (_index &gt; 0);&#13;
    require (_index &lt; snapshots.length);&#13;
&#13;
    if (_index &gt; accounts [_owner].lastSnapshotIndex)&#13;
      return accounts [_owner].balance;&#13;
    else {&#13;
      uint8 level = 0;&#13;
      while (_index &gt; 0) {&#13;
        uint256 v = historicalBalances [_owner][level][_index];&#13;
        if (v != 0) return v;&#13;
&#13;
        _index &gt;&gt;= 1;&#13;
        level += 1; // Overflow is possible here, but is harmless&#13;
      }&#13;
&#13;
      return 0;&#13;
    }&#13;
  }&#13;
&#13;
  /**&#13;
   * Get first address that probably had non-zero token balance at the moment&#13;
   * snapshot with given index was created.&#13;
   *&#13;
   * @param _index index of the snapshot to get first address the probably had&#13;
   *        non-zero token balance at the moment of&#13;
   * @return flag that tells whether there is at least one address that probably&#13;
   *         had non-zero token balance at the moment of snapshot with given&#13;
   *         index (hasResult); and the fist address that probably had non-zero&#13;
   *         token balance at the moment snapshot with given index was created&#13;
   *         or zero if there are no such addresses (result)&#13;
   */&#13;
  function firstAddressAt (uint256 _index)&#13;
    constant returns (bool hasResult, address result) {&#13;
    require (_index &gt; 0);&#13;
    require (_index &lt; snapshots.length);&#13;
    uint256 rawFirstAddress = snapshots [_index].firstAddress;&#13;
    hasResult = rawFirstAddress != MAX_UINT256;&#13;
    result = hasResult ?&#13;
      address (rawFirstAddress &amp; MAX_ADDRESS) :&#13;
        0;&#13;
  }&#13;
&#13;
  /**&#13;
   * Get next address that probably had non-zero token balance at the moment&#13;
   * certain snapshot was created.&#13;
   *&#13;
   * @param _address previous address that probably had non-zero token balance&#13;
   *        at the moment of certain snapshot&#13;
   * @return flag that tells whether there is next address that probably had&#13;
   *         non-zero token balance at the moment of snapshot with given index&#13;
   *         (hasResult); and the next address that probably had non-zero&#13;
   *         token balance at the moment of snapshot with given index was&#13;
   *         created or zero if there are no such addresses (result)&#13;
   */&#13;
  function nextAddress (address _address)&#13;
    constant returns (bool hasResult, address result) {&#13;
    uint256 rawNextAddress = nextAddresses [_address];&#13;
    require (rawNextAddress != 0);&#13;
    hasResult = rawNextAddress != MAX_UINT256;&#13;
    result = hasResult ?&#13;
      address (rawNextAddress &amp; MAX_ADDRESS) :&#13;
        0;&#13;
  }&#13;
&#13;
  /**&#13;
   * Transfer given number of tokens from message sender to given recipient.&#13;
   *&#13;
   * @param _to address to transfer tokens to the owner of&#13;
   * @param _value number of tokens to transfer to the owner of given address&#13;
   * @return true if tokens were transferred successfully, false otherwise&#13;
   */&#13;
  function transfer (address _to, uint256 _value) returns (bool success) {&#13;
    return doTransfer (msg.sender, _to, _value);&#13;
  }&#13;
&#13;
  /**&#13;
   * Transfer given number of tokens from given owner to given recipient.&#13;
   *&#13;
   * @param _from address to transfer tokens from the owner of&#13;
   * @param _to address to transfer tokens to the owner of&#13;
   * @param _value number of tokens to transfer from given owner to given&#13;
   *        recipient&#13;
   * @return true if tokens were transferred successfully, false otherwise&#13;
   */&#13;
  function transferFrom (address _from, address _to, uint256 _value)&#13;
  returns (bool success) {&#13;
    if (_value &gt; approved [_from][msg.sender]) return false;&#13;
    else if (doTransfer (_from, _to, _value)) {&#13;
      approved [_from][msg.sender] =&#13;
        safeSub (approved[_from][msg.sender], _value);&#13;
      return true;&#13;
    } else return false;&#13;
  }&#13;
&#13;
  /**&#13;
   * Allow given spender to transfer given number of tokens from message sender.&#13;
   *&#13;
   * @param _spender address to allow the owner of to transfer tokens from&#13;
   *        message sender&#13;
   * @param _value number of tokens to allow to transfer&#13;
   * @return true if token transfer was successfully approved, false otherwise&#13;
   */&#13;
  function approve (address _spender, uint256 _value) returns (bool success) {&#13;
    approved [msg.sender][_spender] = _value;&#13;
    Approval (msg.sender, _spender, _value);&#13;
    return true;&#13;
  }&#13;
&#13;
  /**&#13;
   * Tell how many tokens given spender is currently allowed to transfer from&#13;
   * given owner.&#13;
   *&#13;
   * @param _owner address to get number of tokens allowed to be transferred&#13;
   *        from the owner of&#13;
   * @param _spender address to get number of tokens allowed to be transferred&#13;
   *        by the owner of&#13;
   * @return number of tokens given spender is currently allowed to transfer&#13;
   *         from given owner&#13;
   */&#13;
  function allowance (address _owner, address _spender) constant&#13;
  returns (uint256 remaining) {&#13;
    return approved [_owner][_spender];&#13;
  }&#13;
&#13;
  /**&#13;
   * Create snapshot of token holder balances.&#13;
   *&#13;
   * @return index of new created snapshot&#13;
   */&#13;
  function snapshot () returns (uint256 index) {&#13;
    index = snapshots.length++;&#13;
    snapshots [index].tokensCount = tokensCount;&#13;
    snapshots [index].firstAddress = firstAddress;&#13;
    Snapshot (index);&#13;
  }&#13;
&#13;
  /**&#13;
   * Transfer given number of tokens from the owner of given from address to the&#13;
   * owner of given to address.&#13;
   *&#13;
   * @param _from address to transfer tokens from the owner of&#13;
   * @param _to address to transfer tokens to the owner of&#13;
   * @param _value number of tokens to transfer&#13;
   * @return true if tokens were transferred successfully, false otherwise&#13;
   */&#13;
  function doTransfer (address _from, address _to, uint256 _value)&#13;
    internal returns (bool success) {&#13;
    if (_value &gt; accounts [_from].balance) return false;&#13;
    else if (_value &gt; 0 &amp;&amp; _from != _to) {&#13;
      saveAddress (_to);&#13;
      updateHistoricalBalances (_from);&#13;
      updateHistoricalBalances (_to);&#13;
      accounts [_from].balance = safeSub (accounts [_from].balance, _value);&#13;
      accounts [_to].balance = safeAdd (accounts [_to].balance, _value);&#13;
      Transfer (_from, _to, _value);&#13;
      return true;&#13;
    } else return true;&#13;
  }&#13;
&#13;
  /**&#13;
   * Create given number of tokens and give them to message sender.&#13;
   *&#13;
   * @param _value number of tokens to create&#13;
   * @return true on success, false on error&#13;
   */&#13;
  function doCreateTokens (uint256 _value) internal returns (bool success) {&#13;
    if (_value &gt; safeSub (MAX_TOKENS, tokensCount)) return false;&#13;
    else if (_value &gt; 0) {&#13;
      saveAddress (msg.sender);&#13;
      updateHistoricalBalances (msg.sender);&#13;
      accounts [msg.sender].balance =&#13;
        safeAdd (accounts [msg.sender].balance, _value);&#13;
      tokensCount = safeAdd (tokensCount, _value);&#13;
      return true;&#13;
    } else return true;&#13;
  }&#13;
&#13;
  /**&#13;
   * Update historical balances for given token owner.&#13;
   *&#13;
   * @param _owner token owner to update historical balances for&#13;
   */&#13;
  function updateHistoricalBalances (address _owner) internal {&#13;
    uint256 balance = accounts [_owner].balance;&#13;
    uint256 nextSnapshotIndex = snapshots.length;&#13;
    uint256 lastNextSnapshotIndex =&#13;
      safeAdd (accounts [_owner].lastSnapshotIndex, 1);&#13;
    if (nextSnapshotIndex &gt; lastNextSnapshotIndex) {&#13;
      if (balance &gt; 0) {&#13;
        setHistoricalBalance (&#13;
          _owner, lastNextSnapshotIndex, nextSnapshotIndex, balance);&#13;
      }&#13;
      accounts [_owner].lastSnapshotIndex =&#13;
        safeSub (nextSnapshotIndex, 1);&#13;
    }&#13;
  }&#13;
&#13;
  /**&#13;
   * Set historical balance for the owner of given address as it was at the&#13;
   * moments of snapshots with indexes in given range.&#13;
   *&#13;
   * @param _owner address to set the historical balance for the owner of&#13;
   * @param _from beginning of the snapshot index range (inclusive)&#13;
   * @param _to end of the snapshot index range (exclusive)&#13;
   * @param _balance value to set balance to&#13;
   */&#13;
  function setHistoricalBalance (&#13;
    address _owner, uint256 _from, uint256 _to, uint256 _balance)&#13;
    internal {&#13;
    assert (_from &gt; 0);&#13;
    assert (_to &gt;= _from);&#13;
    assert (_balance &gt; 0);&#13;
&#13;
    uint8 level = 0;&#13;
    while (_from &lt; _to) {&#13;
      if (_from &amp; 1 == 1) {&#13;
        // Overflow is not possible here because _from &lt; _to&#13;
        historicalBalances [_owner][level][_from++] = _balance;&#13;
      }&#13;
&#13;
      if (_to &amp; 1 == 1) {&#13;
        // Underflow is not possible here, because _to &amp; 1 == 1&#13;
        historicalBalances [_owner][level][--_to] = _balance;&#13;
      }&#13;
&#13;
      _from &gt;&gt;= 1;&#13;
      _to &gt;&gt;= 1;&#13;
      level += 1; // Even for snapshot index range 1..2^256-1 overflow will&#13;
                  // not happen here&#13;
    }&#13;
  }&#13;
&#13;
  /**&#13;
   * Add address to the list of addresses that ever had non-zero token balance.&#13;
   *&#13;
   * @param _address address to be added to the list of addresses that ever had&#13;
   *        non-zero token balance&#13;
   */&#13;
  function saveAddress (address _address) internal {&#13;
    if (nextAddresses [_address] == 0) {&#13;
      nextAddresses [_address] = firstAddress;&#13;
      firstAddress = TWO_160 | uint256(_address);&#13;
    }&#13;
  }&#13;
&#13;
  /**&#13;
   * Total number of tokens in circulation.&#13;
   */&#13;
  uint256 tokensCount;&#13;
&#13;
  /**&#13;
   * All snapshots ever created.&#13;
   */&#13;
  SnapshotInfo [] snapshots;&#13;
&#13;
  /**&#13;
   * Maps addresses of token owners to states of their accounts.&#13;
   */&#13;
  mapping (address =&gt; Account) accounts;&#13;
&#13;
  /**&#13;
   * First address that ever had non-zero token balance plus 2^160, or 2^256-1&#13;
   * if there are no such addresses.&#13;
   */&#13;
  uint256 firstAddress = MAX_UINT256;&#13;
&#13;
  /**&#13;
   * Mapping from address that ever had non-zero token balance to the next&#13;
   * address that ever had non-zero token balance plus 2^160 or 2^256-1 if there&#13;
   * are no more such addresses.&#13;
   */&#13;
  mapping (address =&gt; uint256) nextAddresses;&#13;
&#13;
  /**&#13;
   * Historical balances of token owners.  If for some address, level and index,&#13;
   * where level &gt;= 0 and index &gt; 0, historicalBalances[address][level][index]&#13;
   * is non-zero, then owner of given address had this many tokens at the&#13;
   * time moments of snapshots with indexes from (index * 2^level) to&#13;
   * ((index + 1) * 2^level - 1) inclusive.&#13;
   * For each snapshot, there should be at most one level with non-zero&#13;
   * value at corresponding index.&#13;
   */&#13;
  mapping (address =&gt; mapping (uint8 =&gt; mapping (uint256 =&gt; uint256)))&#13;
    historicalBalances;&#13;
&#13;
  /**&#13;
   * Maps addresses of token owners to mappings from addresses of spenders to&#13;
   * how many tokens belonging to the owner, the spender is currently allowed to&#13;
   * transfer.&#13;
   */&#13;
  mapping (address =&gt; mapping (address =&gt; uint256)) approved;&#13;
&#13;
  /**&#13;
   * Encapsulates information about snapshot.&#13;
   */&#13;
  struct SnapshotInfo {&#13;
    /**&#13;
     * Total number of tokens in circulation at the moment of snapshot.&#13;
     */&#13;
    uint256 tokensCount;&#13;
&#13;
    /**&#13;
     * Value of firstAddress field at the moment of snapshot.&#13;
     */&#13;
    uint256 firstAddress;&#13;
  }&#13;
&#13;
  /**&#13;
   * Encapsulates information about token owner's balance.&#13;
   */&#13;
  struct Account {&#13;
    /**&#13;
     * Number of tokens currently belonging to the token owner.&#13;
     */&#13;
    uint256 balance;&#13;
&#13;
    /**&#13;
     * Index of the last snapshot before the moment historical balances were&#13;
     * last updated for this token owner.&#13;
     */&#13;
    uint256 lastSnapshotIndex;&#13;
  }&#13;
&#13;
  /**&#13;
   * Logged when new snapshot was created.&#13;
   *&#13;
   * @param _index index of the new snapshot&#13;
   */&#13;
  event Snapshot (uint256 indexed _index);&#13;
}&#13;
&#13;
&#13;
/*&#13;
 * Standard Snapshottable Token Smart Contract.&#13;
 * Author: Mikhail Vladimirov &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="87eaeeecefe6eeeba9f1ebe6e3eeeaeef5e8f1c7e0eae6eeeba9e4e8ea">[email protected]</a>&gt;&#13;
 */&#13;
&#13;
/**&#13;
 * Standard Snapshottable Token Smart Contract.&#13;
 */&#13;
contract StandardSnapshottableToken is AbstractSnapshottableToken {&#13;
  /**&#13;
   * Create new Standard Snapshottable Token Smart Contract and make&#13;
   * message sender the owner of the smart contract.&#13;
   */&#13;
  function StandardSnapshottableToken ()&#13;
    AbstractSnapshottableToken () {&#13;
    owner = msg.sender;&#13;
  }&#13;
&#13;
  /**&#13;
   * Transfer given number of tokens from message sender to given recipient.&#13;
   *&#13;
   * @param _to address to transfer tokens to the owner of&#13;
   * @param _value number of tokens to transfer to the owner of given address&#13;
   * @return true if tokens were transferred successfully, false otherwise&#13;
   */&#13;
  function transfer (address _to, uint256 _value) returns (bool success) {&#13;
    if (frozen) return false;&#13;
    else return AbstractSnapshottableToken.transfer (_to, _value);&#13;
  }&#13;
&#13;
  /**&#13;
   * Transfer given number of tokens from given owner to given recipient.&#13;
   *&#13;
   * @param _from address to transfer tokens from the owner of&#13;
   * @param _to address to transfer tokens to the owner of&#13;
   * @param _value number of tokens to transfer from given owner to given&#13;
   *        recipient&#13;
   * @return true if tokens were transferred successfully, false otherwise&#13;
   */&#13;
  function transferFrom (address _from, address _to, uint256 _value)&#13;
  returns (bool success) {&#13;
    if (frozen) return false;&#13;
    else&#13;
      return AbstractSnapshottableToken.transferFrom (_from, _to, _value);&#13;
  }&#13;
&#13;
  /**&#13;
   * Create given number of tokens and give them to message sender.  May only be&#13;
   * called by the owner of the smart contract.&#13;
   *&#13;
   * @param _value number of tokens to create&#13;
   * @return true on success, false on error&#13;
   */&#13;
  function createTokens (uint256 _value) returns (bool success) {&#13;
    require (msg.sender == owner);&#13;
&#13;
    return doCreateTokens (_value);&#13;
  }&#13;
&#13;
  /**&#13;
   * Freeze token transfers.  May only be called by the owner of the smart&#13;
   * contract.&#13;
   */&#13;
  function freezeTransfers () {&#13;
    require (msg.sender == owner);&#13;
&#13;
    if (!frozen)&#13;
    {&#13;
      frozen = true;&#13;
      Freeze ();&#13;
    }&#13;
  }&#13;
&#13;
  /**&#13;
   * Unfreeze token transfers.  May only be called by the owner of the smart&#13;
   * contract.&#13;
   */&#13;
  function unfreezeTransfers () {&#13;
    require (msg.sender == owner);&#13;
&#13;
    if (frozen) {&#13;
      frozen = false;&#13;
      Unfreeze ();&#13;
    }&#13;
  }&#13;
&#13;
  /**&#13;
   * Set new owner address.  May only be called by the owner of the smart&#13;
   * contract.&#13;
   *&#13;
   * @param _newOwner new owner address&#13;
   */&#13;
  function setOwner (address _newOwner) {&#13;
    require (msg.sender == owner);&#13;
&#13;
    owner = _newOwner;&#13;
  }&#13;
&#13;
  /**&#13;
   * Owner of this smart contract.&#13;
   */&#13;
  address owner;&#13;
&#13;
  /**&#13;
   * Whether token transfers are currently frozen.&#13;
   */&#13;
  bool frozen;&#13;
&#13;
  /**&#13;
   * Logged when token transfers were frozen.&#13;
   */&#13;
  event Freeze ();&#13;
&#13;
  /**&#13;
   * Logged when token transfers were unfrozen.&#13;
   */&#13;
  event Unfreeze ();&#13;
}&#13;
&#13;
&#13;
/*&#13;
 * Science Blockchain Token Smart Contract.&#13;
 * Author: Mikhail Vladimirov &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="e08d898b8881898cce968c8184898d89928f96a0878d81898cce838f8d">[email protected]</a>&gt;&#13;
 */&#13;
&#13;
/**&#13;
 * Science Blockchain Token Smart Contract.&#13;
 */&#13;
contract ScienceBlockchainToken is StandardSnapshottableToken {&#13;
  /**&#13;
   * Create new Science Blockchain Token smart contract and make message sender&#13;
   * to be the owner of smart contract and to be a snapshot creator.&#13;
   */&#13;
  function ScienceBlockchainToken ()&#13;
    StandardSnapshottableToken () {&#13;
    snapshotCreator = msg.sender;&#13;
  }&#13;
&#13;
  /**&#13;
   * Create snapshot of token holder balances.&#13;
   *&#13;
   * @return index of new created snapshot&#13;
   */&#13;
  function snapshot () returns (uint256 index) {&#13;
    require (msg.sender == snapshotCreator);&#13;
    return AbstractSnapshottableToken.snapshot ();&#13;
  }&#13;
&#13;
  /**&#13;
   * Get name of this token.&#13;
   *&#13;
   * @return name of this token&#13;
   */&#13;
  function name () constant returns (string result) {&#13;
    return "SCIENCE BLOCKCHAIN";&#13;
  }&#13;
&#13;
  /**&#13;
   * Get symbol of this token.&#13;
   *&#13;
   * @return symbol of this token&#13;
   */&#13;
  function symbol () constant returns (string result) {&#13;
    return "SCI";&#13;
  }&#13;
&#13;
  /**&#13;
   * Get number of decimals for this token.&#13;
   *&#13;
   * @return number of decimals for this token&#13;
   */&#13;
  function decimals () constant returns (uint8 result) {&#13;
    return 0;&#13;
  }&#13;
&#13;
  /**&#13;
   * Burn given number of tokens belonging to message sender.&#13;
   *&#13;
   * @param _value number of tokens to burn&#13;
   * @return true if tokens were burned successfully, false otherwise&#13;
   */&#13;
  function burnTokens (uint256 _value) returns (bool success) {&#13;
    uint256 balance = accounts [msg.sender].balance;&#13;
    if (_value &gt; balance) return false;&#13;
    if (_value &gt; 0) {&#13;
      updateHistoricalBalances (msg.sender);&#13;
      accounts [msg.sender].balance = safeSub (balance, _value);&#13;
      tokensCount = safeSub (tokensCount, _value);&#13;
      return true;&#13;
    }&#13;
    return true;&#13;
  }&#13;
&#13;
  /**&#13;
   * Set new snapshot creator address.&#13;
   *&#13;
   * @param _snapshotCreator new snapshot creator address&#13;
   */&#13;
  function setSnapshotCreator (address _snapshotCreator) {&#13;
    require (msg.sender == owner);&#13;
    snapshotCreator = _snapshotCreator;&#13;
  }&#13;
&#13;
  /**&#13;
   * Address of snapshot creator, i.e. the one allowed to create snapshots.&#13;
   */&#13;
  address snapshotCreator;&#13;
}