/**
 * Copyright (C) Virtue Fintech FZ-LLC, Dubai
 * All rights reserved.
 * Author: <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="d8b5b0b198aeb1aaacadbdf6beb1b6b9b6bbbd">[emailÂ protected]</a>&#13;
 *&#13;
 * This code is adapted from OpenZeppelin Project.&#13;
 * more at http://openzeppelin.org.&#13;
 *&#13;
 * MIT License&#13;
 *&#13;
 * Permission is hereby granted, free of charge, to any person obtaining a copy &#13;
 * of this software and associated documentation files (the ""Software""), to &#13;
 * deal in the Software without restriction, including without limitation the &#13;
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or &#13;
 * sell copies of the Software, and to permit persons to whom the Software is &#13;
 * furnished to do so, subject to the following conditions: &#13;
 *  The above copyright notice and this permission notice shall be included in &#13;
 *  all copies or substantial portions of the Software.&#13;
 *&#13;
 * THE SOFTWARE IS PROVIDED AS IS, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR &#13;
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, &#13;
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE &#13;
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER &#13;
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, &#13;
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN &#13;
 * THE SOFTWARE.&#13;
 *&#13;
 */&#13;
pragma solidity ^0.4.11;&#13;
&#13;
library SafeMath {&#13;
    function mul(uint256 a, uint256 b) internal returns (uint256) {&#13;
        uint256 c = a * b;&#13;
        assert(a == 0 || c / a == b);&#13;
        return c;&#13;
    }&#13;
&#13;
    function div(uint256 a, uint256 b) internal returns (uint256) {&#13;
        // assert(b &gt; 0); // Solidity automatically throws when dividing by 0&#13;
        uint256 c = a / b;&#13;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold&#13;
        return c;&#13;
    }&#13;
&#13;
    function sub(uint256 a, uint256 b) internal returns (uint256) {&#13;
        assert(b &lt;= a);&#13;
        return a - b;&#13;
    }&#13;
&#13;
    function add(uint256 a, uint256 b) internal returns (uint256) {&#13;
        uint256 c = a + b;&#13;
        assert(c &gt;= a);&#13;
        return c;&#13;
    }&#13;
}&#13;
&#13;
contract Guarded {&#13;
&#13;
    modifier isValidAmount(uint256 _amount) { &#13;
        require(_amount &gt; 0); &#13;
        _; &#13;
    }&#13;
&#13;
    // ensure address not null, and not this contract address&#13;
    modifier isValidAddress(address _address) {&#13;
        require(_address != 0x0 &amp;&amp; _address != address(this));&#13;
        _;&#13;
    }&#13;
&#13;
}&#13;
&#13;
contract Ownable {&#13;
    address public owner;&#13;
&#13;
    /** &#13;
     * @dev The Ownable constructor sets the original `owner` of the contract to the sender&#13;
     * account.&#13;
     */&#13;
    function Ownable() {&#13;
        owner = msg.sender;&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Throws if called by any account other than the owner. &#13;
     */&#13;
    modifier onlyOwner() {&#13;
        require(msg.sender == owner);&#13;
        _;&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Allows the current owner to transfer control of the contract to a newOwner.&#13;
     * @param newOwner The address to transfer ownership to. &#13;
     */&#13;
    function transferOwnership(address newOwner) onlyOwner {&#13;
        if (newOwner != address(0)) {&#13;
            owner = newOwner;&#13;
        }&#13;
    }&#13;
&#13;
}&#13;
&#13;
contract Claimable is Ownable {&#13;
    address public pendingOwner;&#13;
&#13;
    /**&#13;
     * @dev Modifier throws if called by any account other than the pendingOwner. &#13;
     */&#13;
    modifier onlyPendingOwner() {&#13;
        require(msg.sender == pendingOwner);&#13;
        _;&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Allows the current owner to set the pendingOwner address. &#13;
     * @param newOwner The address to transfer ownership to. &#13;
     */&#13;
    function transferOwnership(address newOwner) onlyOwner {&#13;
        pendingOwner = newOwner;&#13;
    }&#13;
&#13;
    /**&#13;
     * @dev Allows the pendingOwner address to finalize the transfer.&#13;
     */&#13;
    function claimOwnership() onlyPendingOwner {&#13;
        owner = pendingOwner;&#13;
        pendingOwner = 0x0;&#13;
    }&#13;
}&#13;
&#13;
contract ERC20 {&#13;
    &#13;
    /// total amount of tokens&#13;
    uint256 public totalSupply;&#13;
&#13;
    /// @param _owner The address from which the balance will be retrieved&#13;
    /// @return The balance&#13;
    function balanceOf(address _owner) constant returns (uint256 balance);&#13;
&#13;
    /// @notice send `_value` token to `_to` from `msg.sender`&#13;
    /// @param _to The address of the recipient&#13;
    /// @param _value The amount of token to be transferred&#13;
    /// @return Whether the transfer was successful or not&#13;
    function transfer(address _to, uint256 _value) returns (bool success);&#13;
&#13;
    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`&#13;
    /// @param _from The address of the sender&#13;
    /// @param _to The address of the recipient&#13;
    /// @param _value The amount of token to be transferred&#13;
    /// @return Whether the transfer was successful or not&#13;
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);&#13;
&#13;
    /// @notice `msg.sender` approves `_spender` to spend `_value` tokens&#13;
    /// @param _spender The address of the account able to transfer the tokens&#13;
    /// @param _value The amount of tokens to be approved for transfer&#13;
    /// @return Whether the approval was successful or not&#13;
    function approve(address _spender, uint256 _value) returns (bool success);&#13;
&#13;
    /// @param _owner The address of the account owning tokens&#13;
    /// @param _spender The address of the account able to transfer the tokens&#13;
    /// @return Amount of remaining tokens allowed to spent&#13;
    function allowance(address _owner, address _spender) constant returns (uint256 remaining);&#13;
&#13;
    event Transfer(address indexed _from, address indexed _to, uint256 _value);&#13;
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);&#13;
&#13;
}&#13;
&#13;
contract ERC20Token is ERC20 {&#13;
    using SafeMath for uint256;&#13;
&#13;
    string public standard = 'Cryptoken 0.1.1';&#13;
&#13;
    string public name = '';            // the token name&#13;
    string public symbol = '';          // the token symbol&#13;
    uint8 public decimals = 0;          // the number of decimals&#13;
&#13;
    // mapping of our users to balance&#13;
    mapping (address =&gt; uint256) public balances;&#13;
    mapping (address =&gt; mapping (address =&gt; uint256)) public allowed;&#13;
&#13;
    // our constructor. We have fixed everything above, and not as &#13;
    // parameters in the constructor.&#13;
    function ERC20Token(string _name, string _symbol, uint8 _decimals) {&#13;
        name = _name;&#13;
        symbol = _symbol;&#13;
        decimals = _decimals;&#13;
    }&#13;
&#13;
    // get token balance&#13;
    function balanceOf(address _owner) &#13;
        public constant &#13;
        returns (uint256 balance) &#13;
    {&#13;
        return balances[_owner];&#13;
    }    &#13;
&#13;
    /**&#13;
     * make a transfer. This can be called from the token holder.&#13;
     * e.g. Token holder Alice, can issue somethign like this to Bob&#13;
     *      Alice.transfer(Bob, 200);     // to transfer 200 to Bob&#13;
     */&#13;
    /// Initiate a transfer to `_to` with value `_value`?&#13;
    function transfer(address _to, uint256 _value) &#13;
        public returns (bool success) &#13;
    {&#13;
        // sanity check&#13;
        require(_to != address(this));&#13;
&#13;
        // // check for overflows&#13;
        // require(_value &gt; 0 &amp;&amp;&#13;
        //   balances[msg.sender] &lt; _value &amp;&amp;&#13;
        //   balances[_to] + _value &lt; balances[_to]);&#13;
&#13;
        // &#13;
        balances[msg.sender] = balances[msg.sender].sub(_value);&#13;
        balances[_to] = balances[_to].add(_value);&#13;
        &#13;
        // emit transfer event&#13;
        Transfer(msg.sender, _to, _value);&#13;
        return true;&#13;
    }&#13;
&#13;
    /**&#13;
     * make an approved transfer to another account from vault. This operation&#13;
     * should be called after approved operation below.&#13;
     * .e.g Alice allow Bob to spend 30 by doing:&#13;
     *      Alice.approve(Bob, 30);                 // allow 30 to Bob&#13;
     *&#13;
     * and Bob can claim, say 10, from that by doing&#13;
     *      Bob.transferFrom(Alice, Bob, 10);       // spend only 10&#13;
     * and Bob's balance shall be 20 in the allowance.&#13;
     */&#13;
    /// Initiate a transfer of `_value` from `_from` to `_to`&#13;
    function transferFrom(address _from, address _to, uint256 _value)         &#13;
        public returns (bool success) &#13;
    {    &#13;
        // sanity check&#13;
        require(_to != 0x0 &amp;&amp; _from != 0x0);&#13;
        require(_from != _to &amp;&amp; _to != address(this));&#13;
&#13;
        // check for overflows&#13;
        // require(_value &gt; 0 &amp;&amp;&#13;
        //   balances[_from] &gt;= _value &amp;&amp;&#13;
        //   allowed[_from][_to] &lt;= _value &amp;&amp;&#13;
        //   balances[_to] + _value &lt; balances[_to]);&#13;
&#13;
        // update public balance&#13;
        allowed[_from][_to] = allowed[_from][_to].sub(_value);        &#13;
        balances[_from] = balances[_from].sub(_value);&#13;
        balances[_to] = balances[_to].add(_value);&#13;
&#13;
        // emit transfer event&#13;
        Transfer(_from, _to, _value);&#13;
        return true;&#13;
    }&#13;
&#13;
    /**&#13;
     * This method is explained further in https://goo.gl/iaqxBa on the&#13;
     * possible attacks. As such, we have to make sure the value is&#13;
     * drained, before any Alice/Bob can approve each other to&#13;
     * transfer on their behalf.&#13;
     * @param _spender  - the recipient of the value&#13;
     * @param _value    - the value allowed to be spent &#13;
     *&#13;
     * This can be called by the token holder&#13;
     * e.g. Alice can allow Bob to spend 30 on her behalf&#13;
     *      Alice.approve(Bob, 30);     // gives 30 to Bob.&#13;
     */&#13;
    /// Approve `_spender` to claim/spend `_value`?&#13;
    function approve(address _spender, uint256 _value)          &#13;
        public returns (bool success) &#13;
    {&#13;
        // sanity check&#13;
        require(_spender != 0x0 &amp;&amp; _spender != address(this));            &#13;
&#13;
        // if the allowance isn't 0, it can only be updated to 0 to prevent &#13;
        // an allowance change immediately after withdrawal&#13;
        require(allowed[msg.sender][_spender] == 0);&#13;
&#13;
        allowed[msg.sender][_spender] = _value;&#13;
        Approval(msg.sender, _spender, _value);&#13;
        return true;&#13;
    }&#13;
&#13;
    /**&#13;
     * Check the allowance that has been approved previously by owner.&#13;
     */&#13;
    /// check allowance approved from `_owner` to `_spender`?&#13;
    function allowance(address _owner, address _spender)          &#13;
        public constant returns (uint remaining) &#13;
    {&#13;
        // sanity check&#13;
        require(_spender != 0x0 &amp;&amp; _owner != 0x0);&#13;
        require(_owner != _spender &amp;&amp; _spender != address(this));            &#13;
&#13;
        // constant op. Just return the balance.&#13;
        return allowed[_owner][_spender];&#13;
    }&#13;
&#13;
}&#13;
&#13;
contract FaradManufacturing is ERC20Token, Guarded, Claimable {&#13;
&#13;
    uint256 public SUPPLY = 1600000000 ether;   // 1.6b ether;&#13;
&#13;
    // our constructor, just supply the total supply.&#13;
    function FaradManufacturing() &#13;
        ERC20Token('FARAD Manufacturing', 'FRM', 18) &#13;
    {&#13;
        totalSupply = SUPPLY;&#13;
        balances[msg.sender] = SUPPLY;&#13;
    }&#13;
&#13;
}