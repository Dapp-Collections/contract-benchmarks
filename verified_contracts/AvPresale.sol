pragma solidity ^0.4.17;

/// @author developers //NB!
/// @notice <span class="__cf_email__" data-cfemail="a1d2d4d1d1ced3d5e1c5c4d7c4cdced1c4d3d2">[emailÂ protected]</span> //NB!&#13;
/// @title  Contract presale //NB!&#13;
&#13;
contract AvPresale {&#13;
&#13;
    string public constant RELEASE = "0.2.1_AviaTest";&#13;
&#13;
    //config// &#13;
    uint public constant PRESALE_START  = 5298043; /* 22.03.2018 03:07:00 +3GMT */ //NB!&#13;
    uint public constant PRESALE_END    = 5303803; /* 23.03.2018 03:07:00 +3GMT */ //NB!&#13;
    uint public constant WITHDRAWAL_END = 5309563; /* 24.03.2018 03:07:00 +3GMT */ //NB!&#13;
&#13;
    address public constant OWNER = 0x32Bac79f4B6395DEa37f0c2B68b6e26ce24a59EA; //NB!&#13;
&#13;
    uint public constant MIN_TOTAL_AMOUNT_GET_ETH = 1; //NB!&#13;
    uint public constant MAX_TOTAL_AMOUNT_GET_ETH = 2; //NB!&#13;
	//min send value 0.001 ETH (1 finney)&#13;
    uint public constant MIN_GET_AMOUNT_FINNEY = 10; //NB!&#13;
&#13;
    string[5] private standingNames = ["BEFORE_START",  "PRESALE_RUNNING", "WITHDRAWAL_RUNNING", "MONEY_BACK_RUNNING", "CLOSED" ];&#13;
    enum State { BEFORE_START,  PRESALE_RUNNING, WITHDRAWAL_RUNNING, MONEY_BACK_RUNNING, CLOSED }&#13;
&#13;
    uint public total_amount = 0;&#13;
    uint public total_money_back = 0;&#13;
    mapping (address =&gt; uint) public balances;&#13;
&#13;
    uint private constant MIN_TOTAL_AMOUNT_GET = MIN_TOTAL_AMOUNT_GET_ETH * 1 ether;&#13;
    uint private constant MAX_TOTAL_AMOUNT_GET = MAX_TOTAL_AMOUNT_GET_ETH * 1 ether;&#13;
    uint private constant MIN_GET_AMOUNT = MIN_GET_AMOUNT_FINNEY * 1 finney;&#13;
    bool public isTerminated = false;&#13;
    bool public isStopped = false;&#13;
&#13;
&#13;
    function AvPresale () public checkSettings() { }&#13;
&#13;
&#13;
    //methods//&#13;
	&#13;
	//The transfer of money to the owner&#13;
    function sendMoneyOwner() external&#13;
	inStanding(State.WITHDRAWAL_RUNNING)&#13;
    onlyOwner&#13;
    noReentrancy&#13;
    {&#13;
        OWNER.transfer(this.balance);&#13;
    }&#13;
	&#13;
	//Money back to users&#13;
    function moneyBack() external&#13;
    inStanding(State.MONEY_BACK_RUNNING)&#13;
    noReentrancy&#13;
    {&#13;
        sendMoneyBack();&#13;
    }&#13;
	&#13;
    //payments&#13;
    function ()&#13;
    payable&#13;
    noReentrancy&#13;
    public&#13;
    {&#13;
        State state = currentStanding();&#13;
        if (state == State.PRESALE_RUNNING) {&#13;
            getMoney();&#13;
        } else if (state == State.MONEY_BACK_RUNNING) {&#13;
            sendMoneyBack();&#13;
        } else {&#13;
            revert();&#13;
        }&#13;
    }&#13;
&#13;
    //Forced termination&#13;
    function termination() external&#13;
    inStandingBefore(State.MONEY_BACK_RUNNING)&#13;
    onlyOwner&#13;
    {&#13;
        isTerminated = true;&#13;
    }&#13;
&#13;
    //Forced stop with the possibility of withdrawal&#13;
    function stop() external&#13;
    inStanding(State.PRESALE_RUNNING)&#13;
    onlyOwner&#13;
    {&#13;
        isStopped = true;&#13;
    }&#13;
&#13;
&#13;
    //Current status of the contract&#13;
    function standing() external constant&#13;
    returns (string)&#13;
    {&#13;
        return standingNames[ uint(currentStanding()) ];&#13;
    }&#13;
&#13;
    //Method adding money to the user&#13;
    function getMoney() private notTooSmallAmountOnly {&#13;
      if (total_amount + msg.value &gt; MAX_TOTAL_AMOUNT_GET) {&#13;
          var change_to_return = total_amount + msg.value - MAX_TOTAL_AMOUNT_GET;&#13;
          var acceptable_remainder = MAX_TOTAL_AMOUNT_GET - total_amount;&#13;
          balances[msg.sender] += acceptable_remainder;&#13;
          total_amount += acceptable_remainder;&#13;
          msg.sender.transfer(change_to_return);&#13;
      } else {&#13;
          balances[msg.sender] += msg.value;&#13;
          total_amount += msg.value;&#13;
      }&#13;
    }&#13;
	&#13;
	//Method of repayment users &#13;
    function sendMoneyBack() private tokenHoldersOnly {&#13;
        uint amount_to_money_back = min(balances[msg.sender], this.balance - msg.value) ;&#13;
        balances[msg.sender] -= amount_to_money_back;&#13;
        total_money_back += amount_to_money_back;&#13;
        msg.sender.transfer(amount_to_money_back + msg.value);&#13;
    }&#13;
&#13;
    //Determining the current status of the contract&#13;
    function currentStanding() private constant returns (State) {&#13;
        if (isTerminated) {&#13;
            return this.balance &gt; 0&#13;
                   ? State.MONEY_BACK_RUNNING&#13;
                   : State.CLOSED;&#13;
        } else if (block.number &lt; PRESALE_START) {&#13;
            return State.BEFORE_START;&#13;
        } else if (block.number &lt;= PRESALE_END &amp;&amp; total_amount &lt; MAX_TOTAL_AMOUNT_GET &amp;&amp; !isStopped) {&#13;
            return State.PRESALE_RUNNING;&#13;
        } else if (this.balance == 0) {&#13;
            return State.CLOSED;&#13;
        } else if (block.number &lt;= WITHDRAWAL_END &amp;&amp; total_amount &gt;= MIN_TOTAL_AMOUNT_GET) {&#13;
            return State.WITHDRAWAL_RUNNING;&#13;
        } else {&#13;
            return State.MONEY_BACK_RUNNING;&#13;
        }&#13;
    }&#13;
&#13;
    function min(uint a, uint b) pure private returns (uint) {&#13;
        return a &lt; b ? a : b;&#13;
    }&#13;
&#13;
    //Prohibition if the condition does not match&#13;
    modifier inStanding(State state) {&#13;
        require(state == currentStanding());&#13;
        _;&#13;
    }&#13;
&#13;
    //Prohibition if the current state was not before&#13;
    modifier inStandingBefore(State state) {&#13;
        require(currentStanding() &lt; state);&#13;
        _;&#13;
    }&#13;
&#13;
    //Works on users's command&#13;
    modifier tokenHoldersOnly(){&#13;
        require(balances[msg.sender] &gt; 0);&#13;
        _;&#13;
    }&#13;
&#13;
    //Do not accept transactions with a sum less than the configuration limit&#13;
    modifier notTooSmallAmountOnly(){&#13;
        require(msg.value &gt;= MIN_GET_AMOUNT);&#13;
        _;&#13;
    }&#13;
&#13;
    //Prohibition of repeated treatment&#13;
    bool private lock = false;&#13;
    modifier noReentrancy() {&#13;
        require(!lock);&#13;
        lock = true;&#13;
        _;&#13;
        lock = false;&#13;
    }&#13;
	&#13;
	 //Prohibition if it does not match the settings&#13;
    modifier checkSettings() {&#13;
        if ( OWNER == 0x0&#13;
            || PRESALE_START == 0&#13;
            || PRESALE_END == 0&#13;
            || WITHDRAWAL_END ==0&#13;
            || PRESALE_START &lt;= block.number&#13;
            || PRESALE_START &gt;= PRESALE_END&#13;
            || PRESALE_END   &gt;= WITHDRAWAL_END&#13;
            || MIN_TOTAL_AMOUNT_GET &gt; MAX_TOTAL_AMOUNT_GET )&#13;
                revert();&#13;
        _;&#13;
    }&#13;
	&#13;
	//Works on owner's command&#13;
    modifier onlyOwner(){&#13;
        require(msg.sender == OWNER);&#13;
        _;&#13;
    }&#13;
}