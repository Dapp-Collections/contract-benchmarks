// produced by the Solididy File Flattener (c) David Appleton 2018
// contact : <span class="__cf_email__" data-cfemail="5e3a3f283b1e3f3531333c3f703d3133">[emailÂ protected]</span>&#13;
// released under Apache 2.0 licence&#13;
contract Ownable {&#13;
  address public owner;&#13;
&#13;
&#13;
  event OwnershipRenounced(address indexed previousOwner);&#13;
  event OwnershipTransferred(&#13;
    address indexed previousOwner,&#13;
    address indexed newOwner&#13;
  );&#13;
&#13;
&#13;
  /**&#13;
   * @dev The Ownable constructor sets the original `owner` of the contract to the sender&#13;
   * account.&#13;
   */&#13;
  constructor() public {&#13;
    owner = msg.sender;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Throws if called by any account other than the owner.&#13;
   */&#13;
  modifier onlyOwner() {&#13;
    require(msg.sender == owner);&#13;
    _;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Allows the current owner to relinquish control of the contract.&#13;
   */&#13;
  function renounceOwnership() public onlyOwner {&#13;
    emit OwnershipRenounced(owner);&#13;
    owner = address(0);&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Allows the current owner to transfer control of the contract to a newOwner.&#13;
   * @param _newOwner The address to transfer ownership to.&#13;
   */&#13;
  function transferOwnership(address _newOwner) public onlyOwner {&#13;
    _transferOwnership(_newOwner);&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Transfers control of the contract to a newOwner.&#13;
   * @param _newOwner The address to transfer ownership to.&#13;
   */&#13;
  function _transferOwnership(address _newOwner) internal {&#13;
    require(_newOwner != address(0));&#13;
    emit OwnershipTransferred(owner, _newOwner);&#13;
    owner = _newOwner;&#13;
  }&#13;
}&#13;
&#13;
library SafeMath {&#13;
&#13;
  /**&#13;
  * @dev Multiplies two numbers, throws on overflow.&#13;
  */&#13;
  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {&#13;
    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the&#13;
    // benefit is lost if 'b' is also tested.&#13;
    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522&#13;
    if (a == 0) {&#13;
      return 0;&#13;
    }&#13;
&#13;
    c = a * b;&#13;
    assert(c / a == b);&#13;
    return c;&#13;
  }&#13;
&#13;
  /**&#13;
  * @dev Integer division of two numbers, truncating the quotient.&#13;
  */&#13;
  function div(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
    // assert(b &gt; 0); // Solidity automatically throws when dividing by 0&#13;
    // uint256 c = a / b;&#13;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold&#13;
    return a / b;&#13;
  }&#13;
&#13;
  /**&#13;
  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).&#13;
  */&#13;
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
    assert(b &lt;= a);&#13;
    return a - b;&#13;
  }&#13;
&#13;
  /**&#13;
  * @dev Adds two numbers, throws on overflow.&#13;
  */&#13;
  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {&#13;
    c = a + b;&#13;
    assert(c &gt;= a);&#13;
    return c;&#13;
  }&#13;
}&#13;
&#13;
contract EthBattle is Ownable {&#13;
    using SafeMath for uint256;&#13;
&#13;
    uint256 constant TOKEN_USE_BONUS = 15; //%, adds weight of win on top of the market price&#13;
    uint256 constant REFERRAL_REWARD = 2 ether; // GTA, 10*19&#13;
    uint256 constant MIN_PLAY_AMOUNT = 50 finney; //wei, equal 0.05 ETH&#13;
&#13;
    uint256 public roundIndex = 0;&#13;
    mapping(uint256 =&gt; address) public rounds;&#13;
&#13;
    address[] private currentRewardingAddresses;&#13;
&#13;
    PlaySeedInterface private playSeedGenerator;&#13;
    GTAInterface public token;&#13;
    AMUStoreInterface public store;&#13;
&#13;
    mapping(address =&gt; address) public referralBacklog; //backlog of players and their referrals&#13;
&#13;
    mapping(address =&gt; uint256) public tokens; //map of deposited tokens&#13;
&#13;
    event RoundCreated(address createdAddress, uint256 index);&#13;
    event Deposit(address user, uint amount, uint balance);&#13;
    event Withdraw(address user, uint amount, uint balance);&#13;
&#13;
    /**&#13;
    * @dev Default fallback function, just deposits funds to the pot&#13;
    */&#13;
    function () public payable {&#13;
        getLastRound().getDevWallet().transfer(msg.value);&#13;
    }&#13;
&#13;
    /**&#13;
    * @dev The EthBattle constructor&#13;
    * @param _playSeedAddress address of the play seed generator&#13;
    * @param _tokenAddress GTA address&#13;
    * @param _storeAddress store contract address&#13;
    */&#13;
    constructor (address _playSeedAddress, address _tokenAddress, address _storeAddress) public {&#13;
        playSeedGenerator = PlaySeedInterface(_playSeedAddress);&#13;
        token = GTAInterface(_tokenAddress);&#13;
        store = AMUStoreInterface(_storeAddress);&#13;
    }&#13;
&#13;
    /**&#13;
    * @dev Try (must be allowed by the seed generator itself) to claim ownership of the seed generator&#13;
    */&#13;
    function claimSeedOwnership() onlyOwner public {&#13;
        playSeedGenerator.claimOwnership();&#13;
    }&#13;
&#13;
    /**&#13;
    * @dev Inject the new round contract, and sets the round with a new index&#13;
    * NOTE! Injected round must have had transferred ownership to this EthBattle already&#13;
    * @param _roundAddress address of the new round to use&#13;
    */&#13;
    function startRound(address _roundAddress) onlyOwner public {&#13;
        RoundInterface round = RoundInterface(_roundAddress);&#13;
&#13;
        round.claimOwnership();&#13;
&#13;
        roundIndex++;&#13;
        rounds[roundIndex] = round;&#13;
        emit RoundCreated(round, roundIndex);&#13;
    }&#13;
&#13;
&#13;
    /**&#13;
    * @dev Interrupts the round to enable participants to claim funds back&#13;
    */&#13;
    function interruptLastRound() onlyOwner public {&#13;
        getLastRound().enableRefunds();&#13;
    }&#13;
&#13;
    /**&#13;
    * @dev End last round so no new plays is possible, but ongoing plays are fine to win&#13;
    */&#13;
    function finishLastRound() onlyOwner public {&#13;
        getLastRound().coolDown();&#13;
    }&#13;
&#13;
    function getLastRound() public view returns (RoundInterface){&#13;
        return RoundInterface(rounds[roundIndex]);&#13;
    }&#13;
&#13;
    function getLastRoundAddress() external view returns (address){&#13;
        return rounds[roundIndex];&#13;
    }&#13;
&#13;
    /**&#13;
    * @dev Player starts a new play providing&#13;
    * @param _referral (Optional) referral address is any&#13;
    * @param _gtaBet (Optional) additional bet in GTA&#13;
    */&#13;
    function play(address _referral, uint256 _gtaBet) public payable {&#13;
        address player = msg.sender;&#13;
        uint256 weiAmount = msg.value;&#13;
&#13;
        require(player != address(0), "Player's address is missing");&#13;
        require(weiAmount &gt;= MIN_PLAY_AMOUNT, "The bet is too low");&#13;
        require(_gtaBet &lt;= balanceOf(player), "Player's got not enough GTA");&#13;
&#13;
        if (_referral != address(0) &amp;&amp; referralBacklog[player] == address(0)) {&#13;
            //new referral for this player&#13;
            referralBacklog[player] = _referral;&#13;
            //reward the referral. Tokens remains in this contract&#13;
            //but become available for withdrawal by _referral&#13;
            transferInternally(owner, _referral, REFERRAL_REWARD);&#13;
        }&#13;
&#13;
        playSeedGenerator.newPlaySeed(player);&#13;
&#13;
        uint256 _bet = aggregateBet(weiAmount, _gtaBet);&#13;
&#13;
        if (_gtaBet &gt; 0) {&#13;
            //player's using GTA&#13;
            transferInternally(player, owner, _gtaBet);&#13;
        }&#13;
&#13;
        if (referralBacklog[player] != address(0)) {&#13;
            //ongoing round might not know about the _referral&#13;
            //delegate the knowledge of the referral to the ongoing round&#13;
            getLastRound().setReferral(player, referralBacklog[player]);&#13;
        }&#13;
        getLastRound().playRound.value(msg.value)(player, _bet);&#13;
    }&#13;
&#13;
    /**&#13;
    * @dev Player claims a win&#13;
    * @param _seed secret seed&#13;
    */&#13;
    function win(bytes32 _seed) public {&#13;
        address player = msg.sender;&#13;
&#13;
        require(player != address(0), "Winner's address is missing");&#13;
        require(playSeedGenerator.findSeed(player) == _seed, "Wrong seed!");&#13;
        playSeedGenerator.cleanSeedUp(player);&#13;
&#13;
        getLastRound().win(player);&#13;
    }&#13;
&#13;
    function findSeedAuthorized(address player) onlyOwner public view returns (bytes32){&#13;
        return playSeedGenerator.findSeed(player);&#13;
    }&#13;
&#13;
    function aggregateBet(uint256 _bet, uint256 _gtaBet) internal view returns (uint256) {&#13;
        //get market price of the GTA, multiply by bet, and apply a bonus on it.&#13;
        //since both 'price' and 'bet' are in 'wei', we need to drop 10*18 decimals at the end&#13;
        uint256 _gtaValueWei = store.getTokenBuyPrice().mul(_gtaBet).div(1 ether).mul(100 + TOKEN_USE_BONUS).div(100);&#13;
&#13;
        //sum up with ETH bet&#13;
        uint256 _resultBet = _bet.add(_gtaValueWei);&#13;
&#13;
        return _resultBet;&#13;
    }&#13;
&#13;
    /**&#13;
    * @dev Calculates the prize amount for this player by now&#13;
    * Note: the result is not the final one and a subject to change once more plays/wins occur&#13;
    * @return The prize in wei&#13;
    */&#13;
    function prizeByNow() public view returns (uint256) {&#13;
        return getLastRound().currentPrize(msg.sender);&#13;
    }&#13;
&#13;
    /**&#13;
    * @dev Calculates the prediction on the prize amount for this player and this bet&#13;
    * Note: the result is not the final one and a subject to change once more plays/wins occur&#13;
    * @param _bet hypothetical bet in wei&#13;
    * @param _gtaBet hypothetical bet in GTA&#13;
    * @return The prediction in wei&#13;
    */&#13;
    function prizeProjection(uint256 _bet, uint256 _gtaBet) public view returns (uint256) {&#13;
        return getLastRound().projectedPrizeForPlayer(msg.sender, aggregateBet(_bet, _gtaBet));&#13;
    }&#13;
&#13;
&#13;
    /**&#13;
    * @dev Deposit GTA to the EthBattle contract so it can be spent (used) immediately&#13;
    * Note: this call must follow the approve() call on the token itself&#13;
    * @param _amount amount to deposit&#13;
    */&#13;
    function depositGTA(uint256 _amount) public {&#13;
        require(token.transferFrom(msg.sender, this, _amount), "Insufficient funds");&#13;
        tokens[msg.sender] = tokens[msg.sender].add(_amount);&#13;
        emit Deposit(msg.sender, _amount, tokens[msg.sender]);&#13;
    }&#13;
&#13;
    /**&#13;
    * @dev Withdraw GTA from this contract to the own (caller) address&#13;
    * @param _amount amount to withdraw&#13;
    */&#13;
    function withdrawGTA(uint256 _amount) public {&#13;
        require(tokens[msg.sender] &gt;= _amount, "Amount exceeds the available balance");&#13;
        tokens[msg.sender] = tokens[msg.sender].sub(_amount);&#13;
        require(token.transfer(msg.sender, _amount), "Amount exceeds the available balance");&#13;
        emit Withdraw(msg.sender, _amount, tokens[msg.sender]);&#13;
    }&#13;
&#13;
    /**&#13;
    * @dev Internal transfer of the token.&#13;
    * Funds remain in this contract but become available for withdrawal&#13;
    */&#13;
    function transferInternally(address _from, address _to, uint256 _amount) internal {&#13;
        require(tokens[_from] &gt;= _amount, "Too much to transfer");&#13;
        tokens[_from] = tokens[_from].sub(_amount);&#13;
        tokens[_to] = tokens[_to].add(_amount);&#13;
    }&#13;
&#13;
    function balanceOf(address _user) public view returns (uint256) {&#13;
        return tokens[_user];&#13;
    }&#13;
&#13;
    function setPlaySeed(address _playSeedAddress) onlyOwner public {&#13;
        playSeedGenerator = PlaySeedInterface(_playSeedAddress);&#13;
    }&#13;
&#13;
    function setStore(address _storeAddress) onlyOwner public {&#13;
        store = AMUStoreInterface(_storeAddress);&#13;
    }&#13;
&#13;
    function getTokenBuyPrice() public view returns (uint256) {&#13;
        return store.getTokenBuyPrice();&#13;
    }&#13;
&#13;
    function getTokenSellPrice() public view returns (uint256) {&#13;
        return store.getTokenSellPrice();&#13;
    }&#13;
&#13;
    /**&#13;
    * @dev Recover the history of referrals in case of the contract migration.&#13;
    */&#13;
    function setReferralsMap(address[] _players, address[] _referrals) onlyOwner public {&#13;
        require(_players.length == _referrals.length, "Size of players must be equal to the size of referrals");&#13;
        for (uint i = 0; i &lt; _players.length; ++i) {&#13;
            referralBacklog[_players[i]] = _referrals[i];&#13;
        }&#13;
    }&#13;
&#13;
}&#13;
&#13;
/**&#13;
 * @title PlaySeed contract interface&#13;
 */&#13;
interface PlaySeedInterface {&#13;
&#13;
    function newPlaySeed(address _player) external;&#13;
&#13;
    function findSeed(address _player) external view returns (bytes32);&#13;
&#13;
    function cleanSeedUp(address _player) external;&#13;
&#13;
    function claimOwnership() external;&#13;
&#13;
}&#13;
&#13;
/**&#13;
 * @title GTA contract interface&#13;
 */&#13;
interface GTAInterface {&#13;
&#13;
    function transferFrom(address _from, address _to, uint256 _value) external returns (bool);&#13;
&#13;
    function transfer(address to, uint256 value) external returns (bool);&#13;
&#13;
}&#13;
&#13;
/**&#13;
 * @title EthBattleRound contract interface&#13;
 */&#13;
interface RoundInterface {&#13;
&#13;
    function claimOwnership() external;&#13;
&#13;
    function setReferral(address _player, address _referral) external;&#13;
&#13;
    function playRound(address _player, uint256 _bet) external payable;&#13;
&#13;
    function enableRefunds() external;&#13;
&#13;
    function coolDown() external;&#13;
&#13;
    function currentPrize(address _player) external view returns (uint256);&#13;
&#13;
    function projectedPrizeForPlayer(address _player, uint256 _bet) external view returns (uint256);&#13;
&#13;
    function win(address _player) external;&#13;
&#13;
    function getDevWallet() external view returns (address);&#13;
&#13;
}&#13;
&#13;
/**&#13;
 * @title Ammu-Nation contract interface&#13;
 */&#13;
interface AMUStoreInterface {&#13;
&#13;
    function getTokenBuyPrice() external view returns (uint256);&#13;
&#13;
    function getTokenSellPrice() external view returns (uint256);&#13;
&#13;
}