pragma solidity ^0.4.18;

///>[ Crypto Brands ]>>>>

/// @title Interface for contracts conforming to ERC-721: Non-Fungible Tokens
/// @author Dieter Shirley <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="aacecfdecfeacbd2c3c5c7d0cfc484c9c5">[emailÂ protected]</a>&gt; (https://github.com/dete)&#13;
contract ERC721 {&#13;
    function approve(address _to, uint256 _tokenId) public;&#13;
    function balanceOf(address _owner) public view returns (uint256 balance);&#13;
    function implementsERC721() public pure returns (bool);&#13;
    function ownerOf(uint256 _tokenId) public view returns (address addr);&#13;
    function takeOwnership(uint256 _tokenId) public;&#13;
    function totalSupply() public view returns (uint256 total);&#13;
    function transferFrom(address _from, address _to, uint256 _tokenId) public;&#13;
    function transfer(address _to, uint256 _tokenId) public;&#13;
&#13;
    event Transfer(address indexed from, address indexed to, uint256 tokenId);&#13;
    event Approval(address indexed owner, address indexed approved, uint256 tokenId);&#13;
}&#13;
&#13;
contract EtherBrand is ERC721 {&#13;
&#13;
  /*** EVENTS ***/&#13;
  event Birth(uint256 tokenId, bytes32 name, address owner);&#13;
  event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, bytes32 name);&#13;
  event Transfer(address from, address to, uint256 tokenId);&#13;
&#13;
  /*** STRUCTS ***/&#13;
  struct Brand {&#13;
    bytes32 name;&#13;
    address owner;&#13;
    uint256 price;&#13;
    uint256 last_price;&#13;
    address approve_transfer_to;&#13;
  }&#13;
  &#13;
  struct TopOwner {&#13;
    address addr;&#13;
    uint256 price;&#13;
  }&#13;
&#13;
  /*** CONSTANTS ***/&#13;
  string public constant NAME = "EtherBrands";&#13;
  string public constant SYMBOL = "EtherBrand";&#13;
  &#13;
  bool public gameOpen = false;&#13;
&#13;
  /*** STORAGE ***/&#13;
  mapping (address =&gt; uint256) private ownerCount;&#13;
  mapping (uint256 =&gt; TopOwner) private topOwner;&#13;
  mapping (uint256 =&gt; address) private lastBuyer;&#13;
&#13;
  address public ceoAddress;&#13;
  address public cooAddress;&#13;
  address public cfoAddress;&#13;
  mapping (uint256 =&gt; address) public extra;&#13;
  &#13;
  uint256 brand_count;&#13;
  uint256 lowest_top_brand;&#13;
 &#13;
  mapping (uint256 =&gt; Brand) private brands;&#13;
  //Brand[] public brands;&#13;
&#13;
  /*** ACCESS MODIFIERS ***/&#13;
  modifier onlyCEO() { require(msg.sender == ceoAddress); _; }&#13;
  modifier onlyCOO() { require(msg.sender == cooAddress); _; }&#13;
  modifier onlyCXX() { require(msg.sender == ceoAddress || msg.sender == cooAddress); _; }&#13;
&#13;
  /*** ACCESS MODIFIES ***/&#13;
  function setCEO(address _newCEO) public onlyCEO {&#13;
    require(_newCEO != address(0));&#13;
    ceoAddress = _newCEO;&#13;
  }&#13;
  function setCOO(address _newCOO) public onlyCEO {&#13;
    require(_newCOO != address(0));&#13;
    cooAddress = _newCOO;&#13;
  }&#13;
  function setCFO(address _newCFO) public onlyCEO {&#13;
    require(_newCFO != address(0));&#13;
    cfoAddress = _newCFO;&#13;
  }&#13;
  function setExtra(uint256 _id, address _newExtra) public onlyCXX {&#13;
    require(_newExtra != address(0));&#13;
    // failsave :3 require(_id &lt;= 2); // 3 = 1 ETH, 4 = 2.5 ETH, 5 = 5 ETH&#13;
    extra[_id] = _newExtra;&#13;
  }&#13;
&#13;
  /*** DEFAULT METHODS ***/&#13;
  function symbol() public pure returns (string) { return SYMBOL; }&#13;
  function name() public pure returns (string) { return NAME; }&#13;
  function implementsERC721() public pure returns (bool) { return true; }&#13;
&#13;
  /*** CONSTRUCTOR ***/&#13;
  function EtherBrand() public {&#13;
    ceoAddress = msg.sender;&#13;
    cooAddress = msg.sender;&#13;
    cfoAddress = msg.sender;&#13;
    topOwner[1] = TopOwner(msg.sender, 500000000000000000); // 0.5&#13;
    topOwner[2] = TopOwner(msg.sender, 100000000000000000); // 0.1&#13;
    topOwner[3] = TopOwner(msg.sender, 50000000000000000); // 0.05&#13;
    topOwner[4] = TopOwner(msg.sender, 0);&#13;
    topOwner[5] = TopOwner(msg.sender, 0);&#13;
    lastBuyer[1] = msg.sender;&#13;
    lastBuyer[2] = msg.sender;&#13;
    lastBuyer[3] = msg.sender;&#13;
    extra[1] = msg.sender;&#13;
    extra[2] = msg.sender;&#13;
    extra[3] = msg.sender;&#13;
    extra[4] = msg.sender;&#13;
    extra[5] = msg.sender;&#13;
  }&#13;
&#13;
  /*** INTERFACE METHODS ***/&#13;
&#13;
  function createBrand(bytes32 _name, uint256 _price) public onlyCXX {&#13;
    require(msg.sender != address(0));&#13;
    _create_brand(_name, address(this), _price);&#13;
  }&#13;
&#13;
  function createPromoBrand(bytes32 _name, address _owner, uint256 _price) public onlyCXX {&#13;
    require(msg.sender != address(0));&#13;
    require(_owner != address(0));&#13;
    _create_brand(_name, _owner, _price);&#13;
  }&#13;
&#13;
  function openGame() public onlyCXX {&#13;
    require(msg.sender != address(0));&#13;
    gameOpen = true;&#13;
  }&#13;
&#13;
  function totalSupply() public view returns (uint256 total) {&#13;
    return brand_count;&#13;
  }&#13;
&#13;
  function balanceOf(address _owner) public view returns (uint256 balance) {&#13;
    return ownerCount[_owner];&#13;
  }&#13;
  function priceOf(uint256 _brand_id) public view returns (uint256 price) {&#13;
    return brands[_brand_id].price;&#13;
  }&#13;
&#13;
  function getBrand(uint256 _brand_id) public view returns (&#13;
    uint256 id,&#13;
    bytes32 brand_name,&#13;
    address owner,&#13;
    uint256 price,&#13;
    uint256 last_price&#13;
  ) {&#13;
    id = _brand_id;&#13;
    brand_name = brands[_brand_id].name;&#13;
    owner = brands[_brand_id].owner;&#13;
    price = brands[_brand_id].price;&#13;
    last_price = brands[_brand_id].last_price;&#13;
  }&#13;
  &#13;
  function getBrands() public view returns (uint256[], bytes32[], address[], uint256[]) {&#13;
    uint256[] memory ids = new uint256[](brand_count);&#13;
    bytes32[] memory names = new bytes32[](brand_count);&#13;
    address[] memory owners = new address[](brand_count);&#13;
    uint256[] memory prices = new uint256[](brand_count);&#13;
    for(uint256 _id = 0; _id &lt; brand_count; _id++){&#13;
      ids[_id] = _id;&#13;
      names[_id] = brands[_id].name;&#13;
      owners[_id] = brands[_id].owner;&#13;
      prices[_id] = brands[_id].price;&#13;
    }&#13;
    return (ids, names, owners, prices);&#13;
  }&#13;
  &#13;
  function purchase(uint256 _brand_id) public payable {&#13;
    require(gameOpen == true);&#13;
    Brand storage brand = brands[_brand_id];&#13;
&#13;
    require(brand.owner != msg.sender);&#13;
    require(msg.sender != address(0));&#13;
    require(msg.value &gt;= brand.price);&#13;
&#13;
    uint256 excess = SafeMath.sub(msg.value, brand.price);&#13;
    uint256 half_diff = SafeMath.div(SafeMath.sub(brand.price, brand.last_price), 2);&#13;
    uint256 reward = SafeMath.add(half_diff, brand.last_price);&#13;
&#13;
    topOwner[1].addr.transfer(uint256(SafeMath.mul(SafeMath.div(half_diff, 100), 15)));  // 15%&#13;
    topOwner[2].addr.transfer(uint256(SafeMath.mul(SafeMath.div(half_diff, 100), 12)));  // 12%&#13;
    topOwner[3].addr.transfer(uint256(SafeMath.mul(SafeMath.div(half_diff, 100), 9)));   // 9%&#13;
    topOwner[4].addr.transfer(uint256(SafeMath.mul(SafeMath.div(half_diff, 100), 5)));   // 5%&#13;
    topOwner[5].addr.transfer(uint256(SafeMath.mul(SafeMath.div(half_diff, 100), 2)));   // 2% == 43%&#13;
  &#13;
    lastBuyer[1].transfer(uint256(SafeMath.mul(SafeMath.div(half_diff, 100), 20))); // 20%&#13;
    lastBuyer[2].transfer(uint256(SafeMath.mul(SafeMath.div(half_diff, 100), 15))); // 15%&#13;
    lastBuyer[3].transfer(uint256(SafeMath.mul(SafeMath.div(half_diff, 100), 10))); // 10% == 45%&#13;
  &#13;
    extra[1].transfer(uint256(SafeMath.mul(SafeMath.div(half_diff, 100), 1)));      // 1%&#13;
    extra[2].transfer(uint256(SafeMath.mul(SafeMath.div(half_diff, 100), 1)));      // 1%&#13;
    extra[3].transfer(uint256(SafeMath.mul(SafeMath.div(half_diff, 100), 1)));      // 1%&#13;
    extra[4].transfer(uint256(SafeMath.mul(SafeMath.div(half_diff, 100), 1)));      // 1%&#13;
    extra[5].transfer(uint256(SafeMath.mul(SafeMath.div(half_diff, 100), 1)));      // 1%&#13;
    &#13;
    cfoAddress.transfer(uint256(SafeMath.mul(SafeMath.div(half_diff, 100), 6)));    // 6%&#13;
    cooAddress.transfer(uint256(SafeMath.mul(SafeMath.div(half_diff, 100), 1)));    // 1%&#13;
&#13;
    if(brand.owner == address(this)){&#13;
      cfoAddress.transfer(reward);&#13;
    } else {&#13;
      brand.owner.transfer(reward);&#13;
    }&#13;
    &#13;
    if(brand.price &gt; topOwner[5].price){&#13;
        for(uint8 i = 1; i &lt;= 5; i++){&#13;
            if(brand.price &gt; topOwner[(i+1)].price){&#13;
                if(i &lt;= 1){ topOwner[2] = topOwner[1]; }&#13;
                if(i &lt;= 2){ topOwner[3] = topOwner[2]; }&#13;
                if(i &lt;= 3){ topOwner[4] = topOwner[3]; }&#13;
                if(i &lt;= 4){ topOwner[5] = topOwner[4]; }&#13;
                topOwner[i] = TopOwner(msg.sender, brand.price);&#13;
                break;&#13;
            }&#13;
        }&#13;
    }&#13;
    &#13;
    if(extra[3] == ceoAddress &amp;&amp; brand.price &gt;= 1000000000000000000){ extra[3] == msg.sender; } // 1 ETH&#13;
    if(extra[4] == ceoAddress &amp;&amp; brand.price &gt;= 2500000000000000000){ extra[4] == msg.sender; } // 2.5 ETH&#13;
    if(extra[5] == ceoAddress &amp;&amp; brand.price &gt;= 5000000000000000000){ extra[5] == msg.sender; } // 5 ETH&#13;
    &#13;
    brand.last_price = brand.price;&#13;
    address _old_owner = brand.owner;&#13;
    &#13;
    if(brand.price &lt; 50000000000000000){ // 0.05&#13;
        brand.price = SafeMath.mul(SafeMath.div(brand.price, 100), 150);&#13;
    } else {&#13;
        brand.price = SafeMath.mul(SafeMath.div(brand.price, 100), 125);&#13;
    }&#13;
    brand.owner = msg.sender;&#13;
&#13;
    lastBuyer[3] = lastBuyer[2];&#13;
    lastBuyer[2] = lastBuyer[1];&#13;
    lastBuyer[1] = msg.sender;&#13;
&#13;
    Transfer(_old_owner, brand.owner, _brand_id);&#13;
    TokenSold(_brand_id, brand.last_price, brand.price, _old_owner, brand.owner, brand.name);&#13;
&#13;
    msg.sender.transfer(excess);&#13;
  }&#13;
&#13;
  function payout() public onlyCEO {&#13;
    cfoAddress.transfer(this.balance);&#13;
  }&#13;
&#13;
  function tokensOfOwner(address _owner) public view returns(uint256[] ownerTokens) {&#13;
    uint256 tokenCount = balanceOf(_owner);&#13;
    if (tokenCount == 0) {&#13;
      return new uint256[](0);&#13;
    } else {&#13;
      uint256[] memory result = new uint256[](tokenCount);&#13;
      uint256 resultIndex = 0;&#13;
      for (uint256 brandId = 0; brandId &lt;= totalSupply(); brandId++) {&#13;
        if (brands[brandId].owner == _owner) {&#13;
          result[resultIndex] = brandId;&#13;
          resultIndex++;&#13;
        }&#13;
      }&#13;
      return result;&#13;
    }&#13;
  }&#13;
&#13;
  /*** ERC-721 compliance. ***/&#13;
&#13;
  function approve(address _to, uint256 _brand_id) public {&#13;
    require(msg.sender == brands[_brand_id].owner);&#13;
    brands[_brand_id].approve_transfer_to = _to;&#13;
    Approval(msg.sender, _to, _brand_id);&#13;
  }&#13;
  function ownerOf(uint256 _brand_id) public view returns (address owner){&#13;
    owner = brands[_brand_id].owner;&#13;
    require(owner != address(0));&#13;
  }&#13;
  function takeOwnership(uint256 _brand_id) public {&#13;
    address oldOwner = brands[_brand_id].owner;&#13;
    require(msg.sender != address(0));&#13;
    require(brands[_brand_id].approve_transfer_to == msg.sender);&#13;
    _transfer(oldOwner, msg.sender, _brand_id);&#13;
  }&#13;
  function transfer(address _to, uint256 _brand_id) public {&#13;
    require(msg.sender != address(0));&#13;
    require(msg.sender == brands[_brand_id].owner);&#13;
    _transfer(msg.sender, _to, _brand_id);&#13;
  }&#13;
  function transferFrom(address _from, address _to, uint256 _brand_id) public {&#13;
    require(_from == brands[_brand_id].owner);&#13;
    require(brands[_brand_id].approve_transfer_to == _to);&#13;
    require(_to != address(0));&#13;
    _transfer(_from, _to, _brand_id);&#13;
  }&#13;
&#13;
  /*** PRIVATE METHODS ***/&#13;
&#13;
  function _create_brand(bytes32 _name, address _owner, uint256 _price) private {&#13;
    // Params: name, owner, price, is_for_sale, is_public, share_price, increase, fee, share_count,&#13;
    brands[brand_count] = Brand({&#13;
      name: _name,&#13;
      owner: _owner,&#13;
      price: _price,&#13;
      last_price: 0,&#13;
      approve_transfer_to: address(0)&#13;
    });&#13;
    Birth(brand_count, _name, _owner);&#13;
    Transfer(address(this), _owner, brand_count);&#13;
    brand_count++;&#13;
  }&#13;
&#13;
  function _transfer(address _from, address _to, uint256 _brand_id) private {&#13;
    brands[_brand_id].owner = _to;&#13;
    brands[_brand_id].approve_transfer_to = address(0);&#13;
    ownerCount[_from] -= 1;&#13;
    ownerCount[_to] += 1;&#13;
    Transfer(_from, _to, _brand_id);&#13;
  }&#13;
}&#13;
&#13;
library SafeMath {&#13;
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
    if (a == 0) {&#13;
      return 0;&#13;
    }&#13;
    uint256 c = a * b;&#13;
    assert(c / a == b);&#13;
    return c;&#13;
  }&#13;
  function div(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
    uint256 c = a / b;&#13;
    return c;&#13;
  }&#13;
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
    assert(b &lt;= a);&#13;
    return a - b;&#13;
  }&#13;
  function add(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
    uint256 c = a + b;&#13;
    assert(c &gt;= a);&#13;
    return c;&#13;
  }&#13;
}