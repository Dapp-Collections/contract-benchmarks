/* ==================================================================== */
/* Copyright (c) 2018 The ether.online Project.  All rights reserved.
/* 
/* https://ether.online  The first RPG game of blockchain 
/*  
/* authors <span class="__cf_email__" data-cfemail="f88a919b93908d968c9d8ad68b909d96b89f95999194d69b9795">[email protected]</span>   &#13;
/*         <span class="__cf_email__" data-cfemail="dfacacbaacaab1bbb6b1b89fb8b2beb6b3f1bcb0b2">[email protected]</span>            &#13;
/* ==================================================================== */&#13;
&#13;
pragma solidity ^0.4.20;&#13;
&#13;
contract AccessAdmin {&#13;
    bool public isPaused = false;&#13;
    address public addrAdmin;  &#13;
&#13;
    event AdminTransferred(address indexed preAdmin, address indexed newAdmin);&#13;
&#13;
    function AccessAdmin() public {&#13;
        addrAdmin = msg.sender;&#13;
    }  &#13;
&#13;
&#13;
    modifier onlyAdmin() {&#13;
        require(msg.sender == addrAdmin);&#13;
        _;&#13;
    }&#13;
&#13;
    modifier whenNotPaused() {&#13;
        require(!isPaused);&#13;
        _;&#13;
    }&#13;
&#13;
    modifier whenPaused {&#13;
        require(isPaused);&#13;
        _;&#13;
    }&#13;
&#13;
    function setAdmin(address _newAdmin) external onlyAdmin {&#13;
        require(_newAdmin != address(0));&#13;
        AdminTransferred(addrAdmin, _newAdmin);&#13;
        addrAdmin = _newAdmin;&#13;
    }&#13;
&#13;
    function doPause() external onlyAdmin whenNotPaused {&#13;
        isPaused = true;&#13;
    }&#13;
&#13;
    function doUnpause() external onlyAdmin whenPaused {&#13;
        isPaused = false;&#13;
    }&#13;
}&#13;
&#13;
&#13;
contract AccessService is AccessAdmin {&#13;
    address public addrService;&#13;
    address public addrFinance;&#13;
&#13;
    modifier onlyService() {&#13;
        require(msg.sender == addrService);&#13;
        _;&#13;
    }&#13;
&#13;
    modifier onlyFinance() {&#13;
        require(msg.sender == addrFinance);&#13;
        _;&#13;
    }&#13;
&#13;
    function setService(address _newService) external {&#13;
        require(msg.sender == addrService || msg.sender == addrAdmin);&#13;
        require(_newService != address(0));&#13;
        addrService = _newService;&#13;
    }&#13;
&#13;
    function setFinance(address _newFinance) external {&#13;
        require(msg.sender == addrFinance || msg.sender == addrAdmin);&#13;
        require(_newFinance != address(0));&#13;
        addrFinance = _newFinance;&#13;
    }&#13;
&#13;
    function withdraw(address _target, uint256 _amount) &#13;
        external &#13;
    {&#13;
        require(msg.sender == addrFinance || msg.sender == addrAdmin);&#13;
        require(_amount &gt; 0);&#13;
        address receiver = _target == address(0) ? addrFinance : _target;&#13;
        uint256 balance = this.balance;&#13;
        if (_amount &lt; balance) {&#13;
            receiver.transfer(_amount);&#13;
        } else {&#13;
            receiver.transfer(this.balance);&#13;
        }      &#13;
    }&#13;
}&#13;
&#13;
/**&#13;
 * @title SafeMath&#13;
 * @dev Math operations with safety checks that throw on error&#13;
 */&#13;
library SafeMath {&#13;
    /**&#13;
    * @dev Multiplies two numbers, throws on overflow.&#13;
    */&#13;
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
        if (a == 0) {&#13;
            return 0;&#13;
        }&#13;
        uint256 c = a * b;&#13;
        assert(c / a == b);&#13;
        return c;&#13;
    }&#13;
&#13;
    /**&#13;
    * @dev Integer division of two numbers, truncating the quotient.&#13;
    */&#13;
    function div(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
        // assert(b &gt; 0); // Solidity automatically throws when dividing by 0&#13;
        uint256 c = a / b;&#13;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold&#13;
        return c;&#13;
    }&#13;
&#13;
    /**&#13;
    * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).&#13;
    */&#13;
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
        assert(b &lt;= a);&#13;
        return a - b;&#13;
    }&#13;
&#13;
    /**&#13;
    * @dev Adds two numbers, throws on overflow.&#13;
    */&#13;
    function add(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
        uint256 c = a + b;&#13;
        assert(c &gt;= a);&#13;
        return c;&#13;
    }&#13;
}&#13;
&#13;
interface IBitGuildToken {&#13;
    function transfer(address _to, uint256 _value) external;&#13;
    function transferFrom(address _from, address _to, uint256 _value) external returns (bool);&#13;
    function approve(address _spender, uint256 _value) external; &#13;
    function approveAndCall(address _spender, uint256 _value, bytes _extraData) external returns (bool);&#13;
    function balanceOf(address _from) external view returns(uint256);&#13;
}&#13;
&#13;
interface IAgonFight {&#13;
    function calcFight(uint64 _mFlag, uint64 _cFlag, uint256 _aSeed, uint256 _fSeed) external pure returns(uint64);&#13;
}&#13;
&#13;
contract ActionAgonPlat is AccessService {&#13;
    using SafeMath for uint256; &#13;
&#13;
    event CreateAgonPlat(uint64 indexed agonId, address indexed master, uint64 indexed outFlag);&#13;
    event CancelAgonPlat(uint64 indexed agonId, address indexed master, uint64 indexed outFlag);&#13;
    event ChallengeAgonPlat(uint64 indexed agonId, address indexed master, uint64 indexed outFlag, address challenger);&#13;
    event ResolveAgonPlat(uint64 indexed agonId, address indexed master, uint64 indexed outFlag, address challenger);&#13;
&#13;
    struct Agon {&#13;
        address master;&#13;
        address challenger;&#13;
        uint64 agonPrice;&#13;
        uint64 outFlag;&#13;
        uint64 agonFlag;    &#13;
        uint64 result;      // 1-win, 2-lose, 99-cancel&#13;
    }&#13;
&#13;
    Agon[] agonArray;&#13;
    IAgonFight fightContract;&#13;
    IBitGuildToken public bitGuildContract;&#13;
&#13;
    mapping (address =&gt; uint64[]) public ownerToAgonIdArray;&#13;
    uint256 public maxAgonCount = 6;&#13;
    uint256 public maxResolvedAgonId = 0; &#13;
    uint256[5] public agonValues;&#13;
&#13;
    function ActionAgonPlat(address _platAddr) public {&#13;
        addrAdmin = msg.sender;&#13;
        addrService = msg.sender;&#13;
        addrFinance = msg.sender;&#13;
&#13;
        bitGuildContract = IBitGuildToken(_platAddr);&#13;
&#13;
        Agon memory order = Agon(0, 0, 0, 0, 1, 1);&#13;
        agonArray.push(order);&#13;
        agonValues[0] = 3000000000000000000000;&#13;
        agonValues[1] = 12000000000000000000000;&#13;
        agonValues[2] = 30000000000000000000000;&#13;
        agonValues[3] = 60000000000000000000000;&#13;
        agonValues[4] = 120000000000000000000000;&#13;
    }&#13;
&#13;
    function() external {}&#13;
&#13;
    function setMaxAgonCount(uint256 _count) external onlyAdmin {&#13;
        require(_count &gt; 0 &amp;&amp; _count &lt; 20);&#13;
        require(_count != maxAgonCount);&#13;
        maxAgonCount = _count;&#13;
    }&#13;
&#13;
    function setAgonFight(address _addr) external onlyAdmin {&#13;
        fightContract = IAgonFight(_addr);&#13;
    }&#13;
&#13;
    function setMaxResolvedAgonId() external {&#13;
        uint256 length = agonArray.length;&#13;
        for (uint256 i = maxResolvedAgonId; i &lt; length; ++i) {&#13;
            if (agonArray[i].result == 0) {&#13;
                maxResolvedAgonId = i - 1;&#13;
                break;&#13;
            }&#13;
        }&#13;
    }&#13;
&#13;
    function setAgonValues(uint256[5] values) external onlyAdmin {&#13;
        require(values[0] &gt;= 100);&#13;
        require(values[1] &gt;= values[0]);&#13;
        require(values[2] &gt;= values[1]);&#13;
        require(values[3] &gt;= values[2]);&#13;
        require(values[4] &gt;= values[3]);&#13;
        require(values[4] &lt;= 600000); &#13;
        require(values[0] % 100 == 0);&#13;
        require(values[1] % 100 == 0);&#13;
        require(values[2] % 100 == 0);&#13;
        require(values[3] % 100 == 0);&#13;
        require(values[4] % 100 == 0);&#13;
        agonValues[0] = values[0].mul(1000000000000000000);&#13;
        agonValues[1] = values[1].mul(1000000000000000000);&#13;
        agonValues[2] = values[2].mul(1000000000000000000);&#13;
        agonValues[3] = values[3].mul(1000000000000000000);&#13;
        agonValues[4] = values[4].mul(1000000000000000000);&#13;
    }&#13;
&#13;
    function _getExtraParam(bytes _extraData) internal pure returns(uint64 p1, uint64 p2, uint64 p3) {&#13;
        p1 = uint64(_extraData[0]);&#13;
        p2 = uint64(_extraData[1]);&#13;
        uint64 index = 2;&#13;
        uint256 val = 0;&#13;
        uint256 length = _extraData.length;&#13;
        while (index &lt; length) {&#13;
            val += (uint256(_extraData[index]) * (256 ** (length - index - 1)));&#13;
            index += 1;&#13;
        }&#13;
        p3 = uint64(val);&#13;
    }&#13;
&#13;
    function receiveApproval(address _sender, uint256 _value, address _tokenContract, bytes _extraData) &#13;
        external &#13;
        whenNotPaused &#13;
    {&#13;
        require(msg.sender == address(bitGuildContract));&#13;
        require(_extraData.length &gt; 2 &amp;&amp; _extraData.length &lt;= 10);&#13;
        var (p1, p2, p3) = _getExtraParam(_extraData);&#13;
        if (p1 == 0) {&#13;
            _newAgon(p3, p2, _sender, _value);&#13;
        } else if (p1 == 1) {&#13;
            _newChallenge(p3, p2, _sender, _value);&#13;
        } else {&#13;
            require(false);&#13;
        }&#13;
    }&#13;
&#13;
    function _newAgon(uint64 _outFlag, uint64 _valId, address _sender, uint256 _value) internal {&#13;
        require(ownerToAgonIdArray[_sender].length &lt; maxAgonCount);&#13;
        require(_valId &gt;= 0 &amp;&amp; _valId &lt;= 4);&#13;
        require(_value == agonValues[_valId]);&#13;
        &#13;
        require(bitGuildContract.transferFrom(_sender, address(this), _value));&#13;
&#13;
        uint64 newAgonId = uint64(agonArray.length);&#13;
        agonArray.length += 1;&#13;
        Agon storage agon = agonArray[newAgonId];&#13;
        agon.master = _sender;&#13;
        agon.agonPrice = uint64(_value.div(1000000000000000000)); &#13;
        agon.outFlag = _outFlag;&#13;
&#13;
        ownerToAgonIdArray[_sender].push(newAgonId);&#13;
&#13;
        CreateAgonPlat(uint64(newAgonId), _sender, _outFlag);&#13;
    } &#13;
&#13;
    function _removeAgonIdByOwner(address _owner, uint64 _agonId) internal {&#13;
        uint64[] storage agonIdArray = ownerToAgonIdArray[_owner];&#13;
        uint256 length = agonIdArray.length;&#13;
        require(length &gt; 0);&#13;
        uint256 findIndex = 99;&#13;
        for (uint256 i = 0; i &lt; length; ++i) {&#13;
            if (_agonId == agonIdArray[i]) {&#13;
                findIndex = i;&#13;
            }&#13;
        }&#13;
        require(findIndex != 99);&#13;
        if (findIndex != (length - 1)) {&#13;
            agonIdArray[findIndex] = agonIdArray[length - 1];&#13;
        } &#13;
        agonIdArray.length -= 1;&#13;
    }&#13;
&#13;
    function cancelAgon(uint64 _agonId) external {&#13;
        require(_agonId &lt; agonArray.length);&#13;
        Agon storage agon = agonArray[_agonId];&#13;
        require(agon.result == 0);&#13;
        require(agon.challenger == address(0));&#13;
        require(agon.master == msg.sender);&#13;
&#13;
        agon.result = 99;&#13;
        _removeAgonIdByOwner(msg.sender, _agonId);&#13;
        bitGuildContract.transfer(msg.sender, uint256(agon.agonPrice).mul(1000000000000000000));&#13;
&#13;
        CancelAgonPlat(_agonId, msg.sender, agon.outFlag);&#13;
    }&#13;
&#13;
    function cancelAgonForce(uint64 _agonId) external onlyService {&#13;
        require(_agonId &lt; agonArray.length);&#13;
        Agon storage agon = agonArray[_agonId];&#13;
        require(agon.result == 0);&#13;
        require(agon.challenger == address(0));&#13;
&#13;
        agon.result = 99;&#13;
        _removeAgonIdByOwner(agon.master, _agonId);&#13;
        bitGuildContract.transfer(agon.master, uint256(agon.agonPrice).mul(1000000000000000000));&#13;
&#13;
        CancelAgonPlat(_agonId, agon.master, agon.outFlag);&#13;
    }&#13;
&#13;
    function _newChallenge(uint64 _agonId, uint64 _flag, address _sender, uint256 _value) internal {&#13;
        require(_agonId &lt; agonArray.length);&#13;
        Agon storage agon = agonArray[_agonId];&#13;
        require(agon.result == 0);&#13;
        require(agon.master != _sender);&#13;
        require(uint256(agon.agonPrice).mul(1000000000000000000) == _value);&#13;
        require(agon.challenger == address(0));&#13;
&#13;
        require(bitGuildContract.transferFrom(_sender, address(this), _value));&#13;
&#13;
        agon.challenger = _sender;&#13;
        agon.agonFlag = _flag;&#13;
        ChallengeAgonPlat(_agonId, agon.master, agon.outFlag, _sender);&#13;
    }&#13;
&#13;
    function fightAgon(uint64 _agonId, uint64 _mFlag, uint256 _aSeed, uint256 _fSeed) external onlyService {&#13;
        require(_agonId &lt; agonArray.length);&#13;
        Agon storage agon = agonArray[_agonId];&#13;
        require(agon.result == 0 &amp;&amp; agon.challenger != address(0));&#13;
        require(fightContract != address(0));&#13;
        uint64 fRet = fightContract.calcFight(_mFlag, agon.agonFlag, _aSeed, _fSeed);&#13;
        require(fRet == 1 || fRet == 2);&#13;
        agon.result = fRet;&#13;
        _removeAgonIdByOwner(agon.master, _agonId);&#13;
        uint256 devCut = uint256(agon.agonPrice).div(10);&#13;
        uint256 winVal = uint256(agon.agonPrice).mul(2).sub(devCut);&#13;
        if (fRet == 1) {&#13;
            bitGuildContract.transfer(agon.master, winVal.mul(1000000000000000000));&#13;
        } else {&#13;
            bitGuildContract.transfer(agon.challenger, winVal.mul(1000000000000000000));&#13;
        }&#13;
&#13;
        ResolveAgonPlat(_agonId, agon.master, agon.outFlag, agon.challenger);&#13;
    }&#13;
&#13;
    function getPlatBalance() external view returns(uint256) {&#13;
        return bitGuildContract.balanceOf(this);&#13;
    }&#13;
&#13;
    function withdrawPlat() external {&#13;
        require(msg.sender == addrFinance || msg.sender == addrAdmin);&#13;
        uint256 balance = bitGuildContract.balanceOf(this);&#13;
        require(balance &gt; 0);&#13;
        bitGuildContract.transfer(addrFinance, balance);&#13;
    }&#13;
&#13;
    function getAgon(uint256 _agonId) external view&#13;
        returns(&#13;
            address master,&#13;
            address challenger,&#13;
            uint64 agonPrice,&#13;
            uint64 outFlag,&#13;
            uint64 agonFlag,&#13;
            uint64 result&#13;
        )&#13;
    {&#13;
        require(_agonId &lt; agonArray.length);&#13;
        Agon memory agon = agonArray[_agonId];&#13;
        master = agon.master;&#13;
        challenger = agon.challenger;&#13;
        agonPrice = agon.agonPrice;&#13;
        outFlag = agon.outFlag;&#13;
        agonFlag = agon.agonFlag;&#13;
        result = agon.result;&#13;
    }&#13;
&#13;
    function getAgonArray(uint64 _startAgonId, uint64 _count) external view&#13;
        returns(&#13;
            uint64[] agonIds,&#13;
            address[] masters,&#13;
            address[] challengers,&#13;
            uint64[] agonPrices,           &#13;
            uint64[] agonOutFlags,&#13;
            uint64[] agonFlags,&#13;
            uint64[] results&#13;
        ) &#13;
    {&#13;
        uint64 length = uint64(agonArray.length);&#13;
        require(_startAgonId &lt; length);&#13;
        require(_startAgonId &gt; 0);&#13;
        uint256 maxLen;&#13;
        if (_count == 0) {&#13;
            maxLen = length - _startAgonId;&#13;
        } else {&#13;
            maxLen = (length - _startAgonId) &gt;= _count ? _count : (length - _startAgonId);&#13;
        }&#13;
        agonIds = new uint64[](maxLen);&#13;
        masters = new address[](maxLen);&#13;
        challengers = new address[](maxLen);&#13;
        agonPrices = new uint64[](maxLen);&#13;
        agonOutFlags = new uint64[](maxLen);&#13;
        agonFlags = new uint64[](maxLen);&#13;
        results = new uint64[](maxLen);&#13;
        uint256 counter = 0;&#13;
        for (uint64 i = _startAgonId; i &lt; length; ++i) {&#13;
            Agon storage tmpAgon = agonArray[i];&#13;
            agonIds[counter] = i;&#13;
            masters[counter] = tmpAgon.master;&#13;
            challengers[counter] = tmpAgon.challenger;&#13;
            agonPrices[counter] = tmpAgon.agonPrice;&#13;
            agonOutFlags[counter] = tmpAgon.outFlag;&#13;
            agonFlags[counter] = tmpAgon.agonFlag;&#13;
            results[counter] = tmpAgon.result;&#13;
            counter += 1;&#13;
            if (counter &gt;= maxLen) {&#13;
                break;&#13;
            }&#13;
        }&#13;
    }&#13;
&#13;
    function getMaxAgonId() external view returns(uint256) {&#13;
        return agonArray.length - 1;&#13;
    }&#13;
&#13;
    function getAgonIdArray(address _owner) external view returns(uint64[]) {&#13;
        return ownerToAgonIdArray[_owner];&#13;
    }&#13;
}