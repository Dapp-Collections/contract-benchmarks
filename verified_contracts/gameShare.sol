/*
 ______   _________  ___   ___   _______    _______             ________  ______      
/_____/\ /________/\/__/\ /__/\ /______/\  /______/\           /_______/\/_____/\     
\::::_\/_\__.::.__\/\::\ \\  \ \\::::__\/__\::::__\/__         \__.::._\/\:::_ \ \    
 \:\/___/\  \::\ \   \::\/_\ .\ \\:\ /____/\\:\ /____/\  ___      \::\ \  \:\ \ \ \   
  \::___\/_  \::\ \   \:: ___::\ \\:\\_  _\/ \:\\_  _\/ /__/\     _\::\ \__\:\ \ \ \  
   \:\____/\  \::\ \   \: \ \\::\ \\:\_\ \ \  \:\_\ \ \ \::\ \   /__\::\__/\\:\_\ \ \ 
    \_____\/   \__\/    \__\/ \::\/ \_____\/   \_____\/  \:_\/   \________\/ \_____\/ 
  ______ _______ _    _    _____  ____   ____  _____     _____          __  __ ______  _____ 
 |  ____|__   __| |  | |  / ____|/ __ \ / __ \|  __ \   / ____|   /\   |  \/  |  ____|/ ____|
 | |__     | |  | |__| | | |  __| |  | | |  | | |  | | | |  __   /  \  | \  / | |__  | (___  
 |  __|    | |  |  __  | | | |_ | |  | | |  | | |  | | | | |_ | / /\ \ | |\/| |  __|  \___ \ 
 | |____   | |  | |  | | | |__| | |__| | |__| | |__| | | |__| |/ ____ \| |  | | |____ ____) |
 |______|  |_|  |_|  |_|  \_____|\____/ \____/|_____/   \_____/_/    \_\_|  |_|______|_____/ 
                                                                                             
                                                         BY : <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="571b3a24043c2e17103a363e3b7934383a">[email protected]</a>&#13;
*/                            &#13;
&#13;
pragma solidity ^0.4.25;&#13;
pragma experimental "v0.5.0";&#13;
contract safeApi{&#13;
    &#13;
   modifier safe(){&#13;
        address _addr = msg.sender;&#13;
        require (_addr == tx.origin,'Error Action!');&#13;
        uint256 _codeLength;&#13;
        assembly {_codeLength := extcodesize(_addr)}&#13;
        require(_codeLength == 0, "Sender not authorized!");&#13;
            _;&#13;
    }&#13;
&#13;
&#13;
    &#13;
 function toBytes(uint256 _num) internal returns (bytes _ret) {&#13;
   assembly {&#13;
        _ret := mload(0x10)&#13;
        mstore(_ret, 0x20)&#13;
        mstore(add(_ret, 0x20), _num)&#13;
    }&#13;
}&#13;
&#13;
function subStr(string _s, uint start, uint end) internal pure returns (string){&#13;
        bytes memory s = bytes(_s);&#13;
        string memory copy = new string(end - start);&#13;
//        string memory copy = new string(5);&#13;
          uint k = 0;&#13;
        for (uint i = start; i &lt; end; i++){ &#13;
            bytes(copy)[k++] = bytes(_s)[i];&#13;
        }&#13;
        return copy;&#13;
    }&#13;
     &#13;
&#13;
 function safePercent(uint256 a,uint256 b) &#13;
      internal&#13;
      constant&#13;
      returns(uint256)&#13;
      {&#13;
        assert(a&gt;0 &amp;&amp; a &lt;=100);&#13;
        return  div(mul(b,a),100);&#13;
      }&#13;
      &#13;
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
    uint256 c = a * b;&#13;
    assert(a == 0 || c / a == b);&#13;
    return c;&#13;
  }&#13;
 &#13;
  function div(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
    // assert(b &gt; 0); // Solidity automatically throws when dividing by 0∂&#13;
    uint256 c = a / b;&#13;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold&#13;
    return c;&#13;
  }&#13;
 &#13;
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
    assert(b &lt;= a);&#13;
    return a - b;&#13;
  }&#13;
 &#13;
  function add(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
    uint256 c = a + b;&#13;
    assert(c &gt;= a);&#13;
    return c;&#13;
  }&#13;
&#13;
}&#13;
&#13;
contract gameShare is safeApi{&#13;
    struct player&#13;
    {&#13;
        uint256 id;&#13;
        address addr;&#13;
        uint256 balance;//wei&#13;
        uint256 affNumLevel_1;&#13;
        uint256 affNumLevel_2;&#13;
        uint256 timeStamp;&#13;
    }&#13;
 &#13;
    mapping (uint256 =&gt; player) public player_;&#13;
    mapping (address =&gt; uint256) public playAddr_;&#13;
    mapping (uint256 =&gt; uint256) public playAff_;&#13;
    &#13;
    mapping (address =&gt; uint256) private contractWhite;&#13;
    address [] private contractWhitelist;&#13;
    &#13;
    mapping(address=&gt;uint256) public otherGameAff_;&#13;
    &#13;
    uint256 private autoPlayId_=123456;&#13;
    address public admin_;&#13;
    uint256 public gameTicketWei_=10000000000000000;//0.01 ether&#13;
    uint8 public leve1Rewards_=50;//%&#13;
    uint8 public leve2Rewards_=20;//%&#13;
    uint256 public feeAmount_=200;&#13;
&#13;
&#13;
    /* Initializes contract with initial supply tokens to the creator of the contract */&#13;
    constructor() public {&#13;
        admin_ = msg.sender;&#13;
        getPlayId();&#13;
        contractWhitelist.push(address(0));&#13;
    }&#13;
    &#13;
    /* Send coins */&#13;
    function addGame(uint256 _affCode)&#13;
    safe() &#13;
    isPlay() &#13;
    external&#13;
    payable {&#13;
        &#13;
      if(_affCode == 0 &amp;&amp;  feeAmount_&gt;0){&#13;
             feeAmount_--;&#13;
      }else{&#13;
         require(msg.value == gameTicketWei_,'Please pay the correct eth');&#13;
      }&#13;
       uint256 _pid=getPlayId();&#13;
      if(msg.value==0)&#13;
        return;&#13;
       &#13;
        uint256 adminAmount=msg.value;&#13;
        if(_affCode&gt;0 &amp;&amp; _affCode != _pid &amp;&amp; player_[_affCode].id &gt;0)&#13;
        {&#13;
             uint256 leve1Amount=safePercent(leve1Rewards_,gameTicketWei_);&#13;
             player_[_affCode].affNumLevel_1++;&#13;
             playAff_[_pid]=player_[_affCode].id;&#13;
             adminAmount-=leve1Amount;&#13;
             player_[_affCode].balance+=leve1Amount;&#13;
             uint256 leve2Pid=playAff_[_affCode];&#13;
              if(leve2Pid&gt;0){&#13;
                uint256 leve2Amount=safePercent(leve2Rewards_,gameTicketWei_);&#13;
                player_[leve2Pid].affNumLevel_2++;&#13;
                adminAmount-=leve2Amount;&#13;
                player_[leve2Pid].balance+=leve2Amount;&#13;
              }&#13;
        }&#13;
        player_[playAddr_[admin_]].balance=add(player_[playAddr_[admin_]].balance,adminAmount);&#13;
    }&#13;
    &#13;
    &#13;
    function withdraw(uint256 pid) safe() external{&#13;
        require(playAddr_[msg.sender] == pid,'Error Action');&#13;
        require(player_[pid].addr == msg.sender,'Error Action');&#13;
        require(player_[pid].balance &gt;= gameTicketWei_,'Insufficient balance');&#13;
        uint256 balance =player_[pid].balance;&#13;
        player_[pid].balance=0;&#13;
        player_[pid].addr.transfer(balance);&#13;
    }&#13;
    &#13;
&#13;
    &#13;
    function getPlayId() private returns(uint256){&#13;
        &#13;
         require(&#13;
                playAddr_[msg.sender] ==0,&#13;
                "Error Player"&#13;
            );&#13;
        &#13;
        autoPlayId_++;&#13;
        uint256 _pid=autoPlayId_;&#13;
       &#13;
        playAddr_[msg.sender]=_pid;&#13;
        player_[_pid].id=_pid;&#13;
        player_[_pid].addr=msg.sender;&#13;
        player_[_pid].balance=0;&#13;
        player_[_pid].timeStamp=now;    &#13;
        return _pid;&#13;
   }&#13;
   &#13;
     modifier  isPlay(){&#13;
            require(&#13;
                playAddr_[msg.sender] == 0,&#13;
                "Everyone can only participate once"&#13;
                );        &#13;
            _;&#13;
        }&#13;
    &#13;
    function getShareAff(uint256 _affCode) external view returns(uint256,address,address){&#13;
        &#13;
        &#13;
        uint256 pid=playAddr_[msg.sender];&#13;
        uint256 level1pid=playAff_[pid];&#13;
        if(pid&gt;0 &amp;&amp; level1pid&gt;0){&#13;
          uint256 level2Pid=playAff_[level1pid];&#13;
          return(&#13;
            player_[level1pid].id,&#13;
            player_[level1pid].addr,&#13;
            player_[level2Pid].addr&#13;
            );&#13;
        }&#13;
        uint256 level2Pid=playAff_[_affCode];&#13;
        return(&#13;
            player_[_affCode].id,&#13;
            player_[_affCode].addr,&#13;
            player_[level2Pid].addr&#13;
            );&#13;
    }&#13;
        &#13;
    function getOtherGameAff() external view returns(uint256,address,address){&#13;
        uint256 pid=otherGameAff_[msg.sender];&#13;
        require(pid&gt;0 &amp;&amp; player_[pid].id&gt;0);&#13;
        uint256 level2Pid = playAff_[pid];&#13;
        return(&#13;
            pid,&#13;
            player_[pid].addr,&#13;
            player_[level2Pid].addr&#13;
            );&#13;
    }&#13;
  &#13;
    //Create a user's sharing relationship&#13;
    function addOtherGameAff(uint256 pid,address myAddr,address level1,address level2) public{&#13;
        &#13;
        uint256 _codeLength;&#13;
        address _addr = msg.sender;&#13;
        assembly {_codeLength := extcodesize(_addr)}&#13;
        require(_codeLength &gt; 0, "Sender not authorized!");&#13;
        require(contractWhite[_addr]&gt;0,'ERROR');&#13;
        require(address(0)!= myAddr);&#13;
        require(pid &gt;0 &amp;&amp; address(0)!= level1 &amp;&amp; player_[pid].addr == level1,'Error1');&#13;
        require(myAddr!=level1,'Error4');&#13;
        require(myAddr!=level2,'Error4');&#13;
        uint256  level2Pid=playAff_[pid];&#13;
        require(level2==player_[level2Pid].addr,'Error2');&#13;
        uint256 addfPid=otherGameAff_[myAddr];        &#13;
        if(addfPid&gt;0){&#13;
            require(addfPid ==pid);&#13;
            return;&#13;
        }&#13;
        otherGameAff_[myAddr]=pid;&#13;
    }&#13;
    &#13;
    //update Can get a contract to share information&#13;
    function updateCW(address addr,uint8 status) external safe(){&#13;
        require(msg.sender==admin_);&#13;
        if(status==0){&#13;
            if(contractWhite[addr]==0){&#13;
                contractWhitelist.push(addr);&#13;
                contractWhite[addr]=contractWhitelist.length;&#13;
            }&#13;
        }else{&#13;
           delete contractWhitelist[contractWhite[addr]];&#13;
           delete  contractWhite[addr];&#13;
        }&#13;
    }&#13;
    &#13;
      //2020.01.01 Close Game&#13;
   function closeGame() external safe() {&#13;
        uint256 closeTime=1577808000;&#13;
        require(now &gt; closeTime,'Time has not arrived');&#13;
        require(msg.sender == admin_,'Error');&#13;
        selfdestruct(admin_);&#13;
    }&#13;
    &#13;
    function getCwList() external  safe()  view returns( address []){&#13;
         require(msg.sender==admin_);&#13;
         return contractWhitelist;&#13;
    }&#13;
        &#13;
}