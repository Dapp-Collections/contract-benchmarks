// Sources flattened with buidler v0.1.5
pragma solidity 0.4.24;


// File openzeppelin-solidity/contracts/token/ERC20/<span class="__cf_email__" data-cfemail="7b3e2938494b391a081218550814173b0d4a554a49554b">[email protected]</span>&#13;
&#13;
/**&#13;
 * @title ERC20Basic&#13;
 * @dev Simpler version of ERC20 interface&#13;
 * See https://github.com/ethereum/EIPs/issues/179&#13;
 */&#13;
contract ERC20Basic {&#13;
  function totalSupply() public view returns (uint256);&#13;
  function balanceOf(address _who) public view returns (uint256);&#13;
  function transfer(address _to, uint256 _value) public returns (bool);&#13;
  event Transfer(address indexed from, address indexed to, uint256 value);&#13;
}&#13;
&#13;
&#13;
// File openzeppelin-solidity/contracts/token/ERC20/<span class="__cf_email__" data-cfemail="d2978091e0e2fca1bdbe92a4e3fce3e0fce2">[email protected]</span>&#13;
&#13;
/**&#13;
 * @title ERC20 interface&#13;
 * @dev see https://github.com/ethereum/EIPs/issues/20&#13;
 */&#13;
contract ERC20 is ERC20Basic {&#13;
  function allowance(address _owner, address _spender)&#13;
    public view returns (uint256);&#13;
&#13;
  function transferFrom(address _from, address _to, uint256 _value)&#13;
    public returns (bool);&#13;
&#13;
  function approve(address _spender, uint256 _value) public returns (bool);&#13;
  event Approval(&#13;
    address indexed owner,&#13;
    address indexed spender,&#13;
    uint256 value&#13;
  );&#13;
}&#13;
&#13;
&#13;
// File openzeppelin-solidity/contracts/token/ERC20/<span class="__cf_email__" data-cfemail="9dcefcfbf8d8cfdeafadb3eef2f1ddebacb3acafb3ad">[email protected]</span>&#13;
&#13;
/**&#13;
 * @title SafeERC20&#13;
 * @dev Wrappers around ERC20 operations that throw on failure.&#13;
 * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,&#13;
 * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.&#13;
 */&#13;
library SafeERC20 {&#13;
  function safeTransfer(&#13;
    ERC20Basic _token,&#13;
    address _to,&#13;
    uint256 _value&#13;
  )&#13;
    internal&#13;
  {&#13;
    require(_token.transfer(_to, _value));&#13;
  }&#13;
&#13;
  function safeTransferFrom(&#13;
    ERC20 _token,&#13;
    address _from,&#13;
    address _to,&#13;
    uint256 _value&#13;
  )&#13;
    internal&#13;
  {&#13;
    require(_token.transferFrom(_from, _to, _value));&#13;
  }&#13;
&#13;
  function safeApprove(&#13;
    ERC20 _token,&#13;
    address _spender,&#13;
    uint256 _value&#13;
  )&#13;
    internal&#13;
  {&#13;
    require(_token.approve(_spender, _value));&#13;
  }&#13;
}&#13;
&#13;
&#13;
// File openzeppelin-solidity/contracts/ownership/<span class="__cf_email__" data-cfemail="1f5068717e7d737a316c70735f692e312e2d312f">[email protected]</span>&#13;
&#13;
/**&#13;
 * @title Ownable&#13;
 * @dev The Ownable contract has an owner address, and provides basic authorization control&#13;
 * functions, this simplifies the implementation of "user permissions".&#13;
 */&#13;
contract Ownable {&#13;
  address public owner;&#13;
&#13;
&#13;
  event OwnershipRenounced(address indexed previousOwner);&#13;
  event OwnershipTransferred(&#13;
    address indexed previousOwner,&#13;
    address indexed newOwner&#13;
  );&#13;
&#13;
&#13;
  /**&#13;
   * @dev The Ownable constructor sets the original `owner` of the contract to the sender&#13;
   * account.&#13;
   */&#13;
  constructor() public {&#13;
    owner = msg.sender;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Throws if called by any account other than the owner.&#13;
   */&#13;
  modifier onlyOwner() {&#13;
    require(msg.sender == owner);&#13;
    _;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Allows the current owner to relinquish control of the contract.&#13;
   * @notice Renouncing to ownership will leave the contract without an owner.&#13;
   * It will not be possible to call the functions with the `onlyOwner`&#13;
   * modifier anymore.&#13;
   */&#13;
  function renounceOwnership() public onlyOwner {&#13;
    emit OwnershipRenounced(owner);&#13;
    owner = address(0);&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Allows the current owner to transfer control of the contract to a newOwner.&#13;
   * @param _newOwner The address to transfer ownership to.&#13;
   */&#13;
  function transferOwnership(address _newOwner) public onlyOwner {&#13;
    _transferOwnership(_newOwner);&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Transfers control of the contract to a newOwner.&#13;
   * @param _newOwner The address to transfer ownership to.&#13;
   */&#13;
  function _transferOwnership(address _newOwner) internal {&#13;
    require(_newOwner != address(0));&#13;
    emit OwnershipTransferred(owner, _newOwner);&#13;
    owner = _newOwner;&#13;
  }&#13;
}&#13;
&#13;
&#13;
// File openzeppelin-solidity/contracts/access/rbac/<span class="__cf_email__" data-cfemail="2a7845464f59045945466a5c1b041b18041a">[email protected]</span>&#13;
&#13;
/**&#13;
 * @title Roles&#13;
 * @author Francisco Giordano (@frangio)&#13;
 * @dev Library for managing addresses assigned to a Role.&#13;
 * See RBAC.sol for example usage.&#13;
 */&#13;
library Roles {&#13;
  struct Role {&#13;
    mapping (address =&gt; bool) bearer;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev give an address access to this role&#13;
   */&#13;
  function add(Role storage _role, address _addr)&#13;
    internal&#13;
  {&#13;
    _role.bearer[_addr] = true;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev remove an address' access to this role&#13;
   */&#13;
  function remove(Role storage _role, address _addr)&#13;
    internal&#13;
  {&#13;
    _role.bearer[_addr] = false;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev check if an address has this role&#13;
   * // reverts&#13;
   */&#13;
  function check(Role storage _role, address _addr)&#13;
    internal&#13;
    view&#13;
  {&#13;
    require(has(_role, _addr));&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev check if an address has this role&#13;
   * @return bool&#13;
   */&#13;
  function has(Role storage _role, address _addr)&#13;
    internal&#13;
    view&#13;
    returns (bool)&#13;
  {&#13;
    return _role.bearer[_addr];&#13;
  }&#13;
}&#13;
&#13;
&#13;
// File openzeppelin-solidity/contracts/access/rbac/<span class="__cf_email__" data-cfemail="fdafbfbcbed38e9291bd8bccd3cccfd3cd">[email protected]</span>&#13;
&#13;
/**&#13;
 * @title RBAC (Role-Based Access Control)&#13;
 * @author Matt Condon (@Shrugs)&#13;
 * @dev Stores and provides setters and getters for roles and addresses.&#13;
 * Supports unlimited numbers of roles and addresses.&#13;
 * See //contracts/mocks/RBACMock.sol for an example of usage.&#13;
 * This RBAC method uses strings to key roles. It may be beneficial&#13;
 * for you to write your own implementation of this interface using Enums or similar.&#13;
 */&#13;
contract RBAC {&#13;
  using Roles for Roles.Role;&#13;
&#13;
  mapping (string =&gt; Roles.Role) private roles;&#13;
&#13;
  event RoleAdded(address indexed operator, string role);&#13;
  event RoleRemoved(address indexed operator, string role);&#13;
&#13;
  /**&#13;
   * @dev reverts if addr does not have role&#13;
   * @param _operator address&#13;
   * @param _role the name of the role&#13;
   * // reverts&#13;
   */&#13;
  function checkRole(address _operator, string _role)&#13;
    public&#13;
    view&#13;
  {&#13;
    roles[_role].check(_operator);&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev determine if addr has role&#13;
   * @param _operator address&#13;
   * @param _role the name of the role&#13;
   * @return bool&#13;
   */&#13;
  function hasRole(address _operator, string _role)&#13;
    public&#13;
    view&#13;
    returns (bool)&#13;
  {&#13;
    return roles[_role].has(_operator);&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev add a role to an address&#13;
   * @param _operator address&#13;
   * @param _role the name of the role&#13;
   */&#13;
  function addRole(address _operator, string _role)&#13;
    internal&#13;
  {&#13;
    roles[_role].add(_operator);&#13;
    emit RoleAdded(_operator, _role);&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev remove a role from an address&#13;
   * @param _operator address&#13;
   * @param _role the name of the role&#13;
   */&#13;
  function removeRole(address _operator, string _role)&#13;
    internal&#13;
  {&#13;
    roles[_role].remove(_operator);&#13;
    emit RoleRemoved(_operator, _role);&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev modifier to scope access to a single role (uses msg.sender as addr)&#13;
   * @param _role the name of the role&#13;
   * // reverts&#13;
   */&#13;
  modifier onlyRole(string _role)&#13;
  {&#13;
    checkRole(msg.sender, _role);&#13;
    _;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev modifier to scope access to a set of roles (uses msg.sender as addr)&#13;
   * @param _roles the names of the roles to scope access to&#13;
   * // reverts&#13;
   *&#13;
   * @TODO - when solidity supports dynamic arrays as arguments to modifiers, provide this&#13;
   *  see: https://github.com/ethereum/solidity/issues/2467&#13;
   */&#13;
  // modifier onlyRoles(string[] _roles) {&#13;
  //     bool hasAnyRole = false;&#13;
  //     for (uint8 i = 0; i &lt; _roles.length; i++) {&#13;
  //         if (hasRole(msg.sender, _roles[i])) {&#13;
  //             hasAnyRole = true;&#13;
  //             break;&#13;
  //         }&#13;
  //     }&#13;
&#13;
  //     require(hasAnyRole);&#13;
&#13;
  //     _;&#13;
  // }&#13;
}&#13;
&#13;
&#13;
// File openzeppelin-solidity/contracts/<span class="__cf_email__" data-cfemail="7336302116101c0516010a5d001c1f3305425d42415d43">[email protected]</span>&#13;
&#13;
/**&#13;
 * @title Elliptic curve signature operations&#13;
 * @dev Based on https://gist.github.com/axic/5b33912c6f61ae6fd96d6c4a47afde6d&#13;
 * TODO Remove this library once solidity supports passing a signature to ecrecover.&#13;
 * See https://github.com/ethereum/solidity/issues/864&#13;
 */&#13;
&#13;
library ECRecovery {&#13;
&#13;
  /**&#13;
   * @dev Recover signer address from a message by using their signature&#13;
   * @param _hash bytes32 message, the hash is the signed message. What is recovered is the signer address.&#13;
   * @param _sig bytes signature, the signature is generated using web3.eth.sign()&#13;
   */&#13;
  function recover(bytes32 _hash, bytes _sig)&#13;
    internal&#13;
    pure&#13;
    returns (address)&#13;
  {&#13;
    bytes32 r;&#13;
    bytes32 s;&#13;
    uint8 v;&#13;
&#13;
    // Check the signature length&#13;
    if (_sig.length != 65) {&#13;
      return (address(0));&#13;
    }&#13;
&#13;
    // Divide the signature in r, s and v variables&#13;
    // ecrecover takes the signature parameters, and the only way to get them&#13;
    // currently is to use assembly.&#13;
    // solium-disable-next-line security/no-inline-assembly&#13;
    assembly {&#13;
      r := mload(add(_sig, 32))&#13;
      s := mload(add(_sig, 64))&#13;
      v := byte(0, mload(add(_sig, 96)))&#13;
    }&#13;
&#13;
    // Version of signature should be 27 or 28, but 0 and 1 are also possible versions&#13;
    if (v &lt; 27) {&#13;
      v += 27;&#13;
    }&#13;
&#13;
    // If the version is correct return the signer address&#13;
    if (v != 27 &amp;&amp; v != 28) {&#13;
      return (address(0));&#13;
    } else {&#13;
      // solium-disable-next-line arg-overflow&#13;
      return ecrecover(_hash, v, r, s);&#13;
    }&#13;
  }&#13;
&#13;
  /**&#13;
   * toEthSignedMessageHash&#13;
   * @dev prefix a bytes32 value with "\x19Ethereum Signed Message:"&#13;
   * and hash the result&#13;
   */&#13;
  function toEthSignedMessageHash(bytes32 _hash)&#13;
    internal&#13;
    pure&#13;
    returns (bytes32)&#13;
  {&#13;
    // 32 is the length in bytes of hash,&#13;
    // enforced by the type signature above&#13;
    return keccak256(&#13;
      abi.encodePacked("\x19Ethereum Signed Message:\n32", _hash)&#13;
    );&#13;
  }&#13;
}&#13;
&#13;
&#13;
// File openzeppelin-solidity/contracts/access/<span class="__cf_email__" data-cfemail="12417b757c7366676077507d677c7177603c617d7e5264233c23203c22">[email protected]</span>&#13;
&#13;
/**&#13;
 * @title SignatureBouncer&#13;
 * @author PhABC, Shrugs and aflesher&#13;
 * @dev Bouncer allows users to submit a signature as a permission to do an action.&#13;
 * If the signature is from one of the authorized bouncer addresses, the signature&#13;
 * is valid. The owner of the contract adds/removes bouncers.&#13;
 * Bouncer addresses can be individual servers signing grants or different&#13;
 * users within a decentralized club that have permission to invite other members.&#13;
 * This technique is useful for whitelists and airdrops; instead of putting all&#13;
 * valid addresses on-chain, simply sign a grant of the form&#13;
 * keccak256(abi.encodePacked(`:contractAddress` + `:granteeAddress`)) using a valid bouncer address.&#13;
 * Then restrict access to your crowdsale/whitelist/airdrop using the&#13;
 * `onlyValidSignature` modifier (or implement your own using isValidSignature).&#13;
 * In addition to `onlyValidSignature`, `onlyValidSignatureAndMethod` and&#13;
 * `onlyValidSignatureAndData` can be used to restrict access to only a given method&#13;
 * or a given method with given parameters respectively.&#13;
 * See the tests Bouncer.test.js for specific usage examples.&#13;
 * @notice A method that uses the `onlyValidSignatureAndData` modifier must make the _sig&#13;
 * parameter the "last" parameter. You cannot sign a message that has its own&#13;
 * signature in it so the last 128 bytes of msg.data (which represents the&#13;
 * length of the _sig data and the _sig data itself) is ignored when validating.&#13;
 * Also non fixed sized parameters make constructing the data in the signature&#13;
 * much more complex. See https://ethereum.stackexchange.com/a/50616 for more details.&#13;
 */&#13;
contract SignatureBouncer is Ownable, RBAC {&#13;
  using ECRecovery for bytes32;&#13;
&#13;
  string public constant ROLE_BOUNCER = "bouncer";&#13;
  uint constant METHOD_ID_SIZE = 4;&#13;
  // signature size is 65 bytes (tightly packed v + r + s), but gets padded to 96 bytes&#13;
  uint constant SIGNATURE_SIZE = 96;&#13;
&#13;
  /**&#13;
   * @dev requires that a valid signature of a bouncer was provided&#13;
   */&#13;
  modifier onlyValidSignature(bytes _sig)&#13;
  {&#13;
    require(isValidSignature(msg.sender, _sig));&#13;
    _;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev requires that a valid signature with a specifed method of a bouncer was provided&#13;
   */&#13;
  modifier onlyValidSignatureAndMethod(bytes _sig)&#13;
  {&#13;
    require(isValidSignatureAndMethod(msg.sender, _sig));&#13;
    _;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev requires that a valid signature with a specifed method and params of a bouncer was provided&#13;
   */&#13;
  modifier onlyValidSignatureAndData(bytes _sig)&#13;
  {&#13;
    require(isValidSignatureAndData(msg.sender, _sig));&#13;
    _;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev allows the owner to add additional bouncer addresses&#13;
   */&#13;
  function addBouncer(address _bouncer)&#13;
    public&#13;
    onlyOwner&#13;
  {&#13;
    require(_bouncer != address(0));&#13;
    addRole(_bouncer, ROLE_BOUNCER);&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev allows the owner to remove bouncer addresses&#13;
   */&#13;
  function removeBouncer(address _bouncer)&#13;
    public&#13;
    onlyOwner&#13;
  {&#13;
    require(_bouncer != address(0));&#13;
    removeRole(_bouncer, ROLE_BOUNCER);&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev is the signature of `this + sender` from a bouncer?&#13;
   * @return bool&#13;
   */&#13;
  function isValidSignature(address _address, bytes _sig)&#13;
    internal&#13;
    view&#13;
    returns (bool)&#13;
  {&#13;
    return isValidDataHash(&#13;
      keccak256(abi.encodePacked(address(this), _address)),&#13;
      _sig&#13;
    );&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev is the signature of `this + sender + methodId` from a bouncer?&#13;
   * @return bool&#13;
   */&#13;
  function isValidSignatureAndMethod(address _address, bytes _sig)&#13;
    internal&#13;
    view&#13;
    returns (bool)&#13;
  {&#13;
    bytes memory data = new bytes(METHOD_ID_SIZE);&#13;
    for (uint i = 0; i &lt; data.length; i++) {&#13;
      data[i] = msg.data[i];&#13;
    }&#13;
    return isValidDataHash(&#13;
      keccak256(abi.encodePacked(address(this), _address, data)),&#13;
      _sig&#13;
    );&#13;
  }&#13;
&#13;
  /**&#13;
    * @dev is the signature of `this + sender + methodId + params(s)` from a bouncer?&#13;
    * @notice the _sig parameter of the method being validated must be the "last" parameter&#13;
    * @return bool&#13;
    */&#13;
  function isValidSignatureAndData(address _address, bytes _sig)&#13;
    internal&#13;
    view&#13;
    returns (bool)&#13;
  {&#13;
    require(msg.data.length &gt; SIGNATURE_SIZE);&#13;
    bytes memory data = new bytes(msg.data.length - SIGNATURE_SIZE);&#13;
    for (uint i = 0; i &lt; data.length; i++) {&#13;
      data[i] = msg.data[i];&#13;
    }&#13;
    return isValidDataHash(&#13;
      keccak256(abi.encodePacked(address(this), _address, data)),&#13;
      _sig&#13;
    );&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev internal function to convert a hash to an eth signed message&#13;
   * and then recover the signature and check it against the bouncer role&#13;
   * @return bool&#13;
   */&#13;
  function isValidDataHash(bytes32 _hash, bytes _sig)&#13;
    internal&#13;
    view&#13;
    returns (bool)&#13;
  {&#13;
    address signer = _hash&#13;
      .toEthSignedMessageHash()&#13;
      .recover(_sig);&#13;
    return hasRole(signer, ROLE_BOUNCER);&#13;
  }&#13;
}&#13;
&#13;
&#13;
// File contracts/EscrowedERC20Bouncer.sol&#13;
&#13;
contract EscrowedERC20Bouncer is SignatureBouncer {&#13;
  using SafeERC20 for ERC20;&#13;
&#13;
  uint256 public nonce;&#13;
&#13;
  modifier onlyBouncer()&#13;
  {&#13;
    checkRole(msg.sender, ROLE_BOUNCER);&#13;
    _;&#13;
  }&#13;
&#13;
  modifier validDataWithoutSender(bytes _signature)&#13;
  {&#13;
    require(isValidSignatureAndData(address(this), _signature), "INVALID_SIGNATURE");&#13;
    _;&#13;
  }&#13;
&#13;
  constructor(address _bouncer)&#13;
    public&#13;
  {&#13;
    addBouncer(_bouncer);&#13;
  }&#13;
&#13;
  /**&#13;
   * allow anyone with a valid bouncer signature for the msg data to send `_amount` of `_token` to `_to`&#13;
   */&#13;
  function withdraw(uint256 _nonce, ERC20 _token, address _to, uint256 _amount, bytes _signature)&#13;
    public&#13;
    validDataWithoutSender(_signature)&#13;
  {&#13;
    require(_nonce &gt; nonce, "NONCE_GT_NONCE_REQUIRED");&#13;
    nonce = _nonce;&#13;
    _token.safeTransfer(_to, _amount);&#13;
  }&#13;
&#13;
  /**&#13;
   * Allow the bouncer to withdraw all of the ERC20 tokens in the contract&#13;
   */&#13;
  function withdrawAll(ERC20 _token, address _to)&#13;
    public&#13;
    onlyBouncer&#13;
  {&#13;
    _token.safeTransfer(_to, _token.balanceOf(address(this)));&#13;
  }&#13;
}&#13;
&#13;
&#13;
// File openzeppelin-solidity/contracts/introspection/<span class="__cf_email__" data-cfemail="317463720007041f425e5d7147001f00031f01">[email protected]</span>&#13;
&#13;
/**&#13;
 * @title ERC165&#13;
 * @dev https://github.com/ethereum/EIPs/blob/master/EIPS/eip-165.md&#13;
 */&#13;
interface ERC165 {&#13;
&#13;
  /**&#13;
   * @notice Query if a contract implements an interface&#13;
   * @param _interfaceId The interface identifier, as specified in ERC-165&#13;
   * @dev Interface identification is specified in ERC-165. This function&#13;
   * uses less than 30,000 gas.&#13;
   */&#13;
  function supportsInterface(bytes4 _interfaceId)&#13;
    external&#13;
    view&#13;
    returns (bool);&#13;
}&#13;
&#13;
&#13;
// File openzeppelin-solidity/contracts/token/ERC721/<span class="__cf_email__" data-cfemail="024750413530334063716b612c716d6e4274332c33302c32">[email protected]</span>&#13;
&#13;
/**&#13;
 * @title ERC721 Non-Fungible Token Standard basic interface&#13;
 * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md&#13;
 */&#13;
contract ERC721Basic is ERC165 {&#13;
&#13;
  bytes4 internal constant InterfaceId_ERC721 = 0x80ac58cd;&#13;
  /*&#13;
   * 0x80ac58cd ===&#13;
   *   bytes4(keccak256('balanceOf(address)')) ^&#13;
   *   bytes4(keccak256('ownerOf(uint256)')) ^&#13;
   *   bytes4(keccak256('approve(address,uint256)')) ^&#13;
   *   bytes4(keccak256('getApproved(uint256)')) ^&#13;
   *   bytes4(keccak256('setApprovalForAll(address,bool)')) ^&#13;
   *   bytes4(keccak256('isApprovedForAll(address,address)')) ^&#13;
   *   bytes4(keccak256('transferFrom(address,address,uint256)')) ^&#13;
   *   bytes4(keccak256('safeTransferFrom(address,address,uint256)')) ^&#13;
   *   bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)'))&#13;
   */&#13;
&#13;
  bytes4 internal constant InterfaceId_ERC721Exists = 0x4f558e79;&#13;
  /*&#13;
   * 0x4f558e79 ===&#13;
   *   bytes4(keccak256('exists(uint256)'))&#13;
   */&#13;
&#13;
  bytes4 internal constant InterfaceId_ERC721Enumerable = 0x780e9d63;&#13;
  /**&#13;
   * 0x780e9d63 ===&#13;
   *   bytes4(keccak256('totalSupply()')) ^&#13;
   *   bytes4(keccak256('tokenOfOwnerByIndex(address,uint256)')) ^&#13;
   *   bytes4(keccak256('tokenByIndex(uint256)'))&#13;
   */&#13;
&#13;
  bytes4 internal constant InterfaceId_ERC721Metadata = 0x5b5e139f;&#13;
  /**&#13;
   * 0x5b5e139f ===&#13;
   *   bytes4(keccak256('name()')) ^&#13;
   *   bytes4(keccak256('symbol()')) ^&#13;
   *   bytes4(keccak256('tokenURI(uint256)'))&#13;
   */&#13;
&#13;
  event Transfer(&#13;
    address indexed _from,&#13;
    address indexed _to,&#13;
    uint256 indexed _tokenId&#13;
  );&#13;
  event Approval(&#13;
    address indexed _owner,&#13;
    address indexed _approved,&#13;
    uint256 indexed _tokenId&#13;
  );&#13;
  event ApprovalForAll(&#13;
    address indexed _owner,&#13;
    address indexed _operator,&#13;
    bool _approved&#13;
  );&#13;
&#13;
  function balanceOf(address _owner) public view returns (uint256 _balance);&#13;
  function ownerOf(uint256 _tokenId) public view returns (address _owner);&#13;
  function exists(uint256 _tokenId) public view returns (bool _exists);&#13;
&#13;
  function approve(address _to, uint256 _tokenId) public;&#13;
  function getApproved(uint256 _tokenId)&#13;
    public view returns (address _operator);&#13;
&#13;
  function setApprovalForAll(address _operator, bool _approved) public;&#13;
  function isApprovedForAll(address _owner, address _operator)&#13;
    public view returns (bool);&#13;
&#13;
  function transferFrom(address _from, address _to, uint256 _tokenId) public;&#13;
  function safeTransferFrom(address _from, address _to, uint256 _tokenId)&#13;
    public;&#13;
&#13;
  function safeTransferFrom(&#13;
    address _from,&#13;
    address _to,&#13;
    uint256 _tokenId,&#13;
    bytes _data&#13;
  )&#13;
    public;&#13;
}&#13;
&#13;
&#13;
// File openzeppelin-solidity/contracts/token/ERC721/<span class="__cf_email__" data-cfemail="6c293e2f5b5e5d421f03002c1a5d425d5e425c">[email protected]</span>&#13;
&#13;
/**&#13;
 * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension&#13;
 * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md&#13;
 */&#13;
contract ERC721Enumerable is ERC721Basic {&#13;
  function totalSupply() public view returns (uint256);&#13;
  function tokenOfOwnerByIndex(&#13;
    address _owner,&#13;
    uint256 _index&#13;
  )&#13;
    public&#13;
    view&#13;
    returns (uint256 _tokenId);&#13;
&#13;
  function tokenByIndex(uint256 _index) public view returns (uint256);&#13;
}&#13;
&#13;
&#13;
/**&#13;
 * @title ERC-721 Non-Fungible Token Standard, optional metadata extension&#13;
 * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md&#13;
 */&#13;
contract ERC721Metadata is ERC721Basic {&#13;
  function name() external view returns (string _name);&#13;
  function symbol() external view returns (string _symbol);&#13;
  function tokenURI(uint256 _tokenId) public view returns (string);&#13;
}&#13;
&#13;
&#13;
/**&#13;
 * @title ERC-721 Non-Fungible Token Standard, full implementation interface&#13;
 * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md&#13;
 */&#13;
contract ERC721 is ERC721Basic, ERC721Enumerable, ERC721Metadata {&#13;
}&#13;
&#13;
&#13;
// File openzeppelin-solidity/contracts/token/ERC721/<span class="__cf_email__" data-cfemail="bcf9eeff8b8e8deed9dfd9d5cad9ce92cfd3d0fcca8d928d8e928c">[email protected]</span>&#13;
&#13;
/**&#13;
 * @title ERC721 token receiver interface&#13;
 * @dev Interface for any contract that wants to support safeTransfers&#13;
 * from ERC721 asset contracts.&#13;
 */&#13;
contract ERC721Receiver {&#13;
  /**&#13;
   * @dev Magic value to be returned upon successful reception of an NFT&#13;
   *  Equals to `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`,&#13;
   *  which can be also obtained as `ERC721Receiver(0).onERC721Received.selector`&#13;
   */&#13;
  bytes4 internal constant ERC721_RECEIVED = 0x150b7a02;&#13;
&#13;
  /**&#13;
   * @notice Handle the receipt of an NFT&#13;
   * @dev The ERC721 smart contract calls this function on the recipient&#13;
   * after a `safetransfer`. This function MAY throw to revert and reject the&#13;
   * transfer. Return of other than the magic value MUST result in the&#13;
   * transaction being reverted.&#13;
   * Note: the contract address is always the message sender.&#13;
   * @param _operator The address which called `safeTransferFrom` function&#13;
   * @param _from The address which previously owned the token&#13;
   * @param _tokenId The NFT identifier which is being transferred&#13;
   * @param _data Additional data with no specified format&#13;
   * @return `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`&#13;
   */&#13;
  function onERC721Received(&#13;
    address _operator,&#13;
    address _from,&#13;
    uint256 _tokenId,&#13;
    bytes _data&#13;
  )&#13;
    public&#13;
    returns(bytes4);&#13;
}&#13;
&#13;
&#13;
// File openzeppelin-solidity/contracts/math/<span class="__cf_email__" data-cfemail="1d4e7c7b78507c6975336e72715d6b2c332c2f332d">[email protected]</span>&#13;
&#13;
/**&#13;
 * @title SafeMath&#13;
 * @dev Math operations with safety checks that throw on error&#13;
 */&#13;
library SafeMath {&#13;
&#13;
  /**&#13;
  * @dev Multiplies two numbers, throws on overflow.&#13;
  */&#13;
  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {&#13;
    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the&#13;
    // benefit is lost if 'b' is also tested.&#13;
    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522&#13;
    if (_a == 0) {&#13;
      return 0;&#13;
    }&#13;
&#13;
    c = _a * _b;&#13;
    assert(c / _a == _b);&#13;
    return c;&#13;
  }&#13;
&#13;
  /**&#13;
  * @dev Integer division of two numbers, truncating the quotient.&#13;
  */&#13;
  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {&#13;
    // assert(_b &gt; 0); // Solidity automatically throws when dividing by 0&#13;
    // uint256 c = _a / _b;&#13;
    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold&#13;
    return _a / _b;&#13;
  }&#13;
&#13;
  /**&#13;
  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).&#13;
  */&#13;
  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {&#13;
    assert(_b &lt;= _a);&#13;
    return _a - _b;&#13;
  }&#13;
&#13;
  /**&#13;
  * @dev Adds two numbers, throws on overflow.&#13;
  */&#13;
  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {&#13;
    c = _a + _b;&#13;
    assert(c &gt;= _a);&#13;
    return c;&#13;
  }&#13;
}&#13;
&#13;
&#13;
// File openzeppelin-solidity/contracts/<span class="__cf_email__" data-cfemail="b2f3d6d6c0d7c1c1e7c6dbdec19cc1dddef2c4839c83809c82">[email protected]</span>&#13;
&#13;
/**&#13;
 * Utility library of inline functions on addresses&#13;
 */&#13;
library AddressUtils {&#13;
&#13;
  /**&#13;
   * Returns whether the target address is a contract&#13;
   * @dev This function will return false if invoked during the constructor of a contract,&#13;
   * as the code is not actually created until after the constructor finishes.&#13;
   * @param _addr address to check&#13;
   * @return whether the target address is a contract&#13;
   */&#13;
  function isContract(address _addr) internal view returns (bool) {&#13;
    uint256 size;&#13;
    // XXX Currently there is no better way to check if there is a contract in an address&#13;
    // than to check the size of the code at that address.&#13;
    // See https://ethereum.stackexchange.com/a/14016/36603&#13;
    // for more details about how this works.&#13;
    // TODO Check this again before the Serenity release, because all addresses will be&#13;
    // contracts then.&#13;
    // solium-disable-next-line security/no-inline-assembly&#13;
    assembly { size := extcodesize(_addr) }&#13;
    return size &gt; 0;&#13;
  }&#13;
&#13;
}&#13;
&#13;
&#13;
// File openzeppelin-solidity/contracts/introspection/<span class="__cf_email__" data-cfemail="3f6c4a4f4f504d4b4c76514b5a4d595e5c5a68564b57735050544a4f114c50537f490e110e0d110f">[email protected]</span>&#13;
&#13;
/**&#13;
 * @title SupportsInterfaceWithLookup&#13;
 * @author Matt Condon (@shrugs)&#13;
 * @dev Implements ERC165 using a lookup table.&#13;
 */&#13;
contract SupportsInterfaceWithLookup is ERC165 {&#13;
&#13;
  bytes4 public constant InterfaceId_ERC165 = 0x01ffc9a7;&#13;
  /**&#13;
   * 0x01ffc9a7 ===&#13;
   *   bytes4(keccak256('supportsInterface(bytes4)'))&#13;
   */&#13;
&#13;
  /**&#13;
   * @dev a mapping of interface id to whether or not it's supported&#13;
   */&#13;
  mapping(bytes4 =&gt; bool) internal supportedInterfaces;&#13;
&#13;
  /**&#13;
   * @dev A contract implementing SupportsInterfaceWithLookup&#13;
   * implement ERC165 itself&#13;
   */&#13;
  constructor()&#13;
    public&#13;
  {&#13;
    _registerInterface(InterfaceId_ERC165);&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev implement supportsInterface(bytes4) using a lookup table&#13;
   */&#13;
  function supportsInterface(bytes4 _interfaceId)&#13;
    external&#13;
    view&#13;
    returns (bool)&#13;
  {&#13;
    return supportedInterfaces[_interfaceId];&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev private method for registering an interface&#13;
   */&#13;
  function _registerInterface(bytes4 _interfaceId)&#13;
    internal&#13;
  {&#13;
    require(_interfaceId != 0xffffffff);&#13;
    supportedInterfaces[_interfaceId] = true;&#13;
  }&#13;
}&#13;
&#13;
&#13;
// File openzeppelin-solidity/contracts/token/ERC721/<span class="__cf_email__" data-cfemail="387d6a7b0f0a097a594b515b6c57535d56164b5754784e0916090a1608">[email protected]</span>&#13;
&#13;
/**&#13;
 * @title ERC721 Non-Fungible Token Standard basic implementation&#13;
 * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md&#13;
 */&#13;
contract ERC721BasicToken is SupportsInterfaceWithLookup, ERC721Basic {&#13;
&#13;
  using SafeMath for uint256;&#13;
  using AddressUtils for address;&#13;
&#13;
  // Equals to `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`&#13;
  // which can be also obtained as `ERC721Receiver(0).onERC721Received.selector`&#13;
  bytes4 private constant ERC721_RECEIVED = 0x150b7a02;&#13;
&#13;
  // Mapping from token ID to owner&#13;
  mapping (uint256 =&gt; address) internal tokenOwner;&#13;
&#13;
  // Mapping from token ID to approved address&#13;
  mapping (uint256 =&gt; address) internal tokenApprovals;&#13;
&#13;
  // Mapping from owner to number of owned token&#13;
  mapping (address =&gt; uint256) internal ownedTokensCount;&#13;
&#13;
  // Mapping from owner to operator approvals&#13;
  mapping (address =&gt; mapping (address =&gt; bool)) internal operatorApprovals;&#13;
&#13;
  constructor()&#13;
    public&#13;
  {&#13;
    // register the supported interfaces to conform to ERC721 via ERC165&#13;
    _registerInterface(InterfaceId_ERC721);&#13;
    _registerInterface(InterfaceId_ERC721Exists);&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Gets the balance of the specified address&#13;
   * @param _owner address to query the balance of&#13;
   * @return uint256 representing the amount owned by the passed address&#13;
   */&#13;
  function balanceOf(address _owner) public view returns (uint256) {&#13;
    require(_owner != address(0));&#13;
    return ownedTokensCount[_owner];&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Gets the owner of the specified token ID&#13;
   * @param _tokenId uint256 ID of the token to query the owner of&#13;
   * @return owner address currently marked as the owner of the given token ID&#13;
   */&#13;
  function ownerOf(uint256 _tokenId) public view returns (address) {&#13;
    address owner = tokenOwner[_tokenId];&#13;
    require(owner != address(0));&#13;
    return owner;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Returns whether the specified token exists&#13;
   * @param _tokenId uint256 ID of the token to query the existence of&#13;
   * @return whether the token exists&#13;
   */&#13;
  function exists(uint256 _tokenId) public view returns (bool) {&#13;
    address owner = tokenOwner[_tokenId];&#13;
    return owner != address(0);&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Approves another address to transfer the given token ID&#13;
   * The zero address indicates there is no approved address.&#13;
   * There can only be one approved address per token at a given time.&#13;
   * Can only be called by the token owner or an approved operator.&#13;
   * @param _to address to be approved for the given token ID&#13;
   * @param _tokenId uint256 ID of the token to be approved&#13;
   */&#13;
  function approve(address _to, uint256 _tokenId) public {&#13;
    address owner = ownerOf(_tokenId);&#13;
    require(_to != owner);&#13;
    require(msg.sender == owner || isApprovedForAll(owner, msg.sender));&#13;
&#13;
    tokenApprovals[_tokenId] = _to;&#13;
    emit Approval(owner, _to, _tokenId);&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Gets the approved address for a token ID, or zero if no address set&#13;
   * @param _tokenId uint256 ID of the token to query the approval of&#13;
   * @return address currently approved for the given token ID&#13;
   */&#13;
  function getApproved(uint256 _tokenId) public view returns (address) {&#13;
    return tokenApprovals[_tokenId];&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Sets or unsets the approval of a given operator&#13;
   * An operator is allowed to transfer all tokens of the sender on their behalf&#13;
   * @param _to operator address to set the approval&#13;
   * @param _approved representing the status of the approval to be set&#13;
   */&#13;
  function setApprovalForAll(address _to, bool _approved) public {&#13;
    require(_to != msg.sender);&#13;
    operatorApprovals[msg.sender][_to] = _approved;&#13;
    emit ApprovalForAll(msg.sender, _to, _approved);&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Tells whether an operator is approved by a given owner&#13;
   * @param _owner owner address which you want to query the approval of&#13;
   * @param _operator operator address which you want to query the approval of&#13;
   * @return bool whether the given operator is approved by the given owner&#13;
   */&#13;
  function isApprovedForAll(&#13;
    address _owner,&#13;
    address _operator&#13;
  )&#13;
    public&#13;
    view&#13;
    returns (bool)&#13;
  {&#13;
    return operatorApprovals[_owner][_operator];&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Transfers the ownership of a given token ID to another address&#13;
   * Usage of this method is discouraged, use `safeTransferFrom` whenever possible&#13;
   * Requires the msg sender to be the owner, approved, or operator&#13;
   * @param _from current owner of the token&#13;
   * @param _to address to receive the ownership of the given token ID&#13;
   * @param _tokenId uint256 ID of the token to be transferred&#13;
  */&#13;
  function transferFrom(&#13;
    address _from,&#13;
    address _to,&#13;
    uint256 _tokenId&#13;
  )&#13;
    public&#13;
  {&#13;
    require(isApprovedOrOwner(msg.sender, _tokenId));&#13;
    require(_from != address(0));&#13;
    require(_to != address(0));&#13;
&#13;
    clearApproval(_from, _tokenId);&#13;
    removeTokenFrom(_from, _tokenId);&#13;
    addTokenTo(_to, _tokenId);&#13;
&#13;
    emit Transfer(_from, _to, _tokenId);&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Safely transfers the ownership of a given token ID to another address&#13;
   * If the target address is a contract, it must implement `onERC721Received`,&#13;
   * which is called upon a safe transfer, and return the magic value&#13;
   * `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`; otherwise,&#13;
   * the transfer is reverted.&#13;
   *&#13;
   * Requires the msg sender to be the owner, approved, or operator&#13;
   * @param _from current owner of the token&#13;
   * @param _to address to receive the ownership of the given token ID&#13;
   * @param _tokenId uint256 ID of the token to be transferred&#13;
  */&#13;
  function safeTransferFrom(&#13;
    address _from,&#13;
    address _to,&#13;
    uint256 _tokenId&#13;
  )&#13;
    public&#13;
  {&#13;
    // solium-disable-next-line arg-overflow&#13;
    safeTransferFrom(_from, _to, _tokenId, "");&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Safely transfers the ownership of a given token ID to another address&#13;
   * If the target address is a contract, it must implement `onERC721Received`,&#13;
   * which is called upon a safe transfer, and return the magic value&#13;
   * `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`; otherwise,&#13;
   * the transfer is reverted.&#13;
   * Requires the msg sender to be the owner, approved, or operator&#13;
   * @param _from current owner of the token&#13;
   * @param _to address to receive the ownership of the given token ID&#13;
   * @param _tokenId uint256 ID of the token to be transferred&#13;
   * @param _data bytes data to send along with a safe transfer check&#13;
   */&#13;
  function safeTransferFrom(&#13;
    address _from,&#13;
    address _to,&#13;
    uint256 _tokenId,&#13;
    bytes _data&#13;
  )&#13;
    public&#13;
  {&#13;
    transferFrom(_from, _to, _tokenId);&#13;
    // solium-disable-next-line arg-overflow&#13;
    require(checkAndCallSafeTransfer(_from, _to, _tokenId, _data));&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Returns whether the given spender can transfer a given token ID&#13;
   * @param _spender address of the spender to query&#13;
   * @param _tokenId uint256 ID of the token to be transferred&#13;
   * @return bool whether the msg.sender is approved for the given token ID,&#13;
   *  is an operator of the owner, or is the owner of the token&#13;
   */&#13;
  function isApprovedOrOwner(&#13;
    address _spender,&#13;
    uint256 _tokenId&#13;
  )&#13;
    internal&#13;
    view&#13;
    returns (bool)&#13;
  {&#13;
    address owner = ownerOf(_tokenId);&#13;
    // Disable solium check because of&#13;
    // https://github.com/duaraghav8/Solium/issues/175&#13;
    // solium-disable-next-line operator-whitespace&#13;
    return (&#13;
      _spender == owner ||&#13;
      getApproved(_tokenId) == _spender ||&#13;
      isApprovedForAll(owner, _spender)&#13;
    );&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Internal function to mint a new token&#13;
   * Reverts if the given token ID already exists&#13;
   * @param _to The address that will own the minted token&#13;
   * @param _tokenId uint256 ID of the token to be minted by the msg.sender&#13;
   */&#13;
  function _mint(address _to, uint256 _tokenId) internal {&#13;
    require(_to != address(0));&#13;
    addTokenTo(_to, _tokenId);&#13;
    emit Transfer(address(0), _to, _tokenId);&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Internal function to burn a specific token&#13;
   * Reverts if the token does not exist&#13;
   * @param _tokenId uint256 ID of the token being burned by the msg.sender&#13;
   */&#13;
  function _burn(address _owner, uint256 _tokenId) internal {&#13;
    clearApproval(_owner, _tokenId);&#13;
    removeTokenFrom(_owner, _tokenId);&#13;
    emit Transfer(_owner, address(0), _tokenId);&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Internal function to clear current approval of a given token ID&#13;
   * Reverts if the given address is not indeed the owner of the token&#13;
   * @param _owner owner of the token&#13;
   * @param _tokenId uint256 ID of the token to be transferred&#13;
   */&#13;
  function clearApproval(address _owner, uint256 _tokenId) internal {&#13;
    require(ownerOf(_tokenId) == _owner);&#13;
    if (tokenApprovals[_tokenId] != address(0)) {&#13;
      tokenApprovals[_tokenId] = address(0);&#13;
    }&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Internal function to add a token ID to the list of a given address&#13;
   * @param _to address representing the new owner of the given token ID&#13;
   * @param _tokenId uint256 ID of the token to be added to the tokens list of the given address&#13;
   */&#13;
  function addTokenTo(address _to, uint256 _tokenId) internal {&#13;
    require(tokenOwner[_tokenId] == address(0));&#13;
    tokenOwner[_tokenId] = _to;&#13;
    ownedTokensCount[_to] = ownedTokensCount[_to].add(1);&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Internal function to remove a token ID from the list of a given address&#13;
   * @param _from address representing the previous owner of the given token ID&#13;
   * @param _tokenId uint256 ID of the token to be removed from the tokens list of the given address&#13;
   */&#13;
  function removeTokenFrom(address _from, uint256 _tokenId) internal {&#13;
    require(ownerOf(_tokenId) == _from);&#13;
    ownedTokensCount[_from] = ownedTokensCount[_from].sub(1);&#13;
    tokenOwner[_tokenId] = address(0);&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Internal function to invoke `onERC721Received` on a target address&#13;
   * The call is not executed if the target address is not a contract&#13;
   * @param _from address representing the previous owner of the given token ID&#13;
   * @param _to target address that will receive the tokens&#13;
   * @param _tokenId uint256 ID of the token to be transferred&#13;
   * @param _data bytes optional data to send along with the call&#13;
   * @return whether the call correctly returned the expected magic value&#13;
   */&#13;
  function checkAndCallSafeTransfer(&#13;
    address _from,&#13;
    address _to,&#13;
    uint256 _tokenId,&#13;
    bytes _data&#13;
  )&#13;
    internal&#13;
    returns (bool)&#13;
  {&#13;
    if (!_to.isContract()) {&#13;
      return true;&#13;
    }&#13;
    bytes4 retval = ERC721Receiver(_to).onERC721Received(&#13;
      msg.sender, _from, _tokenId, _data);&#13;
    return (retval == ERC721_RECEIVED);&#13;
  }&#13;
}&#13;
&#13;
&#13;
// File openzeppelin-solidity/contracts/token/ERC721/<span class="__cf_email__" data-cfemail="6d283f2e5a5f5c3902060803431e02012d1b5c435c5f435d">[email protected]</span>&#13;
&#13;
/**&#13;
 * @title Full ERC721 Token&#13;
 * This implementation includes all the required and some optional functionality of the ERC721 standard&#13;
 * Moreover, it includes approve all functionality using operator terminology&#13;
 * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md&#13;
 */&#13;
contract ERC721Token is SupportsInterfaceWithLookup, ERC721BasicToken, ERC721 {&#13;
&#13;
  // Token name&#13;
  string internal name_;&#13;
&#13;
  // Token symbol&#13;
  string internal symbol_;&#13;
&#13;
  // Mapping from owner to list of owned token IDs&#13;
  mapping(address =&gt; uint256[]) internal ownedTokens;&#13;
&#13;
  // Mapping from token ID to index of the owner tokens list&#13;
  mapping(uint256 =&gt; uint256) internal ownedTokensIndex;&#13;
&#13;
  // Array with all token ids, used for enumeration&#13;
  uint256[] internal allTokens;&#13;
&#13;
  // Mapping from token id to position in the allTokens array&#13;
  mapping(uint256 =&gt; uint256) internal allTokensIndex;&#13;
&#13;
  // Optional mapping for token URIs&#13;
  mapping(uint256 =&gt; string) internal tokenURIs;&#13;
&#13;
  /**&#13;
   * @dev Constructor function&#13;
   */&#13;
  constructor(string _name, string _symbol) public {&#13;
    name_ = _name;&#13;
    symbol_ = _symbol;&#13;
&#13;
    // register the supported interfaces to conform to ERC721 via ERC165&#13;
    _registerInterface(InterfaceId_ERC721Enumerable);&#13;
    _registerInterface(InterfaceId_ERC721Metadata);&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Gets the token name&#13;
   * @return string representing the token name&#13;
   */&#13;
  function name() external view returns (string) {&#13;
    return name_;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Gets the token symbol&#13;
   * @return string representing the token symbol&#13;
   */&#13;
  function symbol() external view returns (string) {&#13;
    return symbol_;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Returns an URI for a given token ID&#13;
   * Throws if the token ID does not exist. May return an empty string.&#13;
   * @param _tokenId uint256 ID of the token to query&#13;
   */&#13;
  function tokenURI(uint256 _tokenId) public view returns (string) {&#13;
    require(exists(_tokenId));&#13;
    return tokenURIs[_tokenId];&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Gets the token ID at a given index of the tokens list of the requested owner&#13;
   * @param _owner address owning the tokens list to be accessed&#13;
   * @param _index uint256 representing the index to be accessed of the requested tokens list&#13;
   * @return uint256 token ID at the given index of the tokens list owned by the requested address&#13;
   */&#13;
  function tokenOfOwnerByIndex(&#13;
    address _owner,&#13;
    uint256 _index&#13;
  )&#13;
    public&#13;
    view&#13;
    returns (uint256)&#13;
  {&#13;
    require(_index &lt; balanceOf(_owner));&#13;
    return ownedTokens[_owner][_index];&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Gets the total amount of tokens stored by the contract&#13;
   * @return uint256 representing the total amount of tokens&#13;
   */&#13;
  function totalSupply() public view returns (uint256) {&#13;
    return allTokens.length;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Gets the token ID at a given index of all the tokens in this contract&#13;
   * Reverts if the index is greater or equal to the total number of tokens&#13;
   * @param _index uint256 representing the index to be accessed of the tokens list&#13;
   * @return uint256 token ID at the given index of the tokens list&#13;
   */&#13;
  function tokenByIndex(uint256 _index) public view returns (uint256) {&#13;
    require(_index &lt; totalSupply());&#13;
    return allTokens[_index];&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Internal function to set the token URI for a given token&#13;
   * Reverts if the token ID does not exist&#13;
   * @param _tokenId uint256 ID of the token to set its URI&#13;
   * @param _uri string URI to assign&#13;
   */&#13;
  function _setTokenURI(uint256 _tokenId, string _uri) internal {&#13;
    require(exists(_tokenId));&#13;
    tokenURIs[_tokenId] = _uri;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Internal function to add a token ID to the list of a given address&#13;
   * @param _to address representing the new owner of the given token ID&#13;
   * @param _tokenId uint256 ID of the token to be added to the tokens list of the given address&#13;
   */&#13;
  function addTokenTo(address _to, uint256 _tokenId) internal {&#13;
    super.addTokenTo(_to, _tokenId);&#13;
    uint256 length = ownedTokens[_to].length;&#13;
    ownedTokens[_to].push(_tokenId);&#13;
    ownedTokensIndex[_tokenId] = length;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Internal function to remove a token ID from the list of a given address&#13;
   * @param _from address representing the previous owner of the given token ID&#13;
   * @param _tokenId uint256 ID of the token to be removed from the tokens list of the given address&#13;
   */&#13;
  function removeTokenFrom(address _from, uint256 _tokenId) internal {&#13;
    super.removeTokenFrom(_from, _tokenId);&#13;
&#13;
    // To prevent a gap in the array, we store the last token in the index of the token to delete, and&#13;
    // then delete the last slot.&#13;
    uint256 tokenIndex = ownedTokensIndex[_tokenId];&#13;
    uint256 lastTokenIndex = ownedTokens[_from].length.sub(1);&#13;
    uint256 lastToken = ownedTokens[_from][lastTokenIndex];&#13;
&#13;
    ownedTokens[_from][tokenIndex] = lastToken;&#13;
    // This also deletes the contents at the last position of the array&#13;
    ownedTokens[_from].length--;&#13;
&#13;
    // Note that this will handle single-element arrays. In that case, both tokenIndex and lastTokenIndex are going to&#13;
    // be zero. Then we can make sure that we will remove _tokenId from the ownedTokens list since we are first swapping&#13;
    // the lastToken to the first position, and then dropping the element placed in the last position of the list&#13;
&#13;
    ownedTokensIndex[_tokenId] = 0;&#13;
    ownedTokensIndex[lastToken] = tokenIndex;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Internal function to mint a new token&#13;
   * Reverts if the given token ID already exists&#13;
   * @param _to address the beneficiary that will own the minted token&#13;
   * @param _tokenId uint256 ID of the token to be minted by the msg.sender&#13;
   */&#13;
  function _mint(address _to, uint256 _tokenId) internal {&#13;
    super._mint(_to, _tokenId);&#13;
&#13;
    allTokensIndex[_tokenId] = allTokens.length;&#13;
    allTokens.push(_tokenId);&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Internal function to burn a specific token&#13;
   * Reverts if the token does not exist&#13;
   * @param _owner owner of the token to burn&#13;
   * @param _tokenId uint256 ID of the token being burned by the msg.sender&#13;
   */&#13;
  function _burn(address _owner, uint256 _tokenId) internal {&#13;
    super._burn(_owner, _tokenId);&#13;
&#13;
    // Clear metadata (if any)&#13;
    if (bytes(tokenURIs[_tokenId]).length != 0) {&#13;
      delete tokenURIs[_tokenId];&#13;
    }&#13;
&#13;
    // Reorg all tokens array&#13;
    uint256 tokenIndex = allTokensIndex[_tokenId];&#13;
    uint256 lastTokenIndex = allTokens.length.sub(1);&#13;
    uint256 lastToken = allTokens[lastTokenIndex];&#13;
&#13;
    allTokens[tokenIndex] = lastToken;&#13;
    allTokens[lastTokenIndex] = 0;&#13;
&#13;
    allTokens.length--;&#13;
    allTokensIndex[_tokenId] = 0;&#13;
    allTokensIndex[lastToken] = tokenIndex;&#13;
  }&#13;
&#13;
}&#13;
&#13;
&#13;
// File contracts/MintableERC721Token.sol&#13;
&#13;
// @TODO - finish this&#13;
contract MintableERC721Token is ERC721Token {&#13;
  constructor(string name, string symbol)&#13;
    ERC721Token(name, symbol)&#13;
    public&#13;
  {&#13;
&#13;
  }&#13;
}&#13;
&#13;
&#13;
// File openzeppelin-solidity/contracts/token/ERC20/<span class="__cf_email__" data-cfemail="692d0c1d0800050c0d2c3b2a5b59471a0605291f5847585b4759">[email protected]</span>&#13;
&#13;
/**&#13;
 * @title DetailedERC20 token&#13;
 * @dev The decimals are only for visualization purposes.&#13;
 * All the operations are done using the smallest and indivisible token unit,&#13;
 * just as on Ethereum all the operations are done in wei.&#13;
 */&#13;
contract DetailedERC20 is ERC20 {&#13;
  string public name;&#13;
  string public symbol;&#13;
  uint8 public decimals;&#13;
&#13;
  constructor(string _name, string _symbol, uint8 _decimals) public {&#13;
    name = _name;&#13;
    symbol = _symbol;&#13;
    decimals = _decimals;&#13;
  }&#13;
}&#13;
&#13;
&#13;
// File openzeppelin-solidity/contracts/token/ERC20/<span class="__cf_email__" data-cfemail="d391b2a0bab087bcb8b6bdfda0bcbf93a5e2fde2e1fde3">[email protected]</span>&#13;
&#13;
/**&#13;
 * @title Basic token&#13;
 * @dev Basic version of StandardToken, with no allowances.&#13;
 */&#13;
contract BasicToken is ERC20Basic {&#13;
  using SafeMath for uint256;&#13;
&#13;
  mapping(address =&gt; uint256) internal balances;&#13;
&#13;
  uint256 internal totalSupply_;&#13;
&#13;
  /**&#13;
  * @dev Total number of tokens in existence&#13;
  */&#13;
  function totalSupply() public view returns (uint256) {&#13;
    return totalSupply_;&#13;
  }&#13;
&#13;
  /**&#13;
  * @dev Transfer token for a specified address&#13;
  * @param _to The address to transfer to.&#13;
  * @param _value The amount to be transferred.&#13;
  */&#13;
  function transfer(address _to, uint256 _value) public returns (bool) {&#13;
    require(_value &lt;= balances[msg.sender]);&#13;
    require(_to != address(0));&#13;
&#13;
    balances[msg.sender] = balances[msg.sender].sub(_value);&#13;
    balances[_to] = balances[_to].add(_value);&#13;
    emit Transfer(msg.sender, _to, _value);&#13;
    return true;&#13;
  }&#13;
&#13;
  /**&#13;
  * @dev Gets the balance of the specified address.&#13;
  * @param _owner The address to query the the balance of.&#13;
  * @return An uint256 representing the amount owned by the passed address.&#13;
  */&#13;
  function balanceOf(address _owner) public view returns (uint256) {&#13;
    return balances[_owner];&#13;
  }&#13;
&#13;
}&#13;
&#13;
&#13;
// File openzeppelin-solidity/contracts/token/ERC20/<span class="__cf_email__" data-cfemail="a9faddc8c7cdc8dbcdfdc6c2ccc787dac6c5e9df9887989b8799">[email protected]</span>&#13;
&#13;
/**&#13;
 * @title Standard ERC20 token&#13;
 *&#13;
 * @dev Implementation of the basic standard token.&#13;
 * https://github.com/ethereum/EIPs/issues/20&#13;
 * Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol&#13;
 */&#13;
contract StandardToken is ERC20, BasicToken {&#13;
&#13;
  mapping (address =&gt; mapping (address =&gt; uint256)) internal allowed;&#13;
&#13;
&#13;
  /**&#13;
   * @dev Transfer tokens from one address to another&#13;
   * @param _from address The address which you want to send tokens from&#13;
   * @param _to address The address which you want to transfer to&#13;
   * @param _value uint256 the amount of tokens to be transferred&#13;
   */&#13;
  function transferFrom(&#13;
    address _from,&#13;
    address _to,&#13;
    uint256 _value&#13;
  )&#13;
    public&#13;
    returns (bool)&#13;
  {&#13;
    require(_value &lt;= balances[_from]);&#13;
    require(_value &lt;= allowed[_from][msg.sender]);&#13;
    require(_to != address(0));&#13;
&#13;
    balances[_from] = balances[_from].sub(_value);&#13;
    balances[_to] = balances[_to].add(_value);&#13;
    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);&#13;
    emit Transfer(_from, _to, _value);&#13;
    return true;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.&#13;
   * Beware that changing an allowance with this method brings the risk that someone may use both the old&#13;
   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this&#13;
   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:&#13;
   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729&#13;
   * @param _spender The address which will spend the funds.&#13;
   * @param _value The amount of tokens to be spent.&#13;
   */&#13;
  function approve(address _spender, uint256 _value) public returns (bool) {&#13;
    allowed[msg.sender][_spender] = _value;&#13;
    emit Approval(msg.sender, _spender, _value);&#13;
    return true;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Function to check the amount of tokens that an owner allowed to a spender.&#13;
   * @param _owner address The address which owns the funds.&#13;
   * @param _spender address The address which will spend the funds.&#13;
   * @return A uint256 specifying the amount of tokens still available for the spender.&#13;
   */&#13;
  function allowance(&#13;
    address _owner,&#13;
    address _spender&#13;
   )&#13;
    public&#13;
    view&#13;
    returns (uint256)&#13;
  {&#13;
    return allowed[_owner][_spender];&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Increase the amount of tokens that an owner allowed to a spender.&#13;
   * approve should be called when allowed[_spender] == 0. To increment&#13;
   * allowed value is better to use this function to avoid 2 calls (and wait until&#13;
   * the first transaction is mined)&#13;
   * From MonolithDAO Token.sol&#13;
   * @param _spender The address which will spend the funds.&#13;
   * @param _addedValue The amount of tokens to increase the allowance by.&#13;
   */&#13;
  function increaseApproval(&#13;
    address _spender,&#13;
    uint256 _addedValue&#13;
  )&#13;
    public&#13;
    returns (bool)&#13;
  {&#13;
    allowed[msg.sender][_spender] = (&#13;
      allowed[msg.sender][_spender].add(_addedValue));&#13;
    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);&#13;
    return true;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Decrease the amount of tokens that an owner allowed to a spender.&#13;
   * approve should be called when allowed[_spender] == 0. To decrement&#13;
   * allowed value is better to use this function to avoid 2 calls (and wait until&#13;
   * the first transaction is mined)&#13;
   * From MonolithDAO Token.sol&#13;
   * @param _spender The address which will spend the funds.&#13;
   * @param _subtractedValue The amount of tokens to decrease the allowance by.&#13;
   */&#13;
  function decreaseApproval(&#13;
    address _spender,&#13;
    uint256 _subtractedValue&#13;
  )&#13;
    public&#13;
    returns (bool)&#13;
  {&#13;
    uint256 oldValue = allowed[msg.sender][_spender];&#13;
    if (_subtractedValue &gt;= oldValue) {&#13;
      allowed[msg.sender][_spender] = 0;&#13;
    } else {&#13;
      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);&#13;
    }&#13;
    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);&#13;
    return true;&#13;
  }&#13;
&#13;
}&#13;
&#13;
&#13;
// File openzeppelin-solidity/contracts/token/ERC20/<span class="__cf_email__" data-cfemail="9ed3f7f0eafffcf2fbcaf1f5fbf0b0edf1f2dee8afb0afacb0ae">[email protected]</span>&#13;
&#13;
/**&#13;
 * @title Mintable token&#13;
 * @dev Simple ERC20 Token example, with mintable token creation&#13;
 * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol&#13;
 */&#13;
contract MintableToken is StandardToken, Ownable {&#13;
  event Mint(address indexed to, uint256 amount);&#13;
  event MintFinished();&#13;
&#13;
  bool public mintingFinished = false;&#13;
&#13;
&#13;
  modifier canMint() {&#13;
    require(!mintingFinished);&#13;
    _;&#13;
  }&#13;
&#13;
  modifier hasMintPermission() {&#13;
    require(msg.sender == owner);&#13;
    _;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Function to mint tokens&#13;
   * @param _to The address that will receive the minted tokens.&#13;
   * @param _amount The amount of tokens to mint.&#13;
   * @return A boolean that indicates if the operation was successful.&#13;
   */&#13;
  function mint(&#13;
    address _to,&#13;
    uint256 _amount&#13;
  )&#13;
    public&#13;
    hasMintPermission&#13;
    canMint&#13;
    returns (bool)&#13;
  {&#13;
    totalSupply_ = totalSupply_.add(_amount);&#13;
    balances[_to] = balances[_to].add(_amount);&#13;
    emit Mint(_to, _amount);&#13;
    emit Transfer(address(0), _to, _amount);&#13;
    return true;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Function to stop minting new tokens.&#13;
   * @return True if the operation was successful.&#13;
   */&#13;
  function finishMinting() public onlyOwner canMint returns (bool) {&#13;
    mintingFinished = true;&#13;
    emit MintFinished();&#13;
    return true;&#13;
  }&#13;
}&#13;
&#13;
&#13;
// File contracts/mocks/MockToken.sol&#13;
&#13;
contract MockToken is DetailedERC20, MintableToken {&#13;
  constructor(string _name, string _symbol, uint8 _decimals)&#13;
    DetailedERC20(_name, _symbol, _decimals)&#13;
    public&#13;
  {&#13;
&#13;
  }&#13;
}&#13;
&#13;
&#13;
// File contracts/old/ClaimableToken.sol&#13;
&#13;
// import "./MintableERC721Token.sol";&#13;
// import "openzeppelin-solidity/contracts/token/ERC721/DefaultTokenURI.sol";&#13;
&#13;
&#13;
// contract ClaimableToken is DefaultTokenURI, MintableERC721Token {&#13;
&#13;
//   constructor(string _name, string _symbol, string _tokenURI)&#13;
//     MintableERC721Token(_name, _symbol)&#13;
//     DefaultTokenURI(_tokenURI)&#13;
//     public&#13;
//   {&#13;
&#13;
//   }&#13;
// }&#13;
&#13;
&#13;
// File contracts/old/ClaimableTokenDeployer.sol&#13;
&#13;
// import "./ClaimableTokenMinter.sol";&#13;
// import "./ClaimableToken.sol";&#13;
&#13;
&#13;
// contract ClaimableTokenDeployer {&#13;
//   ClaimableToken public token;&#13;
//   ClaimableTokenMinter public minter;&#13;
&#13;
//   constructor(&#13;
//     string _name,&#13;
//     string _symbol,&#13;
//     string _tokenURI,&#13;
//     address _bouncer&#13;
//   )&#13;
//     public&#13;
//   {&#13;
//     token = new ClaimableToken(_name, _symbol, _tokenURI);&#13;
//     minter = new ClaimableTokenMinter(token);&#13;
//     token.addOwner(msg.sender);&#13;
//     token.addMinter(address(minter));&#13;
//     minter.addOwner(msg.sender);&#13;
//     minter.addBouncer(_bouncer);&#13;
//   }&#13;
// }&#13;
&#13;
&#13;
// File contracts/old/ClaimableTokenMinter.sol&#13;
&#13;
// import "./ClaimableToken.sol";&#13;
// import "openzeppelin-solidity/contracts/access/ERC721Minter.sol";&#13;
// import "openzeppelin-solidity/contracts/access/NonceTracker.sol";&#13;
&#13;
&#13;
// contract ClaimableTokenMinter is NonceTracker, ERC721Minter {&#13;
&#13;
//   constructor(ClaimableToken _token)&#13;
//     ERC721Minter(_token)&#13;
//     public&#13;
//   {&#13;
&#13;
//   }&#13;
&#13;
//   function mint(bytes _sig)&#13;
//     withAccess(msg.sender, 1)&#13;
//     public&#13;
//     returns (uint256)&#13;
//   {&#13;
//     return super.mint(_sig);&#13;
//   }&#13;
// }