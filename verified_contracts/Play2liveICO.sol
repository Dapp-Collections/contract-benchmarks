// Play2liveICO tokensale smart contract.
// Developed by Phenom.Team <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="ef86818980af9f878a818082c19b8a8e82">[emailÂ protected]</a>&gt;&#13;
pragma solidity ^0.4.15;&#13;
&#13;
/**&#13;
 *   @title SafeMath&#13;
 *   @dev Math operations with safety checks that throw on error&#13;
 */&#13;
&#13;
library SafeMath {&#13;
&#13;
  function mul(uint a, uint b) internal constant returns (uint) {&#13;
    if (a == 0) {&#13;
      return 0;&#13;
    }&#13;
    uint c = a * b;&#13;
    assert(c / a == b);&#13;
    return c;&#13;
  }&#13;
&#13;
  function div(uint a, uint b) internal constant returns(uint) {&#13;
    assert(b &gt; 0);&#13;
    uint c = a / b;&#13;
    assert(a == b * c + a % b);&#13;
    return c;&#13;
  }&#13;
&#13;
  function sub(uint a, uint b) internal constant returns(uint) {&#13;
    assert(b &lt;= a);&#13;
    return a - b;&#13;
  }&#13;
&#13;
  function add(uint a, uint b) internal constant returns(uint) {&#13;
    uint c = a + b;&#13;
    assert(c &gt;= a);&#13;
    return c;&#13;
  }&#13;
}&#13;
&#13;
/**&#13;
 *   @title ERC20&#13;
 *   @dev Standart ERC20 token interface&#13;
 */&#13;
&#13;
contract ERC20 {&#13;
    uint public totalSupply = 0;&#13;
&#13;
    mapping(address =&gt; uint256) balances;&#13;
    mapping(address =&gt; mapping (address =&gt; uint256)) allowed;&#13;
&#13;
    function balanceOf(address _owner) constant returns (uint);&#13;
    function transfer(address _to, uint _value) returns (bool);&#13;
    function transferFrom(address _from, address _to, uint _value) returns (bool);&#13;
    function approve(address _spender, uint _value) returns (bool);&#13;
    function allowance(address _owner, address _spender) constant returns (uint);&#13;
&#13;
    event Transfer(address indexed _from, address indexed _to, uint _value);&#13;
    event Approval(address indexed _owner, address indexed _spender, uint _value);&#13;
&#13;
} &#13;
&#13;
/**&#13;
 *   @title Play2liveICO contract  - takes funds from users and issues tokens&#13;
 */&#13;
contract Play2liveICO {&#13;
    // LUC - Level Up Coin token contract&#13;
    using SafeMath for uint;&#13;
    LucToken public LUC = new LucToken(this);&#13;
    Presale public preSaleToken;&#13;
&#13;
    // Token price parameters&#13;
    // These parametes can be changed only by manager of contract&#13;
    uint public tokensPerDollar = 20;&#13;
    uint public rateEth = 446; // Rate USD per ETH&#13;
    uint public tokenPrice = tokensPerDollar * rateEth; // DTRC per ETH&#13;
    //Crowdsale parameters&#13;
    uint constant publicIcoPart = 625; // 62,5% of TotalSupply for BountyFund&#13;
    uint constant operationsPart = 111;&#13;
    uint constant foundersPart = 104;&#13;
    uint constant partnersPart = 78; // 7,8% of TotalSupply for parnersFund&#13;
    uint constant advisorsPart = 72;&#13;
    uint constant bountyPart = 10; // 1% of TotalSupply for BountyFund&#13;
    uint constant hardCap = 30000000 * tokensPerDollar * 1e18; // &#13;
    uint public soldAmount = 0;&#13;
    // Output ethereum addresses&#13;
    address public Company;&#13;
    address public OperationsFund;&#13;
    address public FoundersFund;&#13;
    address public PartnersFund;&#13;
    address public AdvisorsFund;&#13;
    address public BountyFund;&#13;
    address public Manager; // Manager controls contract&#13;
    address public Controller_Address1; // First address that is used to buy tokens for other cryptos&#13;
    address public Controller_Address2; // Second address that is used to buy tokens for other cryptos&#13;
    address public Controller_Address3; // Third address that is used to buy tokens for other cryptos&#13;
    address public Oracle; // Oracle address&#13;
&#13;
    // Possible ICO statuses&#13;
    enum StatusICO {&#13;
        Created,&#13;
        PreIcoStarted,&#13;
        PreIcoPaused,&#13;
        PreIcoFinished,&#13;
        IcoStarted,&#13;
        IcoPaused,&#13;
        IcoFinished&#13;
    }&#13;
    StatusICO statusICO = StatusICO.Created;&#13;
    &#13;
    // Mappings&#13;
    mapping(address =&gt; bool) public swaped;&#13;
    mapping (address =&gt; string) public keys;&#13;
    &#13;
    // Events Log&#13;
    event LogStartPreICO();&#13;
    event LogPausePreICO();&#13;
    event LogFinishPreICO();&#13;
    event LogStartICO();&#13;
    event LogPauseICO();&#13;
    event LogFinishICO();&#13;
    event LogBuyForInvestor(address investor, uint lucValue, string txHash);&#13;
    event LogSwapTokens(address investor, uint tokensAmount);&#13;
    event LogRegister(address investor, string key);&#13;
&#13;
    // Modifiers&#13;
    // Allows execution by the manager only&#13;
    modifier managerOnly { &#13;
        require(msg.sender == Manager);&#13;
        _; &#13;
     }&#13;
    // Allows execution by the oracle only&#13;
    modifier oracleOnly { &#13;
        require(msg.sender == Oracle);&#13;
        _; &#13;
     }&#13;
    // Allows execution by the one of controllers only&#13;
    modifier controllersOnly {&#13;
        require(&#13;
            (msg.sender == Controller_Address1)||&#13;
            (msg.sender == Controller_Address2)||&#13;
            (msg.sender == Controller_Address3)&#13;
        );&#13;
        _;&#13;
    }&#13;
&#13;
&#13;
   /**&#13;
    *   @dev Contract constructor function&#13;
    */&#13;
    function Play2liveICO(&#13;
        address _preSaleToken,&#13;
        address _Company,&#13;
        address _OperationsFund,&#13;
        address _FoundersFund,&#13;
        address _PartnersFund,&#13;
        address _AdvisorsFund,&#13;
        address _BountyFund,&#13;
        address _Manager,&#13;
        address _Controller_Address1,&#13;
        address _Controller_Address2,&#13;
        address _Controller_Address3,&#13;
        address _Oracle&#13;
        ) public {&#13;
        preSaleToken = Presale(_preSaleToken);&#13;
        Company = _Company;&#13;
        OperationsFund = _OperationsFund;&#13;
        FoundersFund = _FoundersFund;&#13;
        PartnersFund = _PartnersFund;&#13;
        AdvisorsFund = _AdvisorsFund;&#13;
        BountyFund = _BountyFund;&#13;
        Manager = _Manager;&#13;
        Controller_Address1 = _Controller_Address1;&#13;
        Controller_Address2 = _Controller_Address2;&#13;
        Controller_Address3 = _Controller_Address3;&#13;
        Oracle = _Oracle;&#13;
    }&#13;
&#13;
   /**&#13;
    *   @dev Function to set rate of ETH and update token price&#13;
    *   @param _rateEth       current ETH rate&#13;
    */&#13;
    function setRate(uint _rateEth) external oracleOnly {&#13;
        rateEth = _rateEth;&#13;
        tokenPrice = tokensPerDollar.mul(rateEth);&#13;
    }&#13;
&#13;
   /**&#13;
    *   @dev Function to start PreICO&#13;
    *   Sets ICO status to PreIcoStarted&#13;
    */&#13;
    function startPreIco() external managerOnly {&#13;
        require(statusICO == StatusICO.Created || statusICO == StatusICO.PreIcoPaused);&#13;
        statusICO = StatusICO.PreIcoStarted;&#13;
        LogStartPreICO();&#13;
    }&#13;
&#13;
   /**&#13;
    *   @dev Function to pause PreICO&#13;
    *   Sets ICO status to PreIcoPaused&#13;
    */&#13;
    function pausePreIco() external managerOnly {&#13;
       require(statusICO == StatusICO.PreIcoStarted);&#13;
       statusICO = StatusICO.PreIcoPaused;&#13;
       LogPausePreICO();&#13;
    }&#13;
&#13;
   /**&#13;
    *   @dev Function to finish PreICO&#13;
    *   Sets ICO status to PreIcoFinished&#13;
    */&#13;
    function finishPreIco() external managerOnly {&#13;
        require(statusICO == StatusICO.PreIcoStarted || statusICO == StatusICO.PreIcoPaused);&#13;
        statusICO = StatusICO.PreIcoFinished;&#13;
        LogFinishPreICO();&#13;
    }&#13;
&#13;
   /**&#13;
    *   @dev Function to start ICO&#13;
    *   Sets ICO status to IcoStarted&#13;
    */&#13;
    function startIco() external managerOnly {&#13;
        require(statusICO == StatusICO.PreIcoFinished || statusICO == StatusICO.IcoPaused);&#13;
        statusICO = StatusICO.IcoStarted;&#13;
        LogStartICO();&#13;
    }&#13;
&#13;
   /**&#13;
    *   @dev Function to pause ICO&#13;
    *   Sets ICO status to IcoPaused&#13;
    */&#13;
    function pauseIco() external managerOnly {&#13;
       require(statusICO == StatusICO.IcoStarted);&#13;
       statusICO = StatusICO.IcoPaused;&#13;
       LogPauseICO();&#13;
    }&#13;
&#13;
   /**&#13;
    *   @dev Function to finish ICO&#13;
    *   Sets ICO status to IcoFinished and  emits tokens for funds&#13;
    */&#13;
    function finishIco() external managerOnly {&#13;
        require(statusICO == StatusICO.IcoStarted || statusICO == StatusICO.IcoPaused);&#13;
        uint alreadyMinted = LUC.totalSupply();&#13;
        uint totalAmount = alreadyMinted.mul(1000).div(publicIcoPart);&#13;
        LUC.mintTokens(OperationsFund, operationsPart.mul(totalAmount).div(1000));&#13;
        LUC.mintTokens(FoundersFund, foundersPart.mul(totalAmount).div(1000));&#13;
        LUC.mintTokens(PartnersFund, partnersPart.mul(totalAmount).div(1000));&#13;
        LUC.mintTokens(AdvisorsFund, advisorsPart.mul(totalAmount).div(1000));&#13;
        LUC.mintTokens(BountyFund, bountyPart.mul(totalAmount).div(1000));&#13;
        statusICO = StatusICO.IcoFinished;&#13;
        LogFinishICO();&#13;
    }&#13;
&#13;
   /**&#13;
    *   @dev Unfreeze tokens(enable token transfers)&#13;
    */&#13;
    function unfreeze() external managerOnly {&#13;
        require(statusICO == StatusICO.IcoFinished);&#13;
        LUC.defrost();&#13;
    }&#13;
    &#13;
   /**&#13;
    *   @dev Function to swap tokens from pre-sale&#13;
    *   @param _investor     pre-sale tokens holder address&#13;
    */&#13;
    function swapTokens(address _investor) external managerOnly {&#13;
         require(statusICO != StatusICO.IcoFinished);&#13;
         require(!swaped[_investor]);&#13;
         swaped[_investor] = true;&#13;
         uint tokensToSwap = preSaleToken.balanceOf(_investor);&#13;
         LUC.mintTokens(_investor, tokensToSwap);&#13;
         soldAmount = soldAmount.add(tokensToSwap);&#13;
         LogSwapTokens(_investor, tokensToSwap);&#13;
    }&#13;
   /**&#13;
    *   @dev Fallback function calls buy(address _investor, uint _DTRCValue) function to issue tokens&#13;
    *        when investor sends ETH to address of ICO contract and then stores investment amount &#13;
    */&#13;
    function() external payable {&#13;
        if (statusICO == StatusICO.PreIcoStarted) {&#13;
            require(msg.value &gt;= 100 finney);&#13;
        }&#13;
        buy(msg.sender, msg.value.mul(tokenPrice)); &#13;
    }&#13;
&#13;
   /**&#13;
    *   @dev Function to issues tokens for investors who made purchases in other cryptocurrencies&#13;
    *   @param _investor     address the tokens will be issued to&#13;
    *   @param _txHash       transaction hash of investor's payment&#13;
    *   @param _lucValue     number of LUC tokens&#13;
    */&#13;
&#13;
    function buyForInvestor(&#13;
        address _investor, &#13;
        uint _lucValue, &#13;
        string _txHash&#13;
    ) &#13;
        external &#13;
        controllersOnly {&#13;
        buy(_investor, _lucValue);&#13;
        LogBuyForInvestor(_investor, _lucValue, _txHash);&#13;
    }&#13;
&#13;
   /**&#13;
    *   @dev Function to issue tokens for investors who paid in ether&#13;
    *   @param _investor     address which the tokens will be issued tokens&#13;
    *   @param _lucValue     number of LUC tokens&#13;
    */&#13;
    function buy(address _investor, uint _lucValue) internal {&#13;
        require(statusICO == StatusICO.PreIcoStarted || statusICO == StatusICO.IcoStarted);&#13;
        uint bonus = getBonus(_lucValue);&#13;
        uint total = _lucValue.add(bonus);&#13;
        require(soldAmount + _lucValue &lt;= hardCap);&#13;
        LUC.mintTokens(_investor, total);&#13;
        soldAmount = soldAmount.add(_lucValue);&#13;
    }&#13;
&#13;
&#13;
&#13;
   /**&#13;
    *   @dev Function to calculates bonuses &#13;
    *   @param _value        amount of tokens&#13;
    *   @return              bonus value&#13;
    */&#13;
    function getBonus(uint _value) public constant returns (uint) {&#13;
        uint bonus = 0;&#13;
        if (statusICO == StatusICO.PreIcoStarted) {&#13;
            if (now &lt; 1517356800) {&#13;
                bonus = _value.mul(30).div(100);&#13;
                return bonus;&#13;
            } else {&#13;
                bonus = _value.mul(25).div(100);&#13;
                return bonus;                &#13;
            }&#13;
        }&#13;
        if (statusICO == StatusICO.IcoStarted) {&#13;
            if (now &lt; 1518652800) {&#13;
                bonus = _value.mul(10).div(100);&#13;
                return bonus;                   &#13;
            }&#13;
            if (now &lt; 1518912000) {&#13;
                bonus = _value.mul(9).div(100);&#13;
                return bonus;                   &#13;
            }&#13;
            if (now &lt; 1519171200) {&#13;
                bonus = _value.mul(8).div(100);&#13;
                return bonus;                   &#13;
            }&#13;
            if (now &lt; 1519344000) {&#13;
                bonus = _value.mul(7).div(100);&#13;
                return bonus;                   &#13;
            }&#13;
            if (now &lt; 1519516800) {&#13;
                bonus = _value.mul(6).div(100);&#13;
                return bonus;                   &#13;
            }&#13;
            if (now &lt; 1519689600) {&#13;
                bonus = _value.mul(5).div(100);&#13;
                return bonus;                   &#13;
            }&#13;
            if (now &lt; 1519862400) {&#13;
                bonus = _value.mul(4).div(100);&#13;
                return bonus;                   &#13;
            }&#13;
            if (now &lt; 1520035200) {&#13;
                bonus = _value.mul(3).div(100);&#13;
                return bonus;                   &#13;
            }&#13;
            if (now &lt; 1520208000) {&#13;
                bonus = _value.mul(2).div(100);&#13;
                return bonus;                   &#13;
            } else {&#13;
                bonus = _value.mul(1).div(100);&#13;
                return bonus;                   &#13;
            }&#13;
        }&#13;
        return bonus;&#13;
    }&#13;
&#13;
   /**&#13;
    *   @dev Allows invetsot to register thier Level Up Chain address&#13;
    */&#13;
    function register(string _key) public {&#13;
        keys[msg.sender] = _key;&#13;
        LogRegister(msg.sender, _key);&#13;
    }&#13;
&#13;
   /**&#13;
    *   @dev Allows Company withdraw investments&#13;
    */&#13;
    function withdrawEther() external managerOnly {&#13;
        Company.transfer(this.balance);&#13;
    }&#13;
&#13;
}&#13;
&#13;
/**&#13;
 *   @title LucToken&#13;
 *   @dev Luc token contract&#13;
 */&#13;
contract LucToken is ERC20 {&#13;
    using SafeMath for uint;&#13;
    string public name = "Level Up Coin";&#13;
    string public symbol = "LUC";&#13;
    uint public decimals = 18;&#13;
&#13;
    // Ico contract address&#13;
    address public ico;&#13;
    &#13;
    // Tokens transfer ability status&#13;
    bool public tokensAreFrozen = true;&#13;
&#13;
    // Allows execution by the owner only&#13;
    modifier icoOnly { &#13;
        require(msg.sender == ico); &#13;
        _; &#13;
    }&#13;
&#13;
   /**&#13;
    *   @dev Contract constructor function sets Ico address&#13;
    *   @param _ico          ico address&#13;
    */&#13;
    function LucToken(address _ico) public {&#13;
       ico = _ico;&#13;
    }&#13;
&#13;
   /**&#13;
    *   @dev Function to mint tokens&#13;
    *   @param _holder       beneficiary address the tokens will be issued to&#13;
    *   @param _value        number of tokens to issue&#13;
    */&#13;
    function mintTokens(address _holder, uint _value) external icoOnly {&#13;
       require(_value &gt; 0);&#13;
       balances[_holder] = balances[_holder].add(_value);&#13;
       totalSupply = totalSupply.add(_value);&#13;
       Transfer(0x0, _holder, _value);&#13;
    }&#13;
&#13;
&#13;
   /**&#13;
    *   @dev Function to enable token transfers&#13;
    */&#13;
    function defrost() external icoOnly {&#13;
       tokensAreFrozen = false;&#13;
    }&#13;
&#13;
   /**&#13;
    *   @dev Get balance of tokens holder&#13;
    *   @param _holder        holder's address&#13;
    *   @return               balance of investor&#13;
    */&#13;
    function balanceOf(address _holder) constant returns (uint256) {&#13;
         return balances[_holder];&#13;
    }&#13;
&#13;
   /**&#13;
    *   @dev Send coins&#13;
    *   throws on any error rather then return a false flag to minimize&#13;
    *   user errors&#13;
    *   @param _to           target address&#13;
    *   @param _amount       transfer amount&#13;
    *&#13;
    *   @return true if the transfer was successful&#13;
    */&#13;
    function transfer(address _to, uint256 _amount) public returns (bool) {&#13;
        require(!tokensAreFrozen);&#13;
        balances[msg.sender] = balances[msg.sender].sub(_amount);&#13;
        balances[_to] = balances[_to].add(_amount);&#13;
        Transfer(msg.sender, _to, _amount);&#13;
        return true;&#13;
    }&#13;
&#13;
   /**&#13;
    *   @dev An account/contract attempts to get the coins&#13;
    *   throws on any error rather then return a false flag to minimize user errors&#13;
    *&#13;
    *   @param _from         source address&#13;
    *   @param _to           target address&#13;
    *   @param _amount       transfer amount&#13;
    *&#13;
    *   @return true if the transfer was successful&#13;
    */&#13;
    function transferFrom(address _from, address _to, uint256 _amount) public returns (bool) {&#13;
        require(!tokensAreFrozen);&#13;
        balances[_from] = balances[_from].sub(_amount);&#13;
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);&#13;
        balances[_to] = balances[_to].add(_amount);&#13;
        Transfer(_from, _to, _amount);&#13;
        return true;&#13;
     }&#13;
&#13;
&#13;
   /**&#13;
    *   @dev Allows another account/contract to spend some tokens on its behalf&#13;
    *   throws on any error rather then return a false flag to minimize user errors&#13;
    *&#13;
    *   also, to minimize the risk of the approve/transferFrom attack vector&#13;
    *   approve has to be called twice in 2 separate transactions - once to&#13;
    *   change the allowance to 0 and secondly to change it to the new allowance&#13;
    *   value&#13;
    *&#13;
    *   @param _spender      approved address&#13;
    *   @param _amount       allowance amount&#13;
    *&#13;
    *   @return true if the approval was successful&#13;
    */&#13;
    function approve(address _spender, uint256 _amount) public returns (bool) {&#13;
        require((_amount == 0) || (allowed[msg.sender][_spender] == 0));&#13;
        allowed[msg.sender][_spender] = _amount;&#13;
        Approval(msg.sender, _spender, _amount);&#13;
        return true;&#13;
    }&#13;
&#13;
   /**&#13;
    *   @dev Function to check the amount of tokens that an owner allowed to a spender.&#13;
    *&#13;
    *   @param _owner        the address which owns the funds&#13;
    *   @param _spender      the address which will spend the funds&#13;
    *&#13;
    *   @return              the amount of tokens still avaible for the spender&#13;
    */&#13;
    function allowance(address _owner, address _spender) constant returns (uint256) {&#13;
        return allowed[_owner][_spender];&#13;
    }&#13;
}&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
contract tokenLUCG {&#13;
    /* Public variables of the token */&#13;
        string public name;&#13;
        string public symbol;&#13;
        uint8 public decimals;&#13;
        uint256 public totalSupply = 0;&#13;
&#13;
&#13;
        function tokenLUCG (string _name, string _symbol, uint8 _decimals){&#13;
            name = _name;&#13;
            symbol = _symbol;&#13;
            decimals = _decimals;&#13;
&#13;
        }&#13;
    /* This creates an array with all balances */&#13;
        mapping (address =&gt; uint256) public balanceOf;&#13;
&#13;
}&#13;
&#13;
contract Presale is tokenLUCG {&#13;
&#13;
        using SafeMath for uint;&#13;
        string name = 'Level Up Coin Gold';&#13;
        string symbol = 'LUCG';&#13;
        uint8 decimals = 18;&#13;
        address manager;&#13;
        address public ico;&#13;
&#13;
        function Presale (address _manager) tokenLUCG (name, symbol, decimals){&#13;
             manager = _manager;&#13;
&#13;
        }&#13;
&#13;
        event Transfer(address _from, address _to, uint256 amount);&#13;
        event Burn(address _from, uint256 amount);&#13;
&#13;
        modifier onlyManager{&#13;
             require(msg.sender == manager);&#13;
            _;&#13;
        }&#13;
&#13;
        modifier onlyIco{&#13;
             require(msg.sender == ico);&#13;
            _;&#13;
        }&#13;
        function mintTokens(address _investor, uint256 _mintedAmount) public onlyManager {&#13;
             balanceOf[_investor] = balanceOf[_investor].add(_mintedAmount);&#13;
             totalSupply = totalSupply.add(_mintedAmount);&#13;
             Transfer(this, _investor, _mintedAmount);&#13;
&#13;
        }&#13;
&#13;
        function burnTokens(address _owner) public onlyIco{&#13;
             uint  tokens = balanceOf[_owner];&#13;
             require(balanceOf[_owner] != 0);&#13;
             balanceOf[_owner] = 0;&#13;
             totalSupply = totalSupply.sub(tokens);&#13;
             Burn(_owner, tokens);&#13;
        }&#13;
&#13;
        function setIco(address _ico) onlyManager{&#13;
            ico = _ico;&#13;
        }&#13;
}